[
  {
    "index": 14,
    "id": "theory_array_iteration",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 4,
    "title": "Array Iteration Methods",
    "description": "",
    "content": {
      "id": "theory_array_iteration",
      "title": "Array Iteration Methods",
      "description": "",
      "type": "theory",
      "content": "JavaScript provides several ways to iterate over array elements, each with its own use cases and benefits. Understanding these methods is crucial for efficient data processing.\n\n## `Array.prototype.forEach()`\n`forEach` executes a provided function once for each array element. It's a high-order array method, meaning it takes a callback function as an argument. The callback function can access the current `item`, its `index`, and the `array` itself.\n\n**Characteristics:**\n-   Does not return a new array (unlike `map`, `filter`).\n-   Does not modify the original array unless the callback explicitly does so.\n-   Cannot be stopped or broken out of using `break` or `return` (it iterates over all elements).\n-   It's generally preferred for simple iteration where you just need to perform an action on each element.\n\n## `for...of` Loop\nThe `for...of` loop iterates over iterable objects (like Arrays, Strings, Maps, Sets, etc.), allowing you to access the *values* of properties. It provides a more modern and concise way to loop through elements compared to traditional `for` loops when you only need the value.\n\n**Characteristics:**\n-   Iterates directly over values, not indices.\n-   Supports `break`, `continue`, and `return` to control loop flow.\n-   Works with any iterable object, making it versatile.\n-   Generally preferred for simple iteration where the index is not needed, or when working with other iterable collections.\n\n## Traditional `for` Loop for Reverse Iteration\nThe traditional `for` loop offers the most control over the iteration process, including the ability to iterate in reverse or skip elements. It's particularly useful when you need to iterate backwards through an array, which can be important for algorithms that modify the array in place or when processing elements from the end.\n\n**Characteristics:**\n-   Provides full control over iteration start, end, and step.\n-   Allows direct access to elements by index.\n-   Can be used for forward, reverse, or stepped iteration.\n-   Useful when modifying an array while iterating (e.g., removing elements from the end to avoid index issues).\n\n",
      "examples": [
        {
          "id": "example_array_iteration_forEach",
          "title": "Using forEach",
          "code": "const array = ['apple', 'banana', 'cherry'];\n\narray.forEach((item, index) => {\n  console.log(`Element at index ${index}: ${item}`);\n});\n// Expected Output:\n// Element at index 0: apple\n// Element at index 1: banana\n// Element at index 2: cherry",
          "explanation": "This example demonstrates how `forEach` iterates over each item in the `array`, providing both the `item` and its `index` to the callback function. It's a clean way to perform an action for every element.",
          "language": "javascript"
        },
        {
          "id": "example_array_iteration_forOf",
          "title": "Using for...of",
          "code": "const array = ['red', 'green', 'blue'];\n\nfor (const item of array) {\n  console.log(`Color: ${item}`);\n}\n// Expected Output:\n// Color: red\n// Color: green\n// Color: blue",
          "explanation": "The `for...of` loop directly provides the value of each element in `array` without needing to access it via an index. This is simpler and more readable when only the value is required.",
          "language": "javascript"
        },
        {
          "id": "example_array_iteration_reverseForLoop",
          "title": "Reverse Array Iteration with for loop",
          "code": "const array = [10, 20, 30, 40];\n\nfor (let i = array.length - 1; i >= 0; i--) {\n  console.log(`Element from end: ${array[i]}`);\n}\n// Expected Output:\n// Element from end: 40\n// Element from end: 30\n// Element from end: 20\n// Element from end: 10",
          "explanation": "This traditional `for` loop iterates from the last element (length - 1) down to the first (index 0). It's crucial for scenarios where processing elements from end to start is necessary, for instance, when removing items from an array to avoid shifting indices.",
          "language": "javascript"
        }
      ],
      "complexity": 4,
      "tags": [
        "Array Methods",
        "Iteration",
        "JavaScript Fundamentals",
        "ES6"
      ],
      "prerequisites": [
        "javascript_basics",
        "functions"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "Array Methods",
      "Iteration",
      "JavaScript Fundamentals",
      "ES6"
    ],
    "prerequisites": [
      "javascript_basics",
      "functions"
    ]
  },
  {
    "index": 153,
    "id": "theory_string_consecutive_char",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 4,
    "title": "String Manipulation: Finding the Most Consecutive Character",
    "description": "",
    "content": {
      "id": "theory_string_consecutive_char",
      "title": "String Manipulation: Finding the Most Consecutive Character",
      "description": "",
      "type": "theory",
      "content": "This theory block covers an algorithmic approach to find the character that appears most consecutively in a given string. This problem requires iterating through the string, keeping track of the current character and its consecutive count, and comparing it against the maximum count found so far.\n\n## Key Concepts\n-   **Iteration**: Processing each character of the string one by one.\n-   **State Management**: Maintaining `currentChar`, `currentCount`, `maxChar`, and `maxCount` variables to track the state of consecutive sequences.\n-   **Edge Cases**: Handling empty strings, strings with a single character, and ensuring the last sequence in the string is also checked.\n\n## Algorithm Steps\n1.  Initialize `maxChar` and `maxCount` to default values (e.g., empty string/first char and 0/1). For an empty string, handle it explicitly.\n2.  Initialize `currentChar` and `currentCount` for the current sequence being examined.\n3.  Iterate through the string from the second character (index 1).\n4.  If the current character is the same as the `currentChar`, increment `currentCount`.\n5.  If the current character is different, it means a sequence has ended:\n    a.  Compare `currentCount` with `maxCount`. If `currentCount` is greater, update `maxCount` and `maxChar`.\n    b.  Reset `currentChar` to the new character and `currentCount` to 1.\n6.  After the loop finishes, there might be a pending `currentCount` for the last sequence. Perform a final comparison of `currentCount` with `maxCount` to ensure the last sequence is considered.",
      "examples": [
        {
          "id": "example_string_consecutive_char_1",
          "title": "Basic Implementation of findMostConsecutiveChar",
          "code": "function findMostConsecutiveChar(str) {\n  if (!str || str.length === 0) {\n    return { char: '', count: 0 };\n  }\n\n  let maxChar = str[0];\n  let maxCount = 1;\n  let currentChar = str[0];\n  let currentCount = 1;\n\n  for (let i = 1; i < str.length; i++) {\n    if (str[i] === currentChar) {\n      currentCount++;\n    } else {\n      if (currentCount > maxCount) {\n        maxCount = currentCount;\n        maxChar = currentChar;\n      }\n      currentChar = str[i];\n      currentCount = 1;\n    }\n  }\n  \n  // Check for the last character sequence\n  if (currentCount > maxCount) {\n    maxCount = currentCount;\n    maxChar = currentChar;\n  }\n  \n  return { char: maxChar, count: maxCount };\n}\n\n// Example Usage:\nconst str1 = 'bbbaaaaccadd';\nconst result1 = findMostConsecutiveChar(str1);\nconsole.log(result1); // Expected: { char: 'a', count: 4 }\n\nconst str2 = 'aabbbcccc';\nconst result2 = findMostConsecutiveChar(str2);\nconsole.log(result2); // Expected: { char: 'c', count: 4 }\n\nconst str3 = 'a';\nconst result3 = findMostConsecutiveChar(str3);\nconsole.log(result3); // Expected: { char: 'a', count: 1 }",
          "explanation": "This example provides the complete JavaScript function `findMostConsecutiveChar`. It initializes `maxChar` and `maxCount` with the first character's details. It then iterates through the string, comparing each character to the `currentChar`. If they match, `currentCount` increments. If they differ, it means a sequence has ended, so it checks if `currentCount` is a new maximum, updates `maxCount` and `maxChar` if necessary, and then resets `currentChar` and `currentCount` for the new sequence. A crucial final check outside the loop handles the case where the longest consecutive sequence occurs at the very end of the string.",
          "language": "javascript"
        }
      ],
      "complexity": 4,
      "tags": [
        "string-manipulation",
        "algorithms",
        "iteration",
        "data-processing"
      ],
      "prerequisites": [
        "basic-javascript",
        "loops",
        "conditional-statements"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "string-manipulation",
      "algorithms",
      "iteration",
      "data-processing"
    ],
    "prerequisites": [
      "basic-javascript",
      "loops",
      "conditional-statements"
    ]
  },
  {
    "index": 6,
    "id": "theory_iife",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 5,
    "title": "Immediately Invoked Function Expressions (IIFE)",
    "description": "",
    "content": {
      "id": "theory_iife",
      "title": "Immediately Invoked Function Expressions (IIFE)",
      "description": "",
      "type": "theory",
      "content": "An Immediately Invoked Function Expression (IIFE, pronounced \"iffy\") is a JavaScript design pattern that executes a function as soon as it is defined. It consists of two main parts:\n\n1.  **The Function Expression**: An anonymous function (or named, though less common) wrapped in parentheses `(function() { ... })`. This makes it a function expression rather than a function declaration.\n2.  **The Invocation**: The `()` at the end immediately calls the function `(function() { ... })()`. Alternatively, you can place the parentheses inside `(function() { ... }())`.\n\n### Purpose and Benefits\n\n*   **Scope Encapsulation / Data Privacy**: Variables and functions declared inside an IIFE are not accessible from the global scope, preventing them from polluting the global namespace. This helps in avoiding naming collisions, especially in applications with multiple scripts or third-party libraries.\n*   **Creating Private Variables and Closures**: IIFEs can be used to create private variables and methods that are only accessible within the IIFE's scope, similar to private members in object-oriented languages. This is often achieved in conjunction with closures.\n*   **Module Pattern**: IIFEs are fundamental to the module pattern in JavaScript, allowing you to return an object containing public methods while keeping other variables and functions private.\n*   **Aliasing Global Variables**: You can pass global objects (like `window` or `jQuery`) as arguments to an IIFE, aliasing them to shorter, more manageable names within the IIFE's scope, which can also help performance by avoiding repeated scope lookups for global variables.",
      "examples": [
        {
          "id": "example_iife_1",
          "title": "Basic IIFE for Scope Encapsulation",
          "code": "(function() {\n  const privateVar = 'This is private';\n  console.log(privateVar); // Accessible inside\n})();\n\n// console.log(privateVar); // ReferenceError: privateVar is not defined",
          "explanation": "This example shows the basic structure of an IIFE. The `privateVar` is contained within the IIFE's scope and cannot be accessed from outside, demonstrating global scope protection.",
          "language": "javascript"
        },
        {
          "id": "example_iife_2",
          "title": "IIFE with Parameters",
          "code": "(function(name) {\n  console.log(`Hello, ${name}!`);\n})('John');",
          "explanation": "This IIFE takes a parameter `name`. The value `'John'` is passed immediately upon invocation. This is useful for passing global variables or dependencies into the IIFE's private scope.",
          "language": "javascript"
        },
        {
          "id": "example_iife_3",
          "title": "IIFE as a Module Pattern",
          "code": "const counterModule = (function() {\n  let count = 0; // Private variable\n\n  function increment() {\n    count++;\n  }\n\n  function getCount() {\n    return count;\n  }\n\n  return {\n    increment: increment,\n    getCount: getCount\n  };\n})();\n\ncounterModule.increment();\nconsole.log(counterModule.getCount()); // 1\ncounterModule.increment();\nconsole.log(counterModule.getCount()); // 2\n// console.log(counterModule.count); // undefined (private)",
          "explanation": "This example demonstrates how an IIFE can be used to implement the Module Pattern, creating a private `count` variable and exposing only `increment` and `getCount` methods, providing encapsulation.",
          "language": "javascript"
        }
      ],
      "complexity": 5,
      "tags": [
        "JavaScript",
        "Functions",
        "Scope",
        "IIFE",
        "Closures",
        "Module Pattern"
      ],
      "prerequisites": [
        "javascript_functions",
        "javascript_scope",
        "javascript_closures"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "JavaScript",
      "Functions",
      "Scope",
      "IIFE",
      "Closures",
      "Module Pattern"
    ],
    "prerequisites": [
      "javascript_functions",
      "javascript_scope",
      "javascript_closures"
    ]
  },
  {
    "index": 12,
    "id": "theory_array_modification_methods",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 5,
    "title": "Array Modification Methods: Adding and Removing Elements",
    "description": "",
    "content": {
      "id": "theory_array_modification_methods",
      "title": "Array Modification Methods: Adding and Removing Elements",
      "description": "",
      "type": "theory",
      "content": "This section covers fundamental JavaScript array methods used for adding and removing elements. These methods allow for manipulation of array contents at the beginning, end, or specific positions.\n\n## Key Concepts\n- **`push(...items)`**: Adds one or more elements to the end of an array and returns the new length of the array. It modifies the original array.\n- **`pop()`**: Removes the last element from an array and returns that element. If the array is empty, it returns `undefined`. It modifies the original array.\n- **`shift()`**: Removes the first element from an array and returns that element. If the array is empty, it returns `undefined`. It modifies the original array.\n- **`unshift(...items)`**: Adds one or more elements to the beginning of an array and returns the new length of the array. It modifies the original array.\n- **`splice(pos, deleteCount, ...items)`**: A highly versatile method that changes the contents of an array by removing existing elements and/or adding new elements. It modifies the original array.\n  - `pos`: The index at which to start changing the array.\n  - `deleteCount`: An integer indicating the number of elements to remove from `pos`.\n  - `...items`: The elements to add to the array, starting at `pos`.\n  - Returns an array containing the deleted elements.\n- **`slice(start, end)`**: Returns a shallow copy of a portion of an array into a new array object selected from `start` to `end` (end not included). The original array will not be modified.\n  - `start`: Zero-based index at which to begin extraction. If negative, it specifies an offset from the end of the sequence.\n  - `end`: Zero-based index before which to end extraction. `slice` extracts up to (but not including) `end`. If `end` is omitted, `slice` extracts to the end of the sequence.\n- **`concat(...items)`**: Used to merge two or more arrays. This method does not change the existing arrays, but instead returns a new array. It can take an arbitrary number of array arguments or non-array values.",
      "examples": [
        {
          "id": "example_array_modification_1",
          "title": "Basic Push, Pop, Shift, Unshift Operations",
          "code": "const animals = ['cat', 'dog'];\n\n// push(): Adds to the end, returns new length\nconst newLengthPush = animals.push('elephant'); // animals is now ['cat', 'dog', 'elephant'], newLengthPush is 3\nconsole.log('After push:', animals, 'Length:', newLengthPush);\n\n// pop(): Removes from the end, returns removed element\nconst removedPop = animals.pop(); // animals is now ['cat', 'dog'], removedPop is 'elephant'\nconsole.log('After pop:', animals, 'Removed:', removedPop);\n\n// unshift(): Adds to the beginning, returns new length\nconst newLengthUnshift = animals.unshift('horse'); // animals is now ['horse', 'cat', 'dog'], newLengthUnshift is 3\nconsole.log('After unshift:', animals, 'Length:', newLengthUnshift);\n\n// shift(): Removes from the beginning, returns removed element\nconst removedShift = animals.shift(); // animals is now ['cat', 'dog'], removedShift is 'horse'\nconsole.log('After shift:', animals, 'Removed:', removedShift);",
          "explanation": "This example demonstrates the basic usage of `push`, `pop`, `unshift`, and `shift`. Note how these methods directly modify the `animals` array in place and return either the new length or the removed element.",
          "language": "typescript"
        },
        {
          "id": "example_array_modification_2",
          "title": "Splice, Slice, and Concat Operations",
          "code": "const animals = ['cat', 'dog', 'elephant', 'fox'];\n\n// splice() examples:\n// 1. Insert without removing: add 'bird' at index 1\nconst noRemovedSplice = animals.splice(1, 0, 'bird'); // animals is ['cat', 'bird', 'dog', 'elephant', 'fox'], noRemovedSplice is []\nconsole.log('Splice (insert only):', animals, 'Removed:', noRemovedSplice);\n\n// 2. Remove without inserting: remove 2 elements starting at index 2\nconst removedSplice = animals.splice(2, 2); // animals is ['cat', 'bird', 'fox'], removedSplice is ['dog', 'elephant']\nconsole.log('Splice (remove only):', animals, 'Removed:', removedSplice);\n\n// 3. Insert and remove simultaneously (replace): replace 1 element at index 0\nconst replacedSplice = animals.splice(0, 1, 'lion', 'tiger'); // animals is ['lion', 'tiger', 'bird', 'fox'], replacedSplice is ['cat']\nconsole.log('Splice (replace):', animals, 'Removed:', replacedSplice);\n\nconst originalNumbers = [10, 20, 30, 40, 50];\n\n// slice() example: creates a new array\nconst slicedNumbers = originalNumbers.slice(1, 4); // slicedNumbers is [20, 30, 40]\nconsole.log('Original after slice:', originalNumbers); // [10, 20, 30, 40, 50] - remains unchanged\nconsole.log('Sliced array:', slicedNumbers);\n\nconst arr1 = [1, 2];\nconst arr2 = [3, 4];\nconst arr3 = [5, 6];\n\n// concat() example: creates a new array\nconst combinedArray = arr1.concat(arr2, arr3, 7, 8); // [1, 2, 3, 4, 5, 6, 7, 8]\nconsole.log('Combined array:', combinedArray);\nconsole.log('Original arr1 after concat:', arr1); // [1, 2] - remains unchanged",
          "explanation": "This example showcases `splice`'s flexibility for insertion, deletion, and replacement, all of which modify the original array. It also demonstrates `slice` creating a new array without affecting the original and `concat` merging arrays into a new one.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "Array Methods",
        "Mutation",
        "Non-Mutation",
        "Data Manipulation",
        "JavaScript Basics"
      ],
      "prerequisites": [
        "javascript_arrays",
        "javascript_functions"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "Array Methods",
      "Mutation",
      "Non-Mutation",
      "Data Manipulation",
      "JavaScript Basics"
    ],
    "prerequisites": [
      "javascript_arrays",
      "javascript_functions"
    ]
  },
  {
    "index": 18,
    "id": "theory_event_propagation",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 5,
    "title": "Event Propagation: Capturing and Bubbling",
    "description": "",
    "content": {
      "id": "theory_event_propagation",
      "title": "Event Propagation: Capturing and Bubbling",
      "description": "",
      "type": "theory",
      "content": "Event propagation is the order in which event listeners are triggered when an event occurs on an element. It involves two phases:\n\n### 1. Capturing Phase\nThis phase starts from the `Window` object, goes down through the DOM tree, visiting all ancestors of the target element, until it reaches the target itself. During this phase, listeners registered with `useCapture: true` (or `true` as the third argument in `addEventListener`) are triggered.\n\n### 2. Bubbling Phase\nThis phase starts from the target element itself and bubbles up through the DOM tree, visiting all ancestors, up to the `Window` object. Most event listeners are registered to run in this phase by default (i.e., `useCapture: false` or omitting the third argument in `addEventListener`).\n\n### Order of Event Firing\nWhen a click event, for instance, occurs on a child element, the sequence of event listener execution is:\n1.  **Parent (capturing phase)**\n2.  **Child (capturing phase)**\n3.  **Child (bubbling phase)**\n4.  **Parent (bubbling phase)**\n\nThis ordered execution allows for fine-grained control over how events are handled at different levels of the DOM tree.",
      "examples": [
        {
          "id": "example_event_propagation_1",
          "title": "Basic Event Propagation Example",
          "code": "<html>\n<head>\n  <title>Event Propagation</title>\n</head>\n<body>\n  <div id=\"parent\" style=\"padding: 20px; background-color: lightblue;\">\n    Parent\n    <button id=\"child\" style=\"padding: 10px; background-color: lightcoral;\">\n      Child Button\n    </button>\n  </div>\n\n  <script>\n    const parent = document.getElementById('parent');\n    const child = document.getElementById('child');\n\n    parent.addEventListener('click', function(e) {\n      console.log('Parent - Capturing Phase (default: bubbling phase, but showing conceptual order)');\n    }, true); // True for capturing\n\n    child.addEventListener('click', function(e) {\n      console.log('Child - Capturing Phase (default: bubbling phase, but showing conceptual order)');\n    }, true); // True for capturing\n\n    child.addEventListener('click', function(e) {\n      console.log('Child - Bubbling Phase');\n    }, false); // False for bubbling (default)\n\n    parent.addEventListener('click', function(e) {\n      console.log('Parent - Bubbling Phase');\n    }, false); // False for bubbling (default)\n  </script>\n</body>\n</html>",
          "explanation": "This HTML and JavaScript demonstrates the order of event propagation. When the 'Child Button' is clicked, the console logs will show the event traversing down the DOM in the capturing phase and then bubbling up in the bubbling phase, hitting the child's bubbling listener, and finally the parent's bubbling listener. Note that 'Child - Capturing Phase' will log before 'Child - Bubbling Phase' if you have both.",
          "language": "html"
        }
      ],
      "complexity": 5,
      "tags": [
        "DOM",
        "Events",
        "Event Handling",
        "JavaScript Fundamentals"
      ],
      "prerequisites": [
        "dom_manipulation",
        "event_listeners"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "DOM",
      "Events",
      "Event Handling",
      "JavaScript Fundamentals"
    ],
    "prerequisites": [
      "dom_manipulation",
      "event_listeners"
    ]
  },
  {
    "index": 21,
    "id": "theory_es6_classes",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 5,
    "title": "ES6 Classes: Syntax and Basic Usage",
    "description": "",
    "content": {
      "id": "theory_es6_classes",
      "title": "ES6 Classes: Syntax and Basic Usage",
      "description": "",
      "type": "theory",
      "content": "ES6 Classes provide a syntactic sugar over JavaScript's existing prototype-based inheritance. They offer a cleaner and more structured way to create objects and handle inheritance compared to traditional constructor functions and prototype chains, making code more readable and maintainable, especially for developers familiar with class-based languages. However, it's crucial to understand that under the hood, ES6 classes still operate on the prototypal inheritance model.\n\n## Key Concepts\n\n*   **`class` Keyword**: Used to declare a class. Class declarations are not hoisted, unlike function declarations.\n*   **`constructor` Method**: A special method for creating and initializing an object created with a class. There can only be one special method with the name \"constructor\" in a class. If you don't specify a constructor method, a default empty one is used.\n*   **Instance Properties**: Properties assigned within the `constructor` using `this` become instance-specific properties.\n*   **Methods**: Functions defined directly within the class body (outside the constructor) become methods on the class's prototype, meaning they are shared by all instances of the class, saving memory and allowing for method inheritance.\n*   **Instantiation**: Classes are instantiated using the `new` keyword, which calls the `constructor` method.\n\n## Class Declaration Syntax\n```javascript\nclass ClassName {\n  constructor(param1, param2) {\n    this.param1 = param1;\n    this.param2 = param2;\n  }\n\n  methodName() {\n    // Class method logic\n  }\n}\n```\n\n## Class Expression Syntax\nClasses can also be defined using expressions, which can be named or unnamed. A named class expression's name is only visible within the class scope.\n\n```javascript\n// Unnamed class expression\nconst MyClass = class {\n  constructor(name) {\n    this.name = name;\n  }\n};\n\n// Named class expression\nconst AnotherClass = class NamedClass {\n  constructor(value) {\n    this.value = value;\n  }\n  getName() {\n    // NamedClass is accessible here\n    return NamedClass.name; \n  }\n};\n```",
      "examples": [
        {
          "id": "example_es6_classes_1",
          "title": "Basic Class Definition and Instantiation",
          "code": "class PersonClass {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n  \n  getFullName() {\n    return this.firstName + ' ' + this.lastName;\n  }\n}\n\nconst alice = new PersonClass('Alice', 'Johnson');\nconsole.log(alice.getFullName()); // Alice Johnson\nconsole.log(alice.firstName);     // Alice\n",
          "explanation": "This example demonstrates a basic `PersonClass` with a constructor to initialize `firstName` and `lastName`, and a `getFullName` method. An instance `alice` is created using `new`, and its method is called.",
          "language": "javascript"
        },
        {
          "id": "example_es6_classes_2",
          "title": "Understanding Class Methods and Prototype",
          "code": "class Car {\n  constructor(make, model) {\n    this.make = make;\n    this.model = model;\n  }\n  \n  getDetails() {\n    return `${this.make} ${this.model}`;\n  }\n}\n\nconst myCar = new Car('Toyota', 'Camry');\nconst otherCar = new Car('Honda', 'Civic');\n\n// getDetails is a method on the prototype, shared by all instances\nconsole.log(myCar.getDetails === otherCar.getDetails); // true\nconsole.log(myCar.hasOwnProperty('getDetails')); // false (it's on prototype)\n",
          "explanation": "This example illustrates that methods defined within a class body (like `getDetails`) are added to the class's prototype (`Car.prototype`), not directly to each instance. This allows all instances to share the same method, promoting memory efficiency. Instance-specific properties (like `make`, `model`) are defined in the constructor using `this`.",
          "language": "javascript"
        }
      ],
      "complexity": 5,
      "tags": [
        "ES6",
        "Classes",
        "OOP",
        "JavaScript",
        "Frontend"
      ],
      "prerequisites": [
        "javascript_functions",
        "this_keyword"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "ES6",
      "Classes",
      "OOP",
      "JavaScript",
      "Frontend"
    ],
    "prerequisites": [
      "javascript_functions",
      "this_keyword"
    ]
  },
  {
    "index": 22,
    "id": "theory_object_getters_setters",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 5,
    "title": "Object Getters and Setters",
    "description": "",
    "content": {
      "id": "theory_object_getters_setters",
      "title": "Object Getters and Setters",
      "description": "",
      "type": "theory",
      "content": "Getters and setters are special methods defined on objects that provide controlled access to an object's properties. They allow you to define what happens when a property is accessed (getter) or modified (setter).\n\n### Getters (Accessors)\n\nA getter method is executed when you attempt to retrieve the value of a property. It's defined using the `get` keyword before the property name. Getters are useful for:\n\n*   Returning computed values based on other properties.\n*   Formatting data before it's returned.\n*   Adding side effects (though generally not recommended for pure getters).\n\n### Setters (Mutators)\n\nA setter method is executed when you attempt to assign a value to a property. It's defined using the `set` keyword before the property name. Setters are useful for:\n\n*   Validation of input data before assignment.\n*   Transforming data before it's stored.\n*   Updating other properties or triggering side effects when a property changes.\n\n### Syntax\n\nGetters and setters are defined within object literal definitions or class declarations.",
      "examples": [
        {
          "id": "example_getters_setters_1",
          "title": "Basic Getter and Setter Example",
          "code": "const person = {\n  firstName: 'John',\n  lastName: 'Doe',\n\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  },\n\n  set fullName(value) {\n    // The original markdown snippet starts here\n    [this.firstName, this.lastName] = value.split(' ');\n  }\n};\n\nconsole.log(person.fullName); // John Doe\nperson.fullName = 'Jane Smith';\nconsole.log(person.firstName); // Jane\nconsole.log(person.lastName);  // Smith\nconsole.log(person.fullName);  // Jane Smith",
          "explanation": "This example demonstrates a `fullName` property that is accessed via a getter and modified via a setter. When `person.fullName` is read, the `get fullName()` method concatenates `firstName` and `lastName`. When `person.fullName` is assigned a new string, the `set fullName(value)` method splits the string by space and assigns the parts to `firstName` and `lastName` respectively, showcasing how setters can deconstruct and update underlying properties.",
          "language": "javascript"
        }
      ],
      "complexity": 5,
      "tags": [
        "objects",
        "properties",
        "getters",
        "setters",
        "javascript_basics"
      ],
      "prerequisites": [
        "javascript_objects",
        "functions"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "objects",
      "properties",
      "getters",
      "setters",
      "javascript_basics"
    ],
    "prerequisites": [
      "javascript_objects",
      "functions"
    ]
  },
  {
    "index": 24,
    "id": "theory_pure_functions_and_side_effects",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 5,
    "title": "Pure Functions and Side Effects",
    "description": "",
    "content": {
      "id": "theory_pure_functions_and_side_effects",
      "title": "Pure Functions and Side Effects",
      "description": "",
      "type": "theory",
      "content": "## Core Principles of Pure Functions\nPure functions are a fundamental concept in functional programming, offering significant benefits in terms of predictability, testability, and maintainability. A function is considered pure if it adheres to two strict rules:\n\n1.  **Determinism (Same Input, Same Output):** Given the same input arguments, a pure function will *always* produce the exact same output. It does not depend on any external state that might change between calls.\n2.  **No Side Effects:** A pure function does not cause any observable changes outside its local scope during its execution. This means it doesn't modify external variables, mutate data structures passed as arguments, perform I/O operations (like logging to console, network requests, or DOM manipulations), or trigger any other external state changes.\n\n### Understanding Side Effects\nSide effects are any actions a function performs that affect the world outside of itself. While necessary for real-world applications (e.g., displaying data, saving to a database), minimizing and isolating side effects is a key goal of functional programming. Examples of side effects include:\n*   Modifying a global variable or an object passed by reference.\n*   Logging to the console (`console.log`).\n*   Making network requests (e.g., `fetch`, `XMLHttpRequest`).\n*   Modifying the DOM.\n*   Writing to a database or file system.\n*   Throwing exceptions (if not handled internally).\n*   Getting the current time or a random number (as they are not deterministic).\n\n### Benefits of Pure Functions\n*   **Predictability:** Easier to reason about and understand, as their behavior is entirely determined by their inputs.\n*   **Testability:** Simple to test because they only require input arguments and produce predictable output. No complex setup or mocking of external states is needed.\n*   **Maintainability:** Less prone to bugs caused by unexpected interactions or hidden dependencies.\n*   **Cacheability (Memoization):** Their deterministic nature allows for caching results based on input, leading to performance optimizations.\n*   **Parallelization:** Can be run in parallel without fear of race conditions, as they don't share or modify mutable state.",
      "examples": [
        {
          "id": "example_pure_function_1",
          "title": "Pure Function Example",
          "code": "/**\n * A pure function that adds two numbers.\n * - Always returns the same result for the same inputs (e.g., add(2, 3) always returns 5).\n * - Has no side effects (doesn't modify external state or perform I/O).\n */\nfunction add(a, b) {\n  return a + b;\n}",
          "explanation": "This `add` function takes two numbers, `a` and `b`, and returns their sum. It's pure because it always produces the same output for the same inputs and doesn't modify anything outside its scope. It's perfectly predictable and easy to test.",
          "language": "javascript"
        },
        {
          "id": "example_impure_function_1",
          "title": "Impure Function Example (Relies on External State)",
          "code": "let c = 10;\n/**\n * An impure function that adds a number to an external variable 'c'.\n * - Its output depends on the external state of 'c', which can change.\n * - Modifies an external variable 'c' if it were to increment 'c' inside.\n */\nfunction addToC(x) {\n  return x + c; // Depends on external variable 'c'\n}\n\n// Demonstrating impurity:\nconsole.log(addToC(5)); // If c is 10, returns 15\nc = 20;\nconsole.log(addToC(5)); // If c is 20, returns 25 (different output for same input '5')",
          "explanation": "The `addToC` function is impure because its output depends on the external variable `c`. If `c` changes, the function's output will change even with the same input `x`. This violates the 'same input, same output' rule. If it were to modify `c` (e.g., `c += x;`), it would also have a side effect.",
          "language": "javascript"
        },
        {
          "id": "example_pure_function_closure_1",
          "title": "Creating a Pure Function using Closure (Currying Concept)",
          "code": "/**\n * A higher-order function that uses a closure to create a pure adder.\n * The returned inner function is pure because it only depends on its immediate inputs\n * and the 'a' value captured from its lexical environment, which remains constant.\n */\nfunction createPureAdder(a) {\n  // 'a' is captured in the closure. It acts as a fixed part of the inner function's context.\n  return function(b) {\n    return a + b; // 'a' is from the closure, 'b' is the explicit argument\n  };\n}\n\nconst add5 = createPureAdder(5);\nconsole.log(add5(10)); // Always returns 15 given input 10 (5 + 10)\nconsole.log(add5(20)); // Always returns 25 given input 20 (5 + 20)\n\nconst add10 = createPureAdder(10);\nconsole.log(add10(3)); // Always returns 13 given input 3 (10 + 3)",
          "explanation": "This example demonstrates how a closure can be used to create a pure function. `createPureAdder(a)` returns an inner function that 'remembers' the value of `a`. The inner function `(b) => a + b` is pure because for any given `b`, it will always produce the same result (since `a` is fixed by the closure), and it has no side effects. This pattern is related to currying, a functional programming technique.",
          "language": "javascript"
        }
      ],
      "complexity": 5,
      "tags": [
        "functional-programming",
        "pure-functions",
        "side-effects",
        "predictability",
        "testability",
        "javascript"
      ],
      "prerequisites": [
        "basic-functions",
        "scope",
        "closures"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "functional-programming",
      "pure-functions",
      "side-effects",
      "predictability",
      "testability",
      "javascript"
    ],
    "prerequisites": [
      "basic-functions",
      "scope",
      "closures"
    ]
  },
  {
    "index": 88,
    "id": "theory_redux_actions",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 5,
    "title": "Redux Actions and Action Creators",
    "description": "",
    "content": {
      "id": "theory_redux_actions",
      "title": "Redux Actions and Action Creators",
      "description": "",
      "type": "theory",
      "content": "Actions are the sole source of information for the Redux store. They are plain JavaScript objects that serve as payloads of information, sending data from your application to your store. Every action must have a `type` property, which indicates the type of action being performed. This type is typically defined as a string constant to avoid typos and enable easier debugging.\n\nAction Creators are functions that create and return action objects. They encapsulate the logic for constructing an action, making it reusable and easier to dispatch consistently throughout the application. While actions are just plain objects, action creators are functions that produce these objects. They can take arguments to populate the action's payload, such as a todo's text or an item's ID.\n\n## Key Concepts\n-   **Actions**: Plain JavaScript objects with a `type` property. They describe *what happened* in the application.\n-   **Action Creators**: Functions that return action objects. They help standardize action creation and prevent errors.\n-   **`type` property**: A string constant indicating the action's intent (e.g., 'ADD_TODO', 'USER_LOGGED_IN').\n-   **Payload**: Any additional data sent with the action (e.g., `id`, `text`, `completed` for a todo).\n\n## Structure of an Action\nAn action minimally contains a `type` field. It's a common practice to define action types as constants to prevent errors and improve code clarity.\n\n```javascript\n// Action Types\nconst ADD_TODO = 'ADD_TODO';\nconst TOGGLE_TODO = 'TOGGLE_TODO';\nconst SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER';\n```\n\n## Purpose\nActions are dispatched to the Redux store, which then forwards them to reducers. Reducers interpret these actions to decide how to update the application's state. This unidirectional data flow is a core principle of Redux.",
      "examples": [
        {
          "id": "example_action_creator_1",
          "title": "Basic Action Creators",
          "code": "const ADD_TODO = 'ADD_TODO';\nconst TOGGLE_TODO = 'TOGGLE_TODO';\nconst SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER';\n\nlet nextTodoId = 0;\n\nfunction addTodo(text) {\n  return {\n    type: ADD_TODO,\n    id: nextTodoId++,\n    text\n  };\n}\n\nfunction toggleTodo(id) {\n  return {\n    type: TOGGLE_TODO,\n    id\n  };\n}\n\nfunction setVisibilityFilter(filter) {\n  return {\n    type: SET_VISIBILITY_FILTER,\n    filter\n  };\n}\n\n// Example Usage:\nconst newTodoAction = addTodo('Learn Redux');\nconsole.log(newTodoAction); // { type: 'ADD_TODO', id: 0, text: 'Learn Redux' }\n\nconst toggleAction = toggleTodo(0);\nconsole.log(toggleAction); // { type: 'TOGGLE_TODO', id: 0 }\n",
          "explanation": "This example demonstrates how action types are defined as constants and how action creators (`addTodo`, `toggleTodo`, `setVisibilityFilter`) are implemented. Each function takes relevant data as arguments and returns a plain action object with a `type` and a payload. The `id` for `addTodo` is incremented to simulate unique IDs, a common pattern in applications.",
          "language": "javascript"
        }
      ],
      "complexity": 5,
      "tags": [
        "Redux",
        "Actions",
        "Action Creators",
        "State Management",
        "Frontend Architecture"
      ],
      "prerequisites": [
        "JavaScript_Objects",
        "JavaScript_Functions"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "Redux",
      "Actions",
      "Action Creators",
      "State Management",
      "Frontend Architecture"
    ],
    "prerequisites": [
      "JavaScript_Objects",
      "JavaScript_Functions"
    ]
  },
  {
    "index": 97,
    "id": "theory_immutable_basics",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 5,
    "title": "Immutable.js Fundamentals in Redux",
    "description": "",
    "content": {
      "id": "theory_immutable_basics",
      "title": "Immutable.js Fundamentals in Redux",
      "description": "",
      "type": "theory",
      "content": "Immutable.js is a library that provides persistent (immutable) data structures. When integrated with Redux, it helps enforce the principle of immutability, ensuring that the state tree is never directly modified. Instead, any operation that changes the state returns a new immutable state object.\n\n## Key Concepts\n*   **`fromJS(object)`**: Converts a plain JavaScript object or array into an Immutable.js Map or List, respectively. This is crucial for initializing your Redux state with immutable structures.\n*   **`state.set(key, value)`**: Used to update a top-level property of an Immutable Map. It returns a new Immutable Map with the specified key's value updated, leaving the original state unchanged.\n*   **Immutability Principle**: In Redux, state updates must be immutable. This means you should never directly modify the `state` object or its properties. Immutable.js facilitates this by providing methods that return new instances with changes, rather than mutating the original.\n\n## Why use Immutable.js with Redux?\n*   **Predictable State**: By ensuring state cannot be mutated directly, it prevents bugs caused by unintended side effects from different parts of your application modifying the same state reference.\n*   **Easier Debugging**: Each state update creates a new object, making it straightforward to track state changes over time, which is invaluable for Redux DevTools' time-travel debugging.\n*   **Performance Benefits**: Immutable data structures allow for efficient shallow equality checks, which can optimize `shouldComponentUpdate` in React components, preventing unnecessary re-renders.",
      "examples": [
        {
          "id": "example_immutable_basics_1",
          "title": "Initializing State and Basic Set Operation",
          "code": "import { fromJS } from 'immutable';\n\nconst initialState = fromJS({\n  user: null,\n  isLoading: false,\n  error: null\n});\n\nfunction userReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'SET_USER':\n      // Converts action.payload to Immutable.Map before setting\n      return state.set('user', fromJS(action.payload));\n    case 'CLEAR_USER':\n      // Sets user to null\n      return state.set('user', null);\n    case 'SET_LOADING':\n      // Sets isLoading to a boolean payload\n      return state.set('isLoading', action.payload);\n    case 'SET_ERROR':\n      // Sets error to a payload value\n      return state.set('error', action.payload);\n    default:\n      return state;\n  }\n}",
          "explanation": "This example demonstrates how `fromJS` is used to create the initial immutable state. The `userReducer` then uses the `set` method to update top-level properties. Notice how `SET_USER` action also uses `fromJS(action.payload)` to ensure that if `action.payload` is an object, it also becomes an immutable structure, maintaining immutability throughout the nested state.",
          "language": "javascript"
        }
      ],
      "complexity": 5,
      "tags": [
        "Immutable.js",
        "Redux",
        "State Management",
        "Immutability",
        "fromJS",
        "set"
      ],
      "prerequisites": [
        "Redux_Core_Concepts",
        "JavaScript_ES6_Spread_Syntax"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "Immutable.js",
      "Redux",
      "State Management",
      "Immutability",
      "fromJS",
      "set"
    ],
    "prerequisites": [
      "Redux_Core_Concepts",
      "JavaScript_ES6_Spread_Syntax"
    ]
  },
  {
    "index": 108,
    "id": "theory_web_storage_event_listener",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 5,
    "title": "Web Storage: The 'storage' Event Listener",
    "description": "",
    "content": {
      "id": "theory_web_storage_event_listener",
      "title": "Web Storage: The 'storage' Event Listener",
      "description": "",
      "type": "theory",
      "content": "The `storage` event in web browsers allows different browser windows or tabs from the same origin to react to changes made in `localStorage` or `sessionStorage` by another window/tab. This event is *only* triggered when a storage item is changed, added, or removed by *another* window/tab from the same origin. It does not fire for changes made within the same window that initiated the change. It's a powerful mechanism for synchronizing state across multiple browser contexts.\n\n## Event Properties\nWhen the `storage` event fires, the event object provides several useful properties:\n- `key`: The key of the storage item that was changed.\n- `oldValue`: The old value of the key, or `null` if the key was newly added.\n- `newValue`: The new value of the key, or `null` if the key was removed.\n- `url`: The URL of the document whose storage changed.\n- `storageArea`: The `Storage` object (`localStorage` or `sessionStorage`) that was affected.\n\nThis event is crucial for building real-time collaboration features or ensuring data consistency across multiple open tabs of a web application without needing server-side communication.",
      "examples": [
        {
          "id": "example_storage_event_1",
          "title": "Listening for localStorage Changes",
          "code": "// Listen for changes to localStorage from other windows/tabs\nwindow.addEventListener('storage', (event) => {\n  console.log('Storage changed:');\n  console.log('  Key:', event.key);\n  console.log('  Old Value:', event.oldValue);\n  console.log('  New Value:', event.newValue);\n  console.log('  Source URL:', event.url);\n  console.log('  Storage Area:', event.storageArea === localStorage ? 'localStorage' : 'sessionStorage');\n\n  if (event.key === 'theme' && event.newValue) {\n    document.documentElement.setAttribute('data-theme', event.newValue);\n    console.log(`Theme updated to: ${event.newValue}`);\n  }\n});\n\n// To simulate a change from another tab, open this page in two tabs\n// and in one tab's console, run:\n// localStorage.setItem('theme', 'dark');\n// localStorage.removeItem('theme');",
          "explanation": "This example demonstrates how to set up a `storage` event listener. When a change occurs in `localStorage` or `sessionStorage` from another browser tab/window of the same origin, this callback will execute, logging the details of the change. A practical application is shown where a 'theme' change propagates across tabs.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "web-storage",
        "browser-api",
        "event-listener",
        "frontend",
        "synchronization"
      ],
      "prerequisites": [
        "web_storage_basics",
        "event_listeners"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "web-storage",
      "browser-api",
      "event-listener",
      "frontend",
      "synchronization"
    ],
    "prerequisites": [
      "web_storage_basics",
      "event_listeners"
    ]
  },
  {
    "index": 113,
    "id": "theory_canvas_fundamentals",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 5,
    "title": "HTML Canvas API Fundamentals",
    "description": "",
    "content": {
      "id": "theory_canvas_fundamentals",
      "title": "HTML Canvas API Fundamentals",
      "description": "",
      "type": "theory",
      "content": "The HTML Canvas API provides a powerful means for drawing graphics dynamically using JavaScript and the `<canvas>` element. It's a pixel-based drawing surface, ideal for creating a wide variety of visual content such as graphs, game graphics, custom art, and interactive visualizations.\n\n## Basic Setup and Context\nTo start drawing, you first need an HTML `<canvas>` element on your page. You then obtain its 2D rendering context using `getContext('2d')` in JavaScript.\n\n```html\n<!-- Basic canvas element -->\n<canvas id=\"myCanvas\" width=\"500\" height=\"300\"></canvas>\n```\n\nThe `width` and `height` attributes define the size of the drawing surface in pixels. If not specified, they default to 300px width and 150px height.\n\n## Core Drawing Operations\nOnce you have the 2D rendering context (commonly named `ctx`), you can use various methods to draw shapes, lines, text, and images.\n\n### Rectangles\n- `fillRect(x, y, width, height)`: Draws a filled rectangle.\n- `strokeRect(x, y, width, height)`: Draws a rectangular outline.\n- `clearRect(x, y, width, height)`: Clears the specified rectangular area, making it fully transparent. This is crucial for animations.\n\n### Paths\nPaths are sequences of lines and curves. You define a path and then `stroke` it (draw the outline) or `fill` it (fill the enclosed area).\n- `beginPath()`: Starts a new path by emptying the list of sub-paths. Call this before defining a new shape.\n- `moveTo(x, y)`: Moves the pen to the specified coordinates without drawing a line.\n- `lineTo(x, y)`: Draws a line from the current point to the specified coordinates.\n- `arc(x, y, radius, startAngle, endAngle, anticlockwise)`: Adds an arc to the path. `startAngle` and `endAngle` are in radians. `anticlockwise` is an optional boolean (default `false`).\n- `closePath()`: Connects the last point to the start point of the current sub-path, closing the shape.\n- `stroke()`: Draws the defined path outline.\n- `fill()`: Fills the defined path.\n\n### Text\n- `font = value`: Sets the font properties (e.g., '24px Arial').\n- `fillText(text, x, y, maxWidth)`: Draws filled text at the specified coordinates.\n- `strokeText(text, x, y, maxWidth)`: Draws outlined text.\n\n### Images\n- `drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)`: Draws an image onto the canvas. It has several overloads to allow drawing entire images, or just portions of an image, and scaling them. The simplest form is `drawImage(image, x, y, width, height)`.\n\n## Animation\nCanvas animations typically involve clearing the canvas, updating the state of objects, redrawing objects in their new positions, and then requesting the next frame using `requestAnimationFrame`.\n\n- `requestAnimationFrame(callback)`: Tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. This method provides an optimized way to animate, ensuring smooth animations by syncing with the browser's repaint cycle.\n\n### Styling Properties\n- `fillStyle`: Sets the color, gradient, or pattern to use inside shapes. Can be a CSS color string, a `CanvasGradient` object, or a `CanvasPattern` object.\n- `strokeStyle`: Sets the color, gradient, or pattern to use for strokes (outlines).\n- `lineWidth`: Sets the thickness of lines.\n- `lineCap`: Sets the style of the ends of lines (`butt`, `round`, `square`).\n- `lineJoin`: Sets the style of the corners where lines meet (`round`, `bevel`, `miter`).\n- `shadowColor`, `shadowBlur`, `shadowOffsetX`, `shadowOffsetY`: Properties for adding shadows to shapes.",
      "examples": [
        {
          "id": "example_canvas_basic_drawing_1",
          "title": "Basic Canvas Drawing Operations",
          "code": "const canvas = document.getElementById('myCanvas');\nconst ctx = canvas.getContext('2d');\n\n// Drawing a filled blue rectangle\nctx.fillStyle = 'blue';\nctx.fillRect(10, 10, 150, 100); // x, y, width, height\n\n// Drawing a path (triangle outline with fill)\nctx.beginPath();\nctx.moveTo(50, 50); // Starting point\nctx.lineTo(200, 100); // Line to this point\nctx.lineTo(150, 200);\nctx.closePath(); // Connect back to start\nctx.strokeStyle = 'red';\nctx.lineWidth = 3;\nctx.stroke(); // Draw the outline\nctx.fillStyle = 'lightgreen';\nctx.fill(); // Fill the shape\n\n// Drawing a filled black circle\nctx.beginPath();\nctx.arc(250, 150, 50, 0, Math.PI * 2); // x, y, radius, start angle, end angle\nctx.fillStyle = 'black';\nctx.fill();\n\n// Drawing text\nctx.font = '24px Arial';\nctx.fillStyle = 'purple';\nctx.fillText('Hello Canvas', 150, 50); // Text, x, y",
          "explanation": "This example demonstrates how to initialize a canvas context and use fundamental drawing methods. It covers drawing rectangles, custom paths (like a triangle), circles, and text, along with setting fill and stroke styles. The `beginPath()` and `closePath()` methods are essential for defining independent shapes.",
          "language": "javascript"
        },
        {
          "id": "example_canvas_image_animation_2",
          "title": "Drawing Images and Basic Animation",
          "code": "const canvas = document.getElementById('myCanvas');\nconst ctx = canvas.getContext('2d');\n\nlet xPos = 0;\nconst img = new Image();\nimg.onload = function() {\n  function animate() {\n    // Clear canvas for next frame\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Update position\n    xPos = (xPos + 1) % canvas.width; \n    \n    // Draw image at new position\n    ctx.drawImage(img, xPos, 50, 100, 100); // img, x, y, width, height\n    \n    // Request next frame\n    requestAnimationFrame(animate);\n  }\n\n  // Start animation after image loads\n  animate();\n};\nimg.src = 'https://via.placeholder.com/100'; // Placeholder image",
          "explanation": "This example shows how to load and draw an image onto the canvas. It also introduces a basic animation loop using `requestAnimationFrame`. The `clearRect` method is vital here to erase previous frames before redrawing the image in its new position, creating the illusion of movement. The image `src` uses a placeholder for demonstration purposes.",
          "language": "javascript"
        }
      ],
      "complexity": 5,
      "tags": [
        "Canvas API",
        "HTML",
        "JavaScript",
        "Graphics",
        "Drawing",
        "Animation"
      ],
      "prerequisites": [
        "HTML_DOM",
        "JavaScript_Functions",
        "JavaScript_Events"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "Canvas API",
      "HTML",
      "JavaScript",
      "Graphics",
      "Drawing",
      "Animation"
    ],
    "prerequisites": [
      "HTML_DOM",
      "JavaScript_Functions",
      "JavaScript_Events"
    ]
  },
  {
    "index": 125,
    "id": "theory_grunt_task_runner",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 5,
    "title": "Grunt: A Configuration-Based Task Runner",
    "description": "",
    "content": {
      "id": "theory_grunt_task_runner",
      "title": "Grunt: A Configuration-Based Task Runner",
      "description": "",
      "type": "theory",
      "content": "Grunt is an older, but still relevant, JavaScript task runner that emphasizes a configuration-over-code approach. It automates repetitive tasks such as minification, compilation, unit testing, linting, and more. Unlike newer bundlers that focus on module resolution and dependency graphs, Grunt operates by executing predefined tasks based on configurations specified in its `Gruntfile.js`.\n\n## Key Concepts\n*   **Task Runner**: Automates repetitive development tasks.\n*   **Configuration-based**: Tasks are defined and configured using JavaScript objects within `Gruntfile.js`.\n*   **Plugins**: Grunt's functionality is extended through a wide ecosystem of plugins, which handle specific operations (e.g., `grunt-contrib-sass` for SASS compilation, `grunt-contrib-watch` for file watching).\n*   **Gruntfile.js**: The main configuration file where tasks are defined, configured, and registered.\n*   **`grunt.initConfig()`**: Used to define project-specific configurations for tasks. This is where options for plugins are set.\n*   **`grunt.loadNpmTasks()`**: Loads a Grunt plugin, making its tasks available.\n*   **`grunt.registerTask()`**: Registers a new task, which can be a combination of other tasks or a custom function. The `default` task is executed when Grunt is run without any specific task name.\n\n## How it Works\nWhen Grunt is executed, it reads the `Gruntfile.js`. It then applies the configurations defined in `grunt.initConfig()` to the loaded plugins. When a task is invoked (e.g., `grunt default`), Grunt executes the specified series of sub-tasks in order. It's particularly useful for operations that need to be run sequentially or conditionally based on file changes.",
      "examples": [
        {
          "id": "example_grunt_basic_config",
          "title": "Basic Gruntfile.js Configuration",
          "code": "module.exports = function(grunt) {\n  // Project configuration.\n  grunt.initConfig({\n    // Configuration for the 'sass' task\n    sass: {\n      dist: {\n        files: {\n          'dist/css/main.css': 'src/scss/main.scss' // Output:Input mapping\n        }\n      }\n    },\n    // Configuration for the 'watch' task\n    watch: {\n      scss: {\n        files: ['src/scss/**/*.scss'], // Files to watch\n        tasks: ['sass'] // Tasks to run when files change\n      }\n    }\n  });\n\n  // Load Grunt plugins\n  grunt.loadNpmTasks('grunt-contrib-sass');\n  grunt.loadNpmTasks('grunt-contrib-watch');\n\n  // Register a default task alias.\n  // Running 'grunt' in the terminal will execute 'sass' then 'watch'.\n  grunt.registerTask('default', ['sass', 'watch']);\n};",
          "explanation": "This `Gruntfile.js` demonstrates a typical setup for Grunt. It initializes configurations for `sass` and `watch` tasks. The `sass` task compiles a SCSS file into a CSS file. The `watch` task monitors SCSS files and automatically triggers the `sass` task whenever changes are detected. Finally, `grunt.loadNpmTasks` includes the necessary plugins, and `grunt.registerTask` defines a `default` task that runs both `sass` and `watch` sequentially.",
          "language": "javascript"
        }
      ],
      "complexity": 5,
      "tags": [
        "Grunt",
        "Task Runner",
        "Build Tools",
        "Automation",
        "Frontend Development"
      ],
      "prerequisites": [
        "Node.js",
        "npm"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "Grunt",
      "Task Runner",
      "Build Tools",
      "Automation",
      "Frontend Development"
    ],
    "prerequisites": [
      "Node.js",
      "npm"
    ]
  },
  {
    "index": 144,
    "id": "theory_js_fundamentals_datatypes_and_scope",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 5,
    "title": "JavaScript Fundamentals: Data Types, Variables, and Scope",
    "description": "",
    "content": {
      "id": "theory_js_fundamentals_datatypes_and_scope",
      "title": "JavaScript Fundamentals: Data Types, Variables, and Scope",
      "description": "",
      "type": "theory",
      "content": "JavaScript features several built-in data types, broadly categorized into **primitive types** and **object types**.\n\n## Primitive Data Types\nThese are immutable values and include:\n*   `String`: Textual data.\n*   `Number`: Numeric data (integers and floating-point numbers).\n*   `BigInt`: Arbitrary-precision integers.\n*   `Boolean`: Logical entity (true/false).\n*   `Undefined`: A variable that has been declared but not yet assigned a value.\n*   `Symbol`: Unique and immutable values, often used as object property keys.\n*   `Null`: Represents the intentional absence of any object value. It's often referred to as a primitive type, although `typeof null` returns 'object' (a long-standing bug).\n\n## Object Data Type\nThis is the complex type, serving as the base for more structured data. Everything that is not a primitive type is an object. This includes plain objects (`{}`), arrays (`[]`), functions, Dates, RegExps, etc. Objects are mutable and are passed by reference.\n\n## Variable Declaration and Temporal Dead Zone (TDZ)\nJavaScript has different ways to declare variables: `var`, `let`, and `const`.\n*   `var`: Function-scoped or global-scoped. Hoisted to the top of their scope and initialized with `undefined`. Accessing them before declaration doesn't throw an error, but results in `undefined`.\n*   `let` and `const`: Block-scoped. Also hoisted, but they are not initialized. Instead, they enter a 'temporal dead zone' (TDZ) from the start of their block until their declaration is processed. Attempting to access a `let` or `const` variable within its TDZ will result in a `ReferenceError`.\n\n### Temporal Dead Zone Explained\nThe TDZ ensures that variables are only accessible after their declaration and initialization, preventing potential bugs caused by premature access. This makes `let` and `const` more predictable and safer to use than `var`.\n\n## Value vs. Reference Assignment\n*   **Primitive values** are assigned by value. When a primitive variable is assigned to another, a copy of the value is made.\n*   **Object values** are assigned by reference. When an object variable is assigned to another, both variables point to the *same* underlying object in memory. Changes made through one variable will be reflected in the other.\n\n",
      "examples": [
        {
          "id": "example_js_fundamentals_1",
          "title": "Primitive vs. Object Assignment",
          "code": "let num1 = 10;\nlet num2 = num1;\nnum1 = 20;\nconsole.log(num2); // Output: 10 (num2 holds a copy of the original value)\n\nlet obj1 = { name: 'Hello' };\nlet obj2 = obj1;\nobj1 = { name: 'Bye' }; // obj1 now points to a NEW object\nconsole.log(obj2.name); // Output: Hello (obj2 still points to the ORIGINAL object)\n\nlet arr1 = [1, 2, 3];\nlet arr2 = arr1;\narr1.push(4); // Modifies the object arr1 points to\nconsole.log(arr2); // Output: [1, 2, 3, 4] (arr2 sees the change because it's the same object)\n\nlet obj3 = { value: 100 };\nlet obj4 = obj3;\nobj3.value = 200; // Modifies the object obj3 points to\nconsole.log(obj4.value); // Output: 200 (obj4 sees the change)\n",
          "explanation": "This example clearly demonstrates the difference between value assignment for primitives and reference assignment for objects. When `obj1` is reassigned to a *new* object, `obj2` continues to point to the *original* object. However, if `obj1`'s *properties* were modified (e.g., `obj1.name = 'Bye';`) instead of reassigning `obj1` entirely, `obj2` would reflect that change because both would still refer to the same object.",
          "language": "javascript"
        },
        {
          "id": "example_js_fundamentals_tdz",
          "title": "Temporal Dead Zone Demonstration",
          "code": "// console.log(aVar); // No error, 'undefined' (var is hoisted and initialized)\nvar aVar = 10;\n\n// console.log(bLet); // ReferenceError: Cannot access 'bLet' before initialization (TDZ)\nlet bLet = 20;\n\n// console.log(cConst); // ReferenceError: Cannot access 'cConst' before initialization (TDZ)\nconst cConst = 30;\n\nfunction scopeExample() {\n  // console.log(scopedVar); // ReferenceError (TDZ applies to function scope as well for let/const)\n  let scopedVar = 'I am scoped';\n  console.log(scopedVar);\n}\n\n// TDZ with function parameters\nfunction greet(name = defaultName) {\n  // console.log(defaultName); // ReferenceError if defaultName is declared AFTER this line in the scope\n  const defaultName = 'Guest'; \n  console.log(`Hello, ${name}`);\n}\n\n// console.log(myFunc()); // ReferenceError: Cannot access 'myFunc' before initialization\nconst myFunc = () => { return 'Hello'; };\n",
          "explanation": "This example illustrates the Temporal Dead Zone for `let` and `const`. Any attempt to access these variables before their declaration within their scope leads to a `ReferenceError`. In contrast, `var` variables, though hoisted, are initialized with `undefined`, so accessing them before assignment doesn't throw an error. The TDZ concept also applies to default parameters in functions and function expressions declared with `let`/`const`.",
          "language": "javascript"
        }
      ],
      "complexity": 5,
      "tags": [
        "JavaScript",
        "Fundamentals",
        "Data Types",
        "Variables",
        "Scope",
        "Temporal Dead Zone",
        "Primitives",
        "Objects"
      ],
      "prerequisites": [],
      "technology": "JavaScript"
    },
    "tags": [
      "JavaScript",
      "Fundamentals",
      "Data Types",
      "Variables",
      "Scope",
      "Temporal Dead Zone",
      "Primitives",
      "Objects"
    ],
    "prerequisites": []
  },
  {
    "index": 150,
    "id": "theory_local_maxima",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 5,
    "title": "Finding Local Maxima in an Array",
    "description": "",
    "content": {
      "id": "theory_local_maxima",
      "title": "Finding Local Maxima in an Array",
      "description": "",
      "type": "theory",
      "content": "A local maximum in an array is an element that is strictly greater than its immediate neighbors. For elements at the ends of the array, they only need to be greater than their single existing neighbor. This concept is fundamental in array traversal and identifying peaks in data sequences.\n\n## Definition\n\n*   **Local Maximum**: An element `arr[i]` is a local maximum if:\n    *   `arr[i] > arr[i-1]` and `arr[i] > arr[i+1]` (for middle elements).\n    *   `arr[0] > arr[1]` (for the first element).\n    *   `arr[arr.length-1] > arr[arr.length-2]` (for the last element).\n\n## Algorithm Steps\n\nThe most straightforward way to find all local maxima is to iterate through the array once and apply the definition:\n\n1.  **Handle Edge Cases**: \n    *   If the array is empty, there are no local maxima. Return an empty array.\n    *   If the array has only one element, that element is always considered a local maximum (as it has no neighbors to be smaller than).\n2.  **Check the First Element**: Compare `arr[0]` with `arr[1]`. If `arr[0]` is greater, it's a local maximum.\n3.  **Iterate Through Middle Elements**: Loop from the second element (`i = 1`) up to the second-to-last element (`i = arr.length - 2`). For each `arr[i]`, check if `arr[i] > arr[i-1]` AND `arr[i] > arr[i+1]`.\n4.  **Check the Last Element**: Compare `arr[arr.length-1]` with `arr[arr.length-2]`. If `arr[arr.length-1]` is greater, it's a local maximum.\n5.  **Collect Indices**: Store the indices of all found local maxima.\n\n## Time and Space Complexity\n\n*   **Time Complexity**: `O(N)` because the algorithm performs a single pass over the array, where N is the number of elements in the array.\n*   **Space Complexity**: `O(K)` where K is the number of local maxima found. In the worst case (e.g., an alternating sequence like `[1, 0, 1, 0, 1]`), K can be `N/2`, so `O(N)`. In the best case (e.g., a strictly increasing array), K is 1.",
      "examples": [
        {
          "id": "example_local_maxima_1",
          "title": "Basic Local Maxima Finder",
          "code": "function findLocalMaxima(arr) {\n  if (arr.length === 0) return [];\n  if (arr.length === 1) return [0]; // Single element is always a local maximum\n  \n  const localMaxima = [];\n  \n  // Check first element\n  if (arr[0] > arr[1]) {\n    localMaxima.push(0);\n  }\n  \n  // Check middle elements\n  for (let i = 1; i < arr.length - 1; i++) {\n    if (arr[i] > arr[i-1] && arr[i] > arr[i+1]) {\n      localMaxima.push(i);\n    }\n  }\n  \n  // Check last element\n  if (arr[arr.length-1] > arr[arr.length-2]) {\n    localMaxima.push(arr.length-1);\n  }\n  \n  return localMaxima;\n}\n\n// Example Usage:\nconst array1 = [1, 2, 3, 5, 4];\nconsole.log(`Array: [${array1}] | Local Maxima Indices: ${findLocalMaxima(array1)}`); // Expected: [3] (value 5)\n\nconst array2 = [10, 5, 20, 15, 30];\nconsole.log(`Array: [${array2}] | Local Maxima Indices: ${findLocalMaxima(array2)}`); // Expected: [0, 2, 4] (values 10, 20, 30)\n\nconst array3 = [1, 2, 3, 4, 5];\nconsole.log(`Array: [${array3}] | Local Maxima Indices: ${findLocalMaxima(array3)}`); // Expected: [4] (value 5)\n\nconst array4 = [5, 4, 3, 2, 1];\nconsole.log(`Array: [${array4}] | Local Maxima Indices: ${findLocalMaxima(array4)}`); // Expected: [0] (value 5)\n\nconst array5 = [7];\nconsole.log(`Array: [${array5}] | Local Maxima Indices: ${findLocalMaxima(array5)}`); // Expected: [0] (value 7)\n\nconst array6 = [];\nconsole.log(`Array: [${array6}] | Local Maxima Indices: ${findLocalMaxima(array6)}`); // Expected: []",
          "explanation": "This example demonstrates the `findLocalMaxima` function. It correctly handles the edge cases for empty or single-element arrays. Then, it separately checks the first, middle, and last elements based on their specific neighbor comparison rules. The output shows the indices of elements that are local maxima within various test arrays, illustrating the algorithm's behavior for increasing, decreasing, and mixed sequences.",
          "language": "javascript"
        }
      ],
      "complexity": 5,
      "tags": [
        "array",
        "algorithm",
        "traversal",
        "local maximum",
        "peak finding"
      ],
      "prerequisites": [
        "array_basics",
        "conditional_statements",
        "loops"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "array",
      "algorithm",
      "traversal",
      "local maximum",
      "peak finding"
    ],
    "prerequisites": [
      "array_basics",
      "conditional_statements",
      "loops"
    ]
  },
  {
    "index": 155,
    "id": "theory_oop_fundamentals_vehicle_parkinglot_structure",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 5,
    "title": "Object-Oriented Programming Fundamentals: Vehicle and ParkingLot Class Structure",
    "description": "",
    "content": {
      "id": "theory_oop_fundamentals_vehicle_parkinglot_structure",
      "title": "Object-Oriented Programming Fundamentals: Vehicle and ParkingLot Class Structure",
      "description": "",
      "type": "theory",
      "content": "This section introduces the foundational concepts of Object-Oriented Programming (OOP) in JavaScript through the definition of `Vehicle` and `ParkingLot` classes. OOP principles like encapsulation, abstraction, and modularity are demonstrated by structuring the application logic into reusable and distinct entities.\n\n## Vehicle Class\nThe `Vehicle` class serves as a blueprint for creating vehicle objects. Each `Vehicle` instance encapsulates properties such as `registrationNumber` and `color`. The `constructor` method is used to initialize these properties when a new `Vehicle` object is created.\n\n## ParkingLot Class\nThe `ParkingLot` class manages the parking facility. It encapsulates the state of the parking lot (e.g., available slots, occupied slots) and provides methods to interact with it, such as parking, unparking, and querying vehicle information. This design promotes a clear separation of concerns, making the code more organized and maintainable.\n\n### Key Concepts\n-   **Classes (`class` keyword):** A template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods).\n-   **Constructors (`constructor` method):** A special method for creating and initializing an object created with a `class`.\n-   **`this` keyword:** Refers to the current instance of the class within its methods, allowing access to its properties and other methods.\n-   **Encapsulation:** Bundling data (properties) and methods (functions) that operate on the data into a single unit (class), and restricting direct access to some of the object's components.",
      "examples": [
        {
          "id": "example_vehicle_class_1",
          "title": "Defining the Vehicle Class",
          "code": "class Vehicle {\n  constructor(registrationNumber, color) {\n    this.registrationNumber = registrationNumber;\n    this.color = color;\n  }\n}",
          "explanation": "This code defines the `Vehicle` class with a constructor that takes `registrationNumber` and `color` as arguments and assigns them to the instance properties. This allows creating vehicle objects with specific details.",
          "language": "javascript"
        },
        {
          "id": "example_parkinglot_structure_1",
          "title": "Basic ParkingLot Class Structure",
          "code": "class ParkingLot {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.slots = new Array(capacity).fill(null);\n    this.availableSlots = new Set();\n    for (let i = 0; i < capacity; i++) {\n      this.availableSlots.add(i);\n    }\n  }\n\n  // Other methods will go here\n  parkVehicle(vehicle) { /* ... */ }\n  removeVehicle(slotNumber) { /* ... */ }\n  // ...\n}",
          "explanation": "This snippet shows the basic structure of the `ParkingLot` class, including its constructor which initializes the total capacity, an array `slots` to hold vehicles, and a `Set` `availableSlots` to keep track of empty slots. The constructor pre-populates `availableSlots` with all slot numbers.",
          "language": "javascript"
        }
      ],
      "complexity": 5,
      "tags": [
        "OOP",
        "Classes",
        "Constructor",
        "this",
        "JavaScript",
        "Fundamentals"
      ],
      "prerequisites": [
        "javascript_basics",
        "functions"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "OOP",
      "Classes",
      "Constructor",
      "this",
      "JavaScript",
      "Fundamentals"
    ],
    "prerequisites": [
      "javascript_basics",
      "functions"
    ]
  },
  {
    "index": 3,
    "id": "theory_decorator_pattern",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 6,
    "title": "Decorator Pattern",
    "description": "",
    "content": {
      "id": "theory_decorator_pattern",
      "title": "Decorator Pattern",
      "description": "",
      "type": "theory",
      "content": "The Decorator pattern is a structural design pattern that allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from the same class. It provides a flexible alternative to subclassing for extending functionality.\n\n## Key Concepts\n-   **Wrapper**: The decorator 'wraps' the original object, adding new functionality before or after delegating to the original object's method.\n-   **Dynamic Extension**: Functionality can be added or removed at runtime, offering more flexibility than static inheritance.\n-   **Avoids Subclass Explosion**: Instead of creating many subclasses for every combination of features (e.g., `CoffeeWithMilk`, `CoffeeWithWhip`, `CoffeeWithMilkAndWhip`), decorators allow you to compose features dynamically.\n-   **Open/Closed Principle**: The original object's code remains unchanged (closed for modification), while new features can be added (open for extension) through decorators.\n\n## Structure\n-   **Component**: Defines the interface for objects that can be decorated.\n-   **Concrete Component**: The original object to which responsibilities can be attached.\n-   **Decorator**: Maintains a reference to a Component object and conforms to the Component's interface.\n-   **Concrete Decorator**: Adds responsibilities to the Component.\n\n## Use Cases\n-   Adding features to objects without altering their core structure.\n-   When inheritance is impractical due to a large number of independent extensions.\n-   To add or remove responsibilities from an object at runtime.\n\n## Advantages\n-   More flexible than static inheritance.\n-   Avoids feature-laden classes high up in the hierarchy.\n-   Maintains separation of concerns by keeping different responsibilities in separate decorator classes.\n\n## Disadvantages\n-   Can result in a large number of small objects if many decorators are used.\n-   Debugging can become more complex due to multiple layers of wrapping.\n-   The order of wrapping might matter, leading to potential issues if not managed carefully.",
      "examples": [
        {
          "id": "example_decorator_1",
          "title": "Coffee Decorator Example",
          "code": "class Coffee {\n  constructor() {\n    this.price = 5;\n    this.description = 'Basic Coffee';\n  }\n\n  cost() {\n    return this.price;\n  }\n\n  getDescription() {\n    return this.description;\n  }\n}\n\nfunction Milk(coffee) {\n  const baseCost = coffee.cost();\n  const baseDescription = coffee.getDescription();\n\n  coffee.cost = function() {\n    return baseCost + 1; // Add milk cost\n  };\n\n  coffee.getDescription = function() {\n    return baseDescription + ', Milk';\n  };\n  return coffee;\n}\n\nfunction Whip(coffee) {\n  const baseCost = coffee.cost();\n  const baseDescription = coffee.getDescription();\n\n  coffee.cost = function() {\n    return baseCost + 2; // Add whip cost\n  };\n\n  coffee.getDescription = function() {\n    return baseDescription + ', Whip';\n  };\n  return coffee;\n}\n\nfunction Vanilla(coffee) {\n  const baseCost = coffee.cost();\n  const baseDescription = coffee.getDescription();\n\n  coffee.cost = function() {\n    return baseCost + 3; // Add vanilla cost\n  };\n\n  coffee.getDescription = function() {\n    return baseDescription + ', Vanilla';\n  };\n  return coffee;\n}\n\nconst myCoffee = new Coffee();\nconsole.log(`Base: ${myCoffee.getDescription()} - $${myCoffee.cost()}`); // Base: Basic Coffee - $5\n\nconst milkCoffee = Milk(myCoffee);\nconsole.log(`Milk: ${milkCoffee.getDescription()} - $${milkCoffee.cost()}`); // Milk: Basic Coffee, Milk - $6\n\nconst whippedMilkCoffee = Whip(milkCoffee);\nconsole.log(`Whipped Milk: ${whippedMilkCoffee.getDescription()} - $${whippedMilkCoffee.cost()}`); // Whipped Milk: Basic Coffee, Milk, Whip - $8\n\nconst finalCoffee = Vanilla(whippedMilkCoffee);\nconsole.log(`Final: ${finalCoffee.getDescription()} - $${finalCoffee.cost()}`); // Final: Basic Coffee, Milk, Whip, Vanilla - $11",
          "explanation": "This example demonstrates how the `Coffee` object's `cost()` and `getDescription()` methods are dynamically extended by `Milk`, `Whip`, and `Vanilla` functions. Each decorator function captures the current state (cost and description) of the `coffee` object it receives and then redefines the `cost` and `getDescription` methods to include its own contribution. This allows for flexible combinations of additives without creating a complex inheritance hierarchy.",
          "language": "javascript"
        }
      ],
      "complexity": 6,
      "tags": [
        "design-patterns",
        "structural-patterns",
        "javascript",
        "object-oriented-programming",
        "flexibility"
      ],
      "prerequisites": [
        "object-oriented-programming",
        "functions-as-first-class-citizens",
        "closures"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "design-patterns",
      "structural-patterns",
      "javascript",
      "object-oriented-programming",
      "flexibility"
    ],
    "prerequisites": [
      "object-oriented-programming",
      "functions-as-first-class-citizens",
      "closures"
    ]
  },
  {
    "index": 15,
    "id": "theory_array_group_by_reduce",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 6,
    "title": "Array Grouping with `reduce`",
    "description": "",
    "content": {
      "id": "theory_array_group_by_reduce",
      "title": "Array Grouping with `reduce`",
      "description": "",
      "type": "theory",
      "content": "The `Array.prototype.reduce()` method is a powerful higher-order function in JavaScript that executes a user-supplied 'reducer' callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value.\n\n### `reduce` Parameters:\n- **`callback`**: A function to execute on each element in the array. It takes four arguments:\n    - **`accumulator`**: The accumulated value previously returned in the last invocation of the callback, or `initialValue`, if supplied.\n    - **`currentValue`**: The current element being processed in the array.\n    - **`currentIndex`** (Optional): The index of the current element being processed in the array. Starts from index 0 if an `initialValue` is provided. Otherwise, it starts from index 1.\n    - **`array`** (Optional): The array `reduce()` was called upon.\n- **`initialValue`** (Optional): A value to use as the first argument to the first call of the `callback`. If no `initialValue` is supplied, the first element in the array will be used as the `accumulator`'s initial value and `currentValue` will start from the second element.\n\n### Grouping Logic:\nThe provided `groupBy` function leverages `reduce` to categorize objects within an array based on a specified property (`key`). For each `item` in the `array`:\n1.  It checks if the `result` (the accumulator, which will become the grouped object) already has a property corresponding to `item[key]` (e.g., `item.age`).\n2.  If not, it initializes `result[item[key]]` as an empty array `[]`.\n3.  It then pushes the current `item` into this array.\n4.  Finally, it returns the `result` accumulator for the next iteration.\n\nThis pattern efficiently builds an object where keys are the unique values of the specified property, and values are arrays of objects sharing that property value.",
      "examples": [
        {
          "id": "example_group_by_1",
          "title": "Basic `groupBy` Implementation",
          "code": "function groupBy(array, key) {\n  return array.reduce((result, item) => {\n    // If the key doesn't exist in result, initialize it as an empty array\n    (result[item[key]] = result[item[key]] || []).push(item);\n    return result;\n  }, {}); // Initial accumulator is an empty object\n}\n\n// Grouped people by age\nconst peopleData = [\n  { name: 'Alice', age: 30 },\n  { name: 'Bob', age: 25 },\n  { name: 'Charlie', age: 30 },\n  { name: 'David', age: 25 }\n];\n\nconst groupedPeople = groupBy(peopleData, 'age');\nconsole.log(groupedPeople);\n// Expected Output:\n// {\n//   25: [{ name: 'Bob', age: 25 }, { name: 'David', age: 25 }],\n//   30: [{ name: 'Alice', age: 30 }, { name: 'Charlie', age: 30 }]\n// }",
          "explanation": "This example demonstrates the `groupBy` function in action, using `age` as the key to group the `peopleData` array. The `reduce` method iterates through each person, and if a group for their age doesn't exist in the `result` object, it creates an empty array for that age group before pushing the current person into it. The `{}` as the initial value ensures `result` starts as an empty object.",
          "language": "javascript"
        },
        {
          "id": "example_group_by_2",
          "title": "Grouping by Multiple Properties",
          "code": "function groupByMultipleKeys(array, keys) {\n  return array.reduce((result, item) => {\n    let currentGroup = result;\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const value = item[key];\n      if (!currentGroup[value]) {\n        currentGroup[value] = (i === keys.length - 1) ? [] : {};\n      }\n      currentGroup = currentGroup[value];\n    }\n    currentGroup.push(item);\n    return result;\n  }, {});\n}\n\nconst products = [\n  { id: 1, category: 'Electronics', brand: 'Sony' },\n  { id: 2, category: 'Electronics', brand: 'Samsung' },\n  { id: 3, category: 'Clothes', brand: 'Nike' },\n  { id: 4, category: 'Electronics', brand: 'Sony' },\n];\n\nconst groupedProducts = groupByMultipleKeys(products, ['category', 'brand']);\nconsole.log(JSON.stringify(groupedProducts, null, 2));\n// Expected Output:\n// {\n//   \"Electronics\": {\n//     \"Sony\": [\n//       { \"id\": 1, \"category\": \"Electronics\", \"brand\": \"Sony\" },\n//       { \"id\": 4, \"category\": \"Electronics\", \"brand\": \"Sony\" }\n//     ],\n//     \"Samsung\": [\n//       { \"id\": 2, \"category\": \"Electronics\", \"brand\": \"Samsung\" }\n//     ]\n//   },\n//   \"Clothes\": {\n//     \"Nike\": [\n//       { \"id\": 3, \"category\": \"Clothes\", \"brand\": \"Nike\" }\n//     ]\n//   }\n// }",
          "explanation": "This advanced example extends the grouping concept to support multiple nested keys. The `groupByMultipleKeys` function iterates through an array of keys, dynamically building a nested object structure. For each key, it creates a new level in the `result` object, ultimately pushing the original `item` into the innermost array. This demonstrates the versatility of `reduce` for complex data transformations.",
          "language": "javascript"
        }
      ],
      "complexity": 6,
      "tags": [
        "Array.prototype.reduce",
        "functional programming",
        "data transformation",
        "JavaScript",
        "array methods"
      ],
      "prerequisites": [
        "javascript_arrays",
        "javascript_objects",
        "higher_order_functions"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "Array.prototype.reduce",
      "functional programming",
      "data transformation",
      "JavaScript",
      "array methods"
    ],
    "prerequisites": [
      "javascript_arrays",
      "javascript_objects",
      "higher_order_functions"
    ]
  },
  {
    "index": 86,
    "id": "theory_redux_core_concepts",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 6,
    "title": "Redux Core Concepts",
    "description": "",
    "content": {
      "id": "theory_redux_core_concepts",
      "title": "Redux Core Concepts",
      "description": "",
      "type": "theory",
      "content": "Redux is a predictable state container for JavaScript apps, primarily used for managing application state. It helps you write applications that behave consistently across different environments (client, server, and native), and are easy to test. It provides a single source of truth for your application's state, making state changes predictable and debuggable.\n\n## Key Concepts\n\n### Store\nThe **Store** is a single JavaScript object that holds the entire application state tree. There should only be one store in a Redux application. It's responsible for:\n- Holding the application state.\n- Allowing access to the state via `getState()`.\n- Allowing state to be updated via `dispatch(action)`.\n- Registering listeners via `subscribe(listener)`.\n- Handling unregistering of listeners via the function returned by `subscribe(listener)`.\n\n### Actions\n**Actions** are plain JavaScript objects that describe *what happened*. They are the only way to send data from your application to the Red Redux store. Actions must have a `type` property, which is usually a string constant, indicating the type of action performed. Other properties can contain any necessary data.\n\n### Action Creators\n**Action Creators** are functions that create and return action objects. They are not strictly necessary but are a good practice to encapsulate action creation logic, making actions reusable and easier to manage.\n\n### Reducers\n**Reducers** are pure functions that take the current `state` and an `action` as arguments, and return a *new state*. They specify how the application's state changes in response to actions. Reducers must be pure (no side effects) and never mutate the original state directly; instead, they should return a new state object if changes are made, or the original state if no changes are needed.\n\n### Dispatch\n`dispatch` is the method used to send actions to the Redux store. When an action is dispatched, Redux will pass it to the root reducer, which then processes the action and updates the state. It's the only way to trigger a state change.\n\n### Selectors\n**Selectors** are functions used to extract specific pieces of data from the Redux store's state. They are crucial for optimizing performance by preventing unnecessary re-renders in connected components when unrelated parts of the state change. They also encapsulate the logic for deriving data, making it reusable and easier to test.\n",
      "examples": [
        {
          "id": "example_redux_core_1",
          "title": "Action and Action Creator",
          "code": "const ADD_TODO = 'ADD_TODO';\n\n// Action\nconst addTodoAction = {\n  type: ADD_TODO,\n  payload: 'Learn Redux'\n};\n\n// Action Creator\nfunction addTodo(text) {\n  return {\n    type: ADD_TODO,\n    payload: text\n  };\n}",
          "explanation": "This example defines an action type constant and demonstrates both a raw action object and an action creator function `addTodo` that returns such an action. Action creators provide a clean way to construct actions.",
          "language": "typescript"
        },
        {
          "id": "example_redux_core_2",
          "title": "Reducer Example",
          "code": "function todosReducer(state = [], action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [...state, { text: action.payload, completed: false }];\n    case 'TOGGLE_TODO':\n      return state.map((todo, index) => \n        index === action.index \n          ? { ...todo, completed: !todo.completed } \n          : todo\n      );\n    default:\n      return state;\n  }\n}",
          "explanation": "This `todosReducer` function is a pure function. It takes the current state (defaulting to an empty array) and an action. Based on the action type, it returns a *new* state array using spread syntax (`...`) and `map` to ensure immutability. For unrecognized actions, it returns the current state.",
          "language": "typescript"
        },
        {
          "id": "example_redux_core_3",
          "title": "Dispatching an Action",
          "code": "import { createStore } from 'redux';\n\n// Assume todosReducer is defined as above\nconst store = createStore(todosReducer);\n\n// Dispatch an action to update the state\nstore.dispatch({ type: 'ADD_TODO', payload: 'Buy groceries' });\n\nconsole.log(store.getState()); \n// Expected output: [{ text: 'Buy groceries', completed: false }]\n\nstore.dispatch({ type: 'TOGGLE_TODO', index: 0 });\n\nconsole.log(store.getState());\n// Expected output: [{ text: 'Buy groceries', completed: true }]",
          "explanation": "This example demonstrates how to create a Redux store and use the `dispatch` method to send actions to it. After dispatching, `getState()` can be used to observe the updated state.",
          "language": "typescript"
        },
        {
          "id": "example_redux_core_4",
          "title": "Selector Example",
          "code": "interface RootState { todos: { text: string; completed: boolean; }[]; user: { name: string; }; }\n\n// Assuming a state shape like: { todos: [...], user: {...} }\nconst selectTodos = (state: RootState) => state.todos;\nconst selectCompletedTodos = (state: RootState) => \n  state.todos.filter(todo => todo.completed);\nconst selectUserName = (state: RootState) => state.user.name;\n\n// Usage in a component (conceptual)\n// const todos = useSelector(selectTodos);\n// const completedCount = useSelector(state => selectCompletedTodos(state).length);\n",
          "explanation": "These are examples of simple selector functions. They take the entire Redux state as an argument and return a specific slice of that state or a derived piece of data. Using selectors helps encapsulate state access logic and improve component reusability.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "Redux",
        "State Management",
        "Core Concepts",
        "Architecture"
      ],
      "prerequisites": [
        "JavaScript Fundamentals",
        "Immutability"
      ],
      "technology": "TypeScript"
    },
    "tags": [
      "Redux",
      "State Management",
      "Core Concepts",
      "Architecture"
    ],
    "prerequisites": [
      "JavaScript Fundamentals",
      "Immutability"
    ]
  },
  {
    "index": 106,
    "id": "theory_immutable_js_collections",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 6,
    "title": "Immutable.js: Core Concepts and Data Structures",
    "description": "",
    "content": {
      "id": "theory_immutable_js_collections",
      "title": "Immutable.js: Core Concepts and Data Structures",
      "description": "",
      "type": "theory",
      "content": "Immutable.js is a library that provides immutable data structures for JavaScript. Immutability means that once a data structure is created, it cannot be changed. Any operation that would 'modify' the structure actually returns a new instance of the structure with the changes, leaving the original intact. This approach helps in building applications with more predictable state, easier debugging, and optimized performance through structural sharing and referential equality checks.\n\n## Key Concepts\n*   **Immutability**: Data structures cannot be altered after creation. Operations like `set`, `update`, `push` return new instances.\n*   **Persistence**: Previous versions of the data structure remain valid and accessible.\n*   **Structural Sharing**: When a 'modified' version of an immutable data structure is created, only the parts that have changed are re-created. Unchanged parts are shared between the old and new versions, saving memory and improving performance.\n*   **Referential Equality**: Because operations return new instances, you can easily check if a data structure has changed by comparing references (e.g., `oldState === newState`). This is crucial for performance optimizations in UI frameworks like React.\n\n## Immutable Data Structures\n\n### `Immutable.Map`\n`Immutable.Map` is an immutable, ordered collection of key-value pairs, similar to a JavaScript `Object` or a `Map`. It's a fundamental immutable collection.\n\n### `Immutable.List`\n`Immutable.List` is an immutable, ordered indexed collection, similar to a JavaScript `Array`.\n\n### `Immutable.Set`\n`Immutable.Set` is an immutable collection of unique values, similar to a JavaScript `Set`.\n\n### `Immutable.Record`\n`Immutable.Record` provides a way to define immutable objects with a predefined shape and default values. It's useful for creating type-safe and predictable data models.\n\n### `Immutable.fromJS`\n`Immutable.fromJS` is a utility function that deeply converts plain JavaScript objects and arrays into Immutable.js `Map`s and `List`s respectively. This is essential when integrating Immutable.js with existing JavaScript data.\n\n## Common Operations\n*   **`get(key)`**: Retrieves a value associated with a key.\n*   **`set(key, value)`**: Returns a new `Map` with the value at the specified key updated or added.\n*   **`update(key, updaterFn)`**: Returns a new `Map` with the value at `key` updated by the `updaterFn`. The `updaterFn` receives the current value and should return the new value.\n*   **`push(value)`**: Returns a new `List` with `value` appended.\n*   **`filter(predicateFn)`**: Returns a new collection containing only elements for which the `predicateFn` returns `true`.\n*   **`filterNot(predicateFn)`**: Returns a new collection containing only elements for which the `predicateFn` returns `false`.\n*   **`merge(otherMap)`**: Returns a new `Map` with the values from `otherMap` merged into the original `Map`. Conflicts are resolved by the `otherMap`'s values taking precedence.\n*   **`union(collection)`**: Returns a new `Set` containing all unique values from the original `Set` and the provided `collection`.",
      "examples": [
        {
          "id": "example_immutable_map_1",
          "title": "Creating and Updating Immutable.Map",
          "code": "import { Map } from 'immutable';\n\n// Creating an immutable map\nconst map1 = Map({ a: 1, b: 2, c: 3 });\nconsole.log('Map 1:', map1.toJS()); // { a: 1, b: 2, c: 3 }\n\n// Updating 'b' (returns a new map, map1 remains unchanged)\nconst map2 = map1.set('b', 50);\n\nconsole.log('Map 1 (after update):', map1.get('b')); // 2\nconsole.log('Map 2 (new map):', map2.get('b')); // 50\n\n// Using update method\nconst map3 = map2.update('c', value => value * 2);\nconsole.log('Map 3 (updated c):', map3.get('c')); // 100",
          "explanation": "This example demonstrates how `Immutable.Map` instances are created and how `set` and `update` methods operate. Notice that `map1` remains unchanged after `set('b', 50)` is called, proving the immutability principle. `update` provides a functional way to modify a value based on its current state.",
          "language": "typescript"
        },
        {
          "id": "example_immutable_record_1",
          "title": "Using Immutable.Record for Structured Data",
          "code": "import { Record } from 'immutable';\n\nconst DataRecord = Record({\n  value: 5,\n  unit: 'count'\n});\n\nconst TestRecord = Record({\n  text: '',\n  data: new DataRecord() // Nested Record with default\n});\n\nconst testInstance1 = new TestRecord();\nconsole.log(testInstance1.get('data').get('value')); // 5 (the default value)\nconsole.log(testInstance1.get('data').get('unit')); // 'count'\n\n// Create a new instance with overridden values\nconst testInstance2 = testInstance1.set('text', 'Hello').setIn(['data', 'value'], 10);\nconsole.log(testInstance2.get('text')); // 'Hello'\nconsole.log(testInstance2.get('data').get('value')); // 10\nconsole.log(testInstance1.get('text')); // '' (original remains unchanged)\nconsole.log(testInstance1.get('data').get('value')); // 5",
          "explanation": "`Immutable.Record` allows defining a blueprint for immutable objects, complete with default values and nested structures. This improves code readability and maintainability by ensuring a consistent data shape. Accessing values is done via `get` or property access if configured. Updates return new `Record` instances.",
          "language": "typescript"
        },
        {
          "id": "example_immutable_fromjs_1",
          "title": "Converting JavaScript Objects to Immutable Structures",
          "code": "import { fromJS, isImmutable } from 'immutable';\n\n// A plain JavaScript object\nconst jsState = {\n  list: [1, 2, { id: 1 }],\n  isAddUserModalShowed: false,\n  tmpUser: null,\n  settings: {\n    theme: 'dark',\n    notifications: true\n  }\n};\n\n// Deep conversion to Immutable Maps and Lists\nconst immutableState = fromJS(jsState);\n\nconsole.log(isImmutable(immutableState)); // true\nconsole.log(isImmutable(immutableState.get('list'))); // true\nconsole.log(immutableState.getIn(['list', 2, 'id'])); // 1\nconsole.log(immutableState.getIn(['settings', 'theme'])); // 'dark'\n\n// Demonstrating updates\nconst newState = immutableState.set('isAddUserModalShowed', true);\nconsole.log(newState.get('isAddUserModalShowed')); // true\nconsole.log(immutableState.get('isAddUserModalShowed')); // false (original unchanged)",
          "explanation": "`fromJS` is crucial for initializing Immutable.js structures from existing JavaScript data. It performs a deep conversion, ensuring all nested objects become `Map`s and arrays become `List`s. This makes it easy to integrate Immutable.js into applications that might initially receive or generate plain JavaScript data.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "Immutable.js",
        "Data Structures",
        "Immutability",
        "Functional Programming",
        "State Management"
      ],
      "prerequisites": [
        "javascript_objects",
        "javascript_arrays",
        "functional_programming_basics"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "Immutable.js",
      "Data Structures",
      "Immutability",
      "Functional Programming",
      "State Management"
    ],
    "prerequisites": [
      "javascript_objects",
      "javascript_arrays",
      "functional_programming_basics"
    ]
  },
  {
    "index": 109,
    "id": "theory_dom_events",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 6,
    "title": "DOM Events and Event Handling",
    "description": "",
    "content": {
      "id": "theory_dom_events",
      "title": "DOM Events and Event Handling",
      "description": "",
      "type": "theory",
      "content": "## Introduction to DOM Events\nDOM (Document Object Model) events are signals sent by the browser to notify your code that something has happened on the web page. These events can be triggered by user interactions (like clicks, key presses, mouse movements), browser actions (like page loading, resizing), or even programmatically.\n\nEvents are a fundamental part of interactive web development, allowing JavaScript to react to user actions and update the UI dynamically.\n\n## Attaching Event Listeners\nThe most common way to handle events is using the `addEventListener()` method. This method allows you to register a function (the event handler) to be called whenever a specified event is delivered to the target.\n\n### Syntax:\n```typescript\ntarget.addEventListener(type, listener, [options]);\n```\n- `type`: A string representing the event type (e.g., 'click', 'mouseover', 'submit').\n- `listener`: The function to be called when the event occurs.\n- `options` (optional): An object that specifies characteristics about the event listener, such as:\n    - `capture`: A boolean indicating that events of this type will be dispatched to the registered `listener` before being dispatched to any `EventTarget` beneath it in the DOM tree. (Default: `false`, meaning bubbling phase).\n    - `once`: A boolean indicating that the `listener` should be invoked at most once after being added. If `true`, the `listener` would be automatically removed when invoked.\n    - `passive`: A boolean indicating that the `listener` will never call `preventDefault()`. If a listener calls `preventDefault()`, the user agent will still ignore it, but it will generate a console warning.\n\n### The Event Object\nWhen an event occurs, the browser creates an `Event` object and passes it as the first argument to the event handler function. This object contains important information about the event, such as:\n- `event.target`: The actual element on which the event occurred (the innermost element).\n- `event.currentTarget`: The element to which the event listener was attached.\n- `event.type`: The type of event (e.g., 'click').\n- `event.clientX`, `event.clientY`: Coordinates of the mouse pointer (for mouse events).\n- `event.key`, `event.keyCode`: Information about the key pressed (for keyboard events).\n\n## Event Bubbling and Capturing\nWhen an event is triggered on an element, it doesn't just stay on that element. It propagates through the DOM tree in two phases:\n1.  **Capturing Phase:** The event starts from the `window` object and travels down to the `event.target` (the actual element that triggered the event).\n2.  **Bubbling Phase:** The event then travels back up from the `event.target` to the `window` object.\n\nMost event listeners are registered for the bubbling phase by default. You can specify `capture: true` in the `addEventListener` options to listen during the capturing phase.\n\n## Event Delegation\nEvent delegation is a technique where you attach a single event listener to a parent element, rather than attaching individual listeners to multiple child elements. This technique relies on event bubbling.\n\n### Benefits of Event Delegation:\n-   **Performance:** Fewer event listeners mean less memory consumption and better performance, especially for lists with many items.\n-   **Dynamic Content:** It automatically handles events for elements that are added to the DOM dynamically *after* the initial page load, without needing to re-attach listeners.\n-   **Cleaner Code:** Reduces the amount of repetitive code.\n\n### How it works:\nThe event listener on the parent listens for events bubbling up from its children. Inside the handler, you can then check `event.target` to determine which specific child element triggered the event and react accordingly.\n\n## Custom Events\nBesides built-in browser events, you can create and dispatch your own custom events. This is useful for building loosely coupled components or for communicating between different parts of your application without direct dependencies.\n\n### `CustomEvent` Constructor:\n```typescript\nconst customEvent = new CustomEvent(type, [options]);\n```\n- `type`: A string representing the event type (e.g., 'myComponentReady').\n- `options` (optional): An object with properties:\n    - `detail`: A property that allows you to pass any custom data along with the event. This data can be accessed via `event.detail` in the event listener.\n    - `bubbles`: A boolean indicating whether the event should bubble up the DOM tree (default: `false`).\n    - `cancelable`: A boolean indicating whether the event is cancelable (default: `false`).\n\n### `dispatchEvent()` Method:\nAfter creating a custom event, you dispatch it on a specific DOM element using `element.dispatchEvent(eventObject)`.\nAny element on the DOM tree (or `document`, `window`) can dispatch an event, and any element can listen for it.",
      "examples": [
        {
          "id": "example_dom_events_1",
          "title": "Basic Event Listener",
          "code": "// index.html\n// <button id=\"myButton\">Click Me</button>\n\n// script.js\nconst myButton = document.getElementById('myButton');\n\nfunction handleClick(event) {\n  console.log('Button clicked!', event.target.textContent);\n  console.log('Event type:', event.type);\n}\n\nmyButton.addEventListener('click', handleClick);\n\n// Event listener with options (once)\nconst onceButton = document.getElementById('onceButton');\nif (onceButton) {\n  onceButton.addEventListener('click', () => {\n    console.log('This message will only show once.');\n  }, { once: true });\n}",
          "explanation": "This example demonstrates attaching a simple 'click' event listener to a button. When the button is clicked, the `handleClick` function is executed, logging information about the event target and type. The second part shows how to use the `once` option to make an event listener fire only a single time.",
          "language": "typescript"
        },
        {
          "id": "example_dom_events_2",
          "title": "Event Delegation",
          "code": "// index.html\n// <ul id=\"itemList\">\n//   <li>Item 1</li>\n//   <li>Item 2</li>\n//   <li>Item 3</li>\n// </ul>\n// <button id=\"addItemBtn\">Add New Item</button>\n\n// script.js\nconst itemList = document.getElementById('itemList');\nconst addItemBtn = document.getElementById('addItemBtn');\nlet itemCounter = 3;\n\n// Use event delegation on the parent <ul>\nitemList.addEventListener('click', function(event) {\n  // Check if the clicked element is an <li>\n  if (event.target.tagName === 'LI') {\n    console.log('Clicked on item:', event.target.textContent);\n    event.target.style.backgroundColor = 'yellow';\n  }\n});\n\n// Add new items dynamically\naddItemBtn.addEventListener('click', function() {\n  itemCounter++;\n  const newItem = document.createElement('li');\n  newItem.textContent = `Item ${itemCounter}`;\n  itemList.appendChild(newItem);\n  console.log(`Added new item: Item ${itemCounter}`);\n});",
          "explanation": "This example illustrates event delegation. Instead of attaching a listener to each `<li>` element, a single listener is attached to the parent `<ul>`. When any `<li>` is clicked, the event bubbles up to the `<ul>`. The handler then checks `event.target.tagName` to confirm it was an `<li>` and processes the click. This pattern correctly handles dynamically added `<li>` elements.",
          "language": "typescript"
        },
        {
          "id": "example_dom_events_3",
          "title": "Custom Events",
          "code": "// index.html\n// <div id=\"myComponent\">My Component</div>\n\n// script.js\nconst myComponent = document.getElementById('myComponent');\n\n// 1. Define a custom event\nconst componentReadyEvent = new CustomEvent('componentReady', {\n  detail: {\n    timestamp: new Date().toISOString(),\n    message: 'Component initialization complete!'\n  },\n  bubbles: true, // Allow the event to bubble up\n  cancelable: false\n});\n\n// 2. Attach a listener for the custom event\nmyComponent.addEventListener('componentReady', function(event) {\n  console.log('Custom event received on component:', event.type);\n  console.log('Detail data:', event.detail);\n});\n\n// A parent element can also listen due to bubbling\ndocument.body.addEventListener('componentReady', function(event) {\n  console.log('Custom event bubbled up to body:', event.type);\n  console.log('Detail data:', event.detail);\n});\n\n// 3. Dispatch the custom event after some logic (e.g., component setup)\nsetTimeout(() => {\n  console.log('Dispatching custom event...');\n  myComponent.dispatchEvent(componentReadyEvent);\n}, 1000);",
          "explanation": "This example shows how to create and dispatch a custom event. A `CustomEvent` named 'componentReady' is created with `detail` data and set to `bubble`. An event listener is attached to `myComponent` to catch this event. After a delay, the event is dispatched on `myComponent`. Because `bubbles: true` is set, a listener on `document.body` also receives the event, demonstrating event propagation for custom events.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "DOM",
        "Events",
        "Event Handling",
        "Event Delegation",
        "Custom Events",
        "JavaScript"
      ],
      "prerequisites": [
        "html_basics",
        "css_basics",
        "javascript_syntax",
        "dom_basics"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "DOM",
      "Events",
      "Event Handling",
      "Event Delegation",
      "Custom Events",
      "JavaScript"
    ],
    "prerequisites": [
      "html_basics",
      "css_basics",
      "javascript_syntax",
      "dom_basics"
    ]
  },
  {
    "index": 126,
    "id": "theory_transpilers_babel",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 6,
    "title": "Transpilers and Babel",
    "description": "",
    "content": {
      "id": "theory_transpilers_babel",
      "title": "Transpilers and Babel",
      "description": "",
      "type": "theory",
      "content": "## What is a Transpiler?\nIn modern web development, a transpiler (or source-to-source compiler) is a program that converts source code written in one programming language into source code in another programming language. This is distinct from a traditional compiler that converts source code into machine code or bytecode.\n\n## Babel\nBabel is a popular JavaScript transpiler that plays a crucial role in the modern frontend development workflow. Its primary function is to transform next-generation JavaScript (ECMAScript 2015+ or ES6+) into a backwards-compatible version of JavaScript that can run in current and older browsers or environments that do not fully support newer language features.\n\n### Why is Babel necessary?\nWeb browsers and Node.js environments often have varying levels of support for the latest ECMAScript features. By using Babel, developers can write code using cutting-edge JavaScript syntax (like arrow functions, `const`/`let`, classes, async/await, JSX, and TypeScript) and still ensure their applications are compatible with a wider range of target environments, improving accessibility and avoiding fragmented user experiences.\n\n### Key Concepts in Babel Configuration\n*   **Presets**: A preset is a shareable set of Babel plugins and/or options. They allow you to easily configure Babel for specific environments or language features without individually listing every single plugin. For instance, `@babel/preset-env` is a powerful preset that intelligently determines which Babel plugins are needed based on your target environments (e.g., specific browser versions or Node.js versions).\n*   **Plugins**: Plugins are specific transformations that Babel performs on your code. Each plugin typically handles one particular language feature. For example, `@babel/plugin-proposal-class-properties` allows you to use class field declarations (public and private class fields) which are a stage 3 ECMAScript proposal.\n\n### Configuration Example (`babel.config.js`)\nBabel's configuration is typically managed in a file like `babel.config.js` (for project-wide configuration) or `.babelrc` (for directory-specific configuration). The `module.exports` object defines the presets and plugins to be used.\n\n**Common options within `@babel/preset-env`:**\n*   `targets`: Specifies the environments you want to support. This can be a browserslist query string (e.g., `'> 1%', 'last 2 versions'`) or an object specifying specific browser versions or Node.js versions. Babel uses this to only apply transformations for features not supported by your target environments, optimizing bundle size and build time.\n*   `useBuiltIns`: When set to `'usage'` or `'entry'`, this option integrates with `core-js` to automatically polyfill ECMAScript features that are missing in your target environments, further enhancing compatibility.\n",
      "examples": [
        {
          "id": "example_babel_config",
          "title": "Babel Configuration for Modern JS",
          "code": "module.exports = {\n  presets: [\n    ['@babel/preset-env', {\n      targets: {\n        browsers: ['> 1%', 'last 2 versions', 'not dead']\n      },\n      useBuiltIns: 'usage',\n      corejs: 3 // Specify the core-js version for polyfills\n    }]\n  ],\n  plugins: [\n    '@babel/plugin-proposal-class-properties',\n    '@babel/plugin-transform-runtime' // Helps to avoid duplication of helper code\n  ]\n};",
          "explanation": "This configuration demonstrates a typical setup for Babel. It uses `@babel/preset-env` to transpile modern JavaScript features down to a version compatible with 99% of current browsers and the last two stable versions, excluding completely dead browsers. It also uses `useBuiltIns: 'usage'` and `corejs: 3` to automatically include polyfills only for the features actually used in the code and not supported by the target environments. The `@babel/plugin-proposal-class-properties` enables support for class field syntax, and `@babel/plugin-transform-runtime` helps reduce bundle size by preventing helper functions from being duplicated across multiple files.",
          "language": "javascript"
        },
        {
          "id": "example_es6_to_es5",
          "title": "ES6+ to ES5 Transpilation Example",
          "code": "// Input (ES6+)\nclass Greeter {\n  message = 'Hello';\n  constructor(name) {\n    this.name = name;\n  }\n  greet() {\n    return `${this.message}, ${this.name}!`\n  }\n}\nconst person = new Greeter('World');\nconsole.log(person.greet());\n\n// Output (transpiled ES5 by Babel, simplified)\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar Greeter = /*#__PURE__*/function () {\n  function Greeter(name) {\n    _classCallCheck(this, Greeter);\n\n    this.message = 'Hello';\n    this.name = name;\n  }\n\n  _createClass(Greeter, [{\n    key: \"greet\",\n    value: function greet() {\n      return \"\".concat(this.message, \", \").concat(this.name, \"!\");\n    }\n  }]);\n\n  return Greeter;\n}();\n\nvar person = new Greeter('World');\nconsole.log(person.greet());",
          "explanation": "This example illustrates how Babel transforms modern ES6+ JavaScript code (like classes, string literals with template syntax, and class properties) into older ES5 syntax. The original, cleaner ES6 code is on the left, and a simplified version of the Babel-transpiled ES5 output is on the right. Notice the use of helper functions (`_classCallCheck`, `_defineProperties`, `_createClass`) to mimic class behavior in ES5, and string concatenation replacing template literals.",
          "language": "javascript"
        }
      ],
      "complexity": 6,
      "tags": [
        "JavaScript",
        "Transpilers",
        "Babel",
        "ES6+",
        "Build Tools"
      ],
      "prerequisites": [
        "javascript_basics",
        "frontend_development_overview"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "JavaScript",
      "Transpilers",
      "Babel",
      "ES6+",
      "Build Tools"
    ],
    "prerequisites": [
      "javascript_basics",
      "frontend_development_overview"
    ]
  },
  {
    "index": 149,
    "id": "theory_fetch_api_promises",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 6,
    "title": "Asynchronous Operations: Fetch API and Promises",
    "description": "",
    "content": {
      "id": "theory_fetch_api_promises",
      "title": "Asynchronous Operations: Fetch API and Promises",
      "description": "",
      "type": "theory",
      "content": "Asynchronous operations are fundamental in modern web development, allowing applications to perform long-running tasks (like network requests) without blocking the main thread, thus maintaining a responsive user interface. The `Fetch API` provides a modern, flexible way to make network requests, replacing older methods like `XMLHttpRequest`.\n\n## The Fetch API\n`fetch()` is a global method that initiates a network request. It returns a `Promise` that resolves to the `Response` object representing the response to your request. A `Response` object is not directly the JSON data; it's an HTTP response. To extract the actual data (e.g., JSON, text, blob), you use methods like `response.json()`, `response.text()`, etc., which themselves return promises.\n\n## Promises\nPromises are objects representing the eventual completion or failure of an asynchronous operation and its resulting value. A Promise can be in one of three states:\n*   **Pending:** Initial state, neither fulfilled nor rejected.\n*   **Fulfilled (Resolved):** Meaning the operation completed successfully.\n*   **Rejected:** Meaning the operation failed.\n\n## Promise Chaining\nPromises allow for chaining `then()` calls to handle sequential asynchronous operations. Each `.then()` call returns a new promise, allowing you to chain subsequent operations. The `catch()` method is used to handle errors that occur anywhere in the promise chain.\n\n### Key Concepts\n-   `fetch(url, options)`: Initiates a network request.\n-   `Response` object: Represents the HTTP response. Contains methods to parse the body (`.json()`, `.text()`, etc.).\n-   `.then(onFulfilled, onRejected)`: Handles successful completion or rejection of a promise.\n-   `.catch(onRejected)`: A shorthand for `.then(null, onRejected)` for error handling.\n-   `.finally(onFinally)`: Executes a callback when the promise is settled (either fulfilled or rejected), regardless of the outcome.\n\n### Error Handling\n`fetch()` only rejects a promise if a network error occurs or if the request is aborted. It does **not** reject for HTTP error statuses (like 404 Not Found or 500 Internal Server Error). For these, you must check `response.ok` property (which is `true` for 2xx status codes) within the `.then()` block.\n",
      "examples": [
        {
          "id": "example_fetch_api_promises_1",
          "title": "Basic Fetch Request with Promise Chaining",
          "code": "async function fetchStockData(endpoint) {\n  try {\n    const response = await fetch(endpoint);\n    // Check if the response was successful (e.g., status 200-299)\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    // Update UI with new stock data\n    console.log('Updated stock data:', data);\n    return data;\n  } catch (error) {\n    console.error('Error fetching stock data:', error);\n    // Handle error in UI, e.g., display error message\n    throw error; // Re-throw to propagate the error if needed\n  }\n}\n\n// Original example from markdown (using .then/.catch)\nfunction fetchStockDataLegacy(endpoint) {\n  return fetch(endpoint)\n    .then(response => {\n      if (!response.ok) {\n        // Handle HTTP errors specifically\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return response.json();\n    })\n    .then(data => {\n      // Update UI with new stock data\n      console.log('Updated stock data:', data);\n      return data;\n    })\n    .catch(error => {\n      console.error('Error fetching stock data:', error);\n      // Handle error in UI\n    });\n}\n\n// Example Usage:\n// fetchStockData('/api/stocks');\n// fetchStockDataLegacy('/api/stocks');",
          "explanation": "This example demonstrates how to use the Fetch API with Promise chaining (`.then()`, `.catch()`) and also with modern `async/await` syntax for better readability. It highlights the importance of checking `response.ok` for HTTP error statuses, as `fetch` itself only rejects on network errors. The console logs show how to access and use the fetched data.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "asynchronous-javascript",
        "fetch-api",
        "promises",
        "error-handling",
        "web-apis"
      ],
      "prerequisites": [
        "javascript_basics",
        "callbacks"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "asynchronous-javascript",
      "fetch-api",
      "promises",
      "error-handling",
      "web-apis"
    ],
    "prerequisites": [
      "javascript_basics",
      "callbacks"
    ]
  },
  {
    "index": 159,
    "id": "theory_vanilla_js_spreadsheet",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 6,
    "title": "Interactive Spreadsheet with Vanilla JavaScript and DOM Manipulation",
    "description": "",
    "content": {
      "id": "theory_vanilla_js_spreadsheet",
      "title": "Interactive Spreadsheet with Vanilla JavaScript and DOM Manipulation",
      "description": "",
      "type": "theory",
      "content": "This section details the implementation of a basic interactive spreadsheet using vanilla JavaScript and direct DOM manipulation. It serves as a practical example for understanding how to create dynamic HTML structures, handle user input through events, and manage an application's state within a class-based architecture without external frameworks.\n\n## Core Concepts\n-   **DOM Manipulation**: The fundamental technique involves creating, appending, and removing HTML elements (tables, rows, cells, input fields, and buttons) dynamically using JavaScript APIs like `document.createElement()`, `appendChild()`, `removeChild()`, and manipulating `innerHTML`. This provides granular control over the webpage structure.\n-   **Event Handling**: User interactions, such as typing in a cell or clicking buttons, are captured using event listeners (`addEventListener`). The `input` event is particularly important for real-time updates of cell data as the user types, while `click` events trigger actions like adding or removing rows/columns.\n-   **Class-Based Structure**: The entire spreadsheet logic is encapsulated within a `Spreadsheet` class. This object-oriented approach promotes modularity, organizes related data (like `rows`, `cols`, `data` array) and behaviors (like `render`, `addRow`, `update`), and facilitates reusability.\n-   **Data Model (`this.data`)**: The spreadsheet's content is maintained in a 2D array, where `this.data[rowIndex][colIndex]` stores the value of a specific cell. This array acts as the single source of truth for the spreadsheet's state.\n-   **Dynamic Sizing**: Methods such as `addRow()`, `addColumn()`, `removeRow()`, and `removeColumn()` demonstrate how to dynamically modify the `this.data` array and update the spreadsheet's dimensions (`this.rows`, `this.cols`). These methods leverage array manipulation techniques like `push()` and `splice()`.\n-   **Re-rendering Strategy (`update()`)**: The `update()` method re-renders the entire HTML table whenever the underlying data model changes. It achieves this by clearing the contents of the `spreadsheet-container` element (`innerHTML = ''`) and then re-appending a newly generated table via `this.render()`. While simple to implement, this full re-render strategy can be inefficient for very large datasets due to the overhead of recreating the entire DOM structure.\n\n## Implementation Details\n\n### `Spreadsheet` Class Initialization\nThe constructor sets up the initial dimensions and populates the `data` array with empty strings.\n\n```javascript\nclass Spreadsheet {\n  constructor(rows, cols) {\n    this.rows = rows;\n    this.cols = cols;\n    // Initialize data as a 2D array filled with empty strings\n    this.data = Array(rows).fill(null).map(() => Array(cols).fill(''));\n  }\n  // ... other methods\n}\n```\n\n### `render()` Method for UI Generation\nThis method dynamically creates all the necessary HTML elements for the table, including headers, data cells (with input fields), and control buttons. It attaches event listeners to these elements to enable interactivity.\n\n```javascript\nrender() {\n  const table = document.createElement('table');\n  const thead = document.createElement('thead');\n  const tbody = document.createElement('tbody');\n\n  // Header row for column labels and 'add column' button\n  const headerTr = document.createElement('tr');\n  headerTr.innerHTML = '<th></th>'; // Empty corner cell for alignment\n\n  for (let c = 0; c < this.cols; c++) {\n    const th = document.createElement('th');\n    th.textContent = String.fromCharCode(65 + c); // Column A, B, C...\n    const removeColBtn = document.createElement('button');\n    removeColBtn.textContent = 'x';\n    removeColBtn.className = 'remove-btn'; // For styling\n    // Using an IIFE to capture the correct 'c' value for each listener\n    ((colIndex) => {\n        removeColBtn.addEventListener('click', () => this.removeColumn(colIndex));\n    })(c);\n    th.appendChild(removeColBtn);\n    headerTr.appendChild(th);\n  }\n\n  const addColTh = document.createElement('th');\n  const addColButton = document.createElement('button');\n  addColButton.textContent = '+';\n  addColButton.addEventListener('click', () => this.addColumn());\n  addColTh.appendChild(addColButton);\n  headerTr.appendChild(addColTh);\n  thead.appendChild(headerTr);\n  table.appendChild(thead);\n\n  // Data rows and row headers\n  for (let r = 0; r < this.rows; r++) {\n    const tr = document.createElement('tr');\n    const th = document.createElement('th');\n    th.textContent = (r + 1).toString(); // Row 1, 2, 3...\n    const removeRowBtn = document.createElement('button');\n    removeRowBtn.textContent = 'x';\n    removeRowBtn.className = 'remove-btn';\n    ((rowIndex) => {\n        removeRowBtn.addEventListener('click', () => this.removeRow(rowIndex));\n    })(r);\n    th.appendChild(removeRowBtn);\n    tr.appendChild(th);\n\n    for (let c = 0; c < this.cols; c++) {\n      const td = document.createElement('td');\n      const input = document.createElement('input');\n      input.type = 'text';\n      input.value = this.data[r][c];\n      input.dataset.row = r.toString(); // Store row index as data attribute\n      input.dataset.col = c.toString(); // Store column index as data attribute\n      input.addEventListener('input', (e) => {\n        // Update the internal data model when an input changes\n        this.data[parseInt(e.target.dataset.row)][parseInt(e.target.dataset.col)] = e.target.value;\n      });\n      td.appendChild(input);\n      tr.appendChild(td);\n    }\n    tbody.appendChild(tr);\n  }\n\n  // 'Add Row' button at the bottom of the table\n  const addRowTr = document.createElement('tr');\n  const addRowTh = document.createElement('th');\n  const addRowButton = document.createElement('button');\n  addRowButton.textContent = '+';\n  addRowButton.addEventListener('click', () => this.addRow());\n  addRowTh.appendChild(addRowButton);\n  addRowTr.appendChild(addRowTh); // This 'th' acts as the button container for the new row\n  // Append empty 'td' elements to fill the rest of the row, matching column count\n  for (let i = 0; i < this.cols; i++) {\n      addRowTr.appendChild(document.createElement('td'));\n  }\n  tbody.appendChild(addRowTr);\n  \n  table.appendChild(tbody);\n  return table;\n}\n```\n\n### Data Modification Methods\nThese methods directly manipulate the `this.data` array and update the `rows` or `cols` count, then trigger a UI refresh via `update()`.\n\n```javascript\naddRow() {\n  this.data.push(Array(this.cols).fill(''));\n  this.rows++;\n  this.update();\n}\n\naddColumn() {\n  for (let i = 0; i < this.rows; i++) {\n    this.data[i].push('');\n  }\n  this.cols++;\n  this.update();\n}\n\nremoveRow(rowIndex) {\n  if (rowIndex >= 0 && rowIndex < this.rows) {\n    this.data.splice(rowIndex, 1); // Remove 1 element at rowIndex\n    this.rows--;\n    this.update();\n  }\n}\n\nremoveColumn(colIndex) {\n  if (colIndex >= 0 && colIndex < this.cols) {\n    for (let i = 0; i < this.rows; i++) {\n      this.data[i].splice(colIndex, 1); // Remove 1 element at colIndex from each row\n    }\n    this.cols--;\n    this.update();\n  }\n}\n```\n\n### `update()` Method for View Synchronization\nThis method is critical for keeping the DOM in sync with the internal `this.data` model. It ensures that any changes to the spreadsheet's dimensions or data are reflected in the user interface.\n\n```javascript\nupdate() {\n  const spreadsheetContainer = document.getElementById('spreadsheet-container');\n  spreadsheetContainer.innerHTML = ''; // Clears all children\n  spreadsheetContainer.appendChild(this.render()); // Re-creates and appends the new table\n}\n```\n\n## Usage\nThe spreadsheet instance is created and appended to a designated container (`spreadsheet-container`) once the entire DOM content has been loaded, ensuring that the target element exists.\n\n```javascript\ndocument.addEventListener('DOMContentLoaded', () => {\n  const spreadsheet = new Spreadsheet(10, 8); // Example: 10 rows, 8 columns\n  const container = document.getElementById('spreadsheet-container');\n  container.appendChild(spreadsheet.render());\n});\n```",
      "examples": [
        {
          "id": "example_spreadsheet_constructor",
          "title": "Spreadsheet Class Initialization",
          "code": "class Spreadsheet {\n  constructor(rows, cols) {\n    this.rows = rows;\n    this.cols = cols;\n    // Initialize a 2D array with empty strings\n    this.data = Array(rows).fill(null).map(() => Array(cols).fill(''));\n    // Example: Populate some initial data for demonstration\n    this.data[0][0] = 'Product';\n    this.data[0][1] = 'Price';\n    this.data[1][0] = 'Laptop';\n    this.data[1][1] = '1200';\n  }\n  \n  // ... other methods\n}\n\nconst mySpreadsheet = new Spreadsheet(2, 2);\nconsole.log(mySpreadsheet.data);\n/* Output:\n[\n  ['Product', 'Price'],\n  ['Laptop', '1200']\n]\n*/",
          "explanation": "This example illustrates the `Spreadsheet` constructor, showing how `rows`, `cols`, and the `data` 2D array are initialized. It also includes a basic setup to pre-fill a couple of cells, demonstrating how the internal data model holds the spreadsheet's content.",
          "language": "javascript"
        },
        {
          "id": "example_spreadsheet_add_remove_row_col",
          "title": "Adding and Removing Rows/Columns Logic",
          "code": "class Spreadsheet {\n  constructor(rows, cols) {\n    this.rows = rows;\n    this.cols = cols;\n    this.data = Array(rows).fill(null).map(() => Array(cols).fill(''));\n  }\n\n  addRow() {\n    this.data.push(Array(this.cols).fill(''));\n    this.rows++;\n    this.update(); // Assumes update method exists for UI refresh\n  }\n\n  removeRow(rowIndex) {\n    if (rowIndex >= 0 && rowIndex < this.rows) {\n      this.data.splice(rowIndex, 1);\n      this.rows--;\n      this.update();\n    }\n  }\n\n  addColumn() {\n    for (let i = 0; i < this.rows; i++) {\n      this.data[i].push('');\n    }\n    this.cols++;\n    this.update();\n  }\n\n  removeColumn(colIndex) {\n    if (colIndex >= 0 && colIndex < this.cols) {\n      for (let i = 0; i < this.rows; i++) {\n        this.data[i].splice(colIndex, 1);\n      }\n      this.cols--;\n      this.update();\n    }\n  }\n\n  update() {\n    // In a real application, this would trigger a DOM re-render.\n    // For this example, we just log the changes.\n    console.log('Spreadsheet state updated. Current data:', this.data);\n    console.log(`Current dimensions: Rows=${this.rows}, Cols=${this.cols}`);\n  }\n}\n\nconst spreadsheet = new Spreadsheet(2, 2);\nconsole.log('Initial data:', JSON.stringify(spreadsheet.data));\n\nspreadsheet.addRow();\nconsole.log('After addRow:', JSON.stringify(spreadsheet.data));\n\nspreadsheet.removeRow(0);\nconsole.log('After removeRow(0):', JSON.stringify(spreadsheet.data));\n\nspreadsheet.addColumn();\nconsole.log('After addColumn:', JSON.stringify(spreadsheet.data));\n\nspreadsheet.removeColumn(0);\nconsole.log('After removeColumn(0):', JSON.stringify(spreadsheet.data));",
          "explanation": "This example specifically demonstrates the internal logic of the `addRow`, `removeRow`, `addColumn`, and `removeColumn` methods. It shows how they modify the `data` array and the `rows`/`cols` properties. The `update()` call within these methods ensures that the UI (in a full implementation) would be synchronized with these data changes. The `JSON.stringify` is used for clearer console output of the array state.",
          "language": "javascript"
        }
      ],
      "complexity": 6,
      "tags": [
        "Vanilla JS",
        "DOM Manipulation",
        "Classes",
        "Data Structures",
        "Frontend Architecture",
        "Event Handling"
      ],
      "prerequisites": [
        "HTML",
        "CSS",
        "Basic JavaScript Syntax",
        "Arrays",
        "Functions"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "Vanilla JS",
      "DOM Manipulation",
      "Classes",
      "Data Structures",
      "Frontend Architecture",
      "Event Handling"
    ],
    "prerequisites": [
      "HTML",
      "CSS",
      "Basic JavaScript Syntax",
      "Arrays",
      "Functions"
    ]
  },
  {
    "index": 0,
    "id": "theory_javascript_engine_execution_context",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "JavaScript Engine: Execution Context",
    "description": "",
    "content": {
      "id": "theory_javascript_engine_execution_context",
      "title": "JavaScript Engine: Execution Context",
      "description": "",
      "type": "theory",
      "content": "The **Execution Context** is the environment in which JavaScript code is evaluated and executed. Whenever a function is called, or the global code starts running, a new execution context is created. It's an abstract concept that holds information about the current execution environment.\n\nEach execution context has three crucial components:\n\n1.  **Variable Environment**: This is where `var` declarations and function declarations are stored. In ES6+, `let` and `const` declarations are also managed here but are initialized differently (e.g., in the Temporal Dead Zone).\n2.  **Scope Chain**: This is a list of all accessible variable environments in the current context. It's used to resolve the value of variables. When JavaScript tries to find a variable, it first looks in the current execution context's variable environment, then in its outer environment, and so on, up the scope chain until it reaches the global execution context.\n3.  **`this` Binding**: This determines the value of the `this` keyword within the execution context. Its value depends on how the function was called (e.g., global, method, constructor, explicit binding with `call`/`apply`/`bind`, or arrow functions).\n\nThere are three main types of Execution Contexts:\n\n*   **Global Execution Context (GEC)**: The default or base execution context. It's created when the JavaScript file first loads. Anything not inside a function is in the global context. There's only one GEC.\n*   **Function Execution Context (FEC)**: Created whenever a function is called. Each function call creates its own unique FEC. This is why variables inside a function are local to it.\n*   **Eval Execution Context**: Created for code executed inside an `eval()` function. This is generally discouraged due to security and performance implications.\n\nJavaScript engines manage these contexts using a **Call Stack**. The Call Stack is a LIFO (Last In, First Out) data structure that keeps track of all the execution contexts created during the execution of a script. When an execution context is finished, it is popped off the stack.",
      "examples": [
        {
          "id": "example_execution_context_1",
          "title": "Global and Function Execution Contexts",
          "code": "let globalVar = 'I am global';\n\nfunction outerFunction() {\n  let outerVar = 'I am in outer';\n\n  function innerFunction() {\n    let innerVar = 'I am in inner';\n    console.log(globalVar);  // Accesses global execution context\n    console.log(outerVar);   // Accesses outer function's execution context (closure)\n    console.log(innerVar);   // Accesses its own execution context\n  }\n\n  innerFunction();\n}\n\nouterFunction();",
          "explanation": "This example demonstrates the creation of multiple execution contexts. When the script loads, the Global Execution Context is created. When `outerFunction()` is called, a new Function Execution Context for `outerFunction` is pushed onto the Call Stack. Similarly, when `innerFunction()` is called, its own Function Execution Context is pushed. Variables are resolved by traversing the scope chain upwards through these contexts.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "JavaScript Core",
        "Execution Context",
        "Call Stack",
        "Scope",
        "This"
      ],
      "prerequisites": [
        "javascript_fundamentals",
        "functions"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "JavaScript Core",
      "Execution Context",
      "Call Stack",
      "Scope",
      "This"
    ],
    "prerequisites": [
      "javascript_fundamentals",
      "functions"
    ]
  },
  {
    "index": 1,
    "id": "theory_event_loop",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "The JavaScript Event Loop",
    "description": "",
    "content": {
      "id": "theory_event_loop",
      "title": "The JavaScript Event Loop",
      "description": "",
      "type": "theory",
      "content": "The JavaScript Event Loop is a crucial concept for understanding how JavaScript handles asynchronous operations despite being single-threaded. JavaScript executes code line by line in a single call stack. When it encounters asynchronous operations (like `setTimeout`, `fetch`, `Promise`), it offloads them to Web APIs (or Node.js APIs in a Node environment).\n\n### Key Components:\n\n1.  **Call Stack**: Where synchronous code is executed. Functions are pushed onto the stack when called and popped off when they return.\n2.  **Web APIs**: Provided by the browser (or C++ APIs in Node.js) to handle asynchronous tasks like DOM events, HTTP requests (`fetch`), and timers (`setTimeout`, `setInterval`). When a Web API completes its task, it places a corresponding callback function into a queue.\n3.  **Callback Queue (Task Queue / Macrotask Queue)**: This queue holds callback functions for macrotasks (e.g., `setTimeout`, `setInterval`, I/O, UI rendering). When the Call Stack is empty, the Event Loop picks one callback from this queue and pushes it to the Call Stack for execution.\n4.  **Microtask Queue**: This queue holds callback functions for microtasks (e.g., Promise callbacks (`.then()`, `.catch()`, `.finally()`), `queueMicrotask`, `MutationObserver`). The Event Loop prioritizes the Microtask Queue. It processes *all* microtasks in the Microtask Queue *before* picking any macrotask from the Callback Queue, as long as the Call Stack is empty.\n\n### How it Works (The Loop):\n\nThe Event Loop continuously monitors the Call Stack and the various task queues. Its job is to:\n\n*   When the Call Stack is empty, it checks the Microtask Queue. If there are microtasks, it moves *all* of them (one by one) to the Call Stack for execution, emptying the Microtask Queue.\n*   After the Microtask Queue is empty (or if it was empty to begin with), if the Call Stack is still empty, the Event Loop checks the Callback Queue (Macrotask Queue). It picks *one* macrotask from the Callback Queue and moves it to the Call Stack for execution.\n*   This cycle repeats indefinitely.\n\nThis prioritization means that Promises will often execute their `.then()` callbacks before `setTimeout` callbacks, even if the `setTimeout` has a delay of 0ms.\n\n### Example Flow Trace:\n\nConsider the following code snippet:\n\n```javascript\nconsole.log('Script start');\n\nsetTimeout(() => {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise resolved');\n});\n\nconsole.log('Script end');\n```\n\n1.  `console.log('Script start')` is executed immediately. Output: `Script start`.\n2.  `setTimeout(() => { console.log('setTimeout'); }, 0)` is encountered. The callback `() => { console.log('setTimeout'); }` is sent to the Web API for timers. After 0ms (or minimum browser delay, usually 4ms for HTML5 spec), the Web API places this callback into the **Callback Queue**.\n3.  `Promise.resolve().then(() => { console.log('Promise resolved'); })` is encountered. `Promise.resolve()` immediately resolves a Promise. Its `.then()` callback `() => { console.log('Promise resolved'); }` is placed into the **Microtask Queue**.\n4.  `console.log('Script end')` is executed immediately. Output: `Script end`.\n5.  The global script execution finishes. The Call Stack is now empty.\n6.  The Event Loop checks the **Microtask Queue**. It finds `() => { console.log('Promise resolved'); }` and moves it to the Call Stack.\n7.  `console.log('Promise resolved')` executes. Output: `Promise resolved`.\n8.  The Microtask Queue is now empty. The Call Stack is empty.\n9.  The Event Loop checks the **Callback Queue**. It finds `() => { console.log('setTimeout'); }` and moves it to the Call Stack.\n10. `console.log('setTimeout')` executes. Output: `setTimeout`.\n11. The Callback Queue is now empty. The Call Stack is empty. The Event Loop continues its cycle.\n\n**Final Output Order:**\n```\nScript start\nScript end\nPromise resolved\nsetTimeout\n```\nThis order highlights the microtask queue's priority over the macrotask queue.",
      "examples": [
        {
          "id": "example_event_loop_basic_flow",
          "title": "Event Loop Basic Flow Demonstration",
          "code": "console.log('Script start');\n\nsetTimeout(() => {\n  console.log('setTimeout 1');\n  Promise.resolve().then(() => {\n    console.log('Promise resolved 2 (inside setTimeout)');\n  });\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise resolved 1');\n  setTimeout(() => {\n    console.log('setTimeout 2 (inside Promise)');\n  }, 0);\n});\n\nconsole.log('Script end');\n\n// Expected Output:\n// Script start\n// Script end\n// Promise resolved 1\n// Promise resolved 2 (inside setTimeout)\n// setTimeout 1\n// setTimeout 2 (inside Promise)",
          "explanation": "This example demonstrates a more complex interaction. `Script start` and `Script end` execute first. Then, `Promise resolved 1` (microtask) executes before `setTimeout 1` (macrotask). Inside `Promise resolved 1`, a new `setTimeout 2` is queued as a macrotask. Inside `setTimeout 1`, a new `Promise resolved 2` is queued as a microtask. When `setTimeout 1` executes, `Promise resolved 2` goes to the microtask queue, which is processed *before* any new macrotasks (like `setTimeout 2` or the *next* macrotask in general). Thus, `Promise resolved 2` executes before `setTimeout 1` *finishes* its execution (in the context of the next loop iteration of macrotasks), and `setTimeout 2` gets picked up even later.",
          "language": "javascript"
        }
      ],
      "complexity": 9,
      "tags": [
        "Event Loop",
        "Asynchronous JavaScript",
        "Concurrency Model",
        "Promises",
        "setTimeout",
        "Microtasks",
        "Macrotasks"
      ],
      "prerequisites": [
        "Callbacks",
        "Promises"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "Event Loop",
      "Asynchronous JavaScript",
      "Concurrency Model",
      "Promises",
      "setTimeout",
      "Microtasks",
      "Macrotasks"
    ],
    "prerequisites": [
      "Callbacks",
      "Promises"
    ]
  },
  {
    "index": 2,
    "id": "theory_singleton_pattern",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Singleton Pattern",
    "description": "",
    "content": {
      "id": "theory_singleton_pattern",
      "title": "Singleton Pattern",
      "description": "",
      "type": "theory",
      "content": "The Singleton pattern is a creational design pattern that ensures a class has only one instance and provides a global point of access to that instance. It's useful when you need to coordinate actions across the system from a single, centralized object, such as a database connection, a configuration manager, or a logger.\n\n## Key Concepts\n-   **Single Instance:** Guarantees that only one object of a particular class can be instantiated.\n-   **Global Access:** Provides a well-known global point of access to that single instance.\n-   **Lazy Initialization:** The instance is often created only when it's first requested, saving resources if the instance is not always needed immediately.\n-   **Self-Encapsulation:** The Singleton class itself is responsible for managing its single instance.\n\n## Implementation in JavaScript\nIn JavaScript, the Singleton pattern is typically implemented using an Immediately Invoked Function Expression (IIFE) and a closure to maintain a private `instance` variable. The IIFE executes once and returns an object with a `getInstance` method. This method checks if an instance already exists; if not, it creates one and stores it, ensuring subsequent calls return the same instance.\n\n## Advantages\n-   **Controlled Access to Sole Instance:** Clients can access the instance only through the controlled `getInstance` method.\n-   **Reduced Namespace Pollution:** Avoids polluting the global namespace with numerous global variables.\n-   **Resource Management:** Useful for managing shared resources (e.g., database connections, file systems) to prevent conflicts and ensure efficient usage.\n-   **Lazy Instantiation:** The instance is created only when needed.\n\n## Disadvantages\n-   **Global State:** Can lead to tightly coupled code and make unit testing difficult due to shared global state.\n-   **Testing Challenges:** Mocking or isolating singletons for testing can be complex.\n-   **Violation of Single Responsibility Principle:** The class takes on two responsibilities: creating its own instance and performing its core business logic.",
      "examples": [
        {
          "id": "example_singleton_1",
          "title": "Basic Singleton Implementation",
          "code": "const Singleton = (function() {\n  let instance;\n  \n  function createInstance() {\n    // This function creates the actual object instance\n    return {\n      data: [],\n      addItem: function(item) {\n        this.data.push(item);\n        console.log(`Item added: ${item}. Current data: ${this.data}`);\n      },\n      getData: function() {\n        return this.data;\n      }\n    };\n  }\n  \n  return {\n    // The public method to get the single instance\n    getInstance: function() {\n      if (!instance) {\n        instance = createInstance(); // Create instance only if it doesn't exist\n      }\n      return instance;\n    }\n  };\n})();\n\nconst instance1 = Singleton.getInstance();\ninstance1.addItem('Apple');\n\nconst instance2 = Singleton.getInstance();\ninstance2.addItem('Banana');\n\nconsole.log(instance1 === instance2); // true - Both variables reference the exact same object\nconsole.log(instance1.getData()); // ['Apple', 'Banana'] - Data is shared\nconsole.log(instance2.getData()); // ['Apple', 'Banana']\n",
          "explanation": "This example demonstrates the classic JavaScript Singleton pattern using an IIFE. The `createInstance` function defines the actual object that will be single. The `getInstance` method within the returned object ensures that `createInstance` is called only once, lazily initializing the `instance` variable. Subsequent calls to `getInstance` simply return the already created instance, proving that `instance1` and `instance2` are indeed the same object.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "design-patterns",
        "creational-patterns",
        "javascript",
        "architecture",
        "state-management"
      ],
      "prerequisites": [
        "iife",
        "closures",
        "object-oriented-programming"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "design-patterns",
      "creational-patterns",
      "javascript",
      "architecture",
      "state-management"
    ],
    "prerequisites": [
      "iife",
      "closures",
      "object-oriented-programming"
    ]
  },
  {
    "index": 4,
    "id": "theory_strategy_pattern",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Strategy Design Pattern",
    "description": "",
    "content": {
      "id": "theory_strategy_pattern",
      "title": "Strategy Design Pattern",
      "description": "",
      "type": "theory",
      "content": "The Strategy design pattern is a behavioral design pattern that enables selecting an algorithm's behavior at runtime. It defines a family of algorithms, encapsulates each one, and makes them interchangeable. This pattern allows the client to choose the desired algorithm (strategy) without knowing the concrete implementation details of that algorithm, promoting flexibility and extensibility.\n\n## Core Components:\n\n1.  **Context**: Holds a reference to a Strategy object and delegates the request to the Strategy. It does not know the concrete strategy it's using.\n2.  **Strategy (Interface/Abstract Class)**: Declares an interface common to all supported algorithms. Context uses this interface to call the algorithm defined by a Concrete Strategy.\n3.  **Concrete Strategy**: Implements the Strategy interface, providing a specific algorithm.\n\n## Benefits:\n\n*   **Flexibility**: Algorithms can be changed at runtime.\n*   **Extensibility**: New strategies can be added easily without modifying the Context.\n*   **Maintainability**: Reduces conditional statements in the Context by encapsulating varying behaviors into separate classes.\n*   **Reusability**: Strategies can be reused across different contexts or parts of an application.",
      "examples": [
        {
          "id": "example_strategy_pattern_1",
          "title": "Shipping Cost Calculation with Strategy Pattern",
          "code": "class Shipping {\n  constructor() {\n    this.strategy = null;\n  }\n\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  calculate(order) {\n    return this.strategy.calculate(order);\n  }\n}\n\n// Strategy Interface (implicit in JS)\n// class ShippingStrategy {\n//   calculate(order) { throw new Error('Method must be implemented'); }\n// }\n\n// Concrete Strategies\nclass FedEx {\n  calculate(order) {\n    // Complex FedEx logic based on weight, distance, etc.\n    return 5 + (order.weight * 0.5);\n  }\n}\n\nclass UPS {\n  calculate(order) {\n    // Complex UPS logic\n    return 4 + (order.weight * 0.4);\n  }\n}\n\nclass USPS {\n  calculate(order) {\n    // Complex USPS logic\n    return 3 + (order.weight * 0.3);\n  }\n}\n\nconst shipping = new Shipping();\nconst order = { weight: 10 };\n\nshipping.setStrategy(new FedEx());\nconsole.log(`FedEx: $${shipping.calculate(order)}`);\n\nshipping.setStrategy(new UPS());\nconsole.log(`UPS: $${shipping.calculate(order)}`);\n\nshipping.setStrategy(new USPS());\nconsole.log(`USPS: $${shipping.calculate(order)}`);",
          "explanation": "This example demonstrates how different shipping carriers (FedEx, UPS, USPS) are implemented as concrete strategies. The `Shipping` class acts as the Context, setting and using the chosen strategy to calculate shipping costs. This allows easily switching between shipping methods without altering the `Shipping` class itself, showcasing the pattern's flexibility.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "design-patterns",
        "behavioral-patterns",
        "oop",
        "javascript"
      ],
      "prerequisites": [
        "object-oriented-programming",
        "polymorphism"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "design-patterns",
      "behavioral-patterns",
      "oop",
      "javascript"
    ],
    "prerequisites": [
      "object-oriented-programming",
      "polymorphism"
    ]
  },
  {
    "index": 5,
    "id": "theory_type_coercion",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "JavaScript Type Coercion and Operator Behavior",
    "description": "",
    "content": {
      "id": "theory_type_coercion",
      "title": "JavaScript Type Coercion and Operator Behavior",
      "description": "",
      "type": "theory",
      "content": "Type coercion in JavaScript is the automatic or implicit conversion of values from one data type to another. This is a common source of unexpected behavior, especially when using loose equality (`==`) or arithmetic operators.\n\n## Implicit Type Coercion Rules\nJavaScript attempts to convert operands to a compatible type before performing an operation. This conversion is often guided by internal operations like `ToPrimitive`, `ToNumber`, `ToString`, and `ToBoolean`.\n\n### The `+` Operator\n- If one of the operands is a string, the `+` operator performs string concatenation. Both operands are converted to strings (via `ToString`).\n- Otherwise, both operands are converted to numbers (via `ToNumber`) and addition is performed.\n\n### Arithmetic Operators (`-`, `*`, `/`, `%`)\n- These operators always attempt to convert both operands to numbers (via `ToNumber`).\n- If a value cannot be meaningfully converted to a number, the result is `NaN` (Not-a-Number).\n\n### Loose Equality (`==`) vs Strict Equality (`===`)\n- The `==` (loose equality) operator performs type coercion before comparison. If the operands are of different types, JavaScript tries to convert one or both to a common type.\n- The `===` (strict equality) operator compares both the value and the type without any type coercion. This is generally preferred to avoid unexpected behavior.\n\n### Division by Zero\n- In JavaScript, dividing a number by zero does not throw an error but results in `Infinity` for positive numbers and `-Infinity` for negative numbers. Dividing `0` by `0` results in `NaN`.\n\n### Operations with `undefined` and `null`\n- `null` typically converts to `0` in numeric contexts (e.g., `null + 1` is `1`), but `undefined` typically converts to `NaN` (e.g., `undefined + 1` is `NaN`).\n- When comparing with `==`:\n    - `null == undefined` is `true`.\n    - `null` is only `==` to `null` or `undefined`.\n    - `undefined` is only `==` to `undefined` or `null`.\n\n### Logical Operators (`&&`, `||`)\n- Logical operators `&&` (AND) and `||` (OR) are \"short-circuiting\" and return the value of one of their operands, not necessarily a boolean `true` or `false`.\n    - `A && B`: Returns `A` if `A` is falsy, otherwise returns `B`.\n    - `A || B`: Returns `A` if `A` is truthy, otherwise returns `B`.\n\n### Object Property Access\n- When accessing object properties, numeric string keys and number keys are treated as equivalent (e.g., `obj['1']` is the same as `obj[1]`).\n",
      "examples": [
        {
          "id": "example_coercion_1",
          "title": "Complex Coercion Scenario",
          "code": "const result1 = [] + false - null + true;\n// Breakdown:\n// 1. [] + false  \n//    [] (ToPrimitive) -> \"\"\n//    false (ToString) -> \"false\"\n//    \"\" + \"false\" -> \"false\" (string concatenation)\n// 2. \"false\" - null\n//    \"false\" (ToNumber) -> NaN\n//    null (ToNumber) -> 0\n//    NaN - 0 -> NaN\n// 3. NaN + true\n//    NaN + true (ToNumber) -> NaN\n//    NaN + 1 -> NaN\nconsole.log(result1); // NaN",
          "explanation": "This example demonstrates a complex series of type coercions involving array to string, boolean to string/number, and null to number conversions. The presence of `NaN` in an arithmetic operation propagates `NaN` through subsequent operations.",
          "language": "javascript"
        },
        {
          "id": "example_coercion_2",
          "title": "Division by Zero and Undefined Operations",
          "code": "let result2 = 5 / 0; // Infinity\nlet negativeResult2 = -5 / 0; // -Infinity\nlet zeroByZero = 0 / 0; // NaN\nlet undefinedAddition = 5 + undefined; // NaN\nlet nullAddition = 5 + null; // 5\n\nconsole.log(result2, negativeResult2, zeroByZero, undefinedAddition, nullAddition);",
          "explanation": "This illustrates JavaScript's handling of division by zero, which yields `Infinity` or `-Infinity`, and `0/0` which yields `NaN`. It also shows the different numeric coercions of `undefined` (to `NaN`) and `null` (to `0`).",
          "language": "javascript"
        },
        {
          "id": "example_coercion_3",
          "title": "Loose vs. Strict Equality",
          "code": "console.log(0 == false);    // true (0 is loosely equal to false)\nconsole.log(0 === false);   // false (different types)\nconsole.log('1' == 1);      // true (string '1' converted to number 1)\nconsole.log('1' === 1);     // false (different types)\nconsole.log(null == undefined); // true\nconsole.log(null === undefined); // false\nconsole.log([] == 0);       // true ([] -> \"\" -> 0)\nconsole.log([] == \"\");     // true ([] -> \"\")",
          "explanation": "This example highlights the key differences between loose (`==`) and strict (`===`) equality. Loose equality often leads to unexpected results due to implicit type conversions, whereas strict equality avoids this by requiring both value and type to be identical.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "type-coercion",
        "javascript-fundamentals",
        "operators",
        "equality",
        "NaN",
        "infinity"
      ],
      "prerequisites": [
        "javascript_datatypes",
        "javascript_operators"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "type-coercion",
      "javascript-fundamentals",
      "operators",
      "equality",
      "NaN",
      "infinity"
    ],
    "prerequisites": [
      "javascript_datatypes",
      "javascript_operators"
    ]
  },
  {
    "index": 7,
    "id": "theory_memoization",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Memoization: Caching Function Results for Performance",
    "description": "",
    "content": {
      "id": "theory_memoization",
      "title": "Memoization: Caching Function Results for Performance",
      "description": "",
      "type": "theory",
      "content": "Memoization is an optimization technique used to speed up computer programs by caching the results of expensive function calls and returning the cached result when the same inputs occur again. It's particularly useful for pure functions (functions that always produce the same output for the same input and have no side effects) and recursive functions where the same sub-problems are computed multiple times.\n\n### How Memoization Works\nAt its core, memoization involves:\n1.  **Caching**: Storing the function's output in a data structure (e.g., an object or Map) against its input arguments.\n2.  **Key Generation**: Creating a unique key from the function's arguments to store and retrieve results. For simple arguments, direct use might work, but for complex arguments (objects, arrays), serialization (like `JSON.stringify`) or custom hashing is often needed.\n3.  **Context Preservation**: Ensuring that the original function's `this` context is maintained when the function is actually executed (i.e., when a cache miss occurs).\n\n### Benefits\n-   **Performance Improvement**: Avoids redundant computations, significantly speeding up applications, especially for CPU-bound tasks.\n-   **Efficiency**: Reduces the workload on the system.\n\n### Considerations\n-   **Memory Usage**: Storing results consumes memory. For functions with many unique inputs, the cache can grow very large.\n-   **Pure Functions**: Most effective for pure functions. Memoizing functions with side effects or external dependencies can lead to stale results.\n-   **Argument Complexity**: Generating unique keys for complex arguments can be challenging and sometimes negate performance gains if the key generation itself is expensive.",
      "examples": [
        {
          "id": "example_memoization_1",
          "title": "Basic Memoization Implementation",
          "code": "function memoize(fn) {\n  const cache = {};\n  return function(...args) {\n    // Create a unique key from arguments. JSON.stringify works for simple types.\n    // For complex objects, it might not be suitable if order or non-enumerable props matter.\n    const key = JSON.stringify(args);\n    if (cache[key]) {\n      console.log(`Fetching '${key}' from cache`);\n      return cache[key];\n    }\n    console.log(`Calculating result for '${key}'`);\n    // Use apply to ensure 'this' context is correctly passed if 'fn' relies on it.\n    const result = fn.apply(this, args);\n    cache[key] = result;\n    return result;\n  };\n}\n\nconst factorial = memoize(function(n) {\n  if (n === 0 || n === 1) return 1;\n  return n * factorial(n - 1);\n});\n\nconsole.log(factorial(5)); // Calculating result, then 120\nconsole.log(factorial(5)); // Fetching from cache, then 120\nconsole.log(factorial(3)); // Calculating result, then 6\nconsole.log(factorial(3)); // Fetching from cache, then 6",
          "explanation": "This example demonstrates a `memoize` higher-order function. It takes a function `fn` and returns a new function. This new function checks a `cache` object before executing `fn`. If the result for the given arguments (`key`) is found in the cache, it's returned immediately. Otherwise, `fn` is executed, its result is stored in the cache, and then returned. `fn.apply(this, args)` is crucial here to ensure that if `fn` itself is a method of an object and relies on its `this` context, that context is correctly preserved.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "optimization",
        "performance",
        "caching",
        "higher-order functions",
        "closures"
      ],
      "prerequisites": [
        "closures",
        "this_keyword",
        "function_apply_call_bind",
        "pure_functions"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "optimization",
      "performance",
      "caching",
      "higher-order functions",
      "closures"
    ],
    "prerequisites": [
      "closures",
      "this_keyword",
      "function_apply_call_bind",
      "pure_functions"
    ]
  },
  {
    "index": 8,
    "id": "theory_this_context_es5",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Managing 'this' Context in ES5",
    "description": "",
    "content": {
      "id": "theory_this_context_es5",
      "title": "Managing 'this' Context in ES5",
      "description": "",
      "type": "theory",
      "content": "In JavaScript, the `this` keyword refers to the context in which a function is executed. Its value is determined dynamically by how the function is called, rather than where it is declared. This dynamic behavior can often lead to confusion, especially in asynchronous callbacks or event handlers where the execution context might differ from the expected context.\n\n### Challenges with `this` in ES5\nWhen a function is used as a callback, particularly with `setInterval` or `setTimeout`, or as an event handler, its `this` context often defaults to the global object (e.g., `window` in browsers, or `undefined` in strict mode), rather than the object that owns the method. This happens because the callback function is invoked directly by the `setInterval` (or event listener) mechanism, not as a method of your object.\n\n### Solutions for Maintaining `this` Context in ES5\nTo overcome this, ES5 offers several patterns to explicitly control or preserve the `this` context.\n\n1.  **Using a 'that' / 'self' Variable (Closure)**:\n    This common pattern involves saving a reference to the desired `this` context in a variable (commonly named `that` or `self`) outside the callback function, but within the scope of the method where `this` is correct. The callback function, being a closure, then captures and retains access to this `that` variable, allowing it to correctly reference the object's properties.\n\n2.  **Using `Function.prototype.bind()`**:\n    The `bind()` method creates a new function that, when called, has its `this` keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called. It returns a *new function* with the `this` context permanently bound. This is particularly useful when you need to pass a method as a callback and ensure it always operates on a specific object instance.",
      "examples": [
        {
          "id": "example_this_es5_that_self",
          "title": "Solution 1: Using a 'that' / 'self' variable",
          "code": "function Person() {\n  var that = this; // 'this' here refers to the new Person instance\n  that.age = 0;\n  \n  setInterval(function growUp() {\n    // Inside growUp, 'this' would normally be the global object (window) or undefined (strict mode)\n    // But 'that' correctly references the Person instance due to closure\n    that.age++;\n    console.log(`Person's age (via that): ${that.age}`);\n  }, 1000);\n}\n\n// var p1 = new Person(); // Uncomment to see it in action",
          "explanation": "In this example, `var that = this;` captures the `this` context of the `Person` constructor (which is the newly created `Person` instance) into the `that` variable. The `growUp` function, being a closure, maintains access to `that`, allowing it to correctly increment the `age` property of the `Person` instance, even though `growUp` itself is called without a specific `this` context (i.e., by `setInterval`).",
          "language": "javascript"
        },
        {
          "id": "example_this_es5_bind",
          "title": "Solution 2: Using Function.prototype.bind()",
          "code": "function Person() {\n  this.age = 0;\n  \n  // setInterval expects a function. We use .bind(this) to create a new function\n  // where 'this' is permanently bound to the current Person instance.\n  setInterval(function growUp() {\n    // Inside growUp, 'this' now correctly refers to the Person instance\n    this.age++;\n    console.log(`Person's age (via bind): ${this.age}`);\n  }.bind(this), 1000); // 'this' here refers to the Person instance\n}\n\n// var p2 = new Person(); // Uncomment to see it in action",
          "explanation": "Here, `bind(this)` is called on the `growUp` function. The `this` passed to `bind` (which is the `Person` instance in this context) becomes the permanent `this` for the `growUp` function when it's eventually called by `setInterval`. This creates a new function that `setInterval` uses, ensuring `this.age++` correctly modifies the `age` of the `Person` instance.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "javascript",
        "this",
        "context",
        "es5",
        "bind",
        "closure",
        "scope",
        "function-prototype"
      ],
      "prerequisites": [
        "javascript_functions",
        "javascript_scope"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "javascript",
      "this",
      "context",
      "es5",
      "bind",
      "closure",
      "scope",
      "function-prototype"
    ],
    "prerequisites": [
      "javascript_functions",
      "javascript_scope"
    ]
  },
  {
    "index": 9,
    "id": "theory_prototype_inheritance_es5",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Prototype-Based Inheritance (ES5)",
    "description": "",
    "content": {
      "id": "theory_prototype_inheritance_es5",
      "title": "Prototype-Based Inheritance (ES5)",
      "description": "",
      "type": "theory",
      "content": "In JavaScript, before ES6 classes, inheritance was primarily achieved through prototypes. Every JavaScript object has a prototype, which is another object that it inherits properties and methods from. When you try to access a property or method on an object, if it's not found directly on the object, JavaScript will look up its prototype chain until it finds the property or reaches the end of the chain (null).\n\n## Key Concepts\n-   **Prototype Chain:** The mechanism by which JavaScript objects inherit features from one another. Each object has a `[[Prototype]]` (exposed as `__proto__` in some environments, but typically accessed via `Object.getPrototypeOf()`) link to another object, forming a chain.\n-   **`prototype` Property:** Functions in JavaScript have a special `prototype` property, which is an object. When you use a function as a constructor with the `new` keyword, the `[[Prototype]]` of the newly created instance points to the constructor function's `prototype` object.\n-   **`Object.create()`:** This method creates a new object, using an existing object as the prototype of the newly created object. It's the preferred way to set up prototype chains explicitly, as it avoids issues with direct assignment of `new Parent()` to `Child.prototype`.\n-   **`constructor` Property:** Every object created via a constructor function automatically gets a `constructor` property that points back to the constructor function. When manually setting `Child.prototype = Object.create(Parent.prototype)`, the `constructor` property of `Child.prototype` gets reset to `Parent`'s constructor. It's crucial to explicitly set `Child.prototype.constructor = Child;` to maintain correct constructor references, especially for `instanceof` checks or creating new instances from the prototype.\n-   **Method Overriding:** A child object (or prototype) can define a method with the same name as a method in its parent's prototype. When this happens, the child's method will be called, effectively 'overriding' the parent's method for instances of the child type.",
      "examples": [
        {
          "id": "example_prototype_inheritance_es5_1",
          "title": "Basic Prototype Inheritance (ES5)",
          "code": "function Person(firstName) {\n  this.firstName = firstName;\n}\n\nPerson.prototype.sayHello = function() {\n  console.log(\"Hello, I'm \" + this.firstName);\n};\n\nfunction Student(firstName, subject) {\n  Person.call(this, firstName); // Call parent constructor for inherited properties\n  this.subject = subject;\n}\n\n// Inherit methods from Person.prototype\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student; // Correct the constructor reference\n\n// Override a method\nStudent.prototype.sayHello = function() {\n  console.log(\"Hello, I'm \" + this.firstName + \". I'm studying \" + this.subject + \".\");\n};\n\nvar person = new Person(\"Alice\");\nperson.sayHello(); // \"Hello, I'm Alice\"\n\nvar student = new Student(\"John\", \"Computer Science\");\nstudent.sayHello(); // \"Hello, I'm John. I'm studying Computer Science.\"\n\nconsole.log(student instanceof Student); // true\nconsole.log(student instanceof Person);  // true\nconsole.log(student.constructor === Student); // true",
          "explanation": "This example demonstrates how to set up classical inheritance using JavaScript's prototype chain. `Person.call(this, firstName)` ensures that `firstName` is initialized by the `Person` constructor on the `Student` instance. `Object.create(Person.prototype)` links `Student.prototype` to `Person.prototype`, establishing the inheritance chain for methods. `Student.prototype.constructor = Student` is crucial to maintain the correct constructor reference. The `sayHello` method in `Student.prototype` overrides the one from `Person.prototype` for `Student` instances.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "JavaScript",
        "Inheritance",
        "Prototypes",
        "ES5",
        "Object.create",
        "Constructor",
        "OOP"
      ],
      "prerequisites": [
        "JavaScript_Objects",
        "Functions_as_Constructors",
        "This_Keyword"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "JavaScript",
      "Inheritance",
      "Prototypes",
      "ES5",
      "Object.create",
      "Constructor",
      "OOP"
    ],
    "prerequisites": [
      "JavaScript_Objects",
      "Functions_as_Constructors",
      "This_Keyword"
    ]
  },
  {
    "index": 10,
    "id": "theory_private_members_js",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Private Members in JavaScript: Closures vs. Symbols",
    "description": "",
    "content": {
      "id": "theory_private_members_js",
      "title": "Private Members in JavaScript: Closures vs. Symbols",
      "description": "",
      "type": "theory",
      "content": "In JavaScript, achieving true data privacy for object properties has historically been a challenge due to its dynamic nature and lack of built-in private modifiers until recent ES versions (with `#` private class fields). However, two common patterns for creating 'private' or encapsulated members are using closures and ES6 Symbols.\n\n## 1. Using Closures for Private Members\nClosures provide a robust way to create truly private variables and functions. When an inner function retains access to its outer (enclosing) function's scope even after the outer function has finished executing, it forms a closure. This allows variables declared within the outer function to be accessible only by the inner function(s), effectively making them private to the returned object's methods.\n\n### How it works:\n1.  A constructor function (or a factory function) declares variables using `let` or `const` within its scope.\n2.  It then returns an object containing public methods.\n3.  These public methods, being defined within the same scope, 'close over' the private variables, allowing them to read and modify them.\n4.  The private variables are not directly accessible from outside the returned object, ensuring encapsulation.\n\n**Advantages:**\n*   **True Privacy:** Variables are genuinely inaccessible from outside.\n*   **Simple for functional patterns:** Aligns well with factory functions.\n\n**Disadvantages:**\n*   **Memory Overhead:** Each instance created via this pattern will have its own set of private variables and method copies, potentially consuming more memory.\n*   **Method Duplication:** Methods are recreated for every instance, not shared via the prototype chain.\n\n## 2. Using ES6 Symbols for \"Pseudo-Private\" Members\nES6 introduced `Symbol` as a new primitive data type. Symbols are unique and immutable values that can be used as object property keys. While not truly private (as they can be discovered using `Object.getOwnPropertySymbols()` or `Reflect.ownKeys()`), they provide a way to create properties that are not easily discoverable or enumerable, making them suitable for internal use within a class without polluting the public interface.\n\n### How it works:\n1.  A `Symbol` is created and assigned to a `const` variable outside the class definition.\n2.  This `Symbol` is then used as a property key within the class constructor (`this[_symbolKey] = value;`) and accessed by class methods.\n3.  Since Symbols are not enumerable by `for...in` loops or `Object.keys()`, the property appears \"hidden\" from casual inspection.\n\n**Advantages:**\n*   **Prevents Name Collisions:** Symbols are unique, preventing accidental overwrites of properties.\n*   **Less Memory Overhead (compared to closures for classes):** Methods can be defined on the prototype, shared across instances.\n*   **Semantically clear:** Indicates an intended internal property.\n\n**Disadvantages:**\n*   **Not Truly Private:** `Object.getOwnPropertySymbols()` can reveal these properties.\n*   **Requires Convention:** Developers still need to know about the Symbol to access the property, often leading to using `_` prefix for clarity.\n\n```javascript\n// Using closures for private members\nfunction Counter() {\n  // Private variable\n  let count = 0;\n  \n  // Public interface\n  return {\n    increment: function() {\n      count++;\n    },\n    decrement: function() {\n      count--;\n    },\n    getCount: function() {\n      return count;\n    }\n  };\n}\n\n// Using ES6 classes with symbols\nconst _count = Symbol('count'); // Declare Symbol outside the class\n\nclass CounterClass {\n  constructor() {\n    this[_count] = 0; // Use Symbol as a property key\n  }\n  \n  increment() {\n    this[_count]++;\n  }\n  \n  decrement() {\n    this[_count]--;\n  }\n  \n  getCount() {\n    return this[_count];\n  }\n}\n```",
      "examples": [
        {
          "id": "example_private_members_closure_1",
          "title": "Closure-based Counter Example",
          "code": "function Counter() {\n  let count = 0; // Private variable\n  \n  return {\n    increment: function() {\n      count++;\n    },\n    decrement: function() {\n      count--;\n    },\n    getCount: function() {\n      return count;\n    }\n  };\n}\n\nconst counter = Counter();\ncounter.increment();\ncounter.increment();\nconsole.log(counter.getCount()); // Output: 2\nconsole.log(counter.count); // Output: undefined (count is private)",
          "explanation": "This example demonstrates how the `count` variable is truly private to the `Counter` instance. It can only be accessed or modified via the `increment`, `decrement`, and `getCount` methods returned by the `Counter` function. Direct access `counter.count` results in `undefined`.",
          "language": "javascript"
        },
        {
          "id": "example_private_members_symbol_1",
          "title": "Symbol-based Counter Example",
          "code": "const _count = Symbol('count'); // Unique symbol for internal use\n\nclass CounterClass {\n  constructor() {\n    this[_count] = 0; // Property key is a Symbol\n  }\n  \n  increment() {\n    this[_count]++;\n  }\n  \n  decrement() {\n    this[_count]--;\n  }\n  \n  getCount() {\n    return this[_count];\n  }\n}\n\nconst counterSym = new CounterClass();\ncounterSym.increment();\ncounterSym.increment();\nconsole.log(counterSym.getCount()); // Output: 2\n\n// Attempting to access directly will not work (unless you have the Symbol)\nconsole.log(counterSym._count); // Output: undefined (if _count is not a string literal)\n\n// How it's discoverable (demonstrating it's not truly private)\nconsole.log(Object.getOwnPropertySymbols(counterSym)); // Output: [Symbol(count)]\nconsole.log(counterSym[Object.getOwnPropertySymbols(counterSym)[0]]); // Output: 2",
          "explanation": "This example shows how `_count` (a Symbol) is used as a property key within `CounterClass`. While it's not directly accessible via dot notation (`.count`), it's also not truly private as `Object.getOwnPropertySymbols()` can reveal and allow access to it. It effectively hides the property from typical enumeration methods like `Object.keys()` or `for...in` loops.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "JavaScript",
        "OOP",
        "Encapsulation",
        "Closures",
        "Symbols",
        "ES6"
      ],
      "prerequisites": [
        "javascript_functions",
        "javascript_objects",
        "es6_classes",
        "javascript_scope"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "JavaScript",
      "OOP",
      "Encapsulation",
      "Closures",
      "Symbols",
      "ES6"
    ],
    "prerequisites": [
      "javascript_functions",
      "javascript_objects",
      "es6_classes",
      "javascript_scope"
    ]
  },
  {
    "index": 11,
    "id": "theory_object_composition",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Object Composition in JavaScript",
    "description": "",
    "content": {
      "id": "theory_object_composition",
      "title": "Object Composition in JavaScript",
      "description": "",
      "type": "theory",
      "content": "## Introduction to Object Composition\nObject composition is a programming paradigm where complex objects are created by combining simpler objects or functionalities. Unlike classical inheritance, which focuses on \"is-a\" relationships (e.g., a `Dog` *is-a* `Animal`), composition emphasizes \"has-a\" relationships (e.g., a `Bird` *has-a* `flying` ability, *has-a* `eating` ability).\n\nThis approach promotes flexibility, reusability, and avoids common pitfalls associated with deep inheritance hierarchies, such as the \"diamond problem\" (ambiguity arising from multiple inheritance) and tight coupling.\n\n## Core Concepts\n-   **Mixins/Composers:** Functions that return objects containing specific behaviors (methods and/or properties). These functions often take the object's `state` as an argument, allowing the behaviors to interact with and modify the internal state.\n-   **Factory Functions:** Functions that create and return new objects. They typically combine various mixins to assemble the desired object with all its capabilities.\n-   **State Management:** The internal data of an object is often managed in a `state` object, which is passed to the mixins, allowing them to operate on the same shared data.\n\n## Benefits of Composition\n-   **Flexibility:** Easily combine different behaviors in various ways to create diverse objects without a rigid hierarchy.\n-   **Reusability:** Individual behaviors (mixins) can be reused across multiple types of objects.\n-   **Maintainability:** Changes to one behavior are less likely to impact unrelated parts of the system.\n-   **Testability:** Smaller, focused mixins are easier to test in isolation.\n-   **Reduced Coupling:** Objects depend on behaviors rather than concrete classes, leading to looser coupling.\n-   **Avoids Inheritance Problems:** No more super constructor calls, `this` binding issues in inherited methods, or the fragile base class problem.\n\n## Implementation Pattern\nThe common pattern involves:\n1.  Defining `state` for the core properties of the object.\n2.  Creating small functions (mixins) that accept the `state` and return an object with methods that operate on that state.\n3.  Using the spread syntax (`...`) within a factory function to merge the `state` and all the returned behaviors into a single final object.\n\nIt's important to note that directly spreading `state` (`...state`) makes the internal state properties directly accessible and mutable from the outside. For better encapsulation, one might choose to only return methods from the factory function, with state being closed over by the mixins, or by providing getter/setter methods for controlled access.",
      "examples": [
        {
          "id": "example_object_composition_1",
          "title": "Basic Object Composition with State",
          "code": "const canEat = (state) => ({\n  eat: (food) => {\n    console.log(`${state.name} is eating ${food}`);\n    state.energy += 10; // Example: Eating increases energy\n  },\n});\n\nconst canSleep = (state) => ({\n  sleep: (hours) => {\n    console.log(`${state.name} is sleeping for ${hours} hours`);\n    state.energy += hours * 5; // Example: Sleeping increases energy\n  },\n});\n\nconst canFly = (state) => ({\n  fly: (distance) => {\n    if (state.energy >= distance * 2) {\n      console.log(`${state.name} is flying ${distance} meters`);\n      state.energy -= distance * 2;\n    } else {\n      console.log(`${state.name} is too tired to fly`);\n    }\n  },\n});\n\n// Creating objects using composition (Factory Functions)\nfunction createBird(name) {\n  const state = {\n    name,\n    energy: 100,\n  };\n  \n  return {\n    ...state, // Directly exposes name and energy. Alternative: use getters for state properties\n    ...canEat(state),\n    ...canSleep(state),\n    ...canFly(state),\n  };\n}\n\nfunction createDog(name) {\n  const state = {\n    name,\n    energy: 100,\n  };\n  \n  return {\n    ...state,\n    ...canEat(state),\n    ...canSleep(state),\n  };\n}\n\nconst bird = createBird(\"Sparrow\");\nbird.eat(\"seeds\"); \nbird.fly(20); \nconsole.log(`Sparrow's energy: ${bird.energy}`); // 100 + 10 - 40 = 70\n\nconst dog = createDog(\"Rex\");\ndog.eat(\"meat\"); \ndog.sleep(8); \nconsole.log(`Rex's energy: ${dog.energy}`); // 100 + 10 + 40 = 150\n// dog.fly(); // Error: dog.fly is not a function",
          "explanation": "This example demonstrates how `canEat`, `canSleep`, and `canFly` are functions that return objects with specific behaviors. These 'mixin' objects are then combined using the spread operator within `createBird` and `createDog` factory functions. Each mixin takes a `state` object, allowing it to modify or access shared properties like `name` and `energy`. This allows `Bird` to have `fly` ability, while `Dog` does not, showcasing how different combinations of behaviors can be created from the same set of building blocks.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "object-oriented-programming",
        "composition",
        "javascript",
        "design-patterns",
        "functional-programming",
        "factories"
      ],
      "prerequisites": [
        "javascript_objects",
        "javascript_functions",
        "spread_syntax"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "object-oriented-programming",
      "composition",
      "javascript",
      "design-patterns",
      "functional-programming",
      "factories"
    ],
    "prerequisites": [
      "javascript_objects",
      "javascript_functions",
      "spread_syntax"
    ]
  },
  {
    "index": 13,
    "id": "theory_array_mutating_methods",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Mutating Array Methods",
    "description": "",
    "content": {
      "id": "theory_array_mutating_methods",
      "title": "Mutating Array Methods",
      "description": "",
      "type": "theory",
      "content": "Mutating array methods are functions that modify the original array directly (in-place) when they are called. Understanding which methods mutate and which do not is crucial for preventing unexpected side effects in your code, especially when working with references to arrays.\n\n## Key Mutating Methods\n\n### `splice()`\nThe `splice()` method changes the contents of an array by removing or replacing existing elements and/or adding new elements in place. It returns an array containing the deleted elements (if any).\n\n**Syntax:** `array.splice(start, deleteCount, item1, item2, ...)`\n*   `start`: Index at which to start changing the array.\n*   `deleteCount`: An integer indicating the number of elements to remove.\n*   `item1, item2, ...`: The elements to add to the array, starting at the `start` position. If no elements are specified, `splice()` only removes elements.\n\n### `sort()`\nThe `sort()` method sorts the elements of an array in place and returns the reference to the same array, now sorted. The default sort order is ascending, built upon converting the elements into strings, then comparing their sequences of UTF-16 code units. For numeric sorting, a compare function is necessary.\n\n**Syntax:** `array.sort([compareFunction])`\n*   `compareFunction`: A function that defines the sort order. It takes two arguments, `a` and `b`. If `compareFunction(a, b)` returns a value:\n    *   Less than 0: `a` comes before `b`.\n    *   Greater than 0: `b` comes before `a`.\n    *   Equal to 0: `a` and `b` remain unchanged with respect to each other, but are sorted with respect to all other elements.\n\n### `reverse()`\nThe `reverse()` method reverses the order of the elements in an array in place. The first array element becomes the last, and the last array element becomes the first. It returns a reference to the same array.\n\n**Syntax:** `array.reverse()`\n\n### `fill()`\nThe `fill()` method changes all elements in an array to a static value, from a start index (default 0) to an end index (default `array.length`). It modifies the original array and returns it.\n\n**Syntax:** `array.fill(value, [start], [end])`\n*   `value`: Value to fill the array with.\n*   `start` (optional): Start index, default 0.\n*   `end` (optional): End index (exclusive), default `array.length`.\n\n### `copyWithin()`\nThe `copyWithin()` method shallow copies part of an array to another location in the same array and returns it without modifying its length. It's useful for shifting elements within an array.\n\n**Syntax:** `array.copyWithin(target, start, [end])`\n*   `target`: Zero-based index at which to copy the sequence to.\n*   `start`: Zero-based index at which to start copying elements from.\n*   `end` (optional): Zero-based index at which to end copying elements from (exclusive). Defaults to `array.length`.\n",
      "examples": [
        {
          "id": "example_splice_1",
          "title": "Using `splice()` to Remove and Add Elements",
          "code": "const myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];\nconst removed = myFish.splice(2, 1, 'trumpet');\n// myFish is now ['angel', 'clown', 'trumpet', 'sturgeon']\n// removed contains ['mandarin'] - the element that was removed",
          "explanation": "This example demonstrates how `splice()` can remove 'mandarin' at index 2 and insert 'trumpet' in its place. The original `myFish` array is modified, and the removed element is returned.",
          "language": "javascript"
        },
        {
          "id": "example_sort_1",
          "title": "Basic `sort()` and Custom Numeric `sort()`",
          "code": "const fruits = ['banana', 'apple', 'orange'];\nfruits.sort(); // ['apple', 'banana', 'orange']\n\nconst numbers = [10, 5, 8, 1, 7];\nnumbers.sort((a, b) => a - b); // [1, 5, 7, 8, 10] (ascending)\nnumbers.sort((a, b) => b - a); // [10, 8, 7, 5, 1] (descending)",
          "explanation": "The first part shows default lexicographical string sorting. The second part illustrates how to sort numbers correctly using a compare function: `a - b` for ascending and `b - a` for descending order.",
          "language": "javascript"
        },
        {
          "id": "example_reverse_1",
          "title": "Using `reverse()`",
          "code": "const numbers = [1, 5, 7, 8, 10];\nnumbers.reverse(); // numbers is now [10, 8, 7, 5, 1]",
          "explanation": "This shows `reverse()` modifying the array `numbers` in place, changing the order of its elements.",
          "language": "javascript"
        },
        {
          "id": "example_fill_1",
          "title": "Using `fill()`",
          "code": "const filledFull = [1, 2, 3, 4, 5].fill(0); // [0, 0, 0, 0, 0]\nconst partiallyFilled = [1, 2, 3, 4, 5].fill(0, 2, 4); // [1, 2, 0, 0, 5]",
          "explanation": "The first example fills the entire array with zeros. The second example fills elements from index 2 (inclusive) up to index 4 (exclusive) with zeros, leaving other elements untouched.",
          "language": "javascript"
        },
        {
          "id": "example_copywithin_1",
          "title": "Using `copyWithin()`",
          "code": "const originalArray = [1, 2, 3, 4, 5];\noriginalArray.copyWithin(0, 3); // originalArray is now [4, 5, 3, 4, 5]",
          "explanation": "This demonstrates copying elements starting from index 3 (which are 4 and 5) to the beginning of the array, effectively overwriting elements at index 0 and 1. The length of the array remains unchanged.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "array methods",
        "mutation",
        "in-place",
        "splice",
        "sort",
        "reverse",
        "fill",
        "copyWithin"
      ],
      "prerequisites": [
        "javascript_arrays"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "array methods",
      "mutation",
      "in-place",
      "splice",
      "sort",
      "reverse",
      "fill",
      "copyWithin"
    ],
    "prerequisites": [
      "javascript_arrays"
    ]
  },
  {
    "index": 16,
    "id": "theory_promise_combinators",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Promise Combinators: allSettled and any",
    "description": "",
    "content": {
      "id": "theory_promise_combinators",
      "title": "Promise Combinators: allSettled and any",
      "description": "",
      "type": "theory",
      "content": "Promise combinators are static methods on the `Promise` object that take an iterable (like an array) of Promises as input and return a single Promise. They are useful for orchestrating multiple asynchronous operations.\n\n### Promise.allSettled()\n\n`Promise.allSettled()` waits for all given promises to settle, regardless of whether they are fulfilled or rejected. It returns a promise that resolves with an array of objects, each describing the outcome of a promise.\n\nEach outcome object has a `status` string (`'fulfilled'` or `'rejected'`) and either a `value` (if fulfilled) or a `reason` (if rejected). This is particularly useful when you need to know the result of every promise, even if some of them fail, without the entire operation short-circuiting on the first rejection.\n\n### Promise.any()\n\n`Promise.any()` takes an iterable of Promises and returns a single Promise that resolves as soon as any of the input Promises resolves (fulfills). If no Promise in the iterable fulfills (i.e., all of them reject), then the Promise returned by `Promise.any()` rejects with an `AggregateError`, a subclass of `Error` that groups individual errors.\n\nThis combinator is useful when you need to get the fastest successful result from multiple competing asynchronous operations. It's conceptually the opposite of `Promise.all` in its error handling: `Promise.all` rejects on the first rejection, `Promise.any` resolves on the first fulfillment.\n\n| Combinator | Behavior (Success)                                   | Behavior (Failure)                                     | Use Case                                                                                                   |\n|------------|------------------------------------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------|\n| `allSettled` | Resolves with an array of outcome objects (value/reason) once all promises have settled. | Never rejects if all promises settle. The outcome array will contain rejected statuses. | When you need results from all promises, regardless of success or failure.                                |\n| `any`      | Resolves with the value of the first promise that fulfills. | Rejects with an `AggregateError` if all promises reject. | When you need the first successful result from multiple options.                                          |",
      "examples": [
        {
          "id": "example_promise_allsettled_1",
          "title": "Using Promise.allSettled",
          "code": "Promise.allSettled([\n  fetch('/api/users').then(res => res.json()),\n  fetch('/endpoint-that-might-fail').then(res => res.json())\n])\n  .then(results => {\n    console.log('All settled results:', results);\n    results.forEach(result => {\n      if (result.status === 'fulfilled') {\n        console.log('Fulfilled:', result.value);\n      } else {\n        console.log('Rejected:', result.reason);\n      }\n    });\n  })\n  .catch(err => {\n    // This catch block will typically not be hit unless Promise.allSettled itself fails,\n    // not because of individual promise rejections.\n    console.error('Promise.allSettled failed:', err);\n  });\n\n// Example of results array structure:\n/*\n[\n  { status: 'fulfilled', value: [...] },\n  { status: 'rejected', reason: Error('Network Error') }\n]\n*/",
          "explanation": "This example demonstrates how `Promise.allSettled` collects the results (either `fulfilled` with `value` or `rejected` with `reason`) from all promises, allowing the application to continue processing even if some operations fail. The `.then()` block always executes once all input promises have completed.",
          "language": "typescript"
        },
        {
          "id": "example_promise_any_1",
          "title": "Using Promise.any",
          "code": "Promise.any([\n  fetch('/api/endpoint1').then(res => res.json()),\n  fetch('/api/endpoint2').then(res => res.json()),\n  fetch('/api/endpoint3').then(res => res.json())\n])\n  .then(firstSuccess => console.log('First successful result:', firstSuccess))\n  .catch(errors => {\n    console.log('All promises rejected, errors:', errors);\n    // errors will be an AggregateError instance\n    errors.errors.forEach(err => console.error('Individual rejection:', err));\n  });",
          "explanation": "`Promise.any` is used here to resolve with the data from the first successful `fetch` call. If all three `fetch` calls fail (e.g., network errors, server errors), the `.catch()` block will execute, receiving an `AggregateError` containing all the individual rejection reasons.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "Promises",
        "Asynchronous JavaScript",
        "Promise Combinators",
        "ES2020"
      ],
      "prerequisites": [
        "Promises",
        "Fetch API",
        "Error Handling"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "Promises",
      "Asynchronous JavaScript",
      "Promise Combinators",
      "ES2020"
    ],
    "prerequisites": [
      "Promises",
      "Fetch API",
      "Error Handling"
    ]
  },
  {
    "index": 17,
    "id": "theory_event_loop_async",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Asynchronous JavaScript and the Event Loop",
    "description": "",
    "content": {
      "id": "theory_event_loop_async",
      "title": "Asynchronous JavaScript and the Event Loop",
      "description": "",
      "type": "theory",
      "content": "JavaScript is a single-threaded, non-blocking, asynchronous, concurrent language. This means it has one call stack and executes one thing at a time. To handle operations that take time (like network requests, timers, or user interactions) without blocking the main thread, JavaScript uses the Event Loop.\n\n### Call Stack\nThis is where synchronous code is executed. Functions are pushed onto the stack when called and popped off when they return.\n\n### Web APIs\nBrowser provides Web APIs (e.g., `setTimeout`, `DOM events`, `fetch`) that JavaScript can interact with. When these APIs are called, they move the operation out of the call stack and handle it asynchronously.\n\n### Callback Queue (Macrotask Queue)\nAfter a Web API completes its operation (e.g., `setTimeout` timer expires, `fetch` request resolves), its callback function is moved to the Callback Queue. Examples of macrotasks include `setTimeout`, `setInterval`, `setImmediate` (Node.js), I/O operations.\n\n### Microtask Queue\nThis queue has higher priority than the Callback Queue. Callbacks for Promises (`.then()`, `.catch()`, `.finally()`) and `MutationObserver` are placed in the Microtask Queue. The Event Loop checks and empties the Microtask Queue *before* checking the Macrotask Queue after each tick of the call stack.\n\n### Event Loop\nThe Event Loop constantly monitors the Call Stack and the queues. If the Call Stack is empty, it first checks the Microtask Queue and pushes any tasks from it to the Call Stack. Once the Microtask Queue is empty, it then checks the Callback Queue (Macrotask Queue) and pushes the first task from it to the Call Stack. This process repeats, allowing asynchronous operations to be handled without blocking the main thread.\n\n**Execution Order Summary:**\n1.  All synchronous code in the Call Stack runs to completion.\n2.  The Event Loop checks and executes all tasks in the Microtask Queue.\n3.  The Event Loop checks and executes one task from the Macrotask Queue.\n4.  Steps 2 and 3 repeat.",
      "examples": [
        {
          "id": "example_event_loop_1",
          "title": "Promise and setTimeout Execution Order",
          "code": "console.log('Script start');\n\nsetTimeout(() => {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 1');\n}).then(() => {\n  console.log('Promise 2');\n});\n\nconsole.log('Script end');\n\n// Output:\n// Script start\n// Script end\n// Promise 1\n// Promise 2\n// setTimeout",
          "explanation": "1.  `console.log('Script start')` runs immediately (synchronous).\n2.  `setTimeout` callback is sent to Web APIs, then pushed to the Macrotask Queue after 0ms.\n3.  `Promise.resolve().then()` callback is sent to Web APIs, then pushed to the Microtask Queue.\n4.  `console.log('Script end')` runs immediately (synchronous).\n5.  Synchronous code finishes. The Call Stack is empty.\n6.  The Event Loop checks the Microtask Queue: `Promise 1` callback is found and executed.\n7.  The second `.then()` (for `Promise 2`) is then pushed to the Microtask Queue.\n8.  The Event Loop checks the Microtask Queue again: `Promise 2` callback is found and executed.\n9.  Microtask Queue is empty. The Event Loop checks the Macrotask Queue: `setTimeout` callback is found and executed.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "JavaScript",
        "Asynchronous",
        "Event Loop",
        "Promises",
        "setTimeout",
        "Microtasks",
        "Macrotasks"
      ],
      "prerequisites": [
        "Basic JavaScript Syntax",
        "Functions",
        "Callbacks"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "JavaScript",
      "Asynchronous",
      "Event Loop",
      "Promises",
      "setTimeout",
      "Microtasks",
      "Macrotasks"
    ],
    "prerequisites": [
      "Basic JavaScript Syntax",
      "Functions",
      "Callbacks"
    ]
  },
  {
    "index": 19,
    "id": "theory_async_timeout_abortcontroller",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Asynchronous Operations with Timeout and AbortController",
    "description": "",
    "content": {
      "id": "theory_async_timeout_abortcontroller",
      "title": "Asynchronous Operations with Timeout and AbortController",
      "description": "",
      "type": "theory",
      "content": "Asynchronous operations like fetching data from an API are fundamental in frontend development. However, these operations can sometimes hang indefinitely or take too long, leading to a poor user experience. Implementing timeouts is crucial to prevent such scenarios and provide responsive feedback.\n\n## Key Concepts\n\n### `AbortController`\nThe `AbortController` interface provides a way to abort one or more Web requests as and when desired. It's a modern and recommended way to cancel `fetch` requests or any other asynchronous operation that accepts an `AbortSignal`.\n\n-   **`AbortController` instance:** `const controller = new AbortController();`\n-   **`signal` property:** `controller.signal` returns an `AbortSignal` object. This signal can be passed to an asynchronous operation (e.g., `fetch(url, { signal: controller.signal })`).\n-   **`abort()` method:** `controller.abort()` aborts the associated signal. When the signal is aborted, any operations listening to it (like an ongoing `fetch` request) will be cancelled, and a `DOMException` with `name` 'AbortError' will be thrown.\n\n### Timeout Mechanism\nCombining `setTimeout` with `AbortController` allows for implementing a timeout for network requests:\n\n1.  Start a timer using `setTimeout`.\n2.  If the timer expires before the `fetch` request completes, call `controller.abort()` to cancel the request.\n3.  If the `fetch` request completes successfully before the timer expires, clear the timer using `clearTimeout` to prevent the `abort()` call from executing.\n\n### Error Handling\nProper error handling is vital for robust asynchronous code:\n\n-   **`try...catch` block:** Catches errors thrown by the `await` expression, including network errors, JSON parsing errors, or `AbortError`.\n-   **`AbortError`:** Specifically checks for `error.name === 'AbortError'` to differentiate a user-initiated or timeout-based cancellation from other network errors.\n-   **HTTP Status Codes:** After a successful `fetch` call (meaning the network request completed, even if the server responded with an error status like 404 or 500), check `response.ok`. If `response.ok` is `false`, it indicates an HTTP error (status outside 200-299 range), and you should throw a custom error.\n\n## Best Practices\n- Always clear the timeout (`clearTimeout`) on successful completion to avoid memory leaks and unintended `abort()` calls.\n- Provide clear error messages to the user for timeouts or other network failures.\n- Consider retries for transient errors, but not for timeouts or permanent errors.",
      "examples": [
        {
          "id": "example_timeout_abort_1",
          "title": "Implementing fetch with Timeout",
          "code": "async function fetchWithTimeout(url, timeout = 5000) {\n  const controller = new AbortController();\n  // Set up a timeout to abort the request\n  const id = setTimeout(() => controller.abort(), timeout);\n  \n  try {\n    // Initiate fetch with the signal\n    const response = await fetch(url, { signal: controller.signal });\n    // Clear the timeout if fetch completes successfully\n    clearTimeout(id);\n    \n    // Check for HTTP errors (e.g., 404, 500)\n    if (!response.ok) {\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    // Always clear timeout in catch block too to prevent hanging timers\n    clearTimeout(id);\n    \n    // Distinguish timeout errors from other errors\n    if (error.name === 'AbortError') {\n      throw new Error(`Request timed out after ${timeout}ms`);\n    }\n    // Re-throw other errors\n    throw error;\n  }\n}\n\n// Example usage:\n// (async () => {\n//   try {\n//     const data = await fetchWithTimeout('https://jsonplaceholder.typicode.com/todos/1', 2000);\n//     console.log('Fetched data:', data);\n//   } catch (e) {\n//     console.error('Fetch error:', e.message);\n//   }\n// })();",
          "explanation": "This example demonstrates how to implement a timeout for a `fetch` request using `AbortController` and `setTimeout`. It shows how to create an `AbortController`, link its `signal` to the `fetch` request, and use `setTimeout` to trigger the `abort()` method if the request takes too long. Crucially, `clearTimeout` is used in both the `try` and `catch` blocks to ensure the timeout is always cleared once the `fetch` promise settles, preventing resource leaks. Error handling differentiates between `AbortError` (timeout) and other potential fetch errors.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "async",
        "fetch",
        "AbortController",
        "timeout",
        "error-handling",
        "web-apis"
      ],
      "prerequisites": [
        "promises",
        "async-await",
        "event-loop-basics"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "async",
      "fetch",
      "AbortController",
      "timeout",
      "error-handling",
      "web-apis"
    ],
    "prerequisites": [
      "promises",
      "async-await",
      "event-loop-basics"
    ]
  },
  {
    "index": 20,
    "id": "theory_async_fetch_retry",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Asynchronous Operations: Fetch with Retry and Exponential Backoff",
    "description": "",
    "content": {
      "id": "theory_async_fetch_retry",
      "title": "Asynchronous Operations: Fetch with Retry and Exponential Backoff",
      "description": "",
      "type": "theory",
      "content": "## Concept\nWhen making network requests (e.g., using `fetch`), transient errors like network glitches or server overload can occur. A retry mechanism allows an application to automatically re-attempt a failed request, improving robustness and user experience. Exponential backoff is a strategy often combined with retries, where the delay between retries increases exponentially. This prevents overwhelming a potentially recovering server and gives it time to stabilize.\n\n## Implementation Details\n*   **`fetch(url, options)`**: The standard Web API for making network requests, returning a `Promise` that resolves to a `Response` object.\n*   **`async`/`await`**: Simplifies asynchronous code, making it look more synchronous. `await` pauses execution until the `Promise` settles (resolves or rejects).\n*   **`try...catch`**: Catches errors that occur during the `fetch` operation. If an error is caught, the retry logic is initiated.\n*   **Recursion**: The `fetchWithRetry` function calls itself (`return fetchWithRetry(...)`) with a decremented `retries` count. This allows for a clean, recursive retry loop.\n*   **`retries` parameter**: A counter that tracks the number of remaining attempts. The recursion stops when `retries` reaches 0, at which point the error is re-thrown.\n*   **`backoff` parameter**: The initial delay (in milliseconds) before the first retry. This value is used to calculate subsequent delays.\n*   **Exponential Delay Calculation**: `delay = backoff * Math.pow(2, 3 - retries)`. This formula calculates an exponentially increasing delay. For example, if `retries` starts at 3:\n    *   1st retry (`retries=2`): `backoff * Math.pow(2, 1)`\n    *   2nd retry (`retries=1`): `backoff * Math.pow(2, 2)`\n    *   3rd retry (`retries=0`): `backoff * Math.pow(2, 3)`\n*   **`new Promise(resolve => setTimeout(resolve, delay))`**: Creates a promise that resolves after a specified `delay`. Awaiting this promise pauses the function's execution, creating the necessary delay before the next retry attempt.\n\n## Advantages\n*   **Improved Reliability**: Makes network operations more resilient to temporary failures.\n*   **Reduced Server Load**: Exponential backoff prevents stampeding retries from hammering a struggling server.\n*   **Better User Experience**: Transparently handles failures without immediate error messages.\n\n## Disadvantages\n*   **Increased Latency**: Retries introduce delays, potentially making operations take longer.\n*   **Complexity**: Adds logic to network requests that might not always be necessary.\n*   **Not for all errors**: Only suitable for transient errors; permanent errors (e.g., 404 Not Found, 401 Unauthorized) should not be retried indefinitely.",
      "examples": [
        {
          "id": "example_async_fetch_retry_1",
          "title": "Basic Fetch with Retry Implementation",
          "code": "async function fetchWithRetry(url, options = {}, retries = 3, backoff = 300) {\n  try {\n    console.log(`Attempting fetch for ${url} (retries left: ${retries})`);\n    const response = await fetch(url, options);\n    if (!response.ok) {\n      // Consider non-2xx responses as errors for retry purposes, e.g., 5xx errors\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response;\n  } catch (error) {\n    console.error(`Fetch failed: ${error.message}`);\n    if (retries > 0) {\n      const delay = backoff * Math.pow(2, 3 - retries);\n      console.log(`Retrying in ${delay}ms...`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n      return fetchWithRetry(url, options, retries - 1, backoff);\n    }\n    throw error; // Re-throw if no retries left\n  }\n}\n\n// Example usage:\n// (async () => {\n//   try {\n//     const data = await fetchWithRetry('https://jsonplaceholder.typicode.com/todos/1', {}, 3, 200);\n//     console.log('Data fetched successfully:', await data.json());\n//   } catch (err) {\n//     console.error('Failed after multiple retries:', err.message);\n//   }\n// })();\n\n// Example for a failing URL (uncomment to test retry logic)\n// (async () => {\n//   try {\n//     const data = await fetchWithRetry('https://httpstat.us/500', {}, 3, 200);\n//     console.log('Data fetched successfully:', await data.json());\n//   } catch (err) {\n//     console.error('Failed after multiple retries:', err.message);\n//   }\n// })();",
          "explanation": "This example demonstrates the `fetchWithRetry` function with added logging to show the retry attempts and delays. It includes a check for `response.ok` to treat non-2xx HTTP responses as errors that trigger retries. The commented-out sections show how to call the function with a successful URL and a simulated failing URL (HTTP 500) to observe the retry mechanism in action.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "async",
        "promises",
        "error-handling",
        "network",
        "api-calls",
        "resilience"
      ],
      "prerequisites": [
        "async_await",
        "promises",
        "error_handling",
        "fetch_api"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "async",
      "promises",
      "error-handling",
      "network",
      "api-calls",
      "resilience"
    ],
    "prerequisites": [
      "async_await",
      "promises",
      "error_handling",
      "fetch_api"
    ]
  },
  {
    "index": 23,
    "id": "theory_currying",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Currying and Partial Application",
    "description": "",
    "content": {
      "id": "theory_currying",
      "title": "Currying and Partial Application",
      "description": "",
      "type": "theory",
      "content": "Currying is a functional programming technique where a function that takes multiple arguments is transformed into a sequence of functions, each taking a single argument. This transformation allows for partial application, where you fix a certain number of arguments to a function, producing another function with fewer arguments.\n\n## Key Concepts\n-   **Transformation**: A function `f(a, b, c)` becomes `f(a)(b)(c)`. Each nested function returns another function until all arguments are received, and then the final result is computed.\n-   **Closures**: Currying heavily relies on closures. Each inner function 'remembers' the arguments passed to its outer function's scope, even after the outer function has finished execution.\n-   **Partial Application**: A specific application of currying where you fix some arguments of a function, creating a new, specialized function. For example, if you have a `sum(a, b)` function and you curry it, you can create `addFive = sum(5)` which is a new function that always adds 5 to its argument.\n\n## Benefits\n-   **Reusability**: Create specialized, reusable functions from more general ones.\n-   **Function Composition**: Curried functions are easier to compose, as each function typically expects a single argument, fitting nicely into a pipeline of operations.\n-   **Readability**: Can sometimes make code more declarative and easier to understand, especially when creating specific versions of general-purpose functions.",
      "examples": [
        {
          "id": "example_currying_1",
          "title": "Simple Currying Example",
          "code": "function sum(a) {\n  return function(b) {\n    return a + b;\n  };\n}\n\nconsole.log(sum(1)(2)); // Output: 3\nconsole.log(sum(5)(-1)); // Output: 4",
          "explanation": "This example shows `sum` as a curried function. `sum(a)` returns an anonymous function that captures `a` in its closure. When this inner function is called with `b`, it can access `a` and perform the addition. This demonstrates the core mechanism of currying using closures.",
          "language": "javascript"
        },
        {
          "id": "example_currying_2",
          "title": "Practical Use Case: Partial Application for Discount Calculation",
          "code": "function discount(price) {\n  return function(percentage) {\n    return price * (1 - percentage / 100);\n  };\n}\n\n// Create a specialized function for a specific price\nconst tenPercentDiscountOn100 = discount(100);\nconsole.log(tenPercentDiscountOn100(10)); // Output: 90 (10% off 100)\nconsole.log(tenPercentDiscountOn100(20)); // Output: 80 (20% off 100)\n\n// Or, create a specialized function for a specific percentage\nfunction calculatePriceWithDiscount(percentage) {\n  return function(price) {\n    return price * (1 - percentage / 100);\n  };\n}\n\nconst twentyPercentOff = calculatePriceWithDiscount(20);\nconsole.log(twentyPercentOff(200)); // Output: 160 (20% off 200)\nconsole.log(twentyPercentOff(50));  // Output: 40 (20% off 50)",
          "explanation": "Here, the `discount` function is curried. By calling `discount(100)`, we create `tenPercentDiscountOn100`, which is a new function that always applies a discount to an initial price of 100. This is a clear example of partial application, allowing us to reuse the `discount` logic for a fixed `price` while varying the `percentage`. The second part of the example shows another way to partially apply, fixing the `percentage` first.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "functional-programming",
        "closures",
        "currying",
        "partial-application",
        "javascript"
      ],
      "prerequisites": [
        "closures",
        "functions"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "functional-programming",
      "closures",
      "currying",
      "partial-application",
      "javascript"
    ],
    "prerequisites": [
      "closures",
      "functions"
    ]
  },
  {
    "index": 25,
    "id": "theory_js_object_methods",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "JavaScript Object Property Checks and Manipulation Methods",
    "description": "",
    "content": {
      "id": "theory_js_object_methods",
      "title": "JavaScript Object Property Checks and Manipulation Methods",
      "description": "",
      "type": "theory",
      "content": "JavaScript provides a rich set of built-in methods and operators for interacting with objects, allowing developers to check for property existence, control object mutability, and transform objects. Understanding these methods is crucial for effective object management and data manipulation.\n\n## Property Existence Checks\n\n-   **`'property' in object` Operator:** This operator checks if a specified property exists in an object or anywhere along its prototype chain. It returns `true` if the property is found, `false` otherwise. This includes both own properties and inherited properties.\n\n-   **`object.hasOwnProperty('property')` Method:** This method checks if an object has a specified property as its *own* property, meaning it's directly defined on the object itself and not inherited from its prototype chain. It returns `true` if the property is an own property, `false` otherwise.\n\n## Object Mutability Control\n\nJavaScript offers methods to control the mutability (ability to be changed) of objects, which is particularly useful for creating immutable data structures or preventing accidental modifications.\n\n-   **`Object.freeze(obj)`:** This method makes an object immutable. It prevents new properties from being added to it, existing properties from being removed, existing properties from being changed, and the prototype from being changed. The values of existing properties also become immutable (shallow freeze). If you attempt to modify a frozen object, it will silently fail in non-strict mode and throw a `TypeError` in strict mode. `Object.freeze()` is shallow; it only freezes the top-level properties. If a property is an object itself, that nested object can still be modified unless explicitly frozen.\n\n-   **`Object.seal(obj)`:** This method seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. This means you cannot delete existing properties or change their configurability (e.g., make them enumerable or writable). However, you *can* still change the values of existing writable properties. Like `Object.freeze()`, `Object.seal()` is shallow.\n\n## Object Cloning\n\nCloning objects involves creating a new object with the same properties and values as an existing one. There are two main types of cloning:\n\n-   **Shallow Clone:** Creates a new object, but any nested objects or arrays within the original object are still referenced by the new object. Changes to nested structures in the clone will affect the original, and vice-versa.\n    -   **`Object.assign({}, original)`:** Copies all enumerable own properties from one or more source objects to a target object. The first argument (`{}`) is the target, creating a new empty object to copy into.\n    -   **Spread Syntax (`{ ...original }`)**: A modern and concise way to perform a shallow clone. It copies all enumerable own properties from the `original` object into a new object.\n\n-   **Deep Clone:** Creates a new object where all nested objects and arrays are also new, distinct copies. Changes to the cloned object, including nested structures, will not affect the original.\n    -   **`JSON.parse(JSON.stringify(original))` (Basic Approach):** This is a common, simple way to achieve a deep clone for basic JSON-serializable objects. The object is first converted to a JSON string, then parsed back into a new JavaScript object. **Limitations**: This method fails for objects containing `Date` objects (converted to strings), `RegExp` objects (converted to empty objects), `Map`, `Set`, `function`, `undefined`, `Symbol`, `BigInt` (ignored or converted incorrectly), and circular references (throws an error).\n\n## Object Iteration and Transformation\n\nThese methods provide ways to extract parts of an object or construct a new object from key-value pairs.\n\n-   **`Object.keys(obj)`:** Returns an array of a given object's own enumerable string-keyed property names.\n\n-   **`Object.values(obj)`:** Returns an array of a given object's own enumerable string-keyed property values.\n\n-   **`Object.entries(obj)`:** Returns an array of a given object's own enumerable string-keyed property `[key, value]` pairs.\n\n-   **`Object.fromEntries(iterable)`:** Transforms a list of key-value pairs (an iterable, such as an array of `[key, value]` arrays) into a new object. This is essentially the inverse of `Object.entries()`.",
      "examples": [
        {
          "id": "example_object_methods_1",
          "title": "Property Existence and Immutability",
          "code": "const myObject = { a: 1, b: 2 };\nconst protoObject = { c: 3 };\nObject.setPrototypeOf(myObject, protoObject);\n\nconsole.log('a' in myObject); // true (own property)\nconsole.log('c' in myObject); // true (inherited property)\nconsole.log(myObject.hasOwnProperty('a')); // true\nconsole.log(myObject.hasOwnProperty('c')); // false\n\n// Freezing an object\nconst frozenObj = Object.freeze({ name: 'Alice', age: 25 });\n// frozenObj.name = 'Bob'; // Throws TypeError in strict mode, silent fail otherwise\n// delete frozenObj.age; // Throws TypeError in strict mode\nconsole.log(frozenObj.name); // Alice\n\n// Sealing an object\nconst sealedObj = Object.seal({ city: 'New York' });\nsealedObj.city = 'London'; // Works\n// sealedObj.country = 'USA'; // No effect (cannot add new properties)\n// delete sealedObj.city; // Throws TypeError in strict mode\nconsole.log(sealedObj.city); // London",
          "explanation": "This example demonstrates the difference between `in` operator and `hasOwnProperty` for checking property existence, including inherited properties. It also shows the effects of `Object.freeze()` and `Object.seal()` on an object's mutability, highlighting what modifications are allowed or prevented by each method.",
          "language": "javascript"
        },
        {
          "id": "example_object_methods_2",
          "title": "Object Cloning and Transformation",
          "code": "const original = { \n  id: 1,\n  details: { color: 'red', size: 'M' },\n  tags: ['new', 'sale'],\n  getFormattedName: function() { return `Item-${this.id}`; }\n};\n\n// Shallow clone using spread syntax\nconst shallowClone = { ...original };\nshallowClone.details.color = 'blue'; // Modifies original's nested object\nshallowClone.tags.push('popular'); // Modifies original's nested array\n\nconsole.log(original.details.color); // blue\nconsole.log(original.tags); // ['new', 'sale', 'popular']\n\n// Deep clone using JSON serialization (with limitations)\nconst deepCloneJSON = JSON.parse(JSON.stringify(original));\ndeepCloneJSON.details.color = 'green';\nconsole.log(original.details.color); // blue (original not affected)\nconsole.log(deepCloneJSON.getFormattedName); // undefined (function lost)\n\n// Object iteration and creation\nconst obj = { a: 1, b: 2, c: 3 };\nconsole.log(Object.keys(obj));   // ['a', 'b', 'c']\nconsole.log(Object.values(obj)); // [1, 2, 3]\nconsole.log(Object.entries(obj)); // [['a', 1], ['b', 2], ['c', 3]]\n\nconst entriesArray = [['x', 10], ['y', 20]];\nconst newObj = Object.fromEntries(entriesArray);\nconsole.log(newObj); // { x: 10, y: 20 }",
          "explanation": "This example illustrates shallow vs. deep cloning, demonstrating how changes to nested objects/arrays in a shallow clone affect the original. It also shows how `JSON.parse(JSON.stringify())` works for deep cloning but highlights its limitation by showing that the `getFormattedName` function is lost. Finally, it demonstrates how to extract keys, values, and entries from an object and reconstruct an object from entries.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "JavaScript",
        "Objects",
        "Mutability",
        "Cloning",
        "ES6"
      ],
      "prerequisites": [
        "javascript_basics",
        "data_types"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "JavaScript",
      "Objects",
      "Mutability",
      "Cloning",
      "ES6"
    ],
    "prerequisites": [
      "javascript_basics",
      "data_types"
    ]
  },
  {
    "index": 98,
    "id": "theory_immutable_js_structural_sharing",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Immutable.js and Structural Sharing",
    "description": "",
    "content": {
      "id": "theory_immutable_js_structural_sharing",
      "title": "Immutable.js and Structural Sharing",
      "description": "",
      "type": "theory",
      "content": "## Immutability in Programming\nImmutability refers to the principle that once a piece of data is created, it cannot be changed. Instead of modifying existing data, any operation that would logically alter it results in the creation of a new, modified copy, leaving the original data untouched.\n\n## Introduction to Immutable.js\n`Immutable.js` is a JavaScript library that provides a collection of immutable, persistent data structures. These include `List`, `Map`, `Set`, and `Stack`, which are optimized for performance and memory efficiency when dealing with immutable data.\n\n## Structural Sharing (Persistent Data Structures)\nOne of the key features that makes `Immutable.js` efficient is **structural sharing**. When you perform an operation on an immutable data structure (like adding, removing, or updating an element), instead of creating a completely new copy of the entire structure, `Immutable.js` creates a new version that reuses (shares) as many of the original, unchanged parts as possible. Only the paths to the modified data are new, while the rest of the data structure points to the same underlying memory as the original.\n\nThis 'copy-on-write' mechanism significantly reduces memory consumption and improves performance for certain operations, especially when dealing with large data structures and frequent updates, as it avoids deep cloning.\n\n## Benefits in Frontend Development (e.g., React/Redux)\n*   **Predictability:** State changes are explicit; you always know your data won't be mutated unexpectedly.\n*   **Simplified Change Detection:** In React, for example, `shouldComponentUpdate` can perform a shallow comparison of props and state. If immutable data is used, a simple reference comparison (`oldState === newState`) is sufficient to determine if a re-render is needed, as `Immutable.js` guarantees a new reference if the data has changed, and the same reference if it hasn't.\n*   **Undo/Redo Functionality:** Easily implement time-travel debugging or undo/redo by keeping references to previous states.\n*   **Concurrency:** Immutable data structures are inherently thread-safe, though less relevant in single-threaded JavaScript.\n\n## Common Immutable.js Methods\n*   `Map()`: Creates a new Immutable Map.\n*   `set(key, value)`: Returns a new Map with `key` set to `value`. Shares unchanged parts.\n*   `update(key, updaterFn)`: Returns a new Map with the value at `key` updated by `updaterFn`.\n*   `delete(key)`: Returns a new Map with `key` removed.\n*   `merge(otherMap)`: Returns a new Map with entries from `otherMap` merged in.\n*   `filterNot(predicate)`: Returns a new collection with entries that do not satisfy the predicate.\n*   `push(value)`: For `List`s, returns a new List with `value` added to the end.\n\nWhile `Immutable.js` was widely adopted with Redux in the past, modern Redux often uses Immer internally, which provides mutability-like syntax for immutable updates, offering a more ergonomic developer experience while still ensuring immutability behind the scenes.",
      "examples": [
        {
          "id": "example_immutable_js_structural_sharing_1",
          "title": "Basic Structural Sharing with Map.set",
          "code": "import { Map } from 'immutable';\n\nconst originalMap = Map({ a: 1, b: 2, c: 3 });\nconsole.log('Original Map:', originalMap.toJS());\n\n// When 'b' is updated, a new Map is returned.\n// Internally, 'a' and 'c' pointers are shared with originalMap.\nconst newMap = originalMap.set('b', 20);\n\nconsole.log('New Map:', newMap.toJS());\nconsole.log('Original Map (after update):', originalMap.toJS()); // Original is untouched\n\n// Check if 'a' and 'c' are the same reference (conceptually, not directly exposed)\n// originalMap.get('a') === newMap.get('a') is true for Immutable.js values if they are primitive\n// or refer to the same nested immutable structure.\nconsole.log('Is originalMap === newMap?', originalMap === newMap); // false (different objects)\nconsole.log('Is originalMap.get(\"a\") === newMap.get(\"a\")?', originalMap.get('a') === newMap.get('a')); // true (value is primitive, so same value)\n\nconst anotherMap = originalMap.set('d', 4);\n// 'a', 'b', 'c' are shared between originalMap and anotherMap.\nconsole.log('Another Map:', anotherMap.toJS());\n",
          "explanation": "This example demonstrates how `Immutable.Map.set()` creates a new `Map` instance when a value is updated, ensuring the original map remains unchanged. Crucially, even though `newMap` is a distinct object, `Immutable.js` optimizes memory by structurally sharing the unchanged parts (`'a'` and `'c'`) between `originalMap` and `newMap`. This means the internal nodes representing those key-value pairs are the same in memory, making the operation efficient.",
          "language": "javascript"
        },
        {
          "id": "example_immutable_js_update_list",
          "title": "Updating Nested Immutable Data",
          "code": "import { Map, List } from 'immutable';\n\nconst initialState = Map({\n  user: Map({\n    id: 1,\n    name: 'Alice',\n    preferences: List(['dark_mode', 'notifications'])\n  })\n});\n\nconsole.log('Initial State:', initialState.toJS());\n\n// Add a new preference without mutating the original state\nconst newState = initialState.updateIn(['user', 'preferences'], prefs => prefs.push('email_updates'));\n\nconsole.log('New State:', newState.toJS());\nconsole.log('Original State (unchanged):', initialState.toJS());\n\n// Deep comparison of preferences lists\nconsole.log('Are preference lists the same object?', initialState.getIn(['user', 'preferences']) === newState.getIn(['user', 'preferences'])); // false\n\n// Are user maps the same object?\nconsole.log('Are user maps the same object?', initialState.get('user') === newState.get('user')); // false\n\n// Is root state object the same?\nconsole.log('Is root state object the same?', initialState === newState); // false\n",
          "explanation": "This example illustrates how to update nested immutable data structures using `updateIn`. When a change occurs deep within the `Map` (e.g., adding an item to the `preferences` `List`), `Immutable.js` efficiently creates new `List` and `Map` instances only for the modified path (`preferences` -> `user` -> root `Map`). All other parts of the data structure that haven't changed are structurally shared, leading to optimized memory usage and performance.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "Immutable.js",
        "Structural Sharing",
        "Persistent Data Structures",
        "Immutability",
        "Performance",
        "React",
        "Redux"
      ],
      "prerequisites": [
        "javascript_objects",
        "data_structures_basics"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "Immutable.js",
      "Structural Sharing",
      "Persistent Data Structures",
      "Immutability",
      "Performance",
      "React",
      "Redux"
    ],
    "prerequisites": [
      "javascript_objects",
      "data_structures_basics"
    ]
  },
  {
    "index": 105,
    "id": "theory_immutable_js_intro",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Introduction to Immutable.js and Persistent Data Structures",
    "description": "",
    "content": {
      "id": "theory_immutable_js_intro",
      "title": "Introduction to Immutable.js and Persistent Data Structures",
      "description": "",
      "type": "theory",
      "content": "## What is Immutability?\nImmutability, in programming, means that once an object is created, it cannot be changed. Any operation that appears to modify the object actually returns a new object with the desired changes, leaving the original object untouched.\n\n## Why Immutability in Frontend Development?\n1.  **Predictability:** Immutable data flow is easier to reason about. When data doesn't change, its state is always clear, reducing bugs related to unexpected side effects.\n2.  **Performance Optimization (especially in React/Redux):** In frameworks like React, immutability simplifies change detection. Instead of deep comparisons, a simple reference equality check (`===`) is sufficient to determine if an object has changed. This is crucial for optimizing re-renders in components (e.g., using `PureComponent` or `React.memo`).\n3.  **Structural Sharing:** Immutable.js leverages structural sharing, which means that when a new version of a data structure is created, it reuses as much of the old structure as possible. Only the parts that have actually changed are copied. This minimizes memory consumption and improves performance for large data sets.\n    *   Example: If you have a `List` of 1000 items and you `push` a new item, a new `List` is returned, but it shares the underlying 1000 items with the original list. Only the new item and a small number of internal nodes are truly new.\n4.  **Easier Debugging and Time-Travel Debugging:** With immutable data, you have a complete history of states, making it straightforward to track how data evolved over time. This enables powerful debugging techniques like time-travel debugging in Redux DevTools.\n5.  **Concurrency:** While less critical in single-threaded JavaScript, immutability fundamentally simplifies concurrent programming by eliminating race conditions on shared mutable state.\n\n## What is Immutable.js?\nImmutable.js is a library created by Facebook that provides a collection of immutable, persistent data structures for JavaScript. These structures are highly optimized for performance, especially when dealing with frequent updates to large collections. It offers data structures like `List`, `Map`, `Set`, `Stack`, and `Queue`, which are analogous to their mutable JavaScript counterparts but guarantee immutability.",
      "examples": [],
      "complexity": 7,
      "tags": [
        "Immutable.js",
        "Immutability",
        "Functional Programming",
        "Performance",
        "React"
      ],
      "prerequisites": [
        "JavaScript_basics",
        "Data_structures_basics"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "Immutable.js",
      "Immutability",
      "Functional Programming",
      "Performance",
      "React"
    ],
    "prerequisites": [
      "JavaScript_basics",
      "Data_structures_basics"
    ]
  },
  {
    "index": 107,
    "id": "theory_event_loop_async_js",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "JavaScript Event Loop and Asynchronous Execution",
    "description": "",
    "content": {
      "id": "theory_event_loop_async_js",
      "title": "JavaScript Event Loop and Asynchronous Execution",
      "description": "",
      "type": "theory",
      "content": "## Core Concepts\nJavaScript engines are inherently **single-threaded**, meaning they can only perform one operation at a time. This single-threaded nature is crucial to understand how JavaScript processes code.\n\nWhile the main JavaScript thread executes code synchronously, blocking the interface until operations complete, **Web APIs** (provided by the browser environment, not the JavaScript engine itself) manage asynchronous operations. These Web APIs include functionalities like `setTimeout`, `fetch`, DOM events, and more.\n\nWhen an asynchronous operation initiated by a Web API completes, its associated callback function is not immediately executed. Instead, it's placed into the **Callback Queue** (also known as the Task Queue or Macrotask Queue).\n\nThe **Event Loop** is a continuously running process that acts as the bridge between the Callback Queue and the Call Stack. Its primary responsibility is to check if the Call Stack is empty. If the Call Stack is empty, the Event Loop takes the first message (callback function) from the Callback Queue and pushes it onto the Call Stack for execution. This ensures that non-blocking, asynchronous operations do not interfere with the execution of synchronous code and maintain UI responsiveness.\n\n## Practical Application: Zero Delay `setTimeout`\nUsing `setTimeout` with a zero delay (`setTimeout(callback, 0)`) is a common pattern to defer the execution of a function until the current Call Stack is completely cleared. This means the callback will run after all currently executing functions and any pending synchronous code have finished, but before any new asynchronous tasks (that might have been added to the queue later) are processed. It's useful for scenarios where you want to execute code after the UI has potentially rendered or updated, or to break up long-running synchronous tasks into smaller, non-blocking chunks.",
      "examples": [
        {
          "id": "example_event_loop_1",
          "title": "Basic Asynchronous Flow with setTimeout",
          "code": "console.log('Start');\n\nsetTimeout(() => {\n  console.log('Inside setTimeout callback (0ms delay)');\n}, 0);\n\nconsole.log('End');\n\n/*\nExpected Output:\nStart\nEnd\nInside setTimeout callback (0ms delay)\n\nExplanation:\n1. 'Start' is logged immediately.\n2. setTimeout schedules its callback with the Web API. Even with 0ms delay, it's an async operation.\n3. 'End' is logged immediately because setTimeout is non-blocking.\n4. Once the Call Stack is empty (after 'End' is logged), the Event Loop moves the setTimeout callback from the Callback Queue to the Call Stack.\n5. The callback executes, logging 'Inside setTimeout callback (0ms delay)'.\n*/",
          "explanation": "This example illustrates the fundamental concept of the Event Loop. Synchronous code (`console.log('Start')`, `console.log('End')`) executes first. The `setTimeout` callback is offloaded to the Web API and then placed in the callback queue, only to be processed once the main call stack is empty, demonstrating non-blocking behavior.",
          "language": "typescript"
        },
        {
          "id": "example_event_loop_2",
          "title": "Deferring UI Updates with setTimeout(0)",
          "code": "function performComplexCalculation() {\n  let sum = 0;\n  for (let i = 0; i < 1000000000; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\nconst statusElement = document.getElementById('status');\n\nif (statusElement) {\n  statusElement.textContent = 'Calculating...';\n}\n\n// This will block the UI until calculation is done if not deferred\n// performComplexCalculation();\n\n// Defer the heavy calculation to avoid blocking UI update immediately\nsetTimeout(() => {\n  const result = performComplexCalculation();\n  if (statusElement) {\n    statusElement.textContent = `Calculation complete: ${result}`;\n  }\n  console.log('Heavy calculation finished.');\n}, 0); \n\nconsole.log('UI updated and calculation deferred.');\n\n// Assume there's an HTML element with id='status'\n// <div id=\"status\"></div>\n",
          "explanation": "This example demonstrates a practical use case for `setTimeout(0)`. By wrapping a computationally intensive function (`performComplexCalculation`) in `setTimeout(0)`, we ensure that the initial UI update (`statusElement.textContent = 'Calculating...'`) is rendered before the heavy calculation blocks the thread. This makes the application feel more responsive.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "JavaScript",
        "Asynchronous",
        "Event Loop",
        "Concurrency",
        "Web APIs"
      ],
      "prerequisites": [
        "Basic JavaScript Syntax",
        "Understanding of Functions",
        "DOM Manipulation (for UI examples)"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "JavaScript",
      "Asynchronous",
      "Event Loop",
      "Concurrency",
      "Web APIs"
    ],
    "prerequisites": [
      "Basic JavaScript Syntax",
      "Understanding of Functions",
      "DOM Manipulation (for UI examples)"
    ]
  },
  {
    "index": 111,
    "id": "theory_web_workers_intro",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Introduction to Web Workers",
    "description": "",
    "content": {
      "id": "theory_web_workers_intro",
      "title": "Introduction to Web Workers",
      "description": "",
      "type": "theory",
      "content": "Web Workers provide a way to run scripts in background threads, separate from the main execution thread of a web page. This allows for long-running scripts to execute without blocking the user interface (UI), ensuring a smooth and responsive user experience. They are particularly useful for performing computationally intensive tasks such as complex calculations, data processing, or large network requests.\n\n## Key Concepts\n- **Background Execution:** Workers run on a separate thread, preventing UI freezing.\n- **No DOM Access:** Web Workers do not have direct access to the DOM (Document Object Model) of the main page. All interactions with the UI must be done by sending messages to the main thread.\n- **Communication:** Communication between the main thread and a worker thread is done via message passing using the `postMessage()` method and handling messages with the `onmessage` event handler.\n- **Dedicated Workers:** The most common type, dedicated to a single script. Each worker has its own global scope.\n- **Shared Workers:** Can be accessed by multiple scripts from different windows, iframes, or even other workers, provided they are from the same origin.\n- **Service Workers:** Used for intercepting network requests, caching assets, and enabling offline experiences. (Not covered in detail here but important for context).\n\n## Worker Life Cycle\n1.  **Creation:** A `Worker` object is created in the main thread, referencing the worker script.\n2.  **Communication:** Messages are sent using `postMessage()` and received via `onmessage`.\n3.  **Termination:** A worker can be terminated from the main thread using `worker.terminate()` or from within the worker itself using `self.close()`.\n\n## Limitations\n- Cannot directly manipulate the DOM.\n- Cannot access global variables or functions defined on the main page.\n- Restricted access to certain browser APIs (e.g., `alert()`, `confirm()`, `document`, `window`).\n\n## Performance Benefits\nBy offloading heavy computations to a worker thread, the main thread remains free to handle UI updates, user input, and other critical tasks, leading to a more fluid and responsive application.",
      "examples": [
        {
          "id": "example_web_workers_1",
          "title": "Main Thread Script (index.js)",
          "code": "// index.js (main thread)\n\n// Check if Web Workers are supported\nif (window.Worker) {\n  const myWorker = new Worker('worker.js');\n\n  // Send data to the worker\n  myWorker.postMessage('Start calculation');\n  console.log('Message sent to worker');\n\n  // Listen for messages from the worker\n  myWorker.onmessage = function(event) {\n    console.log('Received from worker:', event.data);\n    // Update UI based on worker's result (e.g., display result)\n    const resultElement = document.getElementById('result');\n    if (resultElement) {\n      resultElement.textContent = 'Worker says: ' + event.data;\n    }\n  };\n\n  // Handle errors from the worker\n  myWorker.onerror = function(error) {\n    console.error('Worker error:', error);\n  };\n\n  // Example of terminating the worker after some time\n  setTimeout(() => {\n    myWorker.terminate();\n    console.log('Worker terminated.');\n  }, 5000);\n} else {\n  console.log('Web Workers are not supported in this browser.');\n}",
          "explanation": "This JavaScript code runs in the main browser thread. It creates a new `Worker` instance, loads `worker.js`, sends an initial message, and sets up an `onmessage` handler to receive results back. It also demonstrates error handling and termination.",
          "language": "javascript"
        },
        {
          "id": "example_web_workers_2",
          "title": "Worker Script (worker.js)",
          "code": "// worker.js\n\nself.onmessage = function(event) {\n  console.log('Received from main thread in worker:', event.data);\n  // Perform a heavy calculation (e.g., Fibonacci)\n  const calculateFibonacci = (n) => {\n    if (n <= 1) return n;\n    return calculateFibonacci(n - 1) + calculateFibonacci(n - 2);\n  };\n\n  const result = calculateFibonacci(40); // A moderately heavy calculation\n\n  // Send data back to the main thread\n  self.postMessage('Calculation complete! Result: ' + result);\n};\n\n// Handle errors from the worker itself\nself.onerror = function(error) {\n  console.error('Error within worker:', error);\n};\n\n// Optional: respond to termination\nself.onclose = function() {\n  console.log('Worker is about to be terminated.');\n};",
          "explanation": "This script runs in the worker thread. It listens for messages from the main thread using `self.onmessage`, performs a long-running computation (like calculating a Fibonacci number), and then sends the result back to the main thread using `self.postMessage()`. `self` refers to the global scope of the worker.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "JavaScript",
        "Web Workers",
        "Concurrency",
        "Performance",
        "Frontend Architecture"
      ],
      "prerequisites": [
        "javascript_basics",
        "event_loop"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "JavaScript",
      "Web Workers",
      "Concurrency",
      "Performance",
      "Frontend Architecture"
    ],
    "prerequisites": [
      "javascript_basics",
      "event_loop"
    ]
  },
  {
    "index": 129,
    "id": "theory_webpack_fundamentals",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Webpack Fundamentals: Basic Configuration and Core Concepts",
    "description": "",
    "content": {
      "id": "theory_webpack_fundamentals",
      "title": "Webpack Fundamentals: Basic Configuration and Core Concepts",
      "description": "",
      "type": "theory",
      "content": "Webpack is a static module bundler for modern JavaScript applications. When Webpack processes your application, it internally builds a dependency graph from one or more entry points and then combines every module your project needs into one or more bundles.\n\n## Key Concepts\n\n*   **Entry**: The `entry` property indicates which module Webpack should use to begin building its internal dependency graph. Webpack will figure out which other modules and libraries that entry point depends on (directly and indirectly).\n*   **Output**: The `output` property tells Webpack where to emit the bundles it creates and how to name these files.\n    *   `path.resolve(__dirname, 'dist')`: Specifies the absolute path to the output directory.\n    *   `filename: 'bundle.[contenthash].js'`: Defines the name of the output bundle. `[contenthash]` is a placeholder that will be replaced by a hash of the content of the bundled file. This is useful for cache busting in production.\n*   **Loaders**: Loaders are crucial for Webpack. They tell Webpack how to process different types of files as modules in your dependency graph. For example, you can use loaders to transpile JavaScript (e.g., ES6+ to ES5), compile CSS/Sass/Less, or load image files.\n    *   `test`: A regular expression that matches the file types to be processed by the loader.\n    *   `exclude`: Specifies paths that should not be processed by the loader (e.g., `node_modules`).\n    *   `use`: An array of loaders to apply to the matching files. Loaders are applied in reverse order (right to left).\n        *   `babel-loader`: Transpiles modern JavaScript/React code into compatible versions for older browsers. Requires `@babel/preset-env` for general JS and `@babel/preset-react` for JSX.\n        *   `css-loader`: Interprets `@import` and `url()` like `import/require()` and resolves them.\n        *   `style-loader`: Injects CSS into the DOM by adding `<style>` tags.\n        *   `file-loader`: Resolves `import`/`require` on a file into a url and emits the file into the output directory.\n*   **Plugins**: Plugins are powerful tools that can perform a wide range of tasks, from bundle optimization and asset management to injecting environment variables. They hook into the entire compilation lifecycle.\n    *   `HtmlWebpackPlugin`: Simplifies creation of HTML files to serve your webpack bundles. This is especially useful for bundles with a `contenthash` in their filenames which change every compilation.\n*   **DevServer**: `webpack-dev-server` provides a simple web server with live reloading and hot module replacement (HMR) capabilities. It serves your bundled application from memory, making development faster.\n    *   `contentBase: './dist'`: Specifies the directory from which to serve static files.\n    *   `hot: true`: Enables Hot Module Replacement (HMR), which allows modules to be updated in the browser without a full page reload, preserving application state.\n\nWebpack's extensibility through loaders and plugins makes it a highly flexible and powerful tool for managing complex frontend builds, optimizing assets, and ensuring consistent application behavior across different environments.",
      "examples": [
        {
          "id": "example_webpack_basic_config",
          "title": "Basic Webpack Configuration",
          "code": "const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.[contenthash].js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react']\n          }\n        }\n      },\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      },\n      {\n        test: /\\.(png|svg|jpg|gif)$/,\n        use: ['file-loader']\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  devServer: {\n    contentBase: './dist',\n    hot: true\n  }\n};",
          "explanation": "This configuration sets up Webpack to bundle JavaScript, CSS, and image assets. It uses Babel for JavaScript transpilation, specific loaders for CSS and images, and `HtmlWebpackPlugin` to generate an HTML file that includes the bundled assets. The `devServer` is configured for live reloading and Hot Module Replacement during development.",
          "language": "javascript"
        },
        {
          "id": "example_webpack_run_script",
          "title": "Running Webpack via npm script",
          "code": "{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"build\": \"webpack --mode production\",\n    \"start\": \"webpack serve --mode development\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.23.9\",\n    \"@babel/preset-env\": \"^7.23.9\",\n    \"@babel/preset-react\": \"^7.23.3\",\n    \"babel-loader\": \"^9.1.3\",\n    \"css-loader\": \"^6.9.1\",\n    \"file-loader\": \"^6.2.0\",\n    \"html-webpack-plugin\": \"^5.6.0\",\n    \"style-loader\": \"^3.3.4\",\n    \"webpack\": \"^5.90.0\",\n    \"webpack-cli\": \"^5.1.4\",\n    \"webpack-dev-server\": \"^4.11.1\"\n  }\n}",
          "explanation": "This `package.json` snippet shows how to define `npm` scripts to run Webpack for building a production bundle (`webpack --mode production`) and starting a development server (`webpack serve --mode development`). It also lists the necessary Webpack and Babel related dependencies.",
          "language": "json"
        }
      ],
      "complexity": 7,
      "tags": [
        "Webpack",
        "Bundler",
        "Configuration",
        "Frontend Build",
        "JavaScript",
        "Tools"
      ],
      "prerequisites": [
        "Node.js",
        "npm/yarn",
        "Basic JavaScript Modules"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "Webpack",
      "Bundler",
      "Configuration",
      "Frontend Build",
      "JavaScript",
      "Tools"
    ],
    "prerequisites": [
      "Node.js",
      "npm/yarn",
      "Basic JavaScript Modules"
    ]
  },
  {
    "index": 145,
    "id": "theory_array_prototype_extension_flatten",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Array Prototype Extension and Deep Flattening",
    "description": "",
    "content": {
      "id": "theory_array_prototype_extension_flatten",
      "title": "Array Prototype Extension and Deep Flattening",
      "description": "",
      "type": "theory",
      "content": "## Extending Array Prototype\nJavaScript allows extending built-in object prototypes, such as `Array.prototype`. This enables adding new methods directly to array instances, making them available on all arrays. A common pattern is to check `if (!Array.prototype.methodName)` before defining a polyfill, ensuring that the method is only added if it doesn't already exist natively.\n\n## Array Flattening\nArray flattening is the process of converting a multi-dimensional array into a one-dimensional array. This can be shallow (only flattening one level deep) or deep (flattening all nested arrays recursively).\n\n### Recursive Flattening Implementation\nA common approach for deep flattening is recursion. The function iterates through the array; if an element is an array, it recursively calls itself on that element and concatenates the results. Otherwise, it adds the element directly to the result.\n\nNative JavaScript provides `Array.prototype.flat()` and `Array.prototype.flatMap()` for flattening arrays, which are more performant and robust than custom polyfills for production use. `flat()` takes an optional `depth` argument (defaulting to 1) to control how many levels to flatten. `Infinity` can be passed to flatten all levels.\n\n## Example Code (Polyfill for `flatten`)\n```javascript\n/**\n * Recursively flattens a nested array into a single-dimensional array.\n * @param {Array} array The array to flatten.\n * @returns {Array} The flattened array.\n */\nfunction flatten(array) {\n  let result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (Array.isArray(array[i])) {\n      result = result.concat(flatten(array[i])); // Recursively flatten nested arrays\n    } else {\n      result.push(array[i]); // Add non-array elements directly\n    }\n  }\n  return result;\n}\n\n// Polyfill check to add `flatten` method to Array.prototype if it doesn't exist\nif (!Array.prototype.flatten) {\n  Array.prototype.flatten = function() {\n    // 'this' refers to the array instance on which 'flatten' is called\n    return flatten(this);\n  };\n}\n```\n\n",
      "examples": [
        {
          "id": "example_array_flatten_1",
          "title": "Using the Custom Flatten Polyfill",
          "code": "let arr = [1, 2, [3, 4, [5, 6, [7, [8, 9, 10]]]]];\nconsole.log(arr.flatten()); // Expected: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]",
          "explanation": "This example demonstrates how the `flatten` method, added to `Array.prototype`, can be called directly on an array instance to deeply flatten its contents, producing a single-dimensional array from a deeply nested structure.",
          "language": "javascript"
        },
        {
          "id": "example_array_flatten_2",
          "title": "Native `Array.prototype.flat()` vs. Custom",
          "code": "const nestedArray = [1, [2, 3], [4, [5]]];\n\n// Using custom flatten (if polyfill is present)\n// console.log(nestedArray.flatten()); // [1, 2, 3, 4, 5]\n\n// Using native flat() for shallow flatten\nconsole.log(nestedArray.flat()); // [1, 2, 3, 4, [5]]\n\n// Using native flat() for deep flatten\nconsole.log(nestedArray.flat(Infinity)); // [1, 2, 3, 4, 5]",
          "explanation": "This example contrasts the behavior of a custom deep flatten function with the native `Array.prototype.flat()` method. It shows that `flat()` by default performs a shallow flatten (depth 1), and requires `Infinity` to achieve full deep flattening, similar to the custom implementation.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "Array",
        "Prototype",
        "Polyfill",
        "Recursion",
        "Data Structures",
        "Functional Programming"
      ],
      "prerequisites": [
        "javascript_basics",
        "functions",
        "array_methods"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "Array",
      "Prototype",
      "Polyfill",
      "Recursion",
      "Data Structures",
      "Functional Programming"
    ],
    "prerequisites": [
      "javascript_basics",
      "functions",
      "array_methods"
    ]
  },
  {
    "index": 146,
    "id": "theory_data_manipulation",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Data Manipulation: Filtering, Sorting, and Aggregation in JavaScript",
    "description": "",
    "content": {
      "id": "theory_data_manipulation",
      "title": "Data Manipulation: Filtering, Sorting, and Aggregation in JavaScript",
      "description": "",
      "type": "theory",
      "content": "This section covers fundamental JavaScript array methods (`filter`, `map`, `sort`, `reduce`) used for efficient data processing, transformation, and aggregation. These methods are crucial for handling lists of data in modern web applications.\n\n## Key Concepts\n\n### `Array.prototype.filter()`\nThe `filter()` method creates a new array with all elements that pass the test implemented by the provided function. It's used for selecting a subset of elements from an array based on a condition.\n\n### `Array.prototype.map()`\nThe `map()` method creates a new array populated with the results of calling a provided function on every element in the calling array. It's used for transforming elements without altering the original array's length or structure, but changing the content or adding new properties.\n\n### `Array.prototype.sort()`\nThe `sort()` method sorts the elements of an array *in place* and returns the sorted array. The default sort order is ascending, built upon converting the elements into strings, then comparing their sequences of UTF-16 code units. For numeric or complex object sorting, a comparison function must be provided. This function takes two arguments (`a`, `b`) and should return:\n- A negative value if `a` should come before `b`.\n- A positive value if `a` should come after `b`.\n- `0` if `a` and `b` are considered equal.\n\n### `Array.prototype.reduce()`\nThe `reduce()` method executes a user-supplied 'reducer' callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements is a single value. It's highly versatile and can be used for summing values, flattening arrays, counting occurrences, or calculating averages.\n\n### Helper Functions for Modularity\nComplex data manipulation often benefits from breaking down logic into smaller, reusable helper functions. This improves readability, maintainability, and testability. Examples include functions for case conversion (`toLower`), substring checks (`isSubString`), or aggregate calculations (`getAvgRating`).\n\n### Combining Operations\nReal-world scenarios often require a sequence of these operations: first filtering data, then transforming it, and finally sorting it. The order of operations is crucial as it affects the intermediate and final results.",
      "examples": [
        {
          "id": "example_data_manipulation_1",
          "title": "Basic Array Method Usage",
          "code": "const numbers = [1, 2, 3, 4, 5];\n\n// filter: get even numbers\nconst evenNumbers = numbers.filter(num => num % 2 === 0);\n// evenNumbers is [2, 4]\n\n// map: double each number\nconst doubledNumbers = numbers.map(num => num * 2);\n// doubledNumbers is [2, 4, 6, 8, 10]\n\n// reduce: sum all numbers\nconst sum = numbers.reduce((acc, num) => acc + num, 0);\n// sum is 15\n\n// sort: descending order\nconst sortedNumbers = [...numbers].sort((a, b) => b - a);\n// sortedNumbers is [5, 4, 3, 2, 1]",
          "explanation": "This example demonstrates the basic usage of `filter`, `map`, `reduce`, and `sort` for common array manipulations. Note the use of `[...numbers]` before `sort` to avoid modifying the original array in place.",
          "language": "typescript"
        },
        {
          "id": "example_data_manipulation_2",
          "title": "Calculating Average Rating (`getAvgRating`)",
          "code": "const moviesWithRatings = [\n  { id: 1, movie_id: 101, rating: 8 },\n  { id: 2, movie_id: 102, rating: 7 },\n  { id: 3, movie_id: 101, rating: 9 },\n  { id: 4, movie_id: 103, rating: 6 }\n];\n\nconst getAvgRating = (movie, allRatings) => {\n  let count = 0;\n  const totalRating = allRatings.reduce((acc, value) => {\n    if (movie.id === value.movie_id) {\n      acc += value.rating;\n      count++;\n    }\n    return acc;\n  }, 0);\n  return count > 0 ? totalRating / count : 0;\n};\n\nconst movie101 = { id: 101, name: \"Movie A\" };\nconst avgRatingMovieA = getAvgRating(movie101, moviesWithRatings);\n// avgRatingMovieA is (8 + 9) / 2 = 8.5",
          "explanation": "This helper function calculates the average rating for a given movie by iterating through all available ratings using `reduce`. It accumulates the sum of ratings and counts the number of relevant ratings to compute the average.",
          "language": "typescript"
        },
        {
          "id": "example_data_manipulation_3",
          "title": "Substring Check (`isSubString`)",
          "code": "const toLower = str => str.toLowerCase();\n\nconst isSubString = (str1, str2) => {\n  // Normalize strings by converting to lower case and removing spaces\n  str1 = toLower(str1.split(\" \").join(\"\"));\n  str2 = toLower(str2.split(\" \").join(\"\"));\n  \n  // Check if one string starts with the other, regardless of length\n  if (str1.length > str2.length) {\n    return str1.startsWith(str2);\n  } else {\n    return str2.startsWith(str1);\n  }\n};\n\nconsole.log(isSubString(\"The Dark Knight\", \"dark\")); // true\nconsole.log(isSubString(\"Avengers\", \"The Avengers\")); // true\nconsole.log(isSubString(\"Hello World\", \"world hello\")); // false",
          "explanation": "The `isSubString` function checks if one string is a substring of another after normalizing them (converting to lowercase and removing spaces). It intelligently handles cases where `str1` is longer than `str2` or vice-versa by using `startsWith` on the longer string with the shorter one.",
          "language": "typescript"
        },
        {
          "id": "example_data_manipulation_4",
          "title": "Dynamic Sorting Logic",
          "code": "const movies = [\n  { name: 'Movie C', year: 2000 },\n  { name: 'Movie A', year: 2010 },\n  { name: 'Movie B', year: 1995 }\n];\n\n// Sort by 'year' ascending\nlet sortedByYearAsc = [...movies].sort((a, b) => a['year'] - b['year']);\n// [{ name: 'Movie B', year: 1995 }, { name: 'Movie C', year: 2000 }, { name: 'Movie A', year: 2010 }]\n\n// Sort by 'name' descending\nlet sortedByNameDesc = [...movies].sort((a, b) => {\n  const value1 = a['name'];\n  const value2 = b['name'];\n  return value1 > value2 ? -1 : (value1 < value2 ? 1 : 0);\n});\n// [{ name: 'Movie C', year: 2000 }, { name: 'Movie B', year: 1995 }, { name: 'Movie A', year: 2010 }]\n\n// Example of how `queryMovies` handles sort parameter:\n// sort: \"-year\" for descending, \"name\" for ascending\nconst applySort = (arr, sortParam) => {\n    const isDescending = sortParam[0] === '-';\n    let sortField = isDescending ? sortParam.slice(1) : sortParam;\n\n    return [...arr].sort((a, b) => {\n        const value1 = a[sortField];\n        const value2 = b[sortField];\n        \n        if (typeof value1 === 'string') {\n            return isDescending ? value2.localeCompare(value1) : value1.localeCompare(value2);\n        } else {\n            return isDescending ? value2 - value1 : value1 - value2;\n        }\n    });\n};\n\nconst moviesSortedByYearDesc = applySort(movies, '-year');\nconst moviesSortedByNameAsc = applySort(movies, 'name');",
          "explanation": "This example illustrates how sorting logic can be made dynamic based on a `sort` parameter. It extracts the sort field and direction (ascending/descending) from the parameter and applies the appropriate comparison logic. It differentiates between string and number comparison for robustness.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "JavaScript",
        "Array Methods",
        "Data Manipulation",
        "Filtering",
        "Sorting",
        "Aggregation",
        "Functional Programming"
      ],
      "prerequisites": [
        "basic_javascript_syntax",
        "functions",
        "arrays"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "JavaScript",
      "Array Methods",
      "Data Manipulation",
      "Filtering",
      "Sorting",
      "Aggregation",
      "Functional Programming"
    ],
    "prerequisites": [
      "basic_javascript_syntax",
      "functions",
      "arrays"
    ]
  },
  {
    "index": 147,
    "id": "theory_async_data_processing",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Asynchronous Data Fetching and Transformation with Promise.all",
    "description": "",
    "content": {
      "id": "theory_async_data_processing",
      "title": "Asynchronous Data Fetching and Transformation with Promise.all",
      "description": "",
      "type": "theory",
      "content": "This section explains how to efficiently fetch data asynchronously and transform it using modern JavaScript features like `async/await` and `Promise.all`, along with array manipulation methods like `filter` and `reduce`.\n\n## Key Concepts\n\n### Asynchronous JavaScript (`async/await`)\n`async/await` is syntactic sugar built on top of Promises, designed to make asynchronous code easier to read and write. An `async` function always returns a Promise. The `await` keyword can only be used inside an `async` function and pauses the execution of the `async` function until the Promise is settled (resolved or rejected).\n\n### Parallel Promise Execution (`Promise.all`)\n`Promise.all` is a static method on the `Promise` object that takes an iterable of Promises (e.g., an array) as input. It returns a single Promise that fulfills when all of the input Promises have fulfilled, or rejects if any of the input Promises reject. The fulfillment value is an array of the fulfillment values of the input Promises, in the same order as the input.\n\n`Promise.all` is crucial for scenarios where multiple independent asynchronous operations need to complete before proceeding, optimizing performance by running them concurrently rather than sequentially.\n\n### Array Manipulation (`filter`, `reduce`)\n*   **`Array.prototype.filter()`**: Creates a new array with all elements that pass the test implemented by the provided function. It's used here to efficiently select comments belonging to a specific post.\n*   **`Array.prototype.reduce()`**: Executes a user-supplied 'reducer' callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value. It's used for aggregating or transforming data into a single, comprehensive structure (e.g., an object mapping posts to their comments).\n\n### Error Handling (`try...catch`)\nWhen working with `async/await`, `try...catch` blocks are the standard way to handle potential errors. Any rejected Promise awaited within a `try` block will throw an error that can be caught by the corresponding `catch` block.",
      "examples": [
        {
          "id": "example_async_data_processing_1",
          "title": "Fetch and Map Data Example",
          "code": "/**\n * Mock function to simulate fetching all posts from an API.\n * @returns {Promise<Array<{id: number, title: string, body: string}>>}\n */\nconst fetchAllPosts = () => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve([\n        { id: 1, title: 'Post 1', body: 'Content of post 1' },\n        { id: 2, title: 'Post 2', body: 'Content of post 2' }\n      ]);\n    }, 100);\n  });\n};\n\n/**\n * Mock function to simulate fetching all comments from an API.\n * @returns {Promise<Array<{id: number, postId: number, body: string}>>}\n */\nconst fetchAllComments = () => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve([\n        { id: 101, postId: 1, body: 'Comment for post 1' },\n        { id: 102, postId: 2, body: 'Comment for post 2' },\n        { id: 103, postId: 1, body: 'Another comment for post 1' }\n      ]);\n    }, 150);\n  });\n};\n\nconst fetchAndMapData = async () => {\n  try {\n    // Fetch both posts and comments in parallel using Promise.all\n    const [posts, comments] = await Promise.all([\n      fetchAllPosts(),\n      fetchAllComments()\n    ]);\n\n    // Function to get all comments for a specific post using filter\n    const getCommentsForPost = postId =>\n      comments.filter(comment => comment.postId === postId);\n\n    // Map posts to their comments using reduce\n    const postsWithComments = posts.reduce((result, post) => {\n      result[post.id] = {\n        ...post,\n        comments: getCommentsForPost(post.id)\n      };\n      return result;\n    }, {}); // Initialize accumulator as an empty object\n\n    return postsWithComments;\n  } catch (error) {\n    console.error('Error fetching data:', error);\n    return {}; // Return an empty object on error\n  }\n};\n\n// Usage example\nfetchAndMapData().then(data => {\n  console.log('Posts with comments:', data);\n  /*\n  Expected output:\n  {\n    '1': {\n      id: 1,\n      title: 'Post 1',\n      body: 'Content of post 1',\n      comments: [\n        { id: 101, postId: 1, body: 'Comment for post 1' },\n        { id: 103, postId: 1, body: 'Another comment for post 1' }\n      ]\n    },\n    '2': {\n      id: 2,\n      title: 'Post 2',\n      body: 'Content of post 2',\n      comments: [\n        { id: 102, postId: 2, body: 'Comment for post 2' }\n      ]\n    }\n  }\n  */\n});\n",
          "explanation": "This example demonstrates a common pattern in web development: fetching multiple related pieces of data from different endpoints and then combining them into a single, meaningful structure. `Promise.all` ensures that both `fetchAllPosts` and `fetchAllComments` run concurrently, significantly reducing the total waiting time compared to fetching them sequentially. Once both promises resolve, the `posts` and `comments` arrays are available. The `getCommentsForPost` helper uses `filter` to efficiently find relevant comments, and finally, `reduce` is used to transform the `posts` array into an object where each post is keyed by its `id` and augmented with its corresponding comments. Error handling is included via a `try...catch` block to gracefully manage network or data fetching failures.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "asynchronous-javascript",
        "promises",
        "async-await",
        "array-methods",
        "data-transformation",
        "error-handling",
        "frontend-architecture"
      ],
      "prerequisites": [
        "Promises",
        "Functions",
        "Objects",
        "Arrays"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "asynchronous-javascript",
      "promises",
      "async-await",
      "array-methods",
      "data-transformation",
      "error-handling",
      "frontend-architecture"
    ],
    "prerequisites": [
      "Promises",
      "Functions",
      "Objects",
      "Arrays"
    ]
  },
  {
    "index": 148,
    "id": "theory_custom_array_methods",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Custom Array Methods (Polyfills)",
    "description": "",
    "content": {
      "id": "theory_custom_array_methods",
      "title": "Custom Array Methods (Polyfills)",
      "description": "",
      "type": "theory",
      "content": "JavaScript array methods like `reduce`, `map`, `filter`, etc., are powerful tools for data manipulation. In some scenarios, especially when dealing with older environments or custom logic, one might need to implement a 'polyfill' or a custom version of these methods. A polyfill is a piece of code (or a plugin) that provides the functionality that is natively not available in a web browser, but that you want to use.\n\nImplementing a custom `reduce` function, for instance, involves iterating through the array and accumulating a single value based on a provided callback function. This process demonstrates a fundamental understanding of how array iteration and aggregation work under the hood.\n\n### Array.prototype.reduce Explained\n\nThe `reduce()` method executes a user-supplied 'reducer' callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value.\n\n**Syntax:**\n`arr.reduce(callback(accumulator, currentValue, currentIndex, array), initialValue)`\n\n- `callback`: A function to execute on each element in the array. It takes four arguments:\n    - `accumulator`: The accumulated value previously returned in the last invocation of the callback, or `initialValue`, if supplied.\n    - `currentValue`: The current element being processed in the array.\n    - `currentIndex` (Optional): The index of the current element being processed in the array. Starts from 0 if an `initialValue` is provided, and from 1 if not.\n    - `array` (Optional): The array `reduce()` was called upon.\n- `initialValue` (Optional): A value to use as the first argument to the first call of the `callback`. If no `initialValue` is supplied, the first element in the array will be used as the `accumulator` initial value and `currentValue` will start from the second element.",
      "examples": [
        {
          "id": "example_custom_reduce_1",
          "title": "Basic Custom Reduce Implementation",
          "code": "Array.prototype.customReduce = function(callback, initialValue) {\n  const arr = this;\n  let accumulator = initialValue;\n  let startIndex = 0;\n\n  if (initialValue === undefined) {\n    if (arr.length === 0) {\n      throw new TypeError('Reduce of empty array with no initial value');\n    }\n    accumulator = arr[0];\n    startIndex = 1;\n  }\n\n  for (let i = startIndex; i < arr.length; i++) {\n    accumulator = callback(accumulator, arr[i], i, arr);\n  }\n\n  return accumulator;\n};\n\n// Usage Example 1: Summing numbers\nconst numbers = [1, 2, 3, 4];\nconst sum = numbers.customReduce((acc, current) => acc + current, 0);\nconsole.log(sum); // 10\n\n// Usage Example 2: Flattening an array of arrays\nconst arrays = [[1, 2], [3, 4], [5, 6]];\nconst flattened = arrays.customReduce((acc, current) => acc.concat(current), []);\nconsole.log(flattened); // [1, 2, 3, 4, 5, 6]\n",
          "explanation": "This code block demonstrates a simple polyfill for `Array.prototype.reduce`. It correctly handles cases with and without an `initialValue`, and throws an error for an empty array without an `initialValue`, mimicking the native behavior. The `sum` example from the prompt is included here as a direct demonstration.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "JavaScript",
        "Array Methods",
        "Polyfill",
        "Functional Programming",
        "Higher-Order Functions"
      ],
      "prerequisites": [
        "javascript_basics",
        "functions",
        "arrays",
        "prototypes"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "JavaScript",
      "Array Methods",
      "Polyfill",
      "Functional Programming",
      "Higher-Order Functions"
    ],
    "prerequisites": [
      "javascript_basics",
      "functions",
      "arrays",
      "prototypes"
    ]
  },
  {
    "index": 152,
    "id": "theory_matrix_transformations",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Matrix Transformations: Rotation and Spiral Traversal",
    "description": "",
    "content": {
      "id": "theory_matrix_transformations",
      "title": "Matrix Transformations: Rotation and Spiral Traversal",
      "description": "",
      "type": "theory",
      "content": "## Matrix Rotation (90 Degrees Clockwise)\nMatrix rotation is a common operation in computer graphics and algorithms. For a square matrix, a 90-degree clockwise rotation can be performed in-place. One efficient approach involves iterating through layers of the matrix and cyclically shifting the four elements at each corner of the current layer. This method avoids the need for extra space.\n\n### Algorithm for In-place 90-degree Clockwise Rotation:\n1.  **Iterate through layers**: A square matrix of size `n x n` has `n / 2` layers (for `n` even) or `(n - 1) / 2` layers (for `n` odd). Loop from `layer = 0` to `floor(n / 2) - 1`.\n2.  **Define boundaries**: For each `layer`, define `first = layer` and `last = n - 1 - layer`. These represent the current layer's top-left and bottom-right boundaries.\n3.  **Iterate within the layer**: For each `i` from `first` to `last - 1` (this range ensures we pick unique elements for each cycle):\n    *   Store the top element: `top = matrix[first][i]`\n    *   Move left to top: `matrix[first][i] = matrix[last - (i - first)][first]`\n    *   Move bottom to left: `matrix[last - (i - first)][first] = matrix[last][last - (i - first)]`\n    *   Move right to bottom: `matrix[last][last - (i - first)] = matrix[i][last]`\n    *   Move stored top to right: `matrix[i][last] = top`\n\n## Spiral Matrix Traversal\nSpiral matrix traversal involves extracting elements from a matrix in a spiral order. This is typically achieved by maintaining four boundary pointers (top, bottom, left, right) and iteratively moving them inwards after traversing each side.\n\n### Algorithm for Spiral Traversal:\n1.  **Initialize boundaries**: `top = 0`, `bottom = matrix.length - 1`, `left = 0`, `right = matrix[0].length - 1`.\n2.  **Initialize direction**: `direction = 0` (0: right, 1: down, 2: left, 3: up).\n3.  **Loop while boundaries are valid**: Continue as long as `top <= bottom` and `left <= right`.\n    *   **Move Right (direction 0)**: Traverse from `left` to `right` along `matrix[top]`. Increment `top`.\n    *   **Move Down (direction 1)**: Traverse from `top` to `bottom` along `matrix[i][right]`. Decrement `right`.\n    *   **Move Left (direction 2)**: Traverse from `right` to `left` along `matrix[bottom]`. Decrement `bottom`.\n    *   **Move Up (direction 3)**: Traverse from `bottom` to `top` along `matrix[i][left]`. Increment `left`.\n4.  **Change direction**: After each side traversal, update `direction = (direction + 1) % 4` to cycle through the four directions.\n5.  **Collect results**: Add each visited element to a result array.",
      "examples": [
        {
          "id": "example_matrix_rotation_1",
          "title": "In-place Matrix Rotation (90 Degrees Clockwise)",
          "code": "function rotateMatrix(matrix) {\n  const n = matrix.length; // Assuming square matrix\n\n  for (let layer = 0; layer < Math.floor(n / 2); layer++) {\n    let first = layer;\n    let last = n - 1 - layer;\n\n    for (let i = first; i < last; i++) {\n      let offset = i - first;\n      // Save top-left element\n      let top = matrix[first][i];\n\n      // Move bottom-left to top-left\n      matrix[first][i] = matrix[last - offset][first];\n\n      // Move bottom-right to bottom-left\n      matrix[last - offset][first] = matrix[last][last - offset];\n\n      // Move top-right to bottom-right\n      matrix[last][last - offset] = matrix[i][last];\n\n      // Move saved top-left to top-right\n      matrix[i][last] = top;\n    }\n  }\n}\n\n// Example Usage:\nconst matrixToRotate = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\nconsole.log(\"Original matrix:\", matrixToRotate);\nrotateMatrix(matrixToRotate);\nconsole.log(\"Rotated matrix:\", matrixToRotate);\n/* Expected Result:\n[\n  [7, 4, 1],\n  [8, 5, 2],\n  [9, 6, 3]\n]\n*/",
          "explanation": "This function performs an in-place 90-degree clockwise rotation of a square matrix. It works by processing the matrix in concentric layers. For each layer, it iterates through elements on the top row (from `first` to `last-1`) and performs a cyclic swap of four elements: top-left with bottom-left, then bottom-left with bottom-right, then bottom-right with top-right, and finally top-right with the initially stored top-left element. This moves all four elements in a cycle, effectively rotating them.",
          "language": "javascript"
        },
        {
          "id": "example_spiral_traversal_1",
          "title": "Spiral Order Matrix Traversal",
          "code": "function spiralOrder(matrix) {\n  if (!matrix.length) return [];\n  \n  const result = [];\n  let top = 0;\n  let bottom = matrix.length - 1;\n  let left = 0;\n  let right = matrix[0].length - 1;\n  let direction = 0; // 0: right, 1: down, 2: left, 3: up\n  \n  while (top <= bottom && left <= right) {\n    if (direction === 0) {\n      // Move right\n      for (let i = left; i <= right; i++) {\n        result.push(matrix[top][i]);\n      }\n      top++;\n    } else if (direction === 1) {\n      // Move down\n      for (let i = top; i <= bottom; i++) {\n        result.push(matrix[i][right]);\n      }\n      right--;\n    } else if (direction === 2) {\n      // Move left (only if top is still <= bottom, avoids double counting in single row/column cases)\n      if (top <= bottom) { \n        for (let i = right; i >= left; i--) {\n          result.push(matrix[bottom][i]);\n        }\n      }\n      bottom--;\n    } else if (direction === 3) {\n      // Move up (only if left is still <= right, avoids double counting in single row/column cases)\n      if (left <= right) {\n        for (let i = bottom; i >= top; i--) {\n          result.push(matrix[i][left]);\n        }\n      }\n      left++;\n    }\n    \n    direction = (direction + 1) % 4; // Cycle direction\n  }\n  \n  return result;\n}\n\n// Example Usage:\nconst matrixToSpiral = [\n  [1, 2, 3, 4, 5],\n  [6, 7, 8, 9, 10],\n  [11, 12, 13, 14, 15],\n  [16, 17, 18, 19, 20]\n];\n\nconsole.log(\"Spiral order:\", spiralOrder(matrixToSpiral));\n// Expected: [1, 2, 3, 4, 5, 10, 15, 20, 19, 18, 17, 16, 11, 6, 7, 8, 9, 14, 13, 12]",
          "explanation": "This function extracts elements from a given matrix in a spiral order. It uses four pointers (`top`, `bottom`, `left`, `right`) to define the current boundaries of the sub-matrix being traversed. A `direction` variable (0-3) determines which side is being processed. After traversing one side, the corresponding boundary pointer is adjusted inwards, and the `direction` is updated cyclically. The loops for moving left and up include `if (top <= bottom)` and `if (left <= right)` checks, respectively, to prevent adding duplicate elements in cases of single-row or single-column matrices, which might happen after `top` or `right` have been incremented/decremented past `bottom` or `left`.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "matrix",
        "algorithms",
        "in-place",
        "traversal",
        "array",
        "data-structures"
      ],
      "prerequisites": [
        "arrays",
        "loops",
        "basic_algorithms"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "matrix",
      "algorithms",
      "in-place",
      "traversal",
      "array",
      "data-structures"
    ],
    "prerequisites": [
      "arrays",
      "loops",
      "basic_algorithms"
    ]
  },
  {
    "index": 154,
    "id": "theory_tree_preorder_traversal",
    "type": "theory",
    "moduleId": "javascript",
    "complexity": 7,
    "title": "Tree Traversal: Pre-order (Iterative)",
    "description": "",
    "content": {
      "id": "theory_tree_preorder_traversal",
      "title": "Tree Traversal: Pre-order (Iterative)",
      "description": "",
      "type": "theory",
      "content": "Tree traversal is the process of visiting each node in a tree data structure exactly once. Pre-order traversal is a depth-first traversal strategy that visits the root node first, then recursively traverses the left subtree, and finally recursively traverses the right subtree. This order is commonly used to create a copy of the tree or to obtain a prefix expression of an expression tree.\n\nWhile pre-order traversal can be implemented recursively very naturally, an iterative approach is often preferred in certain scenarios (e.g., to avoid stack overflow for very deep trees or for better performance control).\n\n## Iterative Pre-order Traversal using a Stack\n\nThe iterative approach for pre-order traversal uses a stack data structure to keep track of nodes to visit. The general steps are:\n\n1.  Initialize an empty result list and an empty stack.\n2.  If the root is null, return the empty result list.\n3.  Push the root node onto the stack.\n4.  While the stack is not empty:\n    a.  Pop a node from the top of the stack. This is the `current` node.\n    b.  Add the `current` node's value to the result list.\n    c.  Push the `current` node's right child onto the stack (if it exists). This is pushed first because a stack is LIFO, so the right child will be processed *after* the left child.\n    d.  Push the `current` node's left child onto the stack (if it exists). This is pushed second, ensuring it's on top and processed next.\n5.  Return the result list.\n\nThis sequence ensures that the root is processed first, then its left child (and its subtree), and then its right child (and its subtree), mimicking the pre-order logic.",
      "examples": [
        {
          "id": "example_tree_preorder_1",
          "title": "Basic Iterative Pre-order Traversal",
          "code": "class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction preorderTraversal(root) {\n  const result = [];\n  const stack = [];\n\n  if (!root) {\n    return result;\n  }\n\n  stack.push(root);\n\n  while (stack.length > 0) {\n    // Pop the top node from the stack\n    const current = stack.pop();\n\n    // Process the current node (add to result)\n    result.push(current.value);\n\n    // Push right child first (to process left child first since it's a stack)\n    if (current.right) {\n      stack.push(current.right);\n    }\n\n    // Push left child\n    if (current.left) {\n      stack.push(current.left);\n    }\n  }\n\n  return result;\n}\n\n// Example Usage:\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(preorderTraversal(root)); // Expected output: [1, 2, 4, 5, 3]",
          "explanation": "This example defines a `TreeNode` class and the `preorderTraversal` function which performs an iterative pre-order traversal. It uses a stack to manage the nodes. The key insight is pushing the right child before the left child, so that the left child is popped and processed first, adhering to the 'Root, Left, Right' order of pre-order traversal.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "data-structures",
        "trees",
        "traversal",
        "algorithms",
        "stack",
        "interview-prep"
      ],
      "prerequisites": [
        "data_structures_basic",
        "stack_data_structure"
      ],
      "technology": "JavaScript"
    },
    "tags": [
      "data-structures",
      "trees",
      "traversal",
      "algorithms",
      "stack",
      "interview-prep"
    ],
    "prerequisites": [
      "data_structures_basic",
      "stack_data_structure"
    ]
  },
  {
    "index": 36,
    "id": "theory_https_setup",
    "type": "theory",
    "moduleId": "react",
    "complexity": 2,
    "title": "Enabling HTTPS in React Development",
    "description": "",
    "content": {
      "id": "theory_https_setup",
      "title": "Enabling HTTPS in React Development",
      "description": "",
      "type": "theory",
      "content": "Running a React application over HTTPS (Hypertext Transfer Protocol Secure) during development can be crucial for various reasons, including testing certain browser features that require a secure context (e.g., Service Workers, Geolocation API, WebAuthn), ensuring consistent behavior with production environments, or interacting with APIs that only allow requests from secure origins. Create React App (CRA) provides a simple way to enable HTTPS for your development server.\n\n### How to Enable HTTPS\nTo enable HTTPS for your Create React App development server, you can set the `HTTPS` environment variable to `true`. This can be done in two primary ways:\n\n1.  **In `package.json` scripts:** You can modify your `start` script in `package.json` to include the `HTTPS=true` environment variable before `react-scripts start`. This makes HTTPS the default when you run `npm start`.\n2.  **From the command line:** You can directly set the `HTTPS=true` environment variable in your terminal before running the `npm start` command. This is useful for one-off sessions or testing.\n\n**Note on Cross-Platform Compatibility:** The syntax `set HTTPS=true` is specific to Windows command prompt. For macOS/Linux (Bash/Zsh), you would use `HTTPS=true`. For cross-platform scripts, tools like `cross-env` can be used to set environment variables universally.\n\n### Benefits of Development HTTPS\n*   **Security Feature Testing:** Enables testing of features that require a secure context (e.g., Service Workers, Web Push Notifications, Geolocation).\n*   **API Interaction:** Allows local development to interact with APIs that might enforce secure origins.\n*   **Production Parity:** Helps catch potential issues early that might only arise when serving over HTTPS in a production environment.\n*   **Reduced Browser Warnings:** Prevents browsers from flagging `http://localhost` as insecure, which can be distracting during development.\n\nBy default, when `HTTPS=true` is set, `react-scripts` will generate and use a self-signed SSL certificate. Browsers will typically warn you about this certificate being untrusted, but you can usually proceed past the warning.",
      "examples": [
        {
          "id": "example_https_setup_1",
          "title": "Enabling HTTPS via package.json script (Windows)",
          "code": "{\n  \"name\": \"my-react-app\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"scripts\": {\n    \"start\": \"set HTTPS=true && react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  }\n}",
          "explanation": "This demonstrates how to modify the `start` script in your `package.json` file. When you run `npm start`, the `set HTTPS=true` command will execute first, setting the environment variable for the `react-scripts start` command. This approach is persistent.",
          "language": "json"
        },
        {
          "id": "example_https_setup_2",
          "title": "Enabling HTTPS from Command Line (Cross-Platform)",
          "code": "// For Windows Command Prompt:\nset HTTPS=true && npm start\n\n// For macOS/Linux (Bash/Zsh):\nHTTPS=true npm start",
          "explanation": "These commands show how to enable HTTPS temporarily from the command line. On Windows, `set` is used. On Unix-like systems, `HTTPS=true` directly before the command sets the variable only for that command's process. This is useful for quick tests without modifying `package.json`.",
          "language": "shell"
        }
      ],
      "complexity": 2,
      "tags": [
        "React",
        "Development",
        "HTTPS",
        "Environment Variables",
        "CLI",
        "Web Security"
      ],
      "prerequisites": [
        "Node.js",
        "npm",
        "Create React App"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Development",
      "HTTPS",
      "Environment Variables",
      "CLI",
      "Web Security"
    ],
    "prerequisites": [
      "Node.js",
      "npm",
      "Create React App"
    ]
  },
  {
    "index": 26,
    "id": "theory_jsx_fundamentals",
    "type": "theory",
    "moduleId": "react",
    "complexity": 3,
    "title": "JSX Fundamentals and Differences from HTML",
    "description": "",
    "content": {
      "id": "theory_jsx_fundamentals",
      "title": "JSX Fundamentals and Differences from HTML",
      "description": "",
      "type": "theory",
      "content": "JSX (JavaScript XML) is a syntax extension for JavaScript, commonly used with React to describe what the UI should look like. It allows you to write HTML-like syntax directly within your JavaScript code, which then gets transpiled into standard JavaScript function calls.\n\n## Multiline JSX\nWhen writing JSX across multiple lines, it must be wrapped in parentheses `()` to prevent automatic semicolon insertion from breaking the code. This ensures the entire JSX structure is treated as a single expression.\n\n## JSX vs. HTML Differences\nWhile JSX appears similar to HTML, there are crucial differences, primarily due to JSX being JavaScript under the hood:\n\n1.  **Attribute Naming (camelCase):** HTML attributes like `class` and `onclick` are reserved keywords in JavaScript or conflict with JavaScript naming conventions. Therefore, JSX uses camelCase for most attributes, such as `className` instead of `class` for CSS classes, and `onClick` instead of `onclick` for event handlers. Event handlers in JSX receive a JavaScript function reference directly, not a string of code.\n\n2.  **Self-Closing Tags:** In HTML, some tags like `<img>`, `<input>`, `<br>` can be self-closing (e.g., `<img src=\"image.jpg\">`) or explicitly closed (e.g., `<img></img>`). In JSX, all tags that do not have children must be explicitly self-closed with a trailing slash (`/`) before the closing angle bracket (e.g., `<img src=\"image.jpg\" />`). This applies to custom components as well.\n\n3.  **Style Attribute:** Unlike HTML where the `style` attribute takes a string of CSS rules, in JSX, the `style` attribute expects a JavaScript object. CSS property names within this object are also written in camelCase (e.g., `fontSize` instead of `font-size`), and their values are typically strings (for units) or numbers.\n\nThese differences are essential for writing valid and functional React components using JSX.",
      "examples": [
        {
          "id": "example_jsx_fundamentals_1",
          "title": "Basic Multiline JSX and Attributes",
          "code": "const element = (\n  <div>\n    <h1>Hello!</h1>\n    <p className=\"welcome-text\" onClick={() => console.log('Welcome clicked!')}>\n      Welcome to React\n    </p>\n    <img src=\"logo.png\" alt=\"React Logo\" />\n  </div>\n);\n\n// Example of inline style object\nconst styledElement = <div style={{ color: 'blue', fontSize: '20px' }}>Styled Text Example</div>;",
          "explanation": "This example demonstrates several key JSX features: The `div` is a multiline JSX element, hence wrapped in parentheses. `className` is used instead of `class` for the `p` tag. `onClick` is used for the event handler, receiving a function. The `img` tag is self-closed with `/>`. Finally, an inline style is applied using a JavaScript object.",
          "language": "javascript"
        },
        {
          "id": "example_jsx_fundamentals_2",
          "title": "JSX Style Attribute with Variable",
          "code": "const primaryColor = 'red';\nconst headerFontSize = '24px';\n\nconst styles = {\n  color: primaryColor,\n  fontSize: headerFontSize,\n  backgroundColor: '#eee',\n  padding: '10px'\n};\n\nconst elementWithVariableStyles = <h2 style={styles}>Dynamically Styled Header</h2>;",
          "explanation": "This example shows how to define styles as a separate JavaScript object and then pass that object to the `style` attribute. This approach promotes readability and reusability of style definitions, especially when styles are complex or need to be conditionally applied. Note the camelCase for `backgroundColor`.",
          "language": "javascript"
        }
      ],
      "complexity": 3,
      "tags": [
        "JSX",
        "React",
        "Frontend",
        "Syntax",
        "Beginner"
      ],
      "prerequisites": [
        "HTML_basics",
        "JavaScript_basics"
      ],
      "technology": "React"
    },
    "tags": [
      "JSX",
      "React",
      "Frontend",
      "Syntax",
      "Beginner"
    ],
    "prerequisites": [
      "HTML_basics",
      "JavaScript_basics"
    ]
  },
  {
    "index": 29,
    "id": "theory_presentational_components",
    "type": "theory",
    "moduleId": "react",
    "complexity": 4,
    "title": "Presentational Components (UI Components)",
    "description": "",
    "content": {
      "id": "theory_presentational_components",
      "title": "Presentational Components (UI Components)",
      "description": "",
      "type": "theory",
      "content": "Presentational components, also known as UI components, are primarily concerned with how things look. They are typically pure functional components and are designed to be reusable and independent of the rest of the application's business logic or state management.\n\n## Key Characteristics:\n-   **Focus:** Primarily on presentation and UI rendering.\n-   **Independence:** Have no dependencies on the rest of the application's state or data fetching logic.\n-   **Data Flow:** Receive all data and callback functions exclusively via props.\n-   **State Management:** Do not manage their own state (unless it's purely UI-related state, like a toggle for a dropdown menu, but even then, it's often better managed by a container component or passed via props).\n-   **Composition:** Can contain other presentational components.\n-   **Reusability:** Highly reusable across different parts of an application or even different projects.\n\nThey are essential for building a consistent and modular user interface, making it easier to develop, test, and maintain UI elements.",
      "examples": [
        {
          "id": "example_presentational_button",
          "title": "Basic Presentational Button Component",
          "code": "const Button = ({ onClick, text, isDisabled = false }) => (\n  <button onClick={onClick} disabled={isDisabled}>\n    {text}\n  </button>\n);\n\n// Usage example:\n// <Button onClick={() => alert('Clicked!')} text=\"Click Me\" />\n// <Button onClick={() => console.log('Disabled')} text=\"Disabled Button\" isDisabled={true} />",
          "explanation": "This `Button` component is a classic example of a presentational component. It receives its text, click handler, and disabled state entirely through props. It has no internal state, no data fetching logic, and focuses solely on rendering a button based on the provided properties.",
          "language": "typescript"
        },
        {
          "id": "example_presentational_card",
          "title": "Presentational Hobby Card Component",
          "code": "import React from 'react';\n\ninterface HobbyCardProps {\n  title: string;\n  hobbies: string[];\n}\n\nfunction HobbyCard({ title, hobbies }: HobbyCardProps) {\n  return (\n    <div>\n      <h2>{title}</h2>\n      <ul>\n        {hobbies.map(hobby => <li key={hobby}>{hobby}</li>)}\n      </ul>\n    </div>\n  );\n}",
          "explanation": "This `HobbyCard` component renders a title and a list of hobbies. All the data it needs (`title` and `hobbies` array) is passed down via props. It doesn't fetch hobbies itself or manage any complex state, making it purely presentational and highly reusable for displaying different sets of hobbies.",
          "language": "typescript"
        }
      ],
      "complexity": 4,
      "tags": [
        "React",
        "Components",
        "Presentational",
        "UI",
        "Functional Components",
        "Props"
      ],
      "prerequisites": [
        "react_functional_components",
        "javascript_es6_destructuring"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Components",
      "Presentational",
      "UI",
      "Functional Components",
      "Props"
    ],
    "prerequisites": [
      "react_functional_components",
      "javascript_es6_destructuring"
    ]
  },
  {
    "index": 43,
    "id": "theory_component_lifecycle_overview",
    "type": "theory",
    "moduleId": "react",
    "complexity": 4,
    "title": "React Component Lifecycle Overview and Phases",
    "description": "",
    "content": {
      "id": "theory_component_lifecycle_overview",
      "title": "React Component Lifecycle Overview and Phases",
      "description": "",
      "type": "theory",
      "content": "React components undergo a series of phases throughout their existence in the DOM, collectively known as their lifecycle. Understanding these phases and their associated methods is crucial for building robust and efficient React applications. Each phase provides specific 'hooks' where developers can execute code.\n\n## Component Lifecycle Phases\nThere are three primary phases in a React component's lifecycle:\n\n1.  **Mounting:** This is the phase when an instance of a component is being created and inserted into the DOM. This happens for the very first time a component is rendered.\n\n2.  **Updating:** This phase occurs when a component is being re-rendered due to changes in its props or state. This is the most frequently occurring phase in an active application.\n\n3.  **Unmounting:** This is the final phase when a component is being removed from the DOM. This happens when the component is no longer needed or its parent decides to unmount it.\n\nEach phase has a specific set of lifecycle methods that are called in a predictable order, allowing developers to manage side effects, optimize performance, and interact with the DOM at appropriate times.\n\n## React Component Rendering Process\nReact's rendering process is carefully designed to be efficient and predictable. It involves:\n*   **Reconciliation:** React builds a 'virtual DOM' representation of the UI. When state or props change, React creates a new virtual DOM tree and compares it with the previous one. This comparison process is called reconciliation.\n*   **Diffing Algorithm:** React uses a diffing algorithm to identify the minimal set of changes needed to update the actual DOM, rather than re-rendering the entire tree. This makes updates very fast.\n*   **Batching:** React often batches multiple state updates into a single re-render for performance, especially when updates happen within the same event loop tick.",
      "examples": [],
      "complexity": 4,
      "tags": [
        "react",
        "lifecycle",
        "fundamentals",
        "rendering"
      ],
      "prerequisites": [
        "react_basics",
        "dom_manipulation"
      ],
      "technology": "React"
    },
    "tags": [
      "react",
      "lifecycle",
      "fundamentals",
      "rendering"
    ],
    "prerequisites": [
      "react_basics",
      "dom_manipulation"
    ]
  },
  {
    "index": 27,
    "id": "theory_jsx_fragments",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "JSX Fragments: Grouping Elements Without Extra DOM Nodes",
    "description": "",
    "content": {
      "id": "theory_jsx_fragments",
      "title": "JSX Fragments: Grouping Elements Without Extra DOM Nodes",
      "description": "",
      "type": "theory",
      "content": "JSX Fragments allow you to group multiple elements together without introducing an additional wrapper DOM node into the final rendered output. This is particularly useful when a component needs to return multiple elements, but you want to avoid affecting the component's layout or the overall DOM structure with unnecessary parent elements.\n\n## Syntax\nThere are two primary ways to use Fragments:\n\n1.  **Long Syntax**: Using `React.Fragment`\n    This explicit form is necessary when you need to pass a `key` prop to the Fragment, such as when rendering a list of fragments.\n\n    ```typescript\n    import React from 'react';\n\n    function ListItems() {\n      return (\n        <React.Fragment>\n          <li>Item 1</li>\n          <li>Item 2</li>\n        </React.Fragment>\n      );\n    }\n    ```\n\n2.  **Short Syntax (Shorthand)**: Using `<></>`\n    This is a more concise and commonly used syntax when a `key` is not required. It's essentially syntactic sugar for `React.Fragment`.\n\n    ```typescript\n    function ListItems() {\n      return (\n        <>\n          <li>Item 1</li>\n          <li>Item 2</li>\n        </>\n      );\n    }\n    ```\n\n## Benefits of Fragments Over Container Divs\nUsing Fragments instead of a `div` or other wrapper element to group children provides several significant advantages, especially in complex applications:\n\n1.  **Performance**: Fragments lead to slightly better performance and reduced memory consumption because they do not create an extra DOM node. While the impact might be negligible for small applications, it becomes noticeable in very large and deeply nested component trees where many components might otherwise introduce superfluous wrapper divs.\n\n2.  **CSS Layout Integrity**: Many CSS layout mechanisms, such as Flexbox and CSS Grid, rely on specific parent-child relationships. Introducing an extra `div` in the middle of these relationships can break the intended layout or make it more complicated to achieve. Fragments allow components to return multiple children directly, maintaining the integrity of the CSS layout.\n\n3.  **DOM Inspector Clarity**: When debugging with browser developer tools, the DOM Inspector remains cleaner and less cluttered. Without unnecessary wrapper `div`s, it's easier to inspect the actual structure and identify relevant elements.\n\n4.  **Semantic HTML**: Fragments help in maintaining proper semantic HTML structure. For example, a `<table>` must contain `<tbody>`, `<thead>`, `<tfoot>` directly, and `<tbody>` must contain `<tr>`. Introducing a `div` between these elements would create invalid HTML, potentially impacting accessibility and SEO. Fragments allow you to return valid HTML structures.",
      "examples": [
        {
          "id": "example_jsx_fragments_1",
          "title": "Basic Fragment Usage",
          "code": "import React from 'react';\n\nfunction GreetingList() {\n  return (\n    <>\n      <h1>Hello!</h1>\n      <p>Welcome to the example.</p>\n    </>\n  );\n}\n\n// This component, when rendered, will output directly:\n// <h1>Hello!</h1>\n// <p>Welcome to the example.</p>\n// without an enclosing div.",
          "explanation": "This example demonstrates the most common use case for Fragments: grouping a few sibling elements without adding an extra `div` wrapper. The shorthand syntax `<></>` is used for conciseness. When `GreetingList` is rendered, its output will directly become siblings in the DOM, preserving the desired layout and semantic structure.",
          "language": "typescript"
        },
        {
          "id": "example_jsx_fragments_2",
          "title": "Fragment with Key Prop in Lists",
          "code": "import React from 'react';\n\ninterface ItemProps {\n  id: number;\n  name: string;\n}\n\nfunction TableRows({ items }: { items: ItemProps[] }) {\n  return (\n    <React.Fragment>\n      {items.map(item => (\n        <React.Fragment key={item.id}>\n          <td>{item.id}</td>\n          <td>{item.name}</td>\n        </React.Fragment>\n      ))}\n    </React.Fragment>\n  );\n}\n\n// Usage example within a table body:\n// <tbody>\n//   <TableRows items={[{ id: 1, name: 'Apple' }, { id: 2, name: 'Banana' }]} />\n// </tbody>\n// This will render directly:\n// <tbody>\n//   <td>1</td><td>Apple</td>\n//   <td>2</td><td>Banana</td>\n// </tbody>\n// (Note: This is a simplified example; typically, each row would be a <tr>, but this shows Fragment with keys.)",
          "explanation": "This example shows a more advanced use case where `React.Fragment` (the long syntax) is required because a `key` prop needs to be passed. When mapping over a list and each item needs to render multiple sibling elements (e.g., `<td>`s for a table row, if `<tr>` itself is not the wrapper for the entire row), you might need a fragment to group them. The `key` prop is crucial for React's reconciliation process to efficiently identify and update list items. Here, `React.Fragment` allows us to apply a unique `key` to each logical 'item' being rendered, even though it doesn't create a DOM node.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "JSX",
        "Fragments",
        "DOM",
        "Performance",
        "Semantic HTML",
        "Frontend"
      ],
      "prerequisites": [
        "react_components",
        "jsx_syntax"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "JSX",
      "Fragments",
      "DOM",
      "Performance",
      "Semantic HTML",
      "Frontend"
    ],
    "prerequisites": [
      "react_components",
      "jsx_syntax"
    ]
  },
  {
    "index": 33,
    "id": "theory_react_component_props_conditional_rendering",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "React Component Props and Conditional Rendering",
    "description": "",
    "content": {
      "id": "theory_react_component_props_conditional_rendering",
      "title": "React Component Props and Conditional Rendering",
      "description": "",
      "type": "theory",
      "content": "## React Component Props\nProps (short for properties) are a mechanism for passing data from a parent component to a child component in React. They are read-only, meaning a child component should not modify the props it receives. This immutability helps in maintaining a unidirectional data flow, making applications easier to understand and debug.\n\n### Key Concepts:\n-   **Unidirectional Data Flow**: Data flows down from parent to child components via props.\n-   **Read-Only**: Components must treat props as immutable. They should not modify their own props.\n-   **Passing Data**: Props are passed as attributes in JSX, similar to HTML attributes.\n-   **Accessing Props**: Inside a functional component, props are received as the first argument (an object). In class components, they are accessed via `this.props`.\n\n## Conditional Rendering\nConditional rendering in React allows you to render different elements or components based on certain conditions. This is a powerful way to create dynamic UIs that respond to changes in application state or props.\n\n### Common Techniques:\n-   **`if` statements**: Can be used outside JSX to conditionally return different components or JSX trees.\n-   **Logical `&&` operator**: If the condition is `true`, the element after `&&` will be rendered. If `false`, React ignores and skips the element. This is often used for rendering a block or element only when a certain prop or state is true.\n-   **Ternary operator (`condition ? true_expression : false_expression`)**: Allows rendering one of two different elements based on a condition, useful for inline conditional rendering where you need an `else` branch.\n-   **Element Variables**: Store elements in variables and conditionally assign them, then render the variable.\n\n### Example Scenario:\nImagine a `UserProfile` component that displays user information. Some information, like 'Administrator' status, might only show if a specific condition (e.g., `isAdmin` prop) is met.",
      "examples": [
        {
          "id": "example_props_conditional_rendering_1",
          "title": "Functional Component with Props and Conditional Rendering",
          "code": "import React from 'react';\n\nfunction UserProfile({ name, age, isAdmin }) {\n  return (\n    <div>\n      <h2>{name}</h2>\n      <p>Age: {age}</p>\n      {isAdmin && <p>Administrator</p>} {/* Conditional rendering using logical && */}\n    </div>\n  );\n}\n\n// Usage example:\n// <UserProfile name=\"Alice\" age={25} isAdmin={true} />\n// <UserProfile name=\"Bob\" age={30} isAdmin={false} />",
          "explanation": "This `UserProfile` functional component receives `name`, `age`, and `isAdmin` as props. It uses `isAdmin && <p>Administrator</p>` to conditionally display the 'Administrator' paragraph only if the `isAdmin` prop is `true`.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "Props",
        "Conditional Rendering",
        "JSX",
        "Functional Components"
      ],
      "prerequisites": [
        "react_component_basics",
        "javascript_es6_destructuring"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Props",
      "Conditional Rendering",
      "JSX",
      "Functional Components"
    ],
    "prerequisites": [
      "react_component_basics",
      "javascript_es6_destructuring"
    ]
  },
  {
    "index": 34,
    "id": "theory_class_component_state_basics",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "React State Management: Class Components Basics and Asynchronous Updates",
    "description": "",
    "content": {
      "id": "theory_class_component_state_basics",
      "title": "React State Management: Class Components Basics and Asynchronous Updates",
      "description": "",
      "type": "theory",
      "content": "In React class components, `state` is a plain JavaScript object that holds data influencing the component's rendering. To modify the state, you must use the `this.setState()` method. Direct modification of `this.state` (e.g., `this.state.count = 5;`) will not trigger a re-render and is considered a bad practice, leading to unpredictable behavior.\n\n## Key Concepts\n- **`this.state`**: An object holding the current state of the component.\n- **`this.setState(updater, [callback])`**: The primary method to update component state. It queues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state.\n- **Asynchronous Nature**: `this.setState` calls are often asynchronous and batched for performance reasons. This means you might not see the updated state immediately after calling `setState`.\n- **Batching**: React may batch multiple `setState` calls into a single update for efficiency. This is why if you call `setState` multiple times in the same synchronous event handler, React will only perform one re-render, applying all the changes at once.\n- **Immutability**: When updating state, especially nested objects or arrays, it's crucial to treat `this.state` as immutable. Always create new objects/arrays instead of modifying existing ones directly. This helps prevent side effects and ensures React can correctly detect changes and optimize re-renders.\n\n## Practical Considerations\n- **Accessing Latest State**: Because `setState` is asynchronous, relying on `this.state` immediately after `setState` can lead to errors. For updates that depend on the previous state, use the functional form of `setState` (covered in the next section).\n- **Callback Function**: `this.setState` can optionally take a callback function as its second argument. This callback is executed after the state update has been applied and the component has re-rendered. This is useful for performing side effects that depend on the new state.",
      "examples": [
        {
          "id": "example_class_component_state_basics_1",
          "title": "Basic State Initialization and Update",
          "code": "import React from 'react';\n\nclass Counter extends React.Component {\n  state = {\n    count: 0\n  };\n\n  increment = () => {\n    // Basic update: new state does not depend on old state, or simple increment\n    this.setState({ count: this.state.count + 1 });\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}",
          "explanation": "This example shows the initialization of `count` in `state` and a basic `increment` method. The `this.setState({ count: this.state.count + 1 });` line updates the `count` property. When `increment` is called multiple times in quick succession within the same event loop (e.g., due to React's batching), `this.state.count` might not reflect the very latest value from a preceding `setState` call.",
          "language": "typescript"
        },
        {
          "id": "example_class_component_state_basics_2",
          "title": "Using setState Callback",
          "code": "import React from 'react';\n\nclass DataFetcher extends React.Component {\n  state = {\n    data: null,\n    loading: false\n  };\n\n  fetchData = () => {\n    this.setState({ loading: true }, () => {\n      // This callback runs AFTER loading state is updated and component potentially re-rendered\n      console.log('Loading state updated to true. Now fetching data...');\n      // Simulate API call\n      setTimeout(() => {\n        this.setState({ data: 'Fetched Data!', loading: false });\n      }, 1000);\n    });\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.fetchData} disabled={this.state.loading}>\n          {this.state.loading ? 'Loading...' : 'Fetch Data'}\n        </button>\n        {this.state.data && <p>{this.state.data}</p>}\n      </div>\n    );\n  }\n}",
          "explanation": "This example demonstrates using the optional callback function of `setState`. The `console.log` statement inside the callback will execute only after `this.setState({ loading: true })` has completed and the component has potentially re-rendered. This is crucial for operations that depend on the state being fully updated.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "Class Components",
        "State Management",
        "setState",
        "Asynchronous",
        "Batching"
      ],
      "prerequisites": [
        "javascript_basics",
        "react_components_intro"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Class Components",
      "State Management",
      "setState",
      "Asynchronous",
      "Batching"
    ],
    "prerequisites": [
      "javascript_basics",
      "react_components_intro"
    ]
  },
  {
    "index": 37,
    "id": "theory_react_event_handling_basics",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "React Event Handling Fundamentals",
    "description": "",
    "content": {
      "id": "theory_react_event_handling_basics",
      "title": "React Event Handling Fundamentals",
      "description": "",
      "type": "theory",
      "content": "React implements a synthetic event system that wraps browser's native events, providing a consistent cross-browser interface. While similar to traditional HTML DOM event handling, React introduces several key differences:\n\n### 1. Event Naming Convention (camelCase)\nUnlike HTML, where event names are typically lowercase (e.g., `onclick`), React uses camelCase for event names (e.g., `onClick`). This convention applies to all event types.\n\n### 2. Passing Functions as Event Handlers\nIn HTML, event handlers are often defined as strings containing JavaScript code that gets executed. In React, you pass a direct reference to a JavaScript function as the event handler. This allows for cleaner separation of concerns and easier maintenance.\n\n### 3. Explicit `preventDefault()`\nTo prevent the default browser behavior (like form submission or navigating away from a link), you must explicitly call `event.preventDefault()` within your event handler function. In traditional HTML, returning `false` from an event handler could sometimes prevent default behavior, but this is not the case in React's synthetic event system.\n\nReact's synthetic events are pooled. This means the synthetic event object will be reused, and its properties will be nullified after the event callback has been invoked. If you need to access the event object asynchronously, you should call `event.persist()` on the event, or read the properties you need before the event callback returns.",
      "examples": [
        {
          "id": "example_react_event_handling_basics_1",
          "title": "HTML vs. React Event Naming and Handler Passing",
          "code": "```html\n<!-- In HTML -->\n<button onclick=\"activateAccount()\">\n  Activate Account\n</button>\n<a href=\"#\" onclick=\"console.log('Clicked'); return false;\">\n  Click me\n</a>\n```\n\n```jsx\n// In React\nfunction activateAccount() {\n  console.log('Account activated!');\n}\n\nfunction preventNavigation(e) {\n  e.preventDefault(); // Explicitly prevent default\n  console.log('Navigation prevented, but clicked!');\n}\n\nfunction MyComponent() {\n  return (\n    <>\n      <button onClick={activateAccount}>\n        Activate Account\n      </button>\n      <a href=\"#\" onClick={preventNavigation}>\n        Click me (Prevent Default)\n      </a>\n    </>\n  );\n}\n```",
          "explanation": "This example clearly illustrates the differences. In HTML, `onclick` is lowercase and accepts a string. In React, `onClick` is camelCase and accepts a function reference. Additionally, the `preventDefault()` method is explicitly called on the synthetic event object `e` to stop the default browser behavior of navigating to '#'.",
          "language": "jsx"
        },
        {
          "id": "example_react_event_handling_basics_2",
          "title": "Complete Event Handling Example in React",
          "code": "```jsx\nfunction ButtonComponent() {\n  const handleClick = (e) => {\n    // console.log('Event target:', e.target);\n    // console.log('Event type:', e.type);\n    e.preventDefault(); // Prevents default behavior (e.g., form submission if this was a submit button)\n    console.log('Button was clicked and default prevented');\n  };\n\n  return (\n    <button onClick={handleClick}>\n      Click me\n    </button>\n  );\n}\n\n// Usage example:\n// ReactDOM.render(<ButtonComponent />, document.getElementById('root'));\n```",
          "explanation": "This example shows a functional React component demonstrating a basic click handler. The `handleClick` function receives the synthetic event object `e`. Inside this handler, `e.preventDefault()` is called to explicitly prevent any default browser action associated with the button (though for a simple button, it's less critical unless it's a submit button within a form). `console.log` is used to confirm the event has fired.",
          "language": "jsx"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "Events",
        "Event Handling",
        "Synthetic Events",
        "DOM"
      ],
      "prerequisites": [
        "html_basics",
        "javascript_functions",
        "dom_events"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Events",
      "Event Handling",
      "Synthetic Events",
      "DOM"
    ],
    "prerequisites": [
      "html_basics",
      "javascript_functions",
      "dom_events"
    ]
  },
  {
    "index": 39,
    "id": "theory_react_refs_overview",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "React Refs: Accessing DOM Nodes and React Elements",
    "description": "",
    "content": {
      "id": "theory_react_refs_overview",
      "title": "React Refs: Accessing DOM Nodes and React Elements",
      "description": "",
      "type": "theory",
      "content": "Refs provide a way to access DOM nodes or React elements created in the render method. In a typical React data flow, props are the only way parent components interact with their children. However, there are a few cases where you need to imperatively modify a child outside of the typical data flow. Refs are the solution for this.\n\n## When to Use Refs\nRefs are useful in scenarios where direct manipulation or access to a DOM element or component instance is necessary. Common use cases include:\n\n*   Managing focus, text selection, or media playback.\n*   Triggering imperative animations.\n*   Integrating with third-party DOM libraries.\n*   Working with uncontrolled components.\n\n## When NOT to Use Refs\nAvoid using refs for anything that can be done declaratively. For example, rather than using a ref to imperatively change a component's style, you should pass a prop to it. Props are the primary way to pass data down the component tree.",
      "examples": [],
      "complexity": 5,
      "tags": [
        "React",
        "Refs",
        "DOM",
        "Imperative Programming",
        "Component Interaction"
      ],
      "prerequisites": [
        "react_components",
        "react_props",
        "dom_basics"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Refs",
      "DOM",
      "Imperative Programming",
      "Component Interaction"
    ],
    "prerequisites": [
      "react_components",
      "react_props",
      "dom_basics"
    ]
  },
  {
    "index": 40,
    "id": "theory_uncontrolled_components",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "Uncontrolled Components in React",
    "description": "",
    "content": {
      "id": "theory_uncontrolled_components",
      "title": "Uncontrolled Components in React",
      "description": "",
      "type": "theory",
      "content": "## Overview\nIn React, an 'uncontrolled component' is a form input element whose value is managed by the DOM itself, rather than by React state. These components behave more like traditional HTML form inputs. React uses 'refs' to access the DOM node directly and retrieve its current value when needed, typically during form submission. The component itself maintains its internal state without React explicitly controlling its value.\n\n## Key Characteristics\n- **DOM as Source of Truth**: The input's current value is managed internally by the DOM.\n- **`ref` Attribute**: Instead of a `value` prop, a `ref` attribute is used to get a direct reference to the DOM element.\n- **`defaultValue` (Optional)**: Can be used to set an initial value for the input, but subsequent changes are handled by the DOM, not React state.\n- **No `onChange` for State**: While `onChange` can still be used for other purposes (like triggering side effects), it's not used to update React state for the input's value.\n\n## Benefits\n- **Simpler Code for Basic Forms**: Requires less boilerplate code compared to controlled components as you don't need `useState` and `onChange` handlers for every input.\n- **Better Performance (Fewer Re-renders)**: Since React state is not being updated on every keystroke, there are fewer component re-renders, which can be a performance advantage for forms with a very large number of inputs or high-frequency updates.\n- **Can Integrate More Easily with Non-React Code**: Because they rely on the DOM for state management, uncontrolled components can be simpler to integrate with third-party libraries that directly manipulate the DOM (e.g., certain jQuery plugins, custom DOM-based input widgets).\n- **Good for One-Time Inputs Like File Uploads**: File inputs (`<input type=\"file\"/>`) are inherently uncontrolled because their value (the file path) is read-only for security reasons and cannot be programmatically set by JavaScript. Using `ref` is the standard way to access the selected file.\n\n## Drawbacks\n- **Less Control over Validation Timing**: Validation typically occurs only when the form is submitted, making it harder to provide real-time feedback to the user as they type.\n- **Cannot Enforce Input Constraints During Typing**: It's difficult to restrict or transform input on the fly since React isn't actively managing the value.\n- **More Difficult to Implement Dynamic Form Logic**: Logic that depends on the current value of an input (e.g., showing a password confirmation field only when the password field is filled) becomes more cumbersome to implement without the value being readily available in React state.\n- **Less 'React-like'**: It deviates from React's typical declarative approach where the UI reflects the state.",
      "examples": [
        {
          "id": "example_uncontrolled_components_1",
          "title": "Basic Uncontrolled Form with useRef",
          "code": "import React, { useRef } from 'react';\n\nfunction UncontrolledForm() {\n  const nameRef = useRef(null);\n  const emailRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const formData = {\n      name: nameRef.current ? nameRef.current.value : '',\n      email: emailRef.current ? emailRef.current.value : '',\n      message: messageRef.current ? messageRef.current.value : ''\n    };\n    \n    console.log('Form submitted:', formData);\n    // Submit to server, etc.\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"name\">Name:</label>\n        <input\n          type=\"text\"\n          id=\"name\"\n          name=\"name\"\n          ref={nameRef}\n          defaultValue=\"\"\n        />\n      </div>\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input\n          type=\"email\"\n          id=\"email\"\n          name=\"email\"\n          ref={emailRef}\n          defaultValue=\"\"\n        />\n      </div>\n      <div>\n        <label htmlFor=\"message\">Message:</label>\n        <textarea\n          id=\"message\"\n          name=\"message\"\n          ref={messageRef}\n          defaultValue=\"\"\n        />\n      </div>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}",
          "explanation": "This example shows an uncontrolled form using `useRef`. Each input has a `ref` attribute pointing to a mutable ref object created by `useRef`. When the form is submitted, the `handleSubmit` function accesses the current values of the inputs directly from the DOM nodes via `ref.current.value`. Note the `defaultValue` prop for initial values, as `value` would make it controlled.",
          "language": "typescript"
        },
        {
          "id": "example_uncontrolled_components_file_upload",
          "title": "Uncontrolled File Input",
          "code": "import React, { useRef } from 'react';\n\nfunction FileUploadForm() {\n  const fileInputRef = useRef(null);\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (fileInputRef.current && fileInputRef.current.files.length > 0) {\n      const selectedFile = fileInputRef.current.files[0];\n      console.log('Selected file:', selectedFile.name);\n      // Typically, you'd upload the file here\n    } else {\n      console.log('No file selected.');\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"fileUpload\">Upload File:</label>\n        <input\n          type=\"file\"\n          id=\"fileUpload\"\n          name=\"fileUpload\"\n          ref={fileInputRef}\n        />\n      </div>\n      <button type=\"submit\">Upload</button>\n    </form>\n  );\n}",
          "explanation": "This example demonstrates using an uncontrolled component for a file input. File inputs are inherently uncontrolled because their `value` property is read-only for security reasons. `useRef` is used to get a reference to the `<input type='file'>` DOM element, and `fileInputRef.current.files` provides access to the selected files.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "Forms",
        "Uncontrolled Components",
        "Refs",
        "DOM Manipulation"
      ],
      "prerequisites": [
        "React Basics",
        "useRef Hook",
        "DOM API"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Forms",
      "Uncontrolled Components",
      "Refs",
      "DOM Manipulation"
    ],
    "prerequisites": [
      "React Basics",
      "useRef Hook",
      "DOM API"
    ]
  },
  {
    "index": 50,
    "id": "theory_react_testing_overview",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "React Component Testing Overview",
    "description": "",
    "content": {
      "id": "theory_react_testing_overview",
      "title": "React Component Testing Overview",
      "description": "",
      "type": "theory",
      "content": "Testing React components is crucial for ensuring the reliability, maintainability, and correctness of user interfaces. It helps catch bugs early in the development cycle, verifies that components behave as expected under various conditions, and provides confidence for future changes or refactoring. There are several approaches and libraries for testing React components, each with its own philosophy and strengths.\n\nKey aspects of React testing often involve:\n- **Rendering components:** Mounting components into a test environment.\n- **Finding elements:** Querying the rendered output to locate specific DOM nodes.\n- **Simulating user interactions:** Triggering events like clicks, input changes, or form submissions.\n- **Asserting component behavior:** Verifying that the component's state, rendered output, or side effects are correct.\n- **Mocking dependencies:** Isolating the component under test by replacing external dependencies (like API calls or third-party libraries) with controlled mock implementations.",
      "examples": [],
      "complexity": 5,
      "tags": [
        "react",
        "testing",
        "frontend-development",
        "best-practices"
      ],
      "prerequisites": [
        "react_fundamentals",
        "javascript_fundamentals"
      ],
      "technology": "React"
    },
    "tags": [
      "react",
      "testing",
      "frontend-development",
      "best-practices"
    ],
    "prerequisites": [
      "react_fundamentals",
      "javascript_fundamentals"
    ]
  },
  {
    "index": 53,
    "id": "theory_jest_react_basics",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "Jest and React Testing Library Fundamentals",
    "description": "",
    "content": {
      "id": "theory_jest_react_basics",
      "title": "Jest and React Testing Library Fundamentals",
      "description": "",
      "type": "theory",
      "content": "Jest is a powerful JavaScript testing framework that is widely used for React applications. It is known for its simplicity and 'batteries-included' approach, providing a complete testing solution out of the box, including assertion libraries, mocking capabilities, and test runners.\n\nReact Testing Library (RTL) is a set of utilities that help test React components by interacting with them in a way that resembles how real users would. Its guiding principle is to make tests reflect actual user behavior as closely as possible, discouraging reliance on component internals (like state or props).\n\n### Key Concepts:\n*   **`render` function (from `@testing-library/react`):** Renders a React component into a Document Object Model (DOM) container and returns a set of utilities to query that DOM. This function is the primary way to mount components for testing.\n*   **Queries (e.g., `getByRole`, `getByText`, `queryByTestId`):** RTL provides various query functions to find elements in the rendered DOM. `getByRole` is highly recommended as it encourages semantic HTML and helps ensure accessibility, simulating how assistive technologies would interact with the page.\n    *   `getByRole(role, options)`: Finds an element by its ARIA role (e.g., 'button', 'heading', 'navigation').\n    *   `getByText(text, options)`: Finds an element that contains the given text content.\n    *   `queryBy...`: Similar to `getBy...` but returns `null` if no element is found, instead of throwing an error. Useful for asserting an element is *not* present.\n    *   `findBy...`: Asynchronous versions of `getBy...`, useful for waiting for elements to appear in the DOM (e.g., after an API call).\n*   **`expect` and Matchers:** Jest provides `expect` to make assertions about values. Matchers are functions chained to `expect` that perform the actual comparison or check.\n    *   `toBeInTheDocument()`: Checks if an element exists within the document (provided by `@testing-library/jest-dom`).\n    *   `toHaveTextContent(text)`: Checks if an element contains the specified text content.\n*   **`describe` block:** A way to group related tests together. It often represents a component or a specific feature being tested.\n*   **`it` (or `test`) block:** Defines an individual test case. It should describe a single, specific behavior or outcome.",
      "examples": [
        {
          "id": "example_jest_react_basics_1",
          "title": "Basic Component Rendering and Assertion",
          "code": "import React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport MyComponent from './MyComponent';\n\ndescribe('MyComponent', () => {\n  it('should render the title and content correctly', () => {\n    render(<MyComponent title=\"Welcome\" content=\"Hello World\" />);\n    // Using getByRole for semantic elements\n    expect(screen.getByRole('heading', { level: 1 })).toHaveTextContent('Welcome');\n    // Using getByText for general text content\n    expect(screen.getByText('Hello World')).toBeInTheDocument();\n  });\n\n  it('should display a default message when no content is provided', () => {\n    render(<MyComponent title=\"Empty\" />);\n    expect(screen.getByText(/no content available/i)).toBeInTheDocument();\n  });\n});\n\n// MyComponent.jsx (for context)\n// import React from 'react';\n// const MyComponent = ({ title, content }) => (\n//   <div>\n//     <h1>{title}</h1>\n//     {content ? <p>{content}</p> : <p>No content available.</p>}\n//   </div>\n// );\n// export default MyComponent;\n",
          "explanation": "This example demonstrates how to render a simple React component (`MyComponent`) using `render` from React Testing Library. It then uses `screen.getByRole` to find a heading and `toHaveTextContent` to assert its text, and `screen.getByText` with `toBeInTheDocument` to check for paragraph text. The second test case shows how to test a default behavior when a prop is missing, using a regex for text matching.",
          "language": "typescript"
        },
        {
          "id": "example_jest_react_basics_2",
          "title": "Querying for specific HTML elements",
          "code": "import React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport Header from './Header';\n\ndescribe('Header component', () => {\n  it('renders correctly with a given title', () => {\n    // Render the Header component with a specific title prop\n    const { getByRole } = render(<Header title=\"Test Title\" />);\n    // Assert that a heading element (h1, h2, etc.) contains the title text\n    expect(getByRole('heading')).toHaveTextContent('Test Title');\n  });\n\n  it('contains a navigation menu', () => {\n    // Render the Header component (without title, if optional)\n    const { getByRole } = render(<Header />);\n    // Assert that an element with the 'navigation' ARIA role is present in the document\n    expect(getByRole('navigation')).toBeInTheDocument();\n  });\n});\n\n// Header.jsx (for context)\n// import React from 'react';\n// const Header = ({ title }) => (\n//   <header>\n//     <h1>{title || 'Default Header'}</h1>\n//     <nav aria-label=\"Main navigation\">\n//       <ul>\n//         <li>Home</li>\n//         <li>About</li>\n//       </ul>\n//     </nav>\n//   </header>\n// );\n// export default Header;\n",
          "explanation": "This example, directly from the provided markdown, illustrates basic component testing. It uses `getByRole` to locate elements based on their semantic roles (`heading` and `navigation`) which is a best practice for accessibility and robust tests. `toHaveTextContent` verifies the text within the heading, and `toBeInTheDocument` confirms the presence of the navigation element.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "Jest",
        "React Testing Library",
        "Unit Testing",
        "Frontend Testing",
        "TDD",
        "Accessibility"
      ],
      "prerequisites": [
        "React Basics",
        "JavaScript ES6+",
        "HTML DOM"
      ],
      "technology": "React"
    },
    "tags": [
      "Jest",
      "React Testing Library",
      "Unit Testing",
      "Frontend Testing",
      "TDD",
      "Accessibility"
    ],
    "prerequisites": [
      "React Basics",
      "JavaScript ES6+",
      "HTML DOM"
    ]
  },
  {
    "index": 56,
    "id": "theory_react_state_forms",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "React State Management with useState and Form Handling",
    "description": "",
    "content": {
      "id": "theory_react_state_forms",
      "title": "React State Management with useState and Form Handling",
      "description": "",
      "type": "theory",
      "content": "This section covers the fundamental `useState` hook in React for managing component-level state and its application in handling user input within forms.\n\n## useState Hook\n`useState` is a React Hook that lets you add state to functional components. It returns a stateful value and a function to update it. When the setter function is called, React re-renders the component.\n\n**Syntax:** `const [state, setState] = useState(initialState);`\n*   `state`: The current state value.\n*   `setState`: A function to update the state. It can be called with a new value or a function that receives the previous state and returns the new state (useful for complex updates or when new state depends on previous state).\n*   `initialState`: The initial value of the state. This can be a primitive (number, string, boolean) or an object/array. If `initialState` is a function, it will be executed only once during the initial render to compute the initial state, which is useful for expensive initializations.\n\n## Controlled Components in Forms\nIn React, form elements like `<input>`, `<textarea>`, and `<select>` maintain their own internal state. When you want React to be the 'single source of truth' for the form data, you create 'controlled components'.\n\nFor a controlled component:\n1.  The `value` attribute of the form element is tied to a state variable.\n2.  The `onChange` event handler updates this state variable whenever the input value changes.\n\nThis pattern ensures that the component's state and the displayed input value are always synchronized, allowing React to control the form data. This approach simplifies validation, conditional rendering, and dynamic changes to the form.\n\n## Event Handling in Forms\n\n*   `onChange`: This event fires whenever the value of a form input element is changed. It's crucial for controlled components to update the state.\n*   `onSubmit`: This event fires when a form is submitted. It's typically attached to the `<form>` element. The event object provides `event.preventDefault()` which is used to stop the browser's default behavior of reloading the page upon form submission, allowing React to handle the submission logic.\n",
      "examples": [
        {
          "id": "example_react_state_forms_1",
          "title": "Basic LoginForm Example",
          "code": "import React, { useState } from 'react';\n\nfunction LoginForm() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n\n  const handleUsernameChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setUsername(event.target.value);\n  };\n\n  const handlePasswordChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setPassword(event.target.value);\n  };\n\n  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    // In a real application, you would send these credentials to a server\n    console.log('Username:', username);\n    console.log('Password:', password);\n    alert(`Submitting: Username - ${username}, Password - ${password}`);\n    // Reset form or redirect\n    setUsername('');\n    setPassword('');\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"username\">Username:</label>\n        <input \n          id=\"username\"\n          type=\"text\" \n          value={username} \n          onChange={handleUsernameChange} \n        />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password:</label>\n        <input \n          id=\"password\"\n          type=\"password\" \n          value={password} \n          onChange={handlePasswordChange} \n        />\n      </div>\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n\nexport default LoginForm;\n",
          "explanation": "This example demonstrates a typical controlled `LoginForm` component. `useState` is used to manage the `username` and `password` inputs. Each input's `value` is bound to its respective state variable, and `onChange` handlers update the state whenever the input changes. The `handleSubmit` function prevents the default form submission behavior and logs the collected credentials, then clears the form.",
          "language": "typescript"
        },
        {
          "id": "example_react_state_forms_2",
          "title": "useState with Functional Update",
          "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    // Using functional update is safer when new state depends on previous state\n    setCount(prevCount => prevCount + 1);\n  };\n\n  const incrementTwice = () => {\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n      <button onClick={incrementTwice}>Increment Twice (Safe)</button>\n    </div>\n  );\n}\n\nexport default Counter;\n",
          "explanation": "This example illustrates the use of a functional update for `setCount`. When `setCount` is called with a function, React ensures the `prevCount` argument is the most up-to-date state, preventing stale closure issues, especially when state updates are batched or queued, as seen in `incrementTwice`.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "Hooks",
        "State Management",
        "Forms",
        "useState",
        "Controlled Components",
        "Event Handling"
      ],
      "prerequisites": [
        "JavaScript Basics",
        "HTML Forms"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Hooks",
      "State Management",
      "Forms",
      "useState",
      "Controlled Components",
      "Event Handling"
    ],
    "prerequisites": [
      "JavaScript Basics",
      "HTML Forms"
    ]
  },
  {
    "index": 61,
    "id": "theory_strict_mode",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "React StrictMode",
    "description": "",
    "content": {
      "id": "theory_strict_mode",
      "title": "React StrictMode",
      "description": "",
      "type": "theory",
      "content": "React's `StrictMode` is a development-only tool that helps developers identify potential problems in an application. It activates additional checks and warnings for its descendants. It does not render any visible UI and does not impact the production build.\n\n## Purpose of StrictMode\n- **Identifying Side Effects**: StrictMode helps detect unintended side effects by deliberately double-invoking certain functions (like `render` method, `useState` updater functions, `useEffect` cleanup and setup functions). If a function is pure, calling it twice should not change the application state or behavior, making side effects obvious.\n- **Preparing for Future React Features**: It helps your code be more resilient to future changes in React, especially related to concurrent rendering. Features like concurrent mode or automatic batching rely on components being pure and side-effect free.\n- **Deprecation Warnings**: It warns about deprecated lifecycle methods or API usages.\n- **Legacy Context API**: Warns about unsafe lifecycles, and usage of the legacy context API.\n- **Finding unexpected side effects**: It checks for unexpected side effects during component rendering, state updates, and lifecycle methods.\n\n## Double-Invocation Mechanism\nStrictMode intentionally double-invokes methods or functions such as:\n- Component `render` method.\n- `useState`, `useReducer` updater functions.\n- `useEffect` cleanup and setup functions.\n- Class component `constructor`, `render`, `shouldComponentUpdate`, `getDerivedStateFromProps`, `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`.\n\nIf your components are pure and free of side effects, this double invocation will not cause any issues. If there are side effects (e.g., mutating external state in a `render` method), the double invocation will make them more apparent during development, aiding in debugging and fixing them.\n\n## Usage\nTo use `StrictMode`, wrap any part of your application with `<React.StrictMode>`.",
      "examples": [
        {
          "id": "example_strict_mode_1",
          "title": "Basic StrictMode Usage",
          "code": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\n\nfunction MyComponent() {\n  // In StrictMode, if this console.log had side effects, \n  // it would be more apparent due to double invocation.\n  console.log('MyComponent is rendering');\n  return <h1>Hello from MyComponent</h1>;\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <MyComponent />\n  </React.StrictMode>\n);",
          "explanation": "This example shows how to wrap a component with `React.StrictMode`. During development, `MyComponent`'s `console.log` might appear twice, indicating the double invocation of the render method and prompting developers to ensure their components' render logic is pure.",
          "language": "typescript"
        },
        {
          "id": "example_strict_mode_2",
          "title": "StrictMode with useState and useEffect",
          "code": "import React, { useState, useEffect } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Effect setup run, count:', count);\n    return () => {\n      console.log('Effect cleanup run, count:', count);\n    };\n  }, [count]);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <React.StrictMode>\n      <Counter />\n    </React.StrictMode>\n  );\n}\n\nexport default App;",
          "explanation": "In this example, when `Counter` mounts or `count` changes in StrictMode, you will see the effect setup and cleanup functions log twice. This is React helping ensure that your effects are idempotent and handle cleanup correctly, which is crucial for future concurrent features.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "StrictMode",
        "Development",
        "Debugging",
        "Side Effects",
        "Performance"
      ],
      "prerequisites": [
        "React_Component_Lifecycle",
        "React_Hooks_Basics"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "StrictMode",
      "Development",
      "Debugging",
      "Side Effects",
      "Performance"
    ],
    "prerequisites": [
      "React_Component_Lifecycle",
      "React_Hooks_Basics"
    ]
  },
  {
    "index": 63,
    "id": "theory_react_form_handling_class_components",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "Basic Form Handling with Class Components in React",
    "description": "",
    "content": {
      "id": "theory_react_form_handling_class_components",
      "title": "Basic Form Handling with Class Components in React",
      "description": "",
      "type": "theory",
      "content": "In React, forms are typically handled using controlled components. A controlled component is an input form element whose value is controlled by React state. When the user types into a controlled input, their input is stored in the component's state, and then the input element's `value` prop is updated with this state. This ensures that the React state is the single source of truth for the input's value.\n\n### Key Concepts\n-   **Controlled Components**: Form elements whose values are controlled by React state. This is achieved by binding the `value` prop of the input element to a state variable and updating that state variable via an `onChange` event handler.\n-   **`state`**: An object in a class component that holds data that can change over time and affect the rendering of the component. Changes to `state` trigger a re-render.\n-   **`onChange` Event Handler**: A function attached to input elements (e.g., `<input>`, `<textarea>`, `<select>`) that fires whenever the input's value changes. It typically updates the component's state with the new input value.\n-   **`event.target.name`**: Inside an `onChange` event handler, `event.target` refers to the DOM element that triggered the event. `event.target.name` retrieves the `name` attribute of that input element, which is useful for handling multiple inputs with a single handler.\n-   **`event.target.value`**: Retrieves the current value of the input element that triggered the event.\n-   **`onSubmit` Event Handler**: A function attached to the `<form>` element that fires when the form is submitted. It's crucial to call `event.preventDefault()` inside this handler to stop the default browser behavior of reloading the page on form submission, allowing React to handle the submission logic.\n\n### Implementation\n1.  **Initialize State**: Define initial empty values for each input in the component's `state`.\n2.  **Bind Input Values**: Set the `value` prop of each input field to its corresponding state variable (e.g., `value={this.state.username}`).\n3.  **Handle Changes**: Attach an `onChange` event handler to each input. This handler updates the relevant state property using `this.setState()`. A common pattern is to use `[event.target.name]: event.target.value` to dynamically update the correct state property based on the input's `name` attribute.\n4.  **Handle Submission**: Attach an `onSubmit` event handler to the `<form>`. Inside this handler, prevent the default behavior and then access the form data from the component's state.\n\nThis pattern provides a clear and predictable way to manage form data in React applications, making it easier to implement validation and handle data flow.",
      "examples": [
        {
          "id": "example_form_handling_1",
          "title": "Basic Login Form with Class Component",
          "code": "import React, { Component } from 'react';\n\nclass LoginForm extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      username: '',\n      password: ''\n    };\n    this.handleInputChange = this.handleInputChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleInputChange(event) {\n    const { name, value } = event.target;\n    this.setState({\n      [name]: value\n    });\n  }\n\n  handleSubmit(event) {\n    event.preventDefault();\n    console.log('Login Submitted:', this.state);\n    // Here you would typically send data to a backend or perform validation\n    alert(`Submitting username: ${this.state.username}, password: ${this.state.password}`);\n    // Optionally clear form or redirect\n    this.setState({\n        username: '',\n        password: ''\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>Login Form</h2>\n        <form onSubmit={this.handleSubmit}>\n          <div>\n            <label>Username:</label>\n            <input\n              type=\"text\"\n              name=\"username\"\n              value={this.state.username}\n              onChange={this.handleInputChange}\n            />\n          </div>\n          <div>\n            <label>Password:</label>\n            <input\n              type=\"password\"\n              name=\"password\"\n              value={this.state.password}\n              onChange={this.handleInputChange}\n            />\n          </div>\n          <button type=\"submit\">Login</button>\n        </form>\n      </div>\n    );\n  }\n}\n\nexport default LoginForm;\n",
          "explanation": "This example demonstrates a basic controlled login form implemented using a React class component. The `state` holds the `username` and `password`. The `handleInputChange` method dynamically updates the state based on the input's `name` attribute, making it reusable for multiple inputs. The `handleSubmit` method prevents the default form submission behavior and logs the current state, simulating a login action. After submission, the form fields are cleared by resetting the state.",
          "language": "javascript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "Forms",
        "Class Components",
        "State Management",
        "Controlled Components"
      ],
      "prerequisites": [
        "react_basics",
        "javascript_es6"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Forms",
      "Class Components",
      "State Management",
      "Controlled Components"
    ],
    "prerequisites": [
      "react_basics",
      "javascript_es6"
    ]
  },
  {
    "index": 68,
    "id": "theory_react_hooks_introduction",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "Introduction to React Hooks",
    "description": "",
    "content": {
      "id": "theory_react_hooks_introduction",
      "title": "Introduction to React Hooks",
      "description": "",
      "type": "theory",
      "content": "React Hooks, introduced in React 16.8, are functions that allow you to \"hook into\" React state and lifecycle features from function components. Before Hooks, these features were primarily available only in class components. Hooks enable developers to write functional components that can manage state, side effects, and other React features, leading to more concise, readable, and reusable code.\n\n### Why Hooks?\n\nBefore Hooks, managing state and side effects in functional components was not possible. Developers had to convert functional components to class components to use features like `state`, `componentDidMount`, etc. Hooks provide an alternative to classes, allowing for:\n\n*   **Reusability:** Custom Hooks can encapsulate reusable stateful logic.\n*   **Simplicity:** Often leads to less boilerplate code compared to classes.\n*   **Readability:** Easier to follow the logic within components.\n*   **Improved stateful logic sharing:** Stateful logic can be extracted and tested independently.\n\n### Basic Rules of Hooks\n\nWhile not explicitly in the provided text, understanding these rules is crucial for correct Hook usage:\n\n1.  **Only call Hooks at the top level:** Don't call Hooks inside loops, conditions, or nested functions.\n2.  **Only call Hooks from React Function Components:** Don't call Hooks from regular JavaScript functions (unless it's a custom Hook).",
      "examples": [],
      "complexity": 5,
      "tags": [
        "React",
        "Hooks",
        "Introduction",
        "Functional Components",
        "State Management"
      ],
      "prerequisites": [
        "react_functional_components",
        "javascript_es6_features"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Hooks",
      "Introduction",
      "Functional Components",
      "State Management"
    ],
    "prerequisites": [
      "react_functional_components",
      "javascript_es6_features"
    ]
  },
  {
    "index": 69,
    "id": "theory_lazy_initial_state",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "Lazy Initial State with useState Hook",
    "description": "",
    "content": {
      "id": "theory_lazy_initial_state",
      "title": "Lazy Initial State with useState Hook",
      "description": "",
      "type": "theory",
      "content": "The `useState` hook in React allows functional components to manage local state. When the initial state calculation is computationally expensive, React provides a mechanism to perform this calculation only once, during the component's initial render. This is achieved by passing a function (an 'initializer function') to `useState` instead of the direct initial value.\n\nWhen `useState` receives a function, it executes that function only during the first render to derive the initial state. Subsequent re-renders of the component will not re-execute this initializer function, thus optimizing performance by avoiding unnecessary computations. This is particularly useful when the initial state depends on complex calculations, heavy data processing, or involves reading from local storage.\n\n## Key Concepts\n-   **Initializer Function**: A function passed to `useState` that computes and returns the initial state.\n-   **Lazy Initialization**: The initializer function is executed only once, on the very first render of the component.\n-   **Performance Optimization**: Prevents expensive calculations from running on every re-render, improving application efficiency.\n\n## Syntax\n```typescript\nconst [state, setState] = useState(() => {\n  // Expensive calculation here\n  return initialValue;\n});\n```\n",
      "examples": [
        {
          "id": "example_lazy_initial_state_1",
          "title": "Basic Lazy Initial State",
          "code": "import React, { useState } from 'react';\n\nfunction computeExpensiveValue() {\n  // Simulate a heavy calculation\n  console.log('Performing expensive initial calculation...');\n  let sum = 0;\n  for (let i = 0; i < 1000000; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\nfunction ExpensiveInitialState() {\n  const [count, setCount] = useState(() => {\n    console.log('Computing initial state in useState...');\n    return computeExpensiveValue();\n  });\n  \n  console.log('Component rendered or re-rendered...');\n\n  return (\n    <div>\n      <h2>Lazy Initial State Example</h2>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\n      <button onClick={() => setCount(prev => prev - 1)}>Decrement Count</button>\n    </div>\n  );\n}\n\nexport default ExpensiveInitialState;",
          "explanation": "This example demonstrates the use of a function to initialize state. The `computeExpensiveValue()` function, which simulates a long-running calculation, is called only once when the `ExpensiveInitialState` component first mounts. Subsequent clicks on the 'Increment Count' or 'Decrement Count' buttons will cause the component to re-render, but `computeExpensiveValue()` will not be invoked again, as indicated by the console logs. This ensures that the expensive operation is not unnecessarily repeated.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "useState",
        "Hooks",
        "Performance",
        "Optimization"
      ],
      "prerequisites": [
        "react_functional_components",
        "react_useState_hook"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "useState",
      "Hooks",
      "Performance",
      "Optimization"
    ],
    "prerequisites": [
      "react_functional_components",
      "react_useState_hook"
    ]
  },
  {
    "index": 70,
    "id": "theory_use_effect_basics_and_cleanup",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "Introduction to useEffect and Cleanup Function",
    "description": "",
    "content": {
      "id": "theory_use_effect_basics_and_cleanup",
      "title": "Introduction to useEffect and Cleanup Function",
      "description": "",
      "type": "theory",
      "content": "The `useEffect` hook in React allows you to perform side effects in functional components. Side effects are operations that interact with the outside world, such as data fetching, subscriptions, manually changing the DOM, or setting up event listeners. By default, `useEffect` runs after every render of the component, but its behavior can be controlled by a dependency array.\n\nThe `useEffect` hook takes two arguments: a function containing the side effect code and an optional dependency array.\n\n```typescript\nuseEffect(() => {\n  // Side effect code here\n\n  return () => {\n    // Cleanup function (optional)\n    // This runs before the component unmounts\n    // or before the effect re-runs (if dependencies change)\n  };\n}, [dependencies]); // Dependency array\n```\n\n### Cleanup Function\n\nThe cleanup function is an optional return from the effect callback. It is crucial for preventing memory leaks and unwanted behavior. The cleanup function runs in two main scenarios:\n\n1.  **Before the component unmounts:** When the component is removed from the DOM, the cleanup function for its last effect execution is invoked.\n2.  **Before the next effect re-runs:** If the effect is scheduled to run again due to a change in its dependencies, the cleanup function from the *previous* effect execution is run before the *new* effect is executed. This ensures that any subscriptions or event listeners from the previous render are properly disposed of before new ones are set up.\n\nCommon use cases for cleanup include:\n*   Unsubscribing from external data sources (e.g., websockets, RxJS observables).\n*   Clearing timers (e.g., `setTimeout`, `setInterval`).\n*   Removing event listeners.\n*   Canceling network requests.",
      "examples": [
        {
          "id": "example_use_effect_basics_1",
          "title": "Basic Subscription with Cleanup",
          "code": "import React, { useState, useEffect } from 'react';\n\n// Assume these functions exist for demonstration\nconst subscribeToService = (callback) => {\n  console.log('Subscribing to service...');\n  const intervalId = setInterval(() => {\n    callback(Math.random());\n  }, 1000);\n  return {\n    unsubscribe: () => {\n      console.log('Unsubscribing from service...');\n      clearInterval(intervalId);\n    }\n  };\n};\n\nfunction SubscriptionComponent() {\n  const [data, setData] = useState(null);\n  \n  useEffect(() => {\n    // Subscribe to some service\n    const subscription = subscribeToService(data => {\n      setData(data);\n    });\n    \n    // Cleanup function - runs before component unmounts or before next effect runs\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, []); // Empty dependency array means this effect runs once on mount and cleanup on unmount\n  \n  return (\n    <div>\n      <h2>Subscription Data</h2>\n      <p>Data: {data !== null ? data.toFixed(4) : 'Loading...'}</p>\n    </div>\n  );\n}",
          "explanation": "This example demonstrates how `useEffect` can be used to manage subscriptions. When `SubscriptionComponent` mounts, `subscribeToService` is called, and `setData` updates the component's state with new data. The `return` function acts as the cleanup, ensuring that `subscription.unsubscribe()` is called when the component unmounts (due to the empty dependency array `[]`), preventing memory leaks from the interval.",
          "language": "typescript"
        },
        {
          "id": "example_use_effect_basics_2",
          "title": "Setting Document Title with Cleanup",
          "code": "import React, { useState, useEffect } from 'react';\n\nfunction TitleUpdater() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const originalTitle = document.title;\n    document.title = `Count is ${count}`;\n\n    // Cleanup: Restore original title when component unmounts\n    return () => {\n      document.title = originalTitle;\n    };\n  }, [count]); // Re-run effect when count changes\n\n  return (\n    <div>\n      <h3>Title Updater</h3>\n      <p>Current count: {count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>Increment Count</button>\n      <p>Check your browser tab title!</p>\n    </div>\n  );\n}",
          "explanation": "This example shows a simple side effect (modifying the document title) with a cleanup function. The effect updates the title whenever `count` changes. The cleanup function ensures that when the component unmounts, the document title is reverted to its original value, preventing permanent modification of the browser title by this component.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "Hooks",
        "useEffect",
        "Side Effects",
        "Cleanup",
        "Lifecycle"
      ],
      "prerequisites": [
        "react_functional_components",
        "react_useState"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Hooks",
      "useEffect",
      "Side Effects",
      "Cleanup",
      "Lifecycle"
    ],
    "prerequisites": [
      "react_functional_components",
      "react_useState"
    ]
  },
  {
    "index": 74,
    "id": "theory_react_context_fundamentals",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "React Context API Fundamentals: Passing Data Without Prop Drilling",
    "description": "",
    "content": {
      "id": "theory_react_context_fundamentals",
      "title": "React Context API Fundamentals: Passing Data Without Prop Drilling",
      "description": "",
      "type": "theory",
      "content": "The React Context API provides a way to pass data through the component tree without having to pass props down manually at every level. This is particularly useful for 'global' data that many components in an application might need, such as themes, user authentication status, or preferred language.\n\n## Key Concepts\n\n### 1. `React.createContext`\n`React.createContext` is used to create a Context object. When React renders a component that subscribes to this Context object, it will read the current context value from the closest matching `Provider` above it in the tree. The argument passed to `createContext` (e.g., `dark` in `ThemeContext = React.createContext('dark')`) is the `defaultValue`. This `defaultValue` is used when a component consumes the context without a corresponding `Provider` in the tree. It helps with testing components in isolation without wrapping them in a Provider.\n\n### 2. `Context.Provider`\nThe `Provider` component, which is a property of the Context object (`ThemeContext.Provider`), allows consuming components to subscribe to context changes. It accepts a `value` prop that will be passed down to all consumers of this context that are descendants of this `Provider`. A `Provider` can be nested inside other `Providers` to override values for components deeper in the tree.\n\n### 3. `useContext` Hook\n`useContext` is a React Hook that allows functional components to consume the context value provided by the nearest `Context.Provider` above it. It takes the Context object itself (e.g., `ThemeContext`) as an argument and returns the current context `value`. If no `Provider` is found, it returns the `defaultValue` specified when creating the context.\n\n## Why use Context?\n*   **Avoids Prop Drilling:** Context prevents the need to pass data through many intermediate components that don't directly use the data, simplifying component APIs and making code cleaner.\n*   **Global State Management:** It's suitable for managing global application state that is infrequently updated or doesn't require complex state logic (like authentication, themes, user preferences).\n\n## Limitations\n*   **Performance:** Context is not optimized for high-frequency updates. When the `value` prop of a `Provider` changes, all consuming components re-render, even if they only use a small portion of the context value. For complex, rapidly changing state, dedicated state management libraries (like Redux, Zustand, Recoil) might be more efficient.\n*   **Complexity:** Overuse can lead to a less explicit data flow, making it harder to trace where data comes from.",
      "examples": [
        {
          "id": "example_context_basic_theme",
          "title": "Basic Theme Context Example",
          "code": "import React, { createContext, useContext } from 'react';\n\n// 1. Create a Context object\nconst ThemeContext = createContext('light'); // 'light' is the default value\n\n// Root component that provides the context value\nfunction App() {\n  return (\n    <ThemeContext.Provider value=\"dark\">\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\n// Intermediate component - doesn't need to know about theme, just passes children\nfunction Toolbar() {\n  return <ThemedButton />;\n}\n\n// Component that consumes the context value\nfunction ThemedButton() {\n  // 3. Use the useContext hook to read the context value\n  const theme = useContext(ThemeContext);\n  return (\n    <button style={{ background: theme === 'dark' ? '#333' : '#eee', color: theme === 'dark' ? '#fff' : '#000' }}>\n      {theme} mode\n    </button>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));",
          "explanation": "This example demonstrates the core usage of `createContext`, `Provider`, and `useContext`. The `App` component provides the 'dark' theme value. The `Toolbar` component doesn't receive any props related to the theme, yet `ThemedButton`, nested within it, can directly access the theme value using `useContext(ThemeContext)`. This effectively avoids 'prop drilling' the `theme` prop through `Toolbar`.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "Context API",
        "Hooks",
        "State Management",
        "Prop Drilling"
      ],
      "prerequisites": [
        "react_functional_components",
        "react_props"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Context API",
      "Hooks",
      "State Management",
      "Prop Drilling"
    ],
    "prerequisites": [
      "react_functional_components",
      "react_props"
    ]
  },
  {
    "index": 78,
    "id": "theory_client_components",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "React Client Components",
    "description": "",
    "content": {
      "id": "theory_client_components",
      "title": "React Client Components",
      "description": "",
      "type": "theory",
      "content": "React Client Components are traditional React components that run exclusively on the client-side, meaning within the user's web browser. They are responsible for rendering interactive UI, managing client-side state, and handling user interactions. These components rely on JavaScript to be downloaded, parsed, and executed by the browser to become interactive. They are typically defined without any special directives and use React hooks like `useState`, `useEffect`, `useContext`, etc., for managing their local state and side effects.",
      "examples": [
        {
          "id": "example_client_component_1",
          "title": "Interactive Client Component",
          "code": "import React, { useState } from 'react';\n\n// This is a traditional React component that runs in the browser\nexport default function ClientComponent() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>\n        Increment\n      </button>\n    </div>\n  );\n}",
          "explanation": "This example demonstrates a basic React Client Component. It uses the `useState` hook to manage the `count` state, which is initialized to 0. The component renders a paragraph displaying the current count and a button. Clicking the button updates the `count` state, triggering a re-render and updating the displayed text, all handled by JavaScript executing in the browser.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "Client-side",
        "Frontend",
        "useState",
        "Interactivity"
      ],
      "prerequisites": [
        "JavaScript_basics",
        "HTML_basics",
        "CSS_basics",
        "React_fundamentals"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Client-side",
      "Frontend",
      "useState",
      "Interactivity"
    ],
    "prerequisites": [
      "JavaScript_basics",
      "HTML_basics",
      "CSS_basics",
      "React_fundamentals"
    ]
  },
  {
    "index": 82,
    "id": "theory_useref",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "React Hook: useRef",
    "description": "",
    "content": {
      "id": "theory_useref",
      "title": "React Hook: useRef",
      "description": "",
      "type": "theory",
      "content": "The `useRef` hook in React provides a way to create a mutable `ref` object whose `.current` property can hold a mutable value. This value persists across re-renders of the component and, crucially, updating the `.current` property does *not* trigger a re-render.\n\n## Key Concepts\n-   **Mutable Object:** `useRef` returns a plain JavaScript object `{ current: initialValue }`. The `current` property is mutable and can be updated.\n-   **Persistence:** The `ref` object (and its `current` property) persists for the entire lifetime of the component, even across re-renders.\n-   **No Re-renders:** Unlike `useState`, changing the `.current` value of a ref does *not* cause the component to re-render. This makes it ideal for storing values that don't directly affect the component's render output but need to be retained.\n-   **Accessing DOM Elements:** A primary use case for `useRef` is to directly access DOM elements or React components. When you pass a ref created by `useRef` to an element's `ref` attribute (e.g., `<div ref={myRef}>`), React will set `myRef.current` to the corresponding DOM element after it's mounted. This allows imperative interactions with the DOM, like playing/pausing a video, focusing an input, or measuring dimensions.\n-   **Storing Mutable Values:** Besides DOM access, `useRef` can store any mutable value that needs to persist across renders without triggering updates. This could be a timer ID, a previous state value, or an instance of a third-party library object.",
      "examples": [
        {
          "id": "example_useref_1",
          "title": "Controlling a Video Element",
          "code": "import React, { useRef } from 'react';\n\nfunction VideoPlayer() {\n  const videoRef = useRef(null);\n  \n  const handlePlay = () => {\n    if (videoRef.current) {\n      videoRef.current.play();\n    }\n  };\n  \n  const handlePause = () => {\n    if (videoRef.current) {\n      videoRef.current.pause();\n    }\n  };\n  \n  return (\n    <div>\n      <video \n        ref={videoRef} \n        src=\"https://www.w3schools.com/html/mov_bbb.mp4\" \n        controls\n        width=\"400\"\n      />\n      <div>\n        <button onClick={handlePlay}>Play</button>\n        <button onClick={handlePause}>Pause</button>\n      </div>\n    </div>\n  );\n}\n",
          "explanation": "This example demonstrates how `useRef` can be used to get a direct reference to a DOM element (the `<video>` tag). The `videoRef.current` property holds the actual HTMLVideoElement, allowing us to call its methods like `play()` and `pause()` imperatively. This is a common pattern for interacting with media elements or other DOM APIs.",
          "language": "typescript"
        },
        {
          "id": "example_useref_2",
          "title": "Storing a Mutable Value",
          "code": "import React, { useRef, useState } from 'react';\n\nfunction Counter() {\n  const countRef = useRef(0);\n  const [renderCount, setRenderCount] = useState(0);\n\n  const incrementRef = () => {\n    countRef.current = countRef.current + 1;\n    console.log('Ref Count:', countRef.current);\n    // This will not re-render the component\n  };\n\n  const triggerReRender = () => {\n    setRenderCount(prev => prev + 1);\n  };\n  \n  return (\n    <div>\n      <p>Ref Count (updates, but doesn't re-render): {countRef.current}</p>\n      <p>Render Count (updates and re-renders): {renderCount}</p>\n      <button onClick={incrementRef}>Increment Ref Count</button>\n      <button onClick={triggerReRender}>Trigger Component Re-render</button>\n      <p>Open console to see ref count updating without re-render until re-render is triggered by state change.</p>\n    </div>\n  );\n}\n",
          "explanation": "Here, `countRef` stores a mutable number that persists across renders. When `incrementRef` is called, `countRef.current` updates, but the component itself does not re-render, so the displayed `Ref Count` does not change immediately. Only when `triggerReRender` is called (which updates `renderCount` state) does the component re-render and display the latest `countRef.current` value. This illustrates `useRef`'s ability to hold mutable data without causing re-renders.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React Hooks",
        "useRef",
        "DOM manipulation",
        "Imperative programming"
      ],
      "prerequisites": [
        "React basics",
        "Functional Components",
        "State management with useState"
      ],
      "technology": "React"
    },
    "tags": [
      "React Hooks",
      "useRef",
      "DOM manipulation",
      "Imperative programming"
    ],
    "prerequisites": [
      "React basics",
      "Functional Components",
      "State management with useState"
    ]
  },
  {
    "index": 83,
    "id": "theory_use_debug_value",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "useDebugValue Hook",
    "description": "",
    "content": {
      "id": "theory_use_debug_value",
      "title": "useDebugValue Hook",
      "description": "",
      "type": "theory",
      "content": "The `useDebugValue` hook is a specialized React Hook primarily intended for use within custom hooks. Its main purpose is to display a custom label for custom hooks in React DevTools. This can be extremely useful for debugging, as it allows developers to inspect the current value or state of a custom hook without having to expand it or dig through its internal state.\n\n### How it Works\n`useDebugValue` accepts two arguments:\n1.  **Value**: The value you want to display in DevTools. This can be any JavaScript value.\n2.  **Formatter Function (Optional)**: An optional formatter function. If provided, this function will receive the `value` as its argument and should return a formatted display value. This function is only executed when the React DevTools are open and the hook is inspected, which helps prevent unnecessary computations in production environments.\n\n### Benefits\n-   **Improved Debugging Experience**: Provides immediate visibility into the internal state of custom hooks.\n-   **Performance**: The formatter function ensures that expensive formatting operations are only performed when necessary (i.e., when DevTools are active and inspecting the hook).\n\n### Usage Guidelines\n-   It should only be used inside custom hooks.\n-   It is a development-time tool and has no impact on production bundles or application logic.\n-   Use it judiciously for values that are genuinely helpful for debugging the custom hook's behavior.",
      "examples": [
        {
          "id": "example_use_debug_value_basic",
          "title": "Basic useDebugValue in a Custom Hook",
          "code": "import React, { useState, useEffect, useDebugValue } from 'react';\n\n// Simulate external API for user status\nconst userStatusStore = {};\nfunction subscribeToUserStatus(userId, callback) {\n  userStatusStore[userId] = userStatusStore[userId] || { isOnline: false };\n  // Simulate async subscription\n  setTimeout(() => {\n    callback(userStatusStore[userId]);\n  }, 100);\n}\nfunction unsubscribeFromUserStatus(userId, callback) {\n  // In a real app, clean up subscription\n}\n\n// Custom hook with debug value\nfunction useUserStatus(userId) {\n  const [isOnline, setIsOnline] = useState(null);\n  \n  useEffect(() => {\n    // Subscribe to user online status\n    const handleStatusChange = (status) => {\n      setIsOnline(status.isOnline);\n    };\n    \n    // Simplified API call\n    subscribeToUserStatus(userId, handleStatusChange);\n    \n    return () => {\n      unsubscribeFromUserStatus(userId, handleStatusChange);\n    };\n  }, [userId]);\n  \n  // Show custom label in React DevTools\n  // This will display 'Online' or 'Offline' next to the hook in DevTools\n  useDebugValue(isOnline ? 'Online' : 'Offline');\n  \n  return isOnline;\n}\n\n// Usage example component\nfunction UserStatus({ userId }) {\n  const isOnline = useUserStatus(userId);\n  \n  if (isOnline === null) {\n    return <div>Loading user {userId} status...</div>;\n  }\n  \n  return (\n    <div>\n      User {userId} is {isOnline ? 'online' : 'offline'}\n    </div>\n  );\n}\n\n// To run this, you would render <UserStatus userId=\"123\" /> in your app.\n// Then open React DevTools, inspect the component, and look for 'Hooks' tab.\n",
          "explanation": "This example demonstrates a `useUserStatus` custom hook that subscribes to a user's online status. The `useDebugValue` hook is used to display a simple 'Online' or 'Offline' string directly in the React DevTools, making it easy to see the user's status without drilling down into the hook's internal state. This is particularly helpful for custom hooks that manage complex logic or asynchronous operations.",
          "language": "typescript"
        },
        {
          "id": "example_use_debug_value_formatter",
          "title": "useDebugValue with Formatter Function",
          "code": "import React, { useState, useEffect, useDebugValue } from 'react';\n\nfunction useCounter(initialValue) {\n  const [count, setCount] = useState(initialValue);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setCount(prevCount => prevCount + 1);\n    }, 1000);\n    return () => clearInterval(interval);\n  }, []);\n\n  // Use a formatter function to display a more descriptive label\n  useDebugValue(count, c => `Count: ${c} (Active)`);\n\n  return count;\n}\n\nfunction CounterDisplay() {\n  const currentCount = useCounter(0);\n\n  return (\n    <div>\n      Current Count: {currentCount}\n    </div>\n  );\n}\n",
          "explanation": "This example shows `useDebugValue` with its optional second argument, a formatter function. The `useCounter` hook manages a simple counter. Instead of just displaying the raw `count` number, the formatter function `c => `Count: ${c} (Active)`` provides a more descriptive string. This function is only executed when DevTools are open, optimizing performance by avoiding unnecessary string interpolation in production.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React Hooks",
        "Debugging",
        "Developer Tools",
        "Custom Hooks"
      ],
      "prerequisites": [
        "React Basics",
        "Custom Hooks"
      ],
      "technology": "React"
    },
    "tags": [
      "React Hooks",
      "Debugging",
      "Developer Tools",
      "Custom Hooks"
    ],
    "prerequisites": [
      "React Basics",
      "Custom Hooks"
    ]
  },
  {
    "index": 119,
    "id": "theory_react_component_basics",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "React Functional Components and State Management with Hooks",
    "description": "",
    "content": {
      "id": "theory_react_component_basics",
      "title": "React Functional Components and State Management with Hooks",
      "description": "",
      "type": "theory",
      "content": "React applications are built using components, which are independent, reusable pieces of UI. Functional components are JavaScript functions that accept props (properties) as input and return React elements describing what should appear on the screen.\n\n### `useState` Hook\n`useState` is a React Hook that lets you add state to functional components. Before Hooks, state was primarily managed in class components. `useState` returns an array with two elements:\n\n1.  **Current state value**: The current value of the state variable.\n2.  **Setter function**: A function that lets you update the state. When the setter function is called with a new state value, React re-renders the component.\n\n#### Basic Usage\n```typescript\nimport React, { useState } from 'react';\n\nfunction MyComponent() {\n  // Declares a state variable 'count' initialized to 0\n  // and a setter function 'setCount'\n  const [count, setCount] = useState(0);\n\n  // When 'setCount' is called, 'count' updates and the component re-renders.\n  const increment = () => setCount(count + 1);\n\n  return (\n    <div>\n      <p>Current Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n```\n\n### JSX (JavaScript XML)\nReact components use JSX, a syntax extension for JavaScript. JSX allows you to write HTML-like structures directly within your JavaScript code. It's not mandatory to use JSX, but it makes React code more readable and concise. JSX expressions are compiled down to `React.createElement()` calls.",
      "examples": [
        {
          "id": "example_react_counter_1",
          "title": "React Counter Component",
          "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nexport default Counter;",
          "explanation": "This example demonstrates a basic React functional component. `useState(0)` initializes `count` to 0. The button's `onClick` handler calls `setCount` to update the state, which triggers a re-render of the component, displaying the new `count` value.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "Hooks",
        "useState",
        "Functional Components",
        "JSX",
        "State Management"
      ],
      "prerequisites": [
        "JavaScript ES6",
        "HTML basics"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Hooks",
      "useState",
      "Functional Components",
      "JSX",
      "State Management"
    ],
    "prerequisites": [
      "JavaScript ES6",
      "HTML basics"
    ]
  },
  {
    "index": 130,
    "id": "theory_react_key_best_practices",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "React Best Practices: Avoiding Index as Key",
    "description": "",
    "content": {
      "id": "theory_react_key_best_practices",
      "title": "React Best Practices: Avoiding Index as Key",
      "description": "",
      "type": "theory",
      "content": "Using the `key` prop in React lists is crucial for performance and correctness. When rendering lists of components, React uses `keys` to identify which items have changed, are added, or are removed. This helps React efficiently update the UI during reconciliation.\n\n## The Problem with Using Index as Key\nUsing an array's index as a `key` (`key={index}`) is a common anti-pattern, especially when list items can be reordered, added, or removed. React uses keys to maintain the identity of components. If an item's position changes but its `key` (which is its index) remains the same as another item that was previously at that position, React might reuse the component instance instead of re-rendering it or moving it. This can lead to:\n\n1.  **Component State Mix-ups:** If a list item has internal state (e.g., an input field's value, a checkbox's checked state), that state might persist with the wrong item when the list is reordered, as React thinks it's the same component just at a new index.\n2.  **Unnecessary Re-renders and Performance Issues:** When items are inserted or removed in the middle of a list, all subsequent items will have their indices shifted. React will perceive these as new components at those new indices, leading to unnecessary re-mounting and re-rendering of many components instead of just the changed ones.\n3.  **Subtle UI Bugs:** These issues are often hard to track down because the UI might appear correct initially, but unexpected behavior emerges after list modifications.\n\n## Good Practice: Using Unique, Stable Identifiers\nAlways use a unique and stable identifier for each item in a list as its `key` prop. This identifier should be intrinsic to the data itself and remain consistent across re-renders and reordering.\n\n### When is `index` acceptable?\nUsing `index` as a `key` is generally discouraged. However, it *can* be acceptable in very specific scenarios where:\n1.  The list and its items are static and will **never** change (no additions, deletions, or reordering).\n2.  The items in the list have no unique IDs.\n3.  The list is never filtered or reordered.\n\nIn most real-world applications, these conditions are rarely met, making it safer to always use unique IDs.",
      "examples": [
        {
          "id": "example_key_bad_practice",
          "title": "Bad Practice: Using Index as Key",
          "code": "function ItemList({ items }) {\n  return (\n    <ul>\n      {items.map((item, index) => (\n        // BAD: Using index as key can lead to bugs and performance issues\n        <ListItem key={index} item={item} />\n      ))}\n    </ul>\n  );\n}\n\nfunction ListItem({ item }) {\n  // Imagine ListItem has internal state, e.g., an input field\n  return <li>{item.name}</li>;\n}",
          "explanation": "This example demonstrates the incorrect use of `index` as a key. If `items` array is reordered, React might not correctly update the DOM elements, leading to state persistence issues or incorrect rendering of list items.",
          "language": "typescript"
        },
        {
          "id": "example_key_good_practice",
          "title": "Good Practice: Using Unique ID as Key",
          "code": "function ItemList({ items }) {\n  return (\n    <ul>\n      {items.map(item => (\n        // GOOD: Using a stable, unique ID ensures correct component identity\n        <ListItem key={item.id} item={item} />\n      ))}\n    </ul>\n  );\n}\n\nfunction ListItem({ item }) {\n  // Imagine ListItem has internal state, e.g., an input field\n  return <li>{item.name}</li>;\n}",
          "explanation": "This example shows the recommended approach: using a unique, stable identifier (`item.id`) from the data as the key. This allows React to efficiently and correctly reconcile the list when items are added, removed, or reordered.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "Performance",
        "Best Practices",
        "Lists",
        "Keys"
      ],
      "prerequisites": [
        "React_Components",
        "JavaScript_Array_Methods"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Performance",
      "Best Practices",
      "Lists",
      "Keys"
    ],
    "prerequisites": [
      "React_Components",
      "JavaScript_Array_Methods"
    ]
  },
  {
    "index": 135,
    "id": "theory_arrow_functions_this_binding",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "Understanding 'this' Binding with Arrow Functions in React Class Components",
    "description": "",
    "content": {
      "id": "theory_arrow_functions_this_binding",
      "title": "Understanding 'this' Binding with Arrow Functions in React Class Components",
      "description": "",
      "type": "theory",
      "content": "In JavaScript classes, especially within React class components, the `this` keyword can be a source of confusion. By default, when a method is passed as a callback (e.g., an event handler like `onClick` or `onChange`), its `this` context is lost and defaults to `undefined` in strict mode. This leads to errors when trying to access `this.state` or `this.setState` inside such methods.\n\nTraditionally, developers would explicitly bind `this` to the component instance using `Function.prototype.bind()` in the constructor, or directly in the JSX, or by using a class property with a traditional function expression:\n\n```typescript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleClick = this.handleClick.bind(this); // Binding in constructor\n  }\n\n  handleClick() {\n    // this is now correctly bound\n    this.setState({ clicked: true });\n  }\n\n  render() {\n    return <button onClick={this.handleClick}>Click Me</button>;\n  }\n}\n\n// Or binding in JSX (less performant for frequent re-renders):\n// <button onClick={this.handleClick.bind(this)}>Click Me</button>\n```\n\nArrow functions provide a more concise and intuitive solution to this problem. When an arrow function is defined as a class property, it automatically binds `this` to the instance of the class where it's defined. This lexical `this` binding ensures that `this` always refers to the component instance, eliminating the need for explicit binding.\n\nThis syntax (`myMethod = () => {...}`) is part of the 'class properties' proposal (or 'public class fields') and is typically enabled by build tools like Babel, which is included in `create-react-app`.",
      "examples": [
        {
          "id": "example_arrow_functions_this_binding_1",
          "title": "Arrow Function for Event Handler Binding",
          "code": "import React, { Component } from 'react';\n\nclass DataInput extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: '' };\n  }\n\n  // Arrow function automatically binds 'this' to the component instance\n  onInputChange = (e) => {\n    // 'this' is preserved here, referring to the DataInput component\n    this.setState({ data: e.currentTarget.value });\n  };\n\n  render() {\n    return (\n      <div>\n        <input type=\"text\" value={this.state.data} onChange={this.onInputChange} />\n        <p>Current Data: {this.state.data}</p>\n      </div>\n    );\n  }\n}\n\n// Usage example:\n// <DataInput />",
          "explanation": "This example demonstrates how an arrow function defined as a class property (`onInputChange = (e) => {...}`) automatically binds `this` to the `DataInput` component instance. When `onChange` is triggered, `e.currentTarget.value` correctly updates the component's state without needing `bind()` in the constructor. This makes the code cleaner and less error-prone for event handlers.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "JavaScript",
        "this",
        "Arrow Functions",
        "Class Components",
        "ES6"
      ],
      "prerequisites": [
        "JavaScript_this_keyword",
        "React_class_components",
        "ES6_arrow_functions"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "JavaScript",
      "this",
      "Arrow Functions",
      "Class Components",
      "ES6"
    ],
    "prerequisites": [
      "JavaScript_this_keyword",
      "React_class_components",
      "ES6_arrow_functions"
    ]
  },
  {
    "index": 139,
    "id": "theory_basic_react_forms_useref",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "Basic React Forms with useRef Hook",
    "description": "",
    "content": {
      "id": "theory_basic_react_forms_useref",
      "title": "Basic React Forms with useRef Hook",
      "description": "",
      "type": "theory",
      "content": "In React, handling forms can be approached in various ways. For simpler forms or when direct DOM manipulation is required, the `useRef` hook provides a way to access DOM elements or React components directly. This approach is often referred to as managing 'uncontrolled components' because the form data is handled by the DOM itself rather than by React state.\n\n## Key Concepts\n- **`useRef` Hook**: A React Hook that lets you reference a value that’s not needed for rendering. It can be used to hold a mutable value in its `.current` property, which persists across renders, making it ideal for direct DOM interactions, such as managing form input values.\n- **Uncontrolled Components**: Form elements whose values are handled by the DOM. You use a ref to get their current value when you need it (e.g., on form submission).\n- **`defaultValue` Prop**: Used for initial values in uncontrolled form inputs. Unlike `value` (which is used for controlled components), `defaultValue` sets the initial value, but subsequent changes are managed by the DOM.\n\n## Implementation Details\nTo use `useRef` for form inputs:\n1.  **Initialize `useRef`**: Call `const inputRef = useRef(null);` at the top level of your component.\n2.  **Attach to Input**: Pass the `ref` prop to the desired DOM element (e.g., `<input ref={inputRef} />`).\n3.  **Access Value**: On form submission, access the current value using `inputRef.current.value`.\n\nThis method is lightweight and avoids re-renders on every keystroke, which can be beneficial for very simple forms or specific use cases where you don't need real-time validation or complex state management.",
      "examples": [
        {
          "id": "example_useref_form_1",
          "title": "Basic Contact Form with useRef",
          "code": "import React, { useRef } from 'react';\n\nfunction BasicForm() {\n  const nameRef = useRef(null);\n  const emailRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault(); // Prevent default form submission behavior\n    const name = nameRef.current.value;\n    const email = emailRef.current.value;\n    const message = messageRef.current.value;\n    \n    console.log('Form Submitted:', {\n      name,\n      email,\n      message,\n    });\n    \n    // Optionally clear form fields after submission\n    nameRef.current.value = '';\n    emailRef.current.value = '';\n    messageRef.current.value = '';\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"name\">Name:</label>\n        <input\n          id=\"name\"\n          name=\"name\"\n          type=\"text\"\n          ref={nameRef}\n          defaultValue=\"\"\n        />\n      </div>\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input\n          id=\"email\"\n          name=\"email\"\n          type=\"email\"\n          ref={emailRef}\n          defaultValue=\"\"\n        />\n      </div>\n      <div>\n        <label htmlFor=\"message\">Message:</label>\n        <textarea\n          id=\"message\"\n          name=\"message\"\n          ref={messageRef}\n          defaultValue=\"\"\n        />\n      </div>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}",
          "explanation": "This example demonstrates a basic form where input values are managed using `useRef`. Each input element (`input`, `textarea`) is assigned a ref. On form submission, `handleSubmit` is called, which prevents the default browser behavior (`event.preventDefault()`). The current values are then accessed via `ref.current.value` and logged to the console. Finally, the fields are manually cleared.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "Forms",
        "Hooks",
        "useRef",
        "Uncontrolled Components",
        "DOM Manipulation"
      ],
      "prerequisites": [
        "react_functional_components",
        "react_hooks_basics",
        "html_forms_basics"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Forms",
      "Hooks",
      "useRef",
      "Uncontrolled Components",
      "DOM Manipulation"
    ],
    "prerequisites": [
      "react_functional_components",
      "react_hooks_basics",
      "html_forms_basics"
    ]
  },
  {
    "index": 157,
    "id": "theory_form_field_component",
    "type": "theory",
    "moduleId": "react",
    "complexity": 5,
    "title": "The `FormField` Component: Rendering Diverse Input Types",
    "description": "",
    "content": {
      "id": "theory_form_field_component",
      "title": "The `FormField` Component: Rendering Diverse Input Types",
      "description": "",
      "type": "theory",
      "content": "The `FormField` component is a foundational building block for dynamic forms, responsible for rendering different HTML input elements based on a given configuration. It acts as a switch, conditionally rendering `select`, `checkbox`, or other input types. Its primary role is to encapsulate the logic for associating a form field with its label, current value, and change handler, while also applying common HTML attributes like `id`, `name`, `required`, and specific attributes for each input type.\n\n## Key Concepts\n- **Props-driven Rendering**: The component receives a `field` object (containing `id`, `type`, `name`, `label`, `required`, `options`, `hint`), `value`, and an `onChange` callback.\n- **Conditional Rendering**: It uses a `switch` statement (or equivalent `if/else if`) on `field.type` to render the appropriate HTML element (`<select>`, `<input type='checkbox'>`).\n- **Value Handling**: It correctly binds the `value` prop to the HTML element's `value` or `checked` attribute. For `select` elements, `value || ''` ensures that an empty string is used if `value` is `null` or `undefined`, allowing the 'Select an option' placeholder to be active. For `checkbox` elements, `value || false` ensures the `checked` attribute is a boolean.\n- **Event Handling**: The `onChange` prop is a callback that is triggered when the input's value changes. For `select` and `text` inputs, `e.target.value` is passed. For `checkbox` inputs, `e.target.checked` is passed, reflecting the boolean state of the checkbox.\n- **Accessibility**: Utilizes `id` and `name` attributes for proper form submission and accessibility (`htmlFor` on a `label` element links to the `id` of its associated input).\n- **Extensibility**: The `default` case in the `switch` statement handles unsupported field types, making the component extensible for future input types.",
      "examples": [
        {
          "id": "example_form_field_select",
          "title": "Rendering a Select Field",
          "code": "interface FormFieldConfig {\n  id: string;\n  name: string;\n  label: string;\n  type: 'select' | 'checkbox' | 'text' | 'number';\n  required?: boolean;\n  options?: { value: string; label: string }[];\n  hint?: string;\n}\n\ninterface FormFieldProps {\n  field: FormFieldConfig;\n  value: any;\n  onChange: (fieldId: string, value: any) => void;\n}\n\nconst FormField = ({ field, value, onChange }: FormFieldProps) => {\n  switch (field.type) {\n    case 'select':\n      return (\n        <select\n          id={field.id}\n          name={field.name}\n          value={value || ''}\n          onChange={e => onChange(field.id, e.target.value)}\n          required={field.required}\n        >\n          <option value=\"\">Select an option</option>\n          {field.options && field.options.map(option => (\n            <option key={option.value} value={option.value}>\n              {option.label}\n            </option>\n          ))}\n        </select>\n      );\n    default:\n      return <div>Unsupported field type: {field.type}</div>;\n  }\n};\n\n// Usage example:\n// <FormField\n//   field={{\n//     id: 'city', name: 'city', label: 'City', type: 'select', required: true,\n//     options: [{ value: 'ny', label: 'New York' }, { value: 'la', label: 'Los Angeles' }]\n//   }}\n//   value={selectedCity}\n//   onChange={handleFormChange}\n// />",
          "explanation": "This example demonstrates how the `FormField` component renders a `<select>` element. It handles the `value` prop (defaulting to empty string for initial state or no selection), iterates over `field.options` to create `option` elements, and correctly captures the selected value using `e.target.value` when `onChange` is triggered.",
          "language": "typescript"
        },
        {
          "id": "example_form_field_checkbox",
          "title": "Rendering a Checkbox Field",
          "code": "interface FormFieldConfig {\n  id: string;\n  name: string;\n  label: string;\n  type: 'select' | 'checkbox' | 'text' | 'number';\n  required?: boolean;\n  options?: { value: string; label: string }[];\n  hint?: string;\n}\n\ninterface FormFieldProps {\n  field: FormFieldConfig;\n  value: any;\n  onChange: (fieldId: string, value: any) => void;\n}\n\nconst FormField = ({ field, value, onChange }: FormFieldProps) => {\n  switch (field.type) {\n    case 'checkbox':\n      return (\n        <input\n          type=\"checkbox\"\n          id={field.id}\n          name={field.name}\n          checked={value || false}\n          onChange={e => onChange(field.id, e.target.checked)}\n          required={field.required}\n        />\n      );\n    default:\n      return <div>Unsupported field type: {field.type}</div>;\n  }\n};\n\n// Usage example:\n// <FormField\n//   field={{ id: 'agree', name: 'agree', label: 'Agree to terms', type: 'checkbox' }}\n//   value={isAgreed}\n//   onChange={handleFormChange}\n// />",
          "explanation": "This example shows the implementation for a `checkbox` input. Notice how `checked={value || false}` is used to ensure the `checked` attribute always receives a boolean. The `onChange` event specifically uses `e.target.checked` to get the boolean state of the checkbox.",
          "language": "typescript"
        }
      ],
      "complexity": 5,
      "tags": [
        "React",
        "Components",
        "Forms",
        "Dynamic Forms",
        "JSX",
        "Conditional Rendering"
      ],
      "prerequisites": [
        "react_functional_components",
        "react_props",
        "javascript_events",
        "html_form_elements"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Components",
      "Forms",
      "Dynamic Forms",
      "JSX",
      "Conditional Rendering"
    ],
    "prerequisites": [
      "react_functional_components",
      "react_props",
      "javascript_events",
      "html_form_elements"
    ]
  },
  {
    "index": 31,
    "id": "theory_render_props",
    "type": "theory",
    "moduleId": "react",
    "complexity": 6,
    "title": "Render Props Pattern in React",
    "description": "",
    "content": {
      "id": "theory_render_props",
      "title": "Render Props Pattern in React",
      "description": "",
      "type": "theory",
      "content": "The Render Props pattern in React refers to a technique where a component's `props` include a function that returns a React element. This function allows the component to share code (behavior or state) with other components without explicitly rendering anything itself. Instead, it delegates the rendering responsibility to the consumer component by calling the provided render prop with its internal state or logic.\n\nThis pattern is particularly useful for sharing non-visual logic, such as data fetching, mouse tracking, or form state management, across multiple components in a reusable manner. The core idea is that the 'render prop' (often named `render` or `children`) is a function that the component calls to determine what to render, passing along whatever data or state it needs to share.\n\n## Key Concepts\n*   **Render Prop**: A prop whose value is a function that a component calls to render something. It typically receives the component's internal state or computed values as arguments.\n*   **`children` as a Function**: A common variation where the `children` prop itself is used as the render prop. This leverages the special `children` prop, which can be any valid React node, including a function.\n*   **Sharing Behavior**: The component implementing the render prop pattern encapsulates specific behavior (e.g., mouse position tracking, data loading) and exposes it via the render function, allowing other components to consume this behavior and render their UI based on it.\n\n## Benefits of Render Props\n1.  **Composition**: Facilitates easy composition of behaviors without modifying existing components. You can wrap components with different render prop components to add new functionalities.\n2.  **Reusability**: Shared functionality (like stateful logic) can be used by multiple disparate components across your application, promoting a DRY (Don't Repeat Yourself) principle.\n3.  **Separation of Concerns**: Clearly separates the logic (what to do) from the UI (what to render). The component with the render prop handles the logic, while the consumer handles the rendering.\n4.  **Flexible Rendering**: Consumers decide exactly what gets rendered based on the data provided by the render prop component. This offers unparalleled flexibility compared to fixed UI components.\n5.  **No HOC Wrapper Hell**: Avoids the issue of deeply nested Higher-Order Components (HOCs) that can make debugging and understanding the component tree difficult (often referred to as 'wrapper hell' or 'pyramid of doom'). Render props typically result in a flatter component tree.\n\n## When to Use Render Props\n*   When you need to share non-visual behavior or state between components (e.g., mouse position, network status, authentication state).\n*   When you want to avoid duplicate code across components that need the same logic.\n*   When you need more flexibility in rendering the UI than a Higher-Order Component might provide, as the render prop offers direct control over the JSX output.\n\n## Relationship with Hooks\nWhile Hooks (introduced in React 16.8) have become the primary way to reuse stateful logic and reduce boilerplate, Render Props remain a valid and sometimes preferred pattern for specific scenarios, especially in older codebases or when working with libraries that still heavily rely on them. Hooks often provide a more concise and readable way to achieve similar results by extracting logic into custom hooks, but Render Props offer explicit JSX-level composition.",
      "examples": [
        {
          "id": "example_render_props_1",
          "title": "Mouse Tracking with Render Prop (named prop)",
          "code": "import React from 'react';\n\nclass MouseTracker extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { x: 0, y: 0 };\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n  }\n\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n\n  render() {\n    // The `render` prop is a function that receives the state\n    return (\n      <div style={{ height: '100vh', border: '1px solid black' }} onMouseMove={this.handleMouseMove}>\n        {this.props.render(this.state)}\n      </div>\n    );\n  }\n}\n\n// Usage of MouseTracker with a named `render` prop\nfunction App() {\n  return (\n    <div>\n      <h1>Move the mouse around!</h1>\n      <MouseTracker\n        render={({ x, y }) => (\n          <p>Current mouse position: ({x}, {y})</p>\n        )}\n      />\n    </div>\n  );\n}",
          "explanation": "This example demonstrates the `MouseTracker` component using a named `render` prop. The `MouseTracker` component manages the mouse position state (`x`, `y`) internally. Instead of rendering a fixed UI, it calls `this.props.render(this.state)`, passing its current mouse coordinates to the function provided by its parent. The `App` component then defines how to render the mouse position using an arrow function passed to the `render` prop, making the `MouseTracker` reusable for displaying the mouse position in various ways.",
          "language": "javascript"
        },
        {
          "id": "example_render_props_2",
          "title": "Mouse Tracking with Render Prop (children as function)",
          "code": "import React from 'react';\n\nclass MouseTracker extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { x: 0, y: 0 };\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n  }\n  \n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n  \n  render() {\n    return (\n      <div style={{ height: '100vh', border: '1px solid blue' }} onMouseMove={this.handleMouseMove}>\n        {/* Using children as a function instead of a custom named prop */}\n        {this.props.children(this.state)}\n      </div>\n    );\n  }\n}\n\n// Usage of MouseTracker with children as a function\nfunction App() {\n  return (\n    <div>\n      <h1>Move the mouse around (children prop)!</h1>\n      <MouseTracker>\n        {({ x, y }) => (\n          <p>Current position: ({x}, {y})</p>\n        )}\n      </MouseTracker>\n    </div>\n  );\n}",
          "explanation": "This example shows the `MouseTracker` component using the `children` prop as a function, which is a common and idiomatic way to implement the Render Props pattern. The `MouseTracker` still manages the state, but instead of calling `this.props.render`, it calls `this.props.children(this.state)`. The consumer component then places the rendering logic directly inside the `MouseTracker`'s JSX tags, defining a function that receives the mouse coordinates. This approach often leads to cleaner and more readable JSX, especially when the render logic is simple.",
          "language": "javascript"
        }
      ],
      "complexity": 6,
      "tags": [
        "React",
        "Design Patterns",
        "Render Props",
        "Composition",
        "Reusability",
        "State Management"
      ],
      "prerequisites": [
        "React_Components",
        "React_State_and_Props",
        "Functional_Programming_Concepts"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Design Patterns",
      "Render Props",
      "Composition",
      "Reusability",
      "State Management"
    ],
    "prerequisites": [
      "React_Components",
      "React_State_and_Props",
      "Functional_Programming_Concepts"
    ]
  },
  {
    "index": 35,
    "id": "theory_immutable_state_updates",
    "type": "theory",
    "moduleId": "react",
    "complexity": 6,
    "title": "Immutable State Updates for Objects and Nested Objects in React",
    "description": "",
    "content": {
      "id": "theory_immutable_state_updates",
      "title": "Immutable State Updates for Objects and Nested Objects in React",
      "description": "",
      "type": "theory",
      "content": "In React, direct modification of state can lead to unexpected behavior and make debugging difficult. React relies on state immutability to optimize re-renders and ensure predictable data flow. When updating state that contains objects or arrays, you should always create a *new* object or array rather than mutating the existing one. The spread syntax (`...`) is a powerful tool for achieving this.\n\n## Updating Top-Level Object Properties\nWhen a state variable is an object, and you need to update one of its properties, you should spread the existing state object into a new object, and then override the specific property you want to change. This creates a new object with the desired update, preserving the other properties.\n\n## Updating Nested Object Properties\nFor nested objects, the principle remains the same: immutability at every level. You need to create a new object for each level of nesting that you are modifying. This often involves multiple spread operations, working from the outermost object inwards to the property being updated.",
      "examples": [
        {
          "id": "example_immutable_state_1",
          "title": "Updating a Top-Level Object Property",
          "code": "import React, { useState } from 'react';\n\nfunction UserProfileEditor() {\n  const [user, setUser] = useState({\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com'\n  });\n\n  const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    // Create a new user object, spreading the old properties\n    // and overriding 'name'\n    setUser({\n      ...user,\n      name: event.target.value\n    });\n  };\n\n  return (\n    <div>\n      <label>Name:</label>\n      <input type=\"text\" value={user.name} onChange={handleNameChange} />\n      <p>Current Name: {user.name}</p>\n      <p>Age: {user.age}</p>\n    </div>\n  );\n}",
          "explanation": "This example demonstrates how to immutably update the `name` property of the `user` state object. `...user` copies all existing properties, and `name: event.target.value` then overwrites the `name` property in the new object. This ensures other properties like `age` and `email` remain unchanged without direct mutation.",
          "language": "typescript"
        },
        {
          "id": "example_immutable_state_2",
          "title": "Updating a Nested Object Property",
          "code": "import React, { useState } from 'react';\n\nfunction UserPreferencesEditor() {\n  const [user, setUser] = useState({\n    name: 'Bob',\n    preferences: {\n      newsletter: false,\n      notifications: true\n    }\n  });\n\n  const toggleNewsletter = () => {\n    // To update 'newsletter', we need to create new objects for:\n    // 1. the 'preferences' object\n    // 2. the top-level 'user' object\n    setUser({\n      ...user, // Copy existing user properties\n      preferences: {\n        ...user.preferences, // Copy existing preferences properties\n        newsletter: !user.preferences.newsletter // Override newsletter\n      }\n    });\n  };\n\n  return (\n    <div>\n      <p>Newsletter Subscription: {user.preferences.newsletter ? 'Subscribed' : 'Not Subscribed'}</p>\n      <button onClick={toggleNewsletter}>Toggle Newsletter</button>\n    </div>\n  );\n}",
          "explanation": "This example shows how to update a nested property (`newsletter`) within the `preferences` object. Notice the nested spread operations: `...user.preferences` creates a new `preferences` object, and then `...user` creates a new `user` object containing the newly created `preferences` object. This ensures immutability at all levels.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "React",
        "State Management",
        "Immutability",
        "JavaScript",
        "ES6"
      ],
      "prerequisites": [
        "JavaScript_Objects",
        "JavaScript_Spread_Syntax",
        "React_useState"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "State Management",
      "Immutability",
      "JavaScript",
      "ES6"
    ],
    "prerequisites": [
      "JavaScript_Objects",
      "JavaScript_Spread_Syntax",
      "React_useState"
    ]
  },
  {
    "index": 38,
    "id": "theory_lifting_state_up",
    "type": "theory",
    "moduleId": "react",
    "complexity": 6,
    "title": "Lifting State Up for Shared Data",
    "description": "",
    "content": {
      "id": "theory_lifting_state_up",
      "title": "Lifting State Up for Shared Data",
      "description": "",
      "type": "theory",
      "content": "When multiple components in a React application need to share and react to the same piece of state, it is a recommended practice to \"lift\" that shared state up to their closest common ancestor component. This pattern is fundamental for maintaining data consistency and simplifying state management in complex component trees.\n\n## Core Concept\n\n**Single Source of Truth:** By lifting state, you establish a single, authoritative source for that data. Instead of each child component managing its own copy of potentially conflicting state, the parent component becomes the owner of the shared state. This ensures that all components that depend on this state are always in sync.\n\n**Data Flow:** The data flows downwards from the parent (owner) component to its children via props. If a child component needs to update this shared state, it doesn't modify the state directly. Instead, the parent passes down a callback function (also via props) that the child can invoke to request a state update. The parent then executes its state update logic, which in turn causes a re-render of itself and its children, passing down the new state.\n\n## Benefits of Lifting State Up\n\n-   **Maintains a single source of truth:** Eliminates duplication and ensures data consistency.\n-   **Easier synchronization:** All related components automatically receive updates from the central state, making it simpler to keep them in sync.\n-   **Reduces bugs:** By centralizing state logic, you minimize the chances of inconsistent data and related bugs.\n-   **Simpler debugging:** State changes are centralized in one component, making it easier to trace data flow and identify the source of issues.\n-   **Improved maintainability:** The explicit data flow (props down, events up) makes the application's behavior more predictable and easier to understand.\n\n## Implementation Steps\n\n1.  **Identify Shared State:** Determine which piece of state is needed by multiple sibling components.\n2.  **Find Common Ancestor:** Locate the closest parent component that renders all components needing access to this state.\n3.  **Move State to Ancestor:** Declare the `useState` hook for the shared state in the common ancestor component.\n4.  **Pass State Down:** Pass the state value from the ancestor to its children as props.\n5.  **Pass Update Callbacks Down:** Pass a function from the ancestor (which updates the shared state) down to children as props. Children will call this function when they need to request a state change.\n6.  **Handle Updates in Parent:** The parent component's update function will receive the new data, update its state, and trigger re-renders.\n\nThis pattern encourages a unidirectional data flow, which is a core principle in React, leading to more predictable and manageable applications.",
      "examples": [
        {
          "id": "example_lifting_state_up_1",
          "title": "Temperature Converter Example",
          "code": "import React, { useState } from 'react';\n\n// Parent component holds the shared state\nfunction TemperatureCalculator() {\n  const [temperature, setTemperature] = useState('');\n  const [scale, setScale] = useState('c');\n  \n  // Conversion functions\n  const toCelsius = (fahrenheit) => {\n    if (isNaN(parseFloat(fahrenheit))) return '';\n    return ((parseFloat(fahrenheit) - 32) * 5 / 9).toFixed(2);\n  };\n  const toFahrenheit = (celsius) => {\n    if (isNaN(parseFloat(celsius))) return '';\n    return ((parseFloat(celsius) * 9 / 5) + 32).toFixed(2);\n  };\n  \n  // Handle temperature change from Celsius input\n  const handleCelsiusChange = (value) => {\n    setTemperature(value);\n    setScale('c');\n  };\n  \n  // Handle temperature change from Fahrenheit input\n  const handleFahrenheitChange = (value) => {\n    setTemperature(value);\n    setScale('f');\n  };\n  \n  // Calculate both temperatures based on current scale\n  const celsius = scale === 'f' ? toCelsius(temperature) : temperature;\n  const fahrenheit = scale === 'c' ? toFahrenheit(temperature) : temperature;\n  \n  return (\n    <div>\n      <h2>Temperature Converter</h2>\n      <TemperatureInput \n        scale=\"c\" \n        temperature={celsius}\n        onTemperatureChange={handleCelsiusChange} \n      />\n      <TemperatureInput \n        scale=\"f\" \n        temperature={fahrenheit}\n        onTemperatureChange={handleFahrenheitChange} \n      />\n      <BoilingVerdict celsius={parseFloat(celsius)} />\n    </div>\n  );\n}\n\n// Child component receives props from parent\nfunction TemperatureInput({ scale, temperature, onTemperatureChange }) {\n  const scaleNames = {\n    c: 'Celsius',\n    f: 'Fahrenheit'\n  };\n  \n  const handleChange = (e) => {\n    onTemperatureChange(e.target.value);\n  };\n  \n  return (\n    <fieldset>\n      <legend>Enter temperature in {scaleNames[scale]}:</legend>\n      <input \n        value={temperature}\n        onChange={handleChange} \n      />\n    </fieldset>\n  );\n}\n\n// Another component that uses the same state\nfunction BoilingVerdict({ celsius }) {\n  if (isNaN(celsius)) {\n    return <p>Enter a number to see boiling verdict.</p>;\n  }\n  return celsius >= 100 ?\n    <p style={{ color: 'green' }}>The water would boil.</p> :\n    <p style={{ color: 'blue' }}>The water would not boil.</p>;\n}\n\n// To render:\n// ReactDOM.render(<TemperatureCalculator />, document.getElementById('root'));",
          "explanation": "This example demonstrates how state (`temperature` and `scale`) is lifted up to the `TemperatureCalculator` component. Both `TemperatureInput` components receive the current `temperature` and `onTemperatureChange` callback from `TemperatureCalculator`. When a user types in either input, the `handleChange` function in `TemperatureInput` calls `onTemperatureChange` (which is `handleCelsiusChange` or `handleFahrenheitChange` from the parent). The parent then updates its state, re-calculates both Celsius and Fahrenheit values, and re-renders, ensuring both inputs and the `BoilingVerdict` component are always synchronized based on the single source of truth in `TemperatureCalculator`.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "React",
        "State Management",
        "Component Communication",
        "Unidirectional Data Flow",
        "Best Practices"
      ],
      "prerequisites": [
        "react_functional_components",
        "react_state_hook",
        "react_props"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "State Management",
      "Component Communication",
      "Unidirectional Data Flow",
      "Best Practices"
    ],
    "prerequisites": [
      "react_functional_components",
      "react_state_hook",
      "react_props"
    ]
  },
  {
    "index": 46,
    "id": "theory_react_update_lifecycle_overview",
    "type": "theory",
    "moduleId": "react",
    "complexity": 6,
    "title": "React Component Lifecycle: Updating Phase Overview",
    "description": "",
    "content": {
      "id": "theory_react_update_lifecycle_overview",
      "title": "React Component Lifecycle: Updating Phase Overview",
      "description": "",
      "type": "theory",
      "content": "The updating phase of a React component's lifecycle begins when a component receives new props or state. This phase is crucial for ensuring that the UI reflects the latest data. The methods in this phase allow developers to react to changes, optimize performance, and manage side effects.\n\n### Triggers for Update Phase:\n- **New props**: Parent component re-renders and passes new props to the child.\n- **`setState()`**: The component's internal state changes via `this.setState()`.\n- **`forceUpdate()`**: Explicitly forces a re-render of the component.\n\nThe methods are called in a specific order, enabling a predictable flow of operations from prop/state changes to DOM updates and subsequent side effects.\n\n**Sequence of methods in the Updating Phase:**\n1.  `static getDerivedStateFromProps(props, state)`\n2.  `shouldComponentUpdate(nextProps, nextState)`\n3.  `render()`\n4.  `getSnapshotBeforeUpdate(prevProps, prevState)`\n5.  `componentDidUpdate(prevProps, prevState, snapshot)`",
      "examples": [
        {
          "id": "example_react_update_lifecycle_overview_1",
          "title": "Basic Component Update Flow",
          "code": "import React from 'react';\n\nclass UpdatingComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    console.log('1. Constructor (update)');\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    console.log('2. static getDerivedStateFromProps');\n    // Returning null means no state update from props\n    return null;\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('3. shouldComponentUpdate');\n    // By default, returns true. For demonstration, let's always re-render.\n    return true;\n  }\n\n  render() {\n    console.log('4. render (update)');\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>Increment</button>\n      </div>\n    );\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('5. getSnapshotBeforeUpdate');\n    // This method returns a snapshot that will be passed to componentDidUpdate\n    return { prevCount: prevState.count };\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('6. componentDidUpdate');\n    console.log('Snapshot from getSnapshotBeforeUpdate:', snapshot);\n    if (this.state.count !== prevState.count) {\n      console.log(`Count changed from ${prevState.count} to ${this.state.count}`);\n    }\n  }\n\n  componentWillUnmount() {\n    console.log('7. componentWillUnmount');\n  }\n}\n\n// To see update in action, you'd render this component and interact with its button\n// or update its props from a parent component.\n\n/*\nExpected console output when button is clicked:\n2. static getDerivedStateFromProps\n3. shouldComponentUpdate\n4. render (update)\n5. getSnapshotBeforeUpdate\n6. componentDidUpdate\nCount changed from X to Y\n*/\n",
          "explanation": "This example demonstrates the typical flow of methods during the update phase when the component's state changes. Console logs illustrate the order of execution. Note that the constructor is only called during the initial mount, not subsequent updates.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "React",
        "Lifecycle",
        "Updating Phase",
        "Component",
        "Class Component"
      ],
      "prerequisites": [
        "react_basics",
        "class_components",
        "state_props"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Lifecycle",
      "Updating Phase",
      "Component",
      "Class Component"
    ],
    "prerequisites": [
      "react_basics",
      "class_components",
      "state_props"
    ]
  },
  {
    "index": 58,
    "id": "theory_debouncing_and_useeffect",
    "type": "theory",
    "moduleId": "react",
    "complexity": 6,
    "title": "React `useEffect` for Side Effects and Debouncing",
    "description": "",
    "content": {
      "id": "theory_debouncing_and_useeffect",
      "title": "React `useEffect` for Side Effects and Debouncing",
      "description": "",
      "type": "theory",
      "content": "## Understanding `useEffect` Hook\n\nThe `useEffect` hook in React allows you to perform side effects in functional components. Side effects are operations that interact with the outside world or affect things outside the React component tree, such as data fetching, subscriptions, or manually changing the DOM. `useEffect` runs after every render, but you can control when it runs using its dependency array.\n\n### `useEffect` Signature\n\n```typescript\nuseEffect(() => {\n  // Side effect logic\n  return () => {\n    // Cleanup function (optional)\n  };\n}, [dependencies]); // Dependency array (optional)\n```\n\n-   **Callback Function**: Contains the side effect logic. This function runs after every render where the dependencies have changed.\n-   **Cleanup Function (Return Value)**: An optional function returned by the callback. This function runs before the component unmounts and before the effect runs again (if dependencies change). It's crucial for cleaning up resources to prevent memory leaks (e.g., clearing timers, unsubscribing).\n-   **Dependency Array**: An optional array of values. The effect will only re-run if one of the values in this array changes between renders. If omitted, the effect runs after every render. An empty array `[]` means the effect runs only once after the initial render (and cleanup runs on unmount).\n\n### Debouncing with `useEffect`\n\nDebouncing is a technique used to limit the rate at which a function is called. When applied to an input field, it ensures that a function (e.g., an API call for search results) is not executed until a certain amount of time has passed since the user stopped typing. This is crucial for performance and reducing unnecessary network requests.\n\n`useEffect` is ideal for implementing debouncing because it allows you to:\n1.  **Trigger on Change**: Re-run the effect whenever the input value changes.\n2.  **Delay Execution**: Use `setTimeout` to delay the execution of the actual search logic.\n3.  **Cancel Previous Execution**: Use `clearTimeout` in the cleanup function to cancel any pending delayed executions from previous input changes. This ensures that the search function only runs *after* the user has stopped typing for the specified delay.\n\n**Typical Debouncing Flow:**\n1.  User types a character in the input.\n2.  `searchTerm` state updates.\n3.  `useEffect` detects `searchTerm` change.\n4.  The cleanup function from the *previous* `useEffect` run (if any) clears the old timer.\n5.  A new `setTimeout` is set for the `debouncedSearchTerm` update.\n6.  If the user types again before the timeout, steps 3-5 repeat, resetting the timer.\n7.  If the user stops typing, the timeout eventually completes, updating `debouncedSearchTerm`.\n8.  The `useEffect` watching `debouncedSearchTerm` then triggers the actual search API call.",
      "examples": [
        {
          "id": "example_useeffect_basic",
          "title": "Basic `useEffect` for Logging",
          "code": "import React, { useState, useEffect } from 'react';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Component rendered or count changed:', count);\n    // This runs after every render where 'count' has changed.\n\n    return () => {\n      console.log('Cleanup for count:', count);\n      // This runs before the next effect or on unmount.\n    };\n  }, [count]); // Dependency array\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
          "explanation": "This example demonstrates a basic `useEffect` hook. It logs a message whenever the component renders or the `count` state changes. The cleanup function logs before the effect re-runs or when the component unmounts, showing how resources can be managed.",
          "language": "typescript"
        },
        {
          "id": "example_useeffect_debouncing",
          "title": "Debouncing Search Input with `useEffect`",
          "code": "import React, { useState, useEffect } from 'react';\n\n// Simulate an API call\nconst fetchSearchResults = async (query: string) => {\n  console.log(`Fetching results for: \"${query}\"...`);\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve([{ id: 1, name: `Result for ${query}` }]);\n    }, 500);\n  });\n};\n\nfunction SearchBar() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState('');\n  const [results, setResults] = useState<{ id: number; name: string }[]>([]);\n\n  // Effect to debounce searchTerm\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedSearchTerm(searchTerm);\n    }, 500); // 500ms debounce delay\n\n    // Cleanup function: clear timeout if searchTerm changes before delay\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [searchTerm]); // Re-run effect whenever searchTerm changes\n\n  // Effect to fetch results when debouncedSearchTerm changes\n  useEffect(() => {\n    if (debouncedSearchTerm) {\n      fetchSearchResults(debouncedSearchTerm).then(results => {\n        setResults(results);\n      });\n    } else {\n      setResults([]);\n    }\n  }, [debouncedSearchTerm]); // Re-run effect whenever debouncedSearchTerm changes\n\n  return (\n    <div>\n      <input\n        value={searchTerm}\n        onChange={e => setSearchTerm(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      <ul>\n        {results.map(result => (\n          <li key={result.id}>{result.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
          "explanation": "This example showcases a common pattern for debouncing user input using two `useEffect` hooks. The first `useEffect` manages the `searchTerm` and updates `debouncedSearchTerm` after a delay, ensuring that rapid typing doesn't trigger intermediate updates. Its cleanup function `clearTimeout(handler)` is critical to cancel pending debounces. The second `useEffect` then watches the `debouncedSearchTerm` and triggers the actual (simulated) API call only when the debounced value changes, significantly reducing unnecessary network requests.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "React",
        "useEffect",
        "Hooks",
        "Debouncing",
        "Performance",
        "Side Effects",
        "Frontend Optimization",
        "Cleanup Function"
      ],
      "prerequisites": [
        "react_functional_components",
        "react_state_management"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "useEffect",
      "Hooks",
      "Debouncing",
      "Performance",
      "Side Effects",
      "Frontend Optimization",
      "Cleanup Function"
    ],
    "prerequisites": [
      "react_functional_components",
      "react_state_management"
    ]
  },
  {
    "index": 75,
    "id": "theory_use_reducer_basics",
    "type": "theory",
    "moduleId": "react",
    "complexity": 6,
    "title": "React useReducer Hook: Core Concepts and Usage",
    "description": "",
    "content": {
      "id": "theory_use_reducer_basics",
      "title": "React useReducer Hook: Core Concepts and Usage",
      "description": "",
      "type": "theory",
      "content": "The `useReducer` hook in React is an alternative to `useState` for managing state, particularly when state logic is complex or when the next state depends on the previous one. It's especially useful for managing state that involves multiple sub-values or when the next state depends on the previous one, similar to how Redux works.\n\n## Key Concepts\n- **Reducer Function**: A pure function that takes the current `state` and an `action` as arguments and returns the new `state`. It must not modify the original state directly but instead return a new state object or value.\n- **Action**: A plain JavaScript object that describes 'what happened'. It typically has a `type` property (a string) and an optional `payload` property which contains any data needed to update the state.\n- **Dispatch Function**: The function returned by `useReducer` that you call to dispatch an `action`. When `dispatch` is called, React will re-render the component and pass the current `state` and the `action` to the reducer function to calculate the new state.\n- **Initial State**: The initial value of the state. It can be a direct value or derived from a function (lazy initialization) for performance optimization if the initial state is expensive to compute.\n\n## When to Use useReducer?\n`useReducer` is preferable over `useState` in the following scenarios:\n1.  **Complex State Logic**: When state transitions are non-trivial or involve multiple steps.\n2.  **Multiple State Updates**: When many state updates happen over time, and these updates depend on the previous state.\n3.  **Global State Management**: When combined with React's Context API to manage global application state, providing a Redux-like pattern without external libraries.\n4.  **Performance Optimization**: When passing `dispatch` down deeply nested components, it's more stable than passing `setState` from `useState` as `dispatch` reference is guaranteed to be stable (it doesn't change on re-renders, unlike `setState` when passed through Context).\n\n## Syntax\n```typescript\nconst [state, dispatch] = useReducer(reducer, initialArg, init?);\n```\n- `reducer`: Your reducer function `(state, action) => newState`.\n- `initialArg`: The initial value for the state.\n- `init?`: An optional 'initializer' function `(initialArg) => initialState` which computes the initial state lazily. If present, `initialArg` is passed to it, and its return value becomes the initial state. This is useful for expensive initial state computations.\n\n## How it Works\n1.  You define a `reducer` function that describes how the state changes in response to different actions.\n2.  You call `useReducer` with your `reducer` function and an `initialState`. It returns the current state and a `dispatch` function.\n3.  In your component, you call `dispatch` with an `action` object (e.g., `{ type: 'increment' }`) when an event occurs.\n4.  React passes the current state and the action to your `reducer` function.\n5.  The `reducer` returns the new state.\n6.  React updates the component's state with the new value and re-renders the component.",
      "examples": [
        {
          "id": "example_use_reducer_basic_counter",
          "title": "Basic Counter with useReducer",
          "code": "import React, { useReducer } from 'react';\n\n// Reducer function: defines how state changes based on actions\nfunction counterReducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    case 'reset':\n      return { count: 0 }; // Example of another action type\n    default:\n      throw new Error(`Unknown action type: ${action.type}`);\n  }\n}\n\nfunction Counter() {\n  // Initialize state with useReducer: [current_state, dispatch_function]\n  // The second argument is the initial state: { count: 0 }\n  const [state, dispatch] = useReducer(counterReducer, { count: 0 });\n  \n  return (\n    <div>\n      <h2>Count: {state.count}</h2>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>\n    </div>\n  );\n}\n\nexport default Counter;\n",
          "explanation": "This example demonstrates a simple counter using `useReducer`. The `counterReducer` function specifies how the `count` state changes for 'increment' and 'decrement' actions. The `Counter` component initializes the state to `{ count: 0 }` and uses the `dispatch` function to send actions when buttons are clicked. Notice how the state is an object `{ count: 0 }`, allowing for more complex state structures later.",
          "language": "typescript"
        },
        {
          "id": "example_use_reducer_lazy_initialization",
          "title": "Lazy Initialization with useReducer",
          "code": "import React, { useReducer } from 'react';\n\n// Reducer function (same as before)\nfunction counterReducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    default:\n      throw new Error();\n  }\n}\n\n// Initializer function: computes the initial state lazily\n// It receives the initialArg (passed as the second argument to useReducer)\n// and returns the actual initial state.\nfunction init(initialCount) {\n  console.log('Initializing state lazily...');\n  return { count: initialCount };\n}\n\nfunction LazyCounter({ initialCount = 0 }) {\n  // Using the initializer function as the third argument\n  const [state, dispatch] = useReducer(counterReducer, initialCount, init);\n  \n  return (\n    <div>\n      <h2>Lazy Initialized Count: {state.count}</h2>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n    </div>\n  );\n}\n\nexport default LazyCounter;\n",
          "explanation": "This example shows `useReducer` with lazy initialization. The `init` function is passed as the third argument to `useReducer`. This function is called only once during the initial render to compute the initial state. This is beneficial if the initial state computation is expensive, as it avoids re-running the computation on every re-render, unlike simply passing a function to `useState`.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "React Hooks",
        "State Management",
        "useReducer",
        "Functional Components",
        "Reducer Pattern"
      ],
      "prerequisites": [
        "react_functional_components",
        "react_state_management",
        "javascript_functions",
        "javascript_objects"
      ],
      "technology": "React"
    },
    "tags": [
      "React Hooks",
      "State Management",
      "useReducer",
      "Functional Components",
      "Reducer Pattern"
    ],
    "prerequisites": [
      "react_functional_components",
      "react_state_management",
      "javascript_functions",
      "javascript_objects"
    ]
  },
  {
    "index": 85,
    "id": "theory_react_animations_overview",
    "type": "theory",
    "moduleId": "react",
    "complexity": 6,
    "title": "Animations in React: A Comprehensive Overview",
    "description": "",
    "content": {
      "id": "theory_react_animations_overview",
      "title": "Animations in React: A Comprehensive Overview",
      "description": "",
      "type": "theory",
      "content": "Animations in React enhance user experience by providing visual feedback, guiding user attention, and making interfaces feel more dynamic and engaging. While React itself doesn't offer built-in animation utilities beyond basic CSS transitions, a rich ecosystem of third-party libraries has emerged to simplify complex animations.\n\nThese libraries typically abstract away the intricacies of CSS transitions, keyframe animations, or direct DOM manipulation, allowing developers to define animations declaratively within their React components. They often manage component lifecycle events, interpolate values, and apply styles based on state changes, making it easier to create smooth and performant animations.\n\n### Key Concepts in React Animations\n\n*   **Declarative API:** Most React animation libraries embrace a declarative approach, allowing you to describe *what* you want to animate rather than *how* to animate it. This aligns well with React's component-based paradigm.\n*   **State-Driven Animations:** Animations are often triggered by changes in component state or props, making them reactive and dynamic.\n*   **Performance:** Libraries often optimize for performance by using techniques like `requestAnimationFrame` for smooth rendering, avoiding unnecessary re-renders, and often leveraging CSS transforms and opacity for hardware acceleration.\n*   **Interpolation:** The process of calculating intermediate values between two points (e.g., start and end positions, colors, opacities) to create a smooth transition.\n*   **Physics-Based vs. Duration-Based:**\n    *   **Duration-Based:** Animations are defined with a fixed duration (e.g., `transition: all 0.3s ease-in-out;`). This is common with CSS transitions and libraries like `React Transition Group` (when combined with CSS).\n    *   **Physics-Based:** Animations are defined by physical properties like mass, tension, and friction. They feel more natural and responsive, adapting automatically to changes without explicit durations. `React Motion` and `React Spring` are prime examples.\n\n### Challenges in React Animations\n\n*   **Component Mounting/Unmounting:** Animating components as they enter or exit the DOM requires careful management of their lifecycle, which libraries like `React Transition Group` specialize in.\n*   **Interactivity:** Handling complex gestures (drag, hover, tap) and linking them to animations can be challenging without dedicated support.\n*   **Performance Optimization:** Ensuring animations run smoothly at 60 FPS, especially on less powerful devices, requires careful consideration of how styles are applied (preferring transforms and opacity).\n*   **Orchestration:** Coordinating multiple animations or creating sequences can become complex without proper tools.",
      "examples": [],
      "complexity": 6,
      "tags": [
        "React",
        "Animations",
        "Frontend",
        "UI/UX",
        "Performance"
      ],
      "prerequisites": [
        "react_basics",
        "css_fundamentals"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Animations",
      "Frontend",
      "UI/UX",
      "Performance"
    ],
    "prerequisites": [
      "react_basics",
      "css_fundamentals"
    ]
  },
  {
    "index": 99,
    "id": "theory_react_class_components",
    "type": "theory",
    "moduleId": "react",
    "complexity": 6,
    "title": "React Class Components: State, Props, and Controlled Components",
    "description": "",
    "content": {
      "id": "theory_react_class_components",
      "title": "React Class Components: State, Props, and Controlled Components",
      "description": "",
      "type": "theory",
      "content": "React class components are a fundamental building block in older React applications, though functional components with hooks are now more common. They are JavaScript classes that extend `React.Component` and encapsulate their own state and lifecycle methods.\n\n## Core Concepts\n-   **`React.Component`**: The base class for all class components. Components inherit methods like `setState`, `render`, and various lifecycle methods.\n-   **`constructor(props)`**: The constructor is called before the component is mounted. It's the place to initialize local `state` and bind event handler methods. You must call `super(props)` inside the constructor.\n-   **`this.state`**: An object that holds local component state. State is private and mutable, but should only be updated using `setState`.\n-   **`setState(updater, callback)`**: The primary way to update component state. It asynchronously merges the `updater` (an object or a function) into `this.state` and re-renders the component. The `callback` is optional and executes after the state update is complete and the component has re-rendered.\n-   **`this.props`**: An object containing the properties passed down from a parent component. Props are immutable and read-only within the component that receives them.\n-   **`render()`**: A required method in class components that returns the JSX (React elements) to be rendered. It should be a pure function, meaning it doesn't modify component state or interact with the browser directly.\n\n## Controlled Components\nInput elements (like `<input>`, `<textarea>`, `<select>`) in React forms typically manage their own state. This is known as a \"controlled component.\" The input's value is controlled by React state, and changes are handled via an `onChange` event handler, which updates the state.\n\n### Form Handling\n-   **`onSubmit`**: An event handler attached to the `<form>` element. It's crucial to call `event.preventDefault()` inside this handler to stop the browser's default form submission behavior (which would cause a full page reload).\n-   **`trim()`**: A string method often used to remove whitespace from both ends of a string, useful for validating user input.\n\nIn `PhoneForm.jsx`, we see a classic example of a controlled component:\n```jsx\n// PhoneForm.jsx\nimport React from 'react';\n\nclass PhoneForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { phoneInput: '' };\n  }\n  \n  handleSubmit = (e) => { // Using class field for auto-binding 'this'\n    e.preventDefault();\n    if (this.state.phoneInput.trim()) {\n      this.props.addPhone(this.state.phoneInput);\n      this.setState({ phoneInput: '' }); // Clear input\n    }\n  }\n  \n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <input \n          type=\"text\" \n          value={this.state.phoneInput}\n          onChange={e => this.setState({ phoneInput: e.target.value })} // Controlled input\n          placeholder=\"Enter phone model\"\n        />\n        <button type=\"submit\">Add Phone</button>\n      </form>\n    );\n  }\n}\n```",
      "examples": [
        {
          "id": "example_class_component_state_1",
          "title": "Basic Class Component with State",
          "code": "import React from 'react';\n\nclass Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  increment = () => {\n    this.setState(prevState => ({ \n      count: prevState.count + 1 \n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n// ReactDOM.render(<Counter />, document.getElementById('root'));",
          "explanation": "This example demonstrates a simple `Counter` class component. The `count` is stored in `this.state`. The `increment` method uses `setState` with a functional updater to safely update the count, ensuring the update is based on the most recent state. The `render` method displays the current count and a button to trigger the update.",
          "language": "jsx"
        },
        {
          "id": "example_class_component_props_2",
          "title": "Passing and Receiving Props",
          "code": "import React from 'react';\n\nclass WelcomeMessage extends React.Component {\n  render() {\n    return (\n      <p>Hello, {this.props.name}!</p>\n    );\n  }\n}\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div>\n        <WelcomeMessage name=\"Alice\" />\n        <WelcomeMessage name=\"Bob\" />\n      </div>\n    );\n  }\n}\n// ReactDOM.render(<App />, document.getElementById('root'));",
          "explanation": "This example shows how props are passed from a parent `App` component to child `WelcomeMessage` components. The `name` prop is accessed within `WelcomeMessage` via `this.props.name`. Props are read-only and allow components to communicate data downwards in the component tree.",
          "language": "jsx"
        }
      ],
      "complexity": 6,
      "tags": [
        "React",
        "Class Components",
        "State Management",
        "Props",
        "Controlled Components",
        "Forms"
      ],
      "prerequisites": [
        "javascript_es6_classes",
        "javascript_arrow_functions"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Class Components",
      "State Management",
      "Props",
      "Controlled Components",
      "Forms"
    ],
    "prerequisites": [
      "javascript_es6_classes",
      "javascript_arrow_functions"
    ]
  },
  {
    "index": 122,
    "id": "theory_react_code_splitting",
    "type": "theory",
    "moduleId": "react",
    "complexity": 6,
    "title": "React Code Splitting with React.lazy and Suspense",
    "description": "",
    "content": {
      "id": "theory_react_code_splitting",
      "title": "React Code Splitting with React.lazy and Suspense",
      "description": "",
      "type": "theory",
      "content": "Code splitting is a technique that helps to reduce the bundle size of a web application, leading to faster initial page loads. Instead of loading all the JavaScript code at once, code splitting allows you to split your code into smaller 'chunks' that can be loaded on demand. This is particularly useful for large applications with many routes or features that might not be used immediately.\n\nReact provides built-in tools for code splitting: `React.lazy` and `Suspense`. \n\n## Key Concepts\n-   **React.lazy**: This function lets you render a dynamic import as a regular component. It automatically loads the bundle containing the `About` component when it's rendered for the first time. The `import()` syntax is a dynamic import, which means the module will be loaded on demand.\n-   **Suspense**: This component allows you to display a fallback UI (like a loading indicator) while the dynamic component is being loaded. If the component takes too long to load, or if there's a network error, `Suspense` will handle it. It can wrap multiple `lazy` components.\n-   **Integration with React Router**: `React.lazy` and `Suspense` work seamlessly with routing libraries like React Router. You wrap your route components that use `React.lazy` within a `Suspense` boundary, ensuring a loading state is shown while the route's component chunk is fetched.\n\n## Benefits\n-   **Faster Initial Load Times**: Users only download the code they need for the current view.\n-   **Improved User Experience**: Loading indicators prevent blank screens and provide feedback.\n-   **Better Resource Utilization**: Reduces the amount of data transferred over the network.\n-   **Better Cacheability**: Smaller, more specific chunks can be cached independently, improving subsequent loads.",
      "examples": [
        {
          "id": "example_react_code_splitting_1",
          "title": "Basic React.lazy and Suspense Usage with React Router",
          "code": "import React, { lazy, Suspense } from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\n\nconst Home = () => <div>Home Page</div>;\nconst About = lazy(() => import('./routes/About')); // Dynamically imported component\n\nconst App = () => (\n  <Router>\n    <Suspense fallback={<div>Loading...</div>}> {/* Fallback UI while 'About' loads */}\n      <Switch>\n        <Route exact path=\"/\" component={Home}/>\n        <Route path=\"/about\" component={About}/>\n      </Switch>\n    </Suspense>\n  </Router>\n);\n\nexport default App;",
          "explanation": "This example demonstrates how to use `React.lazy` to defer the loading of the `About` component until it's actually needed (i.e., when the `/about` route is accessed). The `Suspense` component provides a 'Loading...' message while the `About` component's bundle is being fetched over the network. This ensures that the initial bundle size for the application is smaller, as the `About` component's code is not included until it's requested.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "React",
        "Performance",
        "Code Splitting",
        "Lazy Loading",
        "Webpack",
        "Frontend Optimization"
      ],
      "prerequisites": [
        "react_basics",
        "react_router"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Performance",
      "Code Splitting",
      "Lazy Loading",
      "Webpack",
      "Frontend Optimization"
    ],
    "prerequisites": [
      "react_basics",
      "react_router"
    ]
  },
  {
    "index": 134,
    "id": "theory_react_re_rendering",
    "type": "theory",
    "moduleId": "react",
    "complexity": 6,
    "title": "React Component Re-rendering Triggers and `forceUpdate`",
    "description": "",
    "content": {
      "id": "theory_react_re_rendering",
      "title": "React Component Re-rendering Triggers and `forceUpdate`",
      "description": "",
      "type": "theory",
      "content": "In React, components re-render when their displayed output might need to change. This ensures the UI stays synchronized with the application's state and props. There are three primary reasons a class component will re-render:\n\n### 1. Changes in Props\nWhen a component receives new `props` from its parent, React detects this change and triggers a re-render of the component and its children. This is a fundamental mechanism for data flow in React applications.\n\n### 2. State Updates via `setState()`\nCalling `this.setState()` is the standard way to update a component's internal `state`. When `setState()` is called, React schedules a re-render. It then merges the new state into the current state and re-renders the component. This is the primary mechanism for managing dynamic data within a component.\n\n### 3. Explicit Re-render via `forceUpdate()`\nAs a last resort, `this.forceUpdate()` can be called to explicitly force a component to re-render. Unlike `setState()`, `forceUpdate()` will bypass the `shouldComponentUpdate()` lifecycle method for the component itself, meaning it will re-render even if `shouldComponentUpdate()` returns `false` or if no state or props have actually changed. However, it will still trigger the normal lifecycle methods for child components. This method should be used sparingly, as it circumvents React's optimized reconciliation process and can lead to performance issues if misused. It's typically reserved for situations where external, non-React controlled data changes require a UI update.\n",
      "examples": [
        {
          "id": "example_force_update_1",
          "title": "Using `forceUpdate` to Trigger Re-render",
          "code": "import React from 'react';\n\nclass ForceUpdateExample extends React.Component {\n  handleClick = () => {\n    // This will force a re-render regardless of whether state or props changed\n    this.forceUpdate();\n    console.log('Component was forcibly re-rendered');\n  }\n  \n  render() {\n    console.log('Render method called');\n    return (\n      <div>\n        <button onClick={this.handleClick}>Force Update</button>\n        <p>Current time: {new Date().toLocaleTimeString()}</p>\n      </div>\n    );\n  }\n}\n\n// To use this component:\n// ReactDOM.render(<ForceUpdateExample />, document.getElementById('root'));",
          "explanation": "This example demonstrates the `forceUpdate` method. Each time the button is clicked, `forceUpdate()` is called, which immediately triggers the `render()` method, updating the displayed time even though no state or props explicitly changed within the component itself. The console logs illustrate that `render` is indeed called.",
          "language": "typescript"
        },
        {
          "id": "example_state_props_re_render_2",
          "title": "Re-rendering via State and Props Changes",
          "code": "import React, { useState } from 'react';\n\n// Parent Component (changes props)\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => setCount(prev => prev + 1);\n\n  console.log('ParentComponent rendered');\n\n  return (\n    <div>\n      <button onClick={increment}>Increment Count</button>\n      <ChildComponent count={count} />\n    </div>\n  );\n}\n\n// Child Component (re-renders on prop change)\nclass ChildComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { localValue: 0 };\n  }\n\n  handleLocalChange = () => {\n    this.setState(prevState => ({ localValue: prevState.localValue + 1 }));\n  };\n\n  render() {\n    console.log(`ChildComponent rendered. Props count: ${this.props.count}, Local value: ${this.state.localValue}`);\n    return (\n      <div>\n        <p>Prop from parent: {this.props.count}</p>\n        <p>Local state value: {this.state.localValue}</p>\n        <button onClick={this.handleLocalChange}>Change Local State</button>\n      </div>\n    );\n  }\n}\n\n// To use:\n// ReactDOM.render(<ParentComponent />, document.getElementById('root'));",
          "explanation": "This example showcases re-rendering due to prop and state changes. When the parent component's `count` state changes, it passes a new `count` prop to `ChildComponent`, causing the child to re-render. Additionally, when `ChildComponent`'s internal `localValue` state is updated via `this.setState()`, it triggers its own re-render, independent of the parent's props.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "React",
        "re-render",
        "props",
        "state",
        "setState",
        "forceUpdate",
        "lifecycle"
      ],
      "prerequisites": [
        "react_component_basics",
        "javascript_this_context"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "re-render",
      "props",
      "state",
      "setState",
      "forceUpdate",
      "lifecycle"
    ],
    "prerequisites": [
      "react_component_basics",
      "javascript_this_context"
    ]
  },
  {
    "index": 138,
    "id": "theory_controlled_components",
    "type": "theory",
    "moduleId": "react",
    "complexity": 6,
    "title": "Controlled Components in React",
    "description": "",
    "content": {
      "id": "theory_controlled_components",
      "title": "Controlled Components in React",
      "description": "",
      "type": "theory",
      "content": "## Overview\nIn React, a 'controlled component' is a form input element whose value is controlled by React state. This means that instead of the DOM managing its own state, React's state is the single source of truth for the input's value. Every time the input's value changes (e.g., a user types), an `onChange` event handler is triggered. This handler updates the React state, and the input's `value` prop is then re-rendered with the new state value. This creates a data flow where the React state 'controls' the input.\n\n## Key Characteristics\n- **State as Source of Truth**: The input's current value is always derived from the component's state.\n- **`value` Prop**: The input element's `value` attribute is explicitly set to a state variable.\n- **`onChange` Handler**: An `onChange` event listener is required to update the state whenever the user interacts with the input. Without it, the input would be read-only as its `value` is tied to a static state.\n\n## Benefits\n- **Direct Control over Form Data**: React state provides immediate access to the current value of the input at any time.\n- **Immediate Validation and Feedback**: Since the value is in state, validation logic can run instantly as the user types, providing real-time feedback (e.g., showing error messages).\n- **Ability to Conditionally Disable Submit Button**: The state can be used to determine if the form is valid and enable/disable the submit button accordingly.\n- **Enforcing Input Format**: You can transform or restrict input values as they are typed (e.g., converting to uppercase, limiting characters, ensuring numeric input).\n- **Easier Dynamic Form Logic**: Building forms where one input affects others (e.g., showing/hiding fields based on selections) is straightforward due to centralized state management.\n\n## Drawbacks\n- **More Code Required**: Each input needs both a `value` prop tied to state and an `onChange` handler to update that state, leading to more boilerplate code, especially for large forms.\n- **Can Impact Performance on Very Large Forms**: Frequent state updates (on every keystroke) can lead to numerous re-renders of the component and potentially the entire form, which might cause performance issues in extremely large forms with many inputs, though React's reconciliation is generally efficient.",
      "examples": [
        {
          "id": "example_controlled_components_1",
          "title": "Basic Controlled Form",
          "code": "import React, { useState } from 'react';\n\nfunction ControlledForm() {\n  const [formData, setFormData] = useState({\n    name: '',\n    email: '',\n    message: ''\n  });\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setFormData(prevFormData => ({\n      ...prevFormData,\n      [name]: value\n    }));\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Form submitted:', formData);\n    // Typically, you'd send formData to an API here\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"name\">Name:</label>\n        <input\n          type=\"text\"\n          id=\"name\"\n          name=\"name\"\n          value={formData.name}\n          onChange={handleChange}\n        />\n      </div>\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input\n          type=\"email\"\n          id=\"email\"\n          name=\"email\"\n          value={formData.email}\n          onChange={handleChange}\n        />\n      </div>\n      <div>\n        <label htmlFor=\"message\">Message:</label>\n        <textarea\n          id=\"message\"\n          name=\"message\"\n          value={formData.message}\n          onChange={handleChange}\n        />\n      </div>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}",
          "explanation": "This example demonstrates a basic controlled form. The `formData` state object holds the values for all inputs. The `handleChange` function is a generic handler that updates the correct field in `formData` based on the input's `name` attribute. Each input's `value` prop is bound to its corresponding state property, and `onChange` is set to `handleChange`, ensuring React state is always the source of truth.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "React",
        "Forms",
        "Controlled Components",
        "State Management",
        "Frontend Development"
      ],
      "prerequisites": [
        "React Basics",
        "useState Hook",
        "Event Handling"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Forms",
      "Controlled Components",
      "State Management",
      "Frontend Development"
    ],
    "prerequisites": [
      "React Basics",
      "useState Hook",
      "Event Handling"
    ]
  },
  {
    "index": 167,
    "id": "theory_react_purecomponent_memo",
    "type": "theory",
    "moduleId": "react",
    "complexity": 6,
    "title": "React.PureComponent and React.memo for Performance Optimization",
    "description": "",
    "content": {
      "id": "theory_react_purecomponent_memo",
      "title": "React.PureComponent and React.memo for Performance Optimization",
      "description": "",
      "type": "theory",
      "content": "React.PureComponent is a class component that provides a performance optimization by implementing a shallow comparison of props and state within its `shouldComponentUpdate` lifecycle method. This prevents unnecessary re-renders of the component when its props or state have not effectively changed.\n\nFor functional components, the equivalent optimization is achieved using `React.memo`.\n\n## Key Aspects of PureComponent/React.memo\n\n1.  **Automatic `shouldComponentUpdate` (Shallow Comparison)**:\n    *   `PureComponent` automatically implements `shouldComponentUpdate` and performs a shallow comparison of the new props and state with the previous ones.\n    *   `React.memo` is a Higher-Order Component (HOC) that memoizes a functional component. It re-renders the component only if its props have changed by a shallow comparison.\n    *   If the shallow comparison determines that props and state are identical, `shouldComponentUpdate` (or `React.memo`'s internal check) returns `false`, skipping the `render` method and thus preventing a re-render.\n\n2.  **Performance Optimization**:\n    *   The primary benefit is preventing unnecessary re-renders, especially in large component trees or when parent components frequently re-render but child components' props/state are stable.\n    *   This reduces the computational cost of rendering, leading to a smoother user experience.\n\n3.  **Limitations (Shallow Comparison)**:\n    *   **Complex Nested Objects/Arrays**: Since the comparison is shallow, changes within nested objects or arrays are *not* detected. If a prop is an object and its properties change (but the object reference itself remains the same), `PureComponent`/`React.memo` will not re-render. This can lead to bugs where the UI does not update.\n    *   **Function Props**: Functions passed as props will often cause re-renders if they are defined inline within the parent component's render method, as a new function reference is created on each parent render. To avoid this, functions should be memoized using `useCallback` in functional components or bound once in class components' constructors.\n\n## When to use them?\n*   When a component renders frequently.\n*   When the component's render output is the same given the same props and state.\n*   When the component's props and state are simple (primitive values, or objects/arrays whose references change when their content changes).\n\nAvoid using them if a component's render logic is very simple and re-rendering is cheap, or if you explicitly need a deep comparison or complex custom comparison logic (in which case you'd implement your own `shouldComponentUpdate` or pass a custom comparison function to `React.memo`).",
      "examples": [
        {
          "id": "example_purecomponent_1",
          "title": "UserProfile with PureComponent",
          "code": "import React, { PureComponent } from 'react';\n\nclass UserProfile extends PureComponent {\n  render() {\n    console.log('UserProfile (PureComponent) rendered');\n    const { name, email, role } = this.props;\n    \n    return (\n      <div className=\"user-profile\">\n        <h2>{name}</h2>\n        <p>Email: {email}</p>\n        <p>Role: {role}</p>\n      </div>\n    );\n  }\n}\n\n// Example Parent Component demonstrating usage\nclass App extends React.Component {\n  state = {\n    userName: 'John Doe',\n    userEmail: 'john.doe@example.com',\n    userRole: 'Developer',\n    count: 0\n  };\n\n  componentDidMount() {\n    setInterval(() => {\n      // This will cause App to re-render, but UserProfile will only re-render\n      // if its props (name, email, role) actually change (shallowly).\n      // If we just update 'count', UserProfile will not re-render.\n      this.setState(prevState => ({\n        count: prevState.count + 1\n      }));\n    }, 1000);\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>App Counter: {this.state.count}</h1>\n        <UserProfile\n          name={this.state.userName}\n          email={this.state.userEmail}\n          role={this.state.userRole}\n        />\n      </div>\n    );\n  }\n}\n",
          "explanation": "This example demonstrates `PureComponent`. The `App` component's `count` state updates every second, causing `App` to re-render. However, because `UserProfile` is a `PureComponent` and its `name`, `email`, and `role` props are not changing, `UserProfile`'s `render` method is not called, preventing unnecessary re-renders. If `userName` were to change, `UserProfile` would re-render.",
          "language": "typescript"
        },
        {
          "id": "example_react_memo_1",
          "title": "UserProfile with React.memo",
          "code": "import React, { memo } from 'react';\n\n// Functional component\nconst UserProfileMemo = memo(function UserProfile({ name, email, role, preferences }) {\n  console.log('UserProfileMemo (React.memo) rendered');\n  return (\n    <div className=\"user-profile\">\n      <h2>{name}</h2>\n      <p>Email: {email}</p>\n      <p>Role: {role}</p>\n      <p>Preferences: {preferences.theme}</p>\n    </div>\n  );\n});\n\n// Example Parent Component demonstrating usage\nfunction AppMemo() {\n  const [count, setCount] = React.useState(0);\n  const [user, setUser] = React.useState({\n    name: 'Jane Doe',\n    email: 'jane.doe@example.com',\n    role: 'Designer'\n  });\n  const [preferences, setPreferences] = React.useState({ theme: 'dark', notifications: true });\n\n  React.useEffect(() => {\n    const interval = setInterval(() => {\n      // This causes AppMemo to re-render.\n      // UserProfileMemo will only re-render if 'user' or 'preferences' references change.\n      setCount(prevCount => prevCount + 1);\n\n      // Example: Changing a nested property without changing object reference\n      // This WILL NOT cause UserProfileMemo to re-render because of shallow comparison.\n      // setPreferences(prev => { \n      //   prev.notifications = !prev.notifications; \n      //   return prev; \n      // });\n\n      // Correct way to update nested object and trigger re-render with React.memo\n      // setPreferences(prev => ({ ...prev, notifications: !prev.notifications }));\n\n    }, 1000);\n    return () => clearInterval(interval);\n  }, []);\n\n  return (\n    <div>\n      <h1>App Memo Counter: {count}</h1>\n      <UserProfileMemo\n        name={user.name}\n        email={user.email}\n        role={user.role}\n        preferences={preferences}\n      />\n      <button onClick={() => setUser(prev => ({ ...prev, name: 'Jane Smith' }))}>Change Name</button>\n      <button onClick={() => setPreferences(prev => ({ ...prev, theme: prev.theme === 'dark' ? 'light' : 'dark' }))}>Toggle Theme</button>\n    </div>\n  );\n}",
          "explanation": "This example uses `React.memo` for a functional component. Similar to `PureComponent`, `UserProfileMemo` will only re-render if its `name`, `email`, `role`, or `preferences` props (by reference) change. It also highlights the limitation: if `preferences.notifications` is modified without creating a new `preferences` object, `UserProfileMemo` will not re-render because the shallow comparison sees the same object reference for `preferences`.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "React",
        "Performance",
        "Optimization",
        "PureComponent",
        "React.memo",
        "shouldComponentUpdate",
        "Shallow Comparison",
        "HOC"
      ],
      "prerequisites": [
        "react_components",
        "react_state_props",
        "react_lifecycle_methods",
        "react_hooks"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Performance",
      "Optimization",
      "PureComponent",
      "React.memo",
      "shouldComponentUpdate",
      "Shallow Comparison",
      "HOC"
    ],
    "prerequisites": [
      "react_components",
      "react_state_props",
      "react_lifecycle_methods",
      "react_hooks"
    ]
  },
  {
    "index": 30,
    "id": "theory_hoc",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "Higher-Order Components (HOCs)",
    "description": "",
    "content": {
      "id": "theory_hoc",
      "title": "Higher-Order Components (HOCs)",
      "description": "",
      "type": "theory",
      "content": "Higher-Order Components (HOCs) are an advanced technique in React for reusing component logic. A HOC is essentially a function that takes a component as an argument and returns a new component with enhanced props or behavior. They are used for cross-cutting concerns, meaning functionalities that are common across many components, such as data fetching, authentication, logging, or state management.\n\n## Key Concepts\n-   **Function Signature**: A HOC is a function with the signature `(WrappedComponent) => EnhancedComponent`.\n-   **Logic Reusability**: They promote the reuse of component logic without duplicating code.\n-   **Props Proxying**: The HOC renders the WrappedComponent, passing down props it received, potentially adding, modifying, or removing some.\n-   **Inheritance Inversion (less common)**: The HOC extends the WrappedComponent, allowing access to its state and props, but this is generally discouraged due to complexity and tight coupling.\n\n## How HOCs Work\nA HOC wraps an existing component and injects new props or behavior. It doesn't modify the component itself, nor does it use inheritance. Instead, a HOC composes the original component by wrapping it in a container component. This container component handles the shared logic (e.g., fetching data, providing context) and then passes the necessary data as props to the original component.\n\n## Advantages\n-   **Logic Reuse**: Centralize common logic, reducing code duplication.\n-   **Separation of Concerns**: Decouple presentational components from data-fetching or other non-UI logic.\n-   **Abstracting State and Props**: Can manage state or manipulate props before passing them down.\n\n## Disadvantages\n-   **Prop Collisions**: HOCs can unintentionally override props passed to the wrapped component if they use the same prop names.\n-   **Ref Forwarding Issues**: Refs don't automatically pass through HOCs to the wrapped component, requiring explicit `React.forwardRef`.\n-   **Wrapper Hell**: Too many HOCs can lead to a deeply nested component tree, making debugging harder and obscuring where props originate from.\n-   **Static Composition**: HOCs compose components statically, meaning the injected logic is fixed at render time, unlike Hooks or Render Props which offer more dynamic composition.\n\n## Usage Example\nIn the provided example, `withUser` would be a Higher-Order Component that injects `user` data into `UserProfile`. If `user` is not available (e.g., still loading), it might provide `null` or `undefined`, allowing `UserProfile` to render a loading state.\n",
      "examples": [
        {
          "id": "example_hoc_1",
          "title": "Basic HOC Implementation: withUser",
          "code": "import React, { useState, useEffect } from 'react';\n\n// A Higher-Order Component (HOC) to inject user data\nconst withUser = (WrappedComponent) => {\n  const WithUserComponent = (props) => {\n    const [user, setUser] = useState(null);\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() => {\n      // Simulate fetching user data\n      setTimeout(() => {\n        const fetchedUser = { name: 'John Doe', id: 1 };\n        setUser(fetchedUser);\n        setLoading(false);\n      }, 1000);\n    }, []);\n\n    if (loading) {\n      return <div>Loading user data...</div>;\n    }\n\n    return <WrappedComponent {...props} user={user} />;\n  };\n  WithUserComponent.displayName = `WithUser(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return WithUserComponent;\n};\n\n// Original Component to be wrapped\nconst UserProfile = ({ user, greeting }) => (\n  user ? <div>{greeting}, {user.name}!</div> : <div>Loading...</div>\n);\n\n// Applying the HOC\nconst UserProfileWithUser = withUser(UserProfile);\n\n// Usage in an App component\nfunction App() {\n  return <UserProfileWithUser greeting=\"Hello\" />;\n}\n",
          "explanation": "This example demonstrates a basic `withUser` HOC. It fetches user data asynchronously and then passes the `user` object as a prop to the `WrappedComponent` (`UserProfile`). It also handles a loading state. The `displayName` is set for easier debugging in React DevTools.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "HOC",
        "Design Patterns",
        "Reusability",
        "Composition"
      ],
      "prerequisites": [
        "react_components",
        "react_props",
        "react_state",
        "javascript_functions"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "HOC",
      "Design Patterns",
      "Reusability",
      "Composition"
    ],
    "prerequisites": [
      "react_components",
      "react_props",
      "react_state",
      "javascript_functions"
    ]
  },
  {
    "index": 32,
    "id": "theory_compound_components",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Compound Components Pattern",
    "description": "",
    "content": {
      "id": "theory_compound_components",
      "title": "React Compound Components Pattern",
      "description": "",
      "type": "theory",
      "content": "Compound components are a design pattern in React where multiple components work together to form a complete UI widget, sharing implicit state and logic. Instead of passing many props down to deeply nested children, compound components allow developers to compose a complex UI by using child components as properties of a parent component. This pattern promotes flexibility, reusability, and separation of concerns.\n\n### Key Concepts\n-   **Declarative API**: They create a more readable, HTML-like component structure, making the component's intent clear from its usage.\n-   **Flexible Composition**: The consumer of the component can control the order and structure of the component parts, allowing for greater customization without modifying the core component logic.\n-   **Implicit State Sharing**: Component parts share state without explicit prop drilling. This is often achieved using React Context, allowing children to access the parent's state and methods.\n-   **Encapsulation**: Internal state logic is hidden from the consumer, providing a clean and intuitive API. Consumers only interact with the top-level components and their designated properties.\n-   **Intuitive API**: Developers can understand the relationship between components at a glance, as the nested structure visually represents the logical hierarchy.\n\n### Implementation Details\nTypically, the parent compound component (e.g., `Tabs`) manages the shared state (e.g., `activeIndex`). Its children (e.g., `Tabs.TabList`, `Tabs.Tab`, `Tabs.TabPanels`, `Tabs.TabPanel`) then consume this state, often using `React.Children.map` to iterate over children and `React.cloneElement` to inject props, or more commonly, React Context API for state distribution.",
      "examples": [
        {
          "id": "example_compound_components_1",
          "title": "Tabs Component Usage",
          "code": "import React from 'react';\n\n// Usage of the compound components\nfunction App() {\n  return (\n    <Tabs defaultActiveIndex={1}>\n      <Tabs.TabList>\n        <Tabs.Tab index={0}>Profile</Tabs.Tab>\n        <Tabs.Tab index={1}>Settings</Tabs.Tab>\n        <Tabs.Tab index={2}>Notifications</Tabs.Tab>\n      </Tabs.TabList>\n      \n      <Tabs.TabPanels>\n        <Tabs.TabPanel index={0}>\n          <h2>Profile Content</h2>\n          <p>User profile information goes here</p>\n        </Tabs.TabPanel>\n        <Tabs.TabPanel index={1}>\n          <h2>Settings Content</h2>\n          <p>User settings go here</p>\n        </Tabs.TabPanel>\n        <Tabs.TabPanel index={2}>\n          <h2>Notifications Content</h2>\n          <p>User notifications go here</p>\n        </Tabs.TabPanel>\n      </Tabs.TabPanels>\n    </Tabs>\n  );\n}",
          "explanation": "This example shows how a `Tabs` compound component is used. The `Tabs` component itself wraps `Tabs.TabList` and `Tabs.TabPanels`, which are components attached as properties of `Tabs`. `Tabs.Tab` and `Tabs.TabPanel` are children of their respective parent compound components. This structure allows the `Tabs` component to manage the active index state, which is then implicitly available to `Tabs.Tab` (for highlighting the active tab) and `Tabs.TabPanel` (for displaying the correct content). The consumer only needs to define the structure, and the state management is handled internally by the compound components.",
          "language": "typescript"
        },
        {
          "id": "example_compound_components_2",
          "title": "Conceptual Implementation of Tabs (Simplified)",
          "code": "import React, { useState, createContext, useContext } from 'react';\n\ninterface TabsContextType {\n  activeIndex: number;\n  setActiveIndex: (index: number) => void;\n}\n\nconst TabsContext = createContext<TabsContextType | undefined>(undefined);\n\nfunction useTabsContext() {\n  const context = useContext(TabsContext);\n  if (context === undefined) {\n    throw new Error('useTabsContext must be used within a TabsProvider');\n  }\n  return context;\n}\n\nexport function Tabs({ defaultActiveIndex, children }: { defaultActiveIndex: number; children: React.ReactNode }) {\n  const [activeIndex, setActiveIndex] = useState(defaultActiveIndex);\n\n  const contextValue = { activeIndex, setActiveIndex };\n\n  return (\n    <TabsContext.Provider value={contextValue}>\n      {children}\n    </TabsContext.Provider>\n  );\n}\n\nfunction TabList({ children }: { children: React.ReactNode }) {\n  return <div role=\"tablist\">{children}</div>;\n}\n\nfunction Tab({ index, children }: { index: number; children: React.ReactNode }) {\n  const { activeIndex, setActiveIndex } = useTabsContext();\n  const isActive = activeIndex === index;\n\n  return (\n    <button\n      role=\"tab\"\n      aria-selected={isActive}\n      onClick={() => setActiveIndex(index)}\n      style={{ fontWeight: isActive ? 'bold' : 'normal' }}\n    >\n      {children}\n    </button>\n  );\n}\n\nfunction TabPanels({ children }: { children: React.ReactNode }) {\n  return <div>{children}</div>;\n}\n\nfunction TabPanel({ index, children }: { index: number; children: React.ReactNode }) {\n  const { activeIndex } = useTabsContext();\n  const isActive = activeIndex === index;\n\n  return isActive ? <div role=\"tabpanel\">{children}</div> : null;\n}\n\n// Attach child components to the parent Tabs component\nTabs.TabList = TabList;\nTabs.Tab = Tab;\nTabs.TabPanels = TabPanels;\nTabs.TabPanel = TabPanel;\n",
          "explanation": "This is a simplified conceptual implementation of the `Tabs` compound component using React Context API. The `Tabs` component creates a context (`TabsContext`) to share `activeIndex` and `setActiveIndex`. `Tab` and `TabPanel` components then consume this context using `useTabsContext` to get the necessary state and functions, allowing them to render conditionally or react to state changes without direct prop passing from `Tabs`. This demonstrates how implicit state sharing is achieved.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Design Patterns",
        "Component Composition",
        "Context API",
        "Frontend Architecture"
      ],
      "prerequisites": [
        "react_functional_components",
        "react_hooks_basics",
        "react_context_api"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Design Patterns",
      "Component Composition",
      "Context API",
      "Frontend Architecture"
    ],
    "prerequisites": [
      "react_functional_components",
      "react_hooks_basics",
      "react_context_api"
    ]
  },
  {
    "index": 41,
    "id": "theory_react_forward_ref",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React.forwardRef: Forwarding Refs in React",
    "description": "",
    "content": {
      "id": "theory_react_forward_ref",
      "title": "React.forwardRef: Forwarding Refs in React",
      "description": "",
      "type": "theory",
      "content": "Refs in React provide a way to access DOM nodes or React components created in the render method. However, when you use Higher-Order Components (HOCs) or render props, refs are not automatically passed through to the wrapped component or the component rendered by the render prop. This is because `ref` is a special prop, handled directly by React, and it's not simply passed down like other props.\n\n`React.forwardRef` is a React utility that addresses this limitation. It allows your component to receive a ref and pass it further down to one of its children.\n\n## Key Concepts\n- **Problem Statement**: Standard props are passed down, but `ref` is a special prop that is consumed by React itself when attaching to a component instance or DOM node. When a component wraps another component (e.g., via HOCs or render props), the ref placed on the wrapper component refers to the *wrapper component itself*, not the inner component you might intend to reference.\n- **Solution**: `React.forwardRef` creates a React component that takes `props` and `ref` as arguments in its render function. The `ref` argument is the actual ref that was passed from the parent component.\n- **Syntax**: `React.forwardRef((props, ref) => <MyComponent ref={ref} {...props} />)`\n- **Use Cases**: Primarily used when building reusable component libraries, HOCs, or render prop components where you need to expose an underlying DOM element or component instance to a parent component for imperative actions (e.g., `focus()`, `measure()`).\n\n## Note on Refs with HOCs\nRefs are *not* passed through HOCs (Higher Order Components) by default. If you try to place a ref on a HOC-wrapped component, you will get a ref to the *outer wrapper component* (the HOC itself), not the wrapped component. `React.forwardRef` is essential to enable ref forwarding through HOCs, allowing the HOC to 'see' the ref and pass it to its `WrappedComponent`.",
      "examples": [
        {
          "id": "example_forward_ref_1",
          "title": "Forwarding Ref with a Higher-Order Component",
          "code": "import React from 'react';\n\n// A Higher-Order Component (HOC) that logs props.\n// It needs to be ref-aware to forward refs.\nfunction logProps(WrappedComponent) {\n  class LogProps extends React.Component {\n    // This is where React.forwardRef injects the ref\n    // The ref passed by the parent component will be assigned to this.ref\n    render() {\n      const { forwardedRef, ...rest } = this.props;\n      // console.log('Props:', rest);\n      return <WrappedComponent ref={forwardedRef} {...rest} />;\n    }\n  }\n\n  // Using React.forwardRef to pass the ref to the internal WrappedComponent\n  // The second argument 'ref' is the ref passed by the parent.\n  return React.forwardRef((props, ref) => {\n    return <LogProps {...props} forwardedRef={ref} />;\n  });\n}\n\n// A functional component (or class component) that needs its ref forwarded.\n// It receives the ref as the second argument if wrapped by forwardRef.\nconst FancyButton = React.forwardRef((props, ref) => (\n  <button ref={ref} className=\"FancyButton\">\n    {props.label}\n  </button>\n));\n\n// Original class component, before forwarding ref was applied directly\n// class FancyButton extends React.Component {\n//   focus() {\n//     // Implementation for focusing\n//     console.log('FancyButton focused!');\n//     this.buttonRef.current.focus();\n//   }\n//\n//   constructor(props) {\n//     super(props);\n//     this.buttonRef = React.createRef();\n//   }\n//\n//   render() {\n//     return <button ref={this.buttonRef}>Click me!</button>;\n//   }\n// }\n\n// Export wrapped component\nconst EnhancedFancyButton = logProps(FancyButton);\n\n// Consumer component\nfunction App() {\n  const ref = React.createRef();\n  \n  // The ref will be forwarded to the FancyButton component\n  const handleFocus = () => {\n    if (ref.current) {\n      // This calls the .focus() method of the underlying HTML button element\n      ref.current.focus();\n    }\n  };\n\n  return (\n    <div>\n      <EnhancedFancyButton ref={ref} label=\"Click Me\" />\n      <button onClick={handleFocus}>Focus the fancy button</button>\n    </div>\n  );\n}\n\n// To demonstrate the original class component with internal ref and its focus method:\nclass OriginalFancyButton extends React.Component {\n  constructor(props) {\n    super(props);\n    this.buttonRef = React.createRef();\n  }\n  \n  focus() {\n    // Implementation\n    console.log('OriginalFancyButton focused!');\n    this.buttonRef.current.focus();\n  }\n  \n  render() {\n    return <button ref={this.buttonRef}>Click me!</button>;\n  }\n}\n\n// Export wrapped component (if we were using the original class)\n// const EnhancedOriginalFancyButton = logProps(OriginalFancyButton);\n\n// // Consumer component demonstrating original class focus\n// function AppOriginal() {\n//   const ref = React.createRef();\n//   return (\n//     <div>\n//       {/* Without forwardRef on the OriginalFancyButton itself, this ref \n//           would refer to the LogProps instance, not the FancyButton. */}\n//       <EnhancedOriginalFancyButton ref={ref} label=\"Click Me\" />\n//       <button onClick={() => ref.current.focus()}>Focus the fancy button (Original)</button>\n//     </div>\n//   );\n// }",
          "explanation": "This example demonstrates how `React.forwardRef` is used to allow a parent component (`App`) to obtain a ref to an underlying DOM element (the `<button>` inside `FancyButton`), even when `FancyButton` is wrapped by a Higher-Order Component (`logProps`).\n\n1.  `FancyButton` is defined using `React.forwardRef`. This makes `FancyButton` a 'ref-aware' component, meaning it accepts a `ref` prop as its second argument in the render function. This `ref` is then passed directly to the `<button>` element.\n2.  The `logProps` HOC also uses `React.forwardRef`. Inside `logProps`, a wrapper component (`LogProps` class) is created. The `ref` argument from `React.forwardRef` is passed as a regular prop (`forwardedRef`) to this internal `LogProps` component. `LogProps` then renders the `WrappedComponent` (`FancyButton`) and attaches `forwardedRef` to its `ref` prop.\n3.  In `App`, `React.createRef()` creates a ref object. When `EnhancedFancyButton` (the HOC-wrapped `FancyButton`) is rendered with `ref={ref}`, this ref is forwarded through `logProps` and eventually reaches the `<button>` element inside `FancyButton`.\n4.  Clicking 'Focus the fancy button' calls `ref.current.focus()`. Because the ref points directly to the HTML button element, its native `focus()` method is invoked, demonstrating successful ref forwarding.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Refs",
        "forwardRef",
        "HOCs",
        "Composition"
      ],
      "prerequisites": [
        "react_components",
        "react_props",
        "react_refs"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Refs",
      "forwardRef",
      "HOCs",
      "Composition"
    ],
    "prerequisites": [
      "react_components",
      "react_props",
      "react_refs"
    ]
  },
  {
    "index": 42,
    "id": "theory_high_order_components",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "High-Order Components (HOCs)",
    "description": "",
    "content": {
      "id": "theory_high_order_components",
      "title": "High-Order Components (HOCs)",
      "description": "",
      "type": "theory",
      "content": "High-Order Components (HOCs) in React are an advanced technique for reusing component logic. A Higher-Order Component is a function that takes a component as an argument and returns a new component. They are not React components themselves, but rather functions that transform components.\n\n## Core Concept\nAn HOC wraps the original component, enhancing it with additional props, state, or behavior, without modifying the original component itself. This allows for clean separation of concerns and efficient code reuse.\n\n```typescript\ntype HOC<P extends object, T extends object> = (WrappedComponent: React.ComponentType<P>) => React.ComponentType<P & T>;\n\n// Example structure:\nfunction withLogger<P extends object>(WrappedComponent: React.ComponentType<P>): React.ComponentType<P> {\n  class WithLogger extends React.Component<P> {\n    componentDidMount() {\n      console.log(`${getDisplayName(WrappedComponent)} mounted`);\n    }\n    componentWillUnmount() {\n      console.log(`${getDisplayName(WrappedComponent)} unmounted`);\n    }\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n  WithLogger.displayName = `withLogger(${getDisplayName(WrappedComponent)})`;\n  return WithLogger;\n}\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n```\n\n## Common HOC Use Cases\nHOCs are powerful for addressing cross-cutting concerns and abstracting state or props. Key use cases include:\n\n1.  **Code Reuse and Cross-Cutting Concerns:**\n    *   **Authentication/Authorization:** Wrapping components to check user permissions or redirect unauthenticated users.\n    *   **Data Fetching and Loading States:** Providing data from an external source and managing loading/error states.\n    *   **Measuring Performance:** Logging render times or tracking component interactions.\n    *   **Error Handling:** Catching errors in child components and displaying fallback UI.\n    *   **Analytics:** Injecting analytics tracking logic.\n\n2.  **State Abstraction:**\n    *   **Managing Form State:** Handling form input values and validation logic.\n    *   **Managing Subscription Data:** Subscribing to external data sources (e.g., Redux store, external APIs) and passing updates as props.\n    *   **Managing Global UI State:** Controlling modals, tooltips, or themes.\n\n3.  **Prop Manipulation:**\n    *   **Filtering or Transforming Props:** Modifying the props passed to the wrapped component.\n    *   **Adding Extra Props:** Injecting additional props that the wrapped component needs (e.g., `theme`, `currentUser`).\n    *   **Renaming Props for Compatibility:** Adapting prop names to fit a specific component's interface.\n\n## HOC Best Practices\nTo leverage HOCs effectively and avoid common pitfalls, follow these best practices:\n\n1.  **Don't Mutate the Original Component:**\n    *   HOCs should aim for pure functions, meaning they don't modify the input component. Instead, they should return a *new* component that wraps the original. Mutating the original component can lead to side effects, make debugging harder, and break component reusability.\n    ```typescript\n    // Bad - mutates the original component (e.g., adding lifecycle methods directly)\n    function withStylesBad<P extends object>(WrappedComponent: React.ComponentType<P>) {\n      // This modifies the prototype of the original component, affecting all instances.\n      // This is generally an anti-pattern in React.\n      (WrappedComponent.prototype as any).componentDidMount = function() { /* ... */ };\n      return WrappedComponent;\n    }\n    \n    // Good - creates a new component that wraps the original\n    function withStylesGood<P extends object>(WrappedComponent: React.ComponentType<P>) {\n      return class extends React.Component<P> {\n        componentDidMount() { \n          console.log(`Component ${getDisplayName(WrappedComponent)} styled.`);\n        }\n        render() {\n          // Passes all original props to the wrapped component\n          return <WrappedComponent {...this.props} />;\n        }\n      };\n    }\n    ```\n\n2.  **Pass Unrelated Props Through:**\n    *   HOCs should pass all props that are not specifically consumed or injected by the HOC itself directly to the wrapped component. This ensures flexibility and prevents unintended prop loss, allowing the wrapped component to receive all necessary external props.\n    ```typescript\n    function withMousePosition<P extends object>(WrappedComponent: React.ComponentType<P>) {\n      interface MouseState {\n        x: number;\n        y: number;\n      }\n      // Defines the props that the HOC adds to the wrapped component\n      interface InjectedProps {\n        mousePosition: MouseState;\n      }\n\n      type Props = P & InjectedProps;\n\n      return class WithMousePosition extends React.Component<Props> {\n        state: MouseState = { x: 0, y: 0 };\n\n        handleMouseMove = (event: MouseEvent) => {\n          this.setState({ x: event.clientX, y: event.clientY });\n        };\n\n        componentDidMount() {\n          window.addEventListener('mousemove', this.handleMouseMove);\n        }\n\n        componentWillUnmount() {\n          window.removeEventListener('mousemove', this.handleMouseMove);\n        }\n\n        render() {\n          // Injects mousePosition but passes through all other props (P type)\n          const { mousePosition, ...restProps } = this.props;\n          return <WrappedComponent mousePosition={this.state} {...(restProps as P)} />;\n        }\n      };\n    }\n    ```\n\n3.  **Maximize Composability:**\n    *   HOCs are designed to be composed together. You can chain them to apply multiple concerns to a single component. For better readability and maintainability, especially with many HOCs, consider using a `compose` utility function (e.g., from Redux or Lodash) which applies HOCs from right to left.\n    ```typescript\n    // Compose multiple HOCs by chaining them\n    const EnhancedComponent = withRouter(withTheme(withAuth(MyComponent)));\n    \n    // Or using a compose utility for cleaner syntax and right-to-left application\n    // (MyComponent -> withAuth -> withTheme -> withRouter)\n    type ComposeFunction = (...fns: Function[]) => (x: any) => any;\n\n    const compose: ComposeFunction = (...fns) => x => fns.reduceRight((v, f) => f(v), x);\n\n    const enhance = compose(\n      withRouter,\n      withTheme,\n      withAuth\n    );\n    const EnhancedComponent = enhance(MyComponent);\n    ```\n\n4.  **Convention: Include Display Name for Debugging:**\n    *   Setting a `displayName` for the HOC-returned component helps immensely with debugging in React Developer Tools. It makes the component tree more understandable by providing meaningful names for the wrapped components.\n    ```typescript\n    function withSubscription<P extends object, InjectedProps extends object>(\n      WrappedComponent: React.ComponentType<P & InjectedProps>,\n      selectData: (dataSource: any, props: P) => InjectedProps\n    ): React.ComponentType<P> {\n      interface SubscriptionState extends InjectedProps {}\n\n      class WithSubscription extends React.Component<P, SubscriptionState> {\n        state: SubscriptionState = {} as SubscriptionState; // Initial state based on injected props\n        dataSource: any; // Assume DataSource is defined elsewhere\n\n        componentDidMount() {\n          this.dataSource = {}; // Placeholder for actual data source\n          this.setState(selectData(this.dataSource, this.props));\n        }\n        \n        render() {\n          return <WrappedComponent {...this.props} {...this.state} />;\n        }\n      }\n      \n      // Add a proper displayName for dev tools\n      WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;\n      \n      return WithSubscription;\n    }\n    \n    function getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n      return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n    }\n\n    // Usage Example:\n    interface CommentListProps {\n      postId: string;\n      comments: string[]; // Injected by HOC\n    }\n\n    const CommentList: React.FC<CommentListProps> = ({ postId, comments }) => (\n      <div>\n        <h2>Comments for Post #{postId}</h2>\n        {comments.map((comment, index) => <p key={index}>{comment}</p>)}\n      </div>\n    );\n\n    // Assume a DataSource exists globally or is passed in\n    const DataSource = {\n      getComments: (postId: string) => {\n        console.log(`Fetching comments for post ${postId}`);\n        return { comments: [`Comment 1 for ${postId}`, `Comment 2 for ${postId}`] };\n      }\n    };\n\n    const CommentListWithSubscription = withSubscription(\n      CommentList,\n      (source, props) => DataSource.getComments(props.postId)\n    );\n\n    // Example of how it would be rendered:\n    // <CommentListWithSubscription postId=\"123\" />\n    ```\n\n## Limitations of HOCs\nWhile powerful, HOCs have certain limitations:\n\n*   **Don't use HOCs inside the `render` method:** Creating a new HOC-returned component inside `render` will cause the component to unmount and remount every time the parent renders. This leads to performance issues (lost state, unnecessary re-renders) and identity problems (e.g., `shouldComponentUpdate` failing).\n*   **Static methods must be copied over manually or with a utility:** If your wrapped component has static methods (e.g., `MyComponent.someStaticMethod`), these are not automatically copied to the new component returned by the HOC. You need to copy them explicitly or use a utility like `hoist-non-react-statics`.\n*   **Refs aren't passed through automatically (use `React.forwardRef`):** Refs created on the HOC-returned component will refer to the HOC instance, not the instance of the wrapped component. To get a ref to the actual wrapped component, you must use `React.forwardRef` within your HOC to pass the ref down.\n",
      "examples": [
        {
          "id": "example_hoc_basic_usage",
          "title": "Basic HOC Usage: `withSubscription`",
          "code": "import React from 'react';\n\ninterface CommentListProps {\n  postId: string;\n  comments: string[]; // This prop is injected by the HOC\n}\n\nconst CommentList: React.FC<CommentListProps> = ({ postId, comments }) => (\n  <div>\n    <h3>Comments for Post #{postId}</h3>\n    {comments.length > 0 ? (\n      <ul>\n        {comments.map((comment, index) => (\n          <li key={index}>{comment}</li>\n        ))}\n      </ul>\n    ) : (\n      <p>No comments available.</p>\n    )}\n  </div>\n);\n\n// Placeholder for a data source. In a real app, this would be more sophisticated.\nconst DataSource = {\n  getComments: (postId: string) => {\n    // Simulate API call\n    return { comments: [`Comment A for ${postId}`, `Comment B for ${postId}`] };\n  },\n  // Other data fetching methods...\n};\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\ninterface InjectedSubscriptionProps {\n  comments: string[];\n}\n\n// HOC definition\nfunction withSubscription<P extends object>(\n  WrappedComponent: React.ComponentType<P & InjectedSubscriptionProps>,\n  selectData: (dataSource: typeof DataSource, props: P) => InjectedSubscriptionProps\n): React.ComponentType<P> {\n  class WithSubscription extends React.Component<P, InjectedSubscriptionProps> {\n    static displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;\n\n    state: InjectedSubscriptionProps = { comments: [] };\n\n    componentDidMount() {\n      this.setState(selectData(DataSource, this.props));\n    }\n\n    render() {\n      // Pass down all original props AND the injected state (comments)\n      return <WrappedComponent {...this.props} {...this.state} />;\n    }\n  }\n  return WithSubscription;\n}\n\n// Usage\nconst CommentListWithSubscription = withSubscription(\n  CommentList,\n  (source, props) => source.getComments(props.postId)\n);\n\n// How you would use CommentListWithSubscription in your application:\n// <CommentListWithSubscription postId=\"1\" />\n",
          "explanation": "This example demonstrates a common HOC pattern: data subscription. The `withSubscription` HOC takes a `CommentList` component and a `selectData` function. It then internally manages fetching 'comments' based on `props.postId` using a `DataSource`. The fetched `comments` are then injected as props into the `CommentList`. This separates data fetching logic from the presentational component, making `CommentList` reusable and focused solely on rendering comments.",
          "language": "typescript"
        },
        {
          "id": "example_hoc_prop_passthrough",
          "title": "HOC: Passing Unrelated Props Through",
          "code": "import React from 'react';\n\ninterface MyComponentProps {\n  message: string;\n  value: number; // This prop is passed through by the HOC\n  timestamp: Date; // This prop is added by the HOC\n}\n\nconst MyComponent: React.FC<MyComponentProps> = ({ message, value, timestamp }) => (\n  <div>\n    <p>Message: {message}</p>\n    <p>Value from parent: {value}</p>\n    <p>Timestamp from HOC: {timestamp.toLocaleString()}</p>\n  </div>\n);\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\ninterface WithTimestampProps {\n  timestamp: Date;\n}\n\nfunction withTimestamp<P extends object>(WrappedComponent: React.ComponentType<P & WithTimestampProps>): React.ComponentType<P> {\n  class WithTimestamp extends React.Component<P> {\n    static displayName = `WithTimestamp(${getDisplayName(WrappedComponent)})`;\n\n    render() {\n      // The HOC injects a 'timestamp' prop.\n      // All other props (of type P) are passed through using {...this.props}.\n      return <WrappedComponent {...this.props as P} timestamp={new Date()} />;\n    }\n  }\n  return WithTimestamp;\n}\n\n// Usage\nconst EnhancedMyComponent = withTimestamp(MyComponent);\n\n// Example of how it would be rendered:\n// <EnhancedMyComponent message=\"Hello HOC!\" value={42} />\n",
          "explanation": "This example showcases the best practice of passing unrelated props through an HOC. The `withTimestamp` HOC adds a `timestamp` prop to `MyComponent`. Critically, `MyComponent` also expects `message` and `value` props directly from its parent. The `WithTimestamp` HOC ensures that `message` and `value` are correctly passed down to `MyComponent` by using `{...this.props}` in its `render` method, alongside the newly injected `timestamp` prop.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "HOC",
        "Higher-Order Components",
        "Component Patterns",
        "Code Reuse",
        "State Management",
        "Prop Manipulation",
        "Best Practices"
      ],
      "prerequisites": [
        "React Components",
        "JavaScript Functions",
        "Props",
        "State",
        "Lifecycle Methods"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "HOC",
      "Higher-Order Components",
      "Component Patterns",
      "Code Reuse",
      "State Management",
      "Prop Manipulation",
      "Best Practices"
    ],
    "prerequisites": [
      "React Components",
      "JavaScript Functions",
      "Props",
      "State",
      "Lifecycle Methods"
    ]
  },
  {
    "index": 44,
    "id": "theory_component_lifecycle_flow",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Component Lifecycle and Rendering Flow",
    "description": "",
    "content": {
      "id": "theory_component_lifecycle_flow",
      "title": "React Component Lifecycle and Rendering Flow",
      "description": "",
      "type": "theory",
      "content": "Understanding the lifecycle of a React component is fundamental for building robust and efficient applications. A component goes through distinct phases: **mounting** (when it's first created and inserted into the DOM), **updating** (when its props or state change), and **unmounting** (when it's removed from the DOM). React provides special methods, called lifecycle methods, that allow developers to execute code at specific points in these phases.\n\n## Component Creation and Mounting Flow\n\n1.  **Component Definition**: This is the initial step where you define your React component, either as a class component or a functional component. For class components, this involves defining a class that extends `React.Component`.\n2.  **Component Usage**: The component is used within another component's `render` method or, for the root component, directly with `ReactDOM.render`.\n3.  **Instance Creation**: React creates an instance of the component's element. For class components, this is where `this.props` becomes accessible.\n4.  **Constructor Execution**: If a `constructor` method is defined in a class component, it is the *first* lifecycle method called. It's used for initializing state and binding event handlers.\n5.  **Virtual DOM Processing (Render)**: React calls the component's `render` method. This method returns a new React element tree (the Virtual DOM representation) that describes what the UI should look like.\n6.  **DOM Interaction (Mounting)**: For the initial render, React interacts with the browser's DOM to display the elements described by the Virtual DOM. This process is called \"mounting.\"\n7.  **`componentDidMount` Call**: After the component has been mounted and rendered to the actual DOM, `componentDidMount` is called. This is an ideal place for side effects like fetching data, setting up subscriptions, or interacting directly with the DOM.\n\n## Component Update Cycle\n\nWhen a component's props or state change, React initiates an update process:\n\n1.  **State/Prop Change**: The update cycle is triggered when `setState()` is called (either internally or from a parent component) or when a parent component re-renders and passes new props.\n2.  **Pre-Update Methods (`componentWillReceiveProps`, `getDerivedStateFromProps`)**: If props change, legacy class components would call `componentWillReceiveProps`. In modern React, `static getDerivedStateFromProps(nextProps, prevState)` is used. It's called right before `render` on every update and returns an object to update state, or `null` to update nothing. It should be a pure function.\n3.  **Update Decision (`shouldComponentUpdate`)**: React calls `shouldComponentUpdate(nextProps, nextState)`. This method returns a boolean indicating whether React should proceed with the update. It's a crucial optimization point; returning `false` prevents re-rendering of the component and its children, but can lead to stale UI if not used carefully.\n4.  **Pre-Rendering (`componentWillUpdate`, `getSnapshotBeforeUpdate`)**: If `shouldComponentUpdate` returns `true`, legacy class components would call `componentWillUpdate`. In newer React, `getSnapshotBeforeUpdate(prevProps, prevState)` is called right before the changes from the Virtual DOM are applied to the actual DOM. It returns a snapshot value (or `null`) that is passed to `componentDidUpdate`.\n5.  **Re-render**: The component's `render` method is called again to generate a new Virtual DOM tree based on the updated props/state.\n6.  **Diffing**: React performs a diffing algorithm, comparing the new Virtual DOM tree with the previous one. It identifies the minimal set of changes needed to update the actual DOM.\n7.  **DOM Update**: Only the necessary changes are applied to the actual DOM, optimizing performance.\n8.  **`componentDidUpdate` Call**: After the component has been updated and the changes have been flushed to the DOM, `componentDidUpdate(prevProps, prevState, snapshot)` is called. This is a good place to perform side effects after an update, such as network requests based on prop changes or interacting with the updated DOM. The `snapshot` value from `getSnapshotBeforeUpdate` is available here.\n\n## Component Unmounting Phase\n\nWhen a component is removed from the DOM (e.g., due to a conditional render, or its parent unmounting):\n\n1.  **`componentWillUnmount` Call**: Before the component is actually removed from the DOM, `componentWillUnmount()` is called. This is the ideal place to perform cleanup activities, such as invalidating timers, cancelling network requests, or removing event listeners that were set up in `componentDidMount`.\n\n",
      "examples": [
        {
          "id": "example_lifecycle_1",
          "title": "Basic Class Component with Lifecycle Methods",
          "code": "import React from 'react';\n\nclass LifecycleDemo extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    console.log('1. Constructor: Initializing state and binding methods.');\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log('2. getDerivedStateFromProps: Called before render, returns state update.');\n    // Example: Update state based on props\n    if (nextProps.initialCount && nextProps.initialCount !== prevState.count) {\n      return { count: nextProps.initialCount };\n    }\n    return null; // No state update needed\n  }\n\n  componentDidMount() {\n    console.log('4. componentDidMount: Component mounted to DOM. Good for data fetching.');\n    this.timer = setInterval(() => {\n      this.setState(prevState => ({ count: prevState.count + 1 }));\n    }, 1000);\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log(`5. shouldComponentUpdate: Current count ${this.state.count}, Next count ${nextState.count}.`);\n    // Only update if count changes\n    return nextState.count !== this.state.count;\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('6. getSnapshotBeforeUpdate: Called right before DOM updates.');\n    // Example: Capture scroll position before update\n    return 'captured snapshot';\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log(`8. componentDidUpdate: Component updated. Snapshot: ${snapshot}`);\n    console.log(`   Previous state: ${prevState.count}, Current state: ${this.state.count}`);\n  }\n\n  componentWillUnmount() {\n    console.log('9. componentWillUnmount: Cleanup before component unmounts.');\n    clearInterval(this.timer);\n  }\n\n  render() {\n    console.log('3 & 7. Render: Building the Virtual DOM.');\n    return (\n      <div>\n        <h2>Lifecycle Demo</h2>\n        <p>Count: {this.state.count}</p>\n        <button onClick={() => this.setState({ count: this.state.count + 10 })}>Add 10 (Manual Update)</button>\n      </div>\n    );\n  }\n}\n\nexport default LifecycleDemo;",
          "explanation": "This example demonstrates a class component integrating various lifecycle methods. The console logs illustrate the order of execution for mounting and updating phases. `constructor` initializes state. `getDerivedStateFromProps` potentially updates state based on new props. `componentDidMount` sets up a timer. `shouldComponentUpdate` provides a performance optimization. `getSnapshotBeforeUpdate` captures information before DOM updates. `componentDidUpdate` acts after DOM updates. `componentWillUnmount` performs cleanup.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Component Lifecycle",
        "Mounting",
        "Updating",
        "Unmounting",
        "Class Components"
      ],
      "prerequisites": [
        "JavaScript Basics",
        "ES6 Classes",
        "React Basics"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Component Lifecycle",
      "Mounting",
      "Updating",
      "Unmounting",
      "Class Components"
    ],
    "prerequisites": [
      "JavaScript Basics",
      "ES6 Classes",
      "React Basics"
    ]
  },
  {
    "index": 45,
    "id": "theory_mounting_phase",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Component Mounting Phase",
    "description": "",
    "content": {
      "id": "theory_mounting_phase",
      "title": "React Component Mounting Phase",
      "description": "",
      "type": "theory",
      "content": "The Mounting Phase in React refers to the stage where an instance of your component is being created and inserted into the DOM. Understanding this phase is crucial for initializing component state, performing initial data fetching, and setting up necessary DOM interactions. The methods in this phase are called in a specific, predictable order:\n\n1.  `constructor(props)`\n2.  `static getDerivedStateFromProps(props, state)`\n3.  `render()`\n4.  `componentDidMount()`\n\nEach method serves a distinct purpose and has specific guidelines regarding what operations should and should not be performed within it.\n\n## Key Concepts\n-   **Initialization**: Setting up initial state and binding methods.\n-   **Side Effects**: Operations that interact with the outside world (e.g., API calls, subscriptions, direct DOM manipulation).\n-   **Purity of `render`**: Ensuring the `render` method is idempotent and only returns JSX.\n-   **DOM Insertion**: The point at which the component's output is actually placed into the browser's DOM.\n\n## Method Details\n\n### constructor(props)\n-   **Purpose**: Called before the component is mounted to the DOM. Its primary uses are to initialize local state by assigning an object to `this.state` and to bind event handler methods to the instance.\n-   **Execution**: It's the first method called in the mounting lifecycle.\n-   **Important Notes**: \n    -   Always call `super(props)` as the first statement, otherwise, `this.props` will be `undefined` in the constructor and potential other issues.\n    -   This is the *only* place where you can directly assign `this.state`. In all other methods, you must use `this.setState()`.\n    -   **Avoid** causing side effects (like API calls or subscriptions) in the constructor. It should be a pure function that sets up the initial state.\n\n### static getDerivedStateFromProps(props, state)\n-   **Purpose**: Called right before calling the `render` method, both on initial mount and on subsequent updates. Its purpose is to enable a component to update its internal state based on changes in props. It should return an object to update the state, or `null` to indicate that no state update is needed.\n-   **Execution**: Called after `constructor` (on mount) and before `render` (on mount and update).\n-   **Important Notes**:\n    -   It is a `static` method, which means it doesn't have access to the component instance (`this`). It operates purely on its `props` and `state` arguments.\n    -   It exists for rare use cases where the state *must* depend on changes in props over time (e.g., when a component needs to reset some of its internal state when a specific prop changes).\n    -   **Avoid** side effects in this method. It should be a pure function for derived state calculation.\n    -   It replaced deprecated lifecycle methods like `componentWillReceiveProps`.\n\n### render()\n-   **Purpose**: The only required method in a React class component. It reads `this.props` and `this.state` and returns React elements that will eventually be rendered to the DOM. It describes what should be rendered.\n-   **Execution**: Called after `static getDerivedStateFromProps` and before `componentDidMount`.\n-   **Important Notes**:\n    -   **Purity**: The `render()` method should be pure. It means it should not modify component state, perform side effects, or interact directly with the browser DOM. Given the same props and state, it should always return the same output.\n    -   **Return Types**: Can return React elements (JSX), arrays and fragments (must have a single parent key if an array), portals, strings, numbers, booleans (which render nothing), or `null` (renders nothing).\n    -   If returning arrays or fragments, they must have unique `key` props for each child element.\n\n### componentDidMount()\n-   **Purpose**: Called immediately after the component is mounted (i.e., inserted into the DOM tree). This is the ideal place to perform operations that require the component to be in the DOM.\n-   **Execution**: This is the last method called in the mounting sequence.\n-   **Important Notes**:\n    -   **Side Effects**: This is the best place to cause side effects such as:\n        -   Making network requests (API calls) to fetch data.\n        -   Setting up subscriptions (e.g., to an external data source or an event listener).\n        -   Directly manipulating the DOM (e.g., initializing a third-party library that needs DOM access, working with canvas or maps).\n    -   You *can* call `setState()` immediately in this method, but be aware that it will trigger an extra re-rendering. While this extra rendering isn't visible to the user (because it happens before the browser updates the screen), it might affect performance. It's generally preferred to initialize state in the constructor unless there's a specific reason to derive it from props or external sources *after* mount.",
      "examples": [
        {
          "id": "example_mounting_component",
          "title": "Basic Mounting Lifecycle Component",
          "code": "import React from 'react';\n\nclass LifecycleComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null, message: 'Loading...' };\n    console.log('1. Constructor: Initializing state and binding methods.');\n    this.handleClick = this.handleClick.bind(this);\n  }\n  \n  static getDerivedStateFromProps(props, state) {\n    console.log('2. getDerivedStateFromProps: Checking for prop changes to update state.');\n    // Example: If a prop 'reset' changes, reset internal message.\n    if (props.resetMessage && state.message !== 'Message Reset!') {\n        return { message: 'Message Reset!' };\n    }\n    return null; // No state update needed from props\n  }\n  \n  componentDidMount() {\n    console.log('4. componentDidMount: Component mounted to DOM. Performing side effects.');\n    // Best place for API calls, subscriptions, DOM manipulations\n    fetch('https://jsonplaceholder.typicode.com/todos/1') // Example API call\n      .then(response => response.json())\n      .then(json => {\n        console.log('API data fetched:', json);\n        this.setState({ data: json.title, message: 'Data loaded!' });\n      })\n      .catch(error => console.error('Error fetching data:', error));\n\n    // Example of adding an event listener\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  componentWillUnmount() {\n    console.log('ComponentWillUnmount: Cleaning up event listener.');\n    window.removeEventListener('resize', this.handleResize);\n  }\n\n  handleClick() {\n    this.setState(prevState => ({ message: prevState.message + ' Clicked!' }));\n  }\n\n  handleResize = () => {\n    console.log('Window resized!');\n  };\n  \n  render() {\n    console.log('3. render: Rendering component JSX.');\n    return (\n      <div>\n        <h2>Mounting Phase Demo</h2>\n        <p>Data: {this.state.data || 'No data yet'}</p>\n        <p>Message: {this.state.message}</p>\n        <button onClick={this.handleClick}>Click Me</button>\n      </div>\n    );\n  }\n}\n\nexport default LifecycleComponent;",
          "explanation": "This example demonstrates the core methods of the mounting phase. The `constructor` initializes the state and binds `handleClick`. `getDerivedStateFromProps` checks for a `resetMessage` prop to update the state. The `render` method simply displays the current state. `componentDidMount` is used to fetch data from an API and set up a window resize event listener, showcasing appropriate side effects. `componentWillUnmount` is included for completeness to show where to clean up `componentDidMount` effects. Console logs clearly show the order of execution.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Lifecycle Methods",
        "Mounting",
        "Class Components",
        "State",
        "Props",
        "Side Effects"
      ],
      "prerequisites": [
        "react_basics",
        "javascript_classes",
        "promises_and_fetch"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Lifecycle Methods",
      "Mounting",
      "Class Components",
      "State",
      "Props",
      "Side Effects"
    ],
    "prerequisites": [
      "react_basics",
      "javascript_classes",
      "promises_and_fetch"
    ]
  },
  {
    "index": 47,
    "id": "theory_react_error_boundaries_overview",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Error Boundaries: Concept and Implementation",
    "description": "",
    "content": {
      "id": "theory_react_error_boundaries_overview",
      "title": "React Error Boundaries: Concept and Implementation",
      "description": "",
      "type": "theory",
      "content": "## Introduction to React Error Boundaries\nReact Error Boundaries are React components that **catch JavaScript errors** anywhere in their child component tree, **log those errors**, and **display a fallback UI** instead of the crashed component tree. They are a robust way to prevent an entire application from crashing due due to an error in a single component. Error Boundaries catch errors during:\n\n*   Rendering\n*   In lifecycle methods\n*   In constructors of the whole tree below them\n\nThey are class components that implement at least one of the two lifecycle methods: `static getDerivedStateFromError()` or `componentDidCatch()`.\n\n### Why Use Error Boundaries?\nBefore React 16, errors in components could lead to the unmounting of the entire React component tree, resulting in a blank page for the user. Error Boundaries provide a way to gracefully handle these errors, displaying a user-friendly message or fallback UI, thus improving the user experience and application resilience.\n\n### Basic Structure of an Error Boundary\nAn Error Boundary is typically a class component that maintains its own state to track whether an error has occurred in its children.\n\n```typescript\nimport React from 'react';\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  errorInfo: React.ErrorInfo | null;\n}\n\ninterface ErrorBoundaryProps {\n  children: React.ReactNode;\n}\n\nclass ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  state: ErrorBoundaryState = { hasError: false, errorInfo: null };\n  \n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    // Update state so the next render will show the fallback UI.\n    // This method is for handling errors during the render phase.\n    console.log('getDerivedStateFromError called with:', error);\n    return { hasError: true, errorInfo: null }; // errorInfo is typically null here as we only update hasError for immediate fallback\n  }\n  \n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {\n    // You can also log the error to an error reporting service\n    console.log('componentDidCatch called with:', error, errorInfo);\n    console.error('Error caught by Error Boundary:', error);\n    console.error('Error info:', errorInfo);\n    \n    // Update state to display error details (if desired) after the commit phase\n    this.setState({ errorInfo: errorInfo });\n    // logErrorToService(error, errorInfo); // Example of reporting to an external service\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      // Render fallback UI when an error occurs\n      return (\n        <div className=\"error-boundary\">\n          <h2>Something went wrong.</h2>\n          {this.state.errorInfo && (\n            <details style={{ whiteSpace: 'pre-wrap' }}>\n              <summary>Error Details</summary>\n              {/* errorInfo.componentStack provides the component stack trace */}\n              <pre>{this.state.errorInfo.componentStack}</pre>\n            </details>\n          )}\n        </div>\n      );\n    }\n    \n    // Otherwise, render children normally\n    return this.props.children;\n  }\n}\n```\n\n### Usage Example\n\n```typescript jsx\n// Using an error boundary around a component or a section of the UI\n<ErrorBoundary>\n  <MyProblematicComponent />\n</ErrorBoundary>\n\n// You can also wrap multiple components or even the entire application\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <h1>My Application</h1>\n      <MyHeader />\n      <MyContent />\n      <MyFooter />\n    </ErrorBoundary>\n  );\n}\n```\n\nBy placing an `ErrorBoundary` component around parts of your UI, you isolate potential errors. If `MyProblematicComponent` (or any of its descendants) throws an error during rendering, lifecycle methods, or constructors, the `ErrorBoundary` will catch it and display its fallback UI instead of crashing the whole application.",
      "examples": [
        {
          "id": "example_error_boundary_basic_usage",
          "title": "Basic Error Boundary and Usage",
          "code": "import React, { useState } from 'react';\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  errorInfo: React.ErrorInfo | null;\n}\n\ninterface ErrorBoundaryProps {\n  children: React.ReactNode;\n}\n\nclass ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  state: ErrorBoundaryState = { hasError: false, errorInfo: null };\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    console.log('Error caught by getDerivedStateFromError:', error.message);\n    return { hasError: true, errorInfo: null };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {\n    console.error('Error caught by componentDidCatch:', error, errorInfo);\n    this.setState({ errorInfo: errorInfo });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div style={{ padding: '20px', border: '1px solid red', color: 'red' }}>\n          <h3>Oops! Something went wrong in a child component.</h3>\n          {this.state.errorInfo && (\n            <details style={{ whiteSpace: 'pre-wrap' }}>\n              <summary>Error Details (Click to expand)</summary>\n              <pre>{this.state.errorInfo.componentStack}</pre>\n            </details>\n          )}\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n\nconst BuggyComponent: React.FC<{shouldThrow: boolean}> = ({ shouldThrow }) => {\n  if (shouldThrow) {\n    throw new Error('I am a simulated error from BuggyComponent!');\n  }\n  return <p>This component is working fine.</p>;\n};\n\nconst App: React.FC = () => {\n  const [showError, setShowError] = useState(false);\n\n  const triggerError = () => {\n    setShowError(true);\n  };\n\n  return (\n    <div>\n      <h1>Error Boundary Demo</h1>\n      <button onClick={triggerError}>Trigger Error</button>\n      \n      <ErrorBoundary>\n        <BuggyComponent shouldThrow={showError} />\n      </ErrorBoundary>\n\n      <p>Content outside the error boundary continues to work.</p>\n    </div>\n  );\n};\n\nexport default App;\n",
          "explanation": "This example demonstrates a complete `ErrorBoundary` component and how to use it. The `BuggyComponent` is designed to throw an error when `shouldThrow` is `true`. By wrapping `BuggyComponent` with `ErrorBoundary`, any error thrown inside `BuggyComponent` (or its descendants) is caught, and the `ErrorBoundary`'s fallback UI is rendered instead of crashing the entire `App`. The console logs show when `getDerivedStateFromError` and `componentDidCatch` are triggered.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Error Handling",
        "Class Components",
        "Component Lifecycle"
      ],
      "prerequisites": [
        "React_Class_Components",
        "React_State_and_Props",
        "React_Component_Lifecycle"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Error Handling",
      "Class Components",
      "Component Lifecycle"
    ],
    "prerequisites": [
      "React_Class_Components",
      "React_State_and_Props",
      "React_Component_Lifecycle"
    ]
  },
  {
    "index": 48,
    "id": "theory_lifecycle_best_practices",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Class Component Lifecycle Best Practices",
    "description": "",
    "content": {
      "id": "theory_lifecycle_best_practices",
      "title": "React Class Component Lifecycle Best Practices",
      "description": "",
      "type": "theory",
      "content": "React class components provide a set of lifecycle methods that allow you to execute code at specific points during a component's life: when it's created, updated, or destroyed. Understanding and correctly using these methods is crucial for building robust and performant React applications.\n\n## When to Make HTTP Requests\nIt is highly recommended to make HTTP requests inside the `componentDidMount` lifecycle method. This ensures that the component has been rendered to the DOM before the data fetching begins. Fetching data here prevents issues like trying to update state on an unmounted component or causing unnecessary re-renders during the initial render phase. It also guarantees that the data fetching only happens once when the component is initially mounted.\n\n## Updating State Based on Props\nDirectly using props to set state within `componentDidUpdate` without a condition can lead to infinite loops. This happens because `setState` triggers a re-render, which in turn calls `componentDidUpdate` again, creating a cycle. To avoid this, always compare current props (`this.props`) with previous props (`prevProps`) before updating state.\n\nFor deriving state from props, especially when the derived state needs to be re-calculated only when specific props change, `static getDerivedStateFromProps` is the appropriate lifecycle method. It is a static method, meaning it does not have access to `this` (the component instance), and it should return an object to update the state or `null` to indicate no state change. It's called right before `render`, on both initial mount and subsequent updates.\n\n## Optimizing Renders with `shouldComponentUpdate`\nBy default, React components re-render whenever their parent re-renders, or when their own state or props change. `shouldComponentUpdate` is a lifecycle method that allows you to control whether a component re-renders. It receives `nextProps` and `nextState` as arguments and should return `true` if the component should re-render, or `false` if it should not. This method is a powerful tool for performance optimization, especially for complex components or large lists, by preventing unnecessary re-renders. However, it requires careful implementation to avoid bugs from missed updates.",
      "examples": [
        {
          "id": "example_lifecycle_http_request",
          "title": "Making HTTP Requests in componentDidMount",
          "code": "import React, { Component } from 'react';\n\ninterface DataState {\n  data: any[] | null;\n  loading: boolean;\n  error: Error | null;\n}\n\nclass DataFetcher extends Component<{}, DataState> {\n  constructor(props: {}) {\n    super(props);\n    this.state = {\n      data: null,\n      loading: true,\n      error: null,\n    };\n  }\n\n  componentDidMount() {\n    console.log('ComponentDidMount: Fetching data...');\n    fetch('https://jsonplaceholder.typicode.com/posts?_limit=3')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then(data => {\n        this.setState({ data, loading: false });\n        console.log('Data fetched successfully:', data);\n      })\n      .catch(error => {\n        this.setState({ error, loading: false });\n        console.error('Error fetching data:', error);\n      });\n  }\n\n  render() {\n    const { data, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading data...</div>;\n    }\n    if (error) {\n      return <div>Error: {error.message}</div>;\n    }\n    if (!data || data.length === 0) {\n        return <div>No data available.</div>;\n    }\n\n    return (\n      <div>\n        <h2>Fetched Data:</h2>\n        <ul>\n          {data.map((item: any) => (\n            <li key={item.id}>{item.title}</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\n// Usage:\n// <DataFetcher />\n",
          "explanation": "This example demonstrates fetching data within `componentDidMount`. The component's `loading` state is set to `true` initially and then updated to `false` (along with the fetched data or error) once the fetch operation completes. This ensures the data is only fetched once the component is ready to display it, preventing unnecessary network requests or state updates during the initial render cycle.",
          "language": "typescript"
        },
        {
          "id": "example_lifecycle_update_props",
          "title": "Updating State from Props Safely (componentDidUpdate vs. getDerivedStateFromProps)",
          "code": "import React, { Component } from 'react';\n\ninterface Item {\n  id: number;\n  name: string;\n  active: boolean;\n}\n\ninterface FilteredListProps {\n  items: Item[];\n}\n\ninterface FilteredListState {\n  filteredItems: Item[];\n  prevItems: Item[] | null; // Used with getDerivedStateFromProps\n}\n\n// Approach 1: Using componentDidUpdate safely\nclass FilteredListA extends Component<FilteredListProps, FilteredListState> {\n  constructor(props: FilteredListProps) {\n    super(props);\n    this.state = {\n      filteredItems: this.props.items.filter(item => item.active),\n      prevItems: null\n    };\n  }\n\n  componentDidUpdate(prevProps: FilteredListProps) {\n    // GOOD: Check if props actually changed to avoid infinite loop\n    if (prevProps.items !== this.props.items) {\n      console.log('FilteredListA: Items prop changed, updating state via componentDidUpdate');\n      this.setState({\n        filteredItems: this.props.items.filter(item => item.active)\n      });\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Filtered List (componentDidUpdate)</h3>\n        <ul>\n          {this.state.filteredItems.map(item => (\n            <li key={item.id}>{item.name} (Active: {String(item.active)})</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\n// Approach 2: Using static getDerivedStateFromProps (Recommended for prop-derived state)\nclass FilteredListB extends Component<FilteredListProps, FilteredListState> {\n  constructor(props: FilteredListProps) {\n    super(props);\n    this.state = {\n      filteredItems: [], // Initial state, will be updated by getDerivedStateFromProps\n      prevItems: null,   // Store previous items to detect changes\n    };\n  }\n\n  static getDerivedStateFromProps(props: FilteredListProps, state: FilteredListState) {\n    // Check if the items prop has changed since the last render\n    if (props.items !== state.prevItems) {\n      console.log('FilteredListB: Items prop changed, deriving new state via getDerivedStateFromProps');\n      return {\n        filteredItems: props.items.filter(item => item.active),\n        prevItems: props.items, // Update prevItems for the next comparison\n      };\n    }\n    // No change in props, no state update needed\n    return null;\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Filtered List (getDerivedStateFromProps)</h3>\n        <ul>\n          {this.state.filteredItems.map(item => (\n            <li key={item.id}>{item.name} (Active: {String(item.active)})</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\n// Usage example (e.g., in a parent component):\n/*\nconst allItems = [\n  { id: 1, name: 'Apple', active: true },\n  { id: 2, name: 'Banana', active: false },\n  { id: 3, name: 'Cherry', active: true },\n];\n\n<FilteredListA items={allItems} />\n<FilteredListB items={allItems} />\n*/\n",
          "explanation": "This example compares two approaches for updating state based on prop changes. `FilteredListA` uses `componentDidUpdate` with a crucial `if (prevProps.items !== this.props.items)` check to prevent an infinite loop. `FilteredListB` uses the static `getDerivedStateFromProps`, which is the preferred way to derive state from props. It's a pure function that returns the new state object or `null` if no update is needed. Notice how `prevItems` is stored in state to track changes for `getDerivedStateFromProps`.",
          "language": "typescript"
        },
        {
          "id": "example_lifecycle_should_component_update",
          "title": "Optimizing Renders with shouldComponentUpdate",
          "code": "import React, { Component } from 'react';\n\ninterface OptimizableComponentProps {\n  id: number;\n  name: string;\n  value: number;\n}\n\ninterface OptimizableComponentState {\n  counter: number;\n}\n\nclass OptimizableComponent extends Component<OptimizableComponentProps, OptimizableComponentState> {\n  constructor(props: OptimizableComponentProps) {\n    super(props);\n    this.state = { counter: 0 };\n  }\n\n  shouldComponentUpdate(nextProps: OptimizableComponentProps, nextState: OptimizableComponentState): boolean {\n    // Only re-render if 'id' prop or 'counter' state changes.\n    // 'name' and 'value' prop changes will NOT trigger a re-render.\n    if (nextProps.id !== this.props.id || nextState.counter !== this.state.counter) {\n      console.log(`OptimizableComponent (${this.props.name}): Re-rendering due to relevant change.`);\n      return true;\n    }\n    console.log(`OptimizableComponent (${this.props.name}): Skipping re-render (no relevant change).`);\n    return false;\n  }\n\n  render() {\n    console.log(`OptimizableComponent (${this.props.name}): Rendered.`);\n    return (\n      <div style={{ border: '1px solid gray', padding: '10px', margin: '5px' }}>\n        <h4>Optimized Component: {this.props.name} (ID: {this.props.id})</h4>\n        <p>Prop Value: {this.props.value}</p>\n        <p>State Counter: {this.state.counter}</p>\n        <button onClick={() => this.setState(prevState => ({ counter: prevState.counter + 1 }))}>\n          Increment Counter\n        </button>\n      </div>\n    );\n  }\n}\n\n// Usage example (e.g., in a parent component):\n/*\ninterface AppState {\n    id: number;\n    name: string;\n    value: number;\n    triggerRender: boolean;\n}\n\nclass App extends Component<{}, AppState> {\n    state = {\n        id: 1,\n        name: 'Component A',\n        value: 10,\n        triggerRender: false,\n    };\n\n    render() {\n        return (\n            <div>\n                <button onClick={() => this.setState(prev => ({ value: prev.value + 1 }))}>\n                    Change Irrelevant Prop (Value)\n                </button>\n                <button onClick={() => this.setState(prev => ({ id: prev.id + 1 }))}>\n                    Change Relevant Prop (ID)\n                </button>\n                <OptimizableComponent id={this.state.id} name={this.state.name} value={this.state.value} />\n            </div>\n        );\n    }\n}\n*/\n",
          "explanation": "This example shows how `shouldComponentUpdate` can prevent unnecessary renders. The component only re-renders if its `id` prop or `counter` state changes. Changes to the `name` or `value` props will not trigger a re-render because they are explicitly ignored in the `shouldComponentUpdate` logic. This can significantly improve performance for components that receive frequently changing props, but only a subset of those props affects their visual output.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Class Components",
        "Lifecycle Methods",
        "componentDidMount",
        "componentDidUpdate",
        "getDerivedStateFromProps",
        "shouldComponentUpdate",
        "Performance Optimization",
        "State Management"
      ],
      "prerequisites": [
        "React Class Components",
        "State and Props",
        "JavaScript Promises/Fetch API"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Class Components",
      "Lifecycle Methods",
      "componentDidMount",
      "componentDidUpdate",
      "getDerivedStateFromProps",
      "shouldComponentUpdate",
      "Performance Optimization",
      "State Management"
    ],
    "prerequisites": [
      "React Class Components",
      "State and Props",
      "JavaScript Promises/Fetch API"
    ]
  },
  {
    "index": 49,
    "id": "theory_react_hooks_state_effects_memoization",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Hooks: State Management, Side Effects, and Memoization",
    "description": "",
    "content": {
      "id": "theory_react_hooks_state_effects_memoization",
      "title": "React Hooks: State Management, Side Effects, and Memoization",
      "description": "",
      "type": "theory",
      "content": "React Hooks are functions that let you \"hook into\" React state and lifecycle features from function components. They were introduced in React 16.8 to allow developers to use state and other React features without writing a class.\n\n## useState Hook\n`useState` is a Hook that lets you add React state to function components. It returns a pair: the current state value and a function that lets you update it. The update function is typically named `set[StateVariable]`. When the setter function is called, React re-renders the component.\n\n## useEffect Hook\n`useEffect` is a Hook that lets you perform side effects in function components. Side effects are operations that affect the world outside of the component, such as data fetching, subscriptions, or manually changing the DOM. `useEffect` runs after every render of the component by default, but its behavior can be controlled by a dependency array.\n\n*   **No dependency array**: The effect runs after every render, comparable to `componentDidMount` and `componentDidUpdate` combined.\n*   **Empty dependency array (`[]`)**: The effect runs only once after the initial render, and the cleanup function (if provided) runs only when the component unmounts. This is comparable to `componentDidMount` and `componentWillUnmount`.\n*   **Dependency array with values (`[dep1, dep2]`)**: The effect runs after the initial render and then only if any of the values in the dependency array change between renders. The cleanup function runs before the effect re-runs due to a dependency change, and when the component unmounts. This is comparable to `componentDidUpdate` for specific props/state.\n\n`useEffect` can optionally return a cleanup function. This function is called by React before the component unmounts, or before the effect re-runs (if dependencies change). This is crucial for cleaning up subscriptions, timers, or other resources to prevent memory leaks.\n\n### Handling Unmounted Components in useEffect\nWhen performing asynchronous operations (like data fetching) inside `useEffect`, it's possible that the component might unmount before the asynchronous operation completes. If the state update is attempted on an unmounted component, React will issue a warning or potentially cause errors. A common pattern to prevent this is to use a mutable flag (e.g., `isMounted`) that is set to `false` in the cleanup function. Before updating state, check the value of this flag.\n\n## useMemo Hook\n`useMemo` is a Hook that lets you memoize (cache) the result of a function computation. It returns a memoized value that is re-computed only when one of its dependencies has changed. This is useful for optimizing performance by avoiding expensive calculations on every render, especially when those calculations depend on values that don't change frequently. `useMemo` takes two arguments: a function that computes the value and a dependency array.\n\n### Relationship to Class Component Lifecycle Methods\n\n*   `useState` replaces `this.state` and `this.setState`.\n*   `useEffect` with an empty dependency array (`[]`) replaces `componentDidMount` for initial setup and `componentWillUnmount` for cleanup.\n*   `useEffect` with a dependency array (`[props.someValue]`) replaces `componentDidUpdate` for reacting to specific prop/state changes.\n*   `useMemo` can serve as a way to derive state from props or state efficiently, similar in concept to `getDerivedStateFromProps` in terms of deriving state, but for computed values rather than state itself, and without the associated pitfalls.\n",
      "examples": [
        {
          "id": "example_hooks_1",
          "title": "Basic useState and useEffect for Data Fetching",
          "code": "import React, { useState, useEffect } from 'react';\n\nfunction ProfilePage({ userId }) {\n  const [user, setUser] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    let isMounted = true; // Flag to track component mount status\n    setLoading(true); // Indicate loading state\n    setError(null); // Clear previous errors\n    \n    fetch(`/api/users/${userId}`)\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then(data => {\n        if (isMounted) { // Only update if component is still mounted\n          setUser(data);\n          setLoading(false);\n        }\n      })\n      .catch(err => {\n        if (isMounted) { // Only update if component is still mounted\n          setError(err);\n          setLoading(false);\n        }\n      });\n    \n    return () => {\n      isMounted = false; // Set flag to false when component unmounts or effect re-runs\n    };\n  }, [userId]); // Re-run effect when userId changes\n\n  const userNameDisplay = user ? `${user.firstName} ${user.lastName}` : 'Loading...';\n\n  if (loading) return <div>Loading user profile...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  \n  return (\n    <div>\n      <h2>{userNameDisplay}</h2>\n      <div>Email: {user.email}</div>\n    </div>\n  );\n}",
          "explanation": "This example demonstrates `useState` for managing `user`, `error`, and `loading` states. `useEffect` is used for data fetching; it runs when `userId` changes. The `isMounted` flag in the `useEffect`'s closure prevents state updates on an unmounted component, which is a common best practice for async operations in effects. The cleanup function sets `isMounted` to `false` when the component unmounts or when the effect re-runs due to `userId` changing.",
          "language": "javascript"
        },
        {
          "id": "example_hooks_2",
          "title": "Using useMemo for Memoized Calculations",
          "code": "import React, { useState, useMemo } from 'react';\n\nfunction ProductDisplay({ price, quantity }) {\n  const [discount, setDiscount] = useState(0.1);\n\n  // Calculate total price only when price, quantity, or discount change\n  const totalCost = useMemo(() => {\n    console.log('Calculating total cost...');\n    return (price * quantity) * (1 - discount);\n  }, [price, quantity, discount]);\n\n  return (\n    <div>\n      <p>Price per item: ${price}</p>\n      <p>Quantity: {quantity}</p>\n      <p>Discount: {discount * 100}%</p>\n      <h3>Total Cost: ${totalCost.toFixed(2)}</h3>\n      <button onClick={() => setDiscount(prev => prev === 0.1 ? 0.2 : 0.1)}>Toggle Discount</button>\n      <button onClick={() => console.log('Component re-rendered without total cost recalculation')}>Force Re-render (Check Console)</button>\n    </div>\n  );\n}",
          "explanation": "This example uses `useMemo` to calculate `totalCost`. The calculation only re-runs if `price`, `quantity`, or `discount` change. If the `ProductDisplay` component re-renders for other reasons (e.g., a parent component re-renders), the `totalCost` calculation is skipped unless its dependencies have changed, improving performance. The console log helps observe when the calculation actually occurs.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Hooks",
        "useState",
        "useEffect",
        "useMemo",
        "Side Effects",
        "Memoization",
        "Data Fetching",
        "Functional Components",
        "Lifecycle"
      ],
      "prerequisites": [
        "JavaScript_basics",
        "React_components",
        "Promises"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Hooks",
      "useState",
      "useEffect",
      "useMemo",
      "Side Effects",
      "Memoization",
      "Data Fetching",
      "Functional Components",
      "Lifecycle"
    ],
    "prerequisites": [
      "JavaScript_basics",
      "React_components",
      "Promises"
    ]
  },
  {
    "index": 51,
    "id": "theory_react_testing_best_practices",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Component Testing Best Practices",
    "description": "",
    "content": {
      "id": "theory_react_testing_best_practices",
      "title": "React Component Testing Best Practices",
      "description": "",
      "type": "theory",
      "content": "Testing React components effectively ensures their reliability and maintainability. It's crucial to focus on robust testing practices.\n\n## Snapshot Testing\nSnapshot testing, often used with libraries like Jest and React Test Renderer, captures the rendered output of a component and compares it to a previously saved snapshot. If the new output differs, the test fails, indicating an unintentional change or requiring an update to the snapshot. It's useful for ensuring UI consistency.\n\n## Core Testing Best Practices\n1.  **Test behavior, not implementation**: Focus on *what* the component does and its observable outputs, rather than its internal methods or state management. This makes tests more resilient to refactoring.\n2.  **Use `data-testid` for test selectors**: Relying on CSS classes or IDs for selecting elements in tests can lead to brittle tests, as these might change for styling or refactoring purposes. `data-testid` attributes are specifically for testing and provide stable selectors.\n3.  **Mock external dependencies**: Isolate your component tests by mocking any external APIs, services, or modules (e.g., network requests, third-party libraries). This ensures tests are fast, deterministic, and only fail due to issues within the component under test.\n4.  **Test edge cases**: Thoroughly test your components with various scenarios, including empty states (e.g., empty arrays passed as props), error states (e.g., API call failure), and boundary conditions (e.g., minimum/maximum input values). This helps uncover unexpected bugs.\n5.  **Keep tests fast**: Slow tests discourage developers from running them frequently. Optimize test performance by avoiding unnecessary complex setups, limiting the scope of tests, and effectively mocking dependencies.",
      "examples": [
        {
          "id": "example_testing_snapshot",
          "title": "Basic Snapshot Test",
          "code": "import renderer from 'react-test-renderer';\nimport Button from './Button';\n\ntest('Button component renders correctly', () => {\n  const component = renderer.create(\n    <Button text=\"Click me\" onClick={() => {}} />\n  );\n  let tree = component.toJSON();\n  expect(tree).toMatchSnapshot();\n});",
          "explanation": "This example demonstrates a basic snapshot test for a `Button` component using `react-test-renderer` and Jest. The rendered component is serialized to a JSON snapshot file, and `toMatchSnapshot()` asserts that future renders match this saved snapshot, ensuring UI consistency.",
          "language": "typescript"
        },
        {
          "id": "example_testing_data_testid",
          "title": "Using data-testid for Selection",
          "code": "import { render, screen, fireEvent } from '@testing-library/react';\nimport React from 'react';\n\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)} data-testid=\"increment-button\">Increment</button>\n      <p data-testid=\"count-display\">Count: {count}</p>\n    </div>\n  );\n}\n\ntest('Counter increments count on button click', () => {\n  render(<Counter />);\n  const button = screen.getByTestId('increment-button');\n  const countDisplay = screen.getByTestId('count-display');\n  \n  fireEvent.click(button);\n  expect(countDisplay).toHaveTextContent('Count: 1');\n});",
          "explanation": "This example illustrates the use of `data-testid` for reliably selecting elements in tests with `@testing-library/react`. Elements are given `data-testid` attributes, which are then used with `screen.getByTestId` to locate them, making tests resilient to changes in CSS classes or element structure.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "testing",
        "react",
        "jest",
        "react-testing-library",
        "best-practices",
        "snapshot-testing"
      ],
      "prerequisites": [
        "react_basics",
        "javascript_fundamentals"
      ],
      "technology": "React"
    },
    "tags": [
      "testing",
      "react",
      "jest",
      "react-testing-library",
      "best-practices",
      "snapshot-testing"
    ],
    "prerequisites": [
      "react_basics",
      "javascript_fundamentals"
    ]
  },
  {
    "index": 52,
    "id": "theory_react_performance_hooks",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Performance Optimization with useMemo and useCallback",
    "description": "",
    "content": {
      "id": "theory_react_performance_hooks",
      "title": "React Performance Optimization with useMemo and useCallback",
      "description": "",
      "type": "theory",
      "content": "## Introduction to React Performance Hooks\nIn React, components re-render when their state or props change. While React is generally efficient, unnecessary re-renders of expensive computations or re-creation of callback functions can impact application performance, especially in large or frequently updated component trees. React provides `useMemo` and `useCallback` hooks to help optimize functional components by memoizing values and functions.\n\n## useMemo Hook\n`useMemo` is a React Hook that lets you cache the result of an expensive calculation between re-renders. It takes two arguments: a 'create' function and a dependency array. The 'create' function will only re-run if one of the dependencies in the array has changed. If the dependencies are the same as in the last render, `useMemo` returns the cached value.\n\n### When to use useMemo:\n-   **Expensive Calculations:** When you have a function that performs a computationally intensive task (e.g., heavy filtering, sorting, or data transformation) and its result is only needed when its inputs change.\n-   **Referential Equality:** When passing objects or arrays as props to child components that are wrapped in `React.memo`. `React.memo` performs a shallow comparison of props; if an object/array prop is re-created on every render (even if its content is the same), `React.memo` will see it as a new prop and trigger a re-render of the child. `useMemo` helps maintain referential equality.\n\n```typescript\nimport React, { useMemo } from 'react';\n\nfunction ComponentWithExpensiveCalculation({ data, filterCriteria }) {\n  // This calculation will only re-run if 'data' or 'filterCriteria' changes.\n  const filteredData = useMemo(() => {\n    console.log('Performing expensive filtering...');\n    return data.filter(item => item.includes(filterCriteria));\n  }, [data, filterCriteria]);\n\n  return (\n    <div>\n      {filteredData.map((item, index) => <p key={index}>{item}</p>)}\n    </div>\n  );\n}\n```\n\n## useCallback Hook\n`useCallback` is a React Hook that lets you cache a function definition between re-renders. Like `useMemo`, it takes a function and a dependency array. It returns a memoized version of the callback function that only changes if one of the dependencies has changed. This is particularly useful when passing callbacks to optimized child components.\n\n### When to use useCallback:\n-   **Preventing Unnecessary Re-renders of Child Components:** When a parent component re-renders, any functions defined within it are re-created. If these functions are passed as props to child components (especially those optimized with `React.memo`), the child components will re-render because the prop (the function) is technically a new reference. `useCallback` ensures the function reference remains the same unless its dependencies change.\n-   **Optimizing Event Handlers:** Memoizing event handlers prevents them from being re-created on every render, which can be beneficial when passing them to many child elements or when they are part of a dependency array for another hook (like `useEffect`).\n\n```typescript\nimport React, { useState, useCallback, memo } from 'react';\n\nconst Button = memo(({ onClick, label }) => {\n  console.log(`Button '${label}' rendered`);\n  return <button onClick={onClick}>{label}</button>;\n});\n\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n\n  // This function will not be re-created on every render\n  // unless 'count' changes.\n  const increment = useCallback(() => {\n    setCount(prevCount => prevCount + 1);\n  }, []); // Empty dependency array means it's created once\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <Button onClick={increment} label=\"Increment\" />\n      <button onClick={() => setCount(count + 1)}>Direct Increment</button>\n    </div>\n  );\n}\n```\n\n## Key Differences and Considerations\n-   `useMemo` memoizes a **value** returned by a function.\n-   `useCallback` memoizes a **function** itself.\n-   Both require a dependency array. An empty array `[]` means the memoized value/function will only be created once on the initial render.\n-   Overuse of `useMemo` and `useCallback` can introduce unnecessary overhead. They should be used strategically where actual performance bottlenecks are identified or when dealing with referential equality issues for `React.memo`'d components.",
      "examples": [
        {
          "id": "example_react_performance_hooks_1",
          "title": "Basic useMemo for Filtering",
          "code": "import React, { useState, useMemo } from 'react';\n\ninterface Item {\n  id: number;\n  name: string;\n  category: string;\n}\n\ninterface SearchResultsProps {\n  items: Item[];\n  query: string;\n}\n\nfunction SearchResults({ items, query }: SearchResultsProps) {\n  const filteredItems = useMemo(() => {\n    console.log('Filtering items...'); // This log helps identify re-runs\n    if (!query) return items;\n    return items.filter(item => \n      item.name.toLowerCase().includes(query.toLowerCase())\n    );\n  }, [items, query]); // Recalculate only when items or query changes\n  \n  return (\n    <div>\n      <h2>Search Results for \"{query}\"</h2>\n      <ul>\n        {filteredItems.map(item => (\n          <li key={item.id}>{item.name} ({item.category})</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// Example Usage (for demonstration, not part of the component itself)\nfunction App() {\n  const allItems: Item[] = [\n    { id: 1, name: 'Apple', category: 'Fruit' },\n    { id: 2, name: 'Banana', category: 'Fruit' },\n    { id: 3, name: 'Carrot', category: 'Vegetable' },\n    { id: 4, name: 'Broccoli', category: 'Vegetable' },\n  ];\n  const [searchQuery, setSearchQuery] = useState('');\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Search items...\"\n        value={searchQuery}\n        onChange={(e) => setSearchQuery(e.target.value)}\n      />\n      <SearchResults items={allItems} query={searchQuery} />\n    </div>\n  );\n}\n",
          "explanation": "This example demonstrates `useMemo` for an `items` filtering operation. The `console.log` inside `useMemo` helps visualize when the filtering function re-executes. It will only re-run if `items` or `query` changes, preventing redundant filtering when other state in the `SearchResults` component or its parent causes a re-render.",
          "language": "typescript"
        },
        {
          "id": "example_react_performance_hooks_2",
          "title": "Basic useCallback for Event Handlers",
          "code": "import React, { useState, useCallback } from 'react';\n\ninterface Item {\n  id: number;\n  name: string;\n}\n\ninterface SearchResultsProps {\n  items: Item[];\n  query: string;\n}\n\nfunction SearchResults({ items, query }: SearchResultsProps) {\n  const filteredItems = useMemo(() => {\n    console.log('Filtering items...');\n    return items.filter(item => \n      item.name.toLowerCase().includes(query.toLowerCase())\n    );\n  }, [items, query]);\n  \n  // Memoize callback functions\n  const handleItemClick = useCallback((id: number) => {\n    console.log('Item clicked:', id);\n    // In a real application, this would dispatch an action, navigate, etc.\n  }, []); // Empty dependency array ensures this function reference never changes\n  \n  return (\n    <ul>\n      {filteredItems.map(item => (\n        <li key={item.id} onClick={() => handleItemClick(item.id)}>\n          {item.name}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Example Usage (for demonstration)\nfunction App() {\n  const allItems: Item[] = [\n    { id: 1, name: 'Laptop', },\n    { id: 2, name: 'Mouse', },\n    { id: 3, name: 'Keyboard', },\n  ];\n  const [searchQuery, setSearchQuery] = useState('');\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Search items...\"\n        value={searchQuery}\n        onChange={(e) => setSearchQuery(e.target.value)}\n      />\n      <SearchResults items={allItems} query={searchQuery} />\n    </div>\n  );\n}\n",
          "explanation": "This example shows `useCallback` used to memoize the `handleItemClick` function. By providing an empty dependency array (`[]`), this function is created only once during the initial render. This is crucial if `SearchResults` passes `handleItemClick` to a `React.memo` optimized child component, as it prevents the child from re-rendering due to a new function reference being passed down.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Hooks",
        "useMemo",
        "useCallback",
        "Performance",
        "Optimization",
        "Frontend"
      ],
      "prerequisites": [
        "React_Functional_Components",
        "React_State_Hooks",
        "JavaScript_Closures"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Hooks",
      "useMemo",
      "useCallback",
      "Performance",
      "Optimization",
      "Frontend"
    ],
    "prerequisites": [
      "React_Functional_Components",
      "React_State_Hooks",
      "JavaScript_Closures"
    ]
  },
  {
    "index": 57,
    "id": "theory_use_fetch_hook",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "Understanding the useFetch Hook for Asynchronous Data",
    "description": "",
    "content": {
      "id": "theory_use_fetch_hook",
      "title": "Understanding the useFetch Hook for Asynchronous Data",
      "description": "",
      "type": "theory",
      "content": "The `useFetch` custom hook is designed to simplify data fetching logic within React components, abstracting away the complexities of `useState` and `useEffect` for managing loading, error, and data states. This hook encapsulates the common pattern of making API requests, providing a reusable and clean interface.\n\n## Key Concepts\n*   **State Management:** It internally uses `useState` to manage three crucial pieces of state: `data` (for the fetched payload), `loading` (a boolean indicating if a request is in progress), and `error` (for any errors encountered during the fetch).\n*   **Side Effects with `useEffect`:** The actual data fetching logic is housed within a `useEffect` hook. This ensures the fetch operation runs when the component mounts and re-runs if any of its dependencies (`url`, `options`) change.\n*   **Dependency Array:** The `useEffect`'s dependency array `[url, options]` ensures that the fetch operation is re-triggered only when the URL or fetch options change. It's crucial to correctly manage dependencies to prevent unnecessary re-fetches or stale data.\n*   **Asynchronous Operations:** The `fetchData` function is asynchronous (`async/await`) to handle the promise-based nature of the `fetch` API. It wraps the `fetch` call in a `try-catch` block to gracefully handle network errors or invalid responses.\n*   **Preventing Memory Leaks (`isMounted`):** A critical aspect of this `useFetch` implementation is the `isMounted` flag. This boolean variable, initialized to `true` and set to `false` in the `useEffect`'s cleanup function, prevents state updates on an unmounted component. This avoids the common React warning: \"Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application.\" This is particularly important for slow network requests where the component might unmount before the fetch promise resolves.\n*   **Abstraction and Reusability:** By encapsulating the fetching logic into a custom hook, components using `useFetch` become cleaner and more focused on rendering data rather than managing fetch lifecycle.\n\n## Implementation Details\nThe hook returns an object `{ data, loading, error }`, making it easy for consuming components to access the current state of the data fetching operation. The `options` parameter allows for flexibility in configuring the `fetch` request, such as setting HTTP methods, headers, or body for POST/PUT requests.\n\nWhen `options` is an object, it's important to memoize it (e.g., using `useMemo` in the calling component) if it's not a primitive, to prevent the `useEffect` from re-running on every render due to reference equality changes, even if the content of the options object is conceptually the same.\n\n",
      "examples": [
        {
          "id": "example_use_fetch_basic",
          "title": "Basic useFetch Hook Implementation",
          "code": "import { useState, useEffect } from 'react';\n\nfunction useFetch(url, options) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let isMounted = true; // Flag to prevent state updates on unmounted component\n\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      try {\n        const response = await fetch(url, options);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const result = await response.json();\n        if (isMounted) {\n          setData(result);\n        }\n      } catch (e) {\n        if (isMounted) {\n          setError(e.message);\n        }\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    fetchData();\n\n    return () => {\n      isMounted = false; // Set to false on unmount\n    };\n  }, [url, options]); // Re-run effect when url or options change\n\n  return { data, loading, error };\n}",
          "explanation": "This code defines the `useFetch` hook. It initializes `data`, `loading`, and `error` states. The `useEffect` hook performs the asynchronous data fetch. The `isMounted` flag is a crucial pattern to prevent memory leaks and 'Can't perform a React state update on an unmounted component' warnings, ensuring state is only updated if the component is still mounted. The `finally` block ensures `setLoading(false)` is called whether the fetch succeeds or fails. The hook returns an object with the current data, loading status, and any error.",
          "language": "typescript"
        },
        {
          "id": "example_use_fetch_usage",
          "title": "Usage of useFetch Hook",
          "code": "import React from 'react';\n// Assume useFetch is imported from the file above\n\nfunction UserProfile({ userId }) {\n  const { data, loading, error } = useFetch(\n    `https://api.example.com/users/${userId}`\n  );\n\n  if (loading) return <div>Loading user profile...</div>;\n  if (error) return <div>Error loading user: {error}</div>;\n  if (!data) return <div>No user data found.</div>; // Handle case where data is null initially or after error\n\n  return (\n    <div>\n      <h2>{data.name}</h2>\n      <p>Email: {data.email}</p>\n      <p>ID: {userId}</p>\n    </div>\n  );\n}",
          "explanation": "This `UserProfile` component demonstrates how to consume the `useFetch` hook. It destructurizes `data`, `loading`, and `error` from the hook's return value. Based on the `loading` and `error` states, it renders different UI feedback. Once data is successfully fetched and available, it renders the user's name and email.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Hooks",
        "useEffect",
        "useState",
        "Data Fetching",
        "Asynchronous",
        "API Integration",
        "Custom Hooks",
        "Error Handling",
        "Loading States",
        "Memory Leaks"
      ],
      "prerequisites": [
        "useState",
        "useEffect",
        "Asynchronous JavaScript (Promises, async/await)",
        "Fetch API"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Hooks",
      "useEffect",
      "useState",
      "Data Fetching",
      "Asynchronous",
      "API Integration",
      "Custom Hooks",
      "Error Handling",
      "Loading States",
      "Memory Leaks"
    ],
    "prerequisites": [
      "useState",
      "useEffect",
      "Asynchronous JavaScript (Promises, async/await)",
      "Fetch API"
    ]
  },
  {
    "index": 59,
    "id": "theory_react_context_reducer_hooks",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "State Management with React Context, useReducer, and Custom Hooks",
    "description": "",
    "content": {
      "id": "theory_react_context_reducer_hooks",
      "title": "State Management with React Context, useReducer, and Custom Hooks",
      "description": "",
      "type": "theory",
      "content": "This section explores a common and powerful pattern for managing state in React applications using a combination of the Context API, the `useReducer` hook, and custom hooks. This pattern is particularly useful for global or shared state that needs to be accessed by multiple components without prop drilling.\n\n## React Context API\nReact's Context API provides a way to pass data through the component tree without having to pass props down manually at every level. It's designed to share data that can be considered 'global' for a tree of React components, such as the current authenticated user, theme, or preferred language.\n\n-   **`React.createContext(defaultValue)`**: Creates a Context object. When React renders a component that subscribes to this Context object, it will read the current context value from the closest matching Provider above it in the tree.\n-   **`Context.Provider`**: A React component that allows consuming components to subscribe to context changes. It accepts a `value` prop to be passed to consuming components that are descendants of this Provider.\n-   **`useContext(ContextObject)`**: A React Hook that accepts a context object (the value returned from `React.createContext`) and returns the current context value for that context. It subscribes the component to context changes.\n\n## `useReducer` Hook\nThe `useReducer` hook is an alternative to `useState` for more complex state logic, especially when the state logic involves multiple sub-values or when the next state depends on the previous one. It's conceptually similar to Redux.\n\n-   **`const [state, dispatch] = useReducer(reducer, initialArg, init?)`**: Returns the current state and a `dispatch` function. `useReducer` is often preferred over `useState` when you have complex state transitions, or when the next state depends on the previous one.\n-   **`reducer(state, action)`**: A pure function that takes the current `state` and an `action` object, and returns the `newState`.\n-   **`action`**: An object, conventionally with a `type` property (a string) indicating the type of action performed, and an optional `payload` property containing any data needed for the state update.\n-   **`dispatch`**: A function returned by `useReducer` that you call to dispatch actions. Dispatching an action causes the reducer function to be executed with the current state and the given action, and the component re-renders with the new state.\n\n## Custom Hooks\nCustom hooks are JavaScript functions whose names start with 'use' and that can call other hooks. They allow you to extract reusable stateful logic from components. This promotes code reusability, testability, and better organization.\n\nWhen `Context`, `useReducer`, and custom hooks are combined, you can create a robust and scalable state management solution:\n1.  **Define Reducer**: Create a `reducer` function that defines how the state changes based on different actions.\n2.  **Create Context**: Create a `Context` object using `React.createContext`.\n3.  **Implement Provider**: Create a `Provider` component that wraps its children with `Context.Provider` and manages the state using `useReducer`. It passes the `state` and `dispatch` function down through the context `value`.\n4.  **Create Custom Hook**: Create a custom hook (e.g., `useTodo`) that uses `useContext` to consume the `state` and `dispatch` from the `Provider`, making it easy for any component to access the shared state and dispatch actions.\n\nThis pattern centralizes state logic, avoids prop drilling, and provides a clean API for components to interact with the global state.",
      "examples": [
        {
          "id": "example_todo_reducer",
          "title": "Todo Reducer Function",
          "code": "const ADD_TODO = 'ADD_TODO';\nconst TOGGLE_TODO = 'TOGGLE_TODO';\nconst REMOVE_TODO = 'REMOVE_TODO';\n\nfunction todoReducer(state, action) {\n  switch (action.type) {\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          id: Date.now(), // Simple unique ID\n          text: action.payload,\n          completed: false,\n        },\n      ];\n    case TOGGLE_TODO:\n      return state.map(todo =>\n        todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo\n      );\n    case REMOVE_TODO:\n      return state.filter(todo => todo.id !== action.payload);\n    default:\n      return state;\n  }\n}",
          "explanation": "This `todoReducer` function defines the state transitions for our todo application. It takes the current `state` (an array of todo objects) and an `action` object. Based on the `action.type`, it returns a new state array. For `ADD_TODO`, it adds a new todo item. For `TOGGLE_TODO`, it flips the `completed` status of a specific todo. For `REMOVE_TODO`, it filters out a todo by its ID. It's crucial that the reducer always returns a new state object/array, not mutates the existing one.",
          "language": "javascript"
        },
        {
          "id": "example_todo_context_provider_hook",
          "title": "Todo Context, Provider, and Custom Hook",
          "code": "import React, { createContext, useReducer, useContext } from 'react';\n\n// 1. Define Context\nconst TodoContext = createContext(null);\n\n// 2. Define Reducer (as shown in previous example)\nconst ADD_TODO = 'ADD_TODO';\nconst TOGGLE_TODO = 'TOGGLE_TODO';\nconst REMOVE_TODO = 'REMOVE_TODO';\n\nfunction todoReducer(state, action) {\n  switch (action.type) {\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          id: Date.now(),\n          text: action.payload,\n          completed: false,\n        },\n      ];\n    case TOGGLE_TODO:\n      return state.map(todo =>\n        todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo\n      );\n    case REMOVE_TODO:\n      return state.filter(todo => todo.id !== action.payload);\n    default:\n      return state;\n  }\n}\n\n// 3. Implement Provider Component\nexport function TodoProvider({ children }) {\n  const [todos, dispatch] = useReducer(todoReducer, []); // Initial state is an empty array\n\n  return (\n    <TodoContext.Provider value={{ todos, dispatch }}>\n      {children}\n    </TodoContext.Provider>\n  );\n}\n\n// 4. Create Custom Hook to consume context\nexport function useTodo() {\n  const context = useContext(TodoContext);\n  if (context === null) {\n    throw new Error('useTodo must be used within a TodoProvider');\n  }\n  return context;\n}\n",
          "explanation": "This example showcases the full setup: `TodoContext` is created. `TodoProvider` uses `useReducer` to manage the `todos` state and `dispatch` function, then passes them down via `TodoContext.Provider`. The `useTodo` custom hook simplifies consuming this context from any child component, abstracting away the `useContext` call and adding a useful error check for incorrect usage.",
          "language": "javascript"
        },
        {
          "id": "example_todo_components",
          "title": "Components Using the Todo State",
          "code": "import React from 'react';\nimport { useTodo, ADD_TODO, TOGGLE_TODO, REMOVE_TODO } from './TodoContext'; // Assuming previous file is TodoContext.js\n\n// TodoItem component\nfunction TodoItem({ todo }) {\n  const { dispatch } = useTodo();\n  \n  return (\n    <li>\n      <span\n        style={{ textDecoration: todo.completed ? 'line-through' : 'none', cursor: 'pointer' }}\n        onClick={() => dispatch({ type: TOGGLE_TODO, payload: todo.id })}\n      >\n        {todo.text}\n      </span>\n      <button onClick={() => dispatch({ type: REMOVE_TODO, payload: todo.id })}>Remove</button>\n    </li>\n  );\n}\n\n// TodoList component\nfunction TodoList() {\n  const { todos } = useTodo();\n\n  return (\n    <ul>\n      {todos.map(todo => (\n        <TodoItem key={todo.id} todo={todo} />\n      ))}\n    </ul>\n  );\n}\n\n// AddTodo component\nfunction AddTodo() {\n  const { dispatch } = useTodo();\n  const [text, setText] = React.useState('');\n  \n  const handleSubmit = e => {\n    e.preventDefault();\n    if (text.trim()) {\n      dispatch({ type: ADD_TODO, payload: text });\n      setText('');\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        value={text}\n        onChange={e => setText(e.target.value)}\n        placeholder=\"Add todo...\"\n      />\n      <button type=\"submit\">Add</button>\n    </form>\n  );\n}\n\n// App component using the custom hook pattern\nfunction TodoApp() {\n  return (\n    <TodoProvider>\n      <h1>Todo App</h1>\n      <AddTodo />\n      <TodoList />\n    </TodoProvider>\n  );\n}\n",
          "explanation": "These components demonstrate how to consume the shared state and dispatch actions using the `useTodo` custom hook. `TodoList` simply displays todos, `AddTodo` dispatches `ADD_TODO` actions, and `TodoItem` dispatches `TOGGLE_TODO` and `REMOVE_TODO` actions. `TodoApp` wraps the entire application with `TodoProvider`, making the todo state available to all its descendants.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Hooks",
        "Context API",
        "useReducer",
        "State Management",
        "Custom Hooks",
        "Redux Pattern"
      ],
      "prerequisites": [
        "react_functional_components",
        "react_hooks_useState_useEffect"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Hooks",
      "Context API",
      "useReducer",
      "State Management",
      "Custom Hooks",
      "Redux Pattern"
    ],
    "prerequisites": [
      "react_functional_components",
      "react_hooks_useState_useEffect"
    ]
  },
  {
    "index": 60,
    "id": "theory_react_portals",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Portals: Rendering Children Outside Parent Hierarchy",
    "description": "",
    "content": {
      "id": "theory_react_portals",
      "title": "React Portals: Rendering Children Outside Parent Hierarchy",
      "description": "",
      "type": "theory",
      "content": "React Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component. Normally, a component's render method returns JSX that React then renders as a child of the current component's DOM node. However, sometimes it's necessary for a child to break out of its parent's DOM structure.\n\n## Why and When to Use Portals\n\nPortals are particularly useful for components that need to visually \"escape\" their parent's styling, `overflow: hidden` properties, or `z-index` stacking contexts. Common use cases include:\n\n*   **Modal Dialogs:** A modal needs to overlay the entire page, often requiring a high `z-index` and not being affected by parent `overflow` styles.\n*   **Tooltips and Popovers:** These often need to appear directly next to a trigger element but overlay other content, which can be tricky if the trigger is inside a constrained container.\n*   **Floating Menus/Context Menus:** Similar to tooltips, these need to appear above other content.\n*   **Widgets that Break Out of Containers:** Any component that needs to render its UI independently of its parent's clipping or positioning.\n\nWithout portals, achieving these effects often requires complex CSS (e.g., `position: fixed` with explicit `top`, `left`, `z-index`) or imperative DOM manipulation, which goes against React's declarative nature.\n\n## How Portals Work\n\nA portal is created using `ReactDOM.createPortal()`. It takes two arguments:\n\n1.  `child`: Any renderable React child (e.g., a React element, string, fragment).\n2.  `container`: A DOM element (a reference to an existing DOM node) where the `child` will be mounted.\n\nDespite being rendered into a different DOM node, the portal's content still behaves like a normal React child. It remains part of the *React component tree*, meaning:\n\n*   **Event Bubbling:** Events from inside the portal will bubble up to ancestor components in the *React component tree*, not necessarily the DOM tree. This is a powerful feature, as it means you can still use React's event system as usual.\n*   **Context API:** Context will still flow down from providers in the parent React tree to consumers within the portal.\n\nThis behavior makes portals a powerful tool for solving specific layout and layering problems while maintaining the benefits of React's component model.",
      "examples": [
        {
          "id": "example_react_portal_modal",
          "title": "Implementing a Modal using React Portal",
          "code": "import React, { useState, useEffect, useRef } from 'react';\nimport ReactDOM from 'react-dom';\n\n// Create a dedicated DOM node for modals outside the root app element in public/index.html\n// <div id=\"modal-root\"></div>\n\nconst Modal = ({ children, isOpen, onClose }) => {\n  const modalRootRef = useRef(null);\n\n  // Ensure the modal root element exists and cache it\n  useEffect(() => {\n    modalRootRef.current = document.getElementById('modal-root') || document.createElement('div');\n    if (!document.getElementById('modal-root')) {\n      modalRootRef.current.id = 'modal-root';\n      document.body.appendChild(modalRootRef.current);\n    }\n  }, []);\n\n  if (!isOpen || !modalRootRef.current) return null;\n\n  return ReactDOM.createPortal(\n    <div style={{\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0,\n      backgroundColor: 'rgba(0,0,0,0.5)',\n      display: 'flex',\n      justifyContent: 'center',\n      alignItems: 'center',\n      zIndex: 1000 // High z-index to overlay everything\n    }} onClick={onClose}>\n      <div style={{\n        backgroundColor: 'white',\n        padding: '20px',\n        borderRadius: '8px',\n        minWidth: '300px',\n        boxShadow: '0 4px 8px rgba(0,0,0,0.2)',\n        zIndex: 1001 // Higher z-index for modal content\n      }} onClick={e => e.stopPropagation()}>\n        {children}\n        <button onClick={onClose} style={{ marginTop: '20px' }}>Close Modal</button>\n      </div>\n    </div>,\n    modalRootRef.current // The DOM node where the modal content will be rendered\n  );\n};\n\nfunction AppWithModal() {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  return (\n    <div style={{ padding: '20px', height: '150vh', overflow: 'hidden', border: '1px solid gray' }}>\n      <h1>My Application Content</h1>\n      <p>This is some content that might be hidden by overflow rules.</p>\n      <button onClick={() => setIsModalOpen(true)}>Open Modal</button>\n\n      <Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}>\n        <h2>This is a Portal Modal</h2>\n        <p>This content is rendered outside the main app DOM hierarchy.</p>\n      </Modal>\n\n      <p>More content below the fold...</p>\n    </div>\n  );\n}",
          "explanation": "This example shows a `Modal` component implemented using `ReactDOM.createPortal`. The `Modal` component receives `children`, `isOpen`, and `onClose` props. Inside the `Modal`, `ReactDOM.createPortal` renders its children into a specific DOM node (`modal-root`), which is typically a `div` element placed directly under the `<body>` tag in `public/index.html`. This allows the modal to appear above all other content, unaffected by its parent's styling properties like `overflow: hidden`, while still participating in React's event bubbling and context systems.",
          "language": "javascript"
        }
      ],
      "complexity": 8,
      "tags": [
        "React",
        "DOM",
        "Rendering",
        "Modals",
        "Tooltips",
        "UX",
        "Advanced React"
      ],
      "prerequisites": [
        "react_basics",
        "dom_manipulation"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "DOM",
      "Rendering",
      "Modals",
      "Tooltips",
      "UX",
      "Advanced React"
    ],
    "prerequisites": [
      "react_basics",
      "dom_manipulation"
    ]
  },
  {
    "index": 62,
    "id": "theory_react_router_v6_navigation",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Router v6 Navigation Essentials",
    "description": "",
    "content": {
      "id": "theory_react_router_v6_navigation",
      "title": "React Router v6 Navigation Essentials",
      "description": "",
      "type": "theory",
      "content": "React Router v6 introduces streamlined APIs for navigation, moving away from some older concepts in v5. The core components for navigation remain `Link` and `NavLink`, while programmatic navigation is handled exclusively via the `useNavigate` hook.\n\n## Key Components and Hooks:\n\n### 1. `Link` Component\n- The `Link` component is the primary way to enable client-side navigation within a React application.\n- It renders an `<a>` tag in the DOM, but it prevents the default browser behavior of a full page reload.\n- Instead of reloading, it uses React Router to update the URL and render the corresponding component without a full page refresh, making the user experience faster and smoother.\n- **Usage:** `<Link to=\"/path\">Link Text</Link>`\n\n### 2. `NavLink` Component\n- `NavLink` is a special version of `Link` that is designed to add styling attributes to the rendered element when it matches the current URL.\n- This is particularly useful for navigation menus where you want to highlight the currently active link.\n- **Active Styling in v6:** Unlike `v5`'s `activeClassName`, `NavLink` in `v6` uses a functional `style` or `className` prop to determine active status. This function receives an object `{ isActive: boolean }` as an argument.\n- **Usage (with functional style):**\n```jsx\n<NavLink to=\"/about\" style={({ isActive }) => isActive ? { fontWeight: 'bold', color: 'blue' } : undefined}>\n  About\n</NavLink>\n```\n- **Usage (with functional className):**\n```jsx\n<NavLink to=\"/dashboard\" className={({ isActive }) => isActive ? 'active-link' : ''}>\n  Dashboard\n</NavLink>\n```\n\n### 3. `useNavigate` Hook\n- The `useNavigate` hook is the recommended way to perform imperative or programmatic navigation in React Router v6.\n- It returns a function that allows you to navigate to different routes, replace entries in the history stack, or navigate relative to the current route.\n- It replaces the `useHistory` hook from v5.\n- **Basic Usage:** `navigate('/some/path')`\n- **Navigating Back/Forward:** `navigate(-1)` (back one step), `navigate(1)` (forward one step).\n- **Replacing History Entry:** `navigate('/some/path', { replace: true })` - This replaces the current entry in the history stack instead of adding a new one, useful for redirects after login.\n- **State Passing:** `navigate('/users/123', { state: { from: 'dashboard' } })` - You can pass state to the new location, which can be accessed via `useLocation().state`.\n\nThese tools provide a robust and flexible way to manage navigation in modern React applications using React Router v6.",
      "examples": [
        {
          "id": "example_v6_nav_1",
          "title": "Basic v6 Navigation Component",
          "code": "import { Link, NavLink, useNavigate } from 'react-router-dom';\n\nfunction NavigationV6() {\n  const navigate = useNavigate();\n\n  return (\n    <nav>\n      <ul>\n        <li><Link to=\"/\">Home</Link></li>\n        <li>\n          <NavLink \n            to=\"/about\" \n            style={({ isActive }) => \n              isActive ? { fontWeight: 'bold', color: 'darkred' } : undefined\n            }\n          >\n            About\n          </NavLink>\n        </li>\n        <li>\n          <button onClick={() => navigate('/contact')}>Contact Us</button>\n        </li>\n        <li>\n          <button onClick={() => navigate(-1)}>Go Back</button>\n        </li>\n      </ul>\n    </nav>\n  );\n}\n\n// To use this, you'd typically wrap your App component in a <BrowserRouter>\n// import { BrowserRouter, Routes, Route } from 'react-router-dom';\n// function App() {\n//   return (\n//     <BrowserRouter>\n//       <NavigationV6 />\n//       <Routes>\n//         <Route path=\"/\" element={<div>Home Page</div>} />\n//         <Route path=\"/about\" element={<div>About Page</div>} />\n//         <Route path=\"/contact\" element={<div>Contact Page</div>} />\n//       </Routes>\n//     </BrowserRouter>\n//   );\n// }\n",
          "explanation": "This example demonstrates a navigation bar using React Router v6 components. `Link` is used for basic navigation. `NavLink` shows how to apply dynamic styling based on the `isActive` state for the current route. A button uses `useNavigate` for programmatic redirection to the '/contact' route and also to go back one step in history.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React Router",
        "v6",
        "Navigation",
        "Link",
        "NavLink",
        "useNavigate",
        "Hooks"
      ],
      "prerequisites": [
        "React Basics",
        "React Hooks",
        "Client-Side Routing Concepts"
      ],
      "technology": "React"
    },
    "tags": [
      "React Router",
      "v6",
      "Navigation",
      "Link",
      "NavLink",
      "useNavigate",
      "Hooks"
    ],
    "prerequisites": [
      "React Basics",
      "React Hooks",
      "Client-Side Routing Concepts"
    ]
  },
  {
    "index": 65,
    "id": "theory_react_router_v5_vs_v6_navigation",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Router v5 vs. v6: Navigation Differences",
    "description": "",
    "content": {
      "id": "theory_react_router_v5_vs_v6_navigation",
      "title": "React Router v5 vs. v6: Navigation Differences",
      "description": "",
      "type": "theory",
      "content": "This section details the evolution of navigation paradigms in React Router, specifically comparing versions 5 and 6. React Router is a standard library for declarative routing in React applications, allowing navigation between different components without full page reloads, giving the impression of a multi-page application within a single-page application (SPA).\n\n## React Router v5 Navigation (Class Components)\nIn React Router v5, when working with class components, navigation was often handled using the `Redirect` component. The `Redirect` component, when rendered, causes the application to navigate to a new URL. This is a declarative way to handle redirects, often used after an action (like a successful login) completes.\n\nKey characteristics:\n-   Primarily used with class components.\n-   `Redirect` is a component that renders to perform navigation.\n-   Relies on the component lifecycle for triggering redirects.\n\n## React Router v6 Navigation (Functional Components & Hooks)\nReact Router v6 embraces React Hooks, providing the `useNavigate` hook for programmatic navigation. This hook returns a function that can be called to navigate to a different route. This approach is more flexible and integrates seamlessly with functional components and the React Hooks ecosystem.\n\nKey characteristics:\n-   Designed for functional components and React Hooks.\n-   `useNavigate` is a hook that provides a navigation function.\n-   Allows for imperative navigation, often triggered by user interactions or side effects (`useEffect`).\n-   `Navigate` component exists as a direct replacement for `Redirect` in functional components, also for declarative redirects.\n\n## Key Differences Summarized\n-   **Pattern:** v6 uses component composition pattern with `children` prop (e.g., `Routes` and `Route` components), while v5 primarily used render props pattern (e.g., `Switch` and `Route`).\n-   **Navigation Component/Hook:** v5 uses `Redirect` component; v6 uses `useNavigate` hook for programmatic navigation and `Navigate` component for declarative rendering-based redirects.\n-   **Relative Routing:** v6 has built-in, improved support for relative routing, making it easier to define routes relative to the current path.\n-   **API Simplicity:** v6 aims for a simpler and more intuitive API, particularly with the introduction of the `Routes` component instead of `Switch` and more streamlined route definitions.",
      "examples": [
        {
          "id": "example_v5_redirect",
          "title": "React Router v5 with Redirect (Class Component)",
          "code": "import React, { Component } from 'react';\nimport { Redirect } from 'react-router-dom';\n\nclass LoginPageV5 extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      username: '',\n      password: '',\n      isLoggedIn: false\n    };\n  }\n\n  handleInputChange = (e) => {\n    this.setState({\n      [e.target.name]: e.target.value\n    });\n  };\n\n  handleLogin = () => {\n    // Simulate authentication logic\n    if (this.state.username === 'user' && this.state.password === 'pass') {\n      this.setState({ isLoggedIn: true });\n    } else {\n      alert('Invalid credentials');\n    }\n  };\n\n  render() {\n    if (this.state.isLoggedIn) {\n      return <Redirect to=\"/dashboard\" />;\n    } else {\n      return (\n        <div>\n          <h2>Login (v5)</h2>\n          <input \n            type=\"text\" \n            name=\"username\" \n            value={this.state.username} \n            onChange={this.handleInputChange} \n            placeholder=\"Username\"\n          />\n          <input \n            type=\"password\" \n            name=\"password\" \n            value={this.state.password} \n            onChange={this.handleInputChange} \n            placeholder=\"Password\"\n          />\n          <button onClick={this.handleLogin}>Login</button>\n        </div>\n      );\n    }\n  }\n}\n\nexport default LoginPageV5;",
          "explanation": "This example demonstrates a login component in React Router v5. Upon successful login, the `isLoggedIn` state is set to `true`. In the `render` method, if `isLoggedIn` is true, the `Redirect` component is rendered, which causes the browser to navigate to the `/dashboard` path. This is a declarative way of handling redirects.",
          "language": "typescript"
        },
        {
          "id": "example_v6_use_navigate",
          "title": "React Router v6 with useNavigate (Functional Component)",
          "code": "import React, { useState, useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nconst LoginPageV6 = () => {\n  const navigate = useNavigate();\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  \n  useEffect(() => {\n    if (isLoggedIn) {\n      navigate('/dashboard');\n    }\n  }, [isLoggedIn, navigate]); // `navigate` is stable, but included for completeness in dependency array\n  \n  const handleLogin = () => {\n    // Simulate authentication logic\n    if (username === 'user' && password === 'pass') {\n      setIsLoggedIn(true);\n    } else {\n      alert('Invalid credentials');\n    }\n  };\n  \n  return (\n    <div>\n      <h2>Login (v6)</h2>\n      <input\n        type=\"text\"\n        value={username}\n        onChange={(e) => setUsername(e.target.value)}\n        placeholder=\"Username\"\n      />\n      <input\n        type=\"password\"\n        value={password}\n        onChange={(e) => setPassword(e.target.value)}\n        placeholder=\"Password\"\n      />\n      <button onClick={handleLogin}>Login</button>\n    </div>\n  );\n};\n\nexport default LoginPageV6;",
          "explanation": "This example shows the equivalent login component using React Router v6 and functional components. The `useNavigate` hook provides the `navigate` function. After a successful login, `setIsLoggedIn` is set to `true`. A `useEffect` hook then watches for `isLoggedIn` to become `true` and calls `navigate('/dashboard')` to perform the navigation. This is an imperative way of handling navigation.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React Router",
        "React Hooks",
        "SPA",
        "Navigation",
        "Authentication",
        "Frontend Architecture"
      ],
      "prerequisites": [
        "react_functional_components",
        "react_class_components",
        "react_state",
        "react_hooks_basics"
      ],
      "technology": "React"
    },
    "tags": [
      "React Router",
      "React Hooks",
      "SPA",
      "Navigation",
      "Authentication",
      "Frontend Architecture"
    ],
    "prerequisites": [
      "react_functional_components",
      "react_class_components",
      "react_state",
      "react_hooks_basics"
    ]
  },
  {
    "index": 71,
    "id": "theory_async_data_fetching_react",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "Asynchronous Data Fetching and State Management in React",
    "description": "",
    "content": {
      "id": "theory_async_data_fetching_react",
      "title": "Asynchronous Data Fetching and State Management in React",
      "description": "",
      "type": "theory",
      "content": "## Core Concepts of Asynchronous Operations in React\n\nWhen building dynamic web applications with React, interacting with external APIs to fetch or send data is a common requirement. These operations are asynchronous, meaning they don't block the main thread and their results are not immediately available. Proper state management is crucial to provide a good user experience by showing loading indicators, displaying fetched data, and gracefully handling errors.\n\n### Essential States for Asynchronous Operations\nTo manage the lifecycle of an asynchronous request, it's standard practice to maintain at least three pieces of state:\n\n*   `isLoading` (or `loading`): A boolean flag indicating whether an asynchronous operation is currently in progress. This is used to display a loading spinner or message.\n*   `data` (or specific data name like `news`, `users`): Holds the successfully fetched data. Initially null or an empty array/object.\n*   `error`: Stores any error message or object if the request fails. Initially null.\n\nThese states allow for conditional rendering of different UI elements based on the current status of the data fetching process.\n\n### Data Fetching with the `fetch` API\n\nThe `fetch` API is a modern, promise-based JavaScript interface for making network requests. It's built into most browsers and is commonly used in React applications. The `fetch` function returns a `Promise` that resolves to the `Response` object representing the response to your request. \n\nKey aspects of `fetch`:\n*   **Promise-based**: `fetch` returns a Promise. You handle its resolution or rejection using `.then()` and `.catch()`, or with `async/await`.\n*   **`Response.ok`**: The `response.ok` property is a boolean indicating whether the HTTP status code is in the 200-299 range. It's crucial to check this, as `fetch` *does not* reject the promise on HTTP error statuses (like 404 or 500) unless there's a network error or a malformed request. You must explicitly throw an error if `response.ok` is false.\n*   **`response.json()`**: To extract the JSON body content from the `Response` object, you call `response.json()`. This also returns a Promise that resolves with the parsed JSON data.\n\n### Asynchronous Data Fetching in Functional Components with `useEffect`\n\nFunctional components utilize the `useEffect` hook to perform side effects, such as data fetching. The `useEffect` hook accepts two arguments: a function containing the effect logic and an optional dependency array. When the dependency array is empty (`[]`), the effect runs only once after the initial render, mimicking `componentDidMount`.\n\n`async/await` syntax provides a more synchronous-looking way to write asynchronous code, making it easier to read and debug compared to deeply nested `.then()` chains. It must be used inside an `async` function. Since `useEffect`'s callback cannot be directly `async`, an `async` function is typically defined inside the effect and then called immediately.\n\n**Lifecycle Flow (Functional Component):**\n1.  Component mounts.\n2.  `useEffect` runs.\n3.  `setIsLoading(true)`.\n4.  `fetch` request is initiated.\n5.  **Success Path**: `response.ok` is true. `response.json()` is parsed. `setData(result)` and `setError(null)` are called. `finally` block executes `setIsLoading(false)`.\n6.  **Error Path**: `response.ok` is false or a network error occurs. The `catch` block executes. `setError(err.message)` and `setData(null)` are called. `finally` block executes `setIsLoading(false)`.\n7.  Component re-renders as state changes.\n\n### Asynchronous Data Fetching in Class Components with `componentDidMount`\n\nClass components use lifecycle methods to manage side effects. `componentDidMount()` is specifically designed for effects that should run once after the component has been mounted to the DOM. This is the ideal place to initiate API calls.\n\nPromises (`.then()`, `.catch()`) are used to handle the asynchronous nature of `fetch` in class components. The `.then()` method is called when the Promise resolves (success), and `.catch()` is called when the Promise rejects (error).\n\n**Lifecycle Flow (Class Component):**\n1.  Component mounts.\n2.  `componentDidMount` runs.\n3.  `this.setState({ isLoading: true })`.\n4.  `fetch` request is initiated.\n5.  **Success Path**: The first `.then()` checks `response.ok` and parses JSON. The second `.then()` updates `this.state` with `news: data` and `isLoading: false`.\n6.  **Error Path**: If `!response.ok` or a network error, the `.catch()` block executes. `this.setState` updates `error: error.message` and `isLoading: false`.\n7.  Component re-renders as state changes.\n\n### Conditional Rendering\nBoth component types use conditional rendering to display different UI based on the state. The order of conditions is important:\n1.  `isLoading`: Display loading state first.\n2.  `error`: Display error message if an error occurred.\n3.  `!data` (or `data.length === 0`): Display no data message if no data was retrieved or it's empty.\n4.  `data`: Render the actual data when available.\n\nThis ensures a clear and predictable user experience during data fetching.\n\n### Image References\nNone in the provided markdown.",
      "examples": [
        {
          "id": "example_functional_fetch_data",
          "title": "Functional Component Data Fetching with useEffect and async/await",
          "code": "import React, { useState, useEffect } from 'react';\n\nfunction FetchDataComponent() {\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setIsLoading(true);\n      try {\n        const response = await fetch('https://api.example.com/data');\n        if (!response.ok) {\n          throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        const result = await response.json();\n        setData(result);\n        setError(null);\n      } catch (err) {\n        setError(err.message);\n        setData(null);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    \n    fetchData();\n  }, []); // Empty dependency array means this effect runs once on mount\n  \n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n  if (!data) return <div>No data found</div>; // Check for null or empty data\n  \n  return (\n    <div>\n      <h2>Data:</h2>\n      <pre>{JSON.stringify(data, null, 2)}</pre>\n    </div>\n  );\n}",
          "explanation": "This example demonstrates fetching data in a functional React component using the `useEffect` hook and `async/await` syntax. The `useState` hook manages `data`, `isLoading`, and `error` states. The `useEffect` with an empty dependency array ensures the data is fetched only once when the component mounts. The `try...catch...finally` block handles successful data retrieval, errors, and ensures the loading state is reset regardless of the outcome. Conditional rendering displays different UI based on the `isLoading`, `error`, and `data` states.",
          "language": "typescript"
        },
        {
          "id": "example_class_fetch_data",
          "title": "Class Component Data Fetching with componentDidMount and Promises",
          "code": "import React from 'react';\n\nclass NewsContainer extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      news: [],      // Will hold the data from the API\n      isLoading: false, // Tracks if a request is in progress\n      error: null   // Stores any error that occurs\n    };\n  }\n  \n  componentDidMount() {\n    this.setState({ isLoading: true });\n    \n    fetch('https://api.example.com/news')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then(data => {\n        this.setState({\n          news: data,\n          isLoading: false\n        });\n      })\n      .catch(error => {\n        this.setState({\n          error: error.message,\n          isLoading: false\n        });\n      });\n  }\n  \n  render() {\n    const { news, isLoading, error } = this.state;\n    \n    if (isLoading) {\n      return <div className=\"loading-spinner\">Loading news...</div>;\n    }\n    \n    if (error) {\n      return <div className=\"error-message\">Error loading news: {error}</div>;\n    }\n    \n    if (news.length === 0) {\n      return <div className=\"empty-message\">No news available</div>;\n    }\n    \n    return (\n      <div className=\"news-container\">\n        <h2>Latest News</h2>\n        <ul>\n          {news.map(item => (\n            <li key={item.id}>{item.title}</li> // Assuming 'item' has an 'id' and 'title'\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}",
          "explanation": "This example illustrates data fetching within a class-based React component. The `constructor` initializes the component's state, including `news`, `isLoading`, and `error`. The `componentDidMount` lifecycle method is where the `fetch` API call is initiated. Promises (`.then()` and `.catch()`) are used to handle the asynchronous response and update the component's state accordingly. The `render` method performs conditional rendering to display loading, error, empty, or data states based on the component's current state.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Hooks",
        "Class Components",
        "Data Fetching",
        "Fetch API",
        "useEffect",
        "componentDidMount",
        "State Management",
        "Async/Await",
        "Promises",
        "Error Handling",
        "Conditional Rendering"
      ],
      "prerequisites": [
        "JavaScript Promises",
        "ES6+ async/await",
        "React Basics (components, state, props)"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Hooks",
      "Class Components",
      "Data Fetching",
      "Fetch API",
      "useEffect",
      "componentDidMount",
      "State Management",
      "Async/Await",
      "Promises",
      "Error Handling",
      "Conditional Rendering"
    ],
    "prerequisites": [
      "JavaScript Promises",
      "ES6+ async/await",
      "React Basics (components, state, props)"
    ]
  },
  {
    "index": 72,
    "id": "theory_async_best_practices",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "Best Practices for Asynchronous Operations in React",
    "description": "",
    "content": {
      "id": "theory_async_best_practices",
      "title": "Best Practices for Asynchronous Operations in React",
      "description": "",
      "type": "theory",
      "content": "Asynchronous operations are fundamental in modern web applications, especially for data fetching. In React, managing the state of these operations effectively is crucial for a good user experience and preventing bugs like race conditions or memory leaks.\n\n### Key Principles for Async Operations:\n\n1.  **Always Track Three States**: For any asynchronous operation, especially data fetching, it's essential to manage at least three distinct states in your component's local state or a state management solution:\n    *   **Loading**: Indicates that the request is currently in progress. This state is useful for displaying loading spinners or placeholders to the user.\n    *   **Success**: Represents that the request completed successfully, and data is available. This is when you render the fetched data.\n    *   **Error**: Signifies that the request failed. This state is used to display error messages to the user, providing feedback on what went wrong.\n\n2.  **Set Loading State Before the Request Starts**: To prevent race conditions and ensure the UI immediately reflects the pending operation, the `isLoading` state should be set to `true` right before the asynchronous call is initiated.\n\n3.  **Use `try/catch` or Promise `.catch()` for Error Handling**: Robust error handling is paramount. Wrap your asynchronous code in a `try...catch` block (for `async/await`) or chain a `.catch()` method (for Promises) to gracefully handle network issues, API errors, or other exceptions that might occur during the request. This prevents unhandled promise rejections and allows you to display user-friendly error messages.\n\n4.  **Clean Up Pending Requests (Cancellation)**: When a component that initiated an asynchronous request unmounts before the request completes, attempting to update its state can lead to memory leaks and errors (e.g., \"Can't perform a React state update on an unmounted component\"). It's crucial to cancel any in-flight requests when the component unmounts. Techniques like `AbortController` (for `fetch`) or cancellable tokens (for libraries like Axios) are used for this purpose.\n\n5.  **Add Conditional Rendering**: Your component's `render` method (or JSX in functional components) should conditionally render different UI elements based on the current state of the asynchronous operation (loading, error, success, or no data yet). This ensures the user always sees appropriate feedback.\n\n6.  **Use a Consistent Pattern**: Applying a standardized pattern for handling asynchronous operations throughout your application improves code readability, maintainability, and reduces cognitive load for developers.\n\nThese practices collectively lead to more reliable, performant, and user-friendly applications by addressing common pitfalls associated with asynchronous programming in React.",
      "examples": [
        {
          "id": "example_async_basic_class_component",
          "title": "Basic Async Data Fetching (Class Component)",
          "code": "import React from 'react';\n\nclass DataFetcher extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      data: null,\n      isLoading: false,\n      error: null\n    };\n  }\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  async fetchData() {\n    this.setState({ isLoading: true, error: null }); // Reset error on new fetch\n    try {\n      const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      this.setState({ data, isLoading: false });\n    } catch (error) {\n      this.setState({ error: error.message, isLoading: false });\n    }\n  }\n\n  render() {\n    const { data, isLoading, error } = this.state;\n    \n    if (isLoading) return <p>Loading data...</p>;\n    if (error) return <p>Error: {error}</p>;\n    if (!data) return <p>No data available yet. Please wait.</p>;\n    \n    return (\n      <div>\n        <h2>Fetched Data:</h2>\n        <p>Title: {data.title}</p>\n        <p>Body: {data.body}</p>\n      </div>\n    );\n  }\n}",
          "explanation": "This example demonstrates the core principles of managing `isLoading`, `data`, and `error` states in a class component. The `isLoading` state is set before the `fetch` call, and `try...catch` is used for error handling. Conditional rendering ensures the UI updates based on the current state.",
          "language": "typescript"
        },
        {
          "id": "example_async_axios_functional_component",
          "title": "Async Data Fetching with Axios and `useEffect` (Functional Component)",
          "code": "import React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nfunction ArticleFetcher() {\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setIsLoading(true);\n      setError(null); // Reset error on new fetch\n      try {\n        const result = await axios('http://hn.algolia.com/api/v1/search?query=react');\n        setData(result.data);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchData();\n  }, []); // Empty dependency array means this runs once on mount\n\n  if (isLoading) return <p>Loading articles...</p>;\n  if (error) return <p>Error: {error}</p>;\n  if (!data || !data.hits) return <p>No articles found.</p>;\n\n  return (\n    <div>\n      <h2>React Articles:</h2>\n      <ul>\n        {data.hits.map(item => (\n          <li key={item.objectID}>\n            <a href={item.url} target=\"_blank\" rel=\"noopener noreferrer\">{item.title}</a>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
          "explanation": "This example shows the same best practices applied in a functional component using `useState` and `useEffect`. `axios` is used for fetching, and the `finally` block ensures `isLoading` is set to `false` regardless of success or failure. The `useEffect` hook with an empty dependency array makes the data fetching happen once, similar to `componentDidMount`.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Asynchronous Operations",
        "State Management",
        "Error Handling",
        "Data Fetching",
        "Best Practices",
        "Functional Components",
        "Class Components",
        "useEffect",
        "useState",
        "Axios",
        "Fetch API"
      ],
      "prerequisites": [
        "JavaScript Promises",
        "Async/Await",
        "React Component Lifecycle",
        "React Hooks (useState, useEffect)"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Asynchronous Operations",
      "State Management",
      "Error Handling",
      "Data Fetching",
      "Best Practices",
      "Functional Components",
      "Class Components",
      "useEffect",
      "useState",
      "Axios",
      "Fetch API"
    ],
    "prerequisites": [
      "JavaScript Promises",
      "Async/Await",
      "React Component Lifecycle",
      "React Hooks (useState, useEffect)"
    ]
  },
  {
    "index": 73,
    "id": "theory_provider_pattern_context_api",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Provider Pattern with Context API",
    "description": "",
    "content": {
      "id": "theory_provider_pattern_context_api",
      "title": "React Provider Pattern with Context API",
      "description": "",
      "type": "theory",
      "content": "The Provider Pattern, when implemented with React's Context API, is a fundamental approach to managing global state within specific sections of a React application. It offers a centralized mechanism for sharing data across multiple components without resorting to 'prop drilling' – the tedious process of passing props down through many nested components.\n\n## Key Concepts\n\n### 1. The Problem: Prop Drilling\nProp drilling occurs when data needs to be passed from a parent component to a deeply nested child component, requiring intermediate components in the tree to receive and re-pass the prop even if they don't directly use it. This can make code harder to maintain, less readable, and more prone to errors.\n\n### 2. React Context API\nReact's Context API provides a way to pass data through the component tree without having to pass props down manually at every level. It's designed to share 'global' data (like authenticated user, theme, or preferred language) to a tree of React components.\n\n*   **`React.createContext()`**: Creates a Context object. When React renders a component that subscribes to this Context object, it will read the current context value from the closest matching `Provider` above it in the tree.\n    *   `const MyContext = React.createContext(defaultValue);`\n    *   The `defaultValue` is used when a component consumes the context but there is no matching `Provider` above it in the tree. This can be useful for testing components in isolation without wrapping them.\n\n*   **`Context.Provider`**: A React component that allows consuming components to subscribe to context changes. It accepts a `value` prop to be passed to consuming components that are descendants of this Provider.\n    *   ` <MyContext.Provider value={/* some value */}>`\n\n*   **`useContext(Context)` Hook**: A React Hook that lets you read context. It takes a Context object (the value returned from `React.createContext`) and returns the current context value for that context.\n    *   `const value = useContext(MyContext);`\n    *   When the context `value` changes, the component using `useContext` will re-render.\n\n### 3. The Provider Pattern\nThe Provider Pattern wraps the Context API to encapsulate state management logic and make it reusable. A typical implementation involves:\n\n1.  **Creating a Context**: Define a Context object using `React.createContext()`.\n2.  **Creating a Provider Component**: This component (e.g., `UserProvider`) holds the shared state (e.g., `user`, `loading`) and methods to update it (e.g., `login`, `logout`). It renders the `Context.Provider` component, passing the state and methods as its `value` prop. This component typically accepts `children` as props, allowing it to wrap other components.\n3.  **Creating a Custom Hook**: A custom hook (e.g., `useUser`) abstracts the `useContext` call. This provides a cleaner API for consumers, allows for type safety, and ensures that the context is consumed within its respective Provider, throwing an error if not.\n4.  **Placing the Provider**: The Provider component is placed high up in the component tree, ideally at the root or at a level where all components that need access to the shared state are descendants.\n5.  **Consuming the Context**: Any child component can use the custom hook to access the shared state and methods without prop drilling.\n\n## Advantages of Provider Pattern with Context API\n\n*   **Centralized State Management**: Specific sections or the entire application can have their state managed centrally, avoiding scattering state logic.\n*   **Improved Code Organization**: Separates state management logic from UI components, adhering to the principle of separation of concerns. The provider handles the business logic, while consumers focus on rendering.\n*   **Eliminates Prop Drilling**: Data is directly accessible to any descendant component without intermediate components needing to pass it down.\n*   **Reusability**: The Provider component and its custom hook can be reused across different parts of the application or even in different projects.\n*   **Type Safety**: Custom hooks can be strongly typed using TypeScript, providing autocompletion and compile-time error checking for the context value.\n*   **Testability**: Components that consume context can be easily tested by wrapping them with a mock Provider during unit tests, providing controlled context values.\n\nWhile powerful, Context API is not a replacement for full-fledged state management libraries like Redux or Zustand for very complex applications with global, highly interconnected state. It is best suited for sharing 'global' data that does not change very frequently, or for domain-specific state within certain subtrees of the application.",
      "examples": [
        {
          "id": "example_provider_pattern_1",
          "title": "Basic User Authentication Provider",
          "code": "import React, { createContext, useContext, useState } from 'react';\n\n// 1. Create a context\nconst UserContext = createContext(undefined); // Use undefined as default to enforce provider presence\n\n// Mock authentication service\nconst authService = {\n  login: async (credentials) => {\n    // Simulate API call\n    return new Promise(resolve => {\n      setTimeout(() => {\n        if (credentials.username === 'test' && credentials.password === 'password') {\n          resolve({ id: 1, name: 'John Doe', email: 'john@example.com' });\n        } else {\n          throw new Error('Invalid credentials');\n        }\n      }, 500);\n    });\n  },\n  logout: async () => {\n    // Simulate API call\n    return new Promise(resolve => setTimeout(() => resolve(true), 200));\n  }\n};\n\n// 2. Create a provider component that manages shared state\nfunction UserProvider({ children }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(false);\n  \n  const login = async (credentials) => {\n    setLoading(true);\n    try {\n      const userData = await authService.login(credentials);\n      setUser(userData);\n      return { success: true };\n    } catch (error) {\n      return { success: false, error: error.message };\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  const logout = async () => {\n    await authService.logout(); // Simulate logout API call\n    setUser(null);\n  };\n  \n  const value = {\n    user,\n    loading,\n    login,\n    logout\n  };\n  \n  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;\n}\n\n// 3. Create a custom hook for consuming the context\nfunction useUser() {\n  const context = useContext(UserContext);\n  if (context === undefined) {\n    throw new Error('useUser must be used within a UserProvider');\n  }\n  return context;\n}\n\nexport { UserProvider, useUser };",
          "explanation": "This example demonstrates the core components of the Provider Pattern: `UserContext` for creation, `UserProvider` for managing and providing state, and `useUser` for consuming it. The `UserProvider` encapsulates the authentication logic, including asynchronous login and logout operations, and makes the current user state and functions to modify it available to any descendant component. The `useUser` hook provides a convenient and safe way to access this context, ensuring it's used within a `UserProvider`.",
          "language": "typescript"
        },
        {
          "id": "example_provider_pattern_2",
          "title": "Consuming the User Context in Components",
          "code": "import React from 'react';\nimport { UserProvider, useUser } from './UserContext'; // Assuming UserContext.js contains the provider and hook\n\n// Mock Redirect component for demonstration\nconst Redirect = ({ to }) => <p>Redirecting to: {to}</p>;\n\nfunction LoginPage() {\n  const { login, loading, user } = useUser();\n  const [username, setUsername] = React.useState('');\n  const [password, setPassword] = React.useState('');\n  const [error, setError] = React.useState('');\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    setError('');\n    const result = await login({ username, password });\n    if (!result.success) {\n      setError(result.error);\n    }\n  };\n\n  if (user) return <Redirect to=\"/profile\" />;\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <h2>Login</h2>\n      {error && <p style={{ color: 'red' }}>{error}</p>}\n      <input type=\"text\" placeholder=\"Username\" value={username} onChange={e => setUsername(e.target.value)} disabled={loading} />\n      <input type=\"password\" placeholder=\"Password\" value={password} onChange={e => setPassword(e.target.value)} disabled={loading} />\n      <button type=\"submit\" disabled={loading}> \n        {loading ? 'Logging in...' : 'Login'}\n      </button>\n    </form>\n  );\n}\n\nfunction ProfilePage() {\n  const { user, logout } = useUser();\n  \n  if (!user) return <Redirect to=\"/login\" />;\n  \n  return (\n    <div>\n      <h1>Welcome, {user.name}!</h1>\n      <p>Email: {user.email}</p>\n      <button onClick={logout}>Log Out</button>\n    </div>\n  );\n}\n\n// Main App component where the Provider is used\nfunction App() {\n  // In a real app, you'd have React Router here for navigation\n  const [currentPage, setCurrentPage] = React.useState('login');\n\n  return (\n    <UserProvider>\n      <nav>\n        <button onClick={() => setCurrentPage('login')}>Login</button>\n        <button onClick={() => setCurrentPage('profile')}>Profile</button>\n      </nav>\n      <hr />\n      {currentPage === 'login' ? <LoginPage /> : <ProfilePage />}\n    </UserProvider>\n  );\n}\n\nexport default App;\n",
          "explanation": "This example showcases how `UserProvider` wraps the application (or a part of it) and how child components like `LoginPage` and `ProfilePage` consume the shared `user` state and `login`/`logout` functions via the `useUser` custom hook. Notice how neither `App` nor any hypothetical intermediate component needs to explicitly pass the `user` prop down. This directly addresses the prop drilling problem.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Context API",
        "Provider Pattern",
        "State Management",
        "Hooks",
        "Frontend Architecture",
        "Prop Drilling"
      ],
      "prerequisites": [
        "React Basics",
        "Functional Components",
        "useState Hook",
        "useContext Hook",
        "JavaScript ES6+"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Context API",
      "Provider Pattern",
      "State Management",
      "Hooks",
      "Frontend Architecture",
      "Prop Drilling"
    ],
    "prerequisites": [
      "React Basics",
      "Functional Components",
      "useState Hook",
      "useContext Hook",
      "JavaScript ES6+"
    ]
  },
  {
    "index": 76,
    "id": "theory_react_context_reducer_pattern",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Context and Reducer Pattern for State Management",
    "description": "",
    "content": {
      "id": "theory_react_context_reducer_pattern",
      "title": "React Context and Reducer Pattern for State Management",
      "description": "",
      "type": "theory",
      "content": "The provided code demonstrates a powerful pattern for managing global state in React applications, combining the `useContext` and `useReducer` hooks. This approach centralizes state logic, makes state updates predictable, and simplifies component structure.\n\n## Key Concepts\n\n### `useReducer` Hook\n`useReducer` is an alternative to `useState` for managing more complex state logic that involves multiple sub-values or when the next state depends on the previous one. It's often preferred over `useState` when state transitions are more intricate, similar to how Redux works.\n\nIt takes a `reducer` function and an `initialState` as arguments and returns the current state and a `dispatch` function. The `reducer` function takes the current state and an `action` object, and returns the new state. The `action` object typically has a `type` property and an optional `payload`.\n\n### `useContext` Hook\n`useContext` allows components to subscribe to a Context object without prop drilling. Context provides a way to pass data through the component tree without having to pass props down manually at every level. It's commonly used for global data like themes, user authentication status, or, as in this case, application-wide state managed by a reducer.\n\n### Combining `useReducer` and `useContext`\nThis pattern involves:\n1.  **Creating a Context:** A `React.createContext()` call establishes the context that will hold the state and dispatch function.\n2.  **Creating a Provider Component:** A component (e.g., `TodoProvider`) wraps `useReducer` to manage the state. It then provides the state and the `dispatch` function through the Context Provider's `value` prop to all its children.\n3.  **Creating a Custom Hook (Optional but Recommended):** A custom hook (e.g., `useTodo`) simplifies consumption of the context. Components can then use this hook to easily access the state and dispatch function without directly importing `useContext` and the Context object.\n\n## Advantages of this Pattern\n1.  **Centralized State Logic:** All state transitions and the logic for updating state (`reducer`) are defined in one place, making it easier to understand and maintain.\n2.  **Predictable State Updates:** State can only be updated by dispatching actions, which makes the flow of data unidirectional and easier to debug.\n3.  **Easy to Test:** Reducers are pure functions (given the same state and action, they always return the same new state) and can be tested in isolation without needing to render components.\n4.  **No External Dependencies:** This pattern uses only built-in React features, avoiding the need for external state management libraries for many use cases.\n5.  **DevTools Integration:** Works seamlessly with React DevTools for component inspection, allowing you to see the state and prop changes.\n\n## Implementation Steps\n1. Define your reducer function.\n2. Create a Context using `React.createContext`.\n3. Create a Provider component that uses `useReducer` and provides the state and dispatch via the context.\n4. Create a custom hook to consume the context.\n5. Wrap your application or relevant parts with the Provider.",
      "examples": [
        {
          "id": "example_reducer_context_1",
          "title": "Basic Todo Reducer and Context Setup",
          "code": "import React, { createContext, useReducer, useContext, useState } from 'react';\n\n// 1. Define the Reducer function\nconst todoReducer = (state, action) => {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [...state, { id: Date.now(), text: action.payload, completed: false }];\n    case 'TOGGLE_TODO':\n      return state.map(todo =>\n        todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo\n      );\n    case 'DELETE_TODO':\n      return state.filter(todo => todo.id !== action.payload);\n    default:\n      return state;\n  }\n};\n\n// 2. Create Context\nconst TodoContext = createContext(null);\n\n// 3. Create Provider Component\nexport const TodoProvider = ({ children }) => {\n  const [todos, dispatch] = useReducer(todoReducer, []);\n\n  return (\n    <TodoContext.Provider value={{ todos, dispatch }}>\n      {children}\n    </TodoContext.Provider>\n  );\n};\n\n// 4. Create Custom Hook to use the Context\nexport const useTodo = () => {\n  const context = useContext(TodoContext);\n  if (!context) {\n    throw new Error('useTodo must be used within a TodoProvider');\n  }\n  return context;\n};\n\n// 5. Example usage in components\n// AddTodo component\nfunction AddTodo() {\n  const [text, setText] = useState('');\n  const { dispatch } = useTodo();\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (text.trim()) {\n      dispatch({ type: 'ADD_TODO', payload: text });\n      setText('');\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input \n        value={text} \n        onChange={(e) => setText(e.target.value)} \n        placeholder=\"Add a todo\"\n      />\n      <button type=\"submit\">Add</button>\n    </form>\n  );\n}\n\n// TodoList component\nfunction TodoList() {\n  const { todos, dispatch } = useTodo();\n  \n  return (\n    <ul>\n      {todos.map(todo => (\n        <li \n          key={todo.id} \n          style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}\n        >\n          <span \n            onClick={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })} \n            style={{ cursor: 'pointer' }}\n          >\n            {todo.text}\n          </span>\n          <button \n            onClick={() => dispatch({ type: 'DELETE_TODO', payload: todo.id })} \n            style={{ marginLeft: '10px' }}\n          >\n            Delete\n          </button>\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Main App Component\nfunction TodoApp() {\n  return (\n    <TodoProvider>\n      <h1>Todo App</h1>\n      <AddTodo />\n      <TodoList />\n    </TodoProvider>\n  );\n}\n\nexport default TodoApp;\n",
          "explanation": "This example provides the full implementation of the Todo application shown in the markdown, demonstrating how `useReducer` defines the state logic, `TodoContext` provides the state and `dispatch` function, `TodoProvider` wraps the application to make the context available, and `useTodo` simplifies consumption of the context by child components. It illustrates the centralized state management and predictable updates through dispatched actions.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "State Management",
        "Hooks",
        "useReducer",
        "useContext",
        "Context API",
        "Redux Pattern"
      ],
      "prerequisites": [
        "React Basics",
        "Functional Components",
        "useState"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "State Management",
      "Hooks",
      "useReducer",
      "useContext",
      "Context API",
      "Redux Pattern"
    ],
    "prerequisites": [
      "React Basics",
      "Functional Components",
      "useState"
    ]
  },
  {
    "index": 77,
    "id": "theory_concurrent_mode_suspense",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "Concurrent Mode, Suspense, and SuspenseList",
    "description": "",
    "content": {
      "id": "theory_concurrent_mode_suspense",
      "title": "Concurrent Mode, Suspense, and SuspenseList",
      "description": "",
      "type": "theory",
      "content": "Concurrent Mode is an experimental set of features in React designed to improve user experience by enabling applications to remain responsive even during heavy computational tasks or network requests. It allows React to work on multiple tasks concurrently, prioritizing updates and ensuring smoother user interfaces. While Concurrent Mode itself is still experimental and not fully recommended for production in all applications, individual stable features derived from it are being gradually released.\n\n## Key Concepts\n\n### `unstable_createRoot`\nTo opt into Concurrent Mode features, `unstable_createRoot` (or the stable `createRoot` introduced in React 18) is used instead of `ReactDOM.render`. This new root API enables features like automatic batching, transitions, and Suspense for data fetching.\n\n### Suspense\n`Suspense` is a React component that lets you \"wait\" for some code to load dynamically and declaratively specify a loading state (a fallback UI) while it's loading. It's primarily used for code splitting with `React.lazy` and for data fetching with Suspense-enabled data libraries. When a component wrapped in `Suspense` (or any of its children) 'suspends' (e.g., waits for data to load), the `fallback` UI is displayed.\n\n### SuspenseList\n`SuspenseList` is a component used to coordinate the order in which `Suspense` and `React.lazy` components reveal their content. It's useful when you have multiple Suspense boundaries and want to prevent them from showing all their fallbacks at once or reveal them in a specific sequence. It accepts `revealOrder` and `tail` props:\n- `revealOrder`: Can be `forwards`, `backwards`, or `together`.\n  - `forwards`: Children are revealed in the order they appear in the component tree.\n  - `backwards`: Children are revealed in reverse order.\n  - `together`: All children are revealed at once, only after all of them have resolved.\n- `tail`: Can be `collapsed` or `hidden`.\n  - `collapsed`: Only shows one fallback at a time, hiding subsequent ones until the preceding ones resolve.\n  - `hidden`: Hides all fallbacks after the first one resolves, showing only the first until its content is ready.\n\n## Benefits of Concurrent Mode\n\n1.  **Improved User Experience**: Applications feel more responsive and fluid, even during data fetching or heavy computations, especially on slower devices.\n2.  **Smoother Transitions**: Loading states can be coordinated, prioritized, and non-blocking, leading to fewer abrupt changes in the UI.\n3.  **Fewer Loading Indicators**: With `Suspense` and `SuspenseList`, content can be displayed incrementally, reducing the need for all-or-nothing loading screens and providing a more progressive user experience.\n4.  **Better Error Handling**: Errors can be caught and handled more gracefully at the component level using `Error Boundaries`, which complement Suspense by allowing you to define fallback UIs for errors during rendering or data fetching.\n\n## Status\nConcurrent Mode is an umbrella term for a set of experimental features. While `createRoot` is stable in React 18, the full Concurrent Mode features like automatic batching and transitions are built upon it. Suspense for data fetching requires a Suspense-enabled data fetching solution (like Relay, Apollo, or a custom one built with `use` hook) and is still evolving. It's generally not recommended for production use without careful consideration and understanding of its implications.",
      "examples": [
        {
          "id": "example_concurrent_mode_1",
          "title": "Basic Suspense and SuspenseList Usage",
          "code": "import React, { Suspense, SuspenseList, unstable_createRoot as createRoot } from 'react';\n\n// Mock data fetching utility\nconst createResource = (fetcher) => {\n  let status = 'pending';\n  let result;\n  let suspender = fetcher().then(\n    (r) => {\n      status = 'success';\n      result = r;\n    },\n    (e) => {\n      status = 'error';\n      result = e;\n    }\n  );\n  return {\n    read() {\n      if (status === 'pending') {\n        throw suspender;\n      } else if (status === 'error') {\n        throw result;\n      } else if (status === 'success') {\n        return result;\n      }\n    },\n  };\n};\n\n// Simulate an async data fetch\nconst fetchUserData = (userId) => {\n  return createResource(\n    () => new Promise((resolve) =>\n      setTimeout(() => {\n        resolve({ id: userId, name: `User ${userId}`, bio: `Bio for User ${userId}` });\n      }, 1000 + Math.random() * 1000)\n    )\n  );\n};\n\nconst fetchPostsData = (userId) => {\n  return createResource(\n    () => new Promise((resolve) =>\n      setTimeout(() => {\n        resolve([\n          { id: 1, title: `Post 1 by User ${userId}` },\n          { id: 2, title: `Post 2 by User ${userId}` }\n        ]);\n      }, 1500 + Math.random() * 1000)\n    )\n  );\n};\n\n// Components that simulate data fetching and can suspend\nfunction ProfileHeader() {\n  const userResource = fetchUserData(1);\n  const user = userResource.read(); // This will suspend if data is not ready\n  return <h2>{user.name}'s Profile</h2>;\n}\n\nfunction ProfileDetails() {\n  const userResource = fetchUserData(1);\n  const user = userResource.read(); // This will suspend if data is not ready\n  return <div>{user.bio}</div>;\n}\n\nfunction ProfilePosts() {\n  const postsResource = fetchPostsData(1);\n  const posts = postsResource.read(); // This will suspend if data is not ready\n  return (\n    <div>\n      <h3>Posts</h3>\n      <ul>\n        {posts.map(post => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>Concurrent Mode Demo</h1>\n      <SuspenseList revealOrder=\"forwards\" tail=\"collapsed\">\n        <Suspense fallback={<div>Loading header...</div>}>\n          <ProfileHeader />\n        </Suspense>\n        <Suspense fallback={<div>Loading details...</div>}>\n          <ProfileDetails />\n        </Suspense>\n        <Suspense fallback={<div>Loading posts...</div>}>\n          <ProfilePosts />\n        </Suspense>\n      </SuspenseList>\n    </div>\n  );\n}\n\nconst rootEl = document.getElementById('root');\n// In React 18, replace unstable_createRoot with createRoot\nconst root = createRoot(rootEl);\nroot.render(<App />);\n\n// Basic HTML for #root:\n// <div id=\"root\"></div>",
          "explanation": "This example demonstrates how `Suspense` and `SuspenseList` work together. Each `Profile` component internally uses a `createResource` utility to simulate asynchronous data fetching. When `resource.read()` is called and the data isn't ready, it 'throws' a Promise, causing the nearest `Suspense` boundary to activate and display its `fallback` UI. `SuspenseList` then coordinates the display of these fallbacks and the subsequent revelation of content. With `revealOrder=\"forwards\"` and `tail=\"collapsed\"`, the fallbacks appear one by one, and content is revealed in the order it's defined, improving the perceived loading experience.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Concurrent Mode",
        "Suspense",
        "SuspenseList",
        "Performance",
        "User Experience",
        "React 18"
      ],
      "prerequisites": [
        "React Components",
        "State Management",
        "Asynchronous JavaScript",
        "Error Boundaries"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Concurrent Mode",
      "Suspense",
      "SuspenseList",
      "Performance",
      "User Experience",
      "React 18"
    ],
    "prerequisites": [
      "React Components",
      "State Management",
      "Asynchronous JavaScript",
      "Error Boundaries"
    ]
  },
  {
    "index": 79,
    "id": "theory_react_memoization_usecallback_and_react_memo",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Memoization: useCallback and React.memo",
    "description": "",
    "content": {
      "id": "theory_react_memoization_usecallback_and_react_memo",
      "title": "React Memoization: useCallback and React.memo",
      "description": "",
      "type": "theory",
      "content": "## Introduction to Memoization in React\nMemoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. In React, memoization is crucial for performance optimization, especially in large applications with many components or frequent state updates. It helps prevent unnecessary re-renders of components or re-creation of functions, which can be computationally expensive.\n\n## The `useCallback` Hook\n`useCallback` is a React Hook that returns a memoized version of the callback function passed to it. This memoized function only changes if one of the dependencies specified in its dependency array has changed.\n\n### Purpose and Syntax\n`useCallback` is primarily used to optimize performance by ensuring referential equality of functions across re-renders. When a component re-renders, JavaScript typically creates new function instances for all functions defined within that component. This can be problematic when these functions are passed as props to child components that are optimized with `React.memo`.\n\n**Syntax:**\n```typescript\nconst memoizedCallback = useCallback(\n  () => {\n    // your function logic here\n  },\n  [dependencies] // array of dependencies\n);\n```\n\n- The first argument is the function that you want to memoize.\n- The second argument is a dependency array. The `useCallback` hook will return the *same* function instance as long as the values in this array remain unchanged. If any dependency changes, a new function instance is returned.\n\n### Why use `useCallback`?\n1.  **Preventing Unnecessary Renders of Memoized Child Components:** When you pass a callback function as a prop to a child component wrapped in `React.memo` (or a `PureComponent` for class components), `React.memo` performs a shallow comparison of props. If the callback function is re-created on every parent re-render, `React.memo` will see a new reference for the function prop, causing the child component to re-render unnecessarily, even if its other props haven't changed. `useCallback` ensures the function reference remains stable.\n\n2.  **Stable Functions for `useEffect` Dependencies:** When a function is used as a dependency in other hooks like `useEffect`, `useMemo`, or `useRef`, `useCallback` ensures that the effect or memoized value doesn't re-run or re-calculate unnecessarily due to the function's reference changing on every render.\n\n3.  **Optimization for Expensive Callbacks:** While less common for `useCallback` itself (more for `useMemo`), it can be used to prevent re-creation of computationally intensive functions if their logic truly depends only on stable inputs.\n\n### Dependency Array\nThe dependency array is crucial. If it's an empty array `[]`, the function will only be created once during the initial render and will always refer to the state/props from that initial render (stale closure). If dependencies are omitted, the function will be re-created on every render, defeating the purpose of `useCallback`.\n\n## `React.memo` Component Optimization\n`React.memo` is a higher-order component (HOC) that memoizes functional components. It works similarly to `PureComponent` for class components.\n\n### Purpose and Syntax\nWhen a component is wrapped with `React.memo`, React will skip rendering the component if its props have not changed. This shallow comparison of props is key to its efficiency.\n\n**Syntax:**\n```typescript\nconst MemoizedComponent = React.memo(FunctionalComponent);\n```\n\nBy default, `React.memo` only shallowly compares props. You can provide a custom comparison function as a second argument if you need a deeper or specific comparison logic.\n\n```typescript\nconst MemoizedComponent = React.memo(FunctionalComponent, (prevProps, nextProps) => {\n  // return true if props are equal (i.e., render should be skipped)\n  // return false if props are different (i.e., component should re-render)\n  return prevProps.value === nextProps.value;\n});\n```\n\n### Relationship between `useCallback` and `React.memo`\n`useCallback` and `React.memo` often work hand-in-hand. `React.memo` optimizes child components by preventing re-renders if props haven't changed. However, if a function prop is passed to a `React.memo`ized child, and that function is re-created on every parent render (due to JavaScript's default behavior), `React.memo` will detect a new reference for that function prop and re-render the child anyway. `useCallback` solves this by providing a stable reference to the function, allowing `React.memo` to effectively skip re-renders.\n\n## Example: `useCallback` with `React.memo`\n\nHere's an example demonstrating how `useCallback` and `React.memo` work together to prevent unnecessary re-renders of a child component when its parent re-renders due to unrelated state changes.\n\n```typescript\nimport React, { useState, useCallback } from 'react';\n\n// ChildComponent is memoized to prevent re-renders if its props don't change\nconst ChildComponent = React.memo(function ChildComponent({ onClick }) {\n  console.log('ChildComponent rendered');\n  return <button onClick={onClick}>Click Me</button>;\n});\n\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n  const [otherState, setOtherState] = useState(0);\n  \n  // handleClick will only be recreated if 'count' changes. \n  // This ensures a stable reference for ChildComponent's onClick prop.\n  const handleClick = useCallback(() => {\n    console.log(`Click count: ${count}`);\n  }, [count]); // Dependency: count\n  \n  return (\n    <div>\n      {/* Using the memoized child component */}\n      <ChildComponent onClick={handleClick} />\n      <p>Count: {count}</p>\n      <p>Other State: {otherState}</p>\n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\n      {/* This button changes 'otherState', which will re-render ParentComponent. \n          However, ChildComponent will NOT re-render because handleClick's reference is stable\n          (as 'count' has not changed) and ChildComponent is memoized. */}\n      <button onClick={() => setOtherState(otherState + 1)}>Change Other State</button>\n    </div>\n  );\n}\n\n// Export ParentComponent for usage\n// export default ParentComponent;\n```\n\nWhen `Change Other State` button is clicked, `ParentComponent` re-renders. If `handleClick` were not wrapped in `useCallback`, a new `handleClick` function would be created. Because `ChildComponent` is wrapped in `React.memo`, it compares its `onClick` prop. Without `useCallback`, the `onClick` prop's reference would change, causing `ChildComponent` to re-render. With `useCallback`, the `onClick` prop's reference remains the same (as `count` hasn't changed), so `ChildComponent` does not re-render, optimizing performance.\n\n## Example: `useCallback` in `useEffect` Dependencies\n\n`useCallback` is also crucial when a function is a dependency of `useEffect` to prevent the effect from running unnecessarily.\n\n```typescript\nimport React, { useState, useEffect, useCallback } from 'react';\n\nfunction SearchComponent() {\n  const [query, setQuery] = useState('');\n  \n  // This handler will maintain the same reference between renders\n  // as long as 'query' doesn't change.\n  const performSearch = useCallback(() => {\n    // In a real app, this might be an API call or expensive computation\n    console.log(`Performing search for: ${query}`);\n  }, [query]); // Dependency: query\n  \n  useEffect(() => {\n    // This effect runs whenever 'performSearch' changes.\n    // Without useCallback, 'performSearch' would be a new function on every render,\n    // causing this effect to run unnecessarily every time.\n    performSearch();\n    // Clean up or other side effects related to search\n  }, [performSearch]); // Dependency: performSearch\n  \n  return (\n    <input \n      type=\"text\"\n      value={query}\n      onChange={(e) => setQuery(e.target.value)}\n      placeholder=\"Search...\"\n    />\n  );\n}\n\n// export default SearchComponent;\n```\n\nIn this `SearchComponent`, if `performSearch` were not wrapped in `useCallback`, a new function instance would be created on every render. As `performSearch` is a dependency of `useEffect`, the `useEffect` callback would execute on every render, even if the `query` hasn't actually changed, leading to inefficient behavior (e.g., redundant API calls). `useCallback` prevents this by ensuring `performSearch` only changes when `query` changes.\n\n## Forms and State Management (Context from original markdown)\n\nAlthough the core of the provided markdown focuses on `useCallback`, the initial snippet presents a common React form structure:\n\n```html\n<div>\n  <label>Email:</label>\n  <input\n    type=\"email\"\n    value={email}\n    onChange={(e) => dispatch({\n      type: 'field',\n      field: 'email',\n      value: e.target.value\n    })}\n    disabled={isSubmitting}\n  />\n</div>\n<div>\n  <label>Password:</label>\n  <input\n    type=\"password\"\n    value={password}\n    onChange={(e) => dispatch({\n      type: 'field',\n      field: 'password',\n      value: e.target.value\n    })}\n    disabled={isSubmitting}\n  />\n</div>\n<button type=\"submit\" disabled={isSubmitting}>\n  {isSubmitting ? 'Logging in...' : 'Log In'}\n</button>\n<button \n  type=\"button\" \n  onClick={() => dispatch({ type: 'reset' })}\n  disabled={isSubmitting}\n>\n  Reset\n</button>\n```\n\nThis snippet implicitly demonstrates:\n-   **Controlled Components:** Input fields (`<input>`) are controlled by React state, where their `value` is tied to a state variable and `onChange` handlers update that state.\n-   **Event Handling:** `onChange` and `onClick` are used to capture user interactions.\n-   **State Management with `dispatch`:** The use of `dispatch` suggests a `useReducer` hook or a similar pattern where actions (like `'field'` or `'reset'`) are dispatched to update a complex state object. This is a common and often preferred alternative to multiple `useState` calls for related state variables.\n-   **Conditional UI/Disabling Elements:** The `disabled={isSubmitting}` prop on inputs and buttons, along with conditional text `isSubmitting ? 'Logging in...' : 'Log In'`, shows how UI can dynamically react to application state (e.g., during a form submission).\n\nWhile not directly related to `useCallback`, understanding these fundamental React concepts is essential for building robust frontend applications.",
      "examples": [
        {
          "id": "example_usecallback_basic_1",
          "title": "Basic `useCallback` Usage",
          "code": "import React, { useState, useCallback } from 'react';\n\nfunction Parent() {\n  const [value, setValue] = useState(0);\n\n  const doSomething = useCallback(() => {\n    console.log('Value is:', value);\n  }, [value]); // Dependency on 'value'\n\n  return (\n    <div>\n      <button onClick={() => setValue(value + 1)}>Increment Value</button>\n      <button onClick={doSomething}>Log Value</button>\n      <p>Current Value: {value}</p>\n    </div>\n  );\n}\n",
          "explanation": "This example shows `useCallback` memoizing the `doSomething` function. If `value` changes, a new `doSomething` function is created. Otherwise, the same reference is maintained. This can be useful if `doSomething` were passed to a memoized child component.",
          "language": "typescript"
        },
        {
          "id": "example_react_memo_basic_1",
          "title": "`React.memo` for Component Memoization",
          "code": "import React, { useState } from 'react';\n\nconst DisplayCount = React.memo(({ count }) => {\n  console.log('DisplayCount rendered');\n  return <p>Count: {count}</p>;\n});\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n\n  return (\n    <div>\n      <DisplayCount count={count} />\n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\n      <input \n        type=\"text\" \n        value={text} \n        onChange={(e) => setText(e.target.value)} \n        placeholder=\"Type something...\"\n      />\n    </div>\n  );\n}\n",
          "explanation": "In this example, `DisplayCount` is wrapped with `React.memo`. When you type into the input field (changing `text` state), `App` re-renders, but `DisplayCount` will NOT re-render because its `count` prop has not changed. This demonstrates how `React.memo` prevents unnecessary child renders based on prop equality.",
          "language": "typescript"
        },
        {
          "id": "example_form_state_structure",
          "title": "React Form with `dispatch` Pattern",
          "code": "import React, { useReducer } from 'react';\n\nconst initialState = {\n  email: '',\n  password: '',\n  isSubmitting: false,\n  error: null,\n};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'field':\n      return { ...state, [action.field]: action.value, error: null };\n    case 'submit_start':\n      return { ...state, isSubmitting: true, error: null };\n    case 'submit_success':\n      return { ...state, isSubmitting: false };\n    case 'submit_error':\n      return { ...state, isSubmitting: false, error: action.error };\n    case 'reset':\n      return { ...initialState };\n    default:\n      return state;\n  }\n}\n\nfunction LoginForm() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const { email, password, isSubmitting, error } = state;\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    dispatch({ type: 'submit_start' });\n    try {\n      // Simulate API call\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      if (email === 'test@example.com' && password === 'password') {\n        dispatch({ type: 'submit_success' });\n        alert('Login successful!');\n      } else {\n        throw new Error('Invalid credentials');\n      }\n    } catch (err) {\n      dispatch({ type: 'submit_error', error: err.message });\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <h2>Login</h2>\n      {error && <p style={{ color: 'red' }}>{error}</p>}\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input\n          id=\"email\"\n          type=\"email\"\n          value={email}\n          onChange={(e) => dispatch({\n            type: 'field',\n            field: 'email',\n            value: e.target.value\n          })}\n          disabled={isSubmitting}\n        />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password:</label>\n        <input\n          id=\"password\"\n          type=\"password\"\n          value={password}\n          onChange={(e) => dispatch({\n            type: 'field',\n            field: 'password',\n            value: e.target.value\n          })}\n          disabled={isSubmitting}\n        />\n      </div>\n      <button type=\"submit\" disabled={isSubmitting}>\n        {isSubmitting ? 'Logging in...' : 'Log In'}\n      </button>\n      <button \n        type=\"button\" \n        onClick={() => dispatch({ type: 'reset' })}\n        disabled={isSubmitting}\n      >\n        Reset\n      </button>\n    </form>\n  );\n}\n\n// export default LoginForm;\n",
          "explanation": "This example expands on the original snippet, showing a full `LoginForm` component using the `useReducer` hook. `useReducer` is ideal for managing complex state logic (like a form with multiple fields, loading states, and errors) because it centralizes state updates via a `dispatch` function and a `reducer` function. Each input's `onChange` dispatches an action to update its corresponding field, and buttons dispatch actions for submission or reset, demonstrating a robust state management pattern for forms.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React Hooks",
        "Performance Optimization",
        "Memoization",
        "useCallback",
        "React.memo",
        "State Management"
      ],
      "prerequisites": [
        "React_Functional_Components",
        "React_State_Management",
        "JavaScript_Functions"
      ],
      "technology": "React"
    },
    "tags": [
      "React Hooks",
      "Performance Optimization",
      "Memoization",
      "useCallback",
      "React.memo",
      "State Management"
    ],
    "prerequisites": [
      "React_Functional_Components",
      "React_State_Management",
      "JavaScript_Functions"
    ]
  },
  {
    "index": 80,
    "id": "theory_usecallback",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React's useCallback Hook for Function Memoization",
    "description": "",
    "content": {
      "id": "theory_usecallback",
      "title": "React's useCallback Hook for Function Memoization",
      "description": "",
      "type": "theory",
      "content": "The `useCallback` hook in React is used for memoizing functions. It returns a memoized version of the callback function that only changes if one of the dependencies has changed. This is particularly useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary re-renders (e.g., `React.memo`).\n\nWhen a parent component re-renders, any functions defined within it are recreated. If these functions are passed as props to child components, even if the child component is wrapped in `React.memo`, it will still re-render because the prop (the function) is a new reference on each parent render. `useCallback` prevents this by ensuring the function reference remains the same across renders unless its dependencies change.\n\n## Key Concepts\n-   **Function Memoization**: Prevents functions from being recreated on every render.\n-   **Referential Equality**: Crucial for optimizing child components that check for prop changes (e.g., `React.memo`). If a function's reference changes, `React.memo` will see it as a new prop and re-render the child, even if the function's logic is effectively the same.\n-   **Dependency Array**: An optional array of values. The memoized function will only be recreated if any value in this array changes. If the array is empty (`[]`), the function is created once and never changes, which means it will capture the state/props from its initial render. If the array is omitted, the function will be recreated on every render (defeating the purpose).\n\n## When to Use `useCallback`\n-   When passing callbacks to optimized child components (using `React.memo`).\n-   When a function is a dependency of another hook (e.g., `useEffect`, `useMemo`), to prevent infinite loops or unnecessary re-executions.\n-   When dealing with event handlers that might trigger costly operations or re-renders in child components.",
      "examples": [
        {
          "id": "example_usecallback_1",
          "title": "Basic use of useCallback in a List Component",
          "code": "import React, { useState, useCallback } from 'react';\n\nfunction ListComponent({ items }) {\n  const [selectedItem, setSelectedItem] = useState(null);\n  \n  // This callback will only change when 'selectedItem' changes.\n  // This prevents unnecessary re-renders of list items if they were memoized children.\n  const handleItemClick = useCallback((item) => {\n    setSelectedItem(item);\n  }, [selectedItem]);\n  \n  return (\n    <ul>\n      {items.map((item) => (\n        <li key={item.id} onClick={() => handleItemClick(item)}>\n          {item.name}\n        </li>\n      ))}\n    </ul>\n  );\n}",
          "explanation": "In this `ListComponent`, `handleItemClick` is wrapped in `useCallback`. Without `useCallback`, `handleItemClick` would be a new function reference on every render of `ListComponent`. If `ListComponent` had memoized child components for each `li` (e.g., `MemoizedListItem`), they would unnecessarily re-render because their `onClick` prop (the `handleItemClick` function) would be different on each render, even if `items` didn't change. By memoizing `handleItemClick`, we ensure its reference only changes when `selectedItem` changes, thus preserving optimizations for child components.",
          "language": "javascript"
        },
        {
          "id": "example_usecallback_2",
          "title": "useCallback with Empty Dependency Array",
          "code": "import React, { useCallback } from 'react';\n\nfunction StaticButton({ onClickHandler }) {\n  // This function is created once and never changes.\n  const memoizedClick = useCallback(() => {\n    console.log('Button clicked once.');\n    onClickHandler();\n  }, []); // Empty dependency array means it's created once\n\n  return <button onClick={memoizedClick}>Click Me</button>;\n}",
          "explanation": "When `useCallback` is used with an empty dependency array (`[]`), the function `memoizedClick` is created only once when the component mounts. It will always refer to the same function instance, making it suitable for callbacks that don't depend on any props or state from the component's scope, or for situations where you explicitly want to capture initial props/state and not have the function update.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Hooks",
        "Performance",
        "Optimization",
        "useCallback",
        "Frontend"
      ],
      "prerequisites": [
        "react_components",
        "react_state_props",
        "react_memo"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Hooks",
      "Performance",
      "Optimization",
      "useCallback",
      "Frontend"
    ],
    "prerequisites": [
      "react_components",
      "react_state_props",
      "react_memo"
    ]
  },
  {
    "index": 81,
    "id": "theory_react_memoization_hooks",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Memoization Hooks: useMemo and useCallback",
    "description": "",
    "content": {
      "id": "theory_react_memoization_hooks",
      "title": "React Memoization Hooks: useMemo and useCallback",
      "description": "",
      "type": "theory",
      "content": "## Introduction to Memoization in React\nMemoization is an optimization technique used to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. In React, `useMemo` and `useCallback` are hooks designed to prevent unnecessary re-computations or re-creations of values and functions, respectively, thereby optimizing component re-renders.\n\n## useMemo Hook\n`useMemo` is a React Hook that lets you cache the result of an expensive calculation between re-renders. It takes two arguments:\n1.  A 'create' function: This function computes the value that you want to memoize.\n2.  A dependency array: `useMemo` will only re-run the 'create' function if one of the values in this array changes. If the array is empty (`[]`), the function will run once on the initial render and its result will always be returned. If no array is provided, the function will re-run on every render.\n\n**Purpose:** To prevent expensive calculations from running on every render when their inputs haven't changed. This can significantly improve performance for components that render frequently or perform complex computations.\n\n```typescript\n// Returns the memoized result of calling the function\nconst memoizedValue = useMemo(() => {\n  return doSomething(a, b);\n}, [a, b]);\n```\n\n## useCallback Hook\n`useCallback` is a React Hook that lets you cache a function definition between re-renders. It takes two arguments:\n1.  A callback function: The function definition that you want to memoize.\n2.  A dependency array: `useCallback` will return the same function instance (reference) if the values in this array haven't changed. If the array is empty (`[]`), the function instance will remain the same throughout the component's lifetime. If no array is provided, the function will be re-created on every render.\n\n**Purpose:** To prevent functions from being re-created on every render. This is particularly useful when passing callbacks down to optimized child components (like those wrapped with `React.memo`), or when a function is a dependency of another hook like `useEffect` or `useMemo`. Re-creating functions can cause child components to re-render unnecessarily if they rely on reference equality for props.\n\n```typescript\nimport React, { useCallback, useState } from 'react';\n\n// Example of how useCallback works\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n\n  // This function will only be re-created if 'count' changes\n  const handleClick = useCallback(() => {\n    setCount(prevCount => prevCount + 1);\n  }, []); // Empty dependency array means it's created once\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <ChildComponent onButtonClick={handleClick} />\n    </div>\n  );\n}\n\n// Child component optimized with React.memo\nconst ChildComponent = React.memo(({ onButtonClick }) => {\n  console.log('ChildComponent re-rendered'); // This will only log if onButtonClick changes or ChildComponent's own state changes\n  return <button onClick={onButtonClick}>Increment from Child</button>;\n});\n```\n\n## When to Use\n-   **`useMemo`**: When you need to compute and store a value that is expensive to calculate, and you want to prevent its re-computation unless its dependencies change.\n-   **`useCallback`**: When you need to maintain the same function reference across renders, typically to optimize child components (preventing unnecessary re-renders of `React.memo` wrapped components) or to provide stable dependencies for other hooks like `useEffect` or `useMemo`.\n\nIt's important to use these hooks judiciously. Memoization adds overhead; its benefits are only realized when the cost of re-computation/re-creation outweighs the cost of memoization itself.",
      "examples": [
        {
          "id": "example_usememo_expensive_calculation",
          "title": "useMemo: Expensive Calculation Example",
          "code": "import React, { useState, useMemo } from 'react';\n\nfunction ExpensiveCalculation() {\n  const [count, setCount] = useState(0);\n  const [otherState, setOtherState] = useState(0);\n  \n  // This expensive calculation only runs when count changes\n  const expensiveValue = useMemo(() => {\n    console.log('Computing expensive value...');\n    // Simulate expensive calculation\n    let result = 0;\n    for (let i = 0; i < count * 1000; i++) {\n      result += i;\n    }\n    return result;\n  }, [count]);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <p>Other state: {otherState}</p>\n      <p>Expensive calculated value: {expensiveValue}</p>\n      <button onClick={() => setCount(count + 1)}>Increment count</button>\n      <button onClick={() => setOtherState(otherState + 1)}>\n        Increment other state (doesn't trigger expensive calculation)\n      </button>\n    </div>\n  );\n}",
          "explanation": "This example demonstrates how `useMemo` prevents an expensive calculation from running on every render. When 'Increment count' is clicked, `count` changes, triggering the `useMemo` callback to re-run and re-calculate `expensiveValue`. However, when 'Increment other state' is clicked, only `otherState` changes. Since `otherState` is not in `useMemo`'s dependency array, the 'Computing expensive value...' message will not appear, indicating the calculation was skipped, showcasing the optimization.",
          "language": "typescript"
        },
        {
          "id": "example_usecallback_stable_function",
          "title": "useCallback: Passing Stable Function to Child",
          "code": "import React, { useState, useCallback, memo } from 'react';\n\nconst ChildComponent = memo(({ onButtonClick }) => {\n  console.log('ChildComponent re-rendered');\n  return <button onClick={onButtonClick}>Click me</button>;\n});\n\nfunction ParentComponent() {\n  const [parentCount, setParentCount] = useState(0);\n  const [otherState, setOtherState] = useState(0);\n\n  // Memoize the callback function\n  const handleClick = useCallback(() => {\n    setParentCount(prevCount => prevCount + 1);\n  }, []); // Empty dependency array means the function reference is stable across renders\n\n  return (\n    <div>\n      <p>Parent Count: {parentCount}</p>\n      <p>Other State: {otherState}</p>\n      <ChildComponent onButtonClick={handleClick} />\n      <button onClick={() => setOtherState(otherState + 1)}>Change Other State (Parent)</button>\n    </div>\n  );\n}",
          "explanation": "In this example, `ChildComponent` is wrapped with `React.memo`, meaning it will only re-render if its props change. `handleClick` is memoized using `useCallback` with an empty dependency array, ensuring its reference remains stable. When `otherState` in `ParentComponent` changes, `ParentComponent` re-renders, but `ChildComponent` does not because `onButtonClick` (its only prop) retains the same reference. This prevents unnecessary re-renders of `ChildComponent`.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Hooks",
        "useMemo",
        "useCallback",
        "Performance",
        "Optimization",
        "Memoization"
      ],
      "prerequisites": [
        "react_functional_components",
        "react_state_management",
        "react_props"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Hooks",
      "useMemo",
      "useCallback",
      "Performance",
      "Optimization",
      "Memoization"
    ],
    "prerequisites": [
      "react_functional_components",
      "react_state_management",
      "react_props"
    ]
  },
  {
    "index": 84,
    "id": "theory_fetching_data_hooks",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "Fetching Data with Hooks (useEffect)",
    "description": "",
    "content": {
      "id": "theory_fetching_data_hooks",
      "title": "Fetching Data with Hooks (useEffect)",
      "description": "",
      "type": "theory",
      "content": "In React functional components, the `useEffect` hook is commonly used to perform side effects, including data fetching. When `useEffect` is provided with an empty dependency array (`[]`), the effect runs only once after the initial render, mimicking the behavior of `componentDidMount` in class components. This is crucial for data fetching to prevent infinite loops.\n\nWhen fetching data, it's common to use `async/await` syntax for handling asynchronous operations. However, the function passed to `useEffect` cannot be directly `async` because it must return either nothing or a cleanup function. Therefore, the `async` function for data fetching is typically defined inside the `useEffect` callback and then immediately invoked.\n\nPopular libraries like `axios` or the built-in `fetch` API are used to make HTTP requests. After the data is successfully fetched, it's stored in the component's state using a state setter function (e.g., `setData`), triggering a re-render with the new data.\n\n### Key Concepts\n-   `useEffect` Hook: For performing side effects in functional components.\n-   Dependency Array (`[]`): Controls when the effect runs. An empty array means it runs once on mount.\n-   Asynchronous Operations: Handling promises with `async/await`.\n-   State Management: Updating component state with fetched data.",
      "examples": [
        {
          "id": "example_fetching_data_hooks_1",
          "title": "Basic Data Fetching with useEffect and Axios",
          "code": "import React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nfunction DataFetcher() {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const result = await axios('http://hn.algolia.com/api/v1/search?query=react');\n        setData(result.data);\n        setError(null);\n      } catch (err) {\n        setError(err);\n        setData(null);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, []); // Empty dependency array ensures this runs once on mount\n\n  if (loading) return <div>Loading data...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  if (!data || !data.hits) return <div>No data found.</div>;\n\n  return (\n    <div>\n      <h2>Fetched Data</h2>\n      <ul>\n        {data.hits.map((item) => (\n          <li key={item.objectID}>{item.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default DataFetcher;",
          "explanation": "This example demonstrates fetching data using `useEffect` with an empty dependency array. An inner `async` function `fetchData` is defined and immediately called to handle the asynchronous API request. State variables `data`, `loading`, and `error` are used to manage the different states of the data fetching process, providing a robust user experience.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React Hooks",
        "useEffect",
        "Data Fetching",
        "Async/Await",
        "Axios",
        "Side Effects"
      ],
      "prerequisites": [
        "javascript_async_await",
        "react_state",
        "react_functional_components"
      ],
      "technology": "React"
    },
    "tags": [
      "React Hooks",
      "useEffect",
      "Data Fetching",
      "Async/Await",
      "Axios",
      "Side Effects"
    ],
    "prerequisites": [
      "javascript_async_await",
      "react_state",
      "react_functional_components"
    ]
  },
  {
    "index": 123,
    "id": "theory_react_memoization",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Performance Optimization with useMemo, useCallback, and React.memo",
    "description": "",
    "content": {
      "id": "theory_react_memoization",
      "title": "React Performance Optimization with useMemo, useCallback, and React.memo",
      "description": "",
      "type": "theory",
      "content": "React provides several hooks and HOCs (Higher-Order Components) to optimize component re-renders and improve application performance. The core idea behind these optimizations is 'memoization', a technique that caches the result of a function call and returns the cached result when the same inputs occur again, avoiding re-computation or re-rendering.\n\n## `useMemo` Hook\n`useMemo` is a React Hook that lets you cache the result of an expensive calculation between re-renders. It takes two arguments: a 'create' function and a dependency array. The create function is executed only when one of the dependencies in the array changes. If the dependencies are the same as the last render, `useMemo` returns the previously computed value, preventing unnecessary re-calculations.\n\n### When to use `useMemo`:\n*   **Expensive Calculations**: For computations that consume significant CPU time or resources.\n*   **Preventing Re-renders of Child Components**: When a calculated value is passed as a prop to a child component, `useMemo` can ensure the child only re-renders if the calculated value itself changes, and not just because the parent re-rendered.\n*   **Referential Equality**: When you need to preserve object or array reference equality across re-renders for comparisons (e.g., in `useEffect` dependencies or `React.memo` checks).\n\n## `useCallback` Hook\n`useCallback` is a React Hook that lets you cache a function definition between re-renders. It also takes a function and a dependency array. It returns a memoized version of the callback function that only changes if one of the dependencies has changed. This is particularly useful for optimizing child components that rely on referential equality checks for their props (e.g., components wrapped with `React.memo`). If a parent component re-renders, a function defined directly within it would be re-created on every render, leading to unnecessary re-renders in memoized child components.\n\n### When to use `useCallback`:\n*   **Passing Callbacks to Memoized Child Components**: To prevent unnecessary re-renders of child components that are wrapped in `React.memo` and receive callback functions as props.\n*   **Optimizing `useEffect` Dependencies**: To prevent `useEffect` from re-running unnecessarily when a callback function is part of its dependency array.\n\n## `React.memo` HOC\n`React.memo` is a higher-order component that wraps a functional component and memoizes its rendered output. It prevents a functional component from re-rendering if its props have not changed. By default, `React.memo` performs a shallow comparison of the props. If you need more control over the comparison, you can provide a custom comparison function as the second argument to `React.memo`.\n\n### When to use `React.memo`:\n*   **Pure Functional Components**: For components that render the same output given the same props.\n*   **Heavy Components**: Components with complex UI or many nested components that are expensive to render.\n*   **Frequent Re-renders**: Components that re-render often due to parent re-renders but whose props frequently remain the same.\n\n**Important Considerations for Memoization:**\n*   **Overhead**: Memoization itself has a small overhead (memory for caching, comparison logic). It should only be used when the cost of re-rendering or re-computing outweighs this overhead.\n*   **Correct Dependencies**: Incorrect or missing dependencies can lead to stale closures or values, causing bugs. Always ensure the dependency array is accurate.\n*   **Debugging**: Memoization can sometimes make debugging more complex as components might not re-render when expected, leading to stale UI if not correctly implemented.",
      "examples": [
        {
          "id": "example_react_memoization_1",
          "title": "Basic useMemo and useCallback",
          "code": "import React, { useMemo, useCallback, useState } from 'react';\n\nfunction ExpensiveCalculationDisplay({ numbers }) {\n  const sum = useMemo(() => {\n    console.log('Calculating sum...');\n    return numbers.reduce((acc, num) => acc + num, 0);\n  }, [numbers]); // Recalculates only if 'numbers' array changes\n\n  return <p>Sum: {sum}</p>;\n}\n\n// Memoized child component for demonstration\nconst Button = React.memo(({ onClick, label }) => {\n  console.log(`Rendering ${label} Button`);\n  return <button onClick={onClick}>{label}</button>;\n});\n\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n  const [data, setData] = useState([1, 2, 3]);\n\n  // This function would be re-created on every render without useCallback\n  // and cause Button to re-render even if its props haven't conceptually changed.\n  const incrementCount = useCallback(() => {\n    setCount(prevCount => prevCount + 1);\n  }, []); // Empty dependency array means it's created once\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <Button onClick={incrementCount} label=\"Increment\" />\n      <ExpensiveCalculationDisplay numbers={data} />\n      <button onClick={() => setData([...data, Math.random()])}>Add Random Number</button>\n      <button onClick={() => setCount(count + 1)}>Force Parent Re-render</button>\n    </div>\n  );\n}",
          "explanation": "This example demonstrates `useMemo` to cache an expensive sum calculation for the `ExpensiveCalculationDisplay` component, only re-computing when `numbers` changes. `useCallback` is used to memoize the `incrementCount` function, ensuring that the `Button` component (which is wrapped in `React.memo`) does not re-render unnecessarily when `ParentComponent` re-renders due to `data` changes, only when its `onClick` prop (the memoized `incrementCount`) actually changes, which it won't due to `useCallback` with an empty dependency array.",
          "language": "typescript"
        },
        {
          "id": "example_react_memoization_2",
          "title": "React.memo with Custom Comparison",
          "code": "import React from 'react';\n\ninterface ItemProps {\n  item: { id: number; value: string; timestamp: number; };\n  onClick: (id: number) => void;\n}\n\n// Custom comparison function for React.memo\n// Only re-render if id or value changes, ignore timestamp\nconst areEqual = (prevProps: ItemProps, nextProps: ItemProps) => {\n  return (\n    prevProps.item.id === nextProps.item.id &&\n    prevProps.item.value === nextProps.item.value &&\n    prevProps.onClick === nextProps.onClick // Ensure callback is stable\n  );\n};\n\nconst MemoizedListItem = React.memo(({\n  item,\n  onClick\n}: ItemProps) => {\n  console.log(`Rendering Item: ${item.value}`);\n  return (\n    <li onClick={() => onClick(item.id)}>\n      {item.value} (ID: {item.id})\n    </li>\n  );\n}, areEqual);\n\nfunction ItemList({ items, onItemClick }) {\n  return (\n    <ul>\n      {items.map(item => (\n        <MemoizedListItem key={item.id} item={item} onClick={onItemClick} />\n      ))}\n    </ul>\n  );\n}",
          "explanation": "This example shows `React.memo` with a custom comparison function (`areEqual`). The `MemoizedListItem` will only re-render if its `id`, `value`, or `onClick` prop changes. The `timestamp` property on the `item` object is explicitly ignored in the comparison, demonstrating how to fine-tune re-render behavior for specific use cases where a shallow comparison might be too broad or too narrow.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Performance",
        "Optimization",
        "Hooks",
        "useMemo",
        "useCallback",
        "React.memo",
        "Memoization"
      ],
      "prerequisites": [
        "react_functional_components",
        "react_state_props"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Performance",
      "Optimization",
      "Hooks",
      "useMemo",
      "useCallback",
      "React.memo",
      "Memoization"
    ],
    "prerequisites": [
      "react_functional_components",
      "react_state_props"
    ]
  },
  {
    "index": 131,
    "id": "theory_class_method_binding",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "Class Method Binding in React",
    "description": "",
    "content": {
      "id": "theory_class_method_binding",
      "title": "Class Method Binding in React",
      "description": "",
      "type": "theory",
      "content": "In React class components, the `this` keyword inside a method does not automatically refer to the component instance when the method is passed as an event handler (e.g., to an `onClick` prop). This is because JavaScript's `this` context depends on how the function is called, not where it's defined. When a class method is called as an event handler, `this` typically becomes `undefined` in strict mode (which React uses internally), leading to errors like `TypeError: Cannot read property 'setState' of undefined`.\n\nTo ensure `this` correctly refers to the component instance within class methods, binding is necessary. There are several common approaches:\n\n## Binding Approaches\n\n1.  **Binding in the Constructor:** This is a traditional and widely accepted method. Binding once in the constructor ensures that the method's `this` context is permanently bound to the component instance for all future calls. It's performant as the binding only happens once when the component is created.\n2.  **Using Arrow Functions as Class Properties (Class Fields Syntax):** This modern syntax leverages ES6 arrow functions, which lexically bind `this`. This means the `this` inside an arrow function automatically refers to the `this` of the enclosing context (the class instance). This approach is often preferred for its cleaner syntax and automatic binding, eliminating the need for explicit constructor binding. It requires transpilation (e.g., with Babel).\n3.  **Arrow Function in the `render` Method (Inline Binding):** This approach involves defining an arrow function directly within the `render` method and calling the class method inside it. While seemingly convenient, this method creates a *new function* on every render. If the component re-renders frequently, this can lead to performance issues as React's reconciliation process might see a new function prop each time, potentially causing re-renders of child components that receive this function as a prop, even if their state hasn't fundamentally changed. This method is generally discouraged for performance-critical scenarios or when passing the function down to child components as props, but can be acceptable for very simple, isolated cases.\n\n## Why Binding is Important\n\n*   **Correct `this` context:** Ensures `this` inside your event handlers correctly points to the component instance, allowing access to `this.state`, `this.props`, and `this.setState()`.\n*   **Preventing Errors:** Avoids `TypeError` due to `this` being `undefined`.\n*   **Maintaining Component State:** Allows methods to interact with and update the component's internal state reliably.",
      "examples": [
        {
          "id": "example_class_method_binding_1",
          "title": "Option 1: Bind in Constructor",
          "code": "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    // Bind 'this' to handleClick once in the constructor\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        Clicked {this.state.count} times\n      </button>\n    );\n  }\n}",
          "explanation": "In this example, `this.handleClick` is explicitly bound to the component instance (`this`) inside the constructor. This ensures that whenever `handleClick` is invoked as an event listener, its `this` context will correctly refer to `MyComponent`'s instance. This is efficient as the binding happens only once.",
          "language": "javascript"
        },
        {
          "id": "example_class_method_binding_2",
          "title": "Option 2: Use Arrow Functions for Class Methods (Class Fields)",
          "code": "class MyComponent extends React.Component {\n  state = { count: 0 };\n\n  // Use an arrow function as a class property\n  handleClick = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        Clicked {this.state.count} times\n      </button>\n    );\n  }\n}",
          "explanation": "Here, `handleClick` is defined as a class property using an arrow function. Arrow functions automatically bind `this` to the lexical scope in which they are defined. In this case, `this` inside `handleClick` will always refer to the `MyComponent` instance, eliminating the need for explicit binding in the constructor. This is a popular and concise approach.",
          "language": "javascript"
        },
        {
          "id": "example_class_method_binding_3",
          "title": "Option 3: Arrow Function in Render (Inline Binding)",
          "code": "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  handleClick() {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      // A new function is created on every render\n      <button onClick={() => this.handleClick()}>\n        Clicked {this.state.count} times\n      </button>\n    );\n  }\n}",
          "explanation": "This approach defines a new arrow function `() => this.handleClick()` directly within the `render` method. While it works, a new function instance is created on *every* re-render of `MyComponent`. If this component re-renders frequently or passes this function down to optimized child components (e.g., PureComponent or `memo`), it can negatively impact performance due to unnecessary re-renders of children. It's generally less preferred than the first two options.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Class Components",
        "ES6",
        "Binding",
        "this context",
        "Performance"
      ],
      "prerequisites": [
        "javascript_this_keyword",
        "javascript_arrow_functions",
        "react_class_components",
        "react_state"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Class Components",
      "ES6",
      "Binding",
      "this context",
      "Performance"
    ],
    "prerequisites": [
      "javascript_this_keyword",
      "javascript_arrow_functions",
      "react_class_components",
      "react_state"
    ]
  },
  {
    "index": 137,
    "id": "theory_react_error_boundaries",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Error Boundaries",
    "description": "",
    "content": {
      "id": "theory_react_error_boundaries",
      "title": "React Error Boundaries",
      "description": "",
      "type": "theory",
      "content": "Error Boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the crashed component tree. They allow you to gracefully handle errors without unmounting the entire application.\n\n## Key Concepts\n*   **Purpose**: Catch errors in the component tree, log them, and display a fallback UI.\n*   **Mechanism**: Implemented as class components using `static getDerivedStateFromError()` and/or `componentDidCatch()` lifecycle methods.\n    *   `static getDerivedStateFromError(error)`: A static method called during the render phase. It receives the error that was thrown and should return a state object to update the component's state, causing it to re-render with the fallback UI.\n    *   `componentDidCatch(error, errorInfo)`: An instance method called during the commit phase. It receives the error and an object with `componentStack` (information about which component threw the error). This method is typically used for side effects like logging errors to an error reporting service.\n\n## Important Notes on Error Boundaries\n1.  Error boundaries **only catch errors in the components below them in the tree**. They do not catch errors within:\n    *   Event handlers (e.g., `onClick`, `onChange`).\n    *   Asynchronous code (e.g., `setTimeout` or `requestAnimationFrame` callbacks, `Promise` callbacks).\n    *   Server-side rendering (SSR).\n    *   Errors thrown in the error boundary itself.\n2.  As of React 16, errors that are *not* caught by any error boundary will result in the unmounting of the entire React component tree, leaving a blank page.\n3.  Error boundaries **must be class components**. There is no direct hook equivalent provided by React itself. However, third-party libraries offer functional alternatives.\n4.  You would typically place error boundaries at strategic locations in your app, such as route-level components or wrapping widgets that might fail independently, to isolate potential crashes.\n\n## Using a Third-Party Library (e.g., `react-error-boundary`)\nFor functional components, libraries like `react-error-boundary` provide a convenient way to implement error boundaries without writing a class component. They abstract the class component implementation behind a functional API.\n\nThe `ErrorBoundary` component from `react-error-boundary` typically accepts a `FallbackComponent` prop (a component to render when an error occurs), `onReset` (a function called when the `resetErrorBoundary` callback is invoked), and `resetKeys` (an array of keys that, when changed, will reset the error boundary's state, allowing a retry).\n\n",
      "examples": [
        {
          "id": "example_error_boundary_class_component",
          "title": "Basic Class Component Error Boundary",
          "code": "import React, { Component } from 'react';\n\nclass MyErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render shows the fallback UI.\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // You can also log the error to an error reporting service\n    console.error(\"Caught an error:\", error, errorInfo);\n    this.setState({\n      error: error,\n      errorInfo: errorInfo\n    });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return (\n        <div style={{ padding: '20px', border: '1px solid red', color: 'red' }}>\n          <h2>Something went wrong.</h2>\n          <details style={{ whiteSpace: 'pre-wrap' }}>\n            {this.state.error && this.state.error.toString()}\n            <br />\n            {this.state.errorInfo && this.state.errorInfo.componentStack}\n          </details>\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n\n// Usage example:\n// function App() {\n//   return (\n//     <MyErrorBoundary>\n//       <ComponentThatMightThrow />\n//     </MyErrorBoundary>\n//   );\n// }\n",
          "explanation": "This example demonstrates a fundamental class-based error boundary. `getDerivedStateFromError` is used to update the component's state to trigger a re-render with the fallback UI, while `componentDidCatch` is used for logging the error or performing other side effects. The `render` method conditionally displays the children or the fallback UI based on `hasError` state. This pattern isolates errors within a part of the UI, preventing the entire application from crashing.",
          "language": "typescript"
        },
        {
          "id": "example_error_boundary_third_party",
          "title": "Using `react-error-boundary` Library",
          "code": "import { ErrorBoundary } from 'react-error-boundary';\nimport React from 'react';\n\nfunction ErrorFallback({ error, resetErrorBoundary }) {\n  return (\n    <div role=\"alert\" style={{ padding: '20px', border: '1px solid orange', color: 'orange' }}>\n      <p>Something went wrong (via `react-error-boundary`):</p>\n      <pre>{error.message}</pre>\n      <button onClick={resetErrorBoundary}>Try again</button>\n    </div>\n  );\n}\n\nfunction ComponentThatMightThrow() {\n  // Simulate an error for demonstration\n  const [shouldThrow, setShouldThrow] = React.useState(false);\n  \n  if (shouldThrow) {\n    throw new Error('I crashed!');\n  }\n\n  return (\n    <div>\n      <p>This is a component that might throw an error.</p>\n      <button onClick={() => setShouldThrow(true)}>Trigger Error</button>\n    </div>\n  );\n}\n\nfunction AppWithErrorBoundary() {\n  return (\n    <ErrorBoundary \n      FallbackComponent={ErrorFallback}\n      onReset={() => {\n        // Reset the state of your app here, e.g., navigate home or clear data\n        console.log('Error boundary reset!');\n      }}\n      resetKeys={['someKey']} // Changing this key would reset the boundary\n    >\n      <ComponentThatMightThrow />\n    </ErrorBoundary>\n  );\n}\n\nexport default AppWithErrorBoundary;\n",
          "explanation": "This example shows how to use the popular `react-error-boundary` library. It provides a simple `ErrorBoundary` component that accepts a `FallbackComponent` (a functional component to render on error), `onReset` callback for recovery logic, and `resetKeys` to imperatively reset the error state. This abstracts away the need for a class component, making error handling more convenient in functional component heavy applications.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Error Handling",
        "Error Boundaries",
        "Component Lifecycle",
        "Class Components",
        "Functional Components"
      ],
      "prerequisites": [
        "React Components",
        "Class Components",
        "Functional Components",
        "State Management",
        "Lifecycle Methods"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Error Handling",
      "Error Boundaries",
      "Component Lifecycle",
      "Class Components",
      "Functional Components"
    ],
    "prerequisites": [
      "React Components",
      "Class Components",
      "Functional Components",
      "State Management",
      "Lifecycle Methods"
    ]
  },
  {
    "index": 141,
    "id": "theory_form_best_practices",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "Form Submission Best Practices in React",
    "description": "",
    "content": {
      "id": "theory_form_best_practices",
      "title": "Form Submission Best Practices in React",
      "description": "",
      "type": "theory",
      "content": "Form handling is a crucial part of web development, and implementing forms correctly ensures a good user experience, data integrity, and security. In React, several best practices emerge for managing form state, validation, and accessibility.\n\n## Key Concepts\n\n### 1. Client-side and Server-side Validation\n\n**Client-side validation** provides immediate feedback to the user, improving user experience by preventing unnecessary server requests and guiding the user to correct errors quickly. It checks input formats, required fields, and basic constraints.\n\n**Server-side validation** is absolutely essential for security and data integrity. Client-side validation can be bypassed, so all data submitted to the server *must* be re-validated on the server. This prevents malicious data injection, ensures business logic is adhered to, and guards against corrupted data.\n\n### 2. Controlled Components\n\nIn React, a 'controlled component' is a form element (like `<input>`, `<textarea>`, or `<select>`) whose value is controlled by React state. The state is the single source of truth. When the user types into a controlled input, an `onChange` event handler updates the component's state, and the input's `value` prop is then re-rendered with the new state. This provides a clear, reactive way to manage form data.\n\n### 3. Form Libraries for Complex Forms\n\nFor forms with many fields, complex validation rules, or multi-step flows, managing state and logic manually can become cumbersome. Libraries like Formik, React Hook Form, or Redux Form abstract away much of the boilerplate, providing:\n-   Simplified state management for form values, errors, and touched fields.\n-   Declarative validation schemas (e.g., using Yup or Zod).\n-   Performance optimizations (e.g., preventing unnecessary re-renders).\n-   Helpers for submission, resetting, and field-level interactions.\n\n### 4. Proper Error Handling\n\nClear and timely error messages are vital for user experience. Errors should be displayed inline, close to the problematic input field, and clearly explain what went wrong and how to fix it. This includes:\n-   **Validation errors**: Informing the user about incorrect input format or missing fields.\n-   **Submission errors**: Handling network issues, server-side validation failures, or other backend problems.\n\n### 5. ARIA Attributes for Accessibility\n\nARIA (Accessible Rich Internet Applications) attributes provide semantic meaning to elements, making web content and applications more accessible to people with disabilities, especially those using screen readers. For forms, common ARIA attributes include:\n-   `aria-labelledby` / `aria-describedby`: Linking labels/descriptions to form controls.\n-   `aria-required`: Indicating a required field.\n-   `aria-invalid`: Indicating an invalid input field.\n-   `aria-live`: For dynamic content updates, such as submission messages or real-time validation feedback.\n\n### 6. Visual Feedback During Submission\n\nWhen a user submits a form, especially if it involves an asynchronous operation (like an API call), it's important to provide visual feedback. This prevents the user from submitting the form multiple times, assures them that the action is being processed, and improves perceived performance. Examples include:\n-   Disabling the submit button.\n-   Displaying a loading spinner or progress bar.\n-   Changing the button text (e.g., \"Submitting...\").\n\n### 7. User Experience (UX) for Multi-step Forms\n\nMulti-step forms break down complex data collection into smaller, manageable sections. Good UX for these forms includes:\n-   **Progress indicators**: Clearly showing the user which step they are on and how many steps remain.\n-   **Clear navigation**: Obvious \"Next\" and \"Back\" buttons.\n-   **Data persistence**: Allowing users to navigate back and forth without losing previously entered data.\n-   **Error summaries**: Consolidating errors across steps before final submission.\n",
      "examples": [
        {
          "id": "example_form_best_practices_1",
          "title": "Basic Controlled Component with Client-Side Validation",
          "code": "import React, { useState } from 'react';\n\nfunction LoginForm() {\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const [emailError, setEmailError] = useState('');\n  const [passwordError, setPasswordError] = useState('');\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  const validateForm = () => {\n    let isValid = true;\n    setEmailError('');\n    setPasswordError('');\n\n    if (!email) {\n      setEmailError('Email is required.');\n      isValid = false;\n    } else if (!/^[\\w-]+(\\.[\\w-]+)*@([a-z0-9-]+(\\.[a-z0-9-]+)*?\\.[a-z]{2,6}|(\\d{1,3}\\.){3}\\d{1,3})(:\\d{4})?$/.test(email)) {\n      setEmailError('Invalid email format.');\n      isValid = false;\n    }\n\n    if (!password) {\n      setPasswordError('Password is required.');\n      isValid = false;\n    } else if (password.length < 6) {\n      setPasswordError('Password must be at least 6 characters.');\n      isValid = false;\n    }\n\n    return isValid;\n  };\n\n  const handleSubmit = async (event) => {\n    event.preventDefault();\n    if (validateForm()) {\n      setIsSubmitting(true);\n      // Simulate API call\n      try {\n        await new Promise(resolve => setTimeout(resolve, 1500));\n        console.log('Form submitted successfully:', { email, password });\n        alert('Login successful!');\n        // Clear form or redirect\n      } catch (error) {\n        console.error('Submission error:', error);\n        alert('Login failed. Please try again.');\n      } finally {\n        setIsSubmitting(false);\n      }\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px', maxWidth: '300px', margin: '20px auto', padding: '20px', border: '1px solid #ccc', borderRadius: '5px' }}>\n      <h2>Login</h2>\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input\n          type=\"email\"\n          id=\"email\"\n          value={email}\n          onChange={(e) => setEmail(e.target.value)}\n          aria-required=\"true\"\n          aria-invalid={!!emailError}\n          aria-describedby=\"email-error\"\n          disabled={isSubmitting}\n        />\n        {emailError && <div id=\"email-error\" style={{ color: 'red', fontSize: '0.8em' }}>{emailError}</div>}\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password:</label>\n        <input\n          type=\"password\"\n          id=\"password\"\n          value={password}\n          onChange={(e) => setPassword(e.target.value)}\n          aria-required=\"true\"\n          aria-invalid={!!passwordError}\n          aria-describedby=\"password-error\"\n          disabled={isSubmitting}\n        />\n        {passwordError && <div id=\"password-error\" style={{ color: 'red', fontSize: '0.8em' }}>{passwordError}</div>}\n      </div>\n      <button type=\"submit\" disabled={isSubmitting} style={{ padding: '10px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: isSubmitting ? 'not-allowed' : 'pointer' }}>\n        {isSubmitting ? 'Logging in...' : 'Login'}\n      </button>\n    </form>\n  );\n}\n\nexport default LoginForm;\n",
          "explanation": "This example demonstrates a basic login form using React's `useState` hook to manage form input values, validation errors, and submission state. It showcases:\n-   **Controlled Components**: `email` and `password` inputs are bound to state variables.\n-   **Client-side Validation**: The `validateForm` function checks for required fields and basic format, providing immediate feedback.\n-   **Error Handling**: Error messages are displayed below the relevant input field.\n-   **Visual Feedback**: The submit button is disabled and its text changes during submission (`isSubmitting` state).\n-   **ARIA Attributes**: `aria-required`, `aria-invalid`, and `aria-describedby` are used to improve accessibility.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "Forms",
        "React",
        "Validation",
        "Accessibility",
        "UX",
        "Controlled Components"
      ],
      "prerequisites": [
        "React State Management",
        "Event Handling in React",
        "HTML Forms"
      ],
      "technology": "React"
    },
    "tags": [
      "Forms",
      "React",
      "Validation",
      "Accessibility",
      "UX",
      "Controlled Components"
    ],
    "prerequisites": [
      "React State Management",
      "Event Handling in React",
      "HTML Forms"
    ]
  },
  {
    "index": 142,
    "id": "theory_react_hooks_window_dimensions",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Hooks: Managing Window Dimensions with useState and useEffect",
    "description": "",
    "content": {
      "id": "theory_react_hooks_window_dimensions",
      "title": "React Hooks: Managing Window Dimensions with useState and useEffect",
      "description": "",
      "type": "theory",
      "content": "This section covers the fundamental React hooks `useState` and `useEffect` by demonstrating their use in a practical scenario: tracking and displaying browser window dimensions.\n\n## `useState` Hook\n`useState` is a React Hook that lets you add state variables to your components. It returns a pair: the current state value and a function that lets you update it.\n\n-   **State Variable**: Holds the current value (e.g., `dimensions`).\n-   **Setter Function**: A function (e.g., `setDimensions`) used to update the state. When called, it causes the component to re-render with the new state.\n\n```typescript\nconst [stateVariable, setStateVariable] = useState(initialValue);\n```\n\n## `useEffect` Hook\n`useEffect` is a React Hook that lets you perform side effects in function components. Side effects are operations that interact with the outside world, such as data fetching, subscriptions, or manually changing the DOM. It runs after every render of the component.\n\n-   **Effect Function**: The first argument to `useEffect` is a function where you put your side-effect logic.\n-   **Dependency Array**: The second, optional argument is an array of dependencies. `useEffect` will re-run the effect only if any value in this array has changed between renders.\n    -   `[]` (empty array): The effect runs only once after the initial render, similar to `componentDidMount` in class components. This is ideal for setting up event listeners or fetching data that doesn't change.\n    -   No dependency array: The effect runs after every render, including the initial one. This can lead to performance issues if not handled carefully.\n    -   `[prop1, state2]`: The effect runs on initial render and whenever `prop1` or `state2` changes.\n-   **Cleanup Function**: The effect function can optionally return another function. This returned function is the cleanup function. It runs before the component unmounts (similar to `componentWillUnmount`) and before the effect re-runs due to a dependency change. It's crucial for cleaning up subscriptions, timers, or event listeners to prevent memory leaks.\n\n## Window Object and Event Listeners\n-   `window.innerWidth` and `window.innerHeight`: These properties return the interior width and height of the browser window (viewport) in pixels.\n-   `window.addEventListener('event', handler)`: Registers an event handler function to be called when the specified event (e.g., `'resize'`) occurs on the `window` object.\n-   `window.removeEventListener('event', handler)`: Removes an event listener previously registered with `addEventListener`. This is essential for cleanup to avoid memory leaks, especially when the component unmounts or the effect re-runs.\n\n## Example Analysis: `WindowDimensions` Component\n\nThe provided `WindowDimensions` component uses `useState` to manage the `width` and `height` dimensions and `useEffect` to subscribe to and clean up the `'resize'` event.\n\n1.  **State Initialization**: `const [dimensions, setDimensions] = useState({ width: 0, height: 0 });` initializes the state for dimensions.\n2.  **Effect Setup**: The `useEffect` hook is used to manage the `'resize'` event listener.\n    -   `updateDimensions` function is defined to capture the current `window.innerWidth` and `window.innerHeight` and update the state.\n    -   `updateDimensions()` is called once immediately to get the initial dimensions.\n    -   `window.addEventListener('resize', updateDimensions)` registers the listener.\n3.  **Cleanup**: `return () => window.removeEventListener('resize', updateDimensions);` is the cleanup function. It ensures that the event listener is removed when the component unmounts, preventing memory leaks and unnecessary updates.\n4.  **Dependency Array**: The empty `[]` dependency array ensures the effect runs only once on mount and cleans up only on unmount.\n5.  **Rendering**: The component renders the current `dimensions.width` and `dimensions.height` values.\n",
      "examples": [
        {
          "id": "example_window_dimensions_1",
          "title": "Basic Window Dimensions Component",
          "code": "import React, { useState, useEffect } from 'react';\n\nfunction WindowDimensions() {\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n\n  useEffect(() => {\n    const updateDimensions = () => {\n      setDimensions({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n    \n    // Set initial dimensions\n    updateDimensions();\n    \n    // Add event listener\n    window.addEventListener('resize', updateDimensions);\n    \n    // Clean up event listener on component unmount\n    return () => window.removeEventListener('resize', updateDimensions);\n  }, []); // Empty dependency array means this effect runs once on mount and cleans up on unmount\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc' }}>\n      <h2>Window Dimensions</h2>\n      <p>Width: {dimensions.width}px</p>\n      <p>Height: {dimensions.height}px</p>\n    </div>\n  );\n}\n\n// Usage in a parent component (e.g., App.js)\n// function App() {\n//   return <WindowDimensions />;\n// }\n",
          "explanation": "This example directly demonstrates the `WindowDimensions` component provided in the markdown. It showcases the use of `useState` to hold the current `width` and `height`, and `useEffect` to set up and tear down a `resize` event listener. The `updateDimensions` function captures the current `window.innerWidth` and `window.innerHeight` and updates the state, causing a re-render. The empty dependency array `[]` ensures the effect runs only once after the initial render, and the returned cleanup function `return () => window.removeEventListener(...)` is crucial for preventing memory leaks by removing the event listener when the component unmounts.",
          "language": "typescript"
        },
        {
          "id": "example_use_throttle_hook",
          "title": "Custom Hook with Throttling for Window Dimensions",
          "code": "import React, { useState, useEffect, useCallback } from 'react';\n\n// Helper for throttling function calls\nconst throttle = (func, delay) => {\n  let timeoutId = null;\n  let lastArgs = null;\n  let lastThis = null;\n\n  return function(...args) {\n    lastArgs = args;\n    lastThis = this;\n\n    if (!timeoutId) {\n      timeoutId = setTimeout(() => {\n        func.apply(lastThis, lastArgs);\n        timeoutId = null;\n        lastArgs = null;\n        lastThis = null;\n      }, delay);\n    }\n  };\n};\n\n// Custom hook to get throttled window dimensions\nfunction useThrottledWindowDimensions(delay = 200) {\n  const [dimensions, setDimensions] = useState({\n    width: typeof window !== 'undefined' ? window.innerWidth : 0,\n    height: typeof window !== 'undefined' ? window.innerHeight : 0,\n  });\n\n  const updateDimensions = useCallback(\n    throttle(() => {\n      setDimensions({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    }, delay),\n    [delay] // Recalculate throttled function if delay changes\n  );\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n\n    window.addEventListener('resize', updateDimensions);\n    updateDimensions(); // Set initial dimensions\n\n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, [updateDimensions]); // Dependency on updateDimensions ensures effect re-runs if throttled function changes\n\n  return dimensions;\n}\n\n// Component using the custom hook\nfunction ThrottledWindowDimensionsDisplay() {\n  const { width, height } = useThrottledWindowDimensions(100);\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc' }}>\n      <h2>Throttled Window Dimensions</h2>\n      <p>Width: {width}px</p>\n      <p>Height: {height}px</p>\n      <p>Updates throttled to 100ms</p>\n    </div>\n  );\n}\n",
          "explanation": "This advanced example demonstrates creating a reusable custom hook `useThrottledWindowDimensions` that incorporates throttling to optimize performance during rapid resize events. Throttling limits how often a function can run. The `throttle` helper function ensures `updateDimensions` is not called excessively. `useCallback` is used to memoize the throttled function, preventing unnecessary re-creations. The `useEffect` hook now depends on `updateDimensions` (which itself depends on `delay`) to ensure the correct throttled function is always used. This pattern is common for performance-critical DOM event handling in React.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Hooks",
        "useState",
        "useEffect",
        "Lifecycle",
        "Event Handling",
        "Performance",
        "Custom Hooks"
      ],
      "prerequisites": [
        "JavaScript_Functions",
        "DOM_Events",
        "React_Basics_Components"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Hooks",
      "useState",
      "useEffect",
      "Lifecycle",
      "Event Handling",
      "Performance",
      "Custom Hooks"
    ],
    "prerequisites": [
      "JavaScript_Functions",
      "DOM_Events",
      "React_Basics_Components"
    ]
  },
  {
    "index": 156,
    "id": "theory_react_component_design_data_polling",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Component Design, Lifecycle, and Data Polling",
    "description": "",
    "content": {
      "id": "theory_react_component_design_data_polling",
      "title": "React Component Design, Lifecycle, and Data Polling",
      "description": "",
      "type": "theory",
      "content": "This section covers the principles of creating functional React components, managing component lifecycle effects using the `useEffect` hook, handling state with `useState`, performing asynchronous data fetching, and implementing periodic data updates (polling). It also touches upon robust error handling and conditional rendering based on different component states.\n\n## Key Concepts\n\n### Functional Components and Hooks\nReact functional components are JavaScript functions that accept props as arguments and return React elements. Hooks are special functions that let you \"hook into\" React features from functional components. `useState` allows adding state to functional components, while `useEffect` handles side effects like data fetching, subscriptions, or manually changing the DOM.\n\n### `useState` for State Management\n`useState` is a Hook that lets you add React state to functional components. It returns a pair: the current state value and a function that lets you update it. The updater function causes a re-render of the component.\n\n### `useEffect` for Side Effects and Lifecycle\n`useEffect` is used for side effects in functional components. It runs after every render, but you can control when it runs by providing a dependency array.\n\n-   **No dependency array**: Runs after every render.\n-   **Empty dependency array (`[]`)**: Runs only once after the initial render (like `componentDidMount`). Cleanup function runs on unmount (like `componentWillUnmount`).\n-   **With dependencies (`[dep1, dep2]`)**: Runs after the initial render and whenever any dependency in the array changes. Cleanup function runs before re-running the effect and on unmount.\n\n**Cleanup Function**: The `useEffect` hook can return a function. This return function is the cleanup function. It runs before the component unmounts, and also before the effect runs again if the dependencies change. This is crucial for clearing timers, unsubscribing from events, or canceling network requests to prevent memory leaks or unexpected behavior.\n\n### Data Fetching with `fetch` API\nThe `fetch` API provides an interface for fetching resources (e.g., across the network). It returns a Promise that resolves to a `Response` object. It's important to check `response.ok` (status in the 200-299 range) to determine if the request was successful, as `fetch` only rejects a Promise if a network error occurs, not for HTTP errors like 404 or 500.\n\n### Polling\nPolling is a technique where a client repeatedly requests information from a server at a regular interval. This is useful for maintaining up-to-date data without a constant connection (like WebSockets), but it can be inefficient if updates are infrequent or if many clients poll simultaneously.\n\n### Conditional Rendering\nReact allows you to render different elements or components based on certain conditions. This is essential for displaying loading states, error messages, or different UI based on data availability or user permissions.\n\n## Implementation Steps for a Polling Component\n1.  **State Initialization**: Use `useState` to manage loading, error, and online status.\n2.  **Effect for Polling**: Use `useEffect` to initiate the first status check and set up an `setInterval` for periodic checks.\n3.  **Cleanup**: Return a cleanup function from `useEffect` to clear the `setInterval` when the component unmounts to prevent memory leaks.\n4.  **Data Fetching Logic**: Inside the effect, define an `async` function to use `fetch`, handle successful responses (check `response.status === 200`), and `try-catch` for network errors.\n5.  **Conditional UI**: Render different UI elements (loading, error, online, offline) based on the component's state.\n\n",
      "examples": [
        {
          "id": "example_user_status_indicator_1",
          "title": "User Status Indicator Component with Polling",
          "code": "import React, { useState, useEffect } from 'react';\n\nconst UserStatusIndicator = ({ url, pollingInterval = 5000 }) => {\n  const [isOnline, setIsOnline] = useState(null);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // Function to check user status\n    async function checkStatus() {\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          // Handle HTTP errors (e.g., 404, 500)\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        // Consider user online only if status code is 200\n        setIsOnline(response.status === 200);\n        setError(null);\n      } catch (err) {\n        // Handle network errors or errors thrown above\n        setIsOnline(false);\n        setError(err.message);\n      }\n    }\n\n    // Check status immediately on mount\n    checkStatus();\n    \n    // Set up polling interval\n    const intervalId = setInterval(checkStatus, pollingInterval);\n    \n    // Clean up on unmount or before dependencies change\n    return () => {\n      console.log('Clearing interval:', intervalId);\n      clearInterval(intervalId);\n    };\n    \n  }, [url, pollingInterval]); // Dependencies ensure effect re-runs if url or interval changes\n\n  // Loading state\n  if (isOnline === null && !error) {\n    return <div className=\"status-indicator loading\">Checking status...</div>;\n  }\n\n  // Error state\n  if (error) {\n    return <div className=\"status-indicator error\">Error: {error}</div>;\n  }\n\n  // Online/Offline state\n  return (\n    <div className={`status-indicator ${isOnline ? 'online' : 'offline'}`}>\n      <div className=\"indicator-dot\"></div>\n      <span>{isOnline ? 'Online' : 'Offline'}</span>\n    </div>\n  );\n};\n\nexport default UserStatusIndicator;\n",
          "explanation": "This component demonstrates several key React concepts:\n1.  **State Management**: `isOnline` tracks the connection status (null for loading, true for online, false for offline). `error` stores any network or HTTP error messages.\n2.  **Side Effects with `useEffect`**: The `useEffect` hook is used to perform the data fetching logic. It's invoked immediately on mount and then repeatedly at `pollingInterval` using `setInterval`.\n3.  **Dependency Array**: `[url, pollingInterval]` ensures that if these props change, the old interval is cleared, and a new one is set up with the updated values. This is crucial for correct component behavior.\n4.  **Cleanup Function**: The `return () => clearInterval(intervalId);` within `useEffect` is vital. It clears the interval when the component unmounts (or before the effect re-runs due to dependency changes), preventing memory leaks and ensuring resources are properly released.\n5.  **Asynchronous Operations**: `async/await` syntax is used with `fetch` for cleaner asynchronous code.\n6.  **Error Handling**: A `try-catch` block wraps the `fetch` call to catch network errors. Additionally, `response.ok` is checked to handle HTTP response errors (like 404 or 500) that `fetch` itself doesn't throw as rejections.\n7.  **Conditional Rendering**: The component renders different UI elements (`Checking status...`, `Error: ...`, `Online`, `Offline`) based on the `isOnline` and `error` state variables, providing clear user feedback.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Hooks",
        "useEffect",
        "useState",
        "Data Fetching",
        "Polling",
        "Component Design",
        "Error Handling",
        "Conditional Rendering"
      ],
      "prerequisites": [
        "JavaScript Basics",
        "Promises",
        "React Fundamentals"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Hooks",
      "useEffect",
      "useState",
      "Data Fetching",
      "Polling",
      "Component Design",
      "Error Handling",
      "Conditional Rendering"
    ],
    "prerequisites": [
      "JavaScript Basics",
      "Promises",
      "React Fundamentals"
    ]
  },
  {
    "index": 158,
    "id": "theory_react_dynamic_form",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React Dynamic Form Implementation",
    "description": "",
    "content": {
      "id": "theory_react_dynamic_form",
      "title": "React Dynamic Form Implementation",
      "description": "",
      "type": "theory",
      "content": "This theory block describes the implementation of a dynamic form in React, a common requirement in frontend development. A dynamic form is a component that renders its structure (fields, groups, etc.) based on a provided schema, allowing for flexible and configurable form generation without hardcoding each form.\n\n## Key Concepts\n*   **Controlled Components**: In React, form elements like `<input>`, `<textarea>`, and `<select>` maintain their own state. When using controlled components, React state becomes the 'single source of truth' for the input elements. You set the value of an input element from state and update the state via an `onChange` event handler.\n*   **Props for Configuration**: The `DynamicForm` component receives a `formSchema` prop, which is an object defining the structure and content of the form. This includes the form's title, description, and an array of `groups`, each containing its own fields. An `onSubmit` callback prop is also provided for handling form submission.\n*   **State Management with `useState`**: The `useState` hook is used to manage the current values of the form fields. `formValues` holds an object where keys are field IDs and values are the corresponding user inputs. `setFormValues` updates this state.\n*   **Event Handling**: \n    *   `handleSubmit`: This function is triggered when the form is submitted. It prevents the default browser form submission behavior (`e.preventDefault()`) and then calls the `onSubmit` prop with the current `formValues`.\n    *   `handleFieldChange`: This function is passed down to individual form fields (likely within the `FormGroup` component). It updates the `formValues` state whenever an input field's value changes, ensuring the form remains a controlled component.\n*   **Conditional Rendering**: The form description (`formSchema.description`) is rendered only if it exists, using a simple conditional `&&` operator.\n*   **List Rendering (`.map()`)**: The `formSchema.groups` array is iterated over using the `map` method to render multiple `FormGroup` components. Each `FormGroup` receives its specific `group` data, the current `formValues`, and the `handleFieldChange` callback. A unique `key` prop is essential for efficient list rendering in React.\n*   **Component Composition**: The `DynamicForm` leverages component composition by delegating the rendering of individual form groups to a separate `FormGroup` component (which is not provided in the snippet but implied).\n*   **Form Submission Button**: A standard `<button type=\"submit\">` is used, with its text customizable via `formSchema.submitText` or defaulting to 'Submit'.",
      "examples": [
        {
          "id": "example_dynamic_form_1",
          "title": "Basic DynamicForm Structure",
          "code": "import React, { useState } from 'react';\n\nconst FormGroup = ({ group, values, onChange }) => {\n  // This would typically render individual input fields based on group.fields\n  return (\n    <fieldset>\n      <legend>{group.title}</legend>\n      {/* Placeholder for actual input fields */}\n      <p>Group: {group.title}</p>\n      {/* Example of an input inside a FormGroup */}\n      {group.fields && group.fields.map(field => (\n        <div key={field.id}>\n          <label htmlFor={field.id}>{field.label}:</label>\n          <input\n            id={field.id}\n            type={field.type || 'text'}\n            value={values[field.id] || ''}\n            onChange={e => onChange(field.id, e.target.value)}\n          />\n        </div>\n      ))}\n    </fieldset>\n  );\n};\n\nconst DynamicForm = ({ formSchema, onSubmit }) => {\n  const [formValues, setFormValues] = useState({});\n\n  const handleFieldChange = (fieldId, value) => {\n    setFormValues(prevValues => ({\n      ...prevValues,\n      [fieldId]: value,\n    }));\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Form submitted with values:', formValues);\n    onSubmit(formValues);\n  };\n  \n  return (\n    <form onSubmit={handleSubmit} className=\"dynamic-form\">\n      <h2>{formSchema.title}</h2>\n      {formSchema.description && (\n        <p className=\"form-description\">{formSchema.description}</p>\n      )}\n      \n      {formSchema.groups.map(group => (\n        <FormGroup\n          key={group.id}\n          group={group}\n          values={formValues}\n          onChange={handleFieldChange}\n        />\n      ))}\n      \n      <div className=\"form-actions\">\n        <button type=\"submit\" className=\"submit-button\">\n          {formSchema.submitText || 'Submit'}\n        </button>\n      </div>\n    </form>\n  );\n};\n\nexport default DynamicForm;",
          "explanation": "This example shows the `DynamicForm` component using `useState` for `formValues` and `handleFieldChange` to update them. It also includes a basic `FormGroup` component that would typically render actual input fields based on a `group.fields` array. This illustrates how data flows from the parent `DynamicForm` down to `FormGroup` and back up via the `onChange` callback.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Forms",
        "State Management",
        "Controlled Components",
        "Component Composition",
        "Frontend Development"
      ],
      "prerequisites": [
        "react_basics",
        "javascript_es6",
        "dom_events"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Forms",
      "State Management",
      "Controlled Components",
      "Component Composition",
      "Frontend Development"
    ],
    "prerequisites": [
      "react_basics",
      "javascript_es6",
      "dom_events"
    ]
  },
  {
    "index": 160,
    "id": "theory_react_state_and_hooks",
    "type": "theory",
    "moduleId": "react",
    "complexity": 7,
    "title": "React State Management and Essential Hooks (`useState`, `useEffect`, `useRef`)",
    "description": "",
    "content": {
      "id": "theory_react_state_and_hooks",
      "title": "React State Management and Essential Hooks (`useState`, `useEffect`, `useRef`)",
      "description": "",
      "type": "theory",
      "content": "This section covers the fundamental React Hooks (`useState`, `useEffect`, `useRef`) as demonstrated in the provided search component. These hooks are crucial for managing component state, handling side effects, and directly interacting with the DOM.\n\n## `useState` Hook\n`useState` is a React Hook that lets you add state variables to your functional components. It returns a pair: the current state value and a function that lets you update it. When the state updater function is called, React re-renders the component.\n\n**Syntax:** `const [state, setState] = useState(initialState);`\n\n*   `state`: The current value of the state.\n*   `setState`: A function to update the state. It can accept a new value directly or a function that receives the previous state and returns the new state (useful for updates based on previous state).\n*   `initialState`: The initial value of the state variable.\n\nIn the provided code, `searchTerm`, `searchResults`, `selectedIndex`, and `isDropdownOpen` are all managed using `useState`, reflecting user input, search outcomes, UI navigation, and UI visibility.\n\n## `useEffect` Hook\n`useEffect` is a React Hook that lets you synchronize a component with an external system. It's commonly used for side effects like data fetching, subscriptions, or manually changing the DOM.\n\n**Syntax:** `useEffect(() => { /* side effect */ }, [dependencies]);`\n\n*   The first argument is a function containing the side effect logic.\n*   The second argument is an optional dependency array. If provided, the effect will only re-run if any value in the array changes. An empty array (`[]`) means the effect runs only once after the initial render (like `componentDidMount`). Omitting the array means the effect runs after every render.\n\nIn the example, `useEffect` is used to `scrollIntoView` the selected search result. This effect depends on `selectedIndex` and `isDropdownOpen`, ensuring the scrolling happens only when the dropdown is open and the selected item changes.\n\n## `useRef` Hook\n`useRef` is a React Hook that lets you reference a value that's not needed for rendering. It's often used to access a DOM element directly or to persist a mutable value across renders without causing re-renders when it changes.\n\n**Syntax:** `const ref = useRef(initialValue);`\n\n*   It returns a mutable `ref` object whose `.current` property is initialized to the passed `initialValue`.\n*   The `ref.current` property can be updated directly, and these updates do not trigger re-renders.\n\nIn the provided code, `searchInputRef` is used to directly reference the input element, and `resultsContainerRef` is used for the results container, enabling imperative DOM manipulations like `scrollIntoView`.\n\n### Relationship Between Hooks and Component Lifecycle\nWhile hooks don't directly map to lifecycle methods, they provide equivalent functionality:\n*   **Mounting:** `useEffect(() => {}, [])`\n*   **Updating:** `useEffect(() => {}, [dependencies])`\n*   **Unmounting:** `useEffect(() => { return () => { /* cleanup */ }; }, [])` (The return function is the cleanup function.)",
      "examples": [
        {
          "id": "example_usestate_1",
          "title": "Basic useState Example",
          "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <button onClick={() => setCount(prevCount => prevCount - 1)}>Decrement</button>\n    </div>\n  );\n}",
          "explanation": "This example demonstrates `useState` to manage a simple counter. `setCount(count + 1)` directly sets the new value, while `setCount(prevCount => prevCount - 1)` uses a functional update, which is safer when the new state depends on the previous state.",
          "language": "typescript"
        },
        {
          "id": "example_useeffect_useref_1",
          "title": "useEffect and useRef for Focus Management",
          "code": "import React, { useEffect, useRef } from 'react';\n\nfunction MyInput() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // Focus the input element on component mount\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Empty dependency array means this runs once on mount\n\n  return <input type=\"text\" ref={inputRef} placeholder=\"I will be focused!\" />;\n}",
          "explanation": "This example shows `useRef` to get a direct reference to a DOM input element. `useEffect` then uses this ref to call the `focus()` method on the input element once the component mounts.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Hooks",
        "State Management",
        "useEffect",
        "useState",
        "useRef"
      ],
      "prerequisites": [
        "JavaScript_basics",
        "DOM_manipulation_basics",
        "Functional_programming_concepts"
      ],
      "technology": "React"
    },
    "tags": [
      "React",
      "Hooks",
      "State Management",
      "useEffect",
      "useState",
      "useRef"
    ],
    "prerequisites": [
      "JavaScript_basics",
      "DOM_manipulation_basics",
      "Functional_programming_concepts"
    ]
  },
  {
    "index": 28,
    "id": "theory_virtual_dom",
    "type": "theory",
    "moduleId": "default",
    "complexity": 5,
    "title": "Virtual DOM (VDOM) and Reconciliation",
    "description": "",
    "content": {
      "id": "theory_virtual_dom",
      "title": "Virtual DOM (VDOM) and Reconciliation",
      "description": "",
      "type": "theory",
      "content": "The Virtual DOM (VDOM) is a programming concept used by libraries like React, Vue, and others to optimize UI rendering performance. It's an abstract, lightweight copy of the 'real' (browser) DOM kept in memory. The core idea is to minimize direct manipulations of the actual DOM, which are computationally expensive.\n\n## How Virtual DOM Works\n1.  **Initial Render**: When a component first renders, the rendering library (e.g., React) creates a Virtual DOM tree representing the UI. This VDOM tree is then used to construct the actual browser DOM.\n2.  **State/Prop Update**: When the application's state or props change, instead of directly updating the real DOM, the library creates a *new* Virtual DOM tree.\n3.  **Diffing (Reconciliation)**: The library then compares this new VDOM tree with the previous VDOM snapshot. This comparison process is called 'diffing'. It identifies the minimal set of differences between the two trees.\n4.  **Batch Updates**: Once the differences are determined, the library calculates the most efficient way to apply these changes to the actual browser DOM. Multiple updates are often batched together and applied in a single pass to further optimize performance.\n5.  **Real DOM Update**: Only the necessary changes are then applied to the real DOM, leading to fewer and more targeted DOM manipulations.\n\n## Benefits of Virtual DOM\n-   **Performance Optimization**: Minimizes direct DOM manipulations, which are slow. By updating only the necessary parts of the DOM, VDOM significantly improves rendering efficiency.\n-   **Cross-Platform Compatibility**: The VDOM abstraction makes it easier for libraries to support different rendering environments (e.g., web, native mobile, desktop), as the core rendering logic is decoupled from specific DOM APIs.\n-   **Simplified Development**: Developers can treat the UI as a function of state without worrying about the specifics of DOM manipulation. The library handles the updates efficiently.\n-   **Predictable Updates**: The VDOM ensures that updates are applied in a controlled and predictable manner.\n\n## Limitations/Considerations\n-   **Memory Usage**: Maintaining two copies of the DOM (virtual and real) can consume more memory, though the virtual DOM is typically lighter.\n-   **Overhead for Small Updates**: For very small, isolated updates, the overhead of diffing and reconciliation might sometimes be slightly more than direct DOM manipulation, but this is rare in complex applications.\n\n## Comparison with Real DOM\nThe Real DOM (Document Object Model) is a tree-structure interface that browsers use to represent HTML documents. It's a programming interface for web documents. Browsers expose APIs to interact with this DOM (e.g., `document.createElement`, `element.appendChild`). Direct manipulation of the Real DOM can be slow because each change often triggers re-renders, reflows (recalculating element positions and dimensions), and repaints (redrawing elements) of parts of the page, which are expensive operations.",
      "examples": [
        {
          "id": "example_virtual_dom_1",
          "title": "Conceptual VDOM Update Flow",
          "code": "/* \n  Conceptual steps in a React-like VDOM update:\n*/\n\n// 1. Initial Render: Component state initializes, VDOM tree 1 is created.\nconst vdomTree1 = {\n  type: 'div',\n  props: { className: 'container' },\n  children: [\n    { type: 'h1', props: {}, children: ['Hello'] },\n    { type: 'p', props: {}, children: ['World'] }\n  ]\n};\n// Render vdomTree1 to actual DOM\n\n// 2. State Update: User clicks a button, state changes.\n//    A new VDOM tree 2 is created based on the new state.\nconst vdomTree2 = {\n  type: 'div',\n  props: { className: 'container' },\n  children: [\n    { type: 'h1', props: {}, children: ['Hello'] },\n    { type: 'p', props: {}, children: ['React!'] } // 'World' changed to 'React!'\n  ]\n};\n\n// 3. Diffing: Compare vdomTree1 with vdomTree2.\n//    Identifies that only the text content of the <p> element changed.\n\n// 4. Batch Update & Real DOM Update:\n//    React generates a single efficient DOM operation:\n//    `document.querySelector('p').textContent = 'React!';`\n//    No need to re-render the entire <div> or <h1>.\n",
          "explanation": "This conceptual example illustrates how React's VDOM works. Instead of recreating the entire `div` or even the `h1` and `p` elements, the diffing algorithm identifies only the minimal change required (updating the text content of the `p` tag) and applies only that specific change to the real DOM.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "Virtual DOM",
        "Reconciliation",
        "React",
        "Performance",
        "Frontend Architecture",
        "JavaScript"
      ],
      "prerequisites": [
        "JavaScript Fundamentals",
        "DOM Manipulation",
        "Basic Understanding of Frontend Frameworks"
      ],
      "technology": "React, JavaScript"
    },
    "tags": [
      "Virtual DOM",
      "Reconciliation",
      "React",
      "Performance",
      "Frontend Architecture",
      "JavaScript"
    ],
    "prerequisites": [
      "JavaScript Fundamentals",
      "DOM Manipulation",
      "Basic Understanding of Frontend Frameworks"
    ]
  },
  {
    "index": 133,
    "id": "theory_redux_dispatch_hooks",
    "type": "theory",
    "moduleId": "default",
    "complexity": 5,
    "title": "Redux Action Dispatching: `mapDispatchToProps` and React Hooks",
    "description": "",
    "content": {
      "id": "theory_redux_dispatch_hooks",
      "title": "Redux Action Dispatching: `mapDispatchToProps` and React Hooks",
      "description": "",
      "type": "theory",
      "content": "Connecting React components to a Redux store often involves dispatching actions to update the state. Redux provides several patterns for this, including `mapDispatchToProps` for class components (or functional components using `connect`) and dedicated hooks for functional components.\n\n### `mapDispatchToProps` Patterns (with `connect`)\n`mapDispatchToProps` is an optional second argument to Redux's `connect` function. It's a function that receives the `dispatch` method as its first argument and returns an object. The keys of this object will become props passed to your component, and their values should be functions that dispatch Redux actions.\n\nThere are three common ways to define `mapDispatchToProps`:\n\n#### 1. Manually Wrapping Action Creators\nIn this approach, you explicitly define functions that call `dispatch` with the result of your action creators. This gives you full control over how actions are dispatched, including adding middleware logic or specific payload transformations before dispatching.\n\n```typescript\nimport { connect } from 'react-redux';\nimport { addTodo, toggleTodo } from './actions'; // Assuming these are defined elsewhere\n\nconst mapDispatchToProps = (dispatch) => ({\n  addTodo: (text) => dispatch(addTodo(text)),\n  toggleTodo: (id) => dispatch(toggleTodo(id))\n});\n```\n\n#### 2. Using `bindActionCreators`\nThe `bindActionCreators` utility from Redux can be used to automatically wrap action creators in `dispatch` calls. This is useful when you have many action creators and want to avoid manually writing `dispatch(actionCreator(...))` for each one. It takes an object or a function of action creators and the `dispatch` function, returning an object with the same keys but with values wrapped in `dispatch` calls.\n\n```typescript\nimport { bindActionCreators } from 'redux';\nimport { connect } from 'react-redux';\nimport { addTodo, toggleTodo } from './actions';\n\nconst mapDispatchToProps = (dispatch) => ({\n  ...bindActionCreators({ addTodo, toggleTodo }, dispatch)\n});\n```\n\n#### 3. Object Shorthand (Recommended)\nThis is the simplest and most common approach. When you provide an object of action creators directly to `connect` as the `mapDispatchToProps` argument, Redux automatically wraps each action creator in a `dispatch` call for you. This abstracts away the `dispatch` logic entirely, making the code cleaner and more concise.\n\n```typescript\nimport { connect } from 'react-redux';\nimport { addTodo, toggleTodo } from './actions';\n\n// Redux's connect automatically wraps these in dispatch calls\nconst mapDispatchToProps = { addTodo, toggleTodo };\n\n// Usage with connect:\n// export default connect(mapStateToProps, mapDispatchToProps)(MyComponent);\n```\n\nThe third option is generally recommended due to its simplicity and conciseness, reducing boilerplate code.\n\n### Using Redux Hooks with Functional Components\nReact-Redux provides hooks (`useSelector`, `useDispatch`, `useStore`) which are the modern way to interact with the Redux store in functional components, eliminating the need for `connect` for most use cases.\n\n#### `useSelector`\nThe `useSelector` hook allows you to extract data from the Redux store state. It takes a `selector` function as an argument, which receives the entire Redux state as an argument and returns the piece of state you need. `useSelector` automatically subscribes your component to the store, and will re-render your component if the selected state changes.\n\n#### `useDispatch`\nThe `useDispatch` hook returns a reference to the `dispatch` function from the Redux store. You can then use this `dispatch` function to dispatch actions directly from your functional component. This is the equivalent of getting `dispatch` via `mapDispatchToProps` but without the `connect` HOC.\n\n```typescript\nimport { useSelector, useDispatch } from 'react-redux';\nimport { addTodo } from './actions';\n\nfunction TodoList() {\n  // Extracting todos from the state using useSelector\n  const todos = useSelector(state => state.todos);\n  \n  // Getting the dispatch function using useDispatch\n  const dispatch = useDispatch();\n  \n  // Defining a handler to dispatch an action\n  const addNewTodo = (text) => {\n    dispatch(addTodo(text));\n  };\n  \n  return (\n    <div>\n      {/* Render todos */}\n      {todos.map(todo => <div key={todo.id}>{todo.text}</div>)}\n      <button onClick={() => addNewTodo('New Task')}>Add Todo</button>\n    </div>\n  );\n}\n```\n\nUsing hooks often leads to more readable and concise code for Redux integration in functional components."
    },
    "tags": [],
    "prerequisites": []
  },
  {
    "index": 54,
    "id": "theory_react_hooks_testing",
    "type": "theory",
    "moduleId": "react, jest, testing library",
    "complexity": 7,
    "title": "Testing React Custom Hooks with react-hooks-testing-library",
    "description": "",
    "content": {
      "id": "theory_react_hooks_testing",
      "title": "Testing React Custom Hooks with react-hooks-testing-library",
      "description": "",
      "type": "theory",
      "content": "Testing custom React Hooks requires a specific approach different from testing regular React components. `react-hooks-testing-library` is a dedicated library that provides utilities to test hooks in isolation, mimicking their lifecycle within a React component environment without needing to render a full component.\n\n## Key Concepts\n\n### `renderHook`\nThis utility is the primary way to test a hook. It renders a test component internally that calls your hook, allowing you to access its return value and interact with it. It simulates the component lifecycle necessary for hooks to function correctly.\n\n### `result.current`\nThe `renderHook` function returns an object that includes a `result` property. `result.current` holds the latest value returned by your hook. This is the primary way to assert the state or functions exposed by your hook after an action or a re-render.\n\n### `act`\n`act` is a utility from `react-test-renderer` (or `react-dom/test-utils`). When testing React components or hooks, any updates that trigger re-renders or state changes (like calling a state setter, or a function returned by a hook that updates its internal state) should be wrapped in `act()`. This ensures that all React updates are flushed and applied to the DOM (or virtual DOM in tests) before you make assertions. Using `act` prevents warnings about unhandled updates and makes your tests behave closer to how React works in a browser, leading to more reliable test results.\n\n## Lifecycle for Testing Hooks\n1.  **Render the hook:** Use `renderHook(() => yourHook(initialProps))`. This effectively mounts an internal test component and calls your hook.\n2.  **Interact:** Use `act(() => result.current.someFunction())` to simulate user interactions or trigger state updates within the hook. For asynchronous updates, `await act(async () => { ... })` might be necessary, often combined with `waitForNextUpdate`.\n3.  **Assert:** Use `expect(result.current.value).toBe(expectedValue)` to check the hook's state or return values after interactions.\n\n### Example Hook: `useCounter`\nA `useCounter` hook typically manages a numerical state, providing functions to increment and decrement it.",
      "examples": [
        {
          "id": "example_use_counter_hook",
          "title": "Basic `useCounter` Hook Implementation",
          "code": "import { useState, useCallback } from 'react';\n\n/**\n * A custom hook to manage a numerical counter state.\n * @param {number} initialValue The initial value of the counter.\n * @returns {{count: number, increment: () => void, decrement: () => void, reset: () => void}}\n */\nfunction useCounter(initialValue = 0) {\n  const [count, setCount] = useState(initialValue);\n\n  const increment = useCallback(() => {\n    setCount(prevCount => prevCount + 1);\n  }, []);\n\n  const decrement = useCallback(() => {\n    setCount(prevCount => prevCount - 1);\n  }, []);\n\n  const reset = useCallback(() => {\n    setCount(initialValue);\n  }, [initialValue]);\n\n  return { count, increment, decrement, reset };\n}",
          "explanation": "This code defines a simple `useCounter` custom hook. It uses React's `useState` to manage the `count` state and `useCallback` to memoize the `increment`, `decrement`, and `reset` functions. Memoizing these functions is a good practice for performance when they are passed down to child components, as it prevents their re-creation on every re-render of the component consuming the hook, thus avoiding unnecessary re-renders of the children.",
          "language": "typescript"
        },
        {
          "id": "example_use_counter_testing",
          "title": "Testing `useCounter` with `react-hooks-testing-library`",
          "code": "import { renderHook, act } from '@testing-library/react-hooks';\nimport { useCounter } from './useCounter'; // Assuming useCounter is in useCounter.js\n\ntest('should increment counter', () => {\n  const { result } = renderHook(() => useCounter(0));\n\n  act(() => {\n    result.current.increment();\n  });\n\n  expect(result.current.count).toBe(1);\n});\n\ntest('should decrement counter', () => {\n  const { result } = renderHook(() => useCounter(10));\n\n  act(() => {\n    result.current.decrement();\n  });\n\n  expect(result.current.count).toBe(9);\n});\n\ntest('should reset counter to initial value', () => {\n  const { result } = renderHook(() => useCounter(5));\n  act(() => {\n    result.current.increment();\n    result.current.increment();\n  });\n  expect(result.current.count).toBe(7);\n\n  act(() => {\n    result.current.reset();\n  });\n  expect(result.current.count).toBe(5);\n});",
          "explanation": "These tests demonstrate how to use `renderHook` to mount the `useCounter` hook in a test environment. The `act` wrapper is crucial for any operations that update the hook's state (like `increment` or `decrement`) to ensure React updates are processed and the component's state is stable before assertions are made. `result.current` is then used to access the current value of `count` for direct assertions.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React Hooks",
        "Testing",
        "react-hooks-testing-library",
        "Unit Testing",
        "JavaScript"
      ],
      "prerequisites": [
        "react_functional_components",
        "react_hooks_useState_useCallback",
        "jest_basics"
      ],
      "technology": "React, Jest, Testing Library"
    },
    "tags": [
      "React Hooks",
      "Testing",
      "react-hooks-testing-library",
      "Unit Testing",
      "JavaScript"
    ],
    "prerequisites": [
      "react_functional_components",
      "react_hooks_useState_useCallback",
      "jest_basics"
    ]
  },
  {
    "index": 55,
    "id": "theory_styled_components",
    "type": "theory",
    "moduleId": "react, typescript",
    "complexity": 6,
    "title": "Styled Components: CSS-in-JS for React",
    "description": "",
    "content": {
      "id": "theory_styled_components",
      "title": "Styled Components: CSS-in-JS for React",
      "description": "",
      "type": "theory",
      "content": "Styled Components is a popular CSS-in-JS library that allows you to write actual CSS code to style your React components. It leverages tagged template literals to embed CSS directly into your JavaScript, providing a more component-oriented approach to styling.\n\n## Key Concepts\n- **CSS-in-JS**: Write CSS directly within your JavaScript files, collocated with your component logic.\n- **Tagged Template Literals**: Styled Components use JavaScript's tagged template literals (`styled.div` `` `background: blue;` ``) to define styles. This allows for powerful features like prop-based styling and easy interpolation.\n- **Component-Based Styling**: Each styled component is a true React component with styles attached. This promotes modularity and reusability.\n- **Automatic Vendor Prefixing**: Styled Components automatically handles vendor prefixes for CSS properties.\n- **Unique Class Names**: It automatically generates unique class names for your styles, eliminating class name collisions and making debugging easier.\n\n## Core Usage\nTo create a styled component, you import `styled` from `'styled-components'` and then call it with an HTML tag or another React component as a method, followed by a template literal containing your CSS rules.\n\n```jsx\nimport styled from 'styled-components';\n\n// Create a styled div\nconst Wrapper = styled.div`\n  padding: 4em;\n  background: papayawhip;\n`;\n\n// Create a styled h1\nconst Title = styled.h1`\n  font-size: 1.5em;\n  text-align: center;\n  color: palevioletred;\n`;\n\n// Use it like any other React component\nfunction App() {\n  return (\n    <Wrapper>\n      <Title>{'Lets start first styled component!'}</Title>\n    </Wrapper>\n  );\n}\n```\n\n## Advantages of Styled Components\n- **Component Libraries**: Facilitates building reusable component libraries with consistent styling.\n- **Dynamic Styles**: Easily implement styles that change based on component props or state.\n- **Avoid CSS Class Name Collisions**: Unique class names are generated automatically, preventing global styling conflicts.\n- **Removes Component-Style Mapping**: Styles are directly tied to components, simplifying maintenance and understanding.",
      "examples": [
        {
          "id": "example_styled_components_basic_1",
          "title": "Basic Styled Component Structure",
          "code": "import styled from 'styled-components';\n\nconst Wrapper = styled.div`\n  padding: 4em;\n  background: papayawhip;\n`;\n\nconst Title = styled.h1`\n  font-size: 1.5em;\n  text-align: center;\n  color: palevioletred;\n`;\n\nfunction App() {\n  return (\n    <Wrapper>\n      <Title>{'Lets start first styled component!'}</Title>\n    </Wrapper>\n  );\n}",
          "explanation": "This example demonstrates the fundamental way to define and use styled components. `Wrapper` and `Title` are created using `styled.<element>`` `CSS rules` syntax and then used as regular React components in the `App` function.",
          "language": "typescript"
        },
        {
          "id": "example_styled_components_props_2",
          "title": "Dynamic Styles with Props",
          "code": "import styled from 'styled-components';\n\nconst Button = styled.button`\n  background: ${props => props.primary ? 'palevioletred' : 'white'};\n  color: ${props => props.primary ? 'white' : 'palevioletred'};\n  font-size: 1em;\n  margin: 1em;\n  padding: 0.25em 1em;\n  border: 2px solid palevioletred;\n  border-radius: 3px;\n`;\n\nfunction MyComponent() {\n  return (\n    <>\n      <Button>Normal Button</Button>\n      <Button primary>Primary Button</Button>\n    </>\n  );\n}",
          "explanation": "This example shows how to make styles dynamic using props. The `background` and `color` of the `Button` component change based on whether the `primary` prop is `true`. Inside the template literal, you can access props as a function argument.",
          "language": "typescript"
        },
        {
          "id": "example_styled_components_extend_3",
          "title": "Extending Styles of Another Component",
          "code": "import styled from 'styled-components';\n\nconst Button = styled.button`\n  background: white;\n  color: palevioletred;\n  border: 2px solid palevioletred;\n  border-radius: 3px;\n`;\n\nconst TomatoButton = styled(Button)`\n  color: tomato;\n  border-color: tomato;\n  /* Additional styles specific to TomatoButton */\n  box-shadow: 0 0 5px rgba(255, 99, 71, 0.5);\n`;\n\nfunction MyOtherComponent() {\n  return (\n    <>\n      <Button>Original Button</Button>\n      <TomatoButton>Tomato Button</TomatoButton>\n    </>\n  );\n}",
          "explanation": "This demonstrates style inheritance. `TomatoButton` reuses all styles from the `Button` component and then overrides or adds new styles. This is achieved by passing the `Button` component itself to `styled()`.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "React",
        "CSS-in-JS",
        "Styling",
        "Frontend",
        "Styled Components"
      ],
      "prerequisites": [
        "React Basics",
        "JavaScript ES6 Template Literals",
        "CSS Fundamentals"
      ],
      "technology": "React, TypeScript"
    },
    "tags": [
      "React",
      "CSS-in-JS",
      "Styling",
      "Frontend",
      "Styled Components"
    ],
    "prerequisites": [
      "React Basics",
      "JavaScript ES6 Template Literals",
      "CSS Fundamentals"
    ]
  },
  {
    "index": 64,
    "id": "theory_react_router_v6_private_routes",
    "type": "theory",
    "moduleId": "react, typescript",
    "complexity": 6,
    "title": "Implementing Private Routes with React Router v6",
    "description": "",
    "content": {
      "id": "theory_react_router_v6_private_routes",
      "title": "Implementing Private Routes with React Router v6",
      "description": "",
      "type": "theory",
      "content": "Private routes are a fundamental concept in web applications, used to restrict access to certain parts of the application based on user authentication or authorization status. In React Router v6, this is typically achieved by wrapping protected components with a custom component that checks the authentication status and redirects the user if they are not authenticated.\n\n## Key Concepts\n-   **Authentication Context (`AuthContext` and `useAuth` hook):** A global state management pattern (often using React's Context API) is used to store and provide the user's authentication status (`user` object or `isAuthenticated` boolean) throughout the application. The `useAuth` custom hook simplifies access to this context.\n-   **`RequireAuth` Component:** This is a higher-order component or a wrapper component that encapsulates the logic for checking authentication. It receives `children` (the protected component) as a prop.\n-   **`useLocation` Hook:** Provided by React Router v6, this hook returns the current `location` object, which contains information about the current URL. This is crucial for storing the user's intended destination before redirecting them to the login page.\n-   **`Navigate` Component:** In React Router v6, `<Navigate>` is the declarative way to perform programmatic navigation or redirects. It's a component that, when rendered, changes the current URL.\n-   **`state` Prop of `Navigate`:** This prop allows you to pass arbitrary state along with the navigation. When redirecting an unauthenticated user to the login page, it's good practice to store the `from` path (the page they tried to access) in the navigation state. After successful login, the user can then be redirected back to this `from` path.\n-   **`replace` Prop of `Navigate`:** Setting `replace` to `true` on `<Navigate>` will replace the current entry in the history stack instead of pushing a new one. This is important for redirects (like after login or for private routes) because it prevents the user from being able to use the browser's back button to return to the page they were redirected *from* (e.g., the protected page they couldn't access). If `replace` were not used, hitting the back button after being redirected to login would take them back to the protected page, then immediately redirect them again, creating a frustrating loop.",
      "examples": [
        {
          "id": "example_react_router_v6_private_route_1",
          "title": "Basic RequireAuth Component",
          "code": "import React, { useContext } from 'react';\nimport { Navigate, useLocation } from 'react-router-dom';\n\n// Assume AuthContext and useAuth are defined elsewhere, e.g., in an AuthProvider file\nconst AuthContext = React.createContext(null);\nconst useAuth = () => useContext(AuthContext);\n\n// Private Route component for React Router v6\nfunction RequireAuth({ children }) {\n  const { user } = useAuth(); // Get user from authentication context\n  const location = useLocation(); // Get current location\n\n  if (!user) {\n    // If no user is logged in, redirect to login page\n    // Store the current location in state so we can redirect back after login\n    // `replace` ensures the login page replaces the current entry in history\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  // If user is authenticated, render the children (the protected component)\n  return children;\n}",
          "explanation": "This `RequireAuth` component demonstrates the core logic for protecting routes in React Router v6. It uses the `useAuth` hook to check if a `user` is present (indicating authentication). If not, it leverages the `Navigate` component to redirect to the `/login` path, passing the current `location` in the state. The `replace` prop ensures that the `/login` route replaces the history entry of the attempted protected route, preventing an endless redirect loop when pressing the back button.",
          "language": "typescript"
        },
        {
          "id": "example_react_router_v6_private_route_2",
          "title": "Usage in React Router v6 Application",
          "code": "import React from 'react';\nimport { Routes, Route, BrowserRouter as Router } from 'react-router-dom';\n// Assume AuthProvider, Home, Login, Dashboard components are defined\n\n// Dummy AuthProvider for demonstration\nconst AuthContext = React.createContext(null);\nconst AuthProvider = ({ children }) => {\n  const user = { name: 'TestUser' }; // Simulate logged-in user\n  // const user = null; // Simulate logged-out user\n  return (\n    <AuthContext.Provider value={{ user }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nconst Home = () => <h2>Home Page</h2>;\nconst Login = () => <h2>Login Page</h2>;\nconst Dashboard = () => <h2>Dashboard (Protected)</h2>;\n\n// Re-using the RequireAuth component from the previous example\n// import { RequireAuth } from './RequireAuth'; // In a real app, you'd import it\n\nfunction App() {\n  return (\n    <AuthProvider>\n      <Router>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/login\" element={<Login />} />\n          <Route \n            path=\"/dashboard\" \n            element={\n              <RequireAuth>\n                <Dashboard />\n              </RequireAuth>\n            } \n          />\n          {/* Other routes */}\n        </Routes>\n      </Router>\n    </AuthProvider>\n  );\n}\n\nexport default App;",
          "explanation": "This example shows how the `RequireAuth` component is integrated into a React Router v6 application. The `Dashboard` component, which represents a protected resource, is rendered as `children` inside `RequireAuth`. The entire application is wrapped in `AuthProvider` to make the authentication context available. When a user tries to access `/dashboard`, `RequireAuth` will check their status and either render `Dashboard` or redirect to `/login`.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "React",
        "React Router v6",
        "Authentication",
        "Private Routes",
        "Context API",
        "Hooks"
      ],
      "prerequisites": [
        "react_basics",
        "react_hooks",
        "react_context_api",
        "react_router_v6_basics"
      ],
      "technology": "React, TypeScript"
    },
    "tags": [
      "React",
      "React Router v6",
      "Authentication",
      "Private Routes",
      "Context API",
      "Hooks"
    ],
    "prerequisites": [
      "react_basics",
      "react_hooks",
      "react_context_api",
      "react_router_v6_basics"
    ]
  },
  {
    "index": 161,
    "id": "theory_react_user_search",
    "type": "theory",
    "moduleId": "react, typescript",
    "complexity": 7,
    "title": "React Component: User Search Implementation",
    "description": "",
    "content": {
      "id": "theory_react_user_search",
      "title": "React Component: User Search Implementation",
      "description": "",
      "type": "theory",
      "content": "This theory block describes a typical React functional component designed for searching and displaying user data. It covers fundamental React hooks like `useState` and `useEffect`, conditional rendering, and rendering lists of items.\n\n## Key Concepts\n-   **React Functional Component**: A JavaScript function that returns JSX (JavaScript XML) to describe UI elements. Functional components use hooks to manage state and side effects.\n-   **`useState` Hook**: Used to add state to functional components. It returns a stateful value and a function to update it. When the state changes, the component re-renders.\n-   **`useEffect` Hook**: Used to perform side effects in functional components, such as data fetching, subscriptions, or manually changing the DOM. It runs after every render by default, but its execution can be controlled by specifying dependencies.\n-   **Conditional Rendering**: Displaying different UI elements based on certain conditions (e.g., `isLoading`, `noResults`).\n-   **List Rendering**: Iterating over an array of data and rendering a component for each item. The `key` prop is crucial for performance and stable identity of items in a list, especially when items are added, removed, or reordered.\n-   **Event Handling**: Capturing user interactions (e.g., input changes) and updating component state or triggering logic.\n\n## Implementation Details\nThe `UserSearch` component demonstrates:\n1.  **State Management**: `searchText` (for input value), `users` (filtered user data), `isLoading` (for loading state), and `error` (for potential errors during data fetching/processing).\n2.  **Data Filtering/Search Logic**: The `useEffect` hook is used to simulate data fetching and filtering based on `searchText`. It includes a debouncing mechanism (via `setTimeout` and `clearTimeout`) to prevent excessive re-renders or API calls while the user is typing.\n3.  **Loading and Error States**: The component renders a 'Loading...' message when `isLoading` is true and a 'No results found' message if the filtered `users` array is empty after loading.\n4.  **Displaying Results**: Uses the `map` method to iterate over the `users` array and render each user's details, including address, zip code, and purchased items.",
      "examples": [
        {
          "id": "example_react_user_search_1",
          "title": "Basic useState and Conditional Rendering",
          "code": "import React, { useState } from 'react';\n\nfunction LoadingSpinner() {\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Simulate data loading\n  setTimeout(() => setIsLoading(false), 2000);\n\n  return (\n    <div>\n      {isLoading ? (\n        <p>Loading data...</p>\n      ) : (\n        <p>Data loaded successfully!</p>\n      )}\n    </div>\n  );\n}\n",
          "explanation": "This example shows how `useState` manages a boolean loading state and how conditional rendering is used to display a loading message or the loaded content based on that state.",
          "language": "typescript"
        },
        {
          "id": "example_react_user_search_2",
          "title": "List Rendering with map and Key Prop",
          "code": "import React from 'react';\n\nconst items = [\n  { id: 1, name: 'Apple' },\n  { id: 2, name: 'Banana' },\n  { id: 3, name: 'Cherry' }\n];\n\nfunction ItemList() {\n  return (\n    <ul>\n      {items.map(item => (\n        <li key={item.id}>{item.name}</li>\n      ))}\n    </ul>\n  );\n}\n",
          "explanation": "Demonstrates rendering a list of items using `Array.prototype.map()`. Each `<li>` element is given a unique `key` prop, which is essential for React's reconciliation process to efficiently update lists.",
          "language": "typescript"
        },
        {
          "id": "example_react_user_search_3",
          "title": "Basic useEffect with Debounce",
          "code": "import React, { useState, useEffect } from 'react';\n\nfunction SearchInput() {\n  const [query, setQuery] = useState('');\n  const [debouncedQuery, setDebouncedQuery] = useState('');\n\n  useEffect(() => {\n    const timerId = setTimeout(() => {\n      setDebouncedQuery(query);\n    }, 500);\n\n    return () => {\n      clearTimeout(timerId);\n    };\n  }, [query]);\n\n  return (\n    <input\n      type=\"text\"\n      value={query}\n      onChange={(e) => setQuery(e.target.value)}\n      placeholder=\"Type to search...\"\n    />\n  );\n}\n",
          "explanation": "This example illustrates how `useEffect` can be used to debounce an input value. The `debouncedQuery` state only updates after a 500ms pause in typing, preventing excessive re-renders or API calls. The cleanup function (`return () => clearTimeout(timerId)`) is critical to clear the previous timer if the `query` changes before the timeout fires.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Hooks",
        "State Management",
        "Conditional Rendering",
        "List Rendering",
        "Frontend Development",
        "JavaScript"
      ],
      "prerequisites": [
        "JavaScript Fundamentals",
        "HTML Basics",
        "CSS Basics",
        "ES6+",
        "JSX"
      ],
      "technology": "React, TypeScript"
    },
    "tags": [
      "React",
      "Hooks",
      "State Management",
      "Conditional Rendering",
      "List Rendering",
      "Frontend Development",
      "JavaScript"
    ],
    "prerequisites": [
      "JavaScript Fundamentals",
      "HTML Basics",
      "CSS Basics",
      "ES6+",
      "JSX"
    ]
  },
  {
    "index": 66,
    "id": "theory_react_router_basics_nested_routes",
    "type": "theory",
    "moduleId": "react, react router dom",
    "complexity": 6,
    "title": "React Router Basics and Nested Routes",
    "description": "",
    "content": {
      "id": "theory_react_router_basics_nested_routes",
      "title": "React Router Basics and Nested Routes",
      "description": "",
      "type": "theory",
      "content": "React Router is a standard library for routing in React applications. It enables navigation between different components based on the URL. Key components include `Routes` (a wrapper for all route definitions), `Route` (which defines a mapping between a URL path and a component), and `Outlet` (used for rendering child routes).\n\n## Core Concepts\n\n*   **`Routes` Component**: This component acts as a container for all your `Route` definitions. It listens to the URL and renders the first child `Route` that matches the current location.\n*   **`Route` Component**: Each `Route` component specifies a `path` (the URL segment it matches) and an `element` (the React component to render when the path matches).\n    *   **`path`**: A string representing the URL path. Can include dynamic segments (e.g., `:id`).\n    *   **`element`**: The JSX element to render when the route matches.\n*   **Nested Routes**: React Router allows for nested routing, where a parent route can have its own child routes. This is particularly useful for building layouts where a common UI (like a header, sidebar, or footer) remains consistent while only a specific content area changes.\n*   **`Outlet` Component**: When using nested routes, the `Outlet` component from `react-router-dom` is crucial. It acts as a placeholder where the matched child route's `element` will be rendered. The parent route's component is responsible for rendering the `Outlet` at the desired location within its layout.\n*   **`index` Route**: Within a `Route` that defines nested routes, an `index` route (a `Route` without a `path` property but with an `index` prop) serves as the default child route to render when the parent path is matched but no specific child path is specified. This is useful for defining a default view for a section of your application.\n\n## How Nested Routes Work\nWhen a parent `Route` (e.g., `/dashboard`) is matched, its `element` component is rendered. Inside this component, an `Outlet` component is placed. If a child route (e.g., `/dashboard/stats`) is then matched, the component for `/dashboard/stats` is rendered *inside* the `Outlet` of the `Dashboard` component. This allows for hierarchical UI structures and shared layouts.",
      "examples": [
        {
          "id": "example_react_router_basics_1",
          "title": "Basic App Routing Structure",
          "code": "import React from 'react';\nimport { Routes, Route } from 'react-router-dom';\nimport Home from './components/Home';\nimport Dashboard from './components/Dashboard';\nimport Products from './components/Products';\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Home />} />\n      <Route path=\"dashboard\" element={<Dashboard />} />\n      <Route path=\"products\" element={<Products />} />\n    </Routes>\n  );\n}",
          "explanation": "This example shows a basic `App` component setting up multiple top-level routes. When the URL matches `/`, the `Home` component is rendered. Similarly, `Dashboard` and `Products` components are rendered for their respective paths.",
          "language": "typescript"
        },
        {
          "id": "example_react_router_nested_routes_2",
          "title": "Nested Routes with Layout and Outlet",
          "code": "import React from 'react';\nimport { Routes, Route, Outlet } from 'react-router-dom';\nimport Home from './components/Home';\nimport Dashboard from './components/Dashboard';\nimport Stats from './components/Stats';\nimport Profile from './components/Profile';\nimport Products from './components/Products';\n\n// Layout component for shared UI\nfunction Layout() {\n  return (\n    <div>\n      <header>App Header</header>\n      <nav>Sidebar Navigation</nav>\n      <main>\n        {/* Child routes render here */}\n        <Outlet /> \n      </main>\n      <footer>App Footer</footer>\n    </div>\n  );\n}\n\n// Main App routing setup\nfunction App() {\n  return (\n    <Routes>\n      {/* Parent Route for shared layout */}\n      <Route path=\"/\" element={<Layout />}>\n        {/* Index route for the root path within the layout */}\n        <Route index element={<Home />} />\n        \n        {/* Nested Dashboard routes */}\n        <Route path=\"dashboard\" element={<Dashboard />}>\n          <Route path=\"stats\" element={<Stats />} />\n          <Route path=\"profile\" element={<Profile />} />\n        </Route>\n        \n        {/* Another top-level route under the main layout */}\n        <Route path=\"products\" element={<Products />} />\n      </Route>\n    </Routes>\n  );\n}",
          "explanation": "This example demonstrates nested routing. The `Layout` component provides a consistent header, sidebar, and footer. The `<Outlet />` within `Layout` determines where child routes like `Home`, `Dashboard`, and `Products` (or `Stats`/`Profile` within `Dashboard`) will be rendered. The `index` route `Home` serves as the default content for the `/` path when `Layout` is active.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "React Router",
        "Routing",
        "Nested Routes",
        "UI Layout",
        "Outlet",
        "React"
      ],
      "prerequisites": [
        "react_components",
        "jsx",
        "functional_components"
      ],
      "technology": "React, React Router DOM"
    },
    "tags": [
      "React Router",
      "Routing",
      "Nested Routes",
      "UI Layout",
      "Outlet",
      "React"
    ],
    "prerequisites": [
      "react_components",
      "jsx",
      "functional_components"
    ]
  },
  {
    "index": 87,
    "id": "theory_action_creator",
    "type": "theory",
    "moduleId": "typescript",
    "complexity": 4,
    "title": "Action Creators",
    "description": "",
    "content": {
      "id": "theory_action_creator",
      "title": "Action Creators",
      "description": "",
      "type": "theory",
      "content": "## What are Action Creators?\nAction creators are pure functions in Redux that encapsulate the process of creating action objects. Instead of manually constructing action objects every time you need to dispatch an action, you call an action creator function which returns the pre-formatted action object. This approach simplifies action creation, helps maintain consistency in action structure, and reduces the chance of typos.\n\nAn action object is a plain JavaScript object that describes 'what happened'. It *must* have a `type` property, which is typically a string constant, indicating the type of action performed. It can also contain a `payload` or other properties with the data relevant to the action.\n\n## Benefits of Using Action Creators\n- **Consistency**: Ensures all actions of a certain type have a uniform structure.\n- **Readability**: Makes dispatch calls cleaner and easier to understand.\n- **Reusability**: The same action creator can be used in multiple places within the application.\n- **Testability**: Action creators are pure functions, making them easy to test in isolation.\n- **Type Safety (with TypeScript)**: Can provide strong type checking for action objects.",
      "examples": [
        {
          "id": "example_action_creator_1",
          "title": "Basic Action Creator for Adding a Todo",
          "code": "function addTodo(text) {\n  return {\n    type: 'ADD_TODO',\n    payload: {\n      id: Date.now(),\n      text,\n      completed: false\n    }\n  };\n}",
          "explanation": "This `addTodo` function is an action creator. When called with a `text` argument, it returns an action object with a `type` of 'ADD_TODO' and a `payload` containing the new todo item's data, including a unique ID and `completed` status.",
          "language": "typescript"
        },
        {
          "id": "example_action_creator_2",
          "title": "Action Creator for Adding a Phone",
          "code": "const addPhone = (phoneName) => ({\n  type: 'ADD_PHONE',\n  phone: phoneName\n});",
          "explanation": "This example demonstrates an action creator using an arrow function. It takes a `phoneName` and returns an action object with `type: 'ADD_PHONE'` and a `phone` property carrying the data. This highlights that payload doesn't always have to be nested under a `payload` key, though it's a common pattern.",
          "language": "typescript"
        }
      ],
      "complexity": 4,
      "tags": [
        "Redux",
        "Actions",
        "Action Creator",
        "State Management",
        "Frontend Architecture"
      ],
      "prerequisites": [
        "JavaScript Functions",
        "Object Literals"
      ],
      "technology": "TypeScript"
    },
    "tags": [
      "Redux",
      "Actions",
      "Action Creator",
      "State Management",
      "Frontend Architecture"
    ],
    "prerequisites": [
      "JavaScript Functions",
      "Object Literals"
    ]
  },
  {
    "index": 92,
    "id": "theory_redux_thunk_overview_and_benefits",
    "type": "theory",
    "moduleId": "typescript",
    "complexity": 6,
    "title": "Redux Thunk: Overview, Working Mechanism, and Benefits",
    "description": "",
    "content": {
      "id": "theory_redux_thunk_overview_and_benefits",
      "title": "Redux Thunk: Overview, Working Mechanism, and Benefits",
      "description": "",
      "type": "theory",
      "content": "Redux Thunk is a middleware for Redux that allows you to write action creators that return a function instead of an action object. This function receives the `dispatch` and `getState` methods from the Redux store as arguments, enabling asynchronous logic and conditional dispatching.\n\n### How Redux Thunk Works\nRedux Thunk operates by intercepting dispatched actions before they reach the reducers. Its core mechanism involves a simple check:\n\n1.  **Intercepts Actions**: When an action is dispatched, Redux Thunk is the first middleware to process it.\n2.  **Function Check**: It examines the dispatched 'action'. If the 'action' is a JavaScript function, Redux Thunk recognizes it as a 'thunk'. If it's a plain object (a standard Redux action), it lets it pass through.\n3.  **If Function (Thunk)**: If the 'action' is a function, Redux Thunk executes this function immediately. It calls the function with `dispatch` and `getState` as its primary arguments. Optionally, a third argument, `extraArgument`, can also be passed if configured during middleware setup. The thunk function can then perform asynchronous operations (like API calls), dispatch regular actions based on the results, or access the current state.\n4.  **If Object (Normal Action)**: If the 'action' is a plain JavaScript object, Redux Thunk does not alter it. It simply passes the action to the next middleware in the chain, or directly to the reducer if it's the last middleware.\n\nThis flow allows Redux to handle side effects and asynchronous operations in a clean, Redux-idiomatic way, keeping the reducers pure.\n\n![Redux Thunk Flow](images/redux_thunk.png)\n\n### Benefits of Using Redux Thunk\nRedux Thunk provides several significant advantages for managing state in complex applications:\n\n*   **Asynchronous Actions**: It is primarily used to manage asynchronous operations, such as network requests (API calls), database interactions, or timed events (`setTimeout`, `setInterval`). This allows actions to be delayed or to trigger other actions based on the completion or failure of an async task.\n*   **Conditional Dispatching**: By providing access to the `getState()` function, thunks can read the current state of the application. This enables conditional logic where actions are dispatched only if certain conditions in the state are met. For example, preventing a duplicate API call if data is already fetching.\n*   **Access to State**: The `getState()` argument gives thunks the ability to read the entire Redux state tree. This is crucial for making informed decisions within the thunk function, such as determining if a user is authenticated before attempting an API call, or checking if certain data already exists in the store before fetching it again.\n*   **Encapsulation of Complex Logic**: Thunks help encapsulate complex business logic and side effects away from components and reducers, leading to cleaner, more maintainable code. Components can simply dispatch a thunk, and the thunk handles the orchestration of multiple dispatches, async calls, and state checks.\n\nBy leveraging these capabilities, Redux Thunk helps structure complex state interactions in a predictable and testable manner within the Redux ecosystem.",
      "examples": [
        {
          "id": "example_thunk_sync_vs_async_1",
          "title": "Synchronous vs. Asynchronous Action Creators",
          "code": "// Without thunk - simple synchronous action creator\nconst addTodoSync = text => {\n  return { type: 'ADD_TODO', text };\n};\n\n// With thunk - asynchronous action creator that returns a function\n// This function receives dispatch as an argument.\nconst addTodoAsync = text => {\n  return dispatch => {\n    // Simulate an asynchronous operation (e.g., API call)\n    setTimeout(() => {\n      // Dispatch a regular action after the async operation completes\n      dispatch({ type: 'ADD_TODO', text });\n      console.log(`Todo '${text}' added after 1 second.`);\n    }, 1000);\n  };\n};\n\n// Example usage (conceptual, assumes a Redux store is set up)\n// store.dispatch(addTodoSync('Learn Redux')); // Immediate dispatch\n// store.dispatch(addTodoAsync('Build App')); // Dispatches a function, thunk executes it\n",
          "explanation": "This example contrasts a standard synchronous action creator with an asynchronous one using Redux Thunk. The `addTodoSync` function returns a plain action object directly. In contrast, `addTodoAsync` returns a function (a thunk). This returned function takes `dispatch` as an argument, allowing it to perform an asynchronous operation (simulated by `setTimeout`) and then dispatch a regular action (`{ type: 'ADD_TODO', text }`) only after the asynchronous task is complete. This clearly illustrates how thunks enable delayed or conditional dispatches.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "Redux",
        "Redux Thunk",
        "Middleware",
        "Asynchronous Actions",
        "State Management",
        "Frontend Architecture"
      ],
      "prerequisites": [
        "Redux Fundamentals",
        "JavaScript Promises",
        "Middleware Concepts"
      ],
      "technology": "TypeScript"
    },
    "tags": [
      "Redux",
      "Redux Thunk",
      "Middleware",
      "Asynchronous Actions",
      "State Management",
      "Frontend Architecture"
    ],
    "prerequisites": [
      "Redux Fundamentals",
      "JavaScript Promises",
      "Middleware Concepts"
    ]
  },
  {
    "index": 93,
    "id": "theory_redux_thunk_intro",
    "type": "theory",
    "moduleId": "typescript",
    "complexity": 6,
    "title": "Introduction to Redux Thunk and Asynchronous Actions",
    "description": "",
    "content": {
      "id": "theory_redux_thunk_intro",
      "title": "Introduction to Redux Thunk and Asynchronous Actions",
      "description": "",
      "type": "theory",
      "content": "Redux Thunk is a middleware for Redux that allows you to write action creators that return a function instead of a plain action object. This function, often called a 'thunk', receives the store's `dispatch` method and `getState` function as its arguments.\n\nThe core problem Redux Thunk solves is enabling Redux to handle side effects, such as asynchronous operations (e.g., API calls, timers) and complex synchronous logic, without making reducers impure. Reducers in Redux must be pure functions, meaning they take the current state and an action, and return a new state without any side effects or modifications to the original state.\n\nWithout middleware like Redux Thunk, action creators can only return plain JavaScript objects. This works well for synchronous actions but falls short when dealing with operations that take time or depend on the current state. Redux Thunk acts as an intermediary: when an action creator returns a function, the middleware intercepts it and executes that function, passing `dispatch` and `getState` as arguments. This allows you to dispatch multiple actions at different points in time (e.g., before an async call, after success, or after failure) and access the current state to make decisions.\n\n## Key Principles\n*   **Functions as Actions:** Instead of returning `{ type: 'ACTION_TYPE' }`, action creators return `(dispatch, getState) => { /* async logic */ }`.\n*   **Side Effect Management:** Centralizes complex logic and asynchronous operations outside of components and reducers.\n*   **Access to `dispatch` and `getState`:** The thunk function receives `dispatch` to dispatch regular actions (or other thunks) and `getState` to read the current state of the Redux store.",
      "examples": [
        {
          "id": "example_redux_thunk_intro_1",
          "title": "Basic Thunk Action Creator",
          "code": "const delayedIncrement = () => {\n  return (dispatch) => {\n    // Simulate an async operation\n    setTimeout(() => {\n      dispatch({ type: 'INCREMENT' });\n    }, 1000);\n  };\n};\n\n// Usage in a component:\n// import { useDispatch } from 'react-redux';\n// const dispatch = useDispatch();\n// dispatch(delayedIncrement());",
          "explanation": "This example shows a simple thunk action creator `delayedIncrement`. Instead of returning a plain action, it returns a function. This function takes `dispatch` as an argument. Inside the function, a `setTimeout` simulates an asynchronous delay, after which a regular `INCREMENT` action is dispatched. This demonstrates how a thunk can delay a dispatch or perform operations before dispatching.",
          "language": "typescript"
        },
        {
          "id": "example_redux_thunk_intro_2",
          "title": "Thunk with `getState`",
          "code": "const incrementIfOdd = () => {\n  return (dispatch, getState) => {\n    const state = getState(); // Get the current Redux state\n    const { counter } = state; // Assuming 'counter' is a slice of state\n    \n    if (counter % 2 !== 0) {\n      dispatch({ type: 'INCREMENT' });\n    }\n  };\n};\n\n// Usage:\n// dispatch(incrementIfOdd()); // Only increments if 'counter' state is odd",
          "explanation": "This example demonstrates using the `getState` argument within a thunk. The `incrementIfOdd` thunk checks the current value of `counter` from the Redux store's state. It only dispatches the `INCREMENT` action if the `counter` value is odd, showcasing conditional logic based on the application's current state.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "Redux",
        "Redux Thunk",
        "Middleware",
        "Asynchronous Programming",
        "State Management"
      ],
      "prerequisites": [
        "Redux_basics",
        "JavaScript_async_basics"
      ],
      "technology": "TypeScript"
    },
    "tags": [
      "Redux",
      "Redux Thunk",
      "Middleware",
      "Asynchronous Programming",
      "State Management"
    ],
    "prerequisites": [
      "Redux_basics",
      "JavaScript_async_basics"
    ]
  },
  {
    "index": 101,
    "id": "theory_redux_toolkit_configure_store",
    "type": "theory",
    "moduleId": "typescript",
    "complexity": 6,
    "title": "Redux Toolkit: configureStore",
    "description": "",
    "content": {
      "id": "theory_redux_toolkit_configure_store",
      "title": "Redux Toolkit: configureStore",
      "description": "",
      "type": "theory",
      "content": "## Introduction to configureStore\n`configureStore` is a powerful utility function provided by Redux Toolkit (RTK) that simplifies the process of setting up a Redux store. It acts as a wrapper around the original `createStore` from Redux, but with sensible defaults and built-in features that streamline common Redux patterns and reduce boilerplate.\n\n### Key Features and Benefits\n-   **Simplifies Store Setup**: Abstracts away the complexity of configuring enhancers, middleware, and DevTools.\n-   **Includes Redux DevTools**: Automatically sets up the Redux DevTools Extension for debugging during development.\n-   **Adds Default Middleware**: By default, it includes `redux-thunk` for handling asynchronous actions and a development-only middleware that checks for common mistakes like accidental mutations of state.\n-   **Combines Reducers**: It automatically calls `combineReducers` internally if you pass an object of slice reducers to the `reducer` option, saving you an explicit call.\n-   **Immutability Checks**: Includes middleware that warns about state mutations in development.\n-   **Serializable State Checks**: Includes middleware that warns about non-serializable values in state or actions in development, helping ensure proper Redux patterns.\n\n### Usage\nThe `configureStore` function takes a single configuration object as an argument, most commonly containing a `reducer` property.",
      "examples": [
        {
          "id": "example_configure_store_1",
          "title": "Basic Store Configuration",
          "code": "import { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from './counterSlice';\nimport userReducer from './userSlice';\n\nconst store = configureStore({\n  reducer: {\n    counter: counterReducer, // A slice reducer\n    users: userReducer,      // Another slice reducer\n  },\n  // middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(myCustomMiddleware),\n  // devTools: process.env.NODE_ENV !== 'production', // Default is true for dev\n});\n\nexport default store;\n",
          "explanation": "This example demonstrates the most common usage of `configureStore`. We import `configureStore` and then define our store by providing a `reducer` object. Each key in this object (`counter`, `users`) corresponds to a top-level piece of our Redux state, and its value is the reducer function (usually from a Redux Toolkit `createSlice`). `configureStore` internally combines these reducers and sets up the necessary middleware and DevTools.",
          "language": "typescript"
        },
        {
          "id": "example_configure_store_2",
          "title": "Adding Custom Middleware",
          "code": "import { configureStore } from '@reduxjs/toolkit';\nimport rootReducer from './rootReducer'; // Assuming rootReducer is already combined\n\nconst myLoggerMiddleware = (store) => (next) => (action) => {\n  console.log('dispatching', action);\n  let result = next(action);\n  console.log('next state', store.getState());\n  return result;\n};\n\nconst store = configureStore({\n  reducer: rootReducer,\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware()\n      .prepend(myLoggerMiddleware) // Add custom middleware before default ones\n      .concat(\n        // Or concat after default ones\n        // anotherCustomMiddleware\n      ),\n});\n\nexport default store;\n",
          "explanation": "While `configureStore` includes sensible defaults, you might need to add custom middleware. This example shows how to add `myLoggerMiddleware`. The `middleware` option accepts a function that receives `getDefaultMiddleware` as an argument. You call `getDefaultMiddleware()` to get the array of default middleware and then use array methods like `concat` or `prepend` to add your custom middleware. This ensures you retain the benefits of RTK's default middleware while extending functionality.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "Redux",
        "Redux Toolkit",
        "State Management",
        "configureStore",
        "Frontend Architecture"
      ],
      "prerequisites": [
        "Redux Core Concepts",
        "JavaScript ES6 Modules"
      ],
      "technology": "TypeScript"
    },
    "tags": [
      "Redux",
      "Redux Toolkit",
      "State Management",
      "configureStore",
      "Frontend Architecture"
    ],
    "prerequisites": [
      "Redux Core Concepts",
      "JavaScript ES6 Modules"
    ]
  },
  {
    "index": 67,
    "id": "theory_redux_router_setup",
    "type": "theory",
    "moduleId": "typescript",
    "complexity": 7,
    "title": "Redux Store Configuration with React Router Redux",
    "description": "",
    "content": {
      "id": "theory_redux_router_setup",
      "title": "Redux Store Configuration with React Router Redux",
      "description": "",
      "type": "theory",
      "content": "This section details how to integrate `react-router-redux` with your Redux store, enabling the router's state to be managed by Redux and allowing for programmatic navigation. The core idea is to combine `react-router` with `redux` using `react-router-redux`.\n\n## Key Components\n\n*   **`createHistory()`**: This function, typically imported from the `history` library, creates a history object (e.g., `browserHistory` or `hashHistory`) that React Router uses to keep track of the application's navigation state. This history object is then passed to `ConnectedRouter` and `routerMiddleware`.\n*   **`configureStore(initialState, history)`**: A central function responsible for setting up the Redux store. It uses Redux's `createStore` to combine the root reducer, initial state, and enhancers.\n*   **`routerMiddleware(history)`**: This middleware from `react-router-redux` connects the browser history to Redux. It dispatches actions whenever the browser history changes (e.g., URL changes) and also listens for `react-router-redux` specific actions (like `PUSH`, `REPLACE`, `GO`) to update the browser history.\n*   **`applyMiddleware(...middlewares)`**: A Redux utility that applies various middlewares to the store, enhancing its capabilities (e.g., handling asynchronous actions, routing).\n*   **`compose`**: A Redux utility that composes functions from right to left. It's used here to chain multiple store enhancers (like `applyMiddleware` and `Redux DevTools`).\n*   **`Redux DevTools Extension`**: A powerful browser extension for debugging Redux applications. The setup includes logic to conditionally enable `window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__` in development environments, which allows integrating the DevTools with other enhancers.\n*   **`Provider` (from `react-redux`)**: Makes the Redux store available to any nested components that have been wrapped in the `connect()` function.\n*   **`ConnectedRouter` (from `react-router-redux`)**: A wrapper around `react-router`'s `Router` component that uses the Redux store to keep the router's state in sync. It takes the `history` object as a prop.\n*   **`Route` (from `react-router-dom`)**: Renders a UI component when its path matches the current URL.",
      "examples": [
        {
          "id": "example_redux_router_setup_1",
          "title": "Main Application Entry Point (index.tsx)",
          "code": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { ConnectedRouter } from 'react-router-redux';\nimport { Route } from 'react-router-dom';\nimport { createBrowserHistory } from 'history'; // Using createBrowserHistory for web apps\nimport configureStore from './store';\nimport App from './App';\n\nconst rootElement = document.getElementById('root');\nconst initialState = {};\nconst history = createBrowserHistory(); // Initialize browser history\nconst store = configureStore(initialState, history);\n\nReactDOM.render(\n  <Provider store={store}>\n    <ConnectedRouter history={history}>\n      <Route path=\"/\" component={App} />\n    </ConnectedRouter>\n  </Provider>,\n  rootElement\n);\n",
          "explanation": "This is the main entry point of a React application integrated with Redux and React Router Redux. It sets up the Redux `Provider` to make the store available, and `ConnectedRouter` to synchronize React Router's state with Redux. The `history` object is created and passed to both the store configuration and `ConnectedRouter`.",
          "language": "typescript"
        },
        {
          "id": "example_redux_router_setup_2",
          "title": "Redux Store Configuration (store.ts)",
          "code": "import { createStore, applyMiddleware, compose } from 'redux';\nimport { routerMiddleware } from 'react-router-redux';\nimport rootReducer from './rootReducer'; // Assuming you have a rootReducer defined\n\nexport default function configureStore(initialState: any, history: any) {\n  const routerMW = routerMiddleware(history);\n  \n  const middleWares = [\n    routerMW,\n    // Add other middleware here, e.g., redux-thunk or redux-saga\n  ];\n  \n  const enhancers = [\n    applyMiddleware(...middleWares)\n  ];\n  \n  // Conditionally add Redux DevTools Extension if available and not in production\n  const composeEnhancers =\n    process.env.NODE_ENV !== 'production' &&\n    typeof window === 'object' &&\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : compose;\n  \n  const store = createStore(\n    rootReducer,\n    initialState,\n    composeEnhancers(...enhancers),\n  );\n  \n  return store;\n}",
          "explanation": "This `configureStore` function demonstrates how to set up a Redux store with `routerMiddleware`. It applies the router middleware along with any other application-specific middlewares. It also includes the crucial step of integrating with the Redux DevTools Extension for easier debugging during development.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "Redux",
        "React-Router-Redux",
        "Store Configuration",
        "Middleware",
        "DevTools",
        "React"
      ],
      "prerequisites": [
        "React Basics",
        "Redux Core Concepts",
        "React Router Basics",
        "JavaScript ES6"
      ],
      "technology": "TypeScript"
    },
    "tags": [
      "Redux",
      "React-Router-Redux",
      "Store Configuration",
      "Middleware",
      "DevTools",
      "React"
    ],
    "prerequisites": [
      "React Basics",
      "Redux Core Concepts",
      "React Router Basics",
      "JavaScript ES6"
    ]
  },
  {
    "index": 96,
    "id": "theory_redux_saga",
    "type": "theory",
    "moduleId": "typescript",
    "complexity": 7,
    "title": "Redux Saga for Side Effect Management",
    "description": "",
    "content": {
      "id": "theory_redux_saga",
      "title": "Redux Saga for Side Effect Management",
      "description": "",
      "type": "theory",
      "content": "Redux Saga is a middleware library for Redux that aims to make side effects (like asynchronous data fetching and impure actions) easier to manage, more efficient to execute, and better to test. It achieves this by leveraging ES6 Generators, which allow for writing asynchronous code that looks and behaves like synchronous code (imperative style).\n\nSagas are implemented as generator functions that yield plain JavaScript objects. These yielded objects are 'effects' which are instructions for the middleware to perform. When the middleware receives a yielded effect, it executes the effect and then resumes the generator function with the result. This makes sagas highly testable because you can simply assert on the yielded effects without actually executing the side effects.\n\nKey advantages of Redux Saga:\n- **Declarative Effects**: Sagas yield plain objects describing the desired operation, making them easy to test.\n- **Non-blocking**: Effects are non-blocking by default, meaning your application doesn't freeze while waiting for an async operation.\n- **Concurrency Control**: Provides primitives for complex concurrency patterns (e.g., `takeLatest`, `debounce`).\n- **Error Handling**: Robust error handling mechanisms.\n\n**Integration**: To integrate Redux Saga, you create a `sagaMiddleware` using `createSagaMiddleware()` and apply it to your Redux store using `applyMiddleware()`. Finally, you run your root saga using `sagaMiddleware.run(rootSaga)`, which starts listening for dispatched actions.\n\n## Core Concepts\n- **Generators**: Functions that can be paused and resumed.\n- **Effects**: Plain JavaScript objects yielded by sagas, representing instructions to the middleware (e.g., `call`, `put`, `take`, `fork`, `select`).\n- **Watchers and Workers**: Common pattern where a watcher saga listens for specific actions and forks worker sagas to handle the side effect.\n- **`sagaMiddleware.run()`**: The entry point to start all sagas.",
      "examples": [
        {
          "id": "example_redux_saga_1",
          "title": "Basic Redux Saga Setup",
          "code": "import { createStore, applyMiddleware } from 'redux';\nimport createSagaMiddleware from 'redux-saga';\nimport { takeEvery, call, put } from 'redux-saga/effects';\n\n// Action Types\nconst FETCH_USER_REQUEST = 'FETCH_USER_REQUEST';\nconst FETCH_USER_SUCCESS = 'FETCH_USER_SUCCESS';\nconst FETCH_USER_FAILURE = 'FETCH_USER_FAILURE';\n\n// Actions\nconst fetchUserRequest = (userId) => ({ type: FETCH_USER_REQUEST, payload: userId });\nconst fetchUserSuccess = (user) => ({ type: FETCH_USER_SUCCESS, payload: user });\nconst fetchUserFailure = (error) => ({ type: FETCH_USER_FAILURE, payload: error });\n\n// Mock API call\nconst fetchUserApi = async (userId) => {\n  const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);\n  if (!response.ok) {\n    throw new Error('Failed to fetch user');\n  }\n  return response.json();\n};\n\n// Worker Saga\nfunction* fetchUser(action) {\n  try {\n    const user = yield call(fetchUserApi, action.payload);\n    yield put(fetchUserSuccess(user));\n  } catch (error) {\n    yield put(fetchUserFailure(error.message));\n  }\n}\n\n// Watcher Saga\nfunction* watchFetchUser() {\n  yield takeEvery(FETCH_USER_REQUEST, fetchUser);\n}\n\n// Root Reducer (simplified)\nconst initialState = { user: null, loading: false, error: null };\nconst rootReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case FETCH_USER_REQUEST:\n      return { ...state, loading: true, error: null };\n    case FETCH_USER_SUCCESS:\n      return { ...state, loading: false, user: action.payload };\n    case FETCH_USER_FAILURE:\n      return { ...state, loading: false, error: action.payload };\n    default:\n      return state;\n  }\n};\n\n// Combine Sagas\nfunction* rootSaga() {\n  yield watchFetchUser();\n}\n\n// Redux Store Setup\nconst sagaMiddleware = createSagaMiddleware();\n\nconst store = createStore(\n  rootReducer,\n  applyMiddleware(sagaMiddleware)\n);\n\nsagaMiddleware.run(rootSaga);\n\n// Example dispatch:\n// store.dispatch(fetchUserRequest(1));",
          "explanation": "This example demonstrates the typical Redux Saga setup. `fetchUser` is a worker saga that performs an asynchronous API call using the `call` effect and dispatches success or failure actions using the `put` effect. `watchFetchUser` is a watcher saga that listens for `FETCH_USER_REQUEST` actions and triggers `fetchUser` for each. The `rootSaga` combines all watcher sagas. Finally, `sagaMiddleware` is created, applied to the Redux store, and `rootSaga` is run to start listening for actions.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "Redux",
        "Redux Saga",
        "Middleware",
        "Side Effects",
        "Generators",
        "Asynchronous Programming"
      ],
      "prerequisites": [
        "Redux Fundamentals",
        "JavaScript Generators",
        "Asynchronous JavaScript"
      ],
      "technology": "TypeScript"
    },
    "tags": [
      "Redux",
      "Redux Saga",
      "Middleware",
      "Side Effects",
      "Generators",
      "Asynchronous Programming"
    ],
    "prerequisites": [
      "Redux Fundamentals",
      "JavaScript Generators",
      "Asynchronous JavaScript"
    ]
  },
  {
    "index": 151,
    "id": "theory_array_shuffling",
    "type": "theory",
    "moduleId": "typescript",
    "complexity": 7,
    "title": "Array Shuffling (Fisher-Yates Algorithm)",
    "description": "",
    "content": {
      "id": "theory_array_shuffling",
      "title": "Array Shuffling (Fisher-Yates Algorithm)",
      "description": "",
      "type": "theory",
      "content": "The Fisher-Yates (or Knuth) shuffle is an algorithm for generating a random permutation of a finite sequence. The algorithm works by iterating through the array from the last element down to the first (or from the first to the last), and for each element, it swaps it with a randomly chosen element from the unsorted part of the array (including itself).\n\n## Key Concepts\n- **In-place Shuffling:** The algorithm modifies the original array directly without requiring extra space for a new array.\n- **Randomness:** Each permutation of the array elements has an equal probability of being generated, ensuring a truly random shuffle.\n- **Time Complexity:** The algorithm has a time complexity of O(n), where n is the number of elements in the array, because it performs a constant number of operations for each element.\n- **Space Complexity:** The space complexity is O(1) as it only uses a few variables for iteration and swapping.\n\n## Algorithm Steps\n1. Iterate from the last element `n-1` down to `1`.\n2. For each element at index `i`, generate a random index `j` such that `0 <= j <= i`.\n3. Swap the element at index `i` with the element at index `j`.\n\nThis ensures that as we iterate, each element is picked exactly once and moved to a 'final' shuffled position, and the elements already moved are not revisited.",
      "examples": [
        {
          "id": "example_array_shuffling_1",
          "title": "Fisher-Yates Shuffle Implementation",
          "code": "/**\n * Shuffles an array in-place using the Fisher-Yates (Knuth) algorithm.\n * @param {Array<T>} array The array to be shuffled.\n * @returns {Array<T>} The shuffled array.\n */\nfunction shuffleArray<T>(array: T[]): T[] {\n  const result = [...array]; // Create a copy to avoid modifying original if preferred\n  let currentIndex = result.length;\n  let randomIndex: number;\n\n  // While there remain elements to shuffle.\n  while (currentIndex !== 0) {\n\n    // Pick a remaining element.\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n\n    // And swap it with the current element.\n    [result[currentIndex], result[randomIndex]] = [\n      result[randomIndex],\n      result[currentIndex],\n    ];\n  }\n\n  return result;\n}\n\n// Example Usage:\nconst originalArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst shuffled = shuffleArray(originalArray);\nconsole.log('Original Array:', originalArray);\nconsole.log('Shuffled Array:', shuffled); // Random permutation of the original array\n\nconst anotherArray = ['apple', 'banana', 'cherry', 'date'];\nconsole.log('Original Array:', anotherArray);\nconsole.log('Shuffled Array:', shuffleArray(anotherArray));",
          "explanation": "This example provides a complete implementation of the Fisher-Yates shuffle. It iterates from the end of the array to the beginning. In each iteration, it selects a random index from the unshuffled portion (0 to `currentIndex`) and swaps the element at `currentIndex` with the element at the `randomIndex`. This process ensures that each element is equally likely to end up in any position, producing a truly random permutation.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "array",
        "algorithm",
        "shuffling",
        "randomization",
        "in-place",
        "data-structures"
      ],
      "prerequisites": [
        "arrays",
        "loops",
        "math_random",
        "variable_swapping"
      ],
      "technology": "TypeScript"
    },
    "tags": [
      "array",
      "algorithm",
      "shuffling",
      "randomization",
      "in-place",
      "data-structures"
    ],
    "prerequisites": [
      "arrays",
      "loops",
      "math_random",
      "variable_swapping"
    ]
  },
  {
    "index": 90,
    "id": "theory_redux_selectors_basics",
    "type": "theory",
    "moduleId": "redux",
    "complexity": 4,
    "title": "Basic Redux Selectors",
    "description": "",
    "content": {
      "id": "theory_redux_selectors_basics",
      "title": "Basic Redux Selectors",
      "description": "",
      "type": "theory",
      "content": "Redux selectors are simple JavaScript functions that take the Redux state as an argument and return a specific piece of that state or derived data. They serve as a crucial abstraction layer between the Redux store's raw state and the React components (or any other part of the application) that consume the state.\n\n## Key Concepts\n*   **State Extraction**: Selectors provide a standardized way to pull specific data out of the complex, often nested, Redux state tree.\n*   **Encapsulation**: By using selectors, components don't need to know the exact structure of the state. If the state shape changes, only the selector needs to be updated, not every component that uses that piece of data. This promotes maintainability and reduces coupling.\n*   **Reusability**: A single selector can be used by multiple components or in different parts of the application that require the same data slice.\n\n## Implementation\nA basic selector is typically a pure function that takes the `state` object and returns the desired data.",
      "examples": [
        {
          "id": "example_redux_selectors_basics_1",
          "title": "Getting User Data from State",
          "code": "const getUserData = state => state.user.data;\n\n// Example usage in a component:\n// const userData = getUserData(store.getState());",
          "explanation": "This selector `getUserData` directly accesses the `user.data` property from the Redux state. If `state.user.data` holds the user's details, this function encapsulates that path, so any component needing user data just calls `getUserData(state)` without knowing the full path.",
          "language": "javascript"
        },
        {
          "id": "example_redux_selectors_basics_2",
          "title": "Getting Derived Data",
          "code": "const getActiveTodosCount = state => state.todos.filter(todo => !todo.completed).length;\n\n// Example usage:\n// const activeTodosCount = getActiveTodosCount(store.getState());",
          "explanation": "This selector not only extracts data but also derives a new value by filtering the `todos` array and counting active (uncompleted) items. It demonstrates how selectors can perform simple transformations.",
          "language": "javascript"
        }
      ],
      "complexity": 4,
      "tags": [
        "Redux",
        "Selectors",
        "State Management",
        "Data Extraction",
        "Encapsulation"
      ],
      "prerequisites": [
        "Redux Basics",
        "JavaScript Functions"
      ],
      "technology": "Redux"
    },
    "tags": [
      "Redux",
      "Selectors",
      "State Management",
      "Data Extraction",
      "Encapsulation"
    ],
    "prerequisites": [
      "Redux Basics",
      "JavaScript Functions"
    ]
  },
  {
    "index": 91,
    "id": "theory_map_dispatch_to_props",
    "type": "theory",
    "moduleId": "react, redux",
    "complexity": 6,
    "title": "Understanding `mapDispatchToProps` in React-Redux",
    "description": "",
    "content": {
      "id": "theory_map_dispatch_to_props",
      "title": "Understanding `mapDispatchToProps` in React-Redux",
      "description": "",
      "type": "theory",
      "content": "The `mapDispatchToProps` function is a crucial part of connecting React components to a Redux store using the `connect` higher-order component from `react-redux`. Its primary purpose is to map Redux `dispatch` calls to props of your React component, allowing the component to trigger state changes in the Redux store without directly interacting with `store.dispatch()`.\n\nThere are three common ways to define `mapDispatchToProps`:\n\n### 1. Object Shorthand\nThis is the simplest and recommended approach for most straightforward cases. When `mapDispatchToProps` is an object, `connect` will automatically wrap each action creator (function) within the object with `dispatch()` and inject them as props into your component. This means you don't need to manually call `dispatch(actionCreator())` in your component; you can simply call `this.props.actionCreator(args)`.\n\n### 2. Function with `dispatch` Parameter\nWhen `mapDispatchToProps` is a function that takes `dispatch` as its first argument, it gives you more control. Inside this function, you manually define methods that will be passed as props to your component. Each of these methods will typically call `dispatch()` internally. This approach is useful when you need to perform complex logic before dispatching an action, such as conditional dispatches, logging, or combining multiple dispatches.\n\n### 3. Function with `dispatch` and `ownProps` Parameters\nThis form is similar to the second, but it also receives `ownProps` as its second argument. `ownProps` refers to the props that are passed *into* your connected component from its parent. This allows you to create action-dispatching props that are dynamic and depend on the specific props received by that instance of the component. For example, you might dispatch an action with an ID that comes directly from `ownProps`.",
      "examples": [
        {
          "id": "example_map_dispatch_to_props_1",
          "title": "Object Shorthand `mapDispatchToProps`",
          "code": "import { addTodo, toggleTodo } from './actions';\n\nconst mapDispatchToProps = {\n  addTodo,  // Equivalent to: addTodo: (...args) => dispatch(addTodo(...args))\n  toggleTodo\n};\n\n// Usage in connected component:\n// this.props.addTodo('Learn Redux');\n// this.props.toggleTodo(1);\n",
          "explanation": "This example demonstrates the object shorthand. `connect` automatically binds `addTodo` and `toggleTodo` action creators to `dispatch`. Your component receives `addTodo` and `toggleTodo` directly as props, which when called, dispatch the corresponding actions.",
          "language": "typescript"
        },
        {
          "id": "example_map_dispatch_to_props_2",
          "title": "Function with `dispatch` Parameter",
          "code": "import { addTodo, toggleTodo } from './actions';\n\nconst mapDispatchToProps = (dispatch) => ({\n  addTodo: (text) => dispatch(addTodo(text)),\n  toggleTodo: (id) => dispatch(toggleTodo(id)),\n  customAction: () => {\n    // Complex logic before dispatching\n    console.log('Performing custom logic...');\n    dispatch({ type: 'CUSTOM_ACTION', payload: { data: 'some_data' } });\n  }\n});\n\n// Usage in connected component:\n// this.props.addTodo('Refactor code');\n// this.props.customAction();\n",
          "explanation": "This example shows `mapDispatchToProps` as a function. It explicitly receives `dispatch` as an argument. This allows for custom logic to be executed before dispatching, such as logging, conditional dispatches, or dispatching multiple actions from a single prop method.",
          "language": "typescript"
        },
        {
          "id": "example_map_dispatch_to_props_3",
          "title": "Function with `dispatch` and `ownProps` Parameters",
          "code": "const mapDispatchToProps = (dispatch, ownProps) => ({\n  toggleActive: () => {\n    dispatch({\n      type: 'TOGGLE_ACTIVE',\n      id: ownProps.id  // Access props passed to the connected component\n    });\n  },\n  updateItemStatus: (status) => {\n    // Dispatch an action based on ownProps and new status\n    dispatch({ type: 'UPDATE_ITEM_STATUS', id: ownProps.itemId, status });\n  }\n});\n\n// Assume the connected component is rendered like: <ConnectedComponent id={123} itemId={'abc'} />\n// Usage in connected component:\n// this.props.toggleActive(); // Dispatches with id: 123\n// this.props.updateItemStatus('completed'); // Dispatches with itemId: 'abc' and status: 'completed'\n",
          "explanation": "This example demonstrates the use of `ownProps`. The `toggleActive` prop method dispatches an action that includes the `id` property from the component's own props. This is useful when actions need to be aware of data specific to the component instance they are called from.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "Redux",
        "React-Redux",
        "State Management",
        "mapDispatchToProps",
        "Connect HOC"
      ],
      "prerequisites": [
        "Redux_Core_Concepts",
        "React_Props_State",
        "Higher_Order_Components"
      ],
      "technology": "React, Redux"
    },
    "tags": [
      "Redux",
      "React-Redux",
      "State Management",
      "mapDispatchToProps",
      "Connect HOC"
    ],
    "prerequisites": [
      "Redux_Core_Concepts",
      "React_Props_State",
      "Higher_Order_Components"
    ]
  },
  {
    "index": 100,
    "id": "theory_redux_react_integration",
    "type": "theory",
    "moduleId": "react, redux",
    "complexity": 7,
    "title": "Redux with React: Integration & Core Concepts",
    "description": "",
    "content": {
      "id": "theory_redux_react_integration",
      "title": "Redux with React: Integration & Core Concepts",
      "description": "",
      "type": "theory",
      "content": "This section covers the foundational aspects of integrating Redux with React applications, emphasizing the key components and patterns involved in setting up a scalable state management solution.\n\n## Core Concepts\n\n### Provider\n`Provider` is a special React component provided by `react-redux` that makes the Redux store available to any nested components that need to access it. It typically wraps the root component of your application, ensuring that the entire component tree can connect to the Redux store without explicitly passing the store down through props at every level (prop drilling).\n\n### Store Configuration and Initialization\nThe Redux store is the single source of truth for the application's state. It holds the complete state tree and is responsible for dispatching actions and running reducers to update the state. The store is typically configured once during application startup, bringing together all reducers.\n\n### Action Creators and Action Types\n- **Action Types**: Constants that define the type of action being performed. They are usually string literals and help avoid typos and promote consistency.\n- **Action Creators**: Functions that return an action object. An action is a plain JavaScript object with a `type` property (mandatory) and often a `payload` containing data relevant to the action. Actions are the only way to send data from your application to the Redux store.\n\n### Reducer Implementation (with Immutable.js context)\nReducers are pure functions that take the current state and an action as arguments, and return a new state. They must not mutate the original state directly. If `Immutable.js` is used, it provides immutable data structures that help enforce this principle by returning new instances of data structures whenever changes are made, rather than modifying the existing ones.\n\n### Component Hierarchy and Composition\nReact applications are built as a tree of components. With Redux, components can be categorized into presentational (dumb) components that only render UI based on props and container (smart) components that connect to the Redux store and pass data/callbacks to presentational components.\n\n### Connecting Components to Redux with `connect()`\n`connect()` is a Higher-Order Component (HOC) from `react-redux` that allows React components to read data from the Redux store and dispatch actions to the store. It takes two optional arguments: `mapStateToProps` and `mapDispatchToProps`.\n- `mapStateToProps`: A function that receives the entire Redux state and returns an object of data that the component needs. This data is then passed as props to the connected component.\n- `mapDispatchToProps`: A function or object that defines which action creators should be dispatched. These dispatch functions are also passed as props to the connected component.\n\n## Redux Flow Example\n```jsx\nReactDOM.render(\n  <Provider store={store}>\n    <AppView />\n  </Provider>,\n  document.getElementById('root')\n);\n```\nThis snippet illustrates the root-level integration where the `Provider` component makes the `store` available to `AppView` and all its descendants.\n\n![Flux Architecture Flow](images/flux_pattern.png)",
      "examples": [
        {
          "id": "example_redux_react_integration_1",
          "title": "Basic Store and Provider Setup",
          "code": "import { createStore } from 'redux';\nimport { Provider } from 'react-redux';\nimport ReactDOM from 'react-dom';\nimport React from 'react';\n\n// A simple reducer\nconst counterReducer = (state = { count: 0 }, action) => {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { count: state.count + 1 };\n    case 'DECREMENT':\n      return { count: state.count - 1 };\n    default:\n      return state;\n  }\n};\n\n// Create the Redux store\nconst store = createStore(counterReducer);\n\n// A simple App component\nconst App = () => (\n  <div>\n    <h1>Redux App</h1>\n  </div>\n);\n\n// Render the application with Provider\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);",
          "explanation": "This example shows the minimal setup for a Redux application with React. A `store` is created using `createStore` and a basic `counterReducer`. The `Provider` component then wraps the root `App` component, making the `store` accessible to all components within the `App`'s tree. This is the entry point for integrating Redux into a React application.",
          "language": "javascript"
        },
        {
          "id": "example_redux_react_integration_2",
          "title": "Connecting a Component with `connect`",
          "code": "import React from 'react';\nimport { connect } from 'react-redux';\n\n// Action creators\nconst increment = () => ({ type: 'INCREMENT' });\nconst decrement = () => ({ type: 'DECREMENT' });\n\n// A React component that displays a counter\nconst Counter = ({ count, increment, decrement }) => (\n  <div>\n    <p>Count: {count}</p>\n    <button onClick={increment}>Increment</button>\n    <button onClick={decrement}>Decrement</button>\n  </div>\n);\n\n// mapStateToProps: maps state from Redux store to component props\nconst mapStateToProps = (state) => ({\n  count: state.count,\n});\n\n// mapDispatchToProps: maps action creators to component props (dispatch automatically)\nconst mapDispatchToProps = {\n  increment,\n  decrement,\n};\n\n// Connect the Counter component to Redux\nexport default connect(mapStateToProps, mapDispatchToProps)(Counter);",
          "explanation": "This example demonstrates how to use the `connect` HOC to link a React component (`Counter`) to the Redux store. `mapStateToProps` extracts the `count` from the Redux state and passes it as a prop. `mapDispatchToProps` provides the `increment` and `decrement` action creators as props, which automatically dispatch the respective actions when called. This pattern separates data fetching/logic from UI rendering.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "Redux",
        "React",
        "State Management",
        "Provider",
        "Connect",
        "Actions",
        "Reducers",
        "Store"
      ],
      "prerequisites": [
        "React Basics",
        "JavaScript ES6+",
        "Functional Programming Concepts"
      ],
      "technology": "React, Redux"
    },
    "tags": [
      "Redux",
      "React",
      "State Management",
      "Provider",
      "Connect",
      "Actions",
      "Reducers",
      "Store"
    ],
    "prerequisites": [
      "React Basics",
      "JavaScript ES6+",
      "Functional Programming Concepts"
    ]
  },
  {
    "index": 94,
    "id": "theory_redux_saga_introduction",
    "type": "theory",
    "moduleId": "typescript, redux, redux saga",
    "complexity": 7,
    "title": "Redux Saga: Managing Side Effects in Redux Applications",
    "description": "",
    "content": {
      "id": "theory_redux_saga_introduction",
      "title": "Redux Saga: Managing Side Effects in Redux Applications",
      "description": "",
      "type": "theory",
      "content": "Redux Saga is a middleware library for Redux, designed to make asynchronous operations (side effects) in React/Redux applications easier to manage, more efficient, and better to test. Side effects include data fetching, asynchronous I/O, and accessing the browser cache.\n\n### Why Redux Saga?\nTraditional Redux handles synchronous state updates well, but managing complex asynchronous logic can lead to 'Thunk spaghetti' or deeply nested callbacks. Redux Saga addresses this by:\n\n*   **Centralizing Side Effects**: All async logic is encapsulated in sagas, separate from UI components and reducers.\n*   **Declarative Effects**: Sagas use generator functions and 'effects' (plain JavaScript objects) that describe operations to be performed by the middleware. This makes sagas easy to test, as you can simply assert on the yielded effect objects.\n*   **Concurrency Control**: Provides powerful tools like `takeEvery`, `takeLatest`, `throttle`, and `debounce` to manage how concurrent actions are handled.\n*   **Error Handling**: Offers robust `try...catch` blocks for handling errors within sagas.\n*   **Readability and Maintainability**: The synchronous-looking, sequential nature of generator functions makes complex asynchronous flows more readable.\n\n### Generator Functions (`function*` and `yield`)\nSagas are implemented using ES6 Generator functions (`function*`). Generators are functions that can be paused and resumed. When a generator function is called, it returns an Iterator object. The `yield` keyword is used to pause the execution of the generator and return a value (in Redux Saga's case, an effect description). The saga middleware then interprets this effect and performs the necessary action before resuming the generator.\n\n```javascript\nfunction* myGenerator() {\n  yield 'Hello';\n  yield 'World';\n  return 'Done';\n}\n\nconst iterator = myGenerator();\nconsole.log(iterator.next()); // { value: 'Hello', done: false }\nconsole.log(iterator.next()); // { value: 'World', done: false }\nconsole.log(iterator.next()); // { value: 'Done', done: true }\n```\n",
      "examples": [
        {
          "id": "example_redux_saga_intro_1",
          "title": "Basic Generator Function",
          "code": "function* createNumberSequence() {\n  let i = 0;\n  while (true) {\n    yield i++;\n  }\n}\n\nconst sequence = createNumberSequence();\nconsole.log(sequence.next().value); // 0\nconsole.log(sequence.next().value); // 1\nconsole.log(sequence.next().value); // 2",
          "explanation": "This example demonstrates a basic generator function that yields an infinite sequence of numbers. Each call to `next().value` resumes the function from where it left off, producing the next number in the sequence. This 'pause and resume' capability is fundamental to how Redux Saga works.",
          "language": "javascript"
        },
        {
          "id": "example_redux_saga_intro_2",
          "title": "Redux Saga Structure Outline",
          "code": "import { takeEvery, put, call } from 'redux-saga/effects';\n\n// Action Types\nconst FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';\nconst FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';\nconst FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';\n\n// Worker Saga\nfunction* fetchDataAsync() {\n  try {\n    yield put({ type: FETCH_DATA_REQUEST }); // Indicate loading\n    const data = yield call(fetch, 'https://api.example.com/data');\n    const json = yield call([data, data.json]); // Parse JSON response\n    yield put({ type: FETCH_DATA_SUCCESS, payload: json }); // Dispatch success\n  } catch (error) {\n    yield put({ type: FETCH_DATA_FAILURE, error: error.message }); // Dispatch error\n  }\n}\n\n// Watcher Saga\nfunction* watchFetchData() {\n  yield takeEvery('FETCH_DATA', fetchDataAsync); // Watch for 'FETCH_DATA' action\n}\n\n// Root Saga (combines all sagas)\nexport default function* rootSaga() {\n  yield watchFetchData();\n}",
          "explanation": "This provides a high-level overview of a typical Redux Saga setup. It includes action types, a worker saga for async logic, a watcher saga to listen for actions, and a root saga to combine them. This structure separates concerns and makes testing individual parts easier.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "Redux Saga",
        "Side Effects",
        "Asynchronous JavaScript",
        "Generators",
        "Middleware"
      ],
      "prerequisites": [
        "Redux Core Concepts",
        "JavaScript ES6 Generators",
        "Asynchronous JavaScript (Promises, Async/Await concepts)"
      ],
      "technology": "TypeScript"
    },
    "tags": [
      "Redux Saga",
      "Side Effects",
      "Asynchronous JavaScript",
      "Generators",
      "Middleware"
    ],
    "prerequisites": [
      "Redux Core Concepts",
      "JavaScript ES6 Generators",
      "Asynchronous JavaScript (Promises, Async/Await concepts)"
    ]
  },
  {
    "index": 102,
    "id": "theory_git_staging_area",
    "type": "theory",
    "moduleId": "git",
    "complexity": 4,
    "title": "Git Staging Area (Index)",
    "description": "",
    "content": {
      "id": "theory_git_staging_area",
      "title": "Git Staging Area (Index)",
      "description": "",
      "type": "theory",
      "content": "The Git staging area, also known as the 'index', is an intermediate area where you prepare changes before committing them to the repository. It acts as a buffer between your working directory (where you make changes) and your repository (where your committed history is stored). Changes are not permanently recorded until they are committed.\n\n### Key Concepts\n- **Working Directory**: Your current project files and folders.\n- **Staging Area (Index)**: A place to collect changes you want to include in your next commit. You explicitly add changes to this area.\n- **Local Repository**: The `.git` directory which stores all the history of your project, including committed snapshots.\n\n### `git add` Command\n`git add` is used to add changes from the working directory to the staging area. It does not save the changes permanently to the repository; it merely stages them for the next commit.\n\n- **`git add <file>`**: Stages specific changes from a single file. If you've modified multiple files but only want to commit changes from one, this is the command to use.\n- **`git add -A`**: (or `git add --all`) Stages *all* changes across the entire repository. This includes new files, modified files, and deleted files. This command is effective from any directory within the repository.\n- **`git add .`**: Stages all changes in the current directory and its subdirectories. This includes new files and modified files. It **does not stage deletions** unless you are in the root directory where `git add -A` would be more appropriate for deletions across the repo. From the root, `git add .` and `git add -A` often behave similarly for new/modified files, but `-A` explicitly handles deletions globally.\n\n### Importance\nThe staging area allows for fine-grained control over what goes into each commit. You can commit related changes together, keeping your commit history clean and easy to understand. This is crucial for effective version control and collaboration.",
      "examples": [
        {
          "id": "example_git_staging_1",
          "title": "Staging a specific file",
          "code": "# Assume 'README.md' has been modified\ngit add README.md\n# Only changes in README.md are staged.",
          "explanation": "This command stages only the changes made to `README.md`. Other modified files remain unstaged.",
          "language": "bash"
        },
        {
          "id": "example_git_staging_2",
          "title": "Staging all changes",
          "code": "# Assume 'index.html' is modified, 'styles.css' is new, 'old.js' is deleted\ngit add -A\n# All modifications, new files, and deletions are staged across the entire repository.",
          "explanation": "This command stages all changes detected by Git, including additions, modifications, and deletions, regardless of the current working directory. This is useful for preparing a full snapshot of your current work.",
          "language": "bash"
        },
        {
          "id": "example_git_staging_3",
          "title": "Staging changes in current directory",
          "code": "# Assume 'src/components/Button.js' is new, 'src/App.js' is modified\ncd src\ngit add .\n# Both Button.js (new) and App.js (modified) are staged if they are in or under 'src'.",
          "explanation": "This command stages all new and modified files within the current directory (`src` in this case) and its subdirectories. It's a convenient way to stage changes within a specific part of your project.",
          "language": "bash"
        }
      ],
      "complexity": 4,
      "tags": [
        "Git",
        "Version Control",
        "Staging Area",
        "git add",
        "Fundamentals"
      ],
      "prerequisites": [],
      "technology": "Git"
    },
    "tags": [
      "Git",
      "Version Control",
      "Staging Area",
      "git add",
      "Fundamentals"
    ],
    "prerequisites": []
  },
  {
    "index": 103,
    "id": "theory_git_remote_management",
    "type": "theory",
    "moduleId": "git",
    "complexity": 4,
    "title": "Git Remote Repository Management",
    "description": "",
    "content": {
      "id": "theory_git_remote_management",
      "title": "Git Remote Repository Management",
      "description": "",
      "type": "theory",
      "content": "Managing remote repositories is a fundamental aspect of collaborative Git workflows. Remote repositories are versions of your project that are hosted on the internet or network, accessible by multiple developers. The commands in this section allow you to connect your local repository to these remote versions, inspect existing connections, and understand where your code can be pushed or pulled from.\n\n## Key Concepts\n*   **Remote:** A remote is simply a bookmark for another repository. It's a named reference to a URL. The default remote name is usually `origin`.\n*   **URL:** The address of the remote repository, which can be an SSH URL (e.g., `git@github.com:user/repo.git`) or an HTTPS URL (e.g., `https://github.com/user/repo.git`).\n*   **Adding a Remote:** The `git remote add` command establishes a new connection to a remote repository, associating a short, memorable name with a lengthy URL.\n*   **Viewing Remotes:** The `git remote -v` command lists all configured remote repositories along with their URLs for both fetching and pushing. This helps in verifying the configured remotes and their access types.",
      "examples": [
        {
          "id": "example_git_remote_add_1",
          "title": "Adding a new remote named 'origin'",
          "code": "git remote add origin https://github.com/your-username/your-repo.git",
          "explanation": "This command adds a new remote repository with the short name `origin` and associates it with the provided HTTPS URL. `origin` is the conventional name for the primary remote, especially the one from which the repository was initially cloned.",
          "language": "bash"
        },
        {
          "id": "example_git_remote_view_1",
          "title": "Viewing all configured remotes",
          "code": "git remote -v\n# Expected output example:\n# origin  https://github.com/your-username/your-repo.git (fetch)\n# origin  https://github.com/your-username/your-repo.git (push)\n# upstream  https://github.com/original-project/original-repo.git (fetch)\n# upstream  https://github.com/original-project/original-repo.git (push)",
          "explanation": "The `-v` (verbose) flag shows the URLs that Git has stored for the shortnames. It displays both the fetch and push URLs, which are often the same but can be different in advanced setups (e.g., for read-only mirrors).",
          "language": "bash"
        }
      ],
      "complexity": 4,
      "tags": [
        "Git",
        "Remote",
        "Repository",
        "Collaboration",
        "Setup"
      ],
      "prerequisites": [
        "git_basics",
        "command_line_basics"
      ],
      "technology": "Git"
    },
    "tags": [
      "Git",
      "Remote",
      "Repository",
      "Collaboration",
      "Setup"
    ],
    "prerequisites": [
      "git_basics",
      "command_line_basics"
    ]
  },
  {
    "index": 104,
    "id": "theory_advanced_git_techniques",
    "type": "theory",
    "moduleId": "git",
    "complexity": 7,
    "title": "Advanced Git Techniques: Workflow, Hooks, and Submodules",
    "description": "",
    "content": {
      "id": "theory_advanced_git_techniques",
      "title": "Advanced Git Techniques: Workflow, Hooks, and Submodules",
      "description": "",
      "type": "theory",
      "content": "## Git Workflow Best Practices\nEffective Git workflows are crucial for team collaboration and maintaining a clean, understandable project history. Adopting best practices can significantly improve code review, debugging, and overall development efficiency.\n\n### 1. Pull with rebase for cleaner history\nUsing `git pull --rebase` instead of a standard `git pull` (which performs a merge) ensures a linear project history. When you rebase, your local commits are temporarily put aside, the remote changes are fetched and applied, and then your local commits are reapplied on top. This avoids unnecessary merge commits, making the history easier to read and follow.\n\n### 2. Use branches for features and fixes\nBranching is fundamental in Git. Each new feature or bug fix should be developed on its own dedicated branch. This isolates changes, prevents conflicts with the main development line (e.g., `master`/`main`), and allows for concurrent development. Descriptive branch names (e.g., `feature/new-login`, `fix/header-alignment`, `bugfix/issue-123`) are essential for organization and clarity.\n\n### 3. Resolve merge conflicts properly\nConflicts occur when Git cannot automatically combine changes from different branches. Resolving them involves manually editing the conflicted files to combine the desired changes from both branches. After editing, the files must be staged (`git add`) and the merge committed (`git commit`). Understanding conflict markers (`<<<<<<<`, `=======`, `>>>>>>>`) is key.\n\n### 4. Use .gitignore for project-specific files\nThe `.gitignore` file specifies intentionally untracked files that Git should ignore. This is vital for keeping your repository clean by excluding generated files (e.g., `build/`, `dist/`), dependency directories (`node_modules/`), environment-specific configurations (`.env`), personal IDE settings (`.idea/`, `.vscode/`), and temporary files. A well-maintained `.gitignore` prevents irrelevant files from cluttering the repository and causing issues across different development environments.\n\n### 5. Commit atomically\nAtomic commits mean that each commit should represent a single, complete, logical change. For example, a commit might introduce a new feature, fix a single bug, or refactor a specific part of the code. This practice makes code reviews easier, simplifies reverting changes (if necessary), and provides a clear narrative of how the project evolves.\n\n## Git Hooks\nGit hooks are custom scripts that Git automatically executes before or after events like committing, pushing, or receiving commits. They are stored in the `.git/hooks` directory of a repository. Hooks allow developers and teams to automate tasks, enforce coding standards, and streamline workflows. While default hooks are examples, custom scripts can be written in any language (e.g., shell scripts, Python, Node.js).\n\nCommon Git hooks include:\n-   `pre-commit`: Runs *before* a commit is created. Often used to run linters, formatters, or tests to ensure code quality before it's even committed.\n-   `commit-msg`: Runs *after* a commit message has been provided but *before* the commit is finalized. Used to validate the format or content of commit messages (e.g., enforcing a specific prefix like `feat:`, `fix:`).\n-   `pre-push`: Runs *before* pushing to a remote repository. Can be used to run full test suites, build checks, or ensure that the local branch is up-to-date with the remote to prevent pushing breaking changes.\n\n## Git Submodules\nGit submodules allow you to embed one Git repository inside another as a subdirectory. This is useful when your project depends on a specific version of an external repository, and you want to manage that dependency directly within your main project. Submodules effectively pin the dependency to a specific commit, ensuring consistency across all development environments.\n\n### Key Submodule Commands:\n-   `git submodule add <repository-url> <path>`: Adds a new submodule. The specified repository will be cloned into the given path within your main repository.\n-   `git submodule init`: Initializes new submodules found in the `.gitmodules` file (which tracks submodule configurations). This command essentially registers the submodules.\n-   `git submodule update`: Fetches and checks out the correct commit for the submodules as recorded in the parent repository. This is crucial after cloning a repository with submodules or when a submodule's reference commit has been updated.\n-   `git clone --recurse-submodules <repository-url>`: Clones the main repository and automatically initializes and updates all submodules within it. This is the recommended way to clone a project that contains submodules.",
      "examples": [
        {
          "id": "example_git_workflow_1",
          "title": "Pull with Rebase",
          "code": "git checkout feature/my-feature\ngit add .\ngit commit -m \"Implement part of feature X\"\ngit pull --rebase origin main",
          "explanation": "This sequence demonstrates working on a feature branch, committing local changes, and then rebasing those changes on top of the latest 'main' branch updates from the 'origin' remote. This keeps the branch history linear and avoids a merge commit.",
          "language": "bash"
        },
        {
          "id": "example_git_workflow_2",
          "title": "Adding and Updating Git Submodules",
          "code": "# Add a new submodule\ngit submodule add https://github.com/example/my-library.git lib/my-library\n\n# Initialize and update all submodules after cloning a repo\ngit submodule init\ngit submodule update\n\n# Or clone with submodules directly\ngit clone --recurse-submodules https://github.com/my-org/my-project.git",
          "explanation": "These commands illustrate how to add a new submodule (linking an external repository into a sub-directory), and how to initialize and update existing submodules within a cloned repository. The `git clone --recurse-submodules` command streamlines the process for new clones.",
          "language": "bash"
        },
        {
          "id": "example_git_hooks_1",
          "title": "Basic pre-commit hook (Shell)",
          "code": "#!/bin/sh\n\n# Navigate to the .git/hooks directory for this file\n# Save this as .git/hooks/pre-commit and make it executable (chmod +x)\n\n# Example: Run linting before commit\necho \"Running pre-commit hook...\"\n\nnpm test -- --findRelatedTests $(git diff --cached --name-only)\n\nif [ $? -ne 0 ]; then\n  echo \"Tests failed. Aborting commit.\"\n  exit 1\nfi\n\n# Example: Prevent committing files with specific content (e.g., 'debugger;')\nif git diff --cached | grep -q 'debugger;'; then\n  echo \"ERROR: Found 'debugger;' statements. Please remove them before committing.\"\n  exit 1\nfi\n\necho \"Pre-commit hook finished successfully.\"\nexit 0",
          "explanation": "This shell script demonstrates a `pre-commit` hook. It first attempts to run relevant tests for staged files. If tests fail, the commit is aborted. It also checks for 'debugger;' statements, preventing commits that include them. This ensures basic code quality and prevents debugging remnants from entering the codebase.",
          "language": "bash"
        }
      ],
      "complexity": 7,
      "tags": [
        "Git",
        "Version Control",
        "Workflow",
        "Branching",
        "Rebase",
        "Git Hooks",
        "Submodules",
        "Collaboration",
        "Best Practices"
      ],
      "prerequisites": [
        "Basic Git commands (add, commit, push, pull, checkout)"
      ],
      "technology": "Git"
    },
    "tags": [
      "Git",
      "Version Control",
      "Workflow",
      "Branching",
      "Rebase",
      "Git Hooks",
      "Submodules",
      "Collaboration",
      "Best Practices"
    ],
    "prerequisites": [
      "Basic Git commands (add, commit, push, pull, checkout)"
    ]
  },
  {
    "index": 110,
    "id": "theory_indexeddb",
    "type": "theory",
    "moduleId": "web apis",
    "complexity": 7,
    "title": "IndexedDB: Client-Side NoSQL Database",
    "description": "",
    "content": {
      "id": "theory_indexeddb",
      "title": "IndexedDB: Client-Side NoSQL Database",
      "description": "",
      "type": "theory",
      "content": "IndexedDB is a low-level API for client-side storage of significant amounts of structured data, including files/blobs. It's a NoSQL database system built into browsers, providing a powerful alternative to `localStorage` or `sessionStorage` for more complex data storage needs.\n\n## Key Characteristics\n- **Persistence between sessions**: Data stored in IndexedDB remains available even after the user closes the browser or restarts their computer.\n- **Storage limit**: Significantly larger than `localStorage` (typically several hundred MBs, potentially more depending on browser and available disk space), making it suitable for large datasets.\n- **Supports complex data structures**: Can store JavaScript objects directly, including nested objects, arrays, Blobs, and Files, without needing explicit serialization/deserialization.\n- **Transactions and indexes**: Offers robust transaction support (ensuring data integrity and atomicity) and the ability to create indexes for efficient querying and searching, similar to traditional relational databases.\n- **Asynchronous API**: All operations are asynchronous, returning `IDBRequest` objects, which emit `success` or `error` events. This prevents blocking the main thread and keeps the UI responsive.\n- **Advanced Search Capabilities**: Allows searching data using cursors and indexes, providing more flexible and efficient query options compared to simple key-value stores.\n\n## Core Concepts\n- **Database (IDBDatabase)**: The top-level container for all data, identified by a name and version. Changes to the database structure (e.g., creating object stores, indexes) require incrementing the version.\n- **Object Store (IDBObjectStore)**: Similar to tables in a relational database. An object store holds records, where each record is a JavaScript object. Each object store must have a `keyPath` or `autoIncrement` property to uniquely identify records.\n- **Index (IDBIndex)**: A mechanism to efficiently look up records in an object store based on a specific property, similar to an index in a database table. Indexes can be unique or non-unique.\n- **Transaction (IDBTransaction)**: A crucial concept for ensuring data integrity. All read and write operations must occur within a transaction. Transactions are atomic: either all operations within them succeed, or none do. They can be `readonly` or `readwrite`.\n- **Request (IDBRequest)**: Most IndexedDB operations (e.g., `open`, `add`, `get`, `put`) return an `IDBRequest` object. The result of the operation is available in the `event.target.result` property of the `success` event handler.\n- **Cursor (IDBCursor)**: Used to iterate over records in an object store or index, allowing for efficient traversal and retrieval of multiple records.\n\n## IndexedDB Workflow Overview\n1.  **Open a Database**: Use `indexedDB.open()` to connect to an existing database or create a new one. This operation returns an `IDBOpenDBRequest`.\n2.  **Handle `onupgradeneeded`**: If the database version changes or it's created for the first time, this event fires. It's the *only* place where you can create or delete object stores and indexes.\n3.  **Handle `onsuccess`**: Once the database is successfully opened (or upgraded), this event fires. You can then start transactions to perform data operations.\n4.  **Perform Transactions**: Create a `readwrite` or `readonly` transaction on specific object stores. Get a reference to the `IDBObjectStore`.\n5.  **Data Operations (CRUD)**: Use methods like `add()`, `get()`, `put()`, `delete()`, `clear()` on the object store.\n6.  **Querying with Indexes**: Use `objectStore.index()` to get an `IDBIndex` object, then use methods like `get()` or `getAll()` on the index.\n7.  **Error Handling**: Always include `onerror` handlers for requests and transactions to gracefully manage failures.\n",
      "examples": [
        {
          "id": "example_indexeddb_open_setup",
          "title": "Opening Database and Creating Object Store/Indexes",
          "code": "const request = indexedDB.open('MyDatabase', 1);\n\nrequest.onupgradeneeded = function(event) {\n  const db = event.target.result;\n  // Create an object store named 'customers' with 'id' as the key path\n  const objectStore = db.createObjectStore('customers', { keyPath: 'id' });\n  \n  // Create indexes for faster searching\n  // 'name' index, based on 'name' property, not unique\n  objectStore.createIndex('name', 'name', { unique: false });\n  // 'email' index, based on 'email' property, must be unique\n  objectStore.createIndex('email', 'email', { unique: true });\n};\n\nrequest.onerror = function(event) {\n  console.error('Database error:', event.target.errorCode);\n};\n\nrequest.onsuccess = function(event) {\n  console.log('Database opened successfully.');\n  // Database is ready for transactions here\n  const db = event.target.result;\n  db.close(); // Close db after setup if no immediate operations\n};\n",
          "explanation": "This example demonstrates the initial setup for an IndexedDB database. It shows how to open a database, specify its version, and crucially, how to use the `onupgradeneeded` event to define object stores and create indexes. The `keyPath` defines the unique identifier for records, while `createIndex` allows for efficient retrieval of data based on other properties. Error handling is also included.",
          "language": "javascript"
        },
        {
          "id": "example_indexeddb_crud",
          "title": "Performing CRUD Operations",
          "code": "const request = indexedDB.open('MyDatabase', 1);\n\nrequest.onsuccess = function(event) {\n  const db = event.target.result;\n  \n  // Start a readwrite transaction for the 'customers' object store\n  const transaction = db.transaction(['customers'], 'readwrite');\n  const objectStore = transaction.objectStore('customers');\n  \n  // --- Add Data ---\n  const customerData = { id: 1, name: 'John Doe', email: 'john@example.com', age: 30 };\n  const addRequest = objectStore.add(customerData);\n  addRequest.onsuccess = () => console.log('Customer added:', customerData);\n  addRequest.onerror = (e) => console.error('Add error:', e.target.error);\n\n  // --- Read Data ---\n  const getRequest = objectStore.get(1);\n  getRequest.onsuccess = function(event) {\n    const customer = event.target.result;\n    console.log('Customer retrieved:', customer);\n  };\n  getRequest.onerror = (e) => console.error('Get error:', e.target.error);\n\n  // --- Update Data ---\n  // Note: 'put' can add if key doesn't exist, or update if it does.\n  const updatedCustomerData = { ...customerData, age: 31 };\n  const updateRequest = objectStore.put(updatedCustomerData);\n  updateRequest.onsuccess = () => console.log('Customer updated:', updatedCustomerData);\n  updateRequest.onerror = (e) => console.error('Update error:', e.target.error);\n  \n  // --- Delete Data ---\n  const deleteRequest = objectStore.delete(1);\n  deleteRequest.onsuccess = () => console.log('Customer deleted with ID 1.');\n  deleteRequest.onerror = (e) => console.error('Delete error:', e.target.error);\n\n  // --- Use an index to search ---\n  const nameIndex = objectStore.index('name');\n  const nameSearchRequest = nameIndex.getAll('John Doe'); // Get all records where 'name' is 'John Doe'\n  nameSearchRequest.onsuccess = function(event) {\n    const matches = event.target.result;\n    console.log('Customers with name \"John Doe\":', matches);\n  };\n  nameSearchRequest.onerror = (e) => console.error('Index search error:', e.target.error);\n\n  // A transaction completes when all its requests complete and there are no new requests.\n  transaction.oncomplete = () => console.log('Transaction completed.');\n  transaction.onerror = (e) => console.error('Transaction error:', e.target.error);\n};\n",
          "explanation": "This example illustrates performing common CRUD (Create, Read, Update, Delete) operations using IndexedDB within a `readwrite` transaction. It demonstrates `add()` for inserting new records, `get()` for retrieving by `keyPath`, `put()` for updating existing records (or adding if not present), and `delete()` for removing records. Crucially, it also shows how to leverage a previously defined index (`nameIndex`) to search for records based on a non-key property using `getAll()`. Each operation is asynchronous and uses `onsuccess`/`onerror` callbacks.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "IndexedDB",
        "Client-Side Storage",
        "Offline",
        "Persistence",
        "Database",
        "NoSQL"
      ],
      "prerequisites": [
        "Asynchronous JavaScript",
        "Event Handling",
        "Promises (basic understanding)"
      ],
      "technology": "Web APIs"
    },
    "tags": [
      "IndexedDB",
      "Client-Side Storage",
      "Offline",
      "Persistence",
      "Database",
      "NoSQL"
    ],
    "prerequisites": [
      "Asynchronous JavaScript",
      "Event Handling",
      "Promises (basic understanding)"
    ]
  },
  {
    "index": 166,
    "id": "theory_serviceworker_caching_deduplication",
    "type": "theory",
    "moduleId": "web apis",
    "complexity": 7,
    "title": "Service Worker: Caching and Request Deduplication",
    "description": "",
    "content": {
      "id": "theory_serviceworker_caching_deduplication",
      "title": "Service Worker: Caching and Request Deduplication",
      "description": "",
      "type": "theory",
      "content": "Service Workers act as a programmable proxy between the browser and the network, enabling powerful features like offline experiences, push notifications, and background data synchronization. They run in a separate thread and can intercept network requests, allowing developers to control how resources are fetched and cached.\n\n## Key Concepts\n\n### Cache-First Strategy\nThe cache-first strategy is a common caching pattern where a Service Worker first checks if a requested resource is available in its cache. If found, it serves the cached version immediately. If not, it falls back to fetching the resource from the network. This approach prioritizes speed and offline availability. The example provided demonstrates a basic cache-first strategy.\n\n### Background Refetching (Stale-While-Revalidate)\nWhile not explicitly shown in the provided example, 'Background refetching' typically refers to patterns like \"Stale-While-Revalidate\". In this strategy:\n1.  The Service Worker immediately serves a cached response if available.\n2.  In the background, it fetches the latest version of the resource from the network.\n3.  Once the new version is successfully fetched, it updates the cache for future requests.\nThis provides the best of both worlds: fast loading times from cache and up-to-date content from the network.\n\n### Deduplication of Requests\nDeduplication of requests involves preventing multiple identical network requests from being sent simultaneously, especially when a resource is requested multiple times in quick succession (e.g., a user rapidly clicks a button, or a component mounts multiple times). A Service Worker can implement deduplication by holding pending promises for ongoing fetches and returning the same promise for subsequent identical requests until the initial fetch resolves.",
      "examples": [
        {
          "id": "example_serviceworker_cache_first",
          "title": "Service Worker Cache-First Strategy",
          "code": "self.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request).then(cachedResponse => {\n      if (cachedResponse) {\n        return cachedResponse;\n      }\n      return fetch(event.request).then(response => {\n        if (!response || response.status !== 200 || response.type !== 'basic') {\n          return response;\n        }\n        \n        const responseToCache = response.clone();\n        caches.open('v1').then(cache => {\n          cache.put(event.request, responseToCache);\n        });\n        \n        return response;\n      });\n    })\n  );\n});",
          "explanation": "This Service Worker code demonstrates a basic 'cache-first' strategy. When a fetch event occurs, it first attempts to find a matching request in the `v1` cache. If a match is found (`cachedResponse` exists), it returns the cached response immediately. If not, it proceeds to fetch the resource from the network. Upon a successful network fetch (status 200, type 'basic'), it clones the response (as a response body can only be consumed once), stores the clone in the cache, and then returns the original network response to the browser. This ensures that subsequent requests for the same resource will be served from the cache, improving performance and enabling offline capabilities.",
          "language": "javascript"
        },
        {
          "id": "example_serviceworker_deduplication_concept",
          "title": "Conceptual Service Worker Request Deduplication",
          "code": "const fetchPromises = new Map();\n\nself.addEventListener('fetch', event => {\n  const requestUrl = event.request.url;\n\n  // Check if a fetch for this URL is already in progress\n  if (fetchPromises.has(requestUrl)) {\n    event.respondWith(fetchPromises.get(requestUrl));\n    return;\n  }\n\n  // If not, perform the fetch and store its promise\n  const fetchPromise = fetch(event.request)\n    .then(response => {\n      // Clone response for caching if needed\n      const responseToCache = response.clone(); \n      // Cache logic here (e.g., caches.open('v1').then(cache => cache.put(event.request, responseToCache))) \n      return response;\n    })\n    .finally(() => {\n      // Remove the promise from the map once resolved or rejected\n      fetchPromises.delete(requestUrl);\n    });\n  \n  fetchPromises.set(requestUrl, fetchPromise);\n  event.respondWith(fetchPromise);\n});",
          "explanation": "This conceptual example illustrates how a Service Worker could implement request deduplication. It uses a `Map` to store promises for ongoing fetches, keyed by their request URL. When a `fetch` event comes in, it checks if there's already a pending promise for that URL. If so, it returns the existing promise, effectively deduplicating the request. If not, it initiates a new fetch, stores its promise, and then removes it from the map once the fetch completes (successfully or with an error). This ensures that only one network request for a given URL is active at any time, preventing redundant fetches.",
          "language": "javascript"
        }
      ],
      "complexity": 7,
      "tags": [
        "Service Worker",
        "PWA",
        "Caching",
        "Offline First",
        "Web Performance",
        "Network Requests",
        "Background Sync",
        "Deduplication"
      ],
      "prerequisites": [
        "JavaScript Async/Await",
        "Promises",
        "Web API Fundamentals",
        "HTTP Basics"
      ],
      "technology": "Web APIs"
    },
    "tags": [
      "Service Worker",
      "PWA",
      "Caching",
      "Offline First",
      "Web Performance",
      "Network Requests",
      "Background Sync",
      "Deduplication"
    ],
    "prerequisites": [
      "JavaScript Async/Await",
      "Promises",
      "Web API Fundamentals",
      "HTTP Basics"
    ]
  },
  {
    "index": 112,
    "id": "theory_html_form_overrides",
    "type": "theory",
    "moduleId": "html",
    "complexity": 4,
    "title": "HTML Form Overriding Attributes",
    "description": "",
    "content": {
      "id": "theory_html_form_overrides",
      "title": "HTML Form Overriding Attributes",
      "description": "",
      "type": "theory",
      "content": "HTML5 introduced a set of attributes that can be applied to `<input type=\"submit\">`, `<input type=\"image\">`, or `<button type=\"submit\">` elements to override the default behavior of their parent `<form>` element. These attributes provide granular control over how a specific submit action behaves, without altering the form's global attributes.\n\n### Key Attributes:\n\n*   `formaction`: This attribute specifies the URL to which the form data will be submitted when the specific submit button is clicked. It overrides the `action` attribute of the parent `<form>` element. This is useful when you want different submit buttons within the same form to submit data to different endpoints.\n*   `formenctype`: This attribute specifies how the form data should be encoded when submitted. It overrides the `enctype` attribute of the parent `<form>`. Common values include `application/x-www-form-urlencoded` (default for most forms), `multipart/form-data` (for file uploads), and `text/plain`.\n*   `formmethod`: This attribute specifies the HTTP method to use when submitting the form data (e.g., `GET`, `POST`). It overrides the `method` attribute of the parent `<form>`. This allows a single form to have buttons that submit data using different HTTP methods.\n*   `formtarget`: This attribute specifies where to display the response after submitting the form. It overrides the `target` attribute of the parent `<form>`. Common values include `_self` (default, in the same browsing context), `_blank` (in a new tab/window), `_parent` (in the parent frame), or `_top` (in the full body of the window). This is particularly useful for submitting data to an iframe or opening a new tab for a report.",
      "examples": [
        {
          "id": "example_form_overrides_1",
          "title": "Basic Formaction and Formmethod Override",
          "code": "<!-- index.html -->\n<form action=\"/default-submit\" method=\"get\">\n  <label for=\"username\">Username:</label>\n  <input type=\"text\" id=\"username\" name=\"username\">\n  <br><br>\n  <button type=\"submit\">Submit Default</button>\n  <button type=\"submit\" formaction=\"/api/create-user\" formmethod=\"post\">Create User</button>\n  <button type=\"submit\" formaction=\"/api/search-user\" formmethod=\"get\">Search User</button>\n</form>",
          "explanation": "In this example, the form's default submission is to `/default-submit` using `GET`. However, the 'Create User' button overrides this to submit to `/api/create-user` using `POST`, and the 'Search User' button submits to `/api/search-user` using `GET`, demonstrating how different buttons can trigger different submission behaviors.",
          "language": "html"
        },
        {
          "id": "example_form_overrides_2",
          "title": "Formtarget and Formenctype Override",
          "code": "<!-- index.html -->\n<form action=\"/upload\" method=\"post\" enctype=\"application/x-www-form-urlencoded\">\n  <label for=\"file\">Upload File:</label>\n  <input type=\"file\" id=\"file\" name=\"userFile\">\n  <br><br>\n  <button type=\"submit\">Submit Standard</button>\n  <button type=\"submit\" formaction=\"/upload-large\" formtarget=\"_blank\" formenctype=\"multipart/form-data\">Upload Large File in New Tab</button>\n</form>",
          "explanation": "Here, the form's default `enctype` is `application/x-www-form-urlencoded`. The 'Upload Large File in New Tab' button overrides the `enctype` to `multipart/form-data` (necessary for file uploads) and opens the submission response in a new tab (`_blank`), while also changing the submission URL.",
          "language": "html"
        }
      ],
      "complexity": 4,
      "tags": [
        "HTML",
        "Forms",
        "Web Development",
        "Frontend Basics",
        "Attributes"
      ],
      "prerequisites": [
        "html_forms",
        "http_methods"
      ],
      "technology": "HTML"
    },
    "tags": [
      "HTML",
      "Forms",
      "Web Development",
      "Frontend Basics",
      "Attributes"
    ],
    "prerequisites": [
      "html_forms",
      "http_methods"
    ]
  },
  {
    "index": 163,
    "id": "theory_html_whitespace_minification",
    "type": "theory",
    "moduleId": "html",
    "complexity": 5,
    "title": "HTML Whitespace Minification and Page Load Performance",
    "description": "",
    "content": {
      "id": "theory_html_whitespace_minification",
      "title": "HTML Whitespace Minification and Page Load Performance",
      "description": "",
      "type": "theory",
      "content": "Minification is the process of removing unnecessary characters from code without changing its functionality. For HTML, this primarily involves eliminating extra whitespace characters (spaces, tabs, newlines) and comments. While modern web browsers are robust in parsing HTML and will collapse multiple spaces into a single space for display, the presence of these extra characters directly impacts the file size of the HTML document.\n\n### Impact on Performance\n1.  **Faster Download Time**: A smaller file size means fewer bytes need to be transferred over the network. This directly reduces the time it takes for the browser to download the HTML document, which is a critical factor for initial page loading metrics like Time to First Byte (TTFB) and overall page load time.\n2.  **Reduced Bandwidth Consumption**: Smaller file sizes conserve network bandwidth for users, which is particularly beneficial for those on limited data plans or slower connections. For server operators, it translates to reduced data transfer costs.\n\n### Browser Parsing vs. Network Transfer\nIt's important to distinguish between how browsers *parse* HTML and how the HTML file is *transferred*. Browsers are indeed efficient at parsing, and extra whitespace might not significantly affect the *rendering* phase once the document is fully downloaded and the DOM is constructed. However, the time spent *downloading* the file, including all its characters (visible or not), is a separate and often more critical bottleneck for initial page load performance. Therefore, minification is a standard and effective optimization practice.\n\n### Common Misconception\nThe original statement in the markdown content, \"removing extra whitespace characters (and newline characters) in HTML not affect the final page loading performance\" is generally incorrect. While the visual rendering might appear the same, the underlying network transfer performance is indeed affected positively by minification. The perceived negligible difference might only apply to extremely small HTML documents where network latency overshadows the download time difference.",
      "examples": [
        {
          "id": "example_html_whitespace_1",
          "title": "Unminified vs. Minified HTML",
          "code": "<!-- Unminified HTML -->\n<!DOCTYPE html>\n<html>\n<head>\n    <title>   My Page   </title>\n</head>\n<body>\n    <p>\n        Hello     World\n    </p>\n    <!-- This is a comment -->\n    <div>\n\n        Another section with   lots of space.\n\n    </div>\n</body>\n</html>\n\n<!-- Minified HTML -->\n<!DOCTYPE html><html><head><title>My Page</title></head><body><p>Hello World</p><div>Another section with lots of space.</div></body></html>",
          "explanation": "This example clearly shows the difference in character count between unminified and minified HTML. The minified version eliminates all unnecessary spaces, tabs, newlines, and comments, resulting in a significantly smaller file size. This reduction directly leads to faster download times over the network, improving initial page load performance.",
          "language": "html"
        }
      ],
      "complexity": 5,
      "tags": [
        "HTML",
        "Performance Optimization",
        "Minification",
        "Web Performance",
        "Frontend Optimization"
      ],
      "prerequisites": [
        "Networking Basics",
        "HTTP Fundamentals"
      ],
      "technology": "HTML"
    },
    "tags": [
      "HTML",
      "Performance Optimization",
      "Minification",
      "Web Performance",
      "Frontend Optimization"
    ],
    "prerequisites": [
      "Networking Basics",
      "HTTP Fundamentals"
    ]
  },
  {
    "index": 114,
    "id": "theory_css_selectors",
    "type": "theory",
    "moduleId": "css",
    "complexity": 5,
    "title": "CSS Selectors and Combinators",
    "description": "",
    "content": {
      "id": "theory_css_selectors",
      "title": "CSS Selectors and Combinators",
      "description": "",
      "type": "theory",
      "content": "CSS selectors are patterns used to select and style HTML elements. They allow developers to target specific elements, groups of elements, or elements based on their state or position within the document.\n\n## Type Selectors\nThese select elements by their HTML tag name, e.g., `div` selects all `<div>` elements.\n\n## Combinators\nCombinators explain the relationship between the selectors. The markdown provided specifically mentions the Adjacent Sibling Selector.\n\n- **Adjacent Sibling Selector (`+`):** Selects an element that is immediately preceded by another specified element. It only selects the *next* sibling.\n\n## Pseudo-classes\nPseudo-classes are used to define a special state of an element. They are denoted by a single colon (`:`).\n\n- `:hover`: Selects an element when the user's mouse pointer is over it.\n- `:focus`: Selects an element that has received focus (e.g., an input field when clicked).\n- `:first-child`: Selects an element that is the first child of its parent.\n- `:last-child`: Selects an element that is the last child of its parent.\n- `:nth-child(n)`: Selects elements based on their position among a group of siblings. `n` can be a number, a keyword (like `odd`, `even`), or a formula (like `2n` for even, `2n+1` for odd, `3n` for every third). `2n` selects every even-numbered element.\n\n## Pseudo-elements\nPseudo-elements are used to style a specific part of an element. They are denoted by a double colon (`::`).\n\n- `::first-line`: Selects the first line of a block-level element.\n- `::first-letter`: Selects the first letter of a block-level element.\n- `::before`: Inserts content before the actual content of an element. This content is inline by default and requires the `content` property.\n- `::after`: Inserts content after the actual content of an element. Similar to `::before`, it requires the `content` property.\n\n## Combining Selectors\nSelectors can be combined to create more specific rules.\n\n- **Multiple Classes (`.class1.class2`):** Selects an element that has *all* the specified classes.\n- **Element with Class (`element.class`):** Selects a specific type of element that also has a particular class.",
      "examples": [
        {
          "id": "example_css_selectors_1",
          "title": "Adjacent Sibling Selector",
          "code": "/* HTML */\n<a href=\"#\">Link</a>\n<p>This paragraph will be styled because it immediately follows an 'a' tag.</p>\n<p>This paragraph will not be styled.</p>\n\n/* CSS */\na + p {\n  color: blue;\n  font-weight: bold;\n}",
          "explanation": "This example demonstrates the adjacent sibling selector. Only the first paragraph element that directly follows an `<a>` element will have its text color changed to blue and made bold.",
          "language": "css"
        },
        {
          "id": "example_css_selectors_2",
          "title": "Pseudo-classes and Pseudo-elements",
          "code": "/* HTML */\n<input type=\"text\" placeholder=\"Focus me\">\n<ul>\n  <li>Item 1</li>\n  <li>Item 2</li>\n  <li>Item 3</li>\n</ul>\n<p>This is a paragraph with multiple lines. The first line and first letter will be styled.</p>\n<div class=\"important\">Important Content</div>\n\n/* CSS */\ninput:focus {\n  border: 2px solid green;\n}\nli:nth-child(2n) {\n  background-color: #f0f0f0;\n}\np::first-line {\n  text-transform: uppercase;\n}\np::first-letter {\n  font-size: 2em;\n  color: red;\n}\ndiv.important::before {\n  content: \"Note: \";\n  font-weight: bold;\n  color: purple;\n}",
          "explanation": "This example shows various pseudo-classes and pseudo-elements. The input field gets a green border on focus. Even-numbered list items get a light gray background. The first line of the paragraph becomes uppercase, and its first letter is larger and red. Finally, the `::before` pseudo-element adds 'Note: ' in bold purple before the content of `div.important`.",
          "language": "css"
        }
      ],
      "complexity": 5,
      "tags": [
        "CSS",
        "Selectors",
        "Pseudo-classes",
        "Pseudo-elements",
        "Combinators"
      ],
      "prerequisites": [
        "HTML_structure"
      ],
      "technology": "CSS"
    },
    "tags": [
      "CSS",
      "Selectors",
      "Pseudo-classes",
      "Pseudo-elements",
      "Combinators"
    ],
    "prerequisites": [
      "HTML_structure"
    ]
  },
  {
    "index": 116,
    "id": "theory_css_grid_fundamentals",
    "type": "theory",
    "moduleId": "css",
    "complexity": 5,
    "title": "CSS Grid Fundamentals: Defining Rows, Columns, and Gaps",
    "description": "",
    "content": {
      "id": "theory_css_grid_fundamentals",
      "title": "CSS Grid Fundamentals: Defining Rows, Columns, and Gaps",
      "description": "",
      "type": "theory",
      "content": "CSS Grid is a powerful two-dimensional layout system that allows precise control over both rows and columns simultaneously. Unlike Flexbox, which is primarily one-dimensional, Grid excels at overall page layouts and complex, asymmetrical designs.\n\n## Key Concepts\n*   **Grid Container**: An element with `display: grid` or `display: inline-grid`. This element becomes the parent for grid items and establishes a new grid formatting context.\n*   **Grid Items**: The direct children of a grid container. These elements are laid out according to the grid rules.\n*   **Grid Lines**: Horizontal and vertical lines that divide the grid into cells. Numbered starting from 1.\n*   **Grid Tracks**: The space between two adjacent grid lines, forming columns or rows.\n*   **Grid Cells**: The intersection of a grid row and a grid column, the smallest unit of a grid.\n*   **`display: grid`**: Turns an element into a grid container.\n*   **`grid-template-columns`**: Defines the columns of the grid. You can specify fixed sizes (e.g., `100px`), flexible sizes (e.g., `1fr` for a fraction of available space), or repeat patterns (`repeat(3, 1fr)`).\n*   **`grid-template-rows`**: Defines the rows of the grid, similar to `grid-template-columns`.\n*   **`gap`**: (formerly `grid-gap`) A shorthand property for `row-gap` and `column-gap`. It defines the spacing between grid cells, not around the container.\n\n## Units in Grid\n*   **`fr` (fractional unit)**: Represents a fraction of the available space in the grid container. `1fr` means one part of the free space. If you have `1fr 2fr`, the second column will be twice as wide as the first.\n*   **Fixed units**: `px`, `em`, `rem`, `vw`, `vh`, etc.\n*   **`auto`**: Allows the browser to determine the size of the track based on its content.",
      "examples": [
        {
          "id": "example_css_grid_basic_1",
          "title": "Basic Grid Definition",
          "code": "```css\n.basic-grid {\n  display: grid;\n  grid-template-columns: 100px 1fr 200px; /* Column 1: 100px, Column 2: fills remaining space, Column 3: 200px */\n  grid-template-rows: 50px auto;\n  gap: 15px;\n  background-color: #eee;\n  padding: 10px;\n}\n\n.grid-item {\n  background-color: lightblue;\n  border: 1px solid #333;\n  padding: 10px;\n}\n\n/* HTML Structure */\n/*\n<div class=\"basic-grid\">\n  <div class=\"grid-item\">Item 1</div>\n  <div class=\"grid-item\">Item 2</div>\n  <div class=\"grid-item\">Item 3</div>\n  <div class=\"grid-item\">Item 4</div>\n  <div class=\"grid-item\">Item 5</div>\n  <div class=\"grid-item\">Item 6</div>\n</div>\n*/\n```",
          "explanation": "This example sets up a grid with three columns (fixed, fractional, fixed) and two rows (fixed, auto). A `gap` of 15px is applied between grid cells. The fractional unit `1fr` ensures that the middle column expands to fill the available space.",
          "language": "css"
        },
        {
          "id": "example_css_grid_repeat_1",
          "title": "Using `repeat()` for Columns and Rows",
          "code": "```css\n.grid-repeat {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr); /* Creates 4 equal columns */\n  grid-template-rows: repeat(2, 80px);   /* Creates 2 rows, each 80px high */\n  gap: 10px 20px; /* Row gap: 10px, Column gap: 20px */\n  background-color: #f0f0f0;\n  padding: 10px;\n}\n\n.grid-item {\n  background-color: lightcoral;\n  border: 1px solid #333;\n  padding: 10px;\n}\n\n/* HTML Structure */\n/*\n<div class=\"grid-repeat\">\n  <div class=\"grid-item\">A</div>\n  <div class=\"grid-item\">B</div>\n  <div class=\"grid-item\">C</div>\n  <div class=\"grid-item\">D</div>\n  <div class=\"grid-item\">E</div>\n  <div class=\"grid-item\">F</div>\n  <div class=\"grid-item\">G</div>\n  <div class=\"grid-item\">H</div>\n</div>\n*/\n```",
          "explanation": "The `repeat()` function is a concise way to define multiple columns or rows with the same size. Here, `repeat(4, 1fr)` creates four equally sized columns, and `repeat(2, 80px)` creates two rows of 80px height. `gap` can also take two values for distinct row and column gaps.",
          "language": "css"
        }
      ],
      "complexity": 5,
      "tags": [
        "CSS Grid",
        "Layout",
        "Frontend",
        "Responsive Design",
        "Grid-template-columns",
        "Grid-template-rows",
        "Gap"
      ],
      "prerequisites": [
        "HTML Structure",
        "Basic CSS Properties"
      ],
      "technology": "CSS"
    },
    "tags": [
      "CSS Grid",
      "Layout",
      "Frontend",
      "Responsive Design",
      "Grid-template-columns",
      "Grid-template-rows",
      "Gap"
    ],
    "prerequisites": [
      "HTML Structure",
      "Basic CSS Properties"
    ]
  },
  {
    "index": 143,
    "id": "theory_css_flex_alignment",
    "type": "theory",
    "moduleId": "css",
    "complexity": 5,
    "title": "CSS Flexbox for Layout and Alignment",
    "description": "",
    "content": {
      "id": "theory_css_flex_alignment",
      "title": "CSS Flexbox for Layout and Alignment",
      "description": "",
      "type": "theory",
      "content": "Flexbox (Flexible Box Layout module) is a one-dimensional layout method for arranging items in rows or columns. It offers an efficient way to lay out, align, and distribute space among items in a container, even when their size is unknown or dynamic. It's particularly useful for aligning items along a single axis.\n\n## Key Concepts\n- **Flex Container**: The element on which `display: flex` is applied. This makes its direct children flex items.\n- **Flex Items**: The direct children of a flex container.\n- **Main Axis**: The primary axis along which flex items are laid out. Determined by `flex-direction`.\n- **Cross Axis**: The axis perpendicular to the main axis.\n- `flex-direction`: Defines the direction of the main axis (e.g., `row`, `column`, `row-reverse`, `column-reverse`).\n- `align-items`: Aligns flex items along the cross axis. Common values include `flex-start`, `flex-end`, `center`, `baseline`, `stretch`.\n- `justify-content`: Aligns flex items along the main axis. Common values include `flex-start`, `flex-end`, `center`, `space-between`, `space-around`, `space-evenly`.\n\n## Vertical Alignment with Flexbox\nTo vertically align items in a row (when `flex-direction: row`), you use the `align-items` property on the flex container. Setting `align-items: center` will vertically center the flex items along the cross-axis, regardless of their individual heights.",
      "examples": [
        {
          "id": "example_flex_alignment_1",
          "title": "Basic Vertical Alignment with Flexbox",
          "code": "/* HTML Structure */\n/* <div class=\"container\">\n  <div class=\"item\">Item 1 (Short)</div>\n  <div class=\"item\">Item 2 (Tall Tall Tall Tall)</div>\n  <div class=\"item\">Item 3</div>\n</div> */\n\n/* CSS */\n.container {\n  display: flex;\n  flex-direction: row;\n  align-items: center; /* Aligns items vertically in the center */\n  border: 2px solid blue;\n  min-height: 150px; /* To make the alignment visible */\n  padding: 10px;\n}\n\n.item {\n  padding: 15px;\n  margin: 5px;\n  background-color: lightblue;\n  border: 1px solid steelblue;\n  /* Items can have different heights and still be vertically aligned */\n}",
          "explanation": "This example demonstrates how to use `display: flex` on a container and `flex-direction: row` to arrange items horizontally. The crucial part for vertical alignment is `align-items: center`, which ensures all flex items are centered along the cross-axis (vertically, in this row-based layout). Even with varying item heights, they will all align their midpoints.",
          "language": "css"
        }
      ],
      "complexity": 5,
      "tags": [
        "CSS",
        "Flexbox",
        "Layout",
        "Alignment",
        "Frontend Basics"
      ],
      "prerequisites": [
        "html_basics",
        "css_box_model"
      ],
      "technology": "CSS"
    },
    "tags": [
      "CSS",
      "Flexbox",
      "Layout",
      "Alignment",
      "Frontend Basics"
    ],
    "prerequisites": [
      "html_basics",
      "css_box_model"
    ]
  },
  {
    "index": 115,
    "id": "theory_css_centering",
    "type": "theory",
    "moduleId": "css3",
    "complexity": 6,
    "title": "Centering Elements in CSS: Multiple Approaches",
    "description": "",
    "content": {
      "id": "theory_css_centering",
      "title": "Centering Elements in CSS: Multiple Approaches",
      "description": "",
      "type": "theory",
      "content": "Centering elements both horizontally and vertically is a common task in CSS layout. Historically, this has been challenging, but modern CSS provides several robust and flexible methods. Understanding these different approaches is crucial for building responsive and maintainable user interfaces.\n\n## Method 1: Using CSS Flexbox\nFlexbox is a one-dimensional layout module that excels at distributing space between items and aligning them within a container. It's highly recommended for centering due to its flexibility and control.\n\nTo center an item within a flex container, you apply `display: flex`, `justify-content: center` (for horizontal centering), and `align-items: center` (for vertical centering) to the parent container. A crucial aspect often overlooked is ensuring the parent container has a defined height (e.g., `height: 100%` or `min-height: 100vh`) for vertical centering to work effectively.\n\n## Method 2: Using CSS Grid\nCSS Grid Layout is a two-dimensional layout system that allows for powerful control over rows and columns. For simple centering, it offers a concise shorthand `place-items`.\n\nTo center an item within a grid container, you apply `display: grid` and `place-items: center` to the parent container. `place-items` is a shorthand property that sets both `align-items` (vertical alignment) and `justify-items` (horizontal alignment) to `center` simultaneously. Similar to Flexbox, the parent container needs a defined height for `place-items` to center vertically within that space.\n\n## Method 3: Using Absolute Positioning and Transform\nThis method is a classic technique, often used when an element needs to be precisely positioned relative to its parent, regardless of other sibling elements. It involves setting the parent to `position: relative` to establish a positioning context, and the child to `position: absolute`.\n\nThe child element is then moved `top: 50%` and `left: 50%`. This positions its top-left corner at the exact center of the parent. To truly center it, a `transform: translate(-50%, -50%)` is applied. This `translate()` function shifts the element back by half of its *own* width and half of its *own* height, regardless of its actual dimensions, ensuring perfect centering. This method is good for overlays or when exact positioning is required.\n\n## Method 4: Using Display Table\nThis older method leverages the behavior of HTML tables for layout, specifically `vertical-align` and `text-align`. While less common with the advent of Flexbox and Grid, it's still a valid technique to be aware of, particularly for legacy systems or simple text/inline element centering within a block.\n\nTo center content using this method, the parent element is set to `display: table` and its child to `display: table-cell`. `vertical-align: middle` handles vertical centering of the content within the 'cell', and `text-align: center` handles horizontal centering of inline content (like text or inline-block elements) inside the 'cell'. The parent also needs a defined `height` and `width` for this method to be effective.",
      "examples": [
        {
          "id": "example_css_centering_flexbox",
          "title": "Centering with Flexbox",
          "code": ".flex-center {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100%; /* Important for vertical centering */\n  border: 1px dashed #ccc;\n}\n\n.flex-center .child {\n  width: 100px;\n  height: 100px;\n  background-color: lightblue;\n  display: flex; /* Can center content inside child if needed */\n  justify-content: center;\n  align-items: center;\n  color: white;\n  font-weight: bold;\n}\n\n/* HTML Structure:\n<div class=\"flex-center\">\n  <div class=\"child\">Flex Item</div>\n</div> */",
          "explanation": "This example demonstrates how to use Flexbox to center a child element within a parent container. `display: flex` makes the container a flex container, `justify-content: center` centers items along the main axis (horizontally by default), and `align-items: center` centers items along the cross axis (vertically by default). A `height: 100%` on the parent is crucial for vertical centering to work, as it gives the container a defined height to align items within.",
          "language": "css"
        },
        {
          "id": "example_css_centering_grid",
          "title": "Centering with CSS Grid",
          "code": ".grid-center {\n  display: grid;\n  place-items: center; /* shorthand for align-items and justify-items */\n  height: 100%;\n  border: 1px dashed #ccc;\n}\n\n.grid-center .child {\n  width: 100px;\n  height: 100px;\n  background-color: lightcoral;\n  display: grid; /* Can center content inside child if needed */\n  place-items: center;\n  color: white;\n  font-weight: bold;\n}\n\n/* HTML Structure:\n<div class=\"grid-center\">\n  <div class=\"child\">Grid Item</div>\n</div> */",
          "explanation": "This example uses CSS Grid for centering. `display: grid` makes the container a grid container. The `place-items: center` property is a concise shorthand that sets both `align-items` and `justify-items` to `center`, effectively centering any direct children within their grid cells. Similar to Flexbox, the parent needs a defined `height` for vertical centering to be effective.",
          "language": "css"
        },
        {
          "id": "example_css_centering_absolute_transform",
          "title": "Centering with Absolute Positioning & Transform",
          "code": ".abs-center {\n  position: relative;\n  height: 200px; /* Example fixed height for parent */\n  width: 300px;\n  border: 1px dashed #ccc;\n}\n\n.abs-center > .child {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%); /* Shifts element back by half its width/height */\n  width: 100px;\n  height: 100px;\n  background-color: lightgreen;\n  display: flex; /* To center text inside child */\n  justify-content: center;\n  align-items: center;\n  color: white;\n  font-weight: bold;\n}\n\n/* HTML Structure:\n<div class=\"abs-center\">\n  <div class=\"child\">Absolute Item</div>\n</div> */",
          "explanation": "This classic method involves setting the parent container to `position: relative` to establish a positioning context. The child is then set to `position: absolute`, and `top: 50%` and `left: 50%` move its top-left corner to the center of the parent. The crucial `transform: translate(-50%, -50%)` then shifts the element by half its own width and height in the negative direction, precisely centering it. This method works well for elements with known or fluid dimensions and when they need to be overlaid.",
          "language": "css"
        },
        {
          "id": "example_css_centering_table",
          "title": "Centering with Display Table",
          "code": ".table-center {\n  display: table;\n  height: 200px;\n  width: 100%;\n  border: 1px dashed #ccc;\n}\n\n.table-center > .cell {\n  display: table-cell;\n  vertical-align: middle; /* vertical centering */\n  text-align: center; /* horizontal centering */\n  background-color: lightsalmon;\n  color: white;\n  font-weight: bold;\n}\n\n/* HTML Structure:\n<div class=\"table-center\">\n  <div class=\"cell\">Table Cell Item</div>\n</div> */",
          "explanation": "This method mimics HTML table behavior. The parent is set to `display: table` and the child (the element to be centered) is set to `display: table-cell`. `vertical-align: middle` then vertically aligns the content within the 'cell', and `text-align: center` horizontally aligns any inline content (like text or inline-block elements) inside the 'cell'. This approach is primarily effective for centering inline content or a single block-level element acting as a table cell.",
          "language": "css"
        }
      ],
      "complexity": 6,
      "tags": [
        "CSS",
        "Layout",
        "Centering",
        "Flexbox",
        "Grid",
        "Position",
        "Table Layout",
        "UI/UX"
      ],
      "prerequisites": [
        "HTML Structure",
        "CSS Box Model",
        "Basic CSS Properties"
      ],
      "technology": "CSS3"
    },
    "tags": [
      "CSS",
      "Layout",
      "Centering",
      "Flexbox",
      "Grid",
      "Position",
      "Table Layout",
      "UI/UX"
    ],
    "prerequisites": [
      "HTML Structure",
      "CSS Box Model",
      "Basic CSS Properties"
    ]
  },
  {
    "index": 117,
    "id": "theory_css_grid",
    "type": "theory",
    "moduleId": "css3",
    "complexity": 7,
    "title": "CSS Grid Layout",
    "description": "",
    "content": {
      "id": "theory_css_grid",
      "title": "CSS Grid Layout",
      "description": "",
      "type": "theory",
      "content": "CSS Grid Layout is a powerful two-dimensional layout system for the web. It allows you to design complex responsive layouts more easily and consistently across different screen sizes. Unlike Flexbox, which is primarily a one-dimensional layout system (either row or column), CSS Grid can manage both rows and columns simultaneously, making it ideal for overall page layout or any component requiring precise alignment in both dimensions.\n\n## Key Concepts\n\n### Grid Container\nThe element on which `display: grid` is applied becomes a grid container. This container directly affects its immediate children, turning them into grid items.\n\n### Grid Items\nDirect children of the grid container become grid items. These items can then be positioned and sized within the grid structure.\n\n### Grid Tracks\nThese are the rows and columns that make up the grid. They are defined using properties like `grid-template-columns` and `grid-template-rows`.\n\n### `grid-template-columns` and `grid-template-rows`\nThese properties define the number and size of columns and rows in the grid. Values can be explicit lengths (px, em, rem), percentages, or flexible units like `fr` (fractional unit). `repeat()` function is very useful for creating multiple tracks of the same size.\n\n### `gap` (or `grid-gap`)\nThis property defines the space between grid tracks (rows and columns). It's a shorthand for `grid-row-gap` and `grid-column-gap`.\n\n### Positioning Grid Items (`grid-column`, `grid-row`)\nGrid items can be explicitly placed within the grid using these properties. They accept `line-start / line-end` values or `line-start / span N` values. `grid-column: 1 / 3` means the item starts at column line 1 and ends before column line 3 (spanning two columns). `grid-row: 2 / span 2` means it starts at row line 2 and spans 2 rows.",
      "examples": [
        {
          "id": "example_css_grid_1",
          "title": "Basic Grid Layout with Gaps",
          "code": "/* HTML Structure */\n<!-- <div class=\"container\">\n  <div class=\"item\">1</div>\n  <div class=\"item\">2</div>\n  <div class=\"item\">3</div>\n  <div class=\"item\">4</div>\n  <div class=\"item\">5</div>\n  <div class=\"item\">6</div>\n</div> -->\n\n/* CSS */\n.container {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr); /* Creates 3 equal-width columns */\n  gap: 20px; /* Adds 20px space between grid cells */\n  border: 1px solid blue;\n  padding: 10px;\n}\n\n.item {\n  background-color: lightblue;\n  border: 1px solid #ccc;\n  padding: 15px;\n  text-align: center;\n}",
          "explanation": "This example sets up a basic grid container with three equal-width columns using `repeat(3, 1fr)`. The `gap: 20px` property adds 20 pixels of space both horizontally and vertically between the grid items. The result is a flexible 3-column layout where items automatically flow into available cells.",
          "language": "css"
        },
        {
          "id": "example_css_grid_2",
          "title": "Positioning Grid Items and Spanning",
          "code": "/* HTML Structure */\n<!-- <div class=\"container-span\">\n  <div class=\"item\">1</div>\n  <div class=\"item special-item\">2 (Spans)</div>\n  <div class=\"item\">3</div>\n  <div class=\"item\">4</div>\n  <div class=\"item\">5</div>\n  <div class=\"item\">6</div>\n</div> -->\n\n/* CSS */\n.container-span {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr); /* 3 columns */\n  grid-template-rows: repeat(3, 100px); /* 3 rows, 100px height each */\n  gap: 10px;\n  border: 1px solid green;\n  padding: 10px;\n}\n\n.item {\n  background-color: lightcoral;\n  border: 1px solid #ccc;\n  padding: 15px;\n  text-align: center;\n}\n\n.special-item {\n  grid-column: 1 / 3; /* Starts at column line 1, ends before column line 3 (spans 2 columns) */\n  grid-row: 2 / span 2; /* Starts at row line 2, spans 2 rows */\n  background-color: lightgreen;\n}",
          "explanation": "This example demonstrates how to explicitly place and size a grid item. The `.special-item` uses `grid-column: 1 / 3` to occupy the first two columns (from line 1 to line 3). It also uses `grid-row: 2 / span 2` to start at row line 2 and stretch across two rows. This precise control over item placement is a key strength of CSS Grid.",
          "language": "css"
        }
      ],
      "complexity": 7,
      "tags": [
        "CSS",
        "Layout",
        "Grid",
        "Responsive Design"
      ],
      "prerequisites": [
        "HTML_structure",
        "CSS_basics"
      ],
      "technology": "CSS3"
    },
    "tags": [
      "CSS",
      "Layout",
      "Grid",
      "Responsive Design"
    ],
    "prerequisites": [
      "HTML_structure",
      "CSS_basics"
    ]
  },
  {
    "index": 118,
    "id": "theory_sass_extend_inheritance",
    "type": "theory",
    "moduleId": "sass",
    "complexity": 5,
    "title": "SASS Extend and Inheritance",
    "description": "",
    "content": {
      "id": "theory_sass_extend_inheritance",
      "title": "SASS Extend and Inheritance",
      "description": "",
      "type": "theory",
      "content": "SASS's `@extend` directive allows a selector to inherit the styles of another selector, promoting code reuse and maintaining the DRY (Don't Repeat Yourself) principle. This is particularly useful for creating variations of components that share a common base style.\n\n## Key Concepts\n\n-   **`@extend` Directive**: Used to share a set of CSS properties from one selector to another. When `@extend` is used, SASS generates a combined selector in the compiled CSS, ensuring that the extending selector (e.g., `.primary-button`) shares the rules of the extended selector (e.g., `%button-base`).\n\n-   **Placeholder Selectors (`%`)**: These are special types of selectors in SASS that will not output any CSS on their own. They are designed exclusively to be `@extend`ed by other selectors. This prevents unnecessary CSS output for base styles that are only intended for inheritance.\n\n-   **Benefits**: \n    -   **DRY Code**: Reduces repetition by allowing shared styles to be defined once.\n    -   **Semantic Markup**: You can use meaningful class names in your HTML (e.g., `.primary-button`) while abstracting common styles into SASS extendable definitions.\n    -   **Maintainability**: Changes to the base style propagate automatically to all extending selectors.\n\n-   **Potential Drawbacks**: \n    -   **Output Bloat**: Overuse or improper use of `@extend` can sometimes lead to very long, comma-separated selectors in the compiled CSS, increasing file size and potentially making the CSS harder to read.\n    -   **Specificity Issues**: If not carefully managed, extending selectors with different specificities can lead to unexpected cascade behavior.\n    -   **Source Order Issues**: The order of `@extend` directives can sometimes affect the compiled output if rules are overridden.\n\nWhen `primary-button` extends `button-base`, SASS includes the styles from `button-base` directly into the `primary-button`'s ruleset in the compiled CSS, usually by grouping selectors.",
      "examples": [
        {
          "id": "example_sass_extend_1",
          "title": "Basic SASS Extend with Placeholder",
          "code": "```scss\n// Define a base button style using a placeholder selector\n%button-base {\n  padding: 10px 20px;\n  border: none;\n  cursor: pointer;\n  font-family: sans-serif;\n  border-radius: 4px;\n}\n\n// Extend the base style for a primary button\n.primary-button {\n  @extend %button-base;\n  background-color: #007bff;\n  color: white;\n}\n\n// Extend the base style for a secondary button\n.secondary-button {\n  @extend %button-base;\n  background-color: #6c757d;\n  color: white;\n}\n```\n\n**Compiled CSS Output:**\n\n```css\n.primary-button, .secondary-button {\n  padding: 10px 20px;\n  border: none;\n  cursor: pointer;\n  font-family: sans-serif;\n  border-radius: 4px;\n}\n\n.primary-button {\n  background-color: #007bff;\n  color: white;\n}\n\n.secondary-button {\n  background-color: #6c757d;\n  color: white;\n}\n```",
          "explanation": "This example demonstrates how `%button-base` defines a set of common styles. Both `.primary-button` and `.secondary-button` use `@extend %button-base` to inherit these styles. In the compiled CSS, SASS groups the selectors that extend the same placeholder, reducing redundant code. This approach ensures that changes to `%button-base` automatically apply to all buttons extending it, promoting consistency and easier maintenance.",
          "language": "scss"
        }
      ],
      "complexity": 5,
      "tags": [
        "SASS",
        "CSS Preprocessors",
        "Extend",
        "Inheritance",
        "Styling",
        "DRY"
      ],
      "prerequisites": [
        "CSS Fundamentals",
        "Basic SASS Syntax"
      ],
      "technology": "SASS"
    },
    "tags": [
      "SASS",
      "CSS Preprocessors",
      "Extend",
      "Inheritance",
      "Styling",
      "DRY"
    ],
    "prerequisites": [
      "CSS Fundamentals",
      "Basic SASS Syntax"
    ]
  },
  {
    "index": 120,
    "id": "theory_bundle_analyzer_plugin",
    "type": "theory",
    "moduleId": "webpack",
    "complexity": 5,
    "title": "Webpack Bundle Analyzer Plugin",
    "description": "",
    "content": {
      "id": "theory_bundle_analyzer_plugin",
      "title": "Webpack Bundle Analyzer Plugin",
      "description": "",
      "type": "theory",
      "content": "The Webpack Bundle Analyzer is a powerful tool for visualizing the size of webpack output files with an interactive treemap. It helps developers understand what makes up the bundle size, identify large modules or dependencies, and pinpoint areas for optimization.\n\n## Key Concepts\n*   **Bundle Visualization:** Provides a graphical representation of your webpack bundle, showing the size of each module and dependency.\n*   **Interactive Treemap:** Allows for detailed exploration of bundle content, enabling drill-down into specific sections.\n*   **Optimization Insights:** Helps in identifying duplicate modules, large libraries, or unused code that might be contributing to a bloated bundle.\n\n## Installation\n```bash\nnpm install --save-dev webpack-bundle-analyzer\n```\n\n## Usage\nTo use the plugin, import it and add it to the `plugins` array in your `webpack.config.js` file, typically within the `plugins` section of your configuration.\n\n```javascript\n// webpack.config.js\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  // ... other webpack configurations\n  plugins: [\n    new BundleAnalyzerPlugin() // Add the plugin here\n  ]\n};\n```\n\nWhen webpack runs with this plugin, it will open a browser window displaying the treemap visualization of your build output.",
      "examples": [
        {
          "id": "example_bundle_analyzer_1",
          "title": "Basic Webpack Configuration with Bundle Analyzer",
          "code": "const path = require('path');\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n  },\n  plugins: [\n    new BundleAnalyzerPlugin({\n      analyzerMode: 'static', // Generates a static HTML file instead of starting a server\n      openAnalyzer: false,    // Prevents opening browser automatically\n      reportFilename: 'bundle-report.html' // Custom report file name\n    })\n  ]\n};\n",
          "explanation": "This example shows a basic webpack configuration for a production build, integrating the `BundleAnalyzerPlugin`. The `analyzerMode` is set to 'static' to generate an HTML report file, and `openAnalyzer` is set to `false` to prevent the browser from automatically opening. This setup is useful for CI/CD environments or when you want to review the report later.",
          "language": "javascript"
        }
      ],
      "complexity": 5,
      "tags": [
        "webpack",
        "bundle-optimization",
        "tooling",
        "performance"
      ],
      "prerequisites": [
        "webpack_basics",
        "javascript_modules"
      ],
      "technology": "Webpack"
    },
    "tags": [
      "webpack",
      "bundle-optimization",
      "tooling",
      "performance"
    ],
    "prerequisites": [
      "webpack_basics",
      "javascript_modules"
    ]
  },
  {
    "index": 121,
    "id": "theory_deployment_checklist",
    "type": "theory",
    "moduleId": "web performance",
    "complexity": 7,
    "title": "Deployment Checklist for Frontend Applications",
    "description": "",
    "content": {
      "id": "theory_deployment_checklist",
      "title": "Deployment Checklist for Frontend Applications",
      "description": "",
      "type": "theory",
      "content": "Optimizing a frontend application for production involves several crucial steps to ensure speed, efficiency, and reliability. This deployment checklist covers key areas to improve user experience and reduce operational costs.\n\n## Key Concepts\n- **Bundle Minification**: Reduces the size of JavaScript and CSS files by removing unnecessary characters like whitespace, comments, and shorting variable names without changing their functionality. This speeds up download times.\n- **Tree Shaking**: A form of dead code elimination. It removes unused code from the final bundle, especially effective with ES modules, further reducing bundle size.\n- **Code Splitting**: Divides the application's code into smaller, on-demand chunks. This allows the browser to load only the necessary code for a given view or feature, improving initial load times.\n- **Cache Optimizations**: Uses techniques like content hashing (adding a hash of the file's content to its filename) to enable aggressive caching by browsers and CDNs. When content changes, the hash changes, invalidating the old cache and ensuring users get the latest version.\n- **Gzip Compression**: A data compression method that significantly reduces the size of text-based assets (HTML, CSS, JavaScript) before they are sent from the server to the client. The browser then decompresses them.\n- **Image Optimization**: Involves compressing images to reduce file size without significant loss of quality, and serving them in modern formats (like WebP) or at appropriate resolutions. This is critical as images often contribute most to page weight.\n- **Critical CSS**: Extracts and inlines the minimum CSS required for the 'above-the-fold' content (what's visible without scrolling) directly into the HTML. This allows the browser to render the initial view faster, preventing a flash of unstyled content (FOUC).\n- **Service Workers**: Scripts that run in the background, separate from the web page, enabling features like offline capabilities, push notifications, and advanced caching strategies. They act as a proxy between the browser and the network.\n- **CDN Usage (Content Delivery Network)**: A geographically distributed network of servers that caches static assets (images, CSS, JS) closer to users. This reduces latency and improves loading speeds by serving content from the nearest server.\n- **Error Monitoring**: Implementing production error logging and reporting tools to proactively identify and fix issues that users encounter, improving the application's reliability and stability.\n\nThese techniques collectively aim to reduce load times, improve interactivity, and enhance the overall performance and user experience of a web application.",
      "examples": [
        {
          "id": "example_minification_1",
          "title": "Minification Example",
          "code": "// Original JavaScript\nfunction calculateSum(a, b) {\n  // This function calculates the sum of two numbers\n  const result = a + b;\n  return result;\n}\n\n// Minified JavaScript\nfunction calculateSum(a,b){const result=a+b;return result;}",
          "explanation": "This example shows how minification removes whitespace, comments, and shortens variable names (though `result` here is too simple for a major change) to reduce file size without altering functionality.",
          "language": "javascript"
        },
        {
          "id": "example_gzip_1",
          "title": "Gzip Compression (Conceptual)",
          "code": "/* \n  Server-side configuration for Gzip (e.g., in Nginx)\n  \n  gzip on;\n  gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\n  gzip_comp_level 6;\n  gzip_min_length 1000;\n*/\n\n// Browser receives compressed content and decompresses it automatically.",
          "explanation": "While Gzip is a server-side configuration, this snippet conceptually shows how a server (like Nginx) is configured to compress specific text-based file types to reduce their transfer size.",
          "language": "nginx"
        }
      ],
      "complexity": 7,
      "tags": [
        "performance",
        "deployment",
        "optimization",
        "build-process",
        "web-essentials"
      ],
      "prerequisites": [
        "javascript_basics",
        "css_basics",
        "http_protocol"
      ],
      "technology": "Web Performance"
    },
    "tags": [
      "performance",
      "deployment",
      "optimization",
      "build-process",
      "web-essentials"
    ],
    "prerequisites": [
      "javascript_basics",
      "css_basics",
      "http_protocol"
    ]
  },
  {
    "index": 124,
    "id": "theory_npm_basics",
    "type": "theory",
    "moduleId": "node.js, npm",
    "complexity": 4,
    "title": "NPM Basics: Project Initialization, Dependency Management, and Script Execution",
    "description": "",
    "content": {
      "id": "theory_npm_basics",
      "title": "NPM Basics: Project Initialization, Dependency Management, and Script Execution",
      "description": "",
      "type": "theory",
      "content": "NPM (Node Package Manager) is the default package manager for Node.js. It allows developers to share and reuse code, manage project dependencies, and automate various development tasks via scripts defined in `package.json`.\n\n## Key Concepts\n\n### Project Initialization (`npm init`)\n`npm init` is used to create a new `package.json` file in your project directory. This file is a manifest for your project, containing metadata such as the project's name, version, description, entry point, test commands, and most importantly, dependencies.\n\nRunning `npm init` interactively prompts you to enter various details about your project, creating a `package.json` based on your input. You can also use `npm init -y` or `npm init --yes` to quickly generate a default `package.json` without prompts.\n\n### Installing Dependencies (`npm install`)\n`npm install <package-name>` adds a specified package to your project's `node_modules` directory and updates the `dependencies` section in your `package.json` file. These dependencies are typically required for your application to run in production.\n\n`npm install <package-name> --save-dev` (or `-D`) adds a package as a development dependency. These packages are only needed during the development process (e.g., testing frameworks, build tools, linters) and are not required for the application to run in production. They are listed under the `devDependencies` section in `package.json`.\n\nRunning `npm install` without any package name in a directory containing a `package.json` file will install all dependencies (both `dependencies` and `devDependencies`) listed in that file.\n\n### Running Scripts (`npm run`)\n`npm run <script-name>` executes custom scripts defined in the `scripts` section of your `package.json` file. This is a powerful feature for automating common tasks like starting a development server, compiling code, running tests, or building production assets.\n\nFor example, if you have a `\"start\": \"node server.js\"` script defined, running `npm run start` will execute `node server.js`. Some common scripts like `start`, `test`, `build`, `dev` can often be run without `run`, e.g., `npm start`.\n\n### `node_modules` Directory\nWhen you install packages, NPM places them in a `node_modules` directory at the root of your project. This directory typically contains all installed packages and their respective dependencies. It is usually excluded from version control (e.g., using `.gitignore`) because it can become very large, and its contents can be recreated by running `npm install` based on `package.json` and `package-lock.json`.\n\n### `package-lock.json`\nThis file is automatically generated by NPM and records the exact versions of all packages installed in `node_modules`, including nested dependencies. Its purpose is to ensure that subsequent installations (e.g., by other developers on the team or in a CI/CD pipeline) use the exact same dependency tree, preventing potential issues caused by dependency version drift.",
      "examples": [
        {
          "id": "example_npm_init",
          "title": "Initializing a Project",
          "code": "npm init -y",
          "explanation": "This command quickly initializes a new Node.js project and creates a `package.json` file with default values, skipping the interactive prompts. It's often used for quick setups or when default values are acceptable."
        },
        {
          "id": "example_npm_install_deps",
          "title": "Installing Dependencies",
          "code": "npm install express\nnpm install webpack --save-dev",
          "explanation": "The first command installs 'express' as a regular dependency (required for runtime). The second command installs 'webpack' as a development dependency (only needed for building, not runtime). Both will be added to `package.json` and `node_modules`."
        },
        {
          "id": "example_npm_run_script",
          "title": "Running a Custom Script",
          "code": "// package.json\n{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"node app.js\",\n    \"build\": \"webpack --config webpack.prod.js\"\n  }\n}\n\n// Command to run:\nnpm run start\nnpm run build",
          "explanation": "This demonstrates how to define and execute custom scripts. `npm run start` will execute `node app.js` and `npm run build` will execute `webpack --config webpack.prod.js`. This centralizes common commands."
        }
      ],
      "complexity": 4,
      "tags": [
        "NPM",
        "Package Manager",
        "Node.js",
        "Dependencies",
        "DevOps",
        "Frontend Build Tools"
      ],
      "prerequisites": [
        "Basic understanding of command line",
        "Node.js environment setup"
      ],
      "technology": "Node.js, NPM"
    },
    "tags": [
      "NPM",
      "Package Manager",
      "Node.js",
      "Dependencies",
      "DevOps",
      "Frontend Build Tools"
    ],
    "prerequisites": [
      "Basic understanding of command line",
      "Node.js environment setup"
    ]
  },
  {
    "index": 127,
    "id": "theory_pwa_manifest",
    "type": "theory",
    "moduleId": "web",
    "complexity": 4,
    "title": "Progressive Web App (PWA) Web App Manifest",
    "description": "",
    "content": {
      "id": "theory_pwa_manifest",
      "title": "Progressive Web App (PWA) Web App Manifest",
      "description": "",
      "type": "theory",
      "content": "The Web App Manifest is a JSON file that provides information about a web application to the browser and the operating system. It allows PWAs to be installed on a user's device and provides a native-app-like experience by controlling how the app appears to the user and defining its launch characteristics. It defines properties like the app's name, icons, start URL, display mode, theme colors, and orientation.\n\n## Key Manifest Fields\n\n*   **`description`**: A general description of the web application. This is used in app stores or installation prompts.\n*   **`start_url`**: Defines the URL that loads when the user launches the application from their home screen, desktop, or other application launchers. It should be a URL relative to the manifest's URL.\n*   **`display`**: Specifies the preferred display mode for the web application. Common values include:\n    *   `standalone`: The application will look and feel like a standalone application. It will open in its own window, separate from the browser, hiding typical browser UI elements like the URL bar.\n    *   `fullscreen`: The application will open completely full screen, taking up the entire display without any browser UI.\n    *   `minimal-ui`: Similar to `standalone`, but provides a minimal set of browser UI (e.g., a back button, URL bar, or refresh button on some platforms).\n    *   `browser`: The application opens in a regular browser tab or window, just like a standard website.\n*   **`background_color`**: Defines the placeholder background color for the application. This color is used when the web app is first launched before its stylesheet is loaded, providing a smooth transition.\n*   **`theme_color`**: Defines the default theme color for the application. This color can influence the color of the browser's UI elements (like the address bar or task switcher) when the PWA is running, providing a more integrated look.\n*   **`icons`**: An array of objects specifying icons for the application. These icons are used on the home screen, app launcher, task switcher, and splash screen. Each icon object requires:\n    *   `src`: The path to the icon image file.\n    *   `sizes`: The pixel dimensions of the icon (e.g., \"192x192\"). Multiple sizes are needed for different device resolutions.\n    *   `type`: The MIME type of the icon image (e.g., \"image/png\").\n\n## Importance\nThe Web App Manifest is crucial for making a web application installable and providing a native-like experience. It's one of the core components that enables a website to become a Progressive Web App.",
      "examples": [
        {
          "id": "example_pwa_manifest_1",
          "title": "Basic Web App Manifest JSON",
          "code": "{\n  \"name\": \"My Awesome PWA\",\n  \"short_name\": \"PWA\",\n  \"description\": \"A simple Progressive Web App for learning.\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#ffffff\",\n  \"theme_color\": \"#000000\",\n  \"icons\": [\n    {\n      \"src\": \"icon-192x192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"icon-512x512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\"\n    }\n  ]\n}",
          "explanation": "This JSON snippet illustrates a typical `manifest.json` file. It defines the application's basic metadata, how it should be displayed when launched from the home screen, and the icons used for various purposes across the operating system.",
          "language": "json"
        }
      ],
      "complexity": 4,
      "tags": [
        "PWA",
        "Web App Manifest",
        "Frontend Fundamentals",
        "Web Development"
      ],
      "prerequisites": [
        "HTML",
        "CSS",
        "JSON"
      ],
      "technology": "Web"
    },
    "tags": [
      "PWA",
      "Web App Manifest",
      "Frontend Fundamentals",
      "Web Development"
    ],
    "prerequisites": [
      "HTML",
      "CSS",
      "JSON"
    ]
  },
  {
    "index": 162,
    "id": "theory_sop_cors",
    "type": "theory",
    "moduleId": "web",
    "complexity": 7,
    "title": "Same-Origin Policy (SOP) and Cross-Origin Resource Sharing (CORS)",
    "description": "",
    "content": {
      "id": "theory_sop_cors",
      "title": "Same-Origin Policy (SOP) and Cross-Origin Resource Sharing (CORS)",
      "description": "",
      "type": "theory",
      "content": "The **Same-Origin Policy (SOP)** is a fundamental security mechanism in web browsers that restricts how documents or scripts loaded from one origin can interact with resources from another origin. An 'origin' is defined by the combination of protocol, host, and port. For example, `http://example.com:80/page` has the origin `http://example.com:80`.\n\n## Key Restrictions Imposed by SOP\n- **Cross-origin reads**: Scripts from one origin cannot directly read data from responses originating from another origin via `XMLHttpRequest` or `Fetch` API calls, unless explicitly allowed by CORS headers.\n- **Cross-origin writes**: While typically allowed (e.g., form submissions, redirects, `<img>` tags, `<script>` tags), the browser still enforces the same-origin policy on the data returned from such requests.\n- **Cross-origin embedding**: Embedding resources (like images, CSS, scripts) is generally allowed, but a script from `http://example.com` cannot directly read data from `http://api.another.com`.\n- **Specific APIs**: Access to certain browser APIs and data stores is also restricted:\n    - **Cookies**: Typically scoped to an origin, meaning cookies set by `example.com` cannot be accessed by `another.com`.\n    - **LocalStorage and IndexedDB**: Data stored in `LocalStorage` and `IndexedDB` is strictly confined to its origin.\n    - **CSS `getComputedStyle` and certain Canvas operations**: Information leakage can occur if these operations are performed on cross-origin content without proper security measures.\n\n## Cross-Origin Resource Sharing (CORS)\n**CORS** is a browser mechanism that allows web servers to explicitly permit cross-origin requests. It provides a flexible way for servers to specify which origins are permitted to access their resources. This is achieved using HTTP headers:\n- **`Access-Control-Allow-Origin`**: Specifies one or more origins that are allowed to access the resource. A value of `*` allows access from any origin (less secure).\n- **Preflight Requests**: For certain types of cross-origin requests (e.g., requests with custom headers, non-GET/POST methods like PUT/DELETE, or specific MIME types), browsers send an `OPTIONS` HTTP request (a \"preflight\" request) to the server before the actual request. This preflight checks if the server is willing to accept the actual request method and headers. The server must respond to the `OPTIONS` request with appropriate CORS headers (`Access-Control-Allow-Methods`, `Access-Control-Allow-Headers`, `Access-Control-Max-Age`).\n\nBy leveraging CORS, developers can build secure web applications that interact with APIs hosted on different domains, while still maintaining the fundamental security benefits of the Same-Origin Policy.",
      "examples": [
        {
          "id": "example_sop_cors_1",
          "title": "CORS Restricted Fetch Example",
          "code": "// Client-side JavaScript (e.g., from http://example.com)\nfetch('http://api.another.com/data')\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error('Fetch error:', error));\n\n// Server-side response from http://api.another.com (without CORS headers)\n// HTTP/1.1 200 OK\n// Content-Type: application/json\n// {\"message\": \"Some data\"}\n\n// Expected browser console error on http://example.com:\n// Access to fetch at 'http://api.another.com/data' from origin 'http://example.com' \n// has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present \n// on the requested resource.",
          "explanation": "This example demonstrates a common CORS error. A `fetch` request from `http://example.com` to `http://api.another.com` will be blocked by the Same-Origin Policy if the `api.another.com` server does not include the `Access-Control-Allow-Origin` header in its response. The browser prevents the script from reading the cross-origin response.",
          "language": "typescript"
        },
        {
          "id": "example_sop_cors_2",
          "title": "CORS Enabled Server Response Example",
          "code": "// Server-side response from http://api.another.com (with CORS headers)\n// HTTP/1.1 200 OK\n// Access-Control-Allow-Origin: http://example.com\n// Access-Control-Allow-Methods: GET, POST\n// Access-Control-Allow-Headers: Content-Type, Authorization\n// Content-Type: application/json\n// {\"message\": \"Data allowed by CORS\"}",
          "explanation": "To allow the `fetch` request from `http://example.com` to succeed, the server at `http://api.another.com` must include the `Access-Control-Allow-Origin` header in its response, specifying `http://example.com` as an allowed origin. This header signals to the browser that the cross-origin request is permissible.",
          "language": "http"
        }
      ],
      "complexity": 7,
      "tags": [
        "security",
        "networking",
        "browser-apis",
        "http",
        "frontend-basics"
      ],
      "prerequisites": [
        "http_basics",
        "javascript_fetch_api"
      ],
      "technology": "Web"
    },
    "tags": [
      "security",
      "networking",
      "browser-apis",
      "http",
      "frontend-basics"
    ],
    "prerequisites": [
      "http_basics",
      "javascript_fetch_api"
    ]
  },
  {
    "index": 165,
    "id": "theory_web_app_production_readiness",
    "type": "theory",
    "moduleId": "web",
    "complexity": 7,
    "title": "Web Application Production Readiness: Build, Performance, Deployment, CI/CD, and Monitoring",
    "description": "",
    "content": {
      "id": "theory_web_app_production_readiness",
      "title": "Web Application Production Readiness: Build, Performance, Deployment, CI/CD, and Monitoring",
      "description": "",
      "type": "theory",
      "content": "Preparing a web application for production involves several critical steps to ensure it is optimized, performant, reliable, and maintainable. This encompasses build processes, performance enhancements, deployment strategies, continuous integration/continuous delivery (CI/CD) pipelines, and robust monitoring and logging.\n\n## 1. Production Build Optimization\nBefore deployment, the application's source code needs to be transformed into an optimized production-ready bundle. This typically involves:\n- **Building the application**: Running build commands (e.g., `npm run build` for React/Vue/Angular) to compile source code, transpile JavaScript (e.g., TypeScript/ES6+ to ES5), and bundle assets.\n- **Environment Variables**: Configuring proper environment variables (e.g., `NODE_ENV=production`) to ensure production-specific settings are applied, such as API endpoints or feature flags.\n- **Code Splitting**: Breaking down the large JavaScript bundle into smaller chunks that can be loaded on demand. This reduces the initial load time as users only download code necessary for the current view.\n- **Tree Shaking**: Eliminating dead code (unused exports) from the final bundle. This is crucial for reducing bundle size, especially when using libraries that might include features not utilized by the application.\n\n## 2. Performance Considerations\nOptimizing application performance is crucial for user experience and SEO. Key strategies include:\n- **Caching Strategies**: Implementing HTTP caching (browser-level caching via headers like `Cache-Control`, `Expires`, `ETag`, `Last-Modified`) and Service Worker caching (programmable caching enabling offline capabilities).\n- **Content Delivery Network (CDN)**: Using a CDN for static assets (images, CSS, JS bundles) to serve content from geographically distributed servers closer to the user, reducing latency.\n- **Compression**: Enabling Brotli or Gzip compression for text-based assets (HTML, CSS, JavaScript) to reduce their transfer size over the network.\n- **Image and Font Loading Optimization**: \n    - **Image Optimization**: Compressing images, using modern formats (WebP, AVIF), responsive images (`srcset`), and lazy loading.\n    - **Font Optimization**: Self-hosting fonts, preloading critical fonts, and using `font-display: swap` to prevent invisible text during font loading.\n\n## 3. Deployment Options\nChoosing the right deployment strategy depends on application complexity, scalability needs, and budget:\n- **Static Hosting**: Ideal for single-page applications (SPAs) or static sites. Services like Netlify, Vercel, and GitHub Pages offer seamless deployment, automatic SSL, and CDN integration.\n- **Container-based Deployment (Docker + Kubernetes)**: For complex, microservices-based applications requiring high scalability and fault tolerance. Docker containers package the application and its dependencies, while Kubernetes orchestrates their deployment, scaling, and management.\n- **Platform-as-a-Service (PaaS)**: Services like Heroku or AWS Amplify abstract away infrastructure management, allowing developers to focus on code. They provide environments for various programming languages, databases, and often include CI/CD features.\n- **Server with Reverse Proxy (Nginx + Node.js)**: A common setup for server-rendered applications or APIs. Nginx acts as a reverse proxy, handling incoming requests, SSL termination, load balancing, and serving static files, while forwarding dynamic requests to a Node.js (or other backend) application.\n\n## 4. CI/CD Pipeline\nA Continuous Integration/Continuous Delivery (CI/CD) pipeline automates the software delivery process, from code commit to deployment:\n- **Automated Testing**: Running unit, integration, and end-to-end tests automatically before deployment to catch bugs early.\n- **Blue-Green Deployment Strategy**: A deployment technique that minimizes downtime by running two identical production environments (Blue and Green). New releases are deployed to the inactive environment (Green), tested, and then traffic is switched to it. The old environment (Blue) is kept as a rollback option.\n- **Rollback Capabilities**: The ability to quickly revert to a previous stable version of the application in case of issues with a new deployment. This is crucial for maintaining application availability.\n\n## 5. Monitoring and Logging\nPost-deployment, continuous monitoring and logging are essential for identifying and resolving issues, understanding user behavior, and tracking performance:\n- **Error Tracking**: Tools like Sentry or LogRocket capture and report errors in real-time, providing detailed stack traces and context to aid debugging.\n- **Analytics Implementation**: Integrating analytics platforms (e.g., Google Analytics, Mixpanel) to track user interactions, traffic sources, and conversion rates.\n- **Performance Monitoring**: Using tools (e.g., Lighthouse, WebPageTest, New Relic, Datadog) to continuously monitor application performance metrics (e.g., loading times, rendering performance, API response times) in production.\n\nThese practices collectively contribute to a robust, performant, and reliable web application ready for production environments.",
      "examples": [
        {
          "id": "example_prod_build_env_vars",
          "title": "Production Environment Variables",
          "code": "// webpack.config.js (or similar build configuration)\nconst webpack = require('webpack');\n\nmodule.exports = {\n  mode: 'production',\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.env.NODE_ENV': JSON.stringify('production'),\n      'process.env.API_BASE_URL': JSON.stringify('https://api.your-prod-domain.com')\n    })\n  ]\n};",
          "explanation": "This Webpack configuration snippet demonstrates how to define `process.env.NODE_ENV` as 'production' and set a production-specific API base URL during the build process. This ensures that the application uses the correct configurations when deployed.",
          "language": "javascript"
        },
        {
          "id": "example_nginx_reverse_proxy",
          "title": "Nginx Reverse Proxy Configuration",
          "code": "# /etc/nginx/sites-available/your_app\nserver {\n    listen 80;\n    server_name your_domain.com www.your_domain.com;\n\n    location / {\n        proxy_pass http://localhost:3000; # Proxy to your Node.js app running on port 3000\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection 'upgrade';\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n    }\n\n    location /static/ {\n        alias /var/www/your_app/static/;\n        expires 30d;\n        add_header Cache-Control \"public, max-age=2592000\";\n    }\n}",
          "explanation": "This Nginx configuration sets up a reverse proxy. Requests to the root path (`/`) are forwarded to a Node.js application running on `localhost:3000`. It also includes a `location /static/` block to serve static files directly from the Nginx server with appropriate caching headers, reducing the load on the Node.js application and improving static asset delivery.",
          "language": "nginx"
        }
      ],
      "complexity": 7,
      "tags": [
        "frontend",
        "deployment",
        "performance",
        "CI/CD",
        "monitoring",
        "optimization",
        "production"
      ],
      "prerequisites": [
        "javascript_basics",
        "node_npm",
        "web_development_fundamentals"
      ],
      "technology": "Web"
    },
    "tags": [
      "frontend",
      "deployment",
      "performance",
      "CI/CD",
      "monitoring",
      "optimization",
      "production"
    ],
    "prerequisites": [
      "javascript_basics",
      "node_npm",
      "web_development_fundamentals"
    ]
  },
  {
    "index": 128,
    "id": "theory_graphql_client_operations",
    "type": "theory",
    "moduleId": "graphql",
    "complexity": 6,
    "title": "GraphQL Client: Queries and Mutations",
    "description": "",
    "content": {
      "id": "theory_graphql_client_operations",
      "title": "GraphQL Client: Queries and Mutations",
      "description": "",
      "type": "theory",
      "content": "GraphQL is a powerful query language for APIs, providing a more efficient, powerful, and flexible alternative to REST. Clients like Apollo Client (implied by the provided code using `client.query` and `client.mutate` with `gql` tag) allow frontend applications to interact with GraphQL servers.\n\n## GraphQL Queries\nQueries in GraphQL are used to fetch data from a server. They are declarative, meaning you specify exactly what data you need, and the server returns only that data, avoiding over-fetching or under-fetching issues common with REST APIs. Queries can accept variables to make them dynamic, allowing for parameterized data requests (e.g., fetching a user by ID).\n\n### Structure of a Query\nA GraphQL query specifies the operation type (`query`), an optional operation name (`GetUser`), and variables (`$id: ID!`). Inside the curly braces, you define the fields you want to retrieve, potentially nesting them for related data (e.g., `user` and its `posts`).\n\n## GraphQL Mutations\nMutations are used to modify data on the server. This includes creating, updating, or deleting records. Like queries, mutations are declarative and can accept variables for the data being sent to the server. The response of a mutation typically includes the state of the data after the operation, allowing the client to update its UI or cache accordingly.\n\n### Structure of a Mutation\nA GraphQL mutation specifies the operation type (`mutation`), an optional operation name (`CreatePost`), and variables (`$title: String!, $content: String!, $authorId: ID!`). Within the mutation, you call a server-defined mutation field (e.g., `createPost`) and specify the fields you want to receive back from the server after the operation is complete.\n\n## `gql` Tag and Client Interaction\nModern GraphQL clients often use a `gql` tag (from `graphql-tag` or similar) to parse GraphQL query strings into an Abstract Syntax Tree (AST), which the client can then send to the server. The `client.query` and `client.mutate` methods are typically asynchronous, returning Promises that resolve with the server's response.",
      "examples": [
        {
          "id": "example_graphql_query",
          "title": "GraphQL Query Example: Fetch User Data",
          "code": "import { ApolloClient, InMemoryCache, gql } from '@apollo/client';\n\nconst client = new ApolloClient({\n  uri: 'http://localhost:4000/graphql',\n  cache: new InMemoryCache(),\n});\n\nclient.query({\n  query: gql`\n    query GetUser($id: ID!) {\n      user(id: $id) {\n        id\n        name\n        email\n        posts {\n          id\n          title\n        }\n      }\n    }\n  `,\n  variables: { id: \"1\" }\n}).then(result => console.log('Query Result:', result.data))\n  .catch(error => console.error('Query Error:', error));",
          "explanation": "This example demonstrates fetching user data using a GraphQL query. The `GetUser` query specifies an `id` variable to retrieve a specific user. It asks for the user's `id`, `name`, `email`, and a list of their `posts`, including each post's `id` and `title`. The `variables` object passes the actual `id` value. The `.then()` block logs the data received from the server.",
          "language": "typescript"
        },
        {
          "id": "example_graphql_mutation",
          "title": "GraphQL Mutation Example: Create a New Post",
          "code": "import { ApolloClient, InMemoryCache, gql } from '@apollo/client';\n\nconst client = new ApolloClient({\n  uri: 'http://localhost:4000/graphql',\n  cache: new InMemoryCache(),\n});\n\nclient.mutate({\n  mutation: gql`\n    mutation CreatePost($title: String!, $content: String!, $authorId: ID!) {\n      createPost(title: $title, content: $content, authorId: $authorId) {\n        id\n        title\n      }\n    }\n  `,\n  variables: {\n    title: \"New Post From Client\",\n    content: \"This is the content of the new post.\",\n    authorId: \"1\"\n  }\n}).then(result => console.log('Mutation Result:', result.data))\n  .catch(error => console.error('Mutation Error:', error));",
          "explanation": "This example shows how to perform a mutation to create a new post. The `CreatePost` mutation defines variables for `title`, `content`, and `authorId`. The `createPost` field is called on the server, and the client requests the `id` and `title` of the newly created post back in the response. The `variables` object provides the actual data for the new post.",
          "language": "typescript"
        }
      ],
      "complexity": 6,
      "tags": [
        "GraphQL",
        "API",
        "Data Fetching",
        "Mutations",
        "Queries",
        "Apollo Client"
      ],
      "prerequisites": [
        "JavaScript_Promises",
        "HTTP_Requests",
        "Basic_API_Concepts"
      ],
      "technology": "GraphQL"
    },
    "tags": [
      "GraphQL",
      "API",
      "Data Fetching",
      "Mutations",
      "Queries",
      "Apollo Client"
    ],
    "prerequisites": [
      "JavaScript_Promises",
      "HTTP_Requests",
      "Basic_API_Concepts"
    ]
  },
  {
    "index": 136,
    "id": "theory_default_props_type_checking",
    "type": "theory",
    "moduleId": "react, javascript, flow, typescript",
    "complexity": 6,
    "title": "React Component Default Props and Type Checking with PropTypes, Flow, and TypeScript",
    "description": "",
    "content": {
      "id": "theory_default_props_type_checking",
      "title": "React Component Default Props and Type Checking with PropTypes, Flow, and TypeScript",
      "description": "",
      "type": "theory",
      "content": "## Default Props\nIn React, `defaultProps` is a way to define default values for props if they are not explicitly passed to a component. This ensures that a component always has a default value for certain props, preventing `undefined` errors and making components more robust and predictable. `defaultProps` are evaluated before the props are passed to the component's `render` method or functional component body.\n\nEven when using static type checkers like Flow (or TypeScript), `defaultProps` continue to function as expected, providing default values for omitted properties. The type checker will correctly infer the type of the prop based on the default value if the prop is optional.\n\n## Runtime Type Checking with PropTypes\n`PropTypes` is a library provided by React (formerly part of the main React package, now a separate package `prop-types`) for runtime type checking of component props. It helps in validating the data type of props passed to a component, providing warnings in the development console if props don't match the expected types. This is particularly useful for catching errors early during development.\n\nWhile `PropTypes` performs checks at runtime (meaning errors are detected when the component renders), it does not prevent the application from compiling or running if there are type mismatches. It serves as a strong development-time tool for ensuring prop consistency.\n\n## Static Type Checking with Flow and TypeScript\nFlow and TypeScript are static type checkers. This means they analyze your code *before* it runs (at compile time or during development) to find type-related errors. They offer a more robust and comprehensive approach to type safety compared to `PropTypes`.\n\n**Flow** is a static type checker for JavaScript developed by Facebook. It focuses on finding type errors in JavaScript code. It requires specific configuration to integrate into a project.\n\n**TypeScript** is a superset of JavaScript that adds static types. It compiles down to plain JavaScript. TypeScript has gained widespread adoption due to its rich tooling, strong community support, and excellent IDE integration.\n\n### Comparing PropTypes vs. Flow/TypeScript\nThe choice between runtime type checking (like `PropTypes`) and static type checking (like Flow or TypeScript) depends on project requirements, team familiarity, and the desired level of type safety.\n\n| Feature           | PropTypes               | Flow / TypeScript               |\n|-------------------|-------------------------|---------------------------------|\n| Type checking     | Runtime                 | Static (compile time/build time) |\n| Setup complexity  | Simple, just import     | Requires configuration          |\n| Error detection   | Only when component renders | Before running code             |\n| Performance impact| Small runtime cost      | No runtime cost (in production) |\n| IDE integration   | Limited                 | Strong with proper setup        |\n| Learning curve    | Gentle                  | Steeper                         |\n| Type expressiveness| Good                    | Excellent                       |\n\nMany teams now opt for TypeScript due to its broader adoption, richer ecosystem, and superior tooling compared to Flow.",
      "examples": [
        {
          "id": "example_default_props_1",
          "title": "Basic Default Props Example",
          "code": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction UserProfile(props) {\n  return (\n    <div>\n      <h2>{props.name}</h2>\n      <p>Age: {props.age}</p>\n      <p>Email: {props.contactInfo.email}</p>\n      <p>Hobbies: {props.hobbies.join(', ')}</p>\n    </div>\n  );\n}\n\nUserProfile.defaultProps = {\n  age: 25,\n  hobbies: [],\n  contactInfo: { email: 'user@example.com' }\n};\n\nUserProfile.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number,\n  hobbies: PropTypes.arrayOf(PropTypes.string),\n  contactInfo: PropTypes.shape({\n    email: PropTypes.string.isRequired\n  })\n};\n\n// Usage example (name is required, others will use default props if not provided):\n// <UserProfile name=\"Alice\" /> \n//    -> Renders Alice, Age: 25, Email: user@example.com, Hobbies: \n// <UserProfile name=\"Bob\" age={30} />\n//    -> Renders Bob, Age: 30, Email: user@example.com, Hobbies: \n// <UserProfile name=\"Charlie\" hobbies={['reading', 'hiking']} />\n//    -> Renders Charlie, Age: 25, Email: user@example.com, Hobbies: reading, hiking\n",
          "explanation": "This example demonstrates how `defaultProps` are defined and used. If `age`, `hobbies`, or `contactInfo` are not provided when `UserProfile` is used, their default values from `UserProfile.defaultProps` will be applied. It also shows `PropTypes` for runtime validation, ensuring `name` is a required string and other props conform to their expected types.",
          "language": "javascript"
        },
        {
          "id": "example_flow_type_definition",
          "title": "Conceptual Flow Type Definition for Component Props",
          "code": "// @flow\nimport * as React from 'react';\n\ntype UserProfileProps = {\n  name: string,\n  age?: number, // Optional prop\n  hobbies?: Array<string>,\n  contactInfo?: { email: string }\n};\n\nfunction UserProfile(props: UserProfileProps): React.Node {\n  const { name, age, hobbies, contactInfo } = props;\n  const defaultAge = age === undefined ? 25 : age;\n  const defaultHobbies = hobbies === undefined ? [] : hobbies;\n  const defaultContactInfo = contactInfo === undefined ? { email: 'user@example.com' } : contactInfo;\n\n  return (\n    <div>\n      <h2>{name}</h2>\n      <p>Age: {defaultAge}</p>\n      <p>Email: {defaultContactInfo.email}</p>\n      <p>Hobbies: {defaultHobbies.join(', ')}</p>\n    </div>\n  );\n}\n\nexport default UserProfile;\n",
          "explanation": "This is a conceptual example showing how Flow types might be defined for component props, including optional properties. While `defaultProps` can still be used, with static type checkers like Flow (and more commonly TypeScript), you often define default values directly within the function signature using destructuring with default assignment, or by explicitly checking for `undefined` as shown here, making the types `?` (optional) to reflect that they might not be passed. This allows the type system to catch errors if a required prop is missing or if an incorrect type is passed.",
          "language": "javascript"
        }
      ],
      "complexity": 6,
      "tags": [
        "React",
        "defaultProps",
        "PropTypes",
        "Flow",
        "TypeScript",
        "type checking",
        "static analysis",
        "runtime analysis",
        "frontend development"
      ],
      "prerequisites": [
        "react_basics",
        "javascript_es6_features"
      ],
      "technology": "React, JavaScript, Flow, TypeScript"
    },
    "tags": [
      "React",
      "defaultProps",
      "PropTypes",
      "Flow",
      "TypeScript",
      "type checking",
      "static analysis",
      "runtime analysis",
      "frontend development"
    ],
    "prerequisites": [
      "react_basics",
      "javascript_es6_features"
    ]
  },
  {
    "index": 140,
    "id": "theory_redux_form_reinitialize",
    "type": "theory",
    "moduleId": "react, redux, redux-form",
    "complexity": 7,
    "title": "Redux-Form: Dynamic Initialization and Reinitialization",
    "description": "",
    "content": {
      "id": "theory_redux_form_reinitialize",
      "title": "Redux-Form: Dynamic Initialization and Reinitialization",
      "description": "",
      "type": "theory",
      "content": "Redux-Form is a popular higher-order component (HOC) based library for managing form state in a Redux store. It handles form state, validation, submission, and more, integrating deeply with Redux.\n\n## `enableReinitialize: true`\n\nOne crucial configuration option for `redux-form` is `enableReinitialize`. When set to `true`, this flag tells `redux-form` to automatically update the form's `initialValues` whenever the `initialValues` prop provided to the `reduxForm` HOC changes. This ensures that your form fields reflect the latest data, even if it changes asynchronously after the form component has mounted.\n\n### How it Works:\n\n1.  **`initialValues` Prop:** The `initialValues` prop is typically supplied to the `reduxForm` HOC via `mapStateToProps`. It's an object where keys correspond to your form field names and values are the initial data for those fields.\n2.  **`enableReinitialize: true`:** When this option is active, `redux-form` observes changes to the `initialValues` prop. If the incoming `initialValues` are different from the current ones, the form's internal state is updated to reflect these new values.\n3.  **Use Cases:**\n    *   **Editing Existing Records:** When you load an existing user or product for editing, the `initialValues` would come from an API call. If the user navigates between different records, `enableReinitialize: true` ensures the form updates with the new record's data.\n    *   **Asynchronous Data Loading:** If form data is fetched asynchronously (e.g., after component mount), `enableReinitialize` will ensure the form fields are populated once the data arrives.\n    *   **Dynamic Form Generation:** Forms whose initial data changes based on user selection or other dynamic factors.\n\n### Key Redux-Form Props:\n\n*   **`handleSubmit`**: A function provided by `redux-form` that wraps your `onSubmit` handler. It prevents default browser submission, runs validation, and then calls your provided `onSubmit` function with the form data if validation passes.\n*   **`pristine`**: A boolean indicating if the form values are currently identical to their `initialValues`. `true` means no changes have been made.\n*   **`reset`**: A function to reset the form's values back to their `initialValues`.\n*   **`submitting`**: A boolean indicating if the form is currently in the process of submitting (e.g., after `handleSubmit` is called and before the `onSubmit` promise resolves).\n*   **`Field`**: A component provided by `redux-form` that connects an input to the Redux store. It manages the input's value, `onChange`, `onBlur`, and error states. You specify which component to render using the `component` prop (e.g., 'input', 'select', or a custom React component).",
      "examples": [
        {
          "id": "example_redux_form_reinitialize_1",
          "title": "Basic Redux-Form with enableReinitialize",
          "code": "import React from 'react';\nimport { connect } from 'react-redux';\nimport { reduxForm, Field } from 'redux-form';\n\n// A simple presentational form component\nclass UserEditFormComponent extends React.Component {\n  render() {\n    const { handleSubmit, pristine, reset, submitting } = this.props;\n    return (\n      <form onSubmit={handleSubmit}>\n        <div>\n          <label>First Name</label>\n          <div>\n            <Field name=\"firstName\" component=\"input\" type=\"text\" placeholder=\"First Name\" />\n          </div>\n        </div>\n        <div>\n          <label>Last Name</label>\n          <div>\n            <Field name=\"lastName\" component=\"input\" type=\"text\" placeholder=\"Last Name\" />\n          </div>\n        </div>\n        <div>\n          <button type=\"submit\" disabled={pristine || submitting}>Submit</button>\n          <button type=\"button\" disabled={pristine || submitting} onClick={reset}>Clear Values</button>\n        </div>\n      </form>\n    );\n  }\n}\n\n// mapStateToProps provides initialValues from Redux state\nconst mapStateToProps = (state) => ({\n  initialValues: state.user.data // Pre-populate form with this data\n});\n\n// Apply reduxForm HOC with enableReinitialize set to true\nconst UserEditFormConnected = reduxForm({\n  form: 'userEdit',\n  enableReinitialize: true // This is the key setting\n})(UserEditFormComponent);\n\n// Connect to Redux store to get user data for initialValues\nexport default connect(mapStateToProps)(UserEditFormConnected);",
          "explanation": "This example demonstrates how to set up `redux-form` with `enableReinitialize: true`. The `initialValues` prop is sourced from the Redux store via `mapStateToProps`. If `state.user.data` changes (e.g., a new user record is loaded), the form fields will automatically update to reflect the new `initialValues`. The `handleSubmit`, `pristine`, `reset`, and `submitting` props are destructured and used to manage form submission and button states.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "Redux-Form",
        "Forms",
        "State Management",
        "React",
        "Reinitialization"
      ],
      "prerequisites": [
        "Redux Basics",
        "React Components",
        "Higher-Order Components"
      ],
      "technology": "React, Redux, Redux-Form"
    },
    "tags": [
      "Redux-Form",
      "Forms",
      "State Management",
      "React",
      "Reinitialization"
    ],
    "prerequisites": [
      "Redux Basics",
      "React Components",
      "Higher-Order Components"
    ]
  },
  {
    "index": 164,
    "id": "theory_lazy_loading_images_intersection_observer",
    "type": "theory",
    "moduleId": "react, typescript, web apis",
    "complexity": 7,
    "title": "Lazy Loading Images with Intersection Observer",
    "description": "",
    "content": {
      "id": "theory_lazy_loading_images_intersection_observer",
      "title": "Lazy Loading Images with Intersection Observer",
      "description": "",
      "type": "theory",
      "content": "Lazy loading is a technique that defers the loading of non-critical resources at page load time. Instead, these resources are loaded at the moment of need. For images, this means loading them only when they are about to enter the viewport, saving bandwidth and improving initial page load performance.\n\nThe `IntersectionObserver` API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with the top-level document's viewport. It's a highly efficient way to implement lazy loading because it avoids constant polling or event listeners (like `scroll` or `resize`), which can be performance heavy.\n\n## Key Concepts\n*   **`IntersectionObserver`**: A browser API that reports when an element (target) enters or exits the viewport (or another element).\n*   **Callback function**: A function that `IntersectionObserver` executes whenever the target element crosses one of the specified thresholds.\n*   **`IntersectionObserverEntry`**: Objects passed to the callback, each describing the intersection change of one observed target.\n    *   `isIntersecting`: A boolean indicating if the target element is currently intersecting with the root.\n*   **`observer.observe(targetElement)`**: Starts observing a target element.\n*   **`observer.disconnect()`**: Stops observing all target elements for a given observer.\n*   **Placeholder Image**: A lightweight, often blurry or low-resolution image shown immediately to improve perceived performance while the actual image loads.",
      "examples": [
        {
          "id": "example_lazy_loading_image_1",
          "title": "React Component for Lazy Loading Images",
          "code": "import React, { useRef, useEffect, useState } from 'react';\n\ninterface LazyImageProps {\n  src: string;\n  placeholder: string;\n  alt: string;\n}\n\nfunction LazyImage({ src, placeholder, alt }: LazyImageProps) {\n  const imgRef = useRef<HTMLImageElement>(null);\n  const [isLoaded, setIsLoaded] = useState(false);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      (entries) => {\n        if (entries[0].isIntersecting) {\n          setIsLoaded(true);\n          observer.disconnect(); // Stop observing once loaded\n        }\n      },\n      { rootMargin: '0px 0px 50px 0px' } // Load when 50px from bottom of viewport\n    );\n\n    if (imgRef.current) {\n      observer.observe(imgRef.current);\n    }\n\n    // Clean up observer on component unmount\n    return () => {\n      if (imgRef.current) {\n        observer.unobserve(imgRef.current);\n      }\n      observer.disconnect();\n    };\n  }, []); // Empty dependency array means this effect runs once on mount\n\n  return (\n    <img\n      ref={imgRef}\n      src={isLoaded ? src : placeholder}\n      alt={alt}\n      style={{ opacity: isLoaded ? 1 : 0.5, transition: 'opacity 0.3s ease-in-out' }} // Visual transition\n    />\n  );\n}",
          "explanation": "This React component demonstrates lazy loading using `IntersectionObserver`. It takes a `src` (the actual image), `placeholder` (a low-res initial image), and `alt` text. Initially, it displays the `placeholder`. Once the `imgRef` element enters the viewport (or is within 50px of it due to `rootMargin`), `isLoaded` is set to `true`, switching the `src` to the high-resolution image. The observer is then disconnected to prevent further observations and save resources. The `useEffect` cleanup function ensures the observer is properly disconnected when the component unmounts.",
          "language": "typescript"
        }
      ],
      "complexity": 7,
      "tags": [
        "React",
        "Performance",
        "Lazy Loading",
        "IntersectionObserver",
        "Frontend",
        "Web APIs"
      ],
      "prerequisites": [
        "react_basics",
        "dom_manipulation",
        "javascript_async"
      ],
      "technology": "React, TypeScript, Web APIs"
    },
    "tags": [
      "React",
      "Performance",
      "Lazy Loading",
      "IntersectionObserver",
      "Frontend",
      "Web APIs"
    ],
    "prerequisites": [
      "react_basics",
      "dom_manipulation",
      "javascript_async"
    ]
  }
]