[
  {
    "id": "b9fbc0e9-c05e-4aff-a54a-fc9c2bd8ea8e",
    "startLine": 6300,
    "endLine": 6399,
    "processedDate": "2025-06-17T09:55:04.980Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_form_handling_class_components",
          "title": "Basic Form Handling with Class Components in React",
          "content": "In React, forms are typically handled using controlled components. A controlled component is an input form element whose value is controlled by React state. When the user types into a controlled input, their input is stored in the component's state, and then the input element's `value` prop is updated with this state. This ensures that the React state is the single source of truth for the input's value.\n\n### Key Concepts\n-   **Controlled Components**: Form elements whose values are controlled by React state. This is achieved by binding the `value` prop of the input element to a state variable and updating that state variable via an `onChange` event handler.\n-   **`state`**: An object in a class component that holds data that can change over time and affect the rendering of the component. Changes to `state` trigger a re-render.\n-   **`onChange` Event Handler**: A function attached to input elements (e.g., `<input>`, `<textarea>`, `<select>`) that fires whenever the input's value changes. It typically updates the component's state with the new input value.\n-   **`event.target.name`**: Inside an `onChange` event handler, `event.target` refers to the DOM element that triggered the event. `event.target.name` retrieves the `name` attribute of that input element, which is useful for handling multiple inputs with a single handler.\n-   **`event.target.value`**: Retrieves the current value of the input element that triggered the event.\n-   **`onSubmit` Event Handler**: A function attached to the `<form>` element that fires when the form is submitted. It's crucial to call `event.preventDefault()` inside this handler to stop the default browser behavior of reloading the page on form submission, allowing React to handle the submission logic.\n\n### Implementation\n1.  **Initialize State**: Define initial empty values for each input in the component's `state`.\n2.  **Bind Input Values**: Set the `value` prop of each input field to its corresponding state variable (e.g., `value={this.state.username}`).\n3.  **Handle Changes**: Attach an `onChange` event handler to each input. This handler updates the relevant state property using `this.setState()`. A common pattern is to use `[event.target.name]: event.target.value` to dynamically update the correct state property based on the input's `name` attribute.\n4.  **Handle Submission**: Attach an `onSubmit` event handler to the `<form>`. Inside this handler, prevent the default behavior and then access the form data from the component's state.\n\nThis pattern provides a clear and predictable way to manage form data in React applications, making it easier to implement validation and handle data flow.",
          "examples": [
            {
              "id": "example_form_handling_1",
              "title": "Basic Login Form with Class Component",
              "code": "import React, { Component } from 'react';\n\nclass LoginForm extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      username: '',\n      password: ''\n    };\n    this.handleInputChange = this.handleInputChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleInputChange(event) {\n    const { name, value } = event.target;\n    this.setState({\n      [name]: value\n    });\n  }\n\n  handleSubmit(event) {\n    event.preventDefault();\n    console.log('Login Submitted:', this.state);\n    // Here you would typically send data to a backend or perform validation\n    alert(`Submitting username: ${this.state.username}, password: ${this.state.password}`);\n    // Optionally clear form or redirect\n    this.setState({\n        username: '',\n        password: ''\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>Login Form</h2>\n        <form onSubmit={this.handleSubmit}>\n          <div>\n            <label>Username:</label>\n            <input\n              type=\"text\"\n              name=\"username\"\n              value={this.state.username}\n              onChange={this.handleInputChange}\n            />\n          </div>\n          <div>\n            <label>Password:</label>\n            <input\n              type=\"password\"\n              name=\"password\"\n              value={this.state.password}\n              onChange={this.handleInputChange}\n            />\n          </div>\n          <button type=\"submit\">Login</button>\n        </form>\n      </div>\n    );\n  }\n}\n\nexport default LoginForm;\n",
              "explanation": "This example demonstrates a basic controlled login form implemented using a React class component. The `state` holds the `username` and `password`. The `handleInputChange` method dynamically updates the state based on the input's `name` attribute, making it reusable for multiple inputs. The `handleSubmit` method prevents the default form submission behavior and logs the current state, simulating a login action. After submission, the form fields are cleared by resetting the state.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_form_mcq_1",
            "question_form_open_1",
            "question_form_code_1",
            "question_form_flashcard_1"
          ],
          "relatedTasks": [
            "task_controlled_form_validation"
          ],
          "tags": [
            "React",
            "Forms",
            "Class Components",
            "State Management",
            "Controlled Components"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "javascript_es6"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_state_management",
            "react_hooks_forms"
          ]
        },
        {
          "id": "theory_react_router_core_concepts",
          "title": "React Router: Core Concepts and Components",
          "content": "React Router is a powerful, declarative routing library for React applications. It enables the creation of Single Page Applications (SPAs) where navigation between different views happens without full page reloads, providing a smooth user experience. It achieves this by synchronizing the UI with the URL in the browser.\n\n### Key Concepts\n-   **Client-Side Routing**: Instead of the server handling navigation requests and returning new HTML pages, the browser's JavaScript updates the content dynamically based on the URL.\n-   **Declarative Routing**: React Router components allow you to define routes and navigation links directly within your React component tree, making routing logic easy to understand and maintain.\n-   **`BrowserRouter`**: This is the recommended router for web applications. It uses the HTML5 history API (pushState, replaceState, popState) to keep your UI in sync with the URL. You should typically wrap your entire application or the part of your application that needs routing within a `<BrowserRouter>` component. This provides the context for all other React Router components.\n\n    ![React Router Provider](images/react_router_provider.png)\n\n-   **`Route`**: The `<Route>` component is responsible for rendering UI when its `path` prop matches the current URL. If the `path` matches, the component specified by the `component` prop (or `render`/`children` props) is rendered. It can also accept a `exact` prop to ensure that the path matches exactly, preventing partial matches.\n-   **`Switch`**: The `<Switch>` component renders only the *first* child `<Route>` or `<Redirect>` that matches the current location. This is crucial for ensuring that only one route is rendered at a time, especially when you have multiple routes that might partially match.\n-   **`Link`**: The `<Link>` component provides declarative navigation within your application. When clicked, it changes the URL without causing a full page refresh. It renders an `<a>` tag in the DOM.\n-   **`NavLink`**: A special version of `Link` that can automatically apply an `active` class or style to itself when its `to` prop matches the current URL. This is commonly used for navigation menus to highlight the active page.\n-   **`Redirect`**: The `<Redirect>` component allows you to programmatically navigate to a new location. When rendered, it navigates the user to the URL specified in its `to` prop. This is useful for handling authentication, 404 pages, or directing users after an action.\n-   **Hooks (`useHistory`/`useLocation`/`useParams`)**: React Router provides hooks for functional components to access router state and methods. \n    -   `useHistory`: Gives you access to the `history` instance, which can be used to navigate programmatically (`history.push('/new-path')`, `history.goBack()`).\n    -   `useLocation`: Returns the current `location` object, which contains information about the current URL (pathname, search, hash, state).\n    -   `useParams`: Extracts parameters from the URL defined in the `Route` path (e.g., `/users/:userId`).\n\n    ![React Router Diagram](images/react_router.png)\n\nThese core components and hooks form the foundation for building robust and intuitive navigation in React applications.",
          "examples": [
            {
              "id": "example_react_router_basic",
              "title": "Basic React Router Setup",
              "code": "import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link, NavLink } from 'react-router-dom';\n\nconst Home = () => <h2>Home Page</h2>;\nconst About = () => <h2>About Us</h2>;\nconst Contact = () => <h2>Contact Info</h2>;\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <nav>\n        <ul>\n          <li>\n            <Link to=\"/\">Home (Link)</Link>\n          </li>\n          <li>\n            <NavLink to=\"/about\" activeClassName=\"active-link\">\n              About (NavLink)\n            </NavLink>\n          </li>\n          <li>\n            <Link to=\"/contact\">Contact (Link)</Link>\n          </li>\n        </ul>\n      </nav>\n\n      <Switch>\n        <Route path=\"/about\">\n          <About />\n        </Route>\n        <Route path=\"/contact\">\n          <Contact />\n        </Route>\n        <Route path=\"/\">\n          <Home />\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppRouter;\n",
              "explanation": "This example sets up a basic React Router application. `BrowserRouter` wraps the entire application, providing routing context. `Link` and `NavLink` are used for navigation, with `NavLink` demonstrating the `activeClassName` feature. `Switch` ensures that only one `Route` is rendered at a time. The `Route` components define paths and render the corresponding functional components (`Home`, `About`, `Contact`). Note that the home route (`/`) is placed last in `Switch` to prevent it from matching all paths partially.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_router_mcq_1",
            "question_router_open_1",
            "question_router_flashcard_1",
            "question_router_mcq_2",
            "question_router_mcq_3"
          ],
          "relatedTasks": [
            "task_basic_react_router_setup"
          ],
          "tags": [
            "React Router",
            "Routing",
            "SPA",
            "BrowserRouter",
            "Route",
            "Switch",
            "Link",
            "NavLink",
            "Redirect",
            "Hooks"
          ],
          "technology": "React",
          "prerequisites": [
            "react_component_lifecycle",
            "javascript_dom_events"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_advanced_routing",
            "single_page_applications"
          ]
        },
        {
          "id": "theory_react_router_parameters_hooks",
          "title": "React Router: Route Parameters and Hooks",
          "content": "React Router allows you to define dynamic segments in your URLs, known as route parameters. These parameters are placeholders in the path that can capture values from the URL, enabling you to render different content based on parts of the URL. This is essential for displaying specific data, like a user profile based on a user ID.\n\n### Key Concepts\n-   **Dynamic Segments**: Defined in the `Route` path using a colon (`:`) followed by the parameter name (e.g., `/users/:userId`). This tells React Router to match any value at that position in the URL and make it available as a parameter.\n-   **Accessing Parameters (Old/Class Components)**: In older React Router versions or class components, parameters were accessed via the `match` prop passed to the routed component. `match.params` is an object containing key-value pairs of the dynamic segments.\n-   **`useParams()` Hook (Modern/Functional Components)**: For functional components (React Router v5+), the `useParams` hook provides a more direct and cleaner way to access route parameters. It returns an object of key/value pairs of URL parameters. It is an ideal way to access parameters in functional components.\n-   **Other Useful Hooks**: While `useParams` is for route parameters, `useHistory` and `useLocation` are other important React Router hooks:\n    -   `useHistory`: Provides access to the `history` object, which allows for programmatic navigation (e.g., `history.push('/dashboard')`, `history.goBack()`).\n    -   `useLocation`: Provides access to the `location` object, which represents the current URL and contains properties like `pathname`, `search` (query parameters), `hash`, and `state` (data passed via `history.push`).\n\nRoute parameters are crucial for creating dynamic and data-driven client-side applications, allowing components to react to different parts of the URL and fetch/display relevant information.",
          "examples": [
            {
              "id": "example_router_params_class",
              "title": "Accessing Route Parameters in Class Components (match prop)",
              "code": "import React, { Component } from 'react';\nimport { Route } from 'react-router-dom';\n\n// Route definition in App component:\n// <Route path=\"/users/:userId\" component={UserProfileClass} />\n\nclass UserProfileClass extends Component {\n  render() {\n    const { userId } = this.props.match.params;\n    return (\n      <div>\n        <h2>User Profile (Class Component)</h2>\n        <p>User ID from match.params: {userId}</p>\n      </div>\n    );\n  }\n}\n\nexport default UserProfileClass;\n",
              "explanation": "This example shows how `userId` is extracted from the `match.params` object, which is passed as a prop to the `UserProfileClass` component by React Router when the route `/users/:userId` is matched. This was the traditional way of accessing parameters in class components.",
              "language": "jsx"
            },
            {
              "id": "example_router_params_hooks",
              "title": "Accessing Route Parameters with `useParams` Hook",
              "code": "import React from 'react';\nimport { useParams, Route } from 'react-router-dom';\n\n// Route definition in App component:\n// <Route path=\"/users/:userId\" component={UserProfileFunctional} />\n\nfunction UserProfileFunctional() {\n  const { userId } = useParams();\n  return (\n    <div>\n      <h2>User Profile (Functional Component)</h2>\n      <p>User ID from useParams hook: {userId}</p>\n    </div>\n  );\n}\n\nexport default UserProfileFunctional;\n",
              "explanation": "This example demonstrates the modern and recommended way to access route parameters in functional components using the `useParams` hook. The hook directly returns an object containing the route parameters, making it more concise and easier to use.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_router_params_mcq_1",
            "question_router_params_open_1",
            "question_router_params_code_1",
            "question_router_params_flashcard_1"
          ],
          "relatedTasks": [
            "task_dynamic_user_profile"
          ],
          "tags": [
            "React Router",
            "Route Parameters",
            "Hooks",
            "useParams",
            "useHistory",
            "useLocation"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_advanced_routing",
            "data_fetching"
          ]
        },
        {
          "id": "theory_react_router_nested_routes",
          "title": "React Router: Nested Routes",
          "content": "Nested routes in React Router allow you to define routes that are relative to a parent route, creating hierarchical URLs and UI structures. This is particularly useful for complex layouts where certain sections of a page (e.g., tabs, sub-sections within a user profile) change based on a deeper URL path, without reloading the entire parent component.\n\n### Key Concepts\n-   **Hierarchical UI**: Nested routes mirror a hierarchical UI structure, where a parent component might render different child components based on sub-paths.\n-   **Relative Paths**: Inside a component rendered by a parent route, you define new `<Route>` components whose `path` props are relative to the parent's matched path.\n-   **`match.path` (Class Components)**: For class components or older functional components that receive `match` prop, `match.path` contains the matched portion of the URL path for the *current* route. It's often used to construct relative nested routes (e.g., `path={`${match.path}/posts`}`).\n-   **`useRouteMatch()` Hook (Functional Components)**: In React Router v5+, the `useRouteMatch()` hook in functional components returns an object similar to the `match` prop, including `path`, `url`, `isExact`, and `params`. `match.path` (or `url`) is crucial for building nested `Route` paths and `Link` `to` props relatively.\n\n### How it Works\nWhen a parent route (e.g., `/users/:userId`) matches, its corresponding component renders. Inside this component, you can place further `<Route>` components. These nested routes will only be considered if the URL matches their combined path with the parent's path. This enables a modular approach to building complex UIs, where each level of routing controls a specific part of the application's layout.",
          "examples": [
            {
              "id": "example_router_nested_routes_class",
              "title": "Implementing Nested Routes with `match.path` (Class Component)",
              "code": "import React from 'react';\nimport { Route, Link } from 'react-router-dom';\n\nconst UserPosts = () => <h3>User Posts View</h3>;\nconst UserPhotos = () => <h3>User Photos View</h3>;\n\n// Assume this component is rendered by a parent route like: <Route path=\"/users/:userId\" component={UserProfileNestedClass} />\nclass UserProfileNestedClass extends React.Component {\n  render() {\n    const { match } = this.props;\n    return (\n      <div>\n        <h2>User Profile (Nested Routes Class)</h2>\n        <p>Current User ID: {match.params.userId}</p>\n        <nav>\n          <ul>\n            <li>\n              <Link to={`${match.url}/posts`}>View Posts</Link>\n            </li>\n            <li>\n              <Link to={`${match.url}/photos`}>View Photos</Link>\n            </li>\n          </ul>\n        </nav>\n        \n        {/* Nested Routes */}\n        <Route path={`${match.path}/posts`} component={UserPosts} />\n        <Route path={`${match.path}/photos`} component={UserPhotos} />\n        \n        {/* A default content or redirect if no nested path matches */}\n        <Route exact path={match.path}>\n            <h3>Select a sub-section above.</h3>\n        </Route>\n      </div>\n    );\n  }\n}\n\nexport default UserProfileNestedClass;\n",
              "explanation": "This example shows a `UserProfileNestedClass` component that defines nested routes for `UserPosts` and `UserPhotos`. It uses `this.props.match.path` (or `match.url` for `Link` `to` props) to construct the paths for the nested `Route` components and `Link` components. When the URL is `/users/123/posts`, `UserPosts` will be rendered, and when it's `/users/123/photos`, `UserPhotos` will be rendered. The `exact` route for `match.path` provides default content when no specific nested route is active.",
              "language": "jsx"
            },
            {
              "id": "example_router_nested_routes_hooks",
              "title": "Implementing Nested Routes with `useRouteMatch` (Functional Component)",
              "code": "import React from 'react';\nimport { Route, Link, useParams, useRouteMatch } from 'react-router-dom';\n\nconst UserPosts = () => <h3>User Posts View</h3>;\nconst UserPhotos = () => <h3>User Photos View</h3>;\n\n// Assume this component is rendered by a parent route like: <Route path=\"/users/:userId\" component={UserProfileNestedFunctional} />\nfunction UserProfileNestedFunctional() {\n  const { userId } = useParams();\n  const { path, url } = useRouteMatch(); // For v5+, useRouteMatch provides path and url\n\n  return (\n    <div>\n      <h2>User Profile (Nested Routes Functional)</h2>\n      <p>Current User ID: {userId}</p>\n      <nav>\n        <ul>\n          <li>\n            <Link to={`${url}/posts`}>View Posts</Link>\n          </li>\n          <li>\n            <Link to={`${url}/photos`}>View Photos</Link>\n          </li>\n        </ul>\n      </nav>\n\n      {/* Nested Routes */}\n      <Route path={`${path}/posts`}>\n        <UserPosts />\n      </Route>\n      <Route path={`${path}/photos`}>\n        <UserPhotos />\n      </Route>\n\n      {/* A default content or redirect if no nested path matches */}\n      <Route exact path={path}>\n          <h3>Select a sub-section above.</h3>\n      </Route>\n    </div>\n  );\n}\n\nexport default UserProfileNestedFunctional;\n",
              "explanation": "This example uses the `useRouteMatch` hook in a functional component to get the `path` and `url` for defining nested routes and links. This approach is cleaner for functional components and provides the same functionality as `match.path` and `match.url` in class components.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_nested_routes_mcq_1",
            "question_nested_routes_open_1",
            "question_nested_routes_code_1",
            "question_nested_routes_flashcard_1"
          ],
          "relatedTasks": [
            "task_nested_user_profile_routes"
          ],
          "tags": [
            "React Router",
            "Nested Routes",
            "useRouteMatch",
            "match.path",
            "Hierarchical UI"
          ],
          "technology": "React",
          "prerequisites": [
            "react_router_parameters_hooks"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "complex_spa_architecture"
          ]
        },
        {
          "id": "theory_react_router_private_routes",
          "title": "React Router: Private Routes and Authentication",
          "content": "Private routes are a common requirement in web applications to restrict access to certain pages based on user authentication or authorization status. React Router does not inherently provide a 'private route' component out-of-the-box, but it offers the flexibility to implement this logic using a combination of its components and React's Context API or conditional rendering.\n\n### Key Concepts\n-   **Authentication Context**: A central place to manage the user's authentication state (e.g., `isLoggedIn`, `user` object) and provide functions for login and logout. React's Context API is well-suited for this, allowing state to be shared across the component tree without prop drilling.\n-   **`AuthContext.Provider`**: Makes the authentication state and functions available to all children components within its scope.\n-   **`useContext` Hook**: Allows functional components to easily consume values from a React Context, such as the `AuthContext` to check the user's login status.\n-   **Custom `PrivateRoute` Component**: This is a wrapper component that renders a standard `<Route>` component internally, but only if a user is authenticated. If the user is not authenticated, it uses the `<Redirect>` component to send them to a login page or another public route.\n-   **Conditional Rendering**: The core of a `PrivateRoute` involves conditionally rendering the protected component or a `Redirect` based on the authentication state.\n\n### Implementation Pattern\n1.  **Create an Authentication Context**: Define a Context object and an `AuthProvider` component that manages the authentication state (e.g., using `useState` for `user`). This provider will wrap your main application or routing logic.\n2.  **Implement a `PrivateRoute` Component**: This component takes the desired `component` to render when authenticated and any other `Route` props. Inside, it uses `useContext` to check the authentication status. If authenticated, it renders the provided `component` via a `Route`. If not, it renders a `Redirect` to a login page.\n3.  **Integrate with React Router**: Wrap your application with the `AuthProvider` and use your `PrivateRoute` component in place of regular `Route` for protected paths.\n\nThis pattern ensures that protected routes are inaccessible to unauthenticated users, enhancing application security and user experience by guiding users to login when necessary.",
          "examples": [
            {
              "id": "example_auth_context",
              "title": "Auth Context for Managing Authentication State",
              "code": "import { createContext, useContext, useState } from 'react';\n\n// Create a Context for authentication\nexport const AuthContext = createContext(null);\n\n// Auth Provider component to wrap the application\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null); // 'user' can be null or a user object\n\n  const login = (userData) => {\n    // In a real app, this would involve API calls, token storage etc.\n    setUser(userData || { name: 'Guest' }); // Mock user data\n    console.log('User logged in:', userData || { name: 'Guest' });\n  };\n\n  const logout = () => {\n    // In a real app, clear tokens, user session etc.\n    setUser(null);\n    console.log('User logged out.');\n  };\n\n  // The value provided to consumers of this context\n  const authContextValue = {\n    user,\n    isAuthenticated: !!user,\n    login,\n    logout\n  };\n\n  return (\n    <AuthContext.Provider value={authContextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// Custom hook to easily consume auth context\nexport const useAuth = () => useContext(AuthContext);\n",
              "explanation": "This code sets up an `AuthContext` using React's `createContext` and an `AuthProvider` component. The `AuthProvider` manages the `user` state and provides `login` and `logout` functions. The `user` state determines if a user is authenticated. The `useAuth` custom hook is provided for convenient consumption of the context in functional components. This context will be used by the `PrivateRoute` component to check authentication status.",
              "language": "typescript"
            },
            {
              "id": "example_private_route_component",
              "title": "Implementing a `PrivateRoute` Component",
              "code": "import React from 'react';\nimport { Route, Redirect } from 'react-router-dom';\nimport { useAuth } from './AuthContext'; // Assuming AuthContext is in AuthContext.js\n\n// A custom PrivateRoute component\nfunction PrivateRoute({ children, ...rest }) {\n  const { isAuthenticated } = useAuth();\n\n  return (\n    <Route\n      {...rest}\n      render={({ location }) =>\n        isAuthenticated ? (\n          children\n        ) : (\n          <Redirect\n            to={{\n              pathname: '/login',\n              state: { from: location } // Pass current location to redirect after login\n            }}\n          />\n        )\n      }\n    />\n  );\n}\n\nexport default PrivateRoute;\n",
              "explanation": "This `PrivateRoute` component is designed to wrap other components that should only be accessible to authenticated users. It uses the `useAuth` hook to check the `isAuthenticated` status. If the user is authenticated, it renders the `children` (the protected component). Otherwise, it uses `Redirect` to send the user to the `/login` page, also passing the original `location` in state, which can be used by the login page to redirect back after successful authentication. This pattern makes it easy to protect multiple routes in your application.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_private_routes_mcq_1",
            "question_private_routes_open_1",
            "question_private_routes_code_1",
            "question_private_routes_flashcard_1"
          ],
          "relatedTasks": [
            "task_implement_private_routes"
          ],
          "tags": [
            "React Router",
            "Authentication",
            "Private Routes",
            "Context API",
            "Conditional Rendering",
            "Authorization"
          ],
          "technology": "React",
          "prerequisites": [
            "react_context_api",
            "react_router_core_concepts"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "secure_spa_development"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_form_mcq_1",
          "topic": "Controlled Components in React Forms",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is the primary purpose of a controlled component in React forms?",
          "answer": "To allow React state to be the single source of truth for the input's value.",
          "options": [
            "To enable direct DOM manipulation for input values.",
            "To allow React state to be the single source of truth for the input's value.",
            "To automatically synchronize input values with the browser's local storage.",
            "To prevent any user input from being entered into the form field."
          ],
          "analysisPoints": [
            "Tests understanding of controlled component definition.",
            "Distinguishes between direct DOM manipulation and React state control.",
            "Highlights the 'single source of truth' principle in React."
          ],
          "keyConcepts": [
            "Controlled Components",
            "React State",
            "Single Source of Truth",
            "Form Handling"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles of React forms.",
            "Ability to distinguish between correct and incorrect paradigms."
          ],
          "example": "In a controlled component, the `value` prop of an input element is bound to `this.state.someValue`, and the `onChange` handler updates `this.state.someValue`. This ensures that the input's value always reflects what's in the React state.",
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "State Management"
          ],
          "prerequisites": [
            "react_basics",
            "react_state"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_form_open_1",
          "topic": "Controlled vs. Uncontrolled Components",
          "level": "medium",
          "type": "open",
          "question": "Explain the difference between controlled and uncontrolled components in React forms. When would you choose one over the other, and why are controlled components generally preferred?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Definition of controlled components (value tied to state, onChange updates state).",
            "Definition of uncontrolled components (value managed by DOM, useRef/ref to access).",
            "Pros/Cons of each (e.g., validation, instant feedback for controlled; simpler for simple forms for uncontrolled).",
            "Reasons for preference: controlled components provide more control over form data, easier validation, instant feedback, and better integration with React's data flow.",
            "Edge cases where uncontrolled might be acceptable (e.g., file inputs, very simple forms where initial value is not important)."
          ],
          "keyConcepts": [
            "Controlled Components",
            "Uncontrolled Components",
            "React Forms",
            "State Management",
            "Refs",
            "Data Flow"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of both paradigms.",
            "Ability to articulate their trade-offs.",
            "Knowledge of best practices and justifications."
          ],
          "example": "A controlled input will look like `<input value={this.state.inputVal} onChange={this.handleChange} />`. An uncontrolled input might use `<input type='file' ref={fileInputRef} />` and access `fileInputRef.current.files[0]` on submission.",
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "Uncontrolled Components",
            "State Management"
          ],
          "prerequisites": [
            "react_basics",
            "react_state",
            "react_refs"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_form_code_1",
          "topic": "Implementing a Controlled Input Field",
          "level": "medium",
          "type": "code",
          "question": "Implement a functional React component called `EmailInput` that renders a single email input field. This input should be a controlled component. The component should manage its own state for the email value and display the current email value below the input in a paragraph tag. Ensure that the `onChange` handler correctly updates the state.",
          "answer": "```javascript\nimport React, { useState } from 'react';\n\nfunction EmailInput() {\n  const [email, setEmail] = useState('');\n\n  const handleEmailChange = (event) => {\n    setEmail(event.target.value);\n  };\n\n  return (\n    <div>\n      <label htmlFor=\"email-field\">Email:</label>\n      <input\n        type=\"email\"\n        id=\"email-field\"\n        value={email}\n        onChange={handleEmailChange}\n        placeholder=\"Enter your email\"\n      />\n      <p>Current Email: {email}</p>\n    </div>\n  );\n}\n\nexport default EmailInput;\n```",
          "options": [],
          "analysisPoints": [
            "Correct usage of `useState` hook for state management.",
            "Binding `value` prop to state.",
            "Implementing `onChange` handler to update state.",
            "Accessibility considerations (e.g., `htmlFor`, `id`)."
          ],
          "keyConcepts": [
            "React Hooks",
            "useState",
            "Controlled Components",
            "Event Handling",
            "Forms"
          ],
          "evaluationCriteria": [
            "Ability to write functional React components.",
            "Correct implementation of controlled input logic.",
            "Understanding of basic state management with hooks."
          ],
          "example": null,
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "Hooks",
            "useState"
          ],
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_form_flashcard_1",
          "topic": "Controlled Component Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a 'controlled component' in React forms?",
          "answer": "An input form element whose value is controlled by React state.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Controlled Components",
            "React Forms",
            "State Management"
          ],
          "evaluationCriteria": [],
          "example": null,
          "tags": [
            "React",
            "Forms",
            "Controlled Components"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_router_mcq_1",
          "topic": "React Router Core Components",
          "level": "easy",
          "type": "mcq",
          "question": "Which React Router component is used to ensure that only the *first* matching `Route` is rendered at any given time?",
          "answer": "Switch",
          "options": [
            "BrowserRouter",
            "Link",
            "Switch",
            "Route"
          ],
          "analysisPoints": [
            "Tests knowledge of `Switch` component's primary function.",
            "Distinguishes `Switch` from other core routing components."
          ],
          "keyConcepts": [
            "React Router",
            "Switch Component",
            "Route Matching"
          ],
          "evaluationCriteria": [
            "Basic understanding of React Router components."
          ],
          "example": "```jsx\n<Switch>\n  <Route path=\"/about\">About</Route>\n  <Route path=\"/\">Home</Route> {/* Without Switch, this might also match /about */}\n</Switch>\n```",
          "tags": [
            "React Router",
            "Switch",
            "Routing"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_router_open_1",
          "topic": "Benefits of React Router",
          "level": "medium",
          "type": "open",
          "question": "Discuss the main advantages of using a client-side routing library like React Router in a Single Page Application (SPA) compared to traditional server-side rendering for navigation.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Faster navigation (no full page reload).",
            "Better user experience (smoother transitions, instant feedback).",
            "Ability to build rich, interactive UIs without server requests for every navigation.",
            "Decoupling of frontend and backend logic (API-driven).",
            "Easier state management across route changes.",
            "Supports dynamic client-side content updates.",
            "SEO challenges and solutions (e.g., server-side rendering, pre-rendering)."
          ],
          "keyConcepts": [
            "Client-Side Routing",
            "Single Page Application (SPA)",
            "User Experience (UX)",
            "Performance",
            "React Router"
          ],
          "evaluationCriteria": [
            "Understanding of SPA architecture benefits.",
            "Ability to compare client-side vs. server-side routing.",
            "Recognition of trade-offs and advanced considerations like SEO."
          ],
          "example": "Navigating from `/products` to `/products/123` in an SPA often involves only updating a small part of the DOM, without fetching a new HTML page, unlike traditional multi-page applications.",
          "tags": [
            "React Router",
            "SPA",
            "Performance",
            "UX",
            "Routing Architecture"
          ],
          "prerequisites": [
            "web_basics",
            "spa_concept"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_mcq_2",
          "topic": "Link vs NavLink",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React Router components:\n\n```jsx\nimport { Link, NavLink } from 'react-router-dom';\n\n// Component 1\n<Link to=\"/dashboard\">Dashboard</Link>\n\n// Component 2\n<NavLink to=\"/profile\" activeClassName=\"is-active\">\n  Profile\n</NavLink>\n```\n\nWhat is the primary distinguishing feature of `NavLink` compared to `Link`?",
          "answer": "`NavLink` can automatically apply styling (like an `activeClassName`) when its `to` prop matches the current URL.",
          "options": [
            "`NavLink` can only be used with functional components, while `Link` is for class components.",
            "`Link` causes a full page reload, whereas `NavLink` does not.",
            "`NavLink` automatically applies styling (like an `activeClassName`) when its `to` prop matches the current URL.",
            "`Link` supports nested routes, but `NavLink` does not."
          ],
          "analysisPoints": [
            "Tests understanding of `NavLink`'s specific styling capability.",
            "Clarifies that both are for client-side navigation without full reloads.",
            "Correctly identifies the `activeClassName` (or `activeStyle`) feature."
          ],
          "keyConcepts": [
            "React Router",
            "Link",
            "NavLink",
            "Active Styling",
            "Navigation"
          ],
          "evaluationCriteria": [
            "Ability to differentiate between similar React Router components.",
            "Knowledge of `NavLink`'s specific use case."
          ],
          "example": "If the current URL is `/profile`, the `NavLink` will have the `is-active` class applied, which can be styled via CSS to highlight the active navigation item.",
          "tags": [
            "React Router",
            "NavLink",
            "Link",
            "Navigation",
            "Styling"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_mcq_3",
          "topic": "BrowserRouter Purpose",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following best describes the role of `BrowserRouter` in a React application using React Router?",
          "answer": "It uses the HTML5 history API to keep the UI in sync with the URL, enabling client-side routing.",
          "options": [
            "It is used to define dynamic segments in the URL for route parameters.",
            "It renders only the first child Route that matches the current location.",
            "It uses the HTML5 history API to keep the UI in sync with the URL, enabling client-side routing.",
            "It provides declarative navigation around the application via standard `<a>` tags."
          ],
          "analysisPoints": [
            "Tests understanding of `BrowserRouter` as the foundational router.",
            "Distinguishes its role from `Route`, `Switch`, and `Link`.",
            "Emphasizes its reliance on the HTML5 History API."
          ],
          "keyConcepts": [
            "React Router",
            "BrowserRouter",
            "HTML5 History API",
            "Client-Side Routing",
            "SPA"
          ],
          "evaluationCriteria": [
            "Basic understanding of the core routing context provider.",
            "Ability to identify the correct mechanism for URL synchronization."
          ],
          "example": "Typically, your `App` component or the root of your routing structure will be wrapped in `<BrowserRouter>`, like `<BrowserRouter><App /></BrowserRouter>`, to enable all other router functionalities.",
          "tags": [
            "React Router",
            "BrowserRouter",
            "Routing Context"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_router_flashcard_1",
          "topic": "React Router `Redirect`",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary function of the `<Redirect>` component in React Router?",
          "answer": "To programmatically navigate the user to a new location.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Router",
            "Redirect",
            "Programmatic Navigation"
          ],
          "evaluationCriteria": [],
          "example": null,
          "tags": [
            "React Router",
            "Redirect"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_router_params_mcq_1",
          "topic": "Accessing Route Parameters with Hooks",
          "level": "medium",
          "type": "mcq",
          "question": "Given a React Router `Route` defined as `<Route path=\"/products/:productId\" component={ProductDetail} />`, which hook would you use in the `ProductDetail` functional component to access the `productId`?",
          "answer": "useParams()",
          "options": [
            "useHistory()",
            "useLocation()",
            "useParams()",
            "useRouteMatch()"
          ],
          "analysisPoints": [
            "Tests specific knowledge of React Router hooks for parameters.",
            "Differentiates `useParams` from other context-related hooks.",
            "Understands the direct purpose of `useParams`."
          ],
          "keyConcepts": [
            "React Router Hooks",
            "useParams",
            "Route Parameters",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Correct identification of the relevant hook.",
            "Understanding of hook functionalities."
          ],
          "example": "```jsx\nimport { useParams } from 'react-router-dom';\n\nfunction ProductDetail() {\n  const { productId } = useParams();\n  return <div>Product ID: {productId}</div>;\n}\n```",
          "tags": [
            "React Router",
            "Hooks",
            "useParams",
            "Route Parameters"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_params_open_1",
          "topic": "When to Use Specific React Router Hooks",
          "level": "hard",
          "type": "open",
          "question": "You are building a complex dashboard application. Describe a scenario where you would specifically choose to use `useHistory()`, `useLocation()`, and `useParams()` respectively. Provide a brief code snippet for each scenario.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Clear scenario for `useHistory` (e.g., programmatic navigation after form submission, back/forward buttons).",
            "Clear scenario for `useLocation` (e.g., reading query parameters, accessing state passed during navigation, conditional rendering based on pathname).",
            "Clear scenario for `useParams` (e.g., fetching data for a specific item, displaying dynamic user profiles).",
            "Correct example usage for each hook.",
            "Understanding of the `location` object properties (`pathname`, `search`, `hash`, `state`)."
          ],
          "keyConcepts": [
            "React Router Hooks",
            "useHistory",
            "useLocation",
            "useParams",
            "Programmatic Navigation",
            "Query Parameters",
            "Route Parameters",
            "Location Object"
          ],
          "evaluationCriteria": [
            "In-depth understanding of each hook's purpose.",
            "Ability to apply hooks to realistic scenarios.",
            "Correct code syntax for hook usage."
          ],
          "example": "```jsx\n// useHistory:\nimport { useHistory } from 'react-router-dom';\nfunction LogoutButton() {\n  const history = useHistory();\n  const handleLogout = () => { /* logout logic */ history.push('/login'); };\n  return <button onClick={handleLogout}>Logout</button>;\n}\n\n// useLocation:\nimport { useLocation } from 'react-router-dom';\nfunction SearchResults() {\n  const location = useLocation();\n  const queryParams = new URLSearchParams(location.search);\n  const query = queryParams.get('q');\n  return <div>Search results for: {query}</div>;\n}\n\n// useParams:\nimport { useParams } from 'react-router-dom';\n// Route: /books/:id\nfunction BookDetail() {\n  const { id } = useParams();\n  return <div>Details for Book ID: {id}</div>;\n}\n```",
          "tags": [
            "React Router",
            "Hooks",
            "useHistory",
            "useLocation",
            "useParams",
            "Programmatic Navigation"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_router_params_code_1",
          "topic": "Extracting Parameters from URL",
          "level": "medium",
          "type": "code",
          "question": "Write a functional React component named `CoursePage` that displays the `courseId` from the URL. Assume the `Route` for this component is defined as `/courses/:courseId`. Your component should use the appropriate React Router hook to access this parameter and display it within an `<h2>` tag.",
          "answer": "```javascript\nimport React from 'react';\nimport { useParams } from 'react-router-dom';\n\nfunction CoursePage() {\n  const { courseId } = useParams();\n\n  return (\n    <div>\n      <h2>Course ID: {courseId}</h2>\n      <p>Welcome to the detail page for this course.</p>\n    </div>\n  );\n}\n\nexport default CoursePage;\n```",
          "options": [],
          "analysisPoints": [
            "Correct import of `useParams`.",
            "Destructuring the parameter from the `useParams` hook's return value.",
            "Rendering the parameter in the component's JSX."
          ],
          "keyConcepts": [
            "React Router Hooks",
            "useParams",
            "Route Parameters",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Ability to use `useParams` correctly.",
            "Demonstrates understanding of dynamic routing segments."
          ],
          "example": null,
          "tags": [
            "React Router",
            "Hooks",
            "useParams",
            "Route Parameters"
          ],
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_params_flashcard_1",
          "topic": "useParams Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What does the `useParams()` hook in React Router return?",
          "answer": "An object of key/value pairs of URL parameters.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Router",
            "useParams",
            "Route Parameters",
            "Hooks"
          ],
          "evaluationCriteria": [],
          "example": null,
          "tags": [
            "React Router",
            "Hooks",
            "useParams"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_nested_routes_mcq_1",
          "topic": "Purpose of `match.path` / `useRouteMatch().path` in Nested Routes",
          "level": "medium",
          "type": "mcq",
          "question": "When defining nested routes within a component, why is `match.path` (or `useRouteMatch().path` for functional components) typically used to construct the paths for the child `Route` components?",
          "answer": "To ensure that the nested routes are relative to the parent route's matched path, making them work correctly within the hierarchical structure.",
          "options": [
            "To force a full page reload when navigating to a nested route.",
            "To extract query parameters from the URL for the nested component.",
            "To ensure that the nested routes are relative to the parent route's matched path, making them work correctly within the hierarchical structure.",
            "To provide a unique key for each nested route for performance optimization."
          ],
          "analysisPoints": [
            "Tests understanding of relative paths in nested routing.",
            "Explains the role of `match.path` in building hierarchical URLs.",
            "Distinguishes its purpose from other routing functionalities."
          ],
          "keyConcepts": [
            "React Router",
            "Nested Routes",
            "match.path",
            "useRouteMatch",
            "Relative Paths"
          ],
          "evaluationCriteria": [
            "Correctly identifies the function of `match.path` in nested routing.",
            "Understands the concept of relative route definitions."
          ],
          "example": "If the parent route is `/users/:userId` and `match.path` is `/users/:userId`, then a nested route `path={`${match.path}/posts`}` would resolve to `/users/:userId/posts`.",
          "tags": [
            "React Router",
            "Nested Routes",
            "match.path",
            "useRouteMatch"
          ],
          "prerequisites": [
            "react_router_core_concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_nested_routes_open_1",
          "topic": "Designing a UI with Nested Routes",
          "level": "hard",
          "type": "open",
          "question": "You are tasked with designing a user profile page that has multiple sub-sections (e.g., 'Overview', 'Settings', 'Activity Log'). How would you leverage React Router's nested routing capabilities to implement this, ensuring a clean URL structure and efficient component rendering? Outline the component structure and the routing logic.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "High-level component structure (e.g., `UserProfile` parent, `UserOverview`, `UserSettings`, `UserActivityLog` children).",
            "Parent `Route` definition (e.g., `/users/:id`).",
            "Use of `useRouteMatch` (or `match.path`) in the `UserProfile` component to define child routes.",
            "Use of `Link` or `NavLink` within `UserProfile` for sub-navigation, also using `match.url` for relative links.",
            "Consideration for a default nested route or redirect when no sub-section is selected.",
            "Benefits: modularity, performance (only re-renders sub-section), clear URLs."
          ],
          "keyConcepts": [
            "React Router",
            "Nested Routes",
            "URL Structure",
            "Component Design",
            "useRouteMatch",
            "Link/NavLink"
          ],
          "evaluationCriteria": [
            "Ability to design a multi-page UI using nested routes.",
            "Correct application of `useRouteMatch` and relative paths.",
            "Understanding of practical benefits of nested routing."
          ],
          "example": "```jsx\n// App.js\n<Route path=\"/users/:userId\">\n  <UserProfile />\n</Route>\n\n// UserProfile.js\nimport { useParams, useRouteMatch, Link, Route, Switch } from 'react-router-dom';\nfunction UserProfile() {\n  const { userId } = useParams();\n  const { path, url } = useRouteMatch();\n  return (\n    <div>\n      <h1>User: {userId}</h1>\n      <nav>\n        <Link to={`${url}`}>Overview</Link>\n        <Link to={`${url}/settings`}>Settings</Link>\n        <Link to={`${url}/activity`}>Activity Log</Link>\n      </nav>\n      <Switch>\n        <Route exact path={path} component={UserOverview} />\n        <Route path={`${path}/settings`} component={UserSettings} />\n        <Route path={`${path}/activity`} component={UserActivityLog} />\n      </Switch>\n    </div>\n  );\n}\n```",
          "tags": [
            "React Router",
            "Nested Routes",
            "Architecture",
            "Design Patterns"
          ],
          "prerequisites": [
            "react_router_parameters_hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_nested_routes_code_1",
          "topic": "Implementing Nested Routes",
          "level": "medium",
          "type": "code",
          "question": "Create a functional React component named `Dashboard` that serves as a parent for nested routes. Inside `Dashboard`, define two nested routes: `/dashboard/analytics` and `/dashboard/reports`. Each nested route should render a simple functional component (`AnalyticsPage` and `ReportsPage` respectively). Use `useRouteMatch` to correctly construct the nested paths. Include `Link` components to navigate between these sub-sections.",
          "answer": "```javascript\nimport React from 'react';\nimport { Switch, Route, Link, useRouteMatch } from 'react-router-dom';\n\nconst AnalyticsPage = () => <h3>Dashboard Analytics</h3>;\nconst ReportsPage = () => <h3>Dashboard Reports</h3>;\nconst DefaultDashboard = () => <h3>Welcome to your Dashboard! Select a section.</h3>;\n\nfunction Dashboard() {\n  const { path, url } = useRouteMatch();\n\n  return (\n    <div>\n      <h2>Main Dashboard</h2>\n      <nav>\n        <ul>\n          <li><Link to={`${url}`}>Overview</Link></li>\n          <li><Link to={`${url}/analytics`}>Analytics</Link></li>\n          <li><Link to={`${url}/reports`}>Reports</Link></li>\n        </ul>\n      </nav>\n\n      <Switch>\n        <Route exact path={path} component={DefaultDashboard} />\n        <Route path={`${path}/analytics`} component={AnalyticsPage} />\n        <Route path={`${path}/reports`} component={ReportsPage} />\n      </Switch>\n    </div>\n  );\n}\n\nexport default Dashboard;\n\n// Example usage in your main App.js:\n// <Route path=\"/dashboard\" component={Dashboard} />\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `useRouteMatch` to get `path` and `url`.",
            "Properly constructs nested `Route` paths using `path`.",
            "Correctly constructs `Link` `to` props using `url`.",
            "Uses `Switch` to ensure only one nested route renders.",
            "Includes an `exact` route for the base path to show default content."
          ],
          "keyConcepts": [
            "React Router",
            "Nested Routes",
            "useRouteMatch",
            "Link",
            "Switch",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Ability to implement nested routing.",
            "Correct application of `useRouteMatch`.",
            "Logical flow of navigation within a nested context."
          ],
          "example": null,
          "tags": [
            "React Router",
            "Nested Routes",
            "Hooks",
            "useRouteMatch",
            "Link"
          ],
          "prerequisites": [
            "react_router_parameters_hooks"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_nested_routes_flashcard_1",
          "topic": "Nested Routes `path` vs `url`",
          "level": "medium",
          "type": "flashcard",
          "question": "In React Router's `useRouteMatch()` hook, what is the difference between `path` and `url`?",
          "answer": "`path` is the string pattern used for matching (e.g., `/users/:userId`), while `url` is the actual matched URL string (e.g., `/users/123`). `path` is typically used for defining nested `<Route>` paths, and `url` for constructing `Link` `to` props.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Router",
            "useRouteMatch",
            "path",
            "url",
            "Nested Routes"
          ],
          "evaluationCriteria": [],
          "example": null,
          "tags": [
            "React Router",
            "Hooks",
            "Nested Routes"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_private_routes_mcq_1",
          "topic": "Redirecting Unauthenticated Users",
          "level": "medium",
          "type": "mcq",
          "question": "When implementing a `PrivateRoute` component in React Router, which component is typically used to send an unauthenticated user to a login page?",
          "answer": "Redirect",
          "options": [
            "Link",
            "NavLink",
            "Route",
            "Redirect"
          ],
          "analysisPoints": [
            "Tests knowledge of the `Redirect` component's programmatic navigation capability.",
            "Differentiates `Redirect` from components used for declarative navigation or route matching."
          ],
          "keyConcepts": [
            "React Router",
            "Private Routes",
            "Redirect",
            "Authentication"
          ],
          "evaluationCriteria": [
            "Correctly identifies the component for programmatic redirection.",
            "Understanding of basic private route implementation strategy."
          ],
          "example": "```jsx\n// Inside PrivateRoute component\nreturn isAuthenticated ? <Route {...rest} /> : <Redirect to=\"/login\" />;\n```",
          "tags": [
            "React Router",
            "Private Routes",
            "Redirect",
            "Authentication"
          ],
          "prerequisites": [
            "react_router_core_concepts"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_private_routes_open_1",
          "topic": "Designing a Private Route System",
          "level": "hard",
          "type": "open",
          "question": "You need to implement a private route system for an e-commerce application where `/admin` and `/checkout` paths should only be accessible to logged-in users. Describe how you would design and implement this using React Router and React's Context API. Include the role of `AuthContext`, `AuthProvider`, and a custom `PrivateRoute` component.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Explanation of `AuthContext` and `AuthProvider` for centralized auth state (`user`, `login`, `logout`).",
            "Details on the `PrivateRoute` component: accepting `children` or `component` prop, checking auth status via `useContext(AuthContext)`, and conditionally rendering `children` or `Redirect`.",
            "How `PrivateRoute` integrates with main `App` routing (wrapping specific `Route` definitions).",
            "Handling redirect with `location.state` to return to original path after login.",
            "Consideration of loading states or fallbacks."
          ],
          "keyConcepts": [
            "React Router",
            "Private Routes",
            "Authentication",
            "Context API",
            "AuthProvider",
            "PrivateRoute Component",
            "Redirect"
          ],
          "evaluationCriteria": [
            "Comprehensive design for a private routing system.",
            "Correct application of Context API and React Router components.",
            "Ability to articulate the flow of authentication and redirection.",
            "Understanding of passing location state for post-login redirects."
          ],
          "example": "```jsx\n// index.js (or App.js)\nimport { AuthProvider } from './AuthContext';\nimport AppRouter from './AppRouter';\n<AuthProvider><AppRouter /></AuthProvider>\n\n// AppRouter.js\nimport { Switch, Route } from 'react-router-dom';\nimport PrivateRoute from './PrivateRoute';\n\nconst LoginPage = () => <div>Login</div>;\nconst AdminPage = () => <div>Admin Dashboard</div>;\nconst CheckoutPage = () => <div>Checkout</div>;\n\nfunction AppRouter() {\n  return (\n    <Switch>\n      <Route path=\"/login\" component={LoginPage} />\n      <PrivateRoute path=\"/admin\" component={AdminPage} />\n      <PrivateRoute path=\"/checkout\" component={CheckoutPage} />\n      {/* ...other public routes... */}\n    </Switch>\n  );\n}\n```",
          "tags": [
            "React Router",
            "Private Routes",
            "Authentication",
            "Context API",
            "Architecture"
          ],
          "prerequisites": [
            "react_context_api",
            "react_router_core_concepts"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "expert"
        },
        {
          "id": "question_private_routes_code_1",
          "topic": "AuthContext Implementation",
          "level": "medium",
          "type": "code",
          "question": "Complete the `AuthContext` and `AuthProvider` implementation. The `AuthProvider` should manage a `user` state (initially `null`). Implement `login` and `logout` functions that update this state. The context value should expose `user`, a boolean `isAuthenticated`, and the `login`/`logout` functions. Also, provide a `useAuth` custom hook.",
          "answer": "```javascript\nimport { createContext, useContext, useState, useEffect } from 'react';\n\nexport const AuthContext = createContext(null);\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true); // Optional: for initial auth check\n\n  // Simulate an initial check for a logged-in user, e.g., from localStorage\n  useEffect(() => {\n    const storedUser = localStorage.getItem('currentUser');\n    if (storedUser) {\n      setUser(JSON.parse(storedUser));\n    }\n    setLoading(false);\n  }, []);\n\n  const login = (userData) => {\n    // In a real app, send credentials to backend, get token, set user\n    const newUser = { id: '1', name: userData.username || 'Test User' };\n    setUser(newUser);\n    localStorage.setItem('currentUser', JSON.stringify(newUser)); // Simulate persisting login\n  };\n\n  const logout = () => {\n    setUser(null);\n    localStorage.removeItem('currentUser'); // Simulate clearing session\n  };\n\n  const authContextValue = {\n    user,\n    isAuthenticated: !!user,\n    login,\n    logout,\n    loading // Useful for waiting on initial auth check\n  };\n\n  return (\n    <AuthContext.Provider value={authContextValue}>\n      {!loading ? children : <div>Loading authentication...</div>}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => useContext(AuthContext);\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `createContext` and `useContext`.",
            "Proper state management for `user` within `AuthProvider`.",
            "Implementation of `login` and `logout` functions.",
            "Exposing correct values via context provider (`user`, `isAuthenticated`, `login`, `logout`).",
            "Creation of a `useAuth` custom hook for convenience.",
            "Consideration of loading state for initial authentication check (optional but good practice)."
          ],
          "keyConcepts": [
            "React Context API",
            "createContext",
            "useContext",
            "useState",
            "Authentication",
            "AuthProvider",
            "Custom Hooks"
          ],
          "evaluationCriteria": [
            "Ability to implement Context API pattern.",
            "Correct state management and function exposure.",
            "Demonstrates understanding of authentication flow at a high level."
          ],
          "example": null,
          "tags": [
            "React",
            "Context API",
            "Authentication",
            "State Management",
            "Hooks"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_context_api"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_private_routes_flashcard_1",
          "topic": "Purpose of `AuthContext.Provider`",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the role of `AuthContext.Provider` in setting up a private routing system?",
          "answer": "It makes the authentication state and functions (like login/logout) available to all children components within its scope.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Context API",
            "AuthContext.Provider",
            "Authentication",
            "State Sharing"
          ],
          "evaluationCriteria": [],
          "example": null,
          "tags": [
            "React",
            "Context API",
            "Private Routes"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_controlled_form_validation",
          "title": "Implement a Controlled Registration Form with Basic Validation",
          "description": "\nCreate a functional React component called `RegistrationForm`. This form should include:\n\n1.  **Input Fields**: `username` (text), `email` (email type), and `password` (password type).\n2.  **Controlled Components**: All input fields must be controlled components, managing their values via `useState`.\n3.  **Basic Validation**: Implement client-side validation logic.\n    *   `username`: Must not be empty.\n    *   `email`: Must be a valid email format (simple regex check is sufficient, e.g., `@` and `.` presence).\n    *   `password`: Must be at least 6 characters long.\n4.  **Error Display**: Display appropriate error messages below each input field if validation fails when the user tries to submit the form.\n5.  **Submission Logic**: On form submission, prevent the default behavior. If all fields are valid, log the form data to the console and display a success message (e.g., an alert). If invalid, display the errors.\n6.  **Reset Form**: After successful submission, clear the form fields.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\nfunction RegistrationForm() {\n  const [formData, setFormData] = useState({\n    username: '',\n    email: '',\n    password: ''\n  });\n\n  const [errors, setErrors] = useState({});\n  const [submissionMessage, setSubmissionMessage] = useState('');\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({ ...prev, [name]: value }));\n    // Clear error for the field as user types\n    if (errors[name]) {\n        setErrors(prev => ({ ...prev, [name]: '' }));\n    }\n  };\n\n  const validateForm = () => {\n    let newErrors = {};\n    if (!formData.username.trim()) {\n      newErrors.username = 'Username is required';\n    }\n    if (!formData.email.includes('@') || !formData.email.includes('.')) {\n      newErrors.email = 'Please enter a valid email';\n    }\n    if (formData.password.length < 6) {\n      newErrors.password = 'Password must be at least 6 characters long';\n    }\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    setSubmissionMessage(''); // Clear previous messages\n\n    if (validateForm()) {\n      console.log('Form Submitted Successfully:', formData);\n      setSubmissionMessage('Registration successful!');\n      setFormData({\n        username: '',\n        email: '',\n        password: ''\n      });\n    } else {\n      setSubmissionMessage('Please correct the errors.');\n    }\n  };\n\n  return (\n    <div>\n      <h2>Register</h2>\n      <form onSubmit={handleSubmit}>\n        <div>\n          <label htmlFor=\"username\">Username:</label>\n          <input\n            type=\"text\"\n            id=\"username\"\n            name=\"username\"\n            value={formData.username}\n            onChange={handleChange}\n          />\n          {errors.username && <p style={{ color: 'red' }}>{errors.username}</p>}\n        </div>\n        <div>\n          <label htmlFor=\"email\">Email:</label>\n          <input\n            type=\"email\"\n            id=\"email\"\n            name=\"email\"\n            value={formData.email}\n            onChange={handleChange}\n          />\n          {errors.email && <p style={{ color: 'red' }}>{errors.email}</p>}\n        </div>\n        <div>\n          <label htmlFor=\"password\">Password:</label>\n          <input\n            type=\"password\"\n            id=\"password\"\n            name=\"password\"\n            value={formData.password}\n            onChange={handleChange}\n          />\n          {errors.password && <p style={{ color: 'red' }}>{errors.password}</p>}\n        </div>\n        <button type=\"submit\">Register</button>\n      </form>\n      {submissionMessage && <p style={{ color: submissionMessage.includes('successful') ? 'green' : 'orange' }}>{submissionMessage}</p>}\n    </div>\n  );\n}\n\nexport default RegistrationForm;\n",
          "solutionCode": "import React, { useState } from 'react';\n\nfunction RegistrationForm() {\n  const [formData, setFormData] = useState({\n    username: '',\n    email: '',\n    password: ''\n  });\n\n  const [errors, setErrors] = useState({});\n  const [submissionMessage, setSubmissionMessage] = useState('');\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({ ...prev, [name]: value }));\n    // Clear error for the field as user types\n    if (errors[name]) {\n        setErrors(prev => ({ ...prev, [name]: '' }));\n    }\n  };\n\n  const validateForm = () => {\n    let newErrors = {};\n    if (!formData.username.trim()) {\n      newErrors.username = 'Username is required';\n    }\n    // Simple email regex, could be more robust\n    if (!/^[\\w-.]+@([\\w-]+\\.)+[\\w-]{2,4}$/g.test(formData.email)) {\n      newErrors.email = 'Please enter a valid email address';\n    }\n    if (formData.password.length < 6) {\n      newErrors.password = 'Password must be at least 6 characters long';\n    }\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    setSubmissionMessage('');\n\n    if (validateForm()) {\n      console.log('Form Submitted Successfully:', formData);\n      setSubmissionMessage('Registration successful! Check console for data.');\n      setFormData({\n        username: '',\n        email: '',\n        password: ''\n      });\n      setErrors({}); // Clear errors on success\n    } else {\n      setSubmissionMessage('Please correct the errors before submitting.');\n    }\n  };\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '8px', maxWidth: '400px', margin: '20px auto' }}>\n      <h2>Register</h2>\n      <form onSubmit={handleSubmit}>\n        <div style={{ marginBottom: '15px' }}>\n          <label htmlFor=\"username\" style={{ display: 'block', marginBottom: '5px' }}>Username:</label>\n          <input\n            type=\"text\"\n            id=\"username\"\n            name=\"username\"\n            value={formData.username}\n            onChange={handleChange}\n            style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}\n          />\n          {errors.username && <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>{errors.username}</p>}\n        </div>\n        <div style={{ marginBottom: '15px' }}>\n          <label htmlFor=\"email\" style={{ display: 'block', marginBottom: '5px' }}>Email:</label>\n          <input\n            type=\"email\"\n            id=\"email\"\n            name=\"email\"\n            value={formData.email}\n            onChange={handleChange}\n            style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}\n          />\n          {errors.email && <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>{errors.email}</p>}\n        </div>\n        <div style={{ marginBottom: '20px' }}>\n          <label htmlFor=\"password\" style={{ display: 'block', marginBottom: '5px' }}>Password:</label>\n          <input\n            type=\"password\"\n            id=\"password\"\n            name=\"password\"\n            value={formData.password}\n            onChange={handleChange}\n            style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}\n          />\n          {errors.password && <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>{errors.password}</p>}\n        </div>\n        <button type=\"submit\" style={{ padding: '10px 15px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}>Register</button>\n      </form>\n      {submissionMessage && <p style={{ color: submissionMessage.includes('successful') ? 'green' : 'orange', marginTop: '15px' }}>{submissionMessage}</p>}\n    </div>\n  );\n}\n\nexport default RegistrationForm;\n",
          "testCases": [
            "Test 1: All fields empty - Should show all 'required' or validation error messages.",
            "Test 2: Invalid email format (e.g., 'test@' or 'test.com') - Should show 'valid email' error.",
            "Test 3: Password less than 6 chars (e.g., 'abc') - Should show 'password length' error.",
            "Test 4: All fields valid - Should log data, show success message, and clear form.",
            "Test 5: User types into a field after an error is shown - Error for that specific field should disappear as typing starts."
          ],
          "hints": [
            "Use a single `useState` object for all form data, and another for errors.",
            "The `name` attribute of input fields can be useful for dynamic state updates in a single `handleChange` function.",
            "Remember to call `event.preventDefault()` in `handleSubmit`.",
            "Consider placing validation logic in a separate function to keep `handleSubmit` clean."
          ],
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "Validation",
            "useState",
            "Event Handling"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics",
            "theory_react_form_handling_class_components"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "controlled_components",
            "form_validation",
            "state_management_hooks"
          ]
        },
        {
          "id": "task_basic_react_router_setup",
          "title": "Build a Simple SPA with React Router Navigation",
          "description": "\nCreate a React application with three main pages using React Router:\n\n1.  **Home Page (`/`)**: A simple page with a welcome message.\n2.  **About Page (`/about`)**: A page describing the application or company.\n3.  **Contact Page (`/contact`)**: A page with contact information.\n\n**Requirements:**\n*   Use `BrowserRouter` to wrap your main application components.\n*   Implement navigation using `Link` components for Home and Contact pages.\n*   Implement navigation for the About page using a `NavLink` component. Configure `NavLink` to apply an `active-link` CSS class when the About page is active.\n*   Use `Switch` to ensure only one route is rendered at a time.\n*   Ensure the Home route (`/`) is handled correctly even when other routes match partially.\n*   Create simple functional components for each page.\n",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link, NavLink } from 'react-router-dom';\n\n// Create your page components here\nconst HomePage = () => {\n  return (\n    <div>\n      <h2>Welcome Home!</h2>\n      <p>This is the home page of our simple SPA.</p>\n    </div>\n  );\n};\n\nconst AboutPage = () => {\n  return (\n    <div>\n      <h2>About Us</h2>\n      <p>Learn more about our mission and values.</p>\n    </div>\n  );\n};\n\nconst ContactPage = () => {\n  return (\n    <div>\n      <h2>Contact Us</h2>\n      <p>Reach out to us via email or phone.</p>\n    </div>\n  );\n};\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <nav>\n        <ul style={{ listStyleType: 'none', padding: 0 }}>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            {/* Implement Link for Home */}\n          </li>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            {/* Implement NavLink for About with activeClassName */}\n          </li>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            {/* Implement Link for Contact */}\n          </li>\n        </ul>\n      </nav>\n\n      {/* Implement Switch and Routes here */}\n      <div>\n\n      </div>\n    </Router>\n  );\n}\n\nexport default AppRouter;\n\n// Add some basic CSS for .active-link\n// body {\n//   font-family: sans-serif;\n// }\n// .active-link {\n//   font-weight: bold;\n//   color: blue;\n//   text-decoration: underline;\n// }\n",
          "solutionCode": "import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link, NavLink } from 'react-router-dom';\n\nconst HomePage = () => {\n  return (\n    <div>\n      <h2>Welcome Home!</h2>\n      <p>This is the home page of our simple SPA.</p>\n    </div>\n  );\n};\n\nconst AboutPage = () => {\n  return (\n    <div>\n      <h2>About Us</h2>\n      <p>Learn more about our mission and values.</p>\n    </div>\n  );\n};\n\nconst ContactPage = () => {\n  return (\n    <div>\n      <h2>Contact Us</h2>\n      <p>Reach out to us via email or phone.</p>\n    </div>\n  );\n};\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <nav>\n        <ul style={{ listStyleType: 'none', padding: 0 }}>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            <Link to=\"/\">Home</Link>\n          </li>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            <NavLink to=\"/about\" activeClassName=\"active-link\">\n              About\n            </NavLink>\n          </li>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            <Link to=\"/contact\">Contact</Link>\n          </li>\n        </ul>\n      </nav>\n\n      <div>\n        <Switch>\n          {/* Specific routes first */}\n          <Route path=\"/about\" component={AboutPage} />\n          <Route path=\"/contact\" component={ContactPage} />\n          {/* Exact home route last to avoid matching other paths partially */}\n          <Route exact path=\"/\" component={HomePage} />\n        </Switch>\n      </div>\n    </Router>\n  );\n}\n\nexport default AppRouter;\n",
          "testCases": [
            "Test 1: Navigate to '/' - Home page should be displayed, Home link should not be active (if Link is used, which it is in solution).",
            "Test 2: Navigate to '/about' - About page should be displayed, 'About' NavLink should have 'active-link' class.",
            "Test 3: Navigate to '/contact' - Contact page should be displayed.",
            "Test 4: Directly access '/invalid-path' - Should not match any of the defined routes and thus show nothing (or a 404 if implemented)."
          ],
          "hints": [
            "Remember to import all necessary components from `react-router-dom`.",
            "The `exact` prop on a `Route` is crucial for the home page to prevent it from matching other paths.",
            "For `NavLink`, the `activeClassName` prop is how you specify the class to apply."
          ],
          "tags": [
            "React Router",
            "SPA",
            "Navigation",
            "BrowserRouter",
            "Route",
            "Switch",
            "Link",
            "NavLink"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_basics",
            "theory_react_router_core_concepts"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "beginner",
          "relatedConcepts": [
            "client_side_routing",
            "declarative_navigation"
          ]
        },
        {
          "id": "task_dynamic_user_profile",
          "title": "Create a User Profile Page with Dynamic Parameters",
          "description": "\nExtend the previous React Router application (or start a new one if preferred) to include a dynamic user profile page.\n\n**Requirements:**\n*   Define a route for `/users/:userId`.\n*   Create a functional component `UserProfile` that will be rendered by this route.\n*   Inside `UserProfile`, use the `useParams` hook to extract the `userId` from the URL.\n*   Display the `userId` prominently on the `UserProfile` page (e.g., in an `<h1>` or `<h2>` tag).\n*   Add a `Link` component on your Home or About page that navigates to a specific user profile, e.g., `/users/123` or `/users/john-doe`.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link, useParams } from 'react-router-dom';\n\nconst HomePage = () => {\n  return (\n    <div>\n      <h2>Welcome!</h2>\n      <Link to=\"/users/123\">Go to User 123 Profile</Link><br/>\n      <Link to=\"/users/alice\">Go to Alice's Profile</Link>\n    </div>\n  );\n};\n\n// TODO: Create UserProfile component here\nfunction UserProfile() {\n  // Access userId using useParams\n  // Display the userId\n  return (\n    <div>\n      <h2>User Profile</h2>\n      <p>User ID: </p>\n    </div>\n  );\n}\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <Switch>\n        <Route exact path=\"/\">\n          <HomePage />\n        </Route>\n        {/* TODO: Define the route for /users/:userId */}\n\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppRouter;\n",
          "solutionCode": "import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link, useParams } from 'react-router-dom';\n\nconst HomePage = () => {\n  return (\n    <div>\n      <h2>Welcome!</h2>\n      <p>Explore dynamic user profiles:</p>\n      <ul>\n        <li><Link to=\"/users/123\">Go to User 123 Profile</Link></li>\n        <li><Link to=\"/users/alice\">Go to Alice's Profile</Link></li>\n        <li><Link to=\"/users/bob-456\">Go to Bob's Profile</Link></li>\n      </ul>\n      <p><Link to=\"/\">Back to Home</Link></p>\n    </div>\n  );\n};\n\nfunction UserProfile() {\n  const { userId } = useParams(); // Access userId using useParams\n  \n  return (\n    <div>\n      <h2>User Profile</h2>\n      <p>Currently viewing profile for:</p>\n      <h1>User ID: {userId}</h1>\n      <p><Link to=\"/\">Back to Home</Link></p>\n    </div>\n  );\n}\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <Switch>\n        <Route exact path=\"/\">\n          <HomePage />\n        </Route>\n        {/* Define the route for /users/:userId */}\n        <Route path=\"/users/:userId\">\n          <UserProfile />\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppRouter;\n",
          "testCases": [
            "Test 1: Navigate to `/users/123` - `UserProfile` component should render and display 'User ID: 123'.",
            "Test 2: Navigate to `/users/john-doe` - `UserProfile` component should render and display 'User ID: john-doe'.",
            "Test 3: Click the 'Go to User 123 Profile' link from Home - Should navigate to `/users/123` and display correctly.",
            "Test 4: Directly access `/` - Home page should render."
          ],
          "hints": [
            "Remember to import `useParams` from `react-router-dom`.",
            "Place the `Route` for `/users/:userId` within the `Switch` component.",
            "The `userId` will be available as a property on the object returned by `useParams()`."
          ],
          "tags": [
            "React Router",
            "Route Parameters",
            "Hooks",
            "useParams",
            "Dynamic Routes"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics",
            "theory_react_router_parameters_hooks",
            "task_basic_react_router_setup"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "dynamic_content",
            "url_segmentation"
          ]
        },
        {
          "id": "task_nested_user_profile_routes",
          "title": "Implement Nested Routes for a User Profile Page",
          "description": "\nBuilding on the dynamic user profile task, enhance the `UserProfile` page to include nested routes for different user sub-sections.\n\n**Requirements:**\n*   Within the `UserProfile` component (from the previous task), add internal navigation links:\n    *   'Overview' (default, at `/users/:userId`)\n    *   'Posts' (at `/users/:userId/posts`)\n    *   'Photos' (at `/users/:userId/photos`)\n*   Use `NavLink` for these internal links to highlight the active sub-section (e.g., using `activeClassName=\"sub-active-link\"`).\n*   Define nested `Route` components within `UserProfile` for `PostsPage` and `PhotosPage`.\n*   `PostsPage` and `PhotosPage` should be simple functional components displaying a message like 'User [ID] Posts' or 'User [ID] Photos'. They should also be able to access `userId` via `useParams()` (or passed down if you prefer).\n*   Implement a default route for `/users/:userId` (the base `UserProfile` path) that renders a `UserOverview` component, or a message if no sub-path is matched.\n*   Ensure the `userId` is still accessible and displayed on the main `UserProfile` page and ideally within the nested components.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link, NavLink, useParams, useRouteMatch } from 'react-router-dom';\n\nconst HomePage = () => {\n  return (\n    <div>\n      <h2>Welcome!</h2>\n      <Link to=\"/users/123\">Go to User 123 Profile</Link><br/>\n      <Link to=\"/users/alice\">Go to Alice's Profile</Link>\n    </div>\n  );\n};\n\n// TODO: Create UserOverview, PostsPage, PhotosPage components\nconst UserOverview = ({ userId }) => <h3>User {userId} Overview</h3>; // userId should be passed or accessed via useParams\nconst PostsPage = ({ userId }) => <h3>User {userId} Posts</h3>;\nconst PhotosPage = ({ userId }) => <h3>User {userId} Photos</h3>;\n\nfunction UserProfile() {\n  const { userId } = useParams();\n  const { path, url } = useRouteMatch(); // Use useRouteMatch for nested paths/urls\n\n  return (\n    <div>\n      <h2>User Profile for ID: {userId}</h2>\n      <nav>\n        <ul style={{ listStyleType: 'none', padding: 0 }}>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            {/* TODO: Add NavLink for Overview */}\n          </li>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            {/* TODO: Add NavLink for Posts */}\n          </li>\n          <li style={{ display: 'inline', marginRight: '10px' }}>\n            {/* TODO: Add NavLink for Photos */}\n          </li>\n        </ul>\n      </nav>\n\n      {/* TODO: Add Switch for nested routes */}\n      <div>\n\n      </div>\n      <p><Link to=\"/\">Back to Home</Link></p>\n    </div>\n  );\n}\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <Switch>\n        <Route exact path=\"/\">\n          <HomePage />\n        </Route>\n        <Route path=\"/users/:userId\">\n          <UserProfile />\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppRouter;\n\n// Add some basic CSS for .sub-active-link\n// .sub-active-link {\n//   font-weight: bold;\n//   color: green;\n//   text-decoration: underline;\n// }\n",
          "solutionCode": "import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link, NavLink, useParams, useRouteMatch } from 'react-router-dom';\n\nconst HomePage = () => {\n  return (\n    <div>\n      <h2>Welcome!</h2>\n      <p>Explore dynamic user profiles with nested sections:</p>\n      <ul>\n        <li><Link to=\"/users/123\">Go to User 123 Profile</Link></li>\n        <li><Link to=\"/users/alice\">Go to Alice's Profile</Link></li>\n      </ul>\n    </div>\n  );\n};\n\nconst UserOverview = () => {\n  const { userId } = useParams(); // Can access params directly in nested components\n  return <h3>User {userId} Overview</h3>;\n};\n\nconst PostsPage = () => {\n  const { userId } = useParams();\n  return <h3>User {userId} Posts</h3>;\n};\n\nconst PhotosPage = () => {\n  const { userId } = useParams();\n  return <h3>User {userId} Photos</h3>;\n};\n\nfunction UserProfile() {\n  const { userId } = useParams();\n  const { path, url } = useRouteMatch(); // For v5+, useRouteMatch provides path and url\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ddd', borderRadius: '8px', margin: '20px' }}>\n      <h2>User Profile for ID: {userId}</h2>\n      <nav>\n        <ul style={{ listStyleType: 'none', padding: 0 }}>\n          <li style={{ display: 'inline', marginRight: '15px' }}>\n            <NavLink exact to={url} activeClassName=\"sub-active-link\">Overview</NavLink>\n          </li>\n          <li style={{ display: 'inline', marginRight: '15px' }}>\n            <NavLink to={`${url}/posts`} activeClassName=\"sub-active-link\">Posts</NavLink>\n          </li>\n          <li style={{ display: 'inline', marginRight: '15px' }}>\n            <NavLink to={`${url}/photos`} activeClassName=\"sub-active-link\">Photos</NavLink>\n          </li>\n        </ul>\n      </nav>\n\n      <div style={{ marginTop: '20px', borderTop: '1px solid #eee', paddingTop: '15px' }}>\n        <Switch>\n          {/* Default nested route for /users/:userId */}\n          <Route exact path={path}>\n            <UserOverview />\n          </Route>\n          <Route path={`${path}/posts`}>\n            <PostsPage />\n          </Route>\n          <Route path={`${path}/photos`}>\n            <PhotosPage />\n          </Route>\n        </Switch>\n      </div>\n      <p style={{ marginTop: '20px' }}><Link to=\"/\">Back to Home</Link></p>\n    </div>\n  );\n}\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <Switch>\n        <Route exact path=\"/\">\n          <HomePage />\n        </Route>\n        {/* Parent route for user profiles */}\n        <Route path=\"/users/:userId\">\n          <UserProfile />\n        </Route>\n        {/* Add a fallback 404 route (optional) */}\n        <Route path=\"*\">\n          <div>\n            <h2>404 - Page Not Found</h2>\n            <p>The page you are looking for does not exist.</p>\n            <Link to=\"/\">Go to Home</Link>\n          </div>\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppRouter;\n",
          "testCases": [
            "Test 1: Navigate to `/users/456` - `UserProfile` with 'User ID: 456' and 'Overview' content should appear. 'Overview' NavLink should be active.",
            "Test 2: Navigate to `/users/789/posts` - `UserProfile` with 'User ID: 789' and 'User 789 Posts' content should appear. 'Posts' NavLink should be active.",
            "Test 3: Navigate to `/users/abc/photos` - `UserProfile` with 'User ID: abc' and 'User abc Photos' content should appear. 'Photos' NavLink should be active.",
            "Test 4: From `/users/123`, click 'Posts' NavLink - Should change URL to `/users/123/posts` and render `PostsPage`. 'Posts' NavLink should become active.",
            "Test 5: Directly type `/users/test-user/invalid-sub` - Should render the main `UserProfile` but no nested content (or a nested 404 if implemented)."
          ],
          "hints": [
            "Use `useRouteMatch()` within `UserProfile` to get the `path` and `url` for constructing nested routes and links.",
            "Remember to use `exact` prop for the default nested route (`<Route exact path={path}>`).",
            "Nested components (`PostsPage`, `PhotosPage`) can also use `useParams()` if they need the `userId` directly."
          ],
          "tags": [
            "React Router",
            "Nested Routes",
            "Dynamic Routes",
            "useRouteMatch",
            "useParams",
            "NavLink"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "react_hooks_basics",
            "theory_react_router_nested_routes",
            "task_dynamic_user_profile"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "hierarchical_routing",
            "component_composition"
          ]
        },
        {
          "id": "task_implement_private_routes",
          "title": "Implement Private Routes with Authentication Context",
          "description": "\nCreate a React application that demonstrates private routes. This application should have:\n\n1.  **Public Pages**: `HomePage` (`/`) and `LoginPage` (`/login`).\n2.  **Private Page**: `DashboardPage` (`/dashboard`).\n3.  **Authentication Context**: An `AuthContext` to manage `isAuthenticated` state and `login`/`logout` functions.\n4.  **`PrivateRoute` Component**: A custom component that wraps a `Route` and redirects unauthenticated users to `/login`.\n\n**Requirements:**\n*   When a user visits `/dashboard` and is not logged in, they should be redirected to `/login`.\n*   After successful login on `/login` (mocked by a button click), they should be redirected to `/dashboard` (or the page they originally tried to access).\n*   Provide a 'Logout' button on the `DashboardPage` that clears authentication state and redirects to `/login` or `/`.\n*   Show a clear message on `LoginPage` indicating whether login was successful or if a redirect is pending.\n*   The `AuthContext` should use `useState` for authentication state and `useEffect` to simulate an initial check (e.g., if a user was previously logged in).\n",
          "difficulty": "hard",
          "startingCode": "import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { BrowserRouter as Router, Route, Switch, Redirect, useHistory, useLocation } from 'react-router-dom';\n\n// --- Auth Context Setup (from theory) ---\nexport const AuthContext = createContext(null);\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    // Simulate checking for a logged-in user, e.g., from localStorage\n    const storedUser = localStorage.getItem('currentUser');\n    if (storedUser) {\n      setUser(JSON.parse(storedUser));\n    }\n    setLoading(false);\n  }, []);\n\n  const login = (userData) => {\n    const newUser = { id: '1', name: userData.username || 'Test User' };\n    setUser(newUser);\n    localStorage.setItem('currentUser', JSON.stringify(newUser));\n  };\n\n  const logout = () => {\n    setUser(null);\n    localStorage.removeItem('currentUser');\n  };\n\n  const authContextValue = {\n    user,\n    isAuthenticated: !!user,\n    login,\n    logout,\n    loading\n  };\n\n  return (\n    <AuthContext.Provider value={authContextValue}>\n      {!loading ? children : <div>Loading authentication...</div>}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => useContext(AuthContext);\n\n// --- Custom PrivateRoute Component (from theory) ---\nfunction PrivateRoute({ children, ...rest }) {\n  const { isAuthenticated, loading } = useAuth();\n\n  if (loading) {\n    return <div>Loading...</div>; // Or a spinner\n  }\n\n  return (\n    <Route\n      {...rest}\n      render={({ location }) =>\n        isAuthenticated ? (\n          children\n        ) : (\n          <Redirect\n            to={{\n              pathname: '/login',\n              state: { from: location }\n            }}\n          />\n        )\n      }\n    />\n  );\n}\n\n// --- Page Components ---\nconst HomePage = () => <h2>Welcome to the Public Home Page!</h2>;\n\nconst DashboardPage = () => {\n  const { logout, user } = useAuth();\n  return (\n    <div>\n      <h2>Welcome to your Private Dashboard, {user ? user.name : 'Guest'}!</h2>\n      <button onClick={logout}>Logout</button>\n    </div>\n  );\n};\n\nconst LoginPage = () => {\n  const history = useHistory();\n  const location = useLocation();\n  const { login, isAuthenticated } = useAuth();\n\n  const { from } = location.state || { from: { pathname: '/dashboard' } };\n\n  const handleLogin = () => {\n    login({ username: 'user123' }); // Mock login\n    // TODO: Redirect after login based on 'from' state\n  };\n\n  if (isAuthenticated) {\n    // If already authenticated, redirect immediately\n    return <Redirect to={from} />;\n  }\n\n  return (\n    <div>\n      <h2>Login</h2>\n      <p>You need to log in to access the dashboard.</p>\n      <button onClick={handleLogin}>Log In (Mock)</button>\n      {location.state && location.state.from &&\n        <p style={{color: 'orange'}}>You were redirected from: {location.state.from.pathname}. Please log in.</p>\n      }\n    </div>\n  );\n};\n\n// --- Main App Router ---\nfunction App() {\n  return (\n    <Router>\n      <nav style={{ marginBottom: '20px' }}>\n        <ul style={{ listStyleType: 'none', padding: 0 }}>\n          <li style={{ display: 'inline', marginRight: '10px' }}><Link to=\"/\">Home</Link></li>\n          <li style={{ display: 'inline', marginRight: '10px' }}><Link to=\"/dashboard\">Dashboard (Private)</Link></li>\n          <li style={{ display: 'inline', marginRight: '10px' }}><Link to=\"/login\">Login</Link></li>\n        </ul>\n      </nav>\n      <Switch>\n        <Route exact path=\"/\" component={HomePage} />\n        <Route path=\"/login\" component={LoginPage} />\n        {/* Use PrivateRoute for protected paths */}\n        <PrivateRoute path=\"/dashboard\">\n          <DashboardPage />\n        </PrivateRoute>\n        {/* Fallback for 404 */}\n        <Route path=\"*\">\n          <div><h2>404 Not Found</h2><p>Go <Link to=\"/\">Home</Link></p></div>\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { BrowserRouter as Router, Route, Switch, Redirect, useHistory, useLocation } from 'react-router-dom';\n\n// --- Auth Context Setup ---\nexport const AuthContext = createContext(null);\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const storedUser = localStorage.getItem('currentUser');\n    if (storedUser) {\n      setUser(JSON.parse(storedUser));\n    }\n    setLoading(false);\n  }, []);\n\n  const login = (userData) => {\n    const newUser = { id: '1', name: userData.username || 'Test User' };\n    setUser(newUser);\n    localStorage.setItem('currentUser', JSON.stringify(newUser));\n  };\n\n  const logout = () => {\n    setUser(null);\n    localStorage.removeItem('currentUser');\n  };\n\n  const authContextValue = {\n    user,\n    isAuthenticated: !!user,\n    login,\n    logout,\n    loading\n  };\n\n  return (\n    <AuthContext.Provider value={authContextValue}>\n      {!loading ? children : <div>Loading authentication...</div>}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => useContext(AuthContext);\n\n// --- Custom PrivateRoute Component ---\nfunction PrivateRoute({ children, ...rest }) {\n  const { isAuthenticated, loading } = useAuth();\n\n  if (loading) {\n    return <div>Loading...</div>; // Or a spinner\n  }\n\n  return (\n    <Route\n      {...rest}\n      render={({ location }) =>\n        isAuthenticated ? (\n          children\n        ) : (\n          <Redirect\n            to={{\n              pathname: '/login',\n              state: { from: location }\n            }}\n          />\n        )\n      }\n    />\n  );\n}\n\n// --- Page Components ---\nconst HomePage = () => <h2>Welcome to the Public Home Page!</h2>;\n\nconst DashboardPage = () => {\n  const { logout, user } = useAuth();\n  const history = useHistory();\n\n  const handleLogout = () => {\n    logout();\n    history.push('/login'); // Redirect to login page after logout\n  };\n\n  return (\n    <div>\n      <h2>Welcome to your Private Dashboard, {user ? user.name : 'Guest'}!</h2>\n      <p>You are logged in and can see this private content.</p>\n      <button onClick={handleLogout}>Logout</button>\n      <p><Link to=\"/\">Go to Home Page</Link></p>\n    </div>\n  );\n};\n\nconst LoginPage = () => {\n  const history = useHistory();\n  const location = useLocation();\n  const { login, isAuthenticated } = useAuth();\n\n  const { from } = location.state || { from: { pathname: '/dashboard' } };\n\n  useEffect(() => {\n    // If already authenticated and tried to access login, redirect to 'from' or dashboard\n    if (isAuthenticated) {\n      history.replace(from);\n    }\n  }, [isAuthenticated, from, history]);\n\n  const handleLogin = () => {\n    login({ username: 'user123' }); // Mock login\n    // The useEffect above will handle the redirect after state updates\n  };\n\n  return (\n    <div>\n      <h2>Login</h2>\n      <p>Enter credentials to access the dashboard.</p>\n      <button onClick={handleLogin}>Log In (Mock)</button>\n      {location.state && location.state.from &&\n        <p style={{color: 'orange', marginTop: '10px'}}>You were redirected from: {location.state.from.pathname}. Please log in.</p>\n      }\n       <p style={{ marginTop: '10px' }}><Link to=\"/\">Go to Home Page</Link></p>\n    </div>\n  );\n};\n\n// --- Main App Router ---\nfunction App() {\n  return (\n    <Router>\n      <nav style={{ marginBottom: '20px' }}>\n        <ul style={{ listStyleType: 'none', padding: 0 }}>\n          <li style={{ display: 'inline', marginRight: '10px' }}><Link to=\"/\">Home</Link></li>\n          <li style={{ display: 'inline', marginRight: '10px' }}><Link to=\"/dashboard\">Dashboard (Private)</Link></li>\n          <li style={{ display: 'inline', marginRight: '10px' }}><Link to=\"/login\">Login</Link></li>\n        </ul>\n      </nav>\n      <Switch>\n        <Route exact path=\"/\" component={HomePage} />\n        <Route path=\"/login\" component={LoginPage} />\n        {/* Use PrivateRoute for protected paths */}\n        <PrivateRoute path=\"/dashboard\">\n          <DashboardPage />\n        </PrivateRoute>\n        {/* Fallback for 404 */}\n        <Route path=\"*\">\n          <div><h2>404 Not Found</h2><p>Go <Link to=\"/\">Home</Link></p></div>\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Test 1: Unauthenticated user directly navigates to `/dashboard` - Should be redirected to `/login` with a 'redirected from' message.",
            "Test 2: On `/login`, click 'Log In (Mock)' button - Should log in, and then be redirected to `/dashboard`.",
            "Test 3: Authenticated user navigates to `/dashboard` - Should see Dashboard content.",
            "Test 4: On `/dashboard`, click 'Logout' button - Should log out and be redirected to `/login`.",
            "Test 5: Authenticated user directly navigates to `/login` - Should be redirected to `/dashboard` (or the `from` path if available).",
            "Test 6: User navigates to `/` (home page) whether authenticated or not - Should always see Home page content."
          ],
          "hints": [
            "Ensure `AuthProvider` wraps your entire `Router` to make context available everywhere.",
            "The `PrivateRoute` component should use `useAuth()` to check `isAuthenticated`.",
            "In `LoginPage`, use `useHistory().replace(from)` or `history.push(from)` to redirect after login. `replace` is generally better to avoid adding the login page to history.",
            "Remember to pass `location.state` when redirecting from `PrivateRoute` to `LoginPage` to remember the original desired path."
          ],
          "tags": [
            "React Router",
            "Authentication",
            "Private Routes",
            "Context API",
            "Hooks",
            "Redirection",
            "Single Page Applications"
          ],
          "timeEstimate": 120,
          "prerequisites": [
            "react_context_api",
            "react_hooks_basics",
            "theory_react_router_private_routes",
            "task_dynamic_user_profile"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "user_authentication",
            "authorization",
            "protected_routes",
            "global_state_management"
          ]
        }
      ]
    }
  },
  {
    "id": "1666d4a1-21b8-4c60-8aca-764f10e4e81f",
    "startLine": 6400,
    "endLine": 6499,
    "processedDate": "2025-06-17T09:59:47.159Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_router_v6_private_routes",
          "title": "Implementing Private Routes with React Router v6",
          "content": "Private routes are a fundamental concept in web applications, used to restrict access to certain parts of the application based on user authentication or authorization status. In React Router v6, this is typically achieved by wrapping protected components with a custom component that checks the authentication status and redirects the user if they are not authenticated.\n\n## Key Concepts\n-   **Authentication Context (`AuthContext` and `useAuth` hook):** A global state management pattern (often using React's Context API) is used to store and provide the user's authentication status (`user` object or `isAuthenticated` boolean) throughout the application. The `useAuth` custom hook simplifies access to this context.\n-   **`RequireAuth` Component:** This is a higher-order component or a wrapper component that encapsulates the logic for checking authentication. It receives `children` (the protected component) as a prop.\n-   **`useLocation` Hook:** Provided by React Router v6, this hook returns the current `location` object, which contains information about the current URL. This is crucial for storing the user's intended destination before redirecting them to the login page.\n-   **`Navigate` Component:** In React Router v6, `<Navigate>` is the declarative way to perform programmatic navigation or redirects. It's a component that, when rendered, changes the current URL.\n-   **`state` Prop of `Navigate`:** This prop allows you to pass arbitrary state along with the navigation. When redirecting an unauthenticated user to the login page, it's good practice to store the `from` path (the page they tried to access) in the navigation state. After successful login, the user can then be redirected back to this `from` path.\n-   **`replace` Prop of `Navigate`:** Setting `replace` to `true` on `<Navigate>` will replace the current entry in the history stack instead of pushing a new one. This is important for redirects (like after login or for private routes) because it prevents the user from being able to use the browser's back button to return to the page they were redirected *from* (e.g., the protected page they couldn't access). If `replace` were not used, hitting the back button after being redirected to login would take them back to the protected page, then immediately redirect them again, creating a frustrating loop.",
          "examples": [
            {
              "id": "example_react_router_v6_private_route_1",
              "title": "Basic RequireAuth Component",
              "code": "import React, { useContext } from 'react';\nimport { Navigate, useLocation } from 'react-router-dom';\n\n// Assume AuthContext and useAuth are defined elsewhere, e.g., in an AuthProvider file\nconst AuthContext = React.createContext(null);\nconst useAuth = () => useContext(AuthContext);\n\n// Private Route component for React Router v6\nfunction RequireAuth({ children }) {\n  const { user } = useAuth(); // Get user from authentication context\n  const location = useLocation(); // Get current location\n\n  if (!user) {\n    // If no user is logged in, redirect to login page\n    // Store the current location in state so we can redirect back after login\n    // `replace` ensures the login page replaces the current entry in history\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  // If user is authenticated, render the children (the protected component)\n  return children;\n}",
              "explanation": "This `RequireAuth` component demonstrates the core logic for protecting routes in React Router v6. It uses the `useAuth` hook to check if a `user` is present (indicating authentication). If not, it leverages the `Navigate` component to redirect to the `/login` path, passing the current `location` in the state. The `replace` prop ensures that the `/login` route replaces the history entry of the attempted protected route, preventing an endless redirect loop when pressing the back button.",
              "language": "typescript"
            },
            {
              "id": "example_react_router_v6_private_route_2",
              "title": "Usage in React Router v6 Application",
              "code": "import React from 'react';\nimport { Routes, Route, BrowserRouter as Router } from 'react-router-dom';\n// Assume AuthProvider, Home, Login, Dashboard components are defined\n\n// Dummy AuthProvider for demonstration\nconst AuthContext = React.createContext(null);\nconst AuthProvider = ({ children }) => {\n  const user = { name: 'TestUser' }; // Simulate logged-in user\n  // const user = null; // Simulate logged-out user\n  return (\n    <AuthContext.Provider value={{ user }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nconst Home = () => <h2>Home Page</h2>;\nconst Login = () => <h2>Login Page</h2>;\nconst Dashboard = () => <h2>Dashboard (Protected)</h2>;\n\n// Re-using the RequireAuth component from the previous example\n// import { RequireAuth } from './RequireAuth'; // In a real app, you'd import it\n\nfunction App() {\n  return (\n    <AuthProvider>\n      <Router>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/login\" element={<Login />} />\n          <Route \n            path=\"/dashboard\" \n            element={\n              <RequireAuth>\n                <Dashboard />\n              </RequireAuth>\n            } \n          />\n          {/* Other routes */}\n        </Routes>\n      </Router>\n    </AuthProvider>\n  );\n}\n\nexport default App;",
              "explanation": "This example shows how the `RequireAuth` component is integrated into a React Router v6 application. The `Dashboard` component, which represents a protected resource, is rendered as `children` inside `RequireAuth`. The entire application is wrapped in `AuthProvider` to make the authentication context available. When a user tries to access `/dashboard`, `RequireAuth` will check their status and either render `Dashboard` or redirect to `/login`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_v6_private_route_1",
            "question_v6_private_route_2",
            "question_v6_private_route_3",
            "question_v6_private_route_4",
            "question_v6_private_route_5"
          ],
          "relatedTasks": [
            "task_v6_private_route_implementation",
            "task_auth_context_refactor"
          ],
          "tags": [
            "React",
            "React Router v6",
            "Authentication",
            "Private Routes",
            "Context API",
            "Hooks"
          ],
          "technology": "React, TypeScript",
          "prerequisites": [
            "react_basics",
            "react_hooks",
            "react_context_api",
            "react_router_v6_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "user_authentication_systems",
            "role_based_access_control"
          ]
        },
        {
          "id": "theory_react_router_v5_private_routes",
          "title": "Implementing Private Routes with React Router v5",
          "content": "Prior to React Router v6, the approach to creating private routes involved different components and patterns. While v6 introduced a more declarative and hook-based API, understanding v5's methodology can be beneficial for working with legacy projects or appreciating the evolution of the library.\n\n## Key Concepts\n-   **`Route` Component with `render` or `component` prop:** In React Router v5, the `<Route>` component was used with either the `component` prop (which would render the specified component when the path matched) or the `render` prop (which accepted an inline function that returns a React element). The `render` prop was preferred for passing additional props.\n-   **`Redirect` Component:** This component was the primary way to perform redirects declaratively in React Router v5. When rendered, it would immediately navigate to the URL specified in its `to` prop.\n-   **`to` Prop of `Redirect`:** Similar to `Navigate`'s `to` prop, this specified the destination path. It could also accept an object with `pathname` and `state` properties, allowing for state to be passed during the redirection.\n-   **`isAuthenticated` Logic:** Authentication status was typically determined by a custom hook or a global variable/function accessible within the `PrivateRoute` component.\n\n## Comparison with React Router v6\n-   **Declarative vs. Component-based:** V6's `Navigate` is a component that renders and causes navigation, fitting naturally within the JSX flow. V5's `Redirect` also renders and causes navigation.\n-   **Props Spreading:** In v5, it was common to spread `...rest` props onto the `<Route>` component to ensure all standard route props (like `exact`, `path`) were correctly applied. The `render` prop would then pass route-specific props (`history`, `location`, `match`) to the wrapped component.\n-   **Hooks vs. HOC/Render Props:** V6 heavily relies on hooks (`useLocation`, `useNavigate`). V5 often used higher-order components (HOCs) or the `render` prop pattern as shown below.\n-   **Simplicity:** V6's approach with `element` prop and `Navigate` within a wrapper component is generally considered more straightforward and composable.",
          "examples": [
            {
              "id": "example_react_router_v5_private_route_1",
              "title": "React Router v5 PrivateRoute Component",
              "code": "import React from 'react';\nimport { Route, Redirect } from 'react-router-dom';\n\n// Dummy authentication check\nconst useAuth = () => { \n  // In a real app, this would check localStorage, context, or an API\n  return true; // Simulate logged-in user\n  // return false; // Simulate logged-out user\n};\n\n// PrivateRoute component for React Router v5\nconst PrivateRoute = ({ component: Component, ...rest }) => {\n  const isAuthenticated = useAuth(); // Your auth hook or logic\n  \n  return (\n    <Route\n      {...rest} // Spread route props like path, exact\n      render={props => // Use render prop to pass location and other props\n        isAuthenticated ? (\n          <Component {...props} /> // Render the component if authenticated\n        ) : (\n          <Redirect // Redirect to login if not authenticated\n            to={{\n              pathname: \"/login\",\n              state: { from: props.location } // Pass current location for redirect back\n            }}\n          />\n        )\n      }\n    />\n  );\n};",
              "explanation": "This `PrivateRoute` component for React Router v5 takes the component to be protected via the `component` prop. It uses the `render` prop of `<Route>` to conditionally render either the `Component` (if `isAuthenticated` is true) or a `Redirect` component that sends the user to `/login`. The `state` object on the `to` prop of `Redirect` is used to pass the original location, allowing for a post-login redirect back to the intended page. The `...rest` ensures any other props passed to `PrivateRoute` (like `path` or `exact`) are correctly applied to the underlying `Route`.",
              "language": "typescript"
            },
            {
              "id": "example_react_router_v5_private_route_2",
              "title": "Usage of PrivateRoute in React Router v5 App",
              "code": "import React from 'react';\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\n// Assume Home, Login, Dashboard components are defined\nconst Home = () => <h2>Home Page</h2>;\nconst Login = () => <h2>Login Page</h2>;\nconst Dashboard = () => <h2>Dashboard (Protected)</h2>;\n\n// Re-using the PrivateRoute component from the previous example\n// import PrivateRoute from './PrivateRoute'; // In a real app, you'd import it\n\nfunction AppV5() {\n  return (\n    <Router>\n      <Switch>\n        <Route path=\"/\" exact component={Home} />\n        <Route path=\"/login\" component={Login} />\n        {/* Protected route using PrivateRoute */}\n        <PrivateRoute path=\"/dashboard\" component={Dashboard} />\n        {/* Other routes */}\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppV5;",
              "explanation": "This example shows the typical usage of the `PrivateRoute` component within a React Router v5 application. Instead of directly using `<Route>` for `/dashboard`, `PrivateRoute` is used. When `/dashboard` is accessed, `PrivateRoute`'s internal logic will determine if the `Dashboard` component should be rendered or if a redirect to `/login` is necessary. Note the use of `Switch` and `exact` common in v5 routing.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_v5_private_route_1",
            "question_v5_private_route_2",
            "question_v5_private_route_3",
            "question_v5_v6_comparison_1"
          ],
          "relatedTasks": [
            "task_v5_to_v6_migration"
          ],
          "tags": [
            "React",
            "React Router v5",
            "Authentication",
            "Private Routes",
            "Legacy"
          ],
          "technology": "React, JavaScript",
          "prerequisites": [
            "react_basics",
            "react_router_v5_basics"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "maintaining_legacy_apps",
            "understanding_router_evolution"
          ]
        },
        {
          "id": "theory_automatic_redirect_after_login",
          "title": "Automatic Redirect After Login in React Router (v5 & v6)",
          "content": "A common user experience pattern in web applications is to redirect a user to a specific page immediately after they successfully log in. This could be their dashboard, the page they were trying to access before authentication, or a default landing page. React Router provides mechanisms to facilitate this in both v5 and v6.\n\n## React Router v5 Approach\nIn React Router v5, the `Redirect` component was primarily used for programmatic redirects. After a successful authentication (e.g., an API call returning a success status), the component's state could be updated to trigger a `Redirect`.\n\n-   **Conditional Rendering of `Redirect`:** A `Redirect` component would be rendered conditionally based on a state variable (e.g., `isLoggedIn`). Once `isLoggedIn` became true, the `Redirect` component would cause the navigation.\n-   **`state.from` Usage:** The `location.state.from` (which was set during the initial redirect to `/login` from a protected route) could be used to determine the target path after login, ensuring the user returns to their intended destination.\n\n## React Router v6 Approach\nReact Router v6 deprecates `Redirect` and introduces the `useNavigate` hook, which provides a function to imperatively change routes.\n\n-   **`useNavigate` Hook:** This hook returns a `navigate` function that can be called with a path string or a number (for going back/forward in history). It offers more flexibility than the declarative `Navigate` component when you need to trigger navigation based on an event (like a button click or an API response).\n-   **`location.state` Access:** The `useLocation` hook is still used to access the `state` passed during the initial redirection to the login page. This allows retrieving the `from` path.\n-   **`replace` Option with `navigate`:** The `navigate` function also accepts an options object, including `replace: true`, which behaves identically to the `replace` prop on the `Navigate` component, preventing new entries in the history stack.",
          "examples": [
            {
              "id": "example_redirect_after_login_v5",
              "title": "React Router v5 Login Component with Redirect",
              "code": "import React, { Component } from 'react';\nimport { Redirect } from 'react-router-dom';\n\nexport default class LoginComponentV5 extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isLoggedIn: false,\n      username: '',\n      password: ''\n    };\n  }\n  \n  handleLogin = () => {\n    // Your authentication logic here\n    // Simulate API call success after a delay\n    setTimeout(() => {\n        console.log('Login successful');\n        this.setState({ isLoggedIn: true });\n    }, 1000);\n  }\n  \n  handleInputChange = (e) => {\n    this.setState({\n      [e.target.name]: e.target.value\n    });\n  }\n  \n  render() {\n    // Get the 'from' path from location state, or default to dashboard\n    const { from } = this.props.location.state || { from: { pathname: '/dashboard' } };\n\n    if (this.state.isLoggedIn) {\n      return <Redirect to={from} />;\n    }\n\n    return (\n      <div>\n        <h2>Login Page (v5)</h2>\n        <input \n          type=\"text\" \n          name=\"username\" \n          placeholder=\"Username\" \n          value={this.state.username} \n          onChange={this.handleInputChange}\n        />\n        <br />\n        <input \n          type=\"password\" \n          name=\"password\" \n          placeholder=\"Password\" \n          value={this.state.password} \n          onChange={this.handleInputChange}\n        />\n        <br />\n        <button onClick={this.handleLogin}>Log In</button>\n      </div>\n    );\n  }\n}",
              "explanation": "This v5 `LoginComponent` demonstrates post-login redirection. Upon successful login (`handleLogin` sets `isLoggedIn` to `true`), the `render` method conditionally returns a `Redirect` component. The `to` prop of `Redirect` is set to `from`, which is retrieved from `this.props.location.state`. This allows the user to be sent back to the page they were originally trying to access. If no `from` state is present (e.g., they directly navigated to login), it defaults to `/dashboard`.",
              "language": "typescript"
            },
            {
              "id": "example_redirect_after_login_v6",
              "title": "React Router v6 Login Component with Redirect",
              "code": "import React, { useState } from 'react';\nimport { useNavigate, useLocation } from 'react-router-dom';\n\n// Assume useAuth hook is available for login functionality\nconst useAuth = () => ({\n    signIn: (username, password) => {\n        return new Promise(resolve => setTimeout(() => {\n            console.log(`Authenticating ${username}...`);\n            resolve({ user: { id: 1, name: username } }); // Simulate successful login\n        }, 500));\n    }\n});\n\nfunction LoginComponentV6() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const navigate = useNavigate();\n  const location = useLocation();\n  const auth = useAuth(); // Your authentication hook\n\n  const from = location.state?.from?.pathname || '/dashboard';\n\n  const handleLogin = async () => {\n    try {\n      await auth.signIn(username, password); // Simulate login call\n      console.log('Login successful, redirecting...');\n      navigate(from, { replace: true }); // Redirect after successful login\n    } catch (error) {\n      console.error('Login failed:', error);\n      // Handle login error (e.g., show error message)\n    }\n  };\n\n  return (\n    <div>\n      <h2>Login Page (v6)</h2>\n      <input \n        type=\"text\" \n        placeholder=\"Username\" \n        value={username} \n        onChange={(e) => setUsername(e.target.value)}\n      />\n      <br />\n      <input \n        type=\"password\" \n        placeholder=\"Password\" \n        value={password} \n        onChange={(e) => setPassword(e.target.value)}\n      />\n      <br />\n      <button onClick={handleLogin}>Log In</button>\n    </div>\n  );\n}\n\nexport default LoginComponentV6;",
              "explanation": "This v6 `LoginComponent` uses the `useNavigate` hook for post-login redirection. After the simulated `auth.signIn` call succeeds, `navigate(from, { replace: true })` is called. The `from` path is retrieved from `location.state`, which allows redirecting to the user's originally intended page. The `replace: true` option ensures that the login page is replaced in the history stack, preventing the user from navigating back to it immediately after logging in.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_redirect_after_login_1",
            "question_redirect_after_login_2",
            "question_redirect_after_login_3",
            "question_redirect_after_login_4",
            "question_redirect_after_login_5"
          ],
          "relatedTasks": [
            "task_implement_post_login_redirect"
          ],
          "tags": [
            "React",
            "React Router",
            "Authentication",
            "Redirection",
            "User Experience",
            "Hooks"
          ],
          "technology": "React, TypeScript",
          "prerequisites": [
            "react_state_management",
            "react_router_v6_basics",
            "asynchronous_javascript"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "user_onboarding_flows",
            "auth_system_integration"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_v6_private_route_1",
          "topic": "React Router v6 Private Routes",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary React Router v6 component used for declarative navigation or redirection within a React component?",
          "answer": "Navigate",
          "options": [],
          "analysisPoints": [
            "Tests basic knowledge of React Router v6 components.",
            "Distinguishes between components and hooks."
          ],
          "keyConcepts": [
            "React Router v6",
            "Navigate component"
          ],
          "evaluationCriteria": [
            "Recall of fundamental React Router v6 components"
          ],
          "example": "",
          "tags": [
            "React Router v6",
            "Navigation",
            "Basic"
          ],
          "prerequisites": [
            "react_router_v6_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_v6_private_route_2",
          "topic": "React Router v6 Private Routes",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `RequireAuth` component for React Router v6:\n\n```jsx\nfunction RequireAuth({ children }) {\n  const { user } = useAuth(); // Assume useAuth returns { user: null } or { user: {} }\n  const location = useLocation();\n\n  if (!user) {\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  return children;\n}\n```\n\nWhat is the primary purpose of passing `state={{ from: location }}` to the `Navigate` component?",
          "answer": "To allow redirection back to the originally attempted protected route after successful login.",
          "options": [
            "To pass user credentials to the login page for automatic pre-filling.",
            "To signal to the login page that it should display a 'login required' message.",
            "To allow redirection back to the originally attempted protected route after successful login.",
            "To replace the current history entry with the login page without losing the previous route's state."
          ],
          "analysisPoints": [
            "Tests understanding of `state` prop in `Navigate`.",
            "Clarifies how post-login redirects work in React Router.",
            "Distinguishes between passing state for navigation and authentication data."
          ],
          "keyConcepts": [
            "React Router v6",
            "Navigate component",
            "Location state",
            "Post-login redirect"
          ],
          "evaluationCriteria": [
            "Understanding of data flow during navigation.",
            "Ability to identify correct use cases for React Router features."
          ],
          "example": "The `state` object allows custom data to be attached to the navigation action. In this case, `from: location` captures the full path object of the page the user was *trying* to visit. When the user logs in, the login component can access `location.state.from` via `useLocation` hook and use `useNavigate` to send the user back to that specific path.",
          "tags": [
            "React Router v6",
            "Authentication",
            "Navigation",
            "State Management"
          ],
          "prerequisites": [
            "react_router_v6_basics",
            "react_hooks"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_v6_private_route_3",
          "topic": "React Router v6 Private Routes",
          "level": "medium",
          "type": "mcq",
          "question": "What is the effect of the `replace` prop on the `Navigate` component in the `RequireAuth` example?\n\n```jsx\nfunction RequireAuth({ children }) {\n  const { user } = useAuth();\n  const location = useLocation();\n\n  if (!user) {\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  return children;\n}\n```",
          "answer": "It ensures that the login page replaces the current protected route in the browser's history, preventing the user from using the back button to return to the protected route without logging in.",
          "options": [
            "It clears all previous entries from the browser history.",
            "It ensures that the login page replaces the current protected route in the browser's history, preventing the user from using the back button to return to the protected route without logging in.",
            "It automatically refreshes the page after redirection.",
            "It prevents the browser from storing the '/login' path in its history."
          ],
          "analysisPoints": [
            "Tests understanding of browser history manipulation with React Router.",
            "Highlights a common best practice for redirects in authentication flows.",
            "Distinguishes between pushing and replacing history entries."
          ],
          "keyConcepts": [
            "React Router v6",
            "Navigate component",
            "Browser History",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Knowledge of `replace` prop functionality.",
            "Ability to explain the rationale behind using `replace` in auth flows."
          ],
          "example": "If `replace` were not used, the history stack would look like: `[Home, Dashboard (attempted), Login]`. If the user then clicked the back button from the login page, they would go back to the 'Dashboard' entry, which would immediately redirect them to login again, creating a loop. With `replace`, the stack becomes `[Home, Login]`, so hitting back from login correctly takes them to 'Home'.",
          "tags": [
            "React Router v6",
            "History",
            "UX",
            "Authentication"
          ],
          "prerequisites": [
            "react_router_v6_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_v6_private_route_4",
          "topic": "React Router v6 Private Routes",
          "level": "hard",
          "type": "code",
          "question": "Implement a `RequireRole` component similar to `RequireAuth` but which restricts access based on a user's role. Assume `useAuth` provides a `user` object with a `role` property (e.g., `user.role: 'admin' | 'user'`). The component should take an `allowedRoles` array prop. If the user does not have an allowed role, redirect them to a `/unauthorized` page, without storing their previous location in state.",
          "answer": "```typescript\nimport React, { useContext } from 'react';\nimport { Navigate, useLocation } from 'react-router-dom';\n\n// Dummy AuthContext and useAuth for demonstration\nconst AuthContext = React.createContext(null);\nconst useAuth = () => useContext(AuthContext);\n\n// For testing roles, you might set a mock user in AuthProvider:\n// const user = { name: 'Admin User', role: 'admin' };\n// const user = { name: 'Regular User', role: 'user' };\n// const user = null; // No user\n\ninterface RequireRoleProps {\n  children: React.ReactNode;\n  allowedRoles: string[];\n}\n\nfunction RequireRole({ children, allowedRoles }: RequireRoleProps) {\n  const { user } = useAuth();\n  const location = useLocation();\n\n  // First, check if user is authenticated at all\n  if (!user) {\n    // If not authenticated, redirect to login (and store location for post-login redirect)\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  // Then, check if the authenticated user has any of the allowed roles\n  const userHasAllowedRole = allowedRoles.includes(user.role);\n\n  if (!userHasAllowedRole) {\n    // If authenticated but unauthorized by role, redirect to unauthorized page\n    // No need to store 'from' location here, as they won't be redirected back after 'auth'\n    return <Navigate to=\"/unauthorized\" replace />;\n  }\n\n  // If authenticated and authorized, render children\n  return children;\n}\n\n// Example Usage in App.tsx\n/*\n<Routes>\n  <Route path=\"/\" element={<Home />} />\n  <Route path=\"/login\" element={<Login />} />\n  <Route path=\"/unauthorized\" element={<h2>Unauthorized Access!</h2>} />\n  <Route \n    path=\"/admin\" \n    element={\n      <RequireRole allowedRoles={['admin']}>\n        <AdminDashboard />\n      </RequireRole>\n    }\n  />\n  <Route \n    path=\"/user-profile\" \n    element={\n      <RequireRole allowedRoles={['admin', 'user']}>\n        <UserProfile />\n      </RequireRole>\n    }\n  />\n</Routes>\n*/\n```",
          "analysisPoints": [
            "Tests ability to extend `RequireAuth` logic for role-based access control.",
            "Requires handling multiple redirection scenarios (unauthenticated vs. unauthorized).",
            "Assesses understanding of `allowedRoles` array and `includes` method.",
            "Checks for correct usage of `Navigate` component with and without `state`."
          ],
          "keyConcepts": [
            "React Router v6",
            "Role-Based Access Control",
            "Conditional Rendering",
            "Authentication",
            "Authorization"
          ],
          "evaluationCriteria": [
            "Correct implementation of role-checking logic.",
            "Appropriate use of `Navigate` component.",
            "Handling of unauthenticated vs. unauthorized states.",
            "Code clarity and reusability."
          ],
          "example": "The `RequireRole` component builds upon `RequireAuth` by adding an extra layer of authorization. It first ensures the user is logged in. If they are, it then checks if their `user.role` is present in the `allowedRoles` array. If not, they are redirected to a dedicated `/unauthorized` page. This demonstrates a robust pattern for managing different access levels.",
          "tags": [
            "React Router v6",
            "Authorization",
            "RBAC",
            "Advanced Routing",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_router_v6_private_routes",
            "array_methods"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_v6_private_route_5",
          "topic": "React Router v6 Private Routes",
          "level": "easy",
          "type": "flashcard",
          "question": "What React Router v6 hook is used to get information about the current URL location?",
          "answer": "useLocation",
          "options": [],
          "analysisPoints": [
            "Tests recall of fundamental React Router hooks."
          ],
          "keyConcepts": [
            "React Router v6",
            "useLocation hook"
          ],
          "evaluationCriteria": [
            "Direct recall of hook name"
          ],
          "example": "The `useLocation` hook returns an object with `pathname`, `search`, `hash`, and `state` properties, representing the current URL.",
          "tags": [
            "React Router v6",
            "Hooks",
            "Basic"
          ],
          "prerequisites": [
            "react_router_v6_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_v5_private_route_1",
          "topic": "React Router v5 Private Routes",
          "level": "medium",
          "type": "mcq",
          "question": "In React Router v5, when creating a `PrivateRoute`, which prop of the `<Route>` component was typically used to conditionally render a component or a `Redirect`?",
          "answer": "render",
          "options": [
            "element",
            "component",
            "children",
            "render"
          ],
          "analysisPoints": [
            "Tests knowledge of React Router v5's `Route` props.",
            "Highlights the distinction between `component` and `render` for conditional logic.",
            "Reinforces that `element` is v6 specific."
          ],
          "keyConcepts": [
            "React Router v5",
            "Route component",
            "render prop"
          ],
          "evaluationCriteria": [
            "Understanding of v5 API differences.",
            "Correct identification of flexible rendering options."
          ],
          "example": "The `component` prop in v5 would instantiate the component directly, making it harder to pass additional props or implement conditional logic. The `render` prop, however, accepts a function that receives route props and can return any JSX, including conditional rendering of a component or a `Redirect`.",
          "tags": [
            "React Router v5",
            "Legacy",
            "Routing"
          ],
          "prerequisites": [
            "react_router_v5_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_v5_private_route_2",
          "topic": "React Router v5 Private Routes",
          "level": "easy",
          "type": "flashcard",
          "question": "What React Router v5 component was used for declarative redirects?",
          "answer": "Redirect",
          "options": [],
          "analysisPoints": [
            "Tests basic recall of v5 redirection component."
          ],
          "keyConcepts": [
            "React Router v5",
            "Redirect component"
          ],
          "evaluationCriteria": [
            "Direct recall of component name"
          ],
          "example": "",
          "tags": [
            "React Router v5",
            "Redirect",
            "Basic"
          ],
          "prerequisites": [
            "react_router_v5_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_v5_private_route_3",
          "topic": "React Router v5 Private Routes",
          "level": "medium",
          "type": "open",
          "question": "Describe a scenario where you would prefer using the `render` prop over the `component` prop in React Router v5 for a `PrivateRoute`.",
          "answer": "You would prefer using the `render` prop when you need to pass additional props to the component being rendered by the route, or when you need to apply conditional logic before rendering the component or performing a redirect. The `component` prop directly renders the component, making it harder to inject props dynamically or to handle conditional rendering like checking authentication status. The `render` prop provides a function that gives you full control over what is rendered, allowing you to access route props and your custom logic (like `isAuthenticated ? <Component {...props} /> : <Redirect />`).",
          "analysisPoints": [
            "Tests understanding of the practical differences between `component` and `render` props.",
            "Assesses ability to explain trade-offs and best practices in v5.",
            "Requires explaining the `PrivateRoute` context specifically."
          ],
          "keyConcepts": [
            "React Router v5",
            "Route component",
            "render prop",
            "component prop",
            "Conditional Rendering"
          ],
          "evaluationCriteria": [
            "Clear explanation of the problem `render` solves.",
            "Demonstrates knowledge of v5 API nuances.",
            "Ability to articulate practical use cases."
          ],
          "example": null,
          "tags": [
            "React Router v5",
            "Architecture",
            "Best Practices",
            "Open-Ended"
          ],
          "prerequisites": [
            "react_router_v5_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 5,
          "learningPath": "intermediate"
        },
        {
          "id": "question_v5_v6_comparison_1",
          "topic": "React Router v5 vs v6 Private Routes",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast the `PrivateRoute` pattern in React Router v5 with the `RequireAuth` pattern in React Router v6. Discuss the advantages and disadvantages of each, and why the v6 approach is generally preferred.",
          "answer": "## React Router v5 `PrivateRoute`\n**Approach:** Typically uses a Higher-Order Component (HOC) or `render` prop on the `<Route>` component. It takes the protected `component` as a prop and conditionally renders it or a `<Redirect>` component based on an authentication check.\n\n**Example:**\n```jsx\nconst PrivateRoute = ({ component: Component, ...rest }) => (\n  <Route\n    {...rest}\n    render={props =>\n      isAuthenticated ? (<Component {...props} />) : (<Redirect to={{ pathname: '/login', state: { from: props.location } }} />)\n    }\n  />\n);\n```\n\n**Advantages:**\n*   **Clear separation of concerns:** The `PrivateRoute` component encapsulates the authentication logic for a specific route.\n\n**Disadvantages:**\n*   **Less intuitive composition:** Wrapping components with a `PrivateRoute` can feel less natural than v6's element prop, especially when nesting.\n*   **`render` vs `component` props:** The nuances between `render` and `component` props (`component` remounts on every render, `render` doesn't) could lead to subtle bugs if not understood properly.\n*   **Imperative `Redirect`:** While declarative, `Redirect` is a component. Programmatic redirects (e.g., after an API call) still required state management to conditionally render it.\n\n## React Router v6 `RequireAuth`\n**Approach:** Leverages React Hooks and the `element` prop on `<Route>`. It's typically implemented as a wrapper component that uses `useContext` for authentication state, `useLocation` for the current path, and the `Navigate` component for redirection.\n\n**Example:**\n```jsx\nfunction RequireAuth({ children }) {\n  const { user } = useAuth();\n  const location = useLocation();\n  if (!user) {\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n  return children;\n}\n\n<Route path=\"/dashboard\" element={<RequireAuth><Dashboard /></RequireAuth>} />\n```\n\n**Advantages:**\n*   **React-ish Composition:** The `element` prop for `<Route>` makes it feel more like standard React component composition, wrapping children directly.\n*   **Hooks API:** Utilizes modern React Hooks (`useLocation`, `useNavigate`), which align with current React development patterns and allow for cleaner, more functional components.\n*   **`Navigate` Component:** `Navigate` is a more declarative and consistent way to handle redirects, both from wrapper components and conditionally.\n*   **`useNavigate` Hook:** Provides an imperative function for redirects (e.g., after login) that doesn't require conditional component rendering.\n*   **Improved Type Safety:** With TypeScript, hooks-based solutions often lead to better type inference and safety.\n\n**Disadvantages:**\n*   Requires functional components (though this is standard practice now).\n*   Can be slightly more verbose if you need deeply nested authentication logic for many routes, but can be abstracted.\n\n**Why v6 is generally preferred:**\nReact Router v6 embraces modern React paradigms (hooks, functional components, JSX composition) more fully. It simplifies the API, makes routing logic more intuitive to read and write, and reduces common pitfalls associated with older patterns (like `component` prop remounts). The clear separation of declarative (`Navigate`) and imperative (`useNavigate`) navigation options also adds flexibility and clarity.",
          "analysisPoints": [
            "Requires detailed knowledge of both v5 and v6 private routing patterns.",
            "Tests ability to identify and articulate key differences in API and conceptual approach.",
            "Evaluates understanding of advantages/disadvantages for each version.",
            "Assesses ability to provide code examples to illustrate points."
          ],
          "keyConcepts": [
            "React Router v5",
            "React Router v6",
            "Private Routes",
            "HOCs",
            "Hooks",
            "Composition",
            "API differences"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison covering API, patterns, advantages, and disadvantages.",
            "Clarity and accuracy of explanations.",
            "Ability to articulate the reasons for v6's preference.",
            "Structured and organized response."
          ],
          "example": null,
          "tags": [
            "React Router",
            "Migration",
            "Architecture",
            "Comparison",
            "Advanced",
            "Open-Ended"
          ],
          "prerequisites": [
            "react_router_v5_private_routes",
            "react_router_v6_private_routes"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_redirect_after_login_1",
          "topic": "Automatic Redirect After Login",
          "level": "medium",
          "type": "code",
          "question": "Given a `LoginComponent` using React Router v6, modify its `handleLogin` function to redirect the user to `/dashboard` after a successful login. Use the `useNavigate` hook.",
          "answer": "```typescript\nimport React, { useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\n// Assume a dummy useAuth hook for demonstration\nconst useAuth = () => ({\n    signIn: (username, password) => {\n        return new Promise(resolve => setTimeout(() => {\n            console.log(`Authenticating ${username}...`);\n            resolve({ user: { id: 1, name: username } }); // Simulate successful login\n        }, 500));\n    }\n});\n\nfunction LoginComponent() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const navigate = useNavigate(); // Initialize useNavigate hook\n  const auth = useAuth(); // Your authentication hook\n\n  const handleLogin = async () => {\n    try {\n      await auth.signIn(username, password); // Simulate login call\n      console.log('Login successful, redirecting...');\n      navigate('/dashboard', { replace: true }); // Redirect to dashboard, replacing history entry\n    } catch (error) {\n      console.error('Login failed:', error);\n      // Handle login error (e.g., show error message)\n    }\n  };\n\n  return (\n    <div>\n      <h2>Login Page</h2>\n      <input \n        type=\"text\" \n        placeholder=\"Username\" \n        value={username} \n        onChange={(e) => setUsername(e.target.value)}\n      />\n      <br />\n      <input \n        type=\"password\" \n        placeholder=\"Password\" \n        value={password} \n        onChange={(e) => setPassword(e.target.value)}\n      />\n      <br />\n      <button onClick={handleLogin}>Log In</button>\n    </div>\n  );\n}\n\nexport default LoginComponent;\n```",
          "analysisPoints": [
            "Tests correct initialization and usage of `useNavigate`.",
            "Ensures understanding of programmatic redirects.",
            "Checks for inclusion of `replace: true` for good UX."
          ],
          "keyConcepts": [
            "React Router v6",
            "useNavigate hook",
            "Programmatic Navigation",
            "Authentication",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Correct use of `useNavigate`.",
            "Proper redirection path.",
            "Consideration for history replacement."
          ],
          "example": "The `useNavigate` hook provides the `navigate` function, which allows you to programmatically change the URL. By calling `navigate('/dashboard', { replace: true })` inside `handleLogin` after a successful authentication, the user is seamlessly moved to the dashboard, and the login page is removed from the browser history, preventing 'back' button issues.",
          "tags": [
            "React Router v6",
            "Hooks",
            "Authentication",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_router_v6_basics",
            "react_hooks"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redirect_after_login_2",
          "topic": "Automatic Redirect After Login",
          "level": "medium",
          "type": "mcq",
          "question": "In React Router v6, if a user attempts to access a protected route (e.g., `/dashboard`), is redirected to `/login` (with `state={{ from: location }}`), and then successfully logs in, which of the following is the most appropriate way to redirect them back to the `/dashboard`?",
          "answer": "Use `useLocation` to retrieve `location.state.from` and then `useNavigate` to navigate to that path, typically with `replace: true`.",
          "options": [
            "Directly use `<Navigate to=\"/dashboard\" />` in the login component's render method.",
            "Use `window.location.href = '/dashboard';` to force a full page reload.",
            "Use `useLocation` to retrieve `location.state.from` and then `useNavigate` to navigate to that path, typically with `replace: true`.",
            "Store the `/dashboard` path in a global variable and access it after login."
          ],
          "analysisPoints": [
            "Tests knowledge of React Router v6 state passing and redirection best practices.",
            "Evaluates understanding of `from` state usage.",
            "Distinguishes between correct React Router patterns and anti-patterns (`window.location.href`)."
          ],
          "keyConcepts": [
            "React Router v6",
            "useLocation",
            "useNavigate",
            "State passing",
            "Post-login redirect"
          ],
          "evaluationCriteria": [
            "Correct application of React Router hooks.",
            "Adherence to recommended patterns for complex navigation flows.",
            "Understanding of the purpose of `from` state."
          ],
          "example": "The flow is: User tries `/dashboard` -> `RequireAuth` sees no user -> `Navigate` to `/login` with `state={{ from: location }}` (where `location` is `/dashboard`). On the login page, `useLocation().state.from` will give you the `/dashboard` location object. Then, `useNavigate()(from.pathname, { replace: true })` will send the user back.",
          "tags": [
            "React Router v6",
            "Authentication",
            "Navigation",
            "Best Practices"
          ],
          "prerequisites": [
            "react_router_v6_private_routes",
            "react_router_v6_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redirect_after_login_3",
          "topic": "Automatic Redirect After Login",
          "level": "easy",
          "type": "flashcard",
          "question": "When redirecting after login, why is it generally recommended to use the `replace: true` option with `navigate` (v6) or the `replace` prop with `Navigate` (v6) / `Redirect` (v5)?",
          "answer": "To prevent the user from being able to navigate back to the login page or the protected page they were redirected from, using the browser's back button, which could lead to an infinite redirect loop.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of UX implications of history management.",
            "Reinforces best practices for authentication flows."
          ],
          "keyConcepts": [
            "React Router",
            "History management",
            "UX",
            "Redirect"
          ],
          "evaluationCriteria": [
            "Correctly identifies the purpose of `replace`"
          ],
          "example": null,
          "tags": [
            "React Router",
            "UX",
            "History",
            "Best Practices"
          ],
          "prerequisites": [
            "react_router_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redirect_after_login_4",
          "topic": "Automatic Redirect After Login",
          "level": "medium",
          "type": "open",
          "question": "What happens if you try to access `location.state.from` in a `LoginComponent` when the user directly navigated to `/login` (not redirected from a protected route)? How should you handle this scenario?",
          "answer": "If a user directly navigates to `/login` (e.g., by typing the URL or clicking a direct login link) instead of being redirected from a protected route, `location.state` will be `undefined` or `null`. Consequently, `location.state.from` would also be `undefined`, leading to an error if accessed without a check.\n\n**Handling this scenario:**\nYou should provide a fallback or default path for redirection. This is typically done using the optional chaining operator (`?.`) in JavaScript or a logical OR (`||`) operator.\n\n**Example (React Router v6):**\n```typescript\nimport { useLocation, useNavigate } from 'react-router-dom';\n\nfunction LoginComponent() {\n  const location = useLocation();\n  const navigate = useNavigate();\n\n  // Safely access `from` or provide a default path\n  const from = location.state?.from?.pathname || '/dashboard'; \n\n  const handleLogin = () => {\n    // ... (authentication logic)\n    navigate(from, { replace: true });\n  };\n\n  // ... (render method)\n}\n```\nIn this example, if `location.state` or `location.state.from` is `undefined`, `from` will default to `'/dashboard'`, ensuring a valid redirection target.",
          "analysisPoints": [
            "Tests understanding of `location.state` and its potential `undefined` value.",
            "Assesses knowledge of defensive programming techniques (optional chaining, logical OR).",
            "Requires suggesting a practical solution for a common edge case."
          ],
          "keyConcepts": [
            "React Router",
            "Location state",
            "Edge Cases",
            "Defensive Programming",
            "Optional Chaining"
          ],
          "evaluationCriteria": [
            "Correctly identifies the problem.",
            "Provides a robust and idiomatic solution.",
            "Explains the reasoning behind the solution."
          ],
          "example": null,
          "tags": [
            "React Router",
            "Edge Cases",
            "Error Handling",
            "Best Practices",
            "Open-Ended"
          ],
          "prerequisites": [
            "react_router_basics",
            "javascript_fundamentals"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redirect_after_login_5",
          "topic": "Automatic Redirect After Login",
          "level": "hard",
          "type": "code",
          "question": "Create a `LoginComponent` that uses the `useAuth` hook (providing `user` and `signIn` function). The component should:\n1.  Handle username and password input.\n2.  Call `auth.signIn(username, password)` on button click.\n3.  After successful login, redirect the user back to the page they were trying to access (if they were redirected from a protected route), otherwise redirect them to `/home`. Ensure the history entry for the login page is replaced.",
          "answer": "```typescript\nimport React, { useState, useContext, createContext } from 'react';\nimport { useNavigate, useLocation } from 'react-router-dom';\n\n// --- Dummy Auth Context and Hook --- START\n// In a real app, these would be in a separate file (e.g., AuthProvider.tsx)\ninterface User { id: number; name: string; }\ninterface AuthContextType {\n  user: User | null;\n  signIn: (username: string, password?: string) => Promise<User>;\n  signOut: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType | null>(null);\n\nconst AuthProvider = ({ children }: { children: React.ReactNode }) => {\n  const [user, setUser] = useState<User | null>(null);\n\n  const signIn = (username: string, password?: string) => {\n    return new Promise<User>(resolve => {\n      setTimeout(() => {\n        const newUser = { id: 1, name: username };\n        setUser(newUser);\n        console.log(`User ${username} logged in.`);\n        resolve(newUser);\n      }, 500);\n    });\n  };\n\n  const signOut = () => {\n    return new Promise<void>(resolve => {\n      setTimeout(() => {\n        setUser(null);\n        console.log('User logged out.');\n        resolve();\n      }, 300);\n    });\n  };\n\n  return (\n    <AuthContext.Provider value={{ user, signIn, signOut }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nconst useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n// --- Dummy Auth Context and Hook --- END\n\n\n// --- LoginComponent Implementation --- START\nfunction LoginComponent() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const navigate = useNavigate();\n  const location = useLocation();\n  const auth = useAuth(); // Access auth functions\n\n  // Determine the 'from' path or default to '/home'\n  const from = location.state?.from?.pathname || '/home';\n\n  const handleLogin = async (e: React.FormEvent) => {\n    e.preventDefault(); // Prevent default form submission\n    try {\n      await auth.signIn(username, password); // Call the sign-in function from context\n      console.log('Login successful, redirecting to:', from);\n      navigate(from, { replace: true }); // Redirect, replacing history entry\n    } catch (error) {\n      console.error('Login failed:', error);\n      // Optionally, set an error message in state to display to the user\n    }\n  };\n\n  return (\n    <div>\n      <h2>Login</h2>\n      <form onSubmit={handleLogin}>\n        <div>\n          <label htmlFor=\"username\">Username:</label>\n          <input \n            id=\"username\" \n            type=\"text\" \n            value={username} \n            onChange={(e) => setUsername(e.target.value)}\n            required\n          />\n        </div>\n        <div>\n          <label htmlFor=\"password\">Password:</label>\n          <input \n            id=\"password\" \n            type=\"password\" \n            value={password} \n            onChange={(e) => setPassword(e.target.value)}\n            required\n          />\n        </div>\n        <button type=\"submit\">Log In</button>\n      </form>\n    </div>\n  );\n}\n\nexport default LoginComponent;\n\n// Example usage (in App.tsx for testing):\n/*\nfunction App() {\n  return (\n    <AuthProvider>\n      <Router>\n        <Routes>\n          <Route path=\"/\" element={<h2>Welcome Home</h2>} />\n          <Route path=\"/home\" element={<h2>Home Page</h2>} />\n          <Route path=\"/login\" element={<LoginComponent />} />\n          <Route \n            path=\"/dashboard\" \n            element={\n              <RequireAuth><Dashboard /></RequireAuth>\n            }\n          />\n          <Route path=\"*\" element={<h2>404 Not Found</h2>} />\n        </Routes>\n      </Router>\n    </AuthProvider>\n  );\n}\n*/\n```",
          "analysisPoints": [
            "Tests complete implementation of a login flow.",
            "Requires integration of `useAuth`, `useNavigate`, `useLocation`.",
            "Checks for correct handling of the `from` state and default fallback.",
            "Evaluates proper usage of `replace: true` for history management.",
            "Assesses basic form handling and asynchronous operation."
          ],
          "keyConcepts": [
            "React Hooks",
            "Context API",
            "React Router v6",
            "Authentication",
            "Navigation",
            "Asynchronous Operations",
            "Form Handling"
          ],
          "evaluationCriteria": [
            "Functional login process.",
            "Correct conditional redirection logic.",
            "Proper use of `replace` option.",
            "Clean code structure and use of hooks.",
            "Error handling (even if basic)."
          ],
          "example": null,
          "tags": [
            "React",
            "React Router v6",
            "Authentication",
            "Forms",
            "State Management",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_router_v6_basics",
            "react_hooks_advanced",
            "asynchronous_javascript",
            "react_context_api"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_v6_private_route_implementation",
          "title": "Implement a Secure Dashboard with React Router v6",
          "description": "\nImplement a React application using React Router v6 that includes:\n\n1.  **Authentication Context (`AuthContext` and `AuthProvider`):** A context to manage user authentication state. It should provide a `user` object (or `null` if logged out) and `signIn`/`signOut` functions (mock them with simple `setTimeout`s).\n2.  **`useAuth` Hook:** A custom hook to consume the `AuthContext`.\n3.  **`RequireAuth` Component:** A component that acts as a private route guard. It should check if `user` is authenticated via `useAuth`. If not, it redirects to `/login`, passing the current location in state (`state={{ from: location }}`). Ensure `replace: true` is used for the `Navigate` component.\n4.  **Login Component:** A basic login form with username/password inputs. On submission, it should call `auth.signIn`. After successful login, it should redirect the user back to the `from` location (retrieved from `useLocation().state`) or to `/dashboard` if `from` is not present. Use `navigate` with `replace: true`.\n5.  **Dashboard Component:** A simple component to be protected.\n6.  **App Routing:** Set up `Routes` for `/`, `/login`, and `/dashboard`. The `/dashboard` route must be protected by `RequireAuth`.\n\nYour solution should demonstrate proper integration of authentication with React Router v6 private routes.\n",
          "difficulty": "medium",
          "startingCode": "import React, { createContext, useContext, useState } from 'react';\nimport { BrowserRouter as Router, Routes, Route, Navigate, useLocation, useNavigate } from 'react-router-dom';\n\n// 1. Define AuthContext and AuthProvider\ninterface User { id: number; name: string; }\ninterface AuthContextType {\n  user: User | null;\n  signIn: (username: string, password?: string) => Promise<User>;\n  signOut: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType | null>(null);\n\nconst AuthProvider = ({ children }: { children: React.ReactNode }) => {\n  const [user, setUser] = useState<User | null>(null); // Initial state: no user\n\n  const signIn = (username: string, password?: string) => {\n    return new Promise<User>(resolve => {\n      setTimeout(() => {\n        const newUser = { id: 1, name: username };\n        setUser(newUser);\n        console.log(`User ${username} logged in.`);\n        resolve(newUser);\n      }, 500);\n    });\n  };\n\n  const signOut = () => {\n    return new Promise<void>(resolve => {\n      setTimeout(() => {\n        setUser(null);\n        console.log('User logged out.');\n        resolve();\n      }, 300);\n    });\n  };\n\n  return (\n    <AuthContext.Provider value={{ user, signIn, signOut }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// 2. Define useAuth hook\nconst useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\n// Dummy Components\nconst Home = () => <h2>Home Page</h2>;\nconst Dashboard = () => {\n  const { signOut } = useAuth();\n  return (\n    <div>\n      <h2>Dashboard (Protected)</h2>\n      <button onClick={signOut}>Sign Out</button>\n    </div>\n  );\n};\n\n// 3. TODO: Implement RequireAuth Component\nfunction RequireAuth({ children }: { children: React.ReactNode }) {\n  // Your implementation here\n  return null; // Placeholder\n}\n\n// 4. TODO: Implement LoginComponent\nfunction LoginComponent() {\n  // Your implementation here\n  return (\n    <div>\n      <h2>Login Page</h2>\n      {/* Add form elements */}\n      <button>Log In</button>\n    </div>\n  );\n}\n\n// App Component to set up routes\nexport default function App() {\n  return (\n    <AuthProvider>\n      <Router>\n        <nav>\n          <p><a href=\"/\">Home</a> | <a href=\"/dashboard\">Dashboard</a> | <a href=\"/login\">Login</a></p>\n        </nav>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/login\" element={<LoginComponent />} />\n          {/* 6. TODO: Protect Dashboard Route */}\n          <Route path=\"/dashboard\" element={null /* Your protected element here */} />\n        </Routes>\n      </Router>\n    </AuthProvider>\n  );\n}\n",
          "solutionCode": "import React, { createContext, useContext, useState } from 'react';\nimport { BrowserRouter as Router, Routes, Route, Navigate, useLocation, useNavigate } from 'react-router-dom';\n\n// 1. Define AuthContext and AuthProvider\ninterface User { id: number; name: string; }\ninterface AuthContextType {\n  user: User | null;\n  signIn: (username: string, password?: string) => Promise<User>;\n  signOut: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType | null>(null);\n\nconst AuthProvider = ({ children }: { children: React.ReactNode }) => {\n  const [user, setUser] = useState<User | null>(null); // Initial state: no user\n\n  const signIn = (username: string, password?: string) => {\n    return new Promise<User>(resolve => {\n      setTimeout(() => {\n        const newUser = { id: 1, name: username };\n        setUser(newUser);\n        console.log(`User ${username} logged in.`);\n        resolve(newUser);\n      }, 500);\n    });\n  };\n\n  const signOut = () => {\n    return new Promise<void>(resolve => {\n      setTimeout(() => {\n        setUser(null);\n        console.log('User logged out.');\n        resolve();\n      }, 300);\n    });\n  };\n\n  return (\n    <AuthContext.Provider value={{ user, signIn, signOut }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// 2. Define useAuth hook\nconst useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\n// Dummy Components\nconst Home = () => <h2>Home Page</h2>;\nconst Dashboard = () => {\n  const { signOut, user } = useAuth();\n  return (\n    <div>\n      <h2>Dashboard (Protected)</h2>\n      {user && <p>Welcome, {user.name}!</p>}\n      <button onClick={signOut}>Sign Out</button>\n    </div>\n  );\n};\n\n// 3. RequireAuth Component\nfunction RequireAuth({ children }: { children: React.ReactNode }) {\n  const { user } = useAuth();\n  const location = useLocation();\n\n  if (!user) {\n    // Redirect to login page, storing current location\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  return children;\n}\n\n// 4. LoginComponent\nfunction LoginComponent() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const navigate = useNavigate();\n  const location = useLocation();\n  const auth = useAuth();\n\n  // Determine the 'from' path or default to '/dashboard'\n  const from = location.state?.from?.pathname || '/dashboard';\n\n  const handleLogin = async (e: React.FormEvent) => {\n    e.preventDefault();\n    try {\n      await auth.signIn(username, password); // Call signIn function\n      console.log('Login successful, redirecting to:', from);\n      navigate(from, { replace: true }); // Redirect, replacing history entry\n    } catch (error) {\n      console.error('Login failed:', error);\n      // Implement error display here\n    }\n  };\n\n  return (\n    <div>\n      <h2>Login Page</h2>\n      <form onSubmit={handleLogin}>\n        <div>\n          <label htmlFor=\"username\">Username:</label>\n          <input \n            id=\"username\" \n            type=\"text\" \n            value={username} \n            onChange={(e) => setUsername(e.target.value)}\n            required\n          />\n        </div>\n        <div>\n          <label htmlFor=\"password\">Password:</label>\n          <input \n            id=\"password\" \n            type=\"password\" \n            value={password} \n            onChange={(e) => setPassword(e.target.value)}\n            required\n          />\n        </div>\n        <button type=\"submit\">Log In</button>\n      </form>\n    </div>\n  );\n}\n\n// App Component to set up routes\nexport default function App() {\n  return (\n    <AuthProvider>\n      <Router>\n        <nav>\n          <p>\n            <a href=\"/\">Home</a> |\n            <a href=\"/dashboard\">Dashboard (Protected)</a> |\n            <a href=\"/login\">Login</a>\n          </p>\n          <hr/>\n        </nav>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/login\" element={<LoginComponent />} />\n          {/* 6. Protect Dashboard Route */}\n          <Route \n            path=\"/dashboard\" \n            element={\n              <RequireAuth>\n                <Dashboard />\n              </RequireAuth>\n            } \n          />\n        </Routes>\n      </Router>\n    </AuthProvider>\n  );\n}\n",
          "testCases": [
            "**Test Case 1: Accessing Protected Route when Logged Out**\n\t- **Steps:** Start the application. Navigate to `/dashboard` directly (e.g., type in URL).\n\t- **Expected:** Should be redirected to `/login` page. The URL should show `/login`, and if you inspect `location.state`, it should contain `from: { pathname: '/dashboard', ... }`.\n\t- **Reasoning:** `RequireAuth` should detect no user and trigger the `Navigate` with `state` and `replace`.\n",
            "**Test Case 2: Successful Login and Redirect**\n\t- **Steps:** From the `/login` page (after being redirected from `/dashboard` in Test Case 1), enter any username/password and click 'Log In'.\n\t- **Expected:** After a brief delay (simulating API call), the page should redirect to `/dashboard`. The URL should show `/dashboard`. Pressing the browser's back button should take you to `/` (Home), not back to `/login`.\n\t- **Reasoning:** `LoginComponent` should retrieve `from` state, call `navigate(from, { replace: true })`.\n",
            "**Test Case 3: Direct Login and Default Redirect**\n\t- **Steps:** Start the application. Navigate directly to `/login` (e.g., type in URL). Enter any username/password and click 'Log In'.\n\t- **Expected:** After a brief delay, the page should redirect to `/dashboard`. The URL should show `/dashboard`. Pressing the browser's back button should take you to `/` (Home).\n\t- **Reasoning:** `LoginComponent` should handle `location.state.from` being `undefined` and fall back to the default `/dashboard` path.\n",
            "**Test Case 4: Accessing Protected Route when Logged In**\n\t- **Steps:** Log in first via the `/login` page (or modify `AuthProvider` to start with a user). Then navigate to `/dashboard`.\n\t- **Expected:** You should see the 'Dashboard (Protected)' content. No redirection should occur.\n\t- **Reasoning:** `RequireAuth` should detect an authenticated user and render its `children`.\n",
            "**Test Case 5: Sign Out Functionality**\n\t- **Steps:** Log in and access the Dashboard. Click the 'Sign Out' button on the Dashboard.\n\t- **Expected:** The application should transition back to the logged-out state. Typically, this would mean redirecting to `/login` or `/` (Home). The `user` in `AuthContext` should become `null`.\n\t- **Reasoning:** The `signOut` function from `useAuth` is called, updating the user state, which implicitly re-renders `RequireAuth` and potentially triggers a redirect to login."
          ],
          "hints": [
            "Remember to wrap your entire application in the `AuthProvider` for the context to be accessible.",
            "The `RequireAuth` component should conditionally return either the `children` or a `Navigate` component.",
            "For the `LoginComponent`, use `useLocation()` to get the `state` from the redirect and `useNavigate()` to perform the post-login redirect.",
            "Don't forget the `replace: true` option in your `Navigate` components and `navigate` calls to manage browser history effectively.",
            "Make sure your `LoginComponent` handles the case where `location.state.from` might be undefined (e.g., if the user directly navigates to /login)."
          ],
          "tags": [
            "React Router v6",
            "Authentication",
            "Private Routes",
            "Context API",
            "Hooks",
            "Frontend Architecture"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_basics",
            "react_hooks",
            "react_context_api",
            "react_router_v6_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "user_authentication",
            "authorization",
            "single_page_application_routing",
            "global_state_management"
          ]
        },
        {
          "id": "task_implement_post_login_redirect",
          "title": "Build a Login Form with Dynamic Post-Login Redirection (v6)",
          "description": "\nEnhance a `LoginComponent` to handle dynamic redirection after a successful login based on where the user was trying to go.\n\n1.  **Login Form:** A simple form with username and password inputs and a submit button.\n2.  **Authentication Logic:** Mock an asynchronous `signIn` function (e.g., with `setTimeout`) that resolves after a short delay, simulating a successful API call.\n3.  **Redirection Logic:** After a successful `signIn`, the component should redirect the user.\n    *   If the user was redirected to `/login` from a protected route (e.g., `/dashboard`), retrieve the original path from `location.state.from` and redirect them there.\n    *   If the user directly navigated to `/login`, redirect them to a default path, e.g., `/home`.\n4.  **History Management:** Ensure that the login page is replaced in the browser's history stack after the redirect (using `replace: true`).\n\nProvide the `LoginComponent` and an `App` setup demonstrating this flow.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\nimport { BrowserRouter as Router, Routes, Route, useNavigate, useLocation } from 'react-router-dom';\n\n// Dummy signIn function (simulates API call)\nconst mockSignIn = (username: string, password?: string): Promise<any> => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(`Authenticating ${username}...`);\n      resolve({ user: { id: 1, name: username } }); // Simulate successful login\n    }, 700);\n  });\n};\n\n// LoginComponent to implement\nfunction LoginComponent() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  // TODO: Implement handleLogin to handle authentication and redirection\n  const handleLogin = async (e: React.FormEvent) => {\n    e.preventDefault();\n    // Your implementation here\n  };\n\n  return (\n    <div>\n      <h2>Login</h2>\n      <form onSubmit={handleLogin}>\n        <div>\n          <label htmlFor=\"username\">Username:</label>\n          <input \n            id=\"username\" \n            type=\"text\" \n            value={username} \n            onChange={(e) => setUsername(e.target.value)}\n            required\n          />\n        </div>\n        <div>\n          <label htmlFor=\"password\">Password:</label>\n          <input \n            id=\"password\" \n            type=\"password\" \n            value={password} \n            onChange={(e) => setPassword(e.target.value)}\n            required\n          />\n        </div>\n        <button type=\"submit\">Log In</button>\n      </form>\n    </div>\n  );\n}\n\n// App setup for testing (you might need a dummy RequireAuth for full test)\nconst Home = () => <h2>Home Page</h2>;\nconst Dashboard = () => <h2>Dashboard (Protected)</h2>;\n\n// For testing, you can temporarily comment out RequireAuth or use a simple one\n// If you use a full RequireAuth, ensure you have an AuthProvider setup\nconst SimpleRequireAuth = ({ children }: { children: React.ReactNode }) => {\n  const isAuthenticated = true; // For simple testing, assume authenticated\n  // const isAuthenticated = false; // Uncomment to test redirect to login\n  const location = useLocation();\n  if (!isAuthenticated) {\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n  return children;\n};\n\nexport default function App() {\n  return (\n    <Router>\n      <nav>\n        <p><a href=\"/\">Home</a> | <a href=\"/dashboard\">Dashboard</a> | <a href=\"/login\">Login</a></p>\n        <hr/>\n      </nav>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/login\" element={<LoginComponent />} />\n        <Route \n          path=\"/dashboard\" \n          element={\n            <SimpleRequireAuth>\n              <Dashboard />\n            </SimpleRequireAuth>\n          } \n        />\n      </Routes>\n    </Router>\n  );\n}\n",
          "solutionCode": "import React, { useState } from 'react';\nimport { BrowserRouter as Router, Routes, Route, useNavigate, useLocation, Navigate } from 'react-router-dom';\n\n// Dummy signIn function (simulates API call)\nconst mockSignIn = (username: string, password?: string): Promise<any> => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(`Authenticating ${username}...`);\n      resolve({ user: { id: 1, name: username } }); // Simulate successful login\n    }, 700);\n  });\n};\n\n// LoginComponent implementation\nfunction LoginComponent() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  const handleLogin = async (e: React.FormEvent) => {\n    e.preventDefault();\n    try {\n      await mockSignIn(username, password); // Call the mock signIn function\n      \n      // Determine the redirect path\n      const from = location.state?.from?.pathname || '/home'; // Default to /home\n      \n      console.log('Login successful, redirecting to:', from);\n      navigate(from, { replace: true }); // Redirect, replacing history entry\n\n    } catch (error) {\n      console.error('Login failed:', error);\n      // Optionally, set an error message in state to display to the user\n    }\n  };\n\n  return (\n    <div>\n      <h2>Login</h2>\n      <form onSubmit={handleLogin}>\n        <div>\n          <label htmlFor=\"username\">Username:</label>\n          <input \n            id=\"username\" \n            type=\"text\" \n            value={username} \n            onChange={(e) => setUsername(e.target.value)}\n            required\n          />\n        </div>\n        <div>\n          <label htmlFor=\"password\">Password:</label>\n          <input \n            id=\"password\" \n            type=\"password\" \n            value={password} \n            onChange={(e) => setPassword(e.target.value)}\n            required\n          />\n        </div>\n        <button type=\"submit\">Log In</button>\n      </form>\n    </div>\n  );\n}\n\n// App setup for testing\nconst Home = () => <h2>Home Page</h2>;\nconst Dashboard = () => <h2>Dashboard (Protected)</h2>;\n\n// A simple RequireAuth for testing the redirection part\nconst SimpleRequireAuth = ({ children }: { children: React.ReactNode }) => {\n  // In a real scenario, this would check a global auth state\n  const isAuthenticated = false; // Set to true to test direct access, false to test redirect to login\n  const location = useLocation();\n  if (!isAuthenticated) {\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n  return children;\n};\n\nexport default function App() {\n  return (\n    <Router>\n      <nav>\n        <p>\n          <a href=\"/\">Home</a> |\n          <a href=\"/dashboard\">Dashboard (Protected)</a> |\n          <a href=\"/login\">Login</a>\n        </p>\n        <hr/>\n      </nav>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/login\" element={<LoginComponent />} />\n        <Route \n          path=\"/dashboard\" \n          element={\n            <SimpleRequireAuth>\n              <Dashboard />\n            </SimpleRequireAuth>\n          } \n        />\n        {/* Add a /home route for the default redirect */}\n        <Route path=\"/home\" element={<h2>Welcome Home!</h2>} />\n      </Routes>\n    </Router>\n  );\n}\n",
          "testCases": [
            "**Test Case 1: Redirect from Protected Route**\n\t- **Steps:** Navigate directly to `/dashboard`. (The `SimpleRequireAuth` should redirect you to `/login`). Enter credentials and click login.\n\t- **Expected:** After login, you should be redirected to `/dashboard`. The browser's back button should take you to `/` (Home), not `/login`.\n\t- **Reasoning:** `location.state.from` should be `/dashboard`, and `navigate` should use `replace: true`.\n",
            "**Test Case 2: Direct Login to Default Path**\n\t- **Steps:** Navigate directly to `/login`. Enter credentials and click login.\n\t- **Expected:** After login, you should be redirected to `/home`. The browser's back button should take you to `/` (Home), not `/login`.\n\t- **Reasoning:** `location.state.from` should be `undefined`, triggering the fallback to `/home`, and `navigate` should use `replace: true`.\n",
            "**Test Case 3: Invalid Credentials (Optional)**\n\t- **Steps:** Modify `mockSignIn` to reject for specific credentials (e.g., password 'wrong'). Try to log in with these credentials.\n\t- **Expected:** Login should fail (console error) and no redirection should occur. User stays on login page.\n\t- **Reasoning:** `try...catch` block in `handleLogin` should catch errors and prevent redirection on failure."
          ],
          "hints": [
            "Use `useNavigate()` to get the `navigate` function and `useLocation()` to access `location.state`.",
            "The `from` path can be accessed as `location.state?.from?.pathname`. Provide a default path using the `||` operator.",
            "Remember to call `e.preventDefault()` inside `handleLogin` to prevent the browser's default form submission behavior.",
            "Pass `{ replace: true }` as the second argument to the `navigate` function.",
            "Make sure your `mockSignIn` function is `async` and returns a `Promise` so you can `await` it."
          ],
          "tags": [
            "React Router v6",
            "Authentication",
            "Redirection",
            "Forms",
            "Hooks"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_hooks",
            "react_router_v6_basics",
            "asynchronous_javascript",
            "html_forms"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "user_experience",
            "history_api",
            "conditional_rendering"
          ]
        },
        {
          "id": "task_v5_to_v6_migration",
          "title": "Migrate React Router v5 PrivateRoute to v6 RequireAuth",
          "description": "\nYou are given a React application using React Router v5 for private routes and a basic authentication hook. Your task is to migrate the `PrivateRoute` component to the React Router v6 `RequireAuth` pattern, updating the `App` component's routing accordingly.\n\n**Given v5 Code (similar to markdown):**\n```jsx\n// AppV5.jsx\nimport React from 'react';\nimport { BrowserRouter as Router, Switch, Route, Redirect } from 'react-router-dom';\n\nconst useAuthV5 = () => { /* In real app, checks auth */ return false; }; // Simulate logged out\n\nconst PrivateRouteV5 = ({ component: Component, ...rest }) => {\n  const isAuthenticated = useAuthV5();\n  return (\n    <Route\n      {...rest}\n      render={props =>\n        isAuthenticated ? (\n          <Component {...props} />\n        ) : (\n          <Redirect to={{ pathname: '/login', state: { from: props.location } }} />\n        )\n      }\n    />\n  );\n};\n\nconst Home = () => <h2>Home Page (v5)</h2>;\nconst Login = () => <h2>Login Page (v5)</h2>;\nconst Dashboard = () => <h2>Dashboard (Protected, v5)</h2>;\n\nfunction AppV5() {\n  return (\n    <Router>\n      <Switch>\n        <Route path=\"/\" exact component={Home} />\n        <Route path=\"/login\" component={Login} />\n        <PrivateRouteV5 path=\"/dashboard\" component={Dashboard} />\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppV5;\n```\n\n**Your Task:**\n\n1.  **Migrate to React Router v6:** Change all `react-router-dom` imports from v5 to v6 style (`Switch` to `Routes`, `component` to `element`, `Redirect` to `Navigate`).\n2.  **Refactor `PrivateRouteV5` to `RequireAuthV6`:**\n    *   Rename the component to `RequireAuth`.\n    *   Modify its signature to accept `children` instead of `component`.\n    *   Replace `useAuthV5` with a `useAuth` hook that integrates with a simple `AuthContext` (provided in starting code).\n    *   Replace `Redirect` with `Navigate`.\n    *   Ensure `useLocation` is used to pass the `from` state.\n    *   Ensure `replace` prop is used on `Navigate`.\n3.  **Update `App` Component:** Adjust the `<Route>` components to use the `element` prop and wrap protected routes with `<RequireAuth>`. Add a dummy `AuthProvider` if needed.\n\nYour final solution should be a working React Router v6 setup with a functional private route.\n",
          "difficulty": "hard",
          "startingCode": "import React, { createContext, useContext, useState } from 'react';\n// TODO: Update imports to React Router v6\nimport { BrowserRouter as Router, Switch, Route, Redirect } from 'react-router-dom';\n\n// Dummy AuthContext and useAuth hook for v6 pattern\ninterface User { id: number; name: string; }\ninterface AuthContextType { user: User | null; }\nconst AuthContext = createContext<AuthContextType | null>(null);\nconst AuthProvider = ({ children }: { children: React.ReactNode }) => {\n  const [user] = useState<User | null>({ id: 1, name: 'MigratedUser' }); // Simulate logged-in\n  // const [user] = useState<User | null>(null); // Uncomment to simulate logged-out\n  return <AuthContext.Provider value={{ user }}>{children}</AuthContext.Provider>;\n};\nconst useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) throw new Error('useAuth must be used within an AuthProvider');\n  return context;\n};\n\n// --- V5 components to be migrated ---\n\n// V5 Dummy Auth Logic\nconst useAuthV5 = () => { /* In real app, checks auth */ return false; }; // Simulate logged out for migration test\n\n// TODO: Refactor this PrivateRouteV5 to RequireAuth (v6)\nconst PrivateRouteV5 = ({ component: Component, ...rest }) => {\n  const isAuthenticated = useAuthV5();\n  return (\n    <Route\n      {...rest}\n      render={props =>\n        isAuthenticated ? (\n          <Component {...props} />\n        ) : (\n          <Redirect to={{ pathname: '/login', state: { from: props.location } }} />\n        )\n      }\n    />\n  );\n};\n\n// Dummy Components\nconst Home = () => <h2>Home Page</h2>;\nconst Login = () => <h2>Login Page</h2>;\nconst Dashboard = () => <h2>Dashboard (Protected)</h2>;\n\n// TODO: Refactor this AppV5 to App (v6)\nfunction AppV5() {\n  return (\n    <Router>\n      <Switch>\n        <Route path=\"/\" exact component={Home} />\n        <Route path=\"/login\" component={Login} />\n        <PrivateRouteV5 path=\"/dashboard\" component={Dashboard} />\n      </Switch>\n    </Router>\n  );\n}\n\nexport default AppV5;\n",
          "solutionCode": "import React, { createContext, useContext, useState } from 'react';\n// Updated imports for React Router v6\nimport { BrowserRouter as Router, Routes, Route, Navigate, useLocation } from 'react-router-dom';\n\n// Dummy AuthContext and useAuth hook for v6 pattern\ninterface User { id: number; name: string; }\ninterface AuthContextType { user: User | null; }\nconst AuthContext = createContext<AuthContextType | null>(null);\nconst AuthProvider = ({ children }: { children: React.ReactNode }) => {\n  // Simulate logged-in user for demonstration. Change to null for logged-out.\n  const [user] = useState<User | null>({ id: 1, name: 'MigratedUser' }); \n  // const [user] = useState<User | null>(null); // Uncomment to simulate logged-out\n  return <AuthContext.Provider value={{ user }}>{children}</AuthContext.Provider>;\n};\nconst useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) throw new Error('useAuth must be used within an AuthProvider');\n  return context;\n};\n\n// --- Migrated RequireAuth (v6) ---\n\n// Refactored PrivateRouteV5 to RequireAuth (v6)\nfunction RequireAuth({ children }: { children: React.ReactNode }) {\n  const { user } = useAuth(); // Use the new v6-compatible useAuth hook\n  const location = useLocation(); // Get current location with v6 hook\n\n  if (!user) {\n    // Redirect to login page using Navigate component (v6)\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  return children;\n}\n\n// Dummy Components (can remain the same)\nconst Home = () => <h2>Home Page</h2>;\nconst Login = () => <h2>Login Page</h2>;\nconst Dashboard = () => <h2>Dashboard (Protected)</h2>;\n\n// Refactored AppV5 to App (v6)\nexport default function App() {\n  return (\n    <AuthProvider> {/* Wrap the app with AuthProvider */}\n      <Router>\n        <nav>\n          <p>\n            <a href=\"/\">Home</a> |\n            <a href=\"/dashboard\">Dashboard (Protected)</a> |\n            <a href=\"/login\">Login</a>\n          </p>\n          <hr/>\n        </nav>\n        <Routes> {/* Use Routes instead of Switch */}\n          <Route path=\"/\" element={<Home />} /> {/* Use element prop */}\n          <Route path=\"/login\" element={<Login />} />\n          {/* Protect Dashboard Route with RequireAuth (v6 pattern) */}\n          <Route \n            path=\"/dashboard\" \n            element={\n              <RequireAuth>\n                <Dashboard />\n              </RequireAuth>\n            } \n          />\n        </Routes>\n      </Router>\n    </AuthProvider>\n  );\n}\n",
          "testCases": [
            "**Test Case 1: Protected Route Access (Logged Out)**\n\t- **Steps:** In `AuthProvider`, set `user` to `null`. Run the app and navigate to `/dashboard`.\n\t- **Expected:** Should be redirected to `/login` with `/dashboard` stored in `location.state.from`. Browser's back button should go to `/`.\n\t- **Reasoning:** `RequireAuth` should detect `null` user and perform a `Navigate` with `replace`.\n",
            "**Test Case 2: Protected Route Access (Logged In)**\n\t- **Steps:** In `AuthProvider`, set `user` to `{ id: 1, name: 'TestUser' }`. Run the app and navigate to `/dashboard`.\n\t- **Expected:** Should see the 'Dashboard (Protected)' content. No redirection.\n\t- **Reasoning:** `RequireAuth` should detect a non-null user and render its `children`.\n",
            "**Test Case 3: Direct Access to Login**\n\t- **Steps:** Navigate directly to `/login`.\n\t- **Expected:** Should see the 'Login Page' content. `location.state.from` should be undefined (as it wasn't redirected from a protected route).\n\t- **Reasoning:** Basic route matching for `/login` should work."
          ],
          "hints": [
            "Start by changing all `react-router-dom` imports to use v6 components/hooks: `BrowserRouter`, `Routes`, `Route`, `Navigate`, `useLocation`.",
            "`Switch` in v5 becomes `Routes` in v6.",
            "The `component` prop on `Route` in v5 is replaced by the `element` prop in v6, which takes a JSX element (e.g., `element={<Home />}`).",
            "The v6 `RequireAuth` component should take `children` as a prop and conditionally render them or a `Navigate` component.",
            "Remember to use `useLocation()` to get the current location object for passing it in the `state` of `Navigate`.",
            "Don't forget the `replace` prop on the `Navigate` component to prevent unwanted history entries."
          ],
          "tags": [
            "React Router",
            "Migration",
            "Private Routes",
            "Authentication",
            "Hooks"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_router_v5_basics",
            "react_router_v6_basics",
            "react_hooks",
            "react_context_api"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "frontend_migration",
            "api_changes",
            "declarative_ui"
          ]
        }
      ]
    }
  }
]