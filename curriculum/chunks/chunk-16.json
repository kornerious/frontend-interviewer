[
  {
    "id": "019fc46f-d6dc-4e84-94c6-f7ff512f50ef",
    "startLine": 3300,
    "endLine": 3399,
    "processedDate": "2025-06-17T08:42:15.068Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_component_props_conditional_rendering",
          "title": "React Component Props and Conditional Rendering",
          "content": "## React Component Props\nProps (short for properties) are a mechanism for passing data from a parent component to a child component in React. They are read-only, meaning a child component should not modify the props it receives. This immutability helps in maintaining a unidirectional data flow, making applications easier to understand and debug.\n\n### Key Concepts:\n-   **Unidirectional Data Flow**: Data flows down from parent to child components via props.\n-   **Read-Only**: Components must treat props as immutable. They should not modify their own props.\n-   **Passing Data**: Props are passed as attributes in JSX, similar to HTML attributes.\n-   **Accessing Props**: Inside a functional component, props are received as the first argument (an object). In class components, they are accessed via `this.props`.\n\n## Conditional Rendering\nConditional rendering in React allows you to render different elements or components based on certain conditions. This is a powerful way to create dynamic UIs that respond to changes in application state or props.\n\n### Common Techniques:\n-   **`if` statements**: Can be used outside JSX to conditionally return different components or JSX trees.\n-   **Logical `&&` operator**: If the condition is `true`, the element after `&&` will be rendered. If `false`, React ignores and skips the element. This is often used for rendering a block or element only when a certain prop or state is true.\n-   **Ternary operator (`condition ? true_expression : false_expression`)**: Allows rendering one of two different elements based on a condition, useful for inline conditional rendering where you need an `else` branch.\n-   **Element Variables**: Store elements in variables and conditionally assign them, then render the variable.\n\n### Example Scenario:\nImagine a `UserProfile` component that displays user information. Some information, like 'Administrator' status, might only show if a specific condition (e.g., `isAdmin` prop) is met.",
          "examples": [
            {
              "id": "example_props_conditional_rendering_1",
              "title": "Functional Component with Props and Conditional Rendering",
              "code": "import React from 'react';\n\nfunction UserProfile({ name, age, isAdmin }) {\n  return (\n    <div>\n      <h2>{name}</h2>\n      <p>Age: {age}</p>\n      {isAdmin && <p>Administrator</p>} {/* Conditional rendering using logical && */}\n    </div>\n  );\n}\n\n// Usage example:\n// <UserProfile name=\"Alice\" age={25} isAdmin={true} />\n// <UserProfile name=\"Bob\" age={30} isAdmin={false} />",
              "explanation": "This `UserProfile` functional component receives `name`, `age`, and `isAdmin` as props. It uses `isAdmin && <p>Administrator</p>` to conditionally display the 'Administrator' paragraph only if the `isAdmin` prop is `true`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_props_unidirectional_data_flow_1",
            "question_conditional_rendering_mcq_1",
            "question_props_class_vs_functional_1",
            "question_conditional_rendering_logical_and_flashcard_1",
            "question_jsx_conditional_rendering_open_1"
          ],
          "relatedTasks": [
            "task_user_profile_display",
            "task_dynamic_alert_component"
          ],
          "tags": [
            "React",
            "Props",
            "Conditional Rendering",
            "JSX",
            "Functional Components"
          ],
          "technology": "React",
          "prerequisites": [
            "react_component_basics",
            "javascript_es6_destructuring"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_state_management",
            "react_component_composition"
          ]
        },
        {
          "id": "theory_prop_types_default_props",
          "title": "React PropTypes and Default Props",
          "content": "## PropTypes for Type Checking\n`PropTypes` is a library used for runtime type checking of props in React components. It helps in catching bugs early by ensuring that components receive props of the expected data type. While `PropTypes` are great for development, they are often replaced by TypeScript or Flow for static type checking in larger applications, which provide type safety during compilation.\n\n### Key Concepts:\n-   **Runtime Validation**: Checks prop types when the component runs, typically in development mode.\n-   **Error Reporting**: Throws a console warning if an invalid prop type is passed.\n-   **`isRequired`**: Specifies that a prop must be provided.\n-   **Common PropTypes**: `PropTypes.string`, `PropTypes.number`, `PropTypes.bool`, `PropTypes.array`, `PropTypes.object`, `PropTypes.func`, `PropTypes.node`, `PropTypes.element`, `PropTypes.instanceOf`, `PropTypes.oneOf`, `PropTypes.oneOfType`, `PropTypes.arrayOf`, `PropTypes.objectOf`, `PropTypes.shape`, `PropTypes.exact`.\n\n## Default Props\n`defaultProps` allows you to define default values for props. If a parent component does not pass a specific prop, the component will use its default value instead. This ensures that a component always has a value for certain props, preventing `undefined` errors and making components more robust and reusable.\n\n### Key Concepts:\n-   **Fallback Values**: Provides a default value if a prop is not explicitly passed.\n-   **Readability**: Makes component usage clearer by indicating optional props and their default behavior.\n-   **Usage**: Defined as a static property on the component (for class components) or directly on the function (for functional components).",
          "examples": [
            {
              "id": "example_prop_types_default_props_1",
              "title": "PropTypes and Default Props in Functional Components",
              "code": "import PropTypes from 'prop-types';\n\nfunction UserProfile({ name, age, isAdmin }) {\n  return (\n    <div>\n      <h2>{name}</h2>\n      <p>Age: {age}</p>\n      {isAdmin && <p>Administrator</p>}\n    </div>\n  );\n}\n\n// PropTypes for type checking\nUserProfile.propTypes = {\n  name: PropTypes.string.isRequired, // 'name' must be a string and is required\n  age: PropTypes.number,           // 'age' should be a number, optional\n  isAdmin: PropTypes.bool          // 'isAdmin' should be a boolean, optional\n};\n\n// Default props\nUserProfile.defaultProps = {\n  age: 30,         // Default age is 30 if not provided\n  isAdmin: false   // Default isAdmin is false if not provided\n};\n\n// Usage examples:\n// <UserProfile name=\"John Doe\" /> // age will be 30, isAdmin will be false\n// <UserProfile name=\"Jane Smith\" age={28} isAdmin={true} />\n// <UserProfile name={123} /> // Console warning for invalid name type in development",
              "explanation": "This example demonstrates `PropTypes` and `defaultProps` for a functional component. `name` is required and must be a string. `age` and `isAdmin` are optional, with default values if not explicitly passed.",
              "language": "typescript"
            },
            {
              "id": "example_prop_types_default_props_2",
              "title": "PropTypes and Default Props in Class Components",
              "code": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nclass UserProfileClass extends React.Component {\n  static propTypes = {\n    name: PropTypes.string.isRequired,\n    age: PropTypes.number,\n    isAdmin: PropTypes.bool\n  };\n  \n  static defaultProps = {\n    age: 30,\n    isAdmin: false\n  };\n  \n  render() {\n    const { name, age, isAdmin } = this.props;\n    return (\n      <div>\n        <h2>{name}</h2>\n        <p>Age: {age}</p>\n        {isAdmin && <p>Administrator</p>}\n      </div>\n    );\n  }\n}\n\n// Usage example:\n// <UserProfileClass name=\"Mike\" />\n// <UserProfileClass name=\"Sarah\" age={22} isAdmin={true} />",
              "explanation": "In class components, `propTypes` and `defaultProps` are defined as static properties directly on the class. The functionality remains the same as with functional components.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_prop_types_purpose_1",
            "question_default_props_use_case_1",
            "question_prop_types_vs_typescript_1",
            "question_prop_types_isrequired_flashcard_1",
            "question_prop_types_mcq_1",
            "question_default_props_priority_1"
          ],
          "relatedTasks": [
            "task_user_profile_display",
            "task_button_component_with_props_defaults"
          ],
          "tags": [
            "React",
            "PropTypes",
            "DefaultProps",
            "Type Checking",
            "Component Props"
          ],
          "technology": "React",
          "prerequisites": [
            "react_component_basics",
            "javascript_objects"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_testing",
            "react_robust_components"
          ]
        },
        {
          "id": "theory_children_prop",
          "title": "React Children Prop for Content Composition",
          "content": "## React Children Prop\nThe `children` prop is a special prop in React that allows you to pass components, elements, or any content directly into the output of another component. This is a fundamental concept for component composition, enabling the creation of flexible and reusable wrapper or layout components.\n\n### Key Concepts:\n-   **Composition**: Enables components to act as generic 'boxes' that can encapsulate and render arbitrary content passed to them.\n-   **Wrapper Components**: Commonly used for layout components (e.g., `Card`, `Modal`, `Layout`), where the wrapper provides a structure and styling, and the `children` prop renders the inner content.\n-   **Accessing `children`**: Like other props, `children` is accessed via the `props` object in functional components or `this.props` in class components.\n-   **Type of `children`**: Can be a single React element, an array of React elements, a string, a number, a boolean, or `null`/`undefined`. React provides `React.Children` utilities (e.g., `React.Children.map`, `React.Children.forEach`) for processing `children` that might be an opaque data structure.",
          "examples": [
            {
              "id": "example_children_prop_1",
              "title": "Using the Children Prop",
              "code": "import React from 'react';\n\nfunction Card({ title, children }) {\n  return (\n    <div className=\"card\">\n      {title && <h2>{title}</h2>} {/* Optionally render title */}\n      <div className=\"card-content\">\n        {children} {/* Renders whatever is passed between <Card> tags */}\n      </div>\n    </div>\n  );\n}\n\n// Usage example:\n// <Card title=\"Welcome\">\n//   <p>This is the card content.</p>\n//   <button>Click me</button>\n//   <ul>\n//     <li>Item 1</li>\n//     <li>Item 2</li>\n//   </ul>\n// </Card>\n\n// Another usage example (no title):\n// <Card>\n//   <span>Only content here.</span>\n// </Card>",
              "explanation": "The `Card` component accepts a `title` prop and a `children` prop. The `children` prop is rendered inside the `card-content` div, allowing any JSX content to be placed within the `<Card>` tags when it's used.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_children_prop_purpose_1",
            "question_children_prop_type_1",
            "question_children_prop_flexibility_1",
            "question_children_prop_wrapper_flashcard_1",
            "question_children_prop_mcq_1"
          ],
          "relatedTasks": [
            "task_dynamic_card_component",
            "task_layout_wrapper_component"
          ],
          "tags": [
            "React",
            "Children Prop",
            "Component Composition",
            "JSX",
            "Wrapper Components"
          ],
          "technology": "React",
          "prerequisites": [
            "react_component_basics",
            "jsx_syntax"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_hoc",
            "react_render_props_pattern"
          ]
        },
        {
          "id": "theory_react_class_component_state",
          "title": "React State in Class Components",
          "content": "## React State\nState is a built-in object within a React component that is used to contain data or information about the component. Unlike props, which are passed from parent to child and are read-only, state is internal to a component and can be changed over time. When the state of a component changes, React re-renders the component to reflect the new state, along with its child components.\n\n### Key Characteristics of State:\n-   **Internal to a Component**: State is managed within the component itself.\n-   **Mutable**: State can be changed. However, it should only be modified using `setState()` (for class components) or state hooks (for functional components). Direct modification (`this.state.count = 5`) is a common pitfall and will not trigger a re-render.\n-   **Triggers Re-renders**: Any update to the state object causes the component and its children to re-render, ensuring the UI reflects the latest data.\n-   **Asynchronous Updates**: `setState()` calls are often asynchronous for performance optimizations. React may batch multiple `setState()` calls into a single update.\n\n### Initializing State in Class Components\nState in class components is typically initialized within the constructor or using class field syntax.\n\n1.  **Using `constructor(props)`**: The traditional way to initialize state. You must call `super(props)` before accessing `this` to ensure `this.props` is correctly initialized.\n2.  **Using Class Field Syntax**: A more modern and concise way to initialize state. This syntax allows you to declare state as a class property without needing a constructor, making the code cleaner and less verbose. This feature is enabled by Babel's class properties transform and is a popular pattern.",
          "examples": [
            {
              "id": "example_class_component_state_1",
              "title": "State Initialization in Class Components (Constructor)",
              "code": "import React from 'react';\n\nclass CounterWithConstructor extends React.Component {\n  constructor(props) {\n    super(props); // Must call super(props) before anything else\n    this.state = { // Initialize state object\n      count: 0\n    };\n  }\n  \n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        {/* State updates would typically use this.setState() */}\n      </div>\n    );\n  }\n}\n\n// Usage:\n// <CounterWithConstructor />",
              "explanation": "This `CounterWithConstructor` class component initializes its state within the constructor. `this.state` is set to an object containing `count: 0`.",
              "language": "typescript"
            },
            {
              "id": "example_class_component_state_2",
              "title": "State Initialization in Class Components (Class Field Syntax)",
              "code": "import React from 'react';\n\nclass CounterWithClassField extends React.Component {\n  state = { // State initialized directly as a class property\n    count: 0\n  };\n  \n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        {/* State updates would typically use this.setState() */}\n      </div>\n    );\n  }\n}\n\n// Usage:\n// <CounterWithClassField />",
              "explanation": "This `CounterWithClassField` component uses the more modern class field syntax to initialize its state. This avoids the need for a constructor and `super(props)`, resulting in more concise code.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_state_purpose_1",
            "question_state_vs_props_1",
            "question_state_initialization_methods_1",
            "question_state_immutability_flashcard_1",
            "question_state_re_render_mcq_1",
            "question_state_direct_modification_1"
          ],
          "relatedTasks": [
            "task_simple_counter_class_component",
            "task_toggle_visibility_class_component"
          ],
          "tags": [
            "React",
            "State",
            "Class Components",
            "Component Lifecycle",
            "Data Management"
          ],
          "technology": "React",
          "prerequisites": [
            "react_component_basics",
            "javascript_es6_classes"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_component_lifecycle",
            "react_hooks",
            "react_context_api"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_props_unidirectional_data_flow_1",
          "topic": "React Component Props",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary characteristic of React props regarding data flow?",
          "answer": "Props are read-only and enforce a unidirectional data flow (from parent to child).",
          "options": [],
          "analysisPoints": [
            "Tests understanding of core React data flow principles.",
            "Highlights the immutability of props from the child's perspective."
          ],
          "keyConcepts": [
            "Props",
            "Unidirectional Data Flow",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Ability to recall fundamental React principles."
          ],
          "example": "Flashcard for quick recall.",
          "tags": [
            "React",
            "Props",
            "Core Concepts"
          ],
          "prerequisites": [
            "react_component_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_conditional_rendering_mcq_1",
          "topic": "Conditional Rendering",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following React component, what will be rendered if `user.isPremium` is `false`?\n\n```jsx\nfunction UserBadge({ user }) {\n  return (\n    <div>\n      {user.name}\n      {user.isPremium && <span> (Premium User)</span>}\n    </div>\n  );\n}\n```",
          "answer": "Only the user's name will be rendered.",
          "options": [
            "Only the user's name will be rendered.",
            "The user's name followed by `false`.",
            "An empty `div`.",
            "A JavaScript error will occur."
          ],
          "analysisPoints": [
            "Tests understanding of the logical `&&` operator in JSX for conditional rendering.",
            "Confirms knowledge that `false` (or `null`, `undefined`) values are not rendered by React."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "Logical && Operator",
            "JSX"
          ],
          "evaluationCriteria": [
            "Ability to interpret JSX conditional rendering.",
            "Knowledge of how React handles falsy values."
          ],
          "example": "The logical `&&` operator works such that if the left operand (`user.isPremium`) is `false`, the right operand (`<span> (Premium User)</span>`) is not evaluated or rendered. React implicitly handles `false`, `null`, `undefined` and `true` (if a boolean is rendered directly) by not rendering them in the DOM.",
          "tags": [
            "React",
            "Conditional Rendering",
            "JSX",
            "MCQ"
          ],
          "prerequisites": [
            "jsx_syntax"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_props_class_vs_functional_1",
          "topic": "React Component Props",
          "level": "easy",
          "type": "open",
          "question": "How do you access props in a functional component versus a class component in React?",
          "answer": "In a functional component, props are received as the first argument to the function. Destructuring is commonly used for convenience. For example: `function MyComponent({ prop1, prop2 }) { ... }`.\n\nIn a class component, props are accessed via `this.props`. For example: `class MyComponent extends React.Component { render() { return <p>{this.props.prop1}</p>; } }`.",
          "options": [],
          "analysisPoints": [
            "Evaluates basic syntax knowledge for both component types.",
            "Checks understanding of `this` context in class components."
          ],
          "keyConcepts": [
            "Props",
            "Functional Components",
            "Class Components",
            "Destructuring"
          ],
          "evaluationCriteria": [
            "Correctly identifying prop access methods for both component types.",
            "Clarity of explanation."
          ],
          "example": null,
          "tags": [
            "React",
            "Props",
            "Functional vs Class",
            "Syntax"
          ],
          "prerequisites": [
            "react_component_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_jsx_conditional_rendering_open_1",
          "topic": "Conditional Rendering",
          "level": "medium",
          "type": "open",
          "question": "Describe at least three different methods for implementing conditional rendering in React JSX, providing a small code snippet for each.",
          "answer": "1.  **Logical `&&` Operator**: Used when you want to render something only if a condition is true.\n    ```jsx\n    {isLoggedIn && <p>Welcome back!</p>}\n    ```\n\n2.  **Ternary Operator**: Used when you need to render one of two different things based on a condition (an `if-else` equivalent).\n    ```jsx\n    {isLoading ? <p>Loading...</p> : <MyDataComponent data={data} />}\n    ```\n\n3.  **Immediately Invoked Function Expression (IIFE) or Helper Function**: For more complex conditions or when you want to encapsulate logic.\n    ```jsx\n    {(() => {\n      if (user.role === 'admin') {\n        return <AdminPanel />;\n      } else if (user.role === 'editor') {\n        return <EditorPanel />;\n      } else {\n        return <GuestView />;\n      }\n    })()}\n    ```\n    Or using a helper function:\n    ```jsx\n    function renderContent() {\n      if (user.role === 'admin') return <AdminPanel />;\n      if (user.role === 'editor') return <EditorPanel />;\n      return <GuestView />;\n    }\n    return <div>{renderContent()}</div>;\n    ```",
          "options": [],
          "analysisPoints": [
            "Evaluates knowledge of common React conditional rendering patterns.",
            "Checks ability to provide practical code examples.",
            "Assesses understanding of scenarios for each method."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "JSX",
            "Logical &&",
            "Ternary Operator",
            "IIFE"
          ],
          "evaluationCriteria": [
            "Accuracy and variety of methods provided.",
            "Correctness and clarity of code snippets.",
            "Demonstration of practical application."
          ],
          "example": null,
          "tags": [
            "React",
            "Conditional Rendering",
            "JSX",
            "Best Practices"
          ],
          "prerequisites": [
            "jsx_syntax"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_prop_types_purpose_1",
          "topic": "PropTypes",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of `PropTypes` in React?",
          "answer": "`PropTypes` are used for runtime type checking of props passed to React components, primarily in development mode, to help catch bugs related to incorrect data types.",
          "options": [],
          "analysisPoints": [
            "Tests recall of `PropTypes`' role.",
            "Emphasizes its development-time utility."
          ],
          "keyConcepts": [
            "PropTypes",
            "Type Checking",
            "Development Tools"
          ],
          "evaluationCriteria": [
            "Ability to define `PropTypes`' function succinctly."
          ],
          "example": "Flashcard for quick recall.",
          "tags": [
            "React",
            "PropTypes",
            "Debugging"
          ],
          "prerequisites": [
            "react_component_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_default_props_use_case_1",
          "topic": "Default Props",
          "level": "medium",
          "type": "open",
          "question": "When would you use `defaultProps` in a React component, and how does it improve component reusability?",
          "answer": "`defaultProps` are used when you want to provide fallback values for props that might not always be explicitly passed by the parent component. This makes the component more robust and less prone to errors (e.g., `undefined` values).\n\nIt improves reusability by:\n1.  **Reducing Boilerplate**: Users of the component don't need to pass common or optional props every time, simplifying usage.\n2.  **Ensuring Consistency**: Guarantees that certain props always have a value, leading to predictable behavior and rendering, even if a parent forgets to pass them.\n3.  **Clearer API**: The component's interface becomes clearer, as optional props and their default behaviors are explicitly defined.",
          "options": [],
          "analysisPoints": [
            "Explains the 'why' behind `defaultProps`.",
            "Connects `defaultProps` to software design principles like reusability and robustness."
          ],
          "keyConcepts": [
            "DefaultProps",
            "Component Reusability",
            "Robustness"
          ],
          "evaluationCriteria": [
            "Understanding of `defaultProps`' practical benefits.",
            "Ability to articulate improvements in reusability."
          ],
          "example": null,
          "tags": [
            "React",
            "DefaultProps",
            "Component Design",
            "Best Practices"
          ],
          "prerequisites": [
            "react_component_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_prop_types_vs_typescript_1",
          "topic": "PropTypes",
          "level": "hard",
          "type": "open",
          "question": "Discuss the advantages of using TypeScript (or Flow) for type checking React props compared to `PropTypes`.",
          "answer": "While `PropTypes` provide runtime type checking in development mode, TypeScript (or Flow) offer **static type checking** during development and compilation, providing several key advantages:\n\n1.  **Early Error Detection**: TypeScript catches type errors before the code even runs, often right in the IDE, reducing development time and preventing bugs from reaching production.\n2.  **Improved Developer Experience**: IDEs provide better autocompletion, refactoring tools, and inline documentation based on static types, making coding faster and more reliable.\n3.  **Enhanced Code Readability and Maintainability**: Type definitions serve as clear documentation for component APIs, making it easier for other developers (or your future self) to understand how to use a component and what data it expects.\n4.  **No Runtime Overhead**: Unlike `PropTypes`, which add some runtime overhead (even if only in development), static type checkers do their work at compile time and are stripped out in the final bundle, resulting in smaller, faster production code.\n5.  **Stronger Guarantees**: TypeScript offers a more comprehensive type system capable of expressing complex types (e.g., union types, intersection types, generics), leading to stronger type guarantees across the entire application, not just at component boundaries.",
          "options": [],
          "analysisPoints": [
            "Compares runtime vs. static type checking.",
            "Highlights benefits for DX, maintainability, and performance.",
            "Demonstrates understanding of modern frontend development practices."
          ],
          "keyConcepts": [
            "PropTypes",
            "TypeScript",
            "Static Type Checking",
            "Runtime Type Checking",
            "Developer Experience"
          ],
          "evaluationCriteria": [
            "Depth of comparison between two type-checking mechanisms.",
            "Ability to articulate specific advantages of static typing."
          ],
          "example": null,
          "tags": [
            "React",
            "PropTypes",
            "TypeScript",
            "Type Checking",
            "Comparison"
          ],
          "prerequisites": [
            "javascript_types",
            "typescript_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_prop_types_isrequired_flashcard_1",
          "topic": "PropTypes",
          "level": "easy",
          "type": "flashcard",
          "question": "What does `.isRequired` signify when used with a `PropTypes` definition?",
          "answer": "It signifies that the corresponding prop must be provided to the component; if not, React will issue a console warning in development mode.",
          "options": [],
          "analysisPoints": [
            "Tests recall of a specific `PropTypes` modifier."
          ],
          "keyConcepts": [
            "PropTypes",
            "isRequired",
            "Prop Validation"
          ],
          "evaluationCriteria": [
            "Correctly identifies the purpose of `isRequired`."
          ],
          "example": "Flashcard for quick recall.",
          "tags": [
            "React",
            "PropTypes",
            "Validation"
          ],
          "prerequisites": [
            "react_prop_types_default_props"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_prop_types_mcq_1",
          "topic": "PropTypes",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following `PropTypes` definitions correctly makes the `price` prop a required number and the `currency` prop an optional string?",
          "answer": "```javascript\nMyComponent.propTypes = {\n  price: PropTypes.number.isRequired,\n  currency: PropTypes.string\n};\n```",
          "options": [
            "```javascript\nMyComponent.propTypes = {\n  price: PropTypes.number.isRequired,\n  currency: PropTypes.string\n};\n```",
            "```javascript\nMyComponent.propTypes = {\n  price: PropTypes.required.number,\n  currency: PropTypes.string.optional\n};\n```",
            "```javascript\nMyComponent.propTypes = {\n  price: PropTypes.numeric.isRequired,\n  currency: PropTypes.text\n};\n```",
            "```javascript\nMyComponent.propTypes = {\n  price: PropTypes.number,\n  currency: PropTypes.string.isRequired\n};\n```"
          ],
          "analysisPoints": [
            "Tests knowledge of `PropTypes` syntax.",
            "Confirms understanding of `.isRequired` placement and common prop types.",
            "Distinguishes correct `PropTypes` usage from incorrect or non-existent properties."
          ],
          "keyConcepts": [
            "PropTypes",
            "isRequired",
            "Syntax"
          ],
          "evaluationCriteria": [
            "Ability to correctly apply `PropTypes` syntax for specific requirements."
          ],
          "example": "The correct option shows `PropTypes.number.isRequired` for a required number and `PropTypes.string` for an optional string. The other options contain incorrect syntax or misinterpret the requirements.",
          "tags": [
            "React",
            "PropTypes",
            "MCQ",
            "Syntax"
          ],
          "prerequisites": [
            "react_prop_types_default_props"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_default_props_priority_1",
          "topic": "Default Props",
          "level": "medium",
          "type": "code",
          "question": "Consider the following component with `defaultProps`:\n\n```jsx\nfunction Button({ text, color }) {\n  return <button style={{ backgroundColor: color }}>{text}</button>;\n}\n\nButton.defaultProps = {\n  text: 'Click Me',\n  color: 'blue'\n};\n\n// How would you render this component so that it displays 'Submit' and has a red background?\n// What would be the background color if no `color` prop is passed, but `text` is 'Go'?\n```",
          "answer": "To display 'Submit' and have a red background:\n```jsx\n<Button text=\"Submit\" color=\"red\" />\n```\n\nIf no `color` prop is passed but `text` is 'Go':\n```jsx\n<Button text=\"Go\" />\n```\nIn this case, the background color would be **'blue'**. `defaultProps` only apply when a prop is `undefined`. If a prop is explicitly passed (even `null`), `defaultProps` are overridden.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of how `defaultProps` are overridden by explicit props.",
            "Confirms knowledge of the precedence of props over default values."
          ],
          "keyConcepts": [
            "DefaultProps",
            "Props Precedence",
            "Component Usage"
          ],
          "evaluationCriteria": [
            "Correctly demonstrating how to override default props.",
            "Accurately predicting behavior when a prop is omitted."
          ],
          "example": null,
          "tags": [
            "React",
            "DefaultProps",
            "Coding"
          ],
          "prerequisites": [
            "react_prop_types_default_props"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_children_prop_purpose_1",
          "topic": "Children Prop",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `children` prop in React?",
          "answer": "The `children` prop allows components to act as generic containers and render any content passed between their opening and closing JSX tags.",
          "options": [],
          "analysisPoints": [
            "Tests recall of the `children` prop's fundamental role.",
            "Emphasizes its use for content composition."
          ],
          "keyConcepts": [
            "Children Prop",
            "Component Composition",
            "JSX"
          ],
          "evaluationCriteria": [
            "Ability to explain the `children` prop's purpose concisely."
          ],
          "example": "Flashcard for quick recall.",
          "tags": [
            "React",
            "Children Prop",
            "Core Concepts"
          ],
          "prerequisites": [
            "react_component_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_children_prop_type_1",
          "topic": "Children Prop",
          "level": "medium",
          "type": "open",
          "question": "What types of content can be passed as `children` to a React component?",
          "answer": "The `children` prop can be:\n-   A **single React element**: e.g., `<MyWrapper><h1>Hello</h1></MyWrapper>`\n-   An **array of React elements**: e.g., `<MyList><li>One</li><li>Two</li></MyList>`\n-   A **string or number**: e.g., `<TextWrapper>Hello World</TextWrapper>` or `<DisplayValue>{123}</DisplayValue>`\n-   A **boolean, `null`, or `undefined`**: These are generally ignored and not rendered by React, useful for conditional rendering.\n-   A **function**: Though less common for simple content, the render props pattern uses functions as children for more advanced composition.",
          "options": [],
          "analysisPoints": [
            "Tests detailed knowledge of the `children` prop's flexibility.",
            "Covers various data types and their implications."
          ],
          "keyConcepts": [
            "Children Prop",
            "JSX",
            "Data Types",
            "Render Props"
          ],
          "evaluationCriteria": [
            "Comprehensive list of content types.",
            "Accuracy of descriptions for each type."
          ],
          "example": null,
          "tags": [
            "React",
            "Children Prop",
            "JSX",
            "Advanced Topics"
          ],
          "prerequisites": [
            "jsx_syntax"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_children_prop_flexibility_1",
          "topic": "Children Prop",
          "level": "medium",
          "type": "code",
          "question": "You need to create a `Panel` component that can optionally display a header and always renders content passed into it. Implement this `Panel` component and show an example of its usage where it has a header and some paragraphs as children.",
          "answer": "```jsx\nimport React from 'react';\n\nfunction Panel({ header, children }) {\n  return (\n    <div style={{\n      border: '1px solid #ccc',\n      padding: '15px',\n      borderRadius: '5px'\n    }}>\n      {header && <h3 style={{ marginTop: 0, color: '#333' }}>{header}</h3>}\n      <div style={{ padding: '10px 0' }}>\n        {children}\n      </div>\n    </div>\n  );\n}\n\n// Usage Example:\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Panel header=\"My Awesome Panel\">\n        <p>This is the first paragraph of content.</p>\n        <p>And this is the second, demonstrating `children` flexibility.</p>\n        <ul>\n          <li>Item 1</li>\n          <li>Item 2</li>\n        </ul>\n        <button>Learn More</button>\n      </Panel>\n      <br/>\n      <Panel>\n        <p>This panel has no header, only children content.</p>\n      </Panel>\n    </div>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to correctly use and render the `children` prop.",
            "Demonstrates conditional rendering of the header.",
            "Shows practical component composition."
          ],
          "keyConcepts": [
            "Children Prop",
            "Conditional Rendering",
            "Component Composition"
          ],
          "evaluationCriteria": [
            "Correct implementation of the `Panel` component.",
            "Proper usage of `children` and `header` props.",
            "Clear and runnable usage example."
          ],
          "example": null,
          "tags": [
            "React",
            "Children Prop",
            "Coding",
            "Component Design"
          ],
          "prerequisites": [
            "react_component_basics",
            "conditional_rendering"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_children_prop_wrapper_flashcard_1",
          "topic": "Children Prop",
          "level": "easy",
          "type": "flashcard",
          "question": "When building a 'wrapper' component (e.g., a layout container or a modal), which prop is most commonly used to pass the inner content?",
          "answer": "The `children` prop.",
          "options": [],
          "analysisPoints": [
            "Tests direct recall of the common use case for `children`.",
            "Connects the concept to practical component design patterns."
          ],
          "keyConcepts": [
            "Children Prop",
            "Wrapper Components",
            "Component Patterns"
          ],
          "evaluationCriteria": [
            "Correctly identifies the `children` prop for wrapper components."
          ],
          "example": "Flashcard for quick recall.",
          "tags": [
            "React",
            "Children Prop",
            "Design Patterns"
          ],
          "prerequisites": [
            "react_children_prop"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_children_prop_mcq_1",
          "topic": "Children Prop",
          "level": "medium",
          "type": "mcq",
          "question": "Given the `Layout` component:\n\n```jsx\nfunction Layout({ title, children }) {\n  return (\n    <div className=\"container\">\n      <h1>{title}</h1>\n      <main>{children}</main>\n    </div>\n  );\n}\n\n// Which of the following uses of the Layout component will correctly render a paragraph 'Welcome!' inside the <main> tag?\n```",
          "answer": "```jsx\n<Layout title=\"My Page\">\n  <p>Welcome!</p>\n</Layout>\n```",
          "options": [
            "```jsx\n<Layout title=\"My Page\" children={<p>Welcome!</p>} />\n```",
            "```jsx\n<Layout title=\"My Page\">\n  <p>Welcome!</p>\n</Layout>\n```",
            "```jsx\n<Layout title=\"My Page\" content={<p>Welcome!</p>} />\n```",
            "```jsx\n<Layout title=\"My Page\">'Welcome!'</Layout>\n```"
          ],
          "analysisPoints": [
            "Tests understanding of the syntactic way `children` are passed in JSX.",
            "Distinguishes between passing `children` as an explicit prop vs. nested JSX."
          ],
          "keyConcepts": [
            "Children Prop",
            "JSX Syntax",
            "Component Usage"
          ],
          "evaluationCriteria": [
            "Correctly identifies the standard way to pass `children` content in JSX."
          ],
          "example": "The `children` prop is special because its content is literally what's placed between the opening and closing tags of the component (`<Layout>...</Layout>`). Option A attempts to pass `children` as a named prop, which is not the idiomatic way for the `children` prop. Option C uses a different prop name (`content`). Option D passes a string, which would render correctly but specifically asks for a *paragraph*.",
          "tags": [
            "React",
            "Children Prop",
            "MCQ",
            "Syntax"
          ],
          "prerequisites": [
            "react_children_prop"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_state_purpose_1",
          "topic": "React State",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of `state` in a React component?",
          "answer": "`State` is an internal, mutable object in a component that holds data that can change over time and triggers re-renders when updated, allowing components to be dynamic.",
          "options": [],
          "analysisPoints": [
            "Tests recall of state's definition and primary function.",
            "Highlights key characteristics: internal, mutable, re-render trigger."
          ],
          "keyConcepts": [
            "State",
            "Re-render",
            "Mutability",
            "Internal Data"
          ],
          "evaluationCriteria": [
            "Ability to define `state`'s purpose clearly."
          ],
          "example": "Flashcard for quick recall.",
          "tags": [
            "React",
            "State",
            "Core Concepts"
          ],
          "prerequisites": [
            "react_component_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_state_vs_props_1",
          "topic": "React State vs Props",
          "level": "medium",
          "type": "open",
          "question": "Explain the fundamental differences between `props` and `state` in React components.",
          "answer": "**Props (Properties):**\n-   **Purpose**: Used to pass data from a parent component to a child component.\n-   **Mutability**: Are read-only. A child component cannot modify the props it receives.\n-   **Scope**: External to the component; they are inputs from the parent.\n-   **Control**: Controlled by the parent component.\n-   **Data Flow**: Unidirectional (data flows down the component tree).\n\n**State:**\n-   **Purpose**: Used to manage data that is internal to a component and can change over time.\n-   **Mutability**: Is mutable, but should only be updated using `setState()` (class components) or state hooks (functional components). Direct modification (`this.state.x = y`) will not trigger a re-render.\n-   **Scope**: Internal to the component.\n-   **Control**: Controlled by the component itself.\n-   **Data Flow**: Managed within the component, affecting its own rendering.",
          "options": [],
          "analysisPoints": [
            "Compares purpose, mutability, scope, control, and data flow.",
            "Highlights the distinct roles of `props` and `state`."
          ],
          "keyConcepts": [
            "State",
            "Props",
            "Mutability",
            "Unidirectional Data Flow",
            "Component Data Management"
          ],
          "evaluationCriteria": [
            "Comprehensive and accurate comparison of `props` and `state` attributes."
          ],
          "example": null,
          "tags": [
            "React",
            "State",
            "Props",
            "Comparison",
            "Core Concepts"
          ],
          "prerequisites": [
            "react_component_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_initialization_methods_1",
          "topic": "React State (Class Components)",
          "level": "medium",
          "type": "code",
          "question": "In a React class component, demonstrate two different ways to initialize `state` with an initial `count` of `0`.",
          "answer": "1.  **Using the `constructor` method:**\n    ```jsx\n    import React from 'react';\n\n    class CounterA extends React.Component {\n      constructor(props) {\n        super(props);\n        this.state = {\n          count: 0\n        };\n      }\n\n      render() {\n        return <p>Count: {this.state.count}</p>;\n      }\n    }\n    ```\n\n2.  **Using Class Field Syntax:**\n    ```jsx\n    import React from 'react';\n\n    class CounterB extends React.Component {\n      state = {\n        count: 0\n      };\n\n      render() {\n        return <p>Count: {this.state.count}</p>;\n      }\n    }\n    ```",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of state initialization patterns in class components.",
            "Demonstrates familiarity with both older (`constructor`) and newer (class fields) syntaxes."
          ],
          "keyConcepts": [
            "State Initialization",
            "Class Components",
            "Constructor",
            "Class Fields"
          ],
          "evaluationCriteria": [
            "Correctly implements both initialization methods.",
            "Proper React class component structure."
          ],
          "example": null,
          "tags": [
            "React",
            "State",
            "Class Components",
            "Coding"
          ],
          "prerequisites": [
            "javascript_es6_classes"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_immutability_flashcard_1",
          "topic": "React State",
          "level": "medium",
          "type": "flashcard",
          "question": "True or False: You should directly modify `this.state` in a React class component (e.g., `this.state.count = 5`).",
          "answer": "False. You should never directly modify `this.state`. Instead, use `this.setState()` to ensure the component re-renders and React can properly manage state updates.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of state immutability principles in React.",
            "Highlights a critical best practice and common mistake."
          ],
          "keyConcepts": [
            "State Immutability",
            "setState()",
            "Re-rendering"
          ],
          "evaluationCriteria": [
            "Correctly identifies the best practice for state updates."
          ],
          "example": "Flashcard for quick recall.",
          "tags": [
            "React",
            "State",
            "Best Practices",
            "Immutability"
          ],
          "prerequisites": [
            "react_class_component_state"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_re_render_mcq_1",
          "topic": "React State",
          "level": "medium",
          "type": "mcq",
          "question": "What is the consequence of calling `this.setState()` in a React class component?",
          "answer": "It queues a re-render of the component and its children.",
          "options": [
            "It immediately re-renders the component synchronously.",
            "It only updates the state object, but doesn't trigger a re-render.",
            "It queues a re-render of the component and its children.",
            "It only re-renders the component if the state value actually changes."
          ],
          "analysisPoints": [
            "Tests understanding of `setState()`'s effect on the component lifecycle.",
            "Distinguishes synchronous vs. asynchronous behavior.",
            "Clarifies that `setState` queues a re-render regardless of value comparison (though React might optimize if values are identical, the *queueing* is the direct effect)."
          ],
          "keyConcepts": [
            "State Updates",
            "setState()",
            "Re-rendering",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Accurately describes the primary effect of `setState()`."
          ],
          "example": "Calling `this.setState()` tells React that the component's state has changed, and it needs to update the UI. React then efficiently schedules and batches these updates, leading to a re-render of the component and its subtree.",
          "tags": [
            "React",
            "State",
            "setState",
            "MCQ",
            "Lifecycle"
          ],
          "prerequisites": [
            "react_class_component_state"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_direct_modification_1",
          "topic": "React State",
          "level": "hard",
          "type": "code",
          "question": "Analyze the following React class component. Explain why directly modifying `this.state.count++` is problematic and propose a corrected version using `this.setState()`.",
          "answer": "```jsx\nimport React from 'react';\n\nclass ProblematicCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    // Problematic: Direct modification of state\n    this.state.count++; \n    console.log(this.state.count); // State *is* updated here\n    // BUT, React doesn't know about this change, so it won't re-render.\n    // The UI will not reflect the new count until another state update happens.\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleClick}>Increment</button>\n      </div>\n    );\n  }\n}\n```\n\n**Explanation of the problem:**\nDirectly modifying `this.state.count++` is problematic because React's change detection mechanism relies on `this.setState()` to know when to re-render the component. When you directly mutate `this.state`, React doesn't detect a change, and therefore the `render()` method is not called, and the UI does not update to reflect the new state value.\n\n**Corrected Version:**\n```jsx\nimport React from 'react';\n\nclass CorrectedCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    // Correct: Use setState to update state and trigger re-render\n    this.setState(prevState => ({ // Using functional setState for reliable updates\n      count: prevState.count + 1\n    }));\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleClick}>Increment</button>\n      </div>\n    );\n  }\n}\n```\n\n**Reason for correction:**\nBy using `this.setState()`, we explicitly tell React that the state has changed. React then re-runs the `render()` method with the updated state, ensuring the UI is synchronized with the data. Using the functional form of `setState` (`prevState => ({ ... })`) is also best practice when the new state depends on the previous state, preventing issues with asynchronous updates.",
          "options": [],
          "analysisPoints": [
            "Identifies the core issue of direct state mutation.",
            "Explains *why* direct mutation is problematic (lack of re-render trigger).",
            "Provides a correct solution using `this.setState()`.",
            "Applies best practices for `setState` (functional update).",
            "Demonstrates understanding of React's rendering lifecycle."
          ],
          "keyConcepts": [
            "State Immutability",
            "setState()",
            "Re-rendering",
            "Class Components",
            "Functional setState"
          ],
          "evaluationCriteria": [
            "Accurate diagnosis of the problem.",
            "Correct and idiomatic solution.",
            "Clear explanation of cause and effect."
          ],
          "example": null,
          "tags": [
            "React",
            "State",
            "Best Practices",
            "Debugging",
            "Coding"
          ],
          "prerequisites": [
            "react_class_component_state"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_user_profile_display",
          "title": "Build a User Profile Card with Dynamic Content and Validation",
          "description": "\nCreate a `UserProfileCard` React functional component that displays user information. The component should meet the following requirements:\n\n1.  Accepts `name` (string, required), `age` (number, optional), and `status` (string, optional, default to 'Active') as props.\n2.  Display the user's name in an `<h2>` tag.\n3.  Display the user's age in a `<p>` tag, but only if the `age` prop is provided and is a positive number.\n4.  Display the user's `status` in a separate `<p>` tag.\n5.  Use `PropTypes` for prop validation and `defaultProps` for default values.\n6.  If `name` is missing or not a string, the component should log an error to the console (handled by PropTypes).\n\nYour solution should demonstrate proper use of props, conditional rendering, PropTypes, and defaultProps.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction UserProfileCard({ name, age, status }) {\n  // TODO: Implement the component logic here\n  // 1. Display name\n  // 2. Conditionally display age if valid\n  // 3. Display status\n  return (\n    <div style={{\n      border: '1px solid #eee',\n      padding: '15px',\n      margin: '10px',\n      borderRadius: '8px',\n      boxShadow: '0 2px 4px rgba(0,0,0,0.1)'\n    }}>\n      {/* Your JSX here */}\n    </div>\n  );\n}\n\n// TODO: Add PropTypes and defaultProps here\n\n// Example Usage (for testing):\n// function App() {\n//   return (\n//     <div>\n//       <UserProfileCard name=\"Alice Wonderland\" age={30} status=\"Admin\" />\n//       <UserProfileCard name=\"Bob The Builder\" age={-5} /> {/* Invalid age, should not display */}\n//       <UserProfileCard name=\"Charlie\" /> {/* Uses default age and status */}\n//       <UserProfileCard name={123} age={25} /> {/* Type error for name via PropTypes */}\n//       <UserProfileCard age={40} /> {/* Missing required name via PropTypes */}\n//     </div>\n//   );\n// }\n\n// export default App;\n",
          "solutionCode": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction UserProfileCard({ name, age, status }) {\n  return (\n    <div style={{\n      border: '1px solid #eee',\n      padding: '15px',\n      margin: '10px',\n      borderRadius: '8px',\n      boxShadow: '0 2px 4px rgba(0,0,0,0.1)'\n    }}>\n      <h2>{name}</h2>\n      {age > 0 && <p>Age: {age}</p>} {/* Conditional rendering for age */}\n      <p>Status: {status}</p>\n    </div>\n  );\n}\n\nUserProfileCard.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number,\n  status: PropTypes.string\n};\n\nUserProfileCard.defaultProps = {\n  age: 30, // Default age\n  status: 'Active' // Default status\n};\n\n// Example Usage:\n// function App() {\n//   return (\n//     <div>\n//       <UserProfileCard name=\"Alice Wonderland\" age={30} status=\"Admin\" />\n//       <UserProfileCard name=\"Bob The Builder\" age={-5} /> \n//       <UserProfileCard name=\"Charlie\" /> \n//       <UserProfileCard name={123} age={25} /> \n//       <UserProfileCard age={40} /> \n//     </div>\n//   );\n// }\n\n// export default App;\n",
          "testCases": [
            "Render with all props: `UserProfileCard name=\"Alice\" age={25} status=\"Active\"` should display all details correctly.",
            "Render with missing optional props: `UserProfileCard name=\"Bob\"` should use default age (30) and status ('Active').",
            "Render with invalid age: `UserProfileCard name=\"Charlie\" age={-10}` should display name and status, but no age.",
            "Test `isRequired` for `name`: `UserProfileCard age={20}` should log a PropTypes warning for missing name.",
            "Test type mismatch for `name`: `UserProfileCard name={123}` should log a PropTypes warning for invalid name type."
          ],
          "hints": [
            "Remember to use the `&&` operator for conditional rendering of the age if it's positive.",
            "PropTypes and defaultProps are static properties on the functional component itself.",
            "Ensure the `age` prop check (`age > 0`) is robust enough for invalid number inputs as well as undefined."
          ],
          "tags": [
            "React",
            "Props",
            "Conditional Rendering",
            "PropTypes",
            "DefaultProps",
            "Component Design"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_component_basics",
            "jsx_syntax",
            "javascript_conditional_logic"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_component_props_conditional_rendering",
            "theory_prop_types_default_props"
          ]
        },
        {
          "id": "task_button_component_with_props_defaults",
          "title": "Create a Configurable Button Component",
          "description": "\nDevelop a `Button` functional component that is highly configurable using props and sensible defaults.\n\n1.  The button should accept `label` (string, required) for its text content.\n2.  It should accept `onClick` (function, optional) for an event handler.\n3.  It should accept `variant` (string, optional) which can be 'primary', 'secondary', or 'danger'. Default to 'primary'.\n4.  It should accept `disabled` (boolean, optional). Default to `false`.\n5.  Apply basic inline styles based on the `variant`:\n    *   'primary': blue background, white text\n    *   'secondary': gray background, black text\n    *   'danger': red background, white text\n6.  Apply styles for `disabled` state: lighter background, cursor `not-allowed`.\n7.  Use `PropTypes` for validation and `defaultProps` for default values.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst BUTTON_VARIANTS = {\n  primary: { backgroundColor: 'blue', color: 'white' },\n  secondary: { backgroundColor: 'lightgray', color: 'black' },\n  danger: { backgroundColor: 'red', color: 'white' }\n};\n\nconst DISABLED_STYLE = { opacity: 0.6, cursor: 'not-allowed' };\n\nfunction Button({ label, onClick, variant, disabled }) {\n  // TODO: Implement button logic and styling based on props\n  // 1. Determine base style based on variant\n  // 2. Apply disabled style if prop is true\n  // 3. Attach onClick handler if provided and not disabled\n  \n  const baseStyle = BUTTON_VARIANTS[variant] || BUTTON_VARIANTS.primary;\n  const buttonStyle = disabled ? { ...baseStyle, ...DISABLED_STYLE } : baseStyle;\n\n  return (\n    <button \n      style={{ padding: '10px 20px', borderRadius: '5px', border: 'none', ...buttonStyle }}\n      onClick={!disabled ? onClick : undefined} // Only attach onClick if not disabled\n      disabled={disabled}\n    >\n      {label}\n    </button>\n  );\n}\n\n// TODO: Add PropTypes and defaultProps\n\n// Example Usage (for testing):\n// function App() {\n//   const handleClick = () => alert('Button clicked!');\n//   return (\n//     <div>\n//       <Button label=\"Primary Button\" onClick={handleClick} />\n//       <Button label=\"Secondary\" variant=\"secondary\" />\n//       <Button label=\"Delete\" variant=\"danger\" onClick={handleClick} disabled={false} />\n//       <Button label=\"Disabled\" disabled={true} onClick={handleClick} />\n//     </div>\n//   );\n// }\n\n// export default App;\n",
          "solutionCode": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst BUTTON_VARIANTS = {\n  primary: { backgroundColor: 'blue', color: 'white' },\n  secondary: { backgroundColor: 'lightgray', color: 'black' },\n  danger: { backgroundColor: 'red', color: 'white' }\n};\n\nconst DISABLED_STYLE = { opacity: 0.6, cursor: 'not-allowed' };\n\nfunction Button({ label, onClick, variant, disabled }) {\n  const baseStyle = BUTTON_VARIANTS[variant] || BUTTON_VARIANTS.primary;\n  const buttonStyle = disabled ? { ...baseStyle, ...DISABLED_STYLE } : baseStyle;\n\n  return (\n    <button \n      style={{ padding: '10px 20px', borderRadius: '5px', border: 'none', ...buttonStyle }}\n      onClick={!disabled ? onClick : undefined}\n      disabled={disabled}\n    >\n      {label}\n    </button>\n  );\n}\n\nButton.propTypes = {\n  label: PropTypes.string.isRequired,\n  onClick: PropTypes.func,\n  variant: PropTypes.oneOf(Object.keys(BUTTON_VARIANTS)), // Restrict variant to defined keys\n  disabled: PropTypes.bool\n};\n\nButton.defaultProps = {\n  onClick: () => {},\n  variant: 'primary',\n  disabled: false\n};\n\n// Example Usage:\n// function App() {\n//   const handleClick = () => alert('Button clicked!');\n//   return (\n//     <div>\n//       <Button label=\"Primary Button\" onClick={handleClick} />\n//       <Button label=\"Secondary\" variant=\"secondary\" />\n//       <Button label=\"Delete\" variant=\"danger\" onClick={handleClick} disabled={false} />\n//       <Button label=\"Disabled\" disabled={true} onClick={handleClick} />\n//     </div>\n//   );\n// }\n\n// export default App;\n",
          "testCases": [
            "Render a default button: `Button label=\"Submit\"` should be blue, 'Click Me' text.",
            "Render a secondary button: `Button label=\"Cancel\" variant=\"secondary\"` should be gray.",
            "Render a disabled danger button: `Button label=\"Remove\" variant=\"danger\" disabled={true}` should be red (lighter), disabled, and not trigger `onClick`.",
            "Test `onClick` functionality for an enabled button.",
            "Test `PropTypes` for an invalid `variant` (e.g., `variant=\"unknown\"`) should log a warning.",
            "Test `PropTypes` for missing required `label`."
          ],
          "hints": [
            "Use `PropTypes.oneOf` to restrict the `variant` prop to a specific set of strings.",
            "The `disabled` HTML attribute automatically prevents `onClick` but also visually disables. You might also want to conditionally apply `onClick` based on the `disabled` prop.",
            "Remember to merge styles using the spread operator (`{...style1, ...style2}`) to apply both base and disabled styles."
          ],
          "tags": [
            "React",
            "Props",
            "DefaultProps",
            "PropTypes",
            "Styling",
            "Event Handling",
            "Component Design"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_component_basics",
            "jsx_syntax",
            "javascript_objects",
            "javascript_functions"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_component_props_conditional_rendering",
            "theory_prop_types_default_props"
          ]
        },
        {
          "id": "task_dynamic_card_component",
          "title": "Create a Flexible Card Component with Children",
          "description": "\nImplement a React functional component named `DynamicCard` that uses the `children` prop to allow flexible content.\n\n1.  The component should accept a `title` (string, required) prop for the card's header.\n2.  It should accept an optional `footer` (React Node, optional) prop for content at the bottom of the card.\n3.  The main content area of the card should be rendered using the `children` prop.\n4.  Add basic inline styling for the card, header, content, and footer areas to visually distinguish them.\n5.  Demonstrate its usage with different types of children (e.g., paragraphs, lists, buttons) and with/without the `footer`.\n\nYour solution should showcase the power of the `children` prop for layout and composition.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction DynamicCard({ title, children, footer }) {\n  // TODO: Implement the card structure\n  // 1. Render title\n  // 2. Render children in a main content area\n  // 3. Conditionally render footer\n  return (\n    <div style={{\n      border: '1px solid #ddd',\n      borderRadius: '8px',\n      padding: '20px',\n      margin: '20px',\n      boxShadow: '0 4px 8px rgba(0,0,0,0.1)'\n    }}>\n      {/* Card Header */}\n      {/* Card Content (children) */}\n      {/* Card Footer */}\n    </div>\n  );\n}\n\nDynamicCard.propTypes = {\n  title: PropTypes.string.isRequired,\n  children: PropTypes.node.isRequired, // Children should typically be required for a card\n  footer: PropTypes.node\n};\n\n// Example Usage (for testing):\n// function App() {\n//   return (\n//     <div>\n//       <DynamicCard title=\"Product Details\">\n//         <p>This is a product description.</p>\n//         <ul>\n//           <li>Feature A</li>\n//           <li>Feature B</li>\n//         </ul>\n//         <button>Add to Cart</button>\n//       </DynamicCard>\n\n//       <DynamicCard title=\"Quick Info\" footer={<span>Last updated: Today</span>}>\n//         <p>Some quick information here.</p>\n//       </DynamicCard>\n\n//       <DynamicCard title=\"Empty Card\">\n//         {/* No children content explicitly */}\n//       </DynamicCard>\n//     </div>\n//   );\n// }\n\n// export default App;\n",
          "solutionCode": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction DynamicCard({ title, children, footer }) {\n  return (\n    <div style={{\n      border: '1px solid #ddd',\n      borderRadius: '8px',\n      padding: '20px',\n      margin: '20px',\n      boxShadow: '0 4px 8px rgba(0,0,0,0.1)',\n      display: 'flex',\n      flexDirection: 'column',\n      minWidth: '300px'\n    }}>\n      <h2 style={{ marginBottom: '15px', color: '#333' }}>{title}</h2>\n      <div style={{ flexGrow: 1, marginBottom: '15px', lineHeight: '1.6' }}>\n        {children}\n      </div>\n      {footer && (\n        <div style={{\n          borderTop: '1px solid #eee',\n          paddingTop: '10px',\n          marginTop: 'auto',\n          fontSize: '0.9em',\n          color: '#666'\n        }}>\n          {footer}\n        </div>\n      )}\n    </div>\n  );\n}\n\nDynamicCard.propTypes = {\n  title: PropTypes.string.isRequired,\n  children: PropTypes.node.isRequired,\n  footer: PropTypes.node\n};\n\n// Example Usage:\n// function App() {\n//   return (\n//     <div style={{ display: 'flex', flexWrap: 'wrap', justifyContent: 'center' }}>\n//       <DynamicCard title=\"Product Details\">\n//         <p>This is a product description.</p>\n//         <ul>\n//           <li>Feature A</li>\n//           <li>Feature B</li>\n//         </ul>\n//         <button>Add to Cart</button>\n//       </DynamicCard>\n\n//       <DynamicCard title=\"Quick Info\" footer={<span>Last updated: Today</span>}>\n//         <p>Some quick information here.</p>\n//       </DynamicCard>\n\n//       <DynamicCard title=\"Empty Card\">\n//         <p>This card has minimal content.</p>\n//       </DynamicCard>\n//     </div>\n//   );\n// }\n\n// export default App;\n",
          "testCases": [
            "Render `DynamicCard` with paragraphs and a button as `children` and no `footer`.",
            "Render `DynamicCard` with a list as `children` and a `footer` string.",
            "Render `DynamicCard` with a function (e.g., `() => <p>Dynamic content</p>`) as `children` (ensure it renders).",
            "Test `isRequired` for `title` (missing title should log a PropTypes warning).",
            "Test rendering an empty `children` (e.g., `<DynamicCard title=\"Empty\"></DynamicCard>`) should render empty content area."
          ],
          "hints": [
            "The `children` prop is automatically available to components that have content between their opening and closing tags in JSX.",
            "You can render `footer` conditionally using the logical `&&` operator.",
            "Consider using `PropTypes.node` for `children` and `footer` as they can be various types of renderable content."
          ],
          "tags": [
            "React",
            "Children Prop",
            "Component Composition",
            "Layout",
            "Styling"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_component_basics",
            "jsx_syntax",
            "css_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_children_prop",
            "theory_react_component_props_conditional_rendering"
          ]
        },
        {
          "id": "task_simple_counter_class_component",
          "title": "Implement a Basic Counter Class Component",
          "description": "\nCreate a React class component called `SimpleCounter` that maintains and updates a count.\n\n1.  Initialize the component's state with `count: 0` using the class field syntax.\n2.  Display the current `count` value in a `<p>` tag.\n3.  Add a 'Increment' button. When clicked, it should increase the `count` by 1.\n4.  Add a 'Decrement' button. When clicked, it should decrease the `count` by 1.\n5.  Ensure that updating the state correctly re-renders the component.\n\nYour solution should demonstrate proper state initialization and updates in a class component.\n",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\n\nclass SimpleCounter extends React.Component {\n  // TODO: Initialize state using class field syntax\n  // state = { ... };\n\n  // TODO: Implement increment and decrement methods\n  // For example: handleIncrement = () => { ... };\n\n  render() {\n    return (\n      <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '5px', margin: '20px' }}>\n        {/* Display count */}\n        {/* Increment button */}\n        {/* Decrement button */}\n      </div>\n    );\n  }\n}\n\n// Example Usage (for testing):\n// function App() {\n//   return <SimpleCounter />;\n// }\n\n// export default App;\n",
          "solutionCode": "import React from 'react';\n\nclass SimpleCounter extends React.Component {\n  state = {\n    count: 0\n  };\n\n  handleIncrement = () => {\n    this.setState(prevState => ({\n      count: prevState.count + 1\n    }));\n  };\n\n  handleDecrement = () => {\n    this.setState(prevState => ({\n      count: prevState.count - 1\n    }));\n  };\n\n  render() {\n    return (\n      <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '5px', margin: '20px' }}>\n        <h2>Counter: {this.state.count}</h2>\n        <button onClick={this.handleIncrement} style={{ margin: '5px' }}>Increment</button>\n        <button onClick={this.handleDecrement} style={{ margin: '5px' }}>Decrement</button>\n      </div>\n    );\n  }\n}\n\n// Example Usage:\n// function App() {\n//   return <SimpleCounter />;\n// }\n\n// export default App;\n",
          "testCases": [
            "Initial render: `count` should be 0.",
            "Click 'Increment' button once: `count` should be 1.",
            "Click 'Increment' button multiple times: `count` should increase correctly.",
            "Click 'Decrement' button once: `count` should be 0 (if started from 1).",
            "Click 'Decrement' button multiple times: `count` should decrease correctly, potentially going negative."
          ],
          "hints": [
            "Remember to use `this.setState()` to update the `count`.",
            "For updating state based on previous state, use the functional form of `setState` (`this.setState(prevState => ({ ... }))`).",
            "Ensure `this` context is correct for event handlers (e.g., using arrow functions for class methods or binding in the constructor)."
          ],
          "tags": [
            "React",
            "State",
            "Class Components",
            "Event Handling",
            "Basic UI"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_component_basics",
            "javascript_es6_classes"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "beginner",
          "relatedConcepts": [
            "theory_react_class_component_state"
          ]
        },
        {
          "id": "task_toggle_visibility_class_component",
          "title": "Create a Toggleable Content Class Component",
          "description": "\nDevelop a React class component named `ToggleContent` that allows a section of content to be shown or hidden.\n\n1.  Initialize the component's state with `isVisible: false`.\n2.  Display a button that toggles the `isVisible` state. The button's text should change between 'Show Content' and 'Hide Content' based on the state.\n3.  Conditionally render a `<div>` (containing a simple paragraph like 'This is the hidden content!') based on the `isVisible` state. The content should only be visible when `isVisible` is `true`.\n4.  Ensure that clicking the button updates the state and triggers the correct conditional rendering.\n\nYour solution should demonstrate managing boolean state and applying conditional rendering in a class component.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass ToggleContent extends React.Component {\n  // TODO: Initialize state with isVisible: false\n\n  // TODO: Implement toggle method\n  // handleToggle = () => { ... };\n\n  render() {\n    return (\n      <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '5px', margin: '20px' }}>\n        {/* Button to toggle visibility */}\n        {/* Conditionally rendered content */}\n      </div>\n    );\n  }\n}\n\n// Example Usage (for testing):\n// function App() {\n//   return <ToggleContent />;\n// }\n\n// export default App;\n",
          "solutionCode": "import React from 'react';\n\nclass ToggleContent extends React.Component {\n  state = {\n    isVisible: false\n  };\n\n  handleToggle = () => {\n    this.setState(prevState => ({\n      isVisible: !prevState.isVisible\n    }));\n  };\n\n  render() {\n    return (\n      <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '5px', margin: '20px' }}>\n        <button onClick={this.handleToggle}>\n          {this.state.isVisible ? 'Hide Content' : 'Show Content'}\n        </button>\n        \n        {this.state.isVisible && (\n          <div style={{ marginTop: '15px', padding: '10px', backgroundColor: '#f9f9f9', border: '1px dashed #eee' }}>\n            <p>This is the hidden content!</p>\n            <p>It becomes visible when the button is clicked.</p>\n          </div>\n        )}\n      </div>\n    );\n  }\n}\n\n// Example Usage:\n// function App() {\n//   return <ToggleContent />;\n// }\n\n// export default App;\n",
          "testCases": [
            "Initial render: Content should be hidden, button text should be 'Show Content'.",
            "Click 'Show Content' button: Content should appear, button text should change to 'Hide Content'.",
            "Click 'Hide Content' button: Content should disappear, button text should change back to 'Show Content'.",
            "Repeated toggling should consistently show/hide content and change button text."
          ],
          "hints": [
            "Use the logical `&&` operator or a ternary operator for conditional rendering of the content `div`.",
            "The button's text can also be conditionally rendered based on `this.state.isVisible`.",
            "Remember to use the functional form of `setState` when toggling boolean states for reliability: `this.setState(prevState => ({ isVisible: !prevState.isVisible }))`."
          ],
          "tags": [
            "React",
            "State",
            "Class Components",
            "Conditional Rendering",
            "Event Handling",
            "UI Toggle"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_class_component_state",
            "react_component_props_conditional_rendering"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_class_component_state",
            "theory_react_component_props_conditional_rendering"
          ]
        }
      ]
    }
  },
  {
    "id": "94af5f9b-4c14-49e5-b46c-3298aed31646",
    "startLine": 3400,
    "endLine": 3499,
    "processedDate": "2025-06-17T08:43:59.991Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_class_component_state_basics",
          "title": "React State Management: Class Components Basics and Asynchronous Updates",
          "content": "In React class components, `state` is a plain JavaScript object that holds data influencing the component's rendering. To modify the state, you must use the `this.setState()` method. Direct modification of `this.state` (e.g., `this.state.count = 5;`) will not trigger a re-render and is considered a bad practice, leading to unpredictable behavior.\n\n## Key Concepts\n- **`this.state`**: An object holding the current state of the component.\n- **`this.setState(updater, [callback])`**: The primary method to update component state. It queues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state.\n- **Asynchronous Nature**: `this.setState` calls are often asynchronous and batched for performance reasons. This means you might not see the updated state immediately after calling `setState`.\n- **Batching**: React may batch multiple `setState` calls into a single update for efficiency. This is why if you call `setState` multiple times in the same synchronous event handler, React will only perform one re-render, applying all the changes at once.\n- **Immutability**: When updating state, especially nested objects or arrays, it's crucial to treat `this.state` as immutable. Always create new objects/arrays instead of modifying existing ones directly. This helps prevent side effects and ensures React can correctly detect changes and optimize re-renders.\n\n## Practical Considerations\n- **Accessing Latest State**: Because `setState` is asynchronous, relying on `this.state` immediately after `setState` can lead to errors. For updates that depend on the previous state, use the functional form of `setState` (covered in the next section).\n- **Callback Function**: `this.setState` can optionally take a callback function as its second argument. This callback is executed after the state update has been applied and the component has re-rendered. This is useful for performing side effects that depend on the new state.",
          "examples": [
            {
              "id": "example_class_component_state_basics_1",
              "title": "Basic State Initialization and Update",
              "code": "import React from 'react';\n\nclass Counter extends React.Component {\n  state = {\n    count: 0\n  };\n\n  increment = () => {\n    // Basic update: new state does not depend on old state, or simple increment\n    this.setState({ count: this.state.count + 1 });\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}",
              "explanation": "This example shows the initialization of `count` in `state` and a basic `increment` method. The `this.setState({ count: this.state.count + 1 });` line updates the `count` property. When `increment` is called multiple times in quick succession within the same event loop (e.g., due to React's batching), `this.state.count` might not reflect the very latest value from a preceding `setState` call.",
              "language": "typescript"
            },
            {
              "id": "example_class_component_state_basics_2",
              "title": "Using setState Callback",
              "code": "import React from 'react';\n\nclass DataFetcher extends React.Component {\n  state = {\n    data: null,\n    loading: false\n  };\n\n  fetchData = () => {\n    this.setState({ loading: true }, () => {\n      // This callback runs AFTER loading state is updated and component potentially re-rendered\n      console.log('Loading state updated to true. Now fetching data...');\n      // Simulate API call\n      setTimeout(() => {\n        this.setState({ data: 'Fetched Data!', loading: false });\n      }, 1000);\n    });\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.fetchData} disabled={this.state.loading}>\n          {this.state.loading ? 'Loading...' : 'Fetch Data'}\n        </button>\n        {this.state.data && <p>{this.state.data}</p>}\n      </div>\n    );\n  }\n}",
              "explanation": "This example demonstrates using the optional callback function of `setState`. The `console.log` statement inside the callback will execute only after `this.setState({ loading: true })` has completed and the component has potentially re-rendered. This is crucial for operations that depend on the state being fully updated.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_class_component_state_basics_1",
            "question_class_component_state_basics_2",
            "question_class_component_state_basics_3",
            "question_class_component_state_basics_4"
          ],
          "relatedTasks": [
            "task_class_component_counter",
            "task_class_component_form"
          ],
          "tags": [
            "React",
            "Class Components",
            "State Management",
            "setState",
            "Asynchronous",
            "Batching"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_basics",
            "react_components_intro"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_lifecycle_methods",
            "react_performance_optimization"
          ]
        },
        {
          "id": "theory_class_component_functional_and_complex_updates",
          "title": "React State Management: Class Components - Functional Updates & Complex State",
          "content": "When the new state depends on the previous state, or when performing multiple state updates in quick succession, using the functional form of `this.setState` is critical. This form takes a function as its first argument, which receives the `prevState` and `props` as arguments, ensuring you are working with the most up-to-date state.\n\n## Functional Updates\n- **`this.setState(updaterFunction, [callback])`**: The `updaterFunction` signature is `(prevState, props) => newState`. React guarantees that `prevState` reflects the state at the time the update is applied, avoiding issues with asynchronous updates and batching.\n- **Guaranteed Consistency**: This form is essential for reliable increments/decrements or toggles where multiple updates might queue up.\n\n## Complex State Updates (Immutability)\nWhen dealing with nested state objects or arrays, directly modifying them will not trigger a re-render, as React performs a shallow comparison of state changes. To correctly update nested state, you must create new objects/arrays at each level where a change occurs, using techniques like the spread operator (`...`). This ensures immutability and proper change detection.\n\n## Key Principles for Complex State Updates:\n1.  **Shallow Copy for Top-Level**: Use the spread operator (`...`) to create a shallow copy of the object containing the nested state you want to update.\n2.  **Deep Copy for Nested Changes**: For each nested level that changes, also create a new object/array, copying over unchanged properties and updating the specific ones.\n3.  **No Direct Mutation**: Never mutate `this.state` directly, nor its nested objects or arrays. Always return a new object from your `setState` updater function.",
          "examples": [
            {
              "id": "example_class_component_functional_update_1",
              "title": "Functional Update for Safe Increment",
              "code": "import React from 'react';\n\nclass Counter extends React.Component {\n  state = { count: 0 };\n\n  incrementSafely = () => {\n    // Functional update: prevState ensures we always use the latest count value\n    this.setState(prevState => ({\n      count: prevState.count + 1\n    }));\n  };\n\n  // Batch multiple state updates\n  resetAndIncrement = () => {\n    // Even though both are setState, React might batch them. Using functional update\n    // for the second call ensures it operates on the state after the first update.\n    this.setState({ count: 0 }); // This might be batched with the next update\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.incrementSafely}>Increment Safely</button>\n        <button onClick={this.resetAndIncrement}>Reset and Increment</button>\n      </div>\n    );\n  }\n}",
              "explanation": "The `incrementSafely` method uses the functional form of `setState`. This is crucial when multiple `setState` calls might occur in quick succession (e.g., inside a loop or batched by React), ensuring each update operates on the most current state. The `resetAndIncrement` example shows how multiple `setState` calls are batched, and the functional update ensures the second `setState` operates on the value after the first one has been processed, even if batched.",
              "language": "typescript"
            },
            {
              "id": "example_class_component_complex_update_1",
              "title": "Updating Nested State in Class Components",
              "code": "import React from 'react';\n\nclass UserForm extends React.Component {\n  state = {\n    user: {\n      name: '',\n      email: '',\n      preferences: {\n        newsletter: false,\n        notifications: true\n      }\n    }\n  };\n\n  handleNameChange = (event) => {\n    // Correctly updating a top-level nested property (name)\n    this.setState({\n      user: {\n        ...this.state.user, // Copy existing user properties\n        name: event.target.value // Update 'name'\n      }\n    });\n  };\n\n  toggleNewsletter = () => {\n    // Correctly updating a deeply nested property (newsletter) using functional update\n    this.setState(prevState => ({\n      user: {\n        ...prevState.user, // Copy existing user properties\n        preferences: {\n          ...prevState.user.preferences, // Copy existing preferences properties\n          newsletter: !prevState.user.preferences.newsletter // Toggle 'newsletter'\n        }\n      }\n    }));\n  };\n\n  render() {\n    const { user } = this.state;\n    return (\n      <div>\n        <label>Name:</label>\n        <input type=\"text\" value={user.name} onChange={this.handleNameChange} />\n        <p>Newsletter: {user.preferences.newsletter ? 'Yes' : 'No'}</p>\n        <button onClick={this.toggleNewsletter}>Toggle Newsletter</button>\n      </div>\n    );\n  }\n}",
              "explanation": "The `handleNameChange` method demonstrates updating a property within a nested object (`user.name`). It uses the spread operator (`...this.state.user`) to create a new `user` object, ensuring immutability. The `toggleNewsletter` method shows an even deeper nested update (`user.preferences.newsletter`). It uses the functional `setState` form to access `prevState`, and then applies spreading at each level (`...prevState.user` and `...prevState.user.preferences`) to immutably update the specific nested property.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_class_component_functional_and_complex_updates_1",
            "question_class_component_functional_and_complex_updates_2",
            "question_class_component_functional_and_complex_updates_3",
            "question_class_component_functional_and_complex_updates_4"
          ],
          "relatedTasks": [
            "task_class_component_form",
            "task_class_component_nested_list"
          ],
          "tags": [
            "React",
            "Class Components",
            "State Management",
            "Functional setState",
            "Immutability",
            "Nested State",
            "Spread Operator"
          ],
          "technology": "React",
          "prerequisites": [
            "theory_class_component_state_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_context_api",
            "react_redux_integration"
          ]
        },
        {
          "id": "theory_functional_component_state_useState",
          "title": "React State Management: Functional Components with useState Hook",
          "content": "In functional components, React Hooks provide a way to add state and other React features without writing a class. The `useState` hook is the fundamental hook for managing state.\n\n## Key Concepts\n- **`useState(initialState)`**: This hook declares a state variable. It returns an array with two elements: the current state value and a function that lets you update it.\n  - `initialState`: The value the state should have on the first render. It can be a primitive value (number, string, boolean) or an object/array. If `initialState` is a function, `useState` will execute it once during the initial render to get the initial state value. This is useful for expensive initializations.\n- **`[stateVariable, setStateFunction]`**: The common pattern is to use array destructuring to name the state variable and its updater function (e.g., `const [count, setCount] = useState(0);`).\n- **Updater Function (`setStateFunction`)**: This function is similar to `this.setState` in class components but specifically for the state variable it's paired with. It queues a re-render with the new state.\n  - **Direct Update**: `setCount(newValue)`: Directly sets the state to `newValue`. Similar to the object form of `setState` in classes, this update is batched.\n  - **Functional Update**: `setCount(prevValue => newValue)`: Takes a function that receives the previous state and returns the new state. This is highly recommended for updates that depend on the previous state to avoid stale closures and ensure reliable updates, especially in scenarios with multiple updates or asynchronous operations.\n- **Immutability with useState**: Just like in class components, `useState` updates trigger a re-render if the new state value is referentially different from the old one. For objects and arrays, you must always provide a new object or array, even if only a nested property has changed. Direct mutation of state objects/arrays will not trigger re-render.",
          "examples": [
            {
              "id": "example_functional_component_state_useState_1",
              "title": "Basic useState for Counter",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  // Declare a state variable 'count' initialized to 0, and its updater 'setCount'\n  const [count, setCount] = useState(0);\n  \n  const increment = () => {\n    // Direct update: new state does not depend on old state, or simple increment\n    setCount(count + 1);\n  };\n  \n  const decrement = () => {\n    // Direct update\n    setCount(count - 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates the basic usage of `useState`. `const [count, setCount] = useState(0);` initializes `count` to 0. `setCount(count + 1);` updates the `count` state. Although `count + 1` uses the current `count` value, this approach can lead to issues if `setCount` is called multiple times within a single batch or asynchronous operation, as `count` might be a 'stale' value from a previous render.",
              "language": "typescript"
            },
            {
              "id": "example_functional_component_state_useState_2",
              "title": "Functional Updates with useState",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  const incrementSafely = () => {\n    // Functional update: prevCount is guaranteed to be the latest state\n    setCount(prevCount => prevCount + 1);\n  };\n\n  const resetAndIncrement = () => {\n    // Example of batched updates using functional form for reliability\n    setCount(0); // This sets count to 0, but might be batched\n    setCount(prevCount => prevCount + 1); // This ensures increment happens after 0, regardless of batching\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={incrementSafely}>Increment Safely</button>\n      <button onClick={resetAndIncrement}>Reset and Increment</button>\n    </div>\n  );\n}",
              "explanation": "The `incrementSafely` function uses the functional update form `setCount(prevCount => prevCount + 1)`. This is the preferred way to update state when the new state depends on the previous state, as `prevCount` is guaranteed to be the most up-to-date value. The `resetAndIncrement` function illustrates how React batches updates; even if `setCount(0)` and `setCount(prevCount => prevCount + 1)` are called in the same event, the functional update ensures `prevCount` correctly reflects the state *after* the `setCount(0)` update has been processed internally.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_functional_component_state_useState_1",
            "question_functional_component_state_useState_2",
            "question_functional_component_state_useState_3",
            "question_functional_component_state_useState_4"
          ],
          "relatedTasks": [
            "task_functional_counter_app",
            "task_functional_timer_component"
          ],
          "tags": [
            "React",
            "Functional Components",
            "Hooks",
            "useState",
            "State Management",
            "Functional Updates"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_es6_features",
            "react_functional_components"
          ],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_use_effect",
            "react_custom_hooks",
            "react_context_api"
          ]
        },
        {
          "id": "theory_functional_component_complex_useState",
          "title": "React State Management: Functional Components - Complex State with useState",
          "content": "Managing complex state objects or arrays in functional components with `useState` requires careful attention to immutability, similar to class components. When your state is an object or an array, `useState` does not automatically merge updates like `this.setState` does in class components. Instead, it *replaces* the entire state value with the new value you provide.\n\n## Key Concepts\n- **State Replacement, Not Merging**: Unlike `this.setState` in class components which merges partial state updates, `useState`'s setter function replaces the entire state value. If your state is an object, and you only want to update one property, you must manually merge the old state with the new property using the spread operator (`...`).\n- **Immutability for Nested Objects**: To update a nested property within a state object, you need to create new objects at each level of nesting leading up to the property you're changing. This ensures React detects the change and re-renders.\n- **Spread Operator for Copies**: The spread operator (`...`) is essential for creating shallow copies of objects and arrays, allowing you to update specific properties while retaining others.\n- **Functional Update for Reliability**: For updates that depend on the previous complex state, especially deeply nested ones, always use the functional form of the setter (`setMyObject(prevObject => ({ ...prevObject, updatedProp }))`) to ensure you're working with the most current state snapshot.",
          "examples": [
            {
              "id": "example_functional_component_complex_useState_1",
              "title": "Updating Nested State in Functional Components",
              "code": "import React, { useState } from 'react';\n\nfunction UserForm() {\n  const [user, setUser] = useState({\n    name: '',\n    email: '',\n    preferences: {\n      newsletter: false,\n      notifications: true\n    }\n  });\n\n  const handleNameChange = (event) => {\n    // Correctly updating a top-level nested property (name)\n    setUser(prevUser => ({\n      ...prevUser, // Copy existing user properties\n      name: event.target.value // Update 'name'\n    }));\n  };\n\n  const toggleNewsletter = () => {\n    // Correctly updating a deeply nested property (newsletter) using functional update\n    setUser(prevUser => ({\n      ...prevUser, // Copy existing user properties\n      preferences: {\n        ...prevUser.preferences, // Copy existing preferences properties\n        newsletter: !prevUser.preferences.newsletter // Toggle 'newsletter'\n      }\n    }));\n  };\n\n  const handleEmailChange = (event) => {\n    // Example: Direct update (less safe if batched, but common for independent updates)\n    setUser({\n      ...user, // Needs 'user' from the current render scope, which might be stale\n      email: event.target.value\n    });\n  };\n\n  return (\n    <div>\n      <label>Name:</label>\n      <input type=\"text\" value={user.name} onChange={handleNameChange} />\n      <label>Email:</label>\n      <input type=\"email\" value={user.email} onChange={handleEmailChange} />\n      <p>Newsletter: {user.preferences.newsletter ? 'Yes' : 'No'}</p>\n      <button onClick={toggleNewsletter}>Toggle Newsletter</button>\n    </div>\n  );\n}",
              "explanation": "This example shows how to manage complex state objects using `useState` in functional components. Notice that to update just the `name`, we must spread the `prevUser` object to retain its `email` and `preferences`. Similarly, for deeply nested updates like `newsletter`, we spread both the `user` object and the `preferences` object to ensure only the `newsletter` property is toggled while others remain unchanged. Using the functional update form (`prevUser => (...)`) is generally safer for complex state as it guarantees access to the latest state.",
              "language": "typescript"
            },
            {
              "id": "example_functional_component_complex_useState_2",
              "title": "Updating Array State with useState",
              "code": "import React, { useState } from 'react';\n\nfunction TodoList() {\n  const [todos, setTodos] = useState([\n    { id: 1, text: 'Learn React', completed: false },\n    { id: 2, text: 'Build a project', completed: true }\n  ]);\n\n  const addTodo = (text) => {\n    const newTodo = { id: Date.now(), text, completed: false };\n    setTodos(prevTodos => [...prevTodos, newTodo]); // Add new item\n  };\n\n  const toggleTodo = (id) => {\n    setTodos(prevTodos =>\n      prevTodos.map(todo =>\n        todo.id === id ? { ...todo, completed: !todo.completed } : todo\n      )\n    );\n  };\n\n  return (\n    <div>\n      <input type=\"text\" onKeyPress={(e) => { if (e.key === 'Enter') { addTodo(e.target.value); e.target.value = ''; } }} placeholder=\"Add new todo\" />\n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id} style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n            <span onClick={() => toggleTodo(todo.id)}>{todo.text}</span>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates how to manage an array of objects in state. To add a new todo, `setTodos` is called with a new array created by spreading `prevTodos` and appending the `newTodo`. To toggle a todo's completion status, `map` is used to iterate over the `prevTodos` array. For the matching todo, a *new* todo object is created with the `completed` status toggled, ensuring immutability of the todo object itself. This results in a new array, triggering a re-render.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_functional_component_complex_useState_1",
            "question_functional_component_complex_useState_2",
            "question_functional_component_complex_useState_3",
            "question_functional_component_complex_useState_4"
          ],
          "relatedTasks": [
            "task_functional_form_validation",
            "task_functional_shopping_cart"
          ],
          "tags": [
            "React",
            "Functional Components",
            "Hooks",
            "useState",
            "Complex State",
            "Immutability",
            "Spread Operator",
            "Array Updates",
            "Object Updates"
          ],
          "technology": "React",
          "prerequisites": [
            "theory_functional_component_state_useState"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "react_performance_optimization",
            "react_context_api_patterns",
            "react_reducer_hook"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_class_component_state_basics_1",
          "topic": "Class Component State & setState",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is the correct way to update state in a React class component?",
          "answer": "Using this.setState()",
          "options": [
            "Directly modifying this.state (e.g., this.state.count = 5;)",
            "Using this.setState()",
            "Calling forceUpdate()",
            "Modifying props directly"
          ],
          "analysisPoints": [
            "Understanding that `this.state` should be treated as immutable.",
            "Recognizing `this.setState()` as the prescribed method for state updates.",
            "Distinguishing between state updates and prop modifications."
          ],
          "keyConcepts": [
            "Class Components",
            "State Management",
            "setState"
          ],
          "evaluationCriteria": [
            "Basic knowledge of React state update mechanisms."
          ],
          "example": "```typescript\nclass MyComponent extends React.Component {\n  state = { count: 0 };\n  handleClick = () => {\n    this.setState({ count: this.state.count + 1 }); // Correct way\n    // this.state.count = 5; // Incorrect, will not trigger re-render\n  };\n  render() {\n    return <button onClick={this.handleClick}>Count: {this.state.count}</button>;\n  }\n}\n```\nExplanation: Directly modifying `this.state` does not notify React of a state change, thus not triggering a re-render. `this.setState()` is the designated method to inform React about state changes and queue a re-render.",
          "tags": [
            "React",
            "Class Components",
            "State",
            "setState"
          ],
          "prerequisites": [
            "javascript_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_class_component_state_basics_2",
          "topic": "setState Asynchronous Nature and Batching",
          "level": "medium",
          "type": "open",
          "question": "Explain why `this.setState` calls are considered asynchronous and how React handles multiple `setState` calls made within the same event loop. Provide a scenario where understanding this behavior is crucial.",
          "answer": "N/A",
          "analysisPoints": [
            "Ability to articulate the asynchronous nature of `setState` (React batches updates for performance).",
            "Understanding that React batches multiple `setState` calls made synchronously within the same event handler/loop to avoid unnecessary re-renders.",
            "Identifying that the functional form of `setState` (`prevState => newState`) is necessary for updates dependent on previous state due to this asynchronous nature.",
            "Providing a concrete scenario (e.g., multiple increments/toggles) where direct state access after `setState` would lead to incorrect results."
          ],
          "keyConcepts": [
            "setState",
            "Asynchronous",
            "Batching",
            "Performance Optimization",
            "Functional setState"
          ],
          "evaluationCriteria": [
            "Depth of understanding of React's internal state update mechanisms.",
            "Ability to explain practical implications."
          ],
          "example": "When `this.setState` is called, React doesn't immediately update the state and re-render the component. Instead, it queues the update. React batches multiple `setState` calls made within the same synchronous event handler (e.g., a button click) into a single re-render cycle. This is done for performance optimization, preventing multiple expensive re-renders for trivial changes. Consequently, if you try to read `this.state` immediately after calling `this.setState`, you might not get the updated value.\n\nScenario: Consider a counter component where you want to increment the count by 3 when a button is clicked, by calling `this.setState({ count: this.state.count + 1 });` three times consecutively.\n\n```typescript\nclass Counter extends React.Component {\n  state = { count: 0 };\n  incrementByThreeIncorrect() {\n    this.setState({ count: this.state.count + 1 }); // count = 0 + 1 = 1\n    this.setState({ count: this.state.count + 1 }); // count is still 0 here, so 0 + 1 = 1\n    this.setState({ count: this.state.count + 1 }); // count is still 0 here, so 0 + 1 = 1\n  }\n  // After batching, the state will be { count: 1 }, not 3.\n\n  incrementByThreeCorrect() {\n    this.setState(prevState => ({ count: prevState.count + 1 })); // prev: 0 -> next: 1\n    this.setState(prevState => ({ count: prevState.count + 1 })); // prev: 1 -> next: 2\n    this.setState(prevState => ({ count: prevState.count + 1 })); // prev: 2 -> next: 3\n  }\n  // After batching, the state will be { count: 3 }.\n}\n```\nIn `incrementByThreeIncorrect`, because `this.state.count` doesn't update immediately, all three `setState` calls read the initial `count` value (0), leading to an incorrect final count of 1. The `incrementByThreeCorrect` method uses the functional update form, ensuring each `setState` call receives the *latest* state from the previous update in the batch, thus correctly incrementing the count to 3.",
          "tags": [
            "React",
            "State Management",
            "setState",
            "Asynchronous",
            "Batching",
            "Performance"
          ],
          "prerequisites": [
            "theory_class_component_state_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_component_state_basics_3",
          "topic": "setState Callback",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following React class component, what will be logged to the console by `console.log(this.state.message);` after the button is clicked, and when will the callback `console.log('State updated and re-rendered');` execute?",
          "answer": "logs 'Initial Message' first, then 'State updated and re-rendered' after the component re-renders.",
          "options": [
            "logs 'New Message' first, then 'State updated and re-rendered' immediately after.",
            "logs 'Initial Message' first, then 'State updated and re-rendered' after the component re-renders.",
            "logs 'Initial Message' first, then 'New Message' immediately after.",
            "logs 'New Message' first, then 'Initial Message' after the component re-renders."
          ],
          "analysisPoints": [
            "Understanding `setState` is asynchronous and its updates are batched.",
            "Knowing that `this.state` might not reflect the updated value immediately after `setState`.",
            "Recognizing that the `setState` callback executes *after* the state has been updated and the component has potentially re-rendered."
          ],
          "keyConcepts": [
            "setState",
            "Asynchronous",
            "Callback Function",
            "Re-render"
          ],
          "evaluationCriteria": [
            "Ability to predict `setState` behavior.",
            "Understanding of `setState` callback execution timing."
          ],
          "example": "```typescript\nimport React from 'react';\n\nclass MyComponent extends React.Component {\n  state = { message: 'Initial Message' };\n\n  handleClick = () => {\n    this.setState({ message: 'New Message' }, () => {\n      console.log('State updated and re-rendered');\n    });\n    console.log(this.state.message); // This logs the 'Initial Message'\n  };\n\n  render() {\n    return (\n      <div>\n        <p>{this.state.message}</p>\n        <button onClick={this.handleClick}>Change Message</button>\n      </div>\n    );\n  }\n}\n```\nExplanation: When `handleClick` is called, `this.setState` queues the update. The `console.log(this.state.message);` immediately after `setState` will log the *current* state value ('Initial Message') because `setState` is asynchronous and the state hasn't been updated yet in that synchronous execution flow. The callback function `() => { console.log('State updated and re-rendered'); }` will execute *after* the state update has been processed by React and the component has potentially re-rendered with the new state ('New Message').",
          "tags": [
            "React",
            "Class Components",
            "setState",
            "Asynchronous",
            "Callback"
          ],
          "prerequisites": [
            "theory_class_component_state_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_component_state_basics_4",
          "topic": "State vs. Props",
          "level": "flashcard",
          "question": "What is the primary difference between `state` and `props` in React class components?",
          "answer": "`State` is data managed by the component itself and can change over time. `Props` are data passed from a parent component to a child component and are immutable (read-only) within the child component.",
          "analysisPoints": [
            "Distinguishing mutability/immutability.",
            "Identifying source of data (internal vs. external)."
          ],
          "keyConcepts": [
            "State",
            "Props",
            "Class Components",
            "Data Flow"
          ],
          "evaluationCriteria": [
            "Quick recall of fundamental React concepts."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "State",
            "Props",
            "Fundamentals"
          ],
          "prerequisites": [
            "react_components_intro"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_class_component_functional_and_complex_updates_1",
          "topic": "Class Component Functional setState",
          "level": "medium",
          "type": "mcq",
          "question": "You have a React class component with a state `counter: 0`. You want to increment `counter` twice when a single button is clicked. Which method ensures the `counter` is correctly incremented by 2, assuming React's batching behavior?",
          "answer": "```javascript\nthis.setState(prevState => ({ counter: prevState.counter + 1 }));\nthis.setState(prevState => ({ counter: prevState.counter + 1 }));\n```",
          "options": [
            "```javascript\nthis.setState({ counter: this.state.counter + 1 });\nthis.setState({ counter: this.state.counter + 1 });\n```",
            "```javascript\nthis.setState(prevState => ({ counter: prevState.counter + 1 }));\nthis.setState(prevState => ({ counter: prevState.counter + 1 }));\n```",
            "```javascript\nthis.setState({ counter: this.state.counter + 2 });\n```",
            "```javascript\nthis.state.counter += 2;\nthis.forceUpdate();\n```"
          ],
          "analysisPoints": [
            "Understanding the importance of functional `setState` for updates depending on previous state.",
            "Knowing that direct `this.state` access inside multiple `setState` calls within a batched update can lead to stale state.",
            "Recognizing that `this.setState({ counter: this.state.counter + 2 });` would also work but does not directly test the understanding of multiple batched updates using functional forms.",
            "Identifying direct mutation + `forceUpdate` as an anti-pattern."
          ],
          "keyConcepts": [
            "Class Components",
            "setState",
            "Functional Update",
            "Batching",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Ability to apply `setState` best practices for sequential updates.",
            "Understanding of asynchronous nature and batching."
          ],
          "example": "```typescript\nclass MyComponent extends React.Component {\n  state = { counter: 0 };\n\n  incrementTwiceSafe = () => {\n    this.setState(prevState => ({ counter: prevState.counter + 1 }));\n    this.setState(prevState => ({ counter: prevState.counter + 1 }));\n    // When batched, the second call's prevState will correctly reflect the first update.\n  };\n\n  incrementTwiceUnsafe = () => {\n    this.setState({ counter: this.state.counter + 1 });\n    this.setState({ counter: this.state.counter + 1 });\n    // Both calls read the original this.state.counter value before any update is processed,\n    // leading to a final counter of 1 if initial was 0.\n  };\n}\n```\nExplanation: The first option using `this.setState({ counter: this.state.counter + 1 });` twice will likely result in `counter` only increasing by 1 (if it started at 0) due to React's batching and the asynchronous nature of `setState`. Both calls will read the same `this.state.counter` value before the update is applied. The second option uses the functional form (`prevState => ...`), which guarantees that each update receives the most recent state value, leading to a correct increment by 2.",
          "tags": [
            "React",
            "Class Components",
            "setState",
            "Functional Update",
            "Batching"
          ],
          "prerequisites": [
            "theory_class_component_state_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_component_functional_and_complex_updates_2",
          "topic": "Class Component Complex State Immutability",
          "level": "hard",
          "type": "code",
          "question": "Implement a `UserProfileEditor` class component. The component should manage a `user` state object with nested properties: `name` (string), `contact` (object with `email` and `phone` strings), and `settings` (object with `receiveEmails` boolean and `theme` string). Provide methods to:\n1. Update the user's `name`.\n2. Update the user's `email` (nested property).\n3. Toggle `receiveEmails` (deeply nested property).\n\nEnsure all updates are immutable and trigger proper re-renders.",
          "answer": "N/A",
          "analysisPoints": [
            "Correctly initializing nested state.",
            "Using spread syntax (`...`) at each level of nested object to ensure immutability.",
            "Applying functional `setState` for updates that depend on previous state (especially toggles/complex paths).",
            "Triggering re-renders without direct mutation."
          ],
          "keyConcepts": [
            "Class Components",
            "Complex State",
            "Immutability",
            "setState",
            "Nested Objects",
            "Spread Operator"
          ],
          "evaluationCriteria": [
            "Ability to handle complex state structures.",
            "Correct application of immutability principles.",
            "Proper use of `setState`."
          ],
          "example": "```typescript\nimport React from 'react';\n\nclass UserProfileEditor extends React.Component {\n  state = {\n    user: {\n      name: 'John Doe',\n      contact: {\n        email: 'john.doe@example.com',\n        phone: '123-456-7890'\n      },\n      settings: {\n        receiveEmails: true,\n        theme: 'light'\n      }\n    }\n  };\n\n  handleNameChange = (event) => {\n    this.setState(prevState => ({\n      user: {\n        ...prevState.user,\n        name: event.target.value\n      }\n    }));\n  };\n\n  handleEmailChange = (event) => {\n    this.setState(prevState => ({\n      user: {\n        ...prevState.user,\n        contact: {\n          ...prevState.user.contact,\n          email: event.target.value\n        }\n      }\n    }));\n  };\n\n  toggleReceiveEmails = () => {\n    this.setState(prevState => ({\n      user: {\n        ...prevState.user,\n        settings: {\n          ...prevState.user.settings,\n          receiveEmails: !prevState.user.settings.receiveEmails\n        }\n      }\n    }));\n  };\n\n  render() {\n    const { user } = this.state;\n    return (\n      <div>\n        <h3>User Profile</h3>\n        <div>\n          <label>Name:</label>\n          <input type=\"text\" value={user.name} onChange={this.handleNameChange} />\n        </div>\n        <div>\n          <label>Email:</label>\n          <input type=\"email\" value={user.contact.email} onChange={this.handleEmailChange} />\n        </div>\n        <div>\n          <label>Receive Emails:</label>\n          <input type=\"checkbox\" checked={user.settings.receiveEmails} onChange={this.toggleReceiveEmails} />\n        </div>\n        <p>Theme: {user.settings.theme}</p>\n        <pre>{JSON.stringify(user, null, 2)}</pre>\n      </div>\n    );\n  }\n}\n```",
          "tags": [
            "React",
            "Class Components",
            "State",
            "Complex State",
            "Immutability",
            "setState"
          ],
          "prerequisites": [
            "theory_class_component_state_basics",
            "theory_class_component_functional_and_complex_updates"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_class_component_functional_and_complex_updates_3",
          "topic": "Immutability Principle",
          "level": "open",
          "question": "Why is it important to update state immutably in React, especially when dealing with objects and arrays? What issues can arise from direct state mutation?",
          "answer": "N/A",
          "analysisPoints": [
            "Explaining how React's shallow comparison (`shouldComponentUpdate`, `PureComponent`) relies on reference equality.",
            "Stating that direct mutation bypasses React's change detection mechanism.",
            "Listing issues: components not re-rendering, unpredictable behavior, difficulty in debugging, breaking optimization techniques, issues with features like Context API, Redux, or DevTools time-travel debugging."
          ],
          "keyConcepts": [
            "Immutability",
            "State Management",
            "Performance",
            "Shallow Comparison",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of immutability's role in React.",
            "Ability to identify potential pitfalls."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Immutability",
            "State",
            "Best Practices",
            "Performance"
          ],
          "prerequisites": [
            "theory_class_component_state_basics",
            "theory_class_component_functional_and_complex_updates"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_component_functional_and_complex_updates_4",
          "topic": "Class Component vs. Functional Component State",
          "level": "flashcard",
          "question": "How does `this.setState`'s merging behavior differ from `useState`'s setter behavior when updating an object?",
          "answer": "`this.setState` in class components automatically merges the object you pass with the current state. `useState`'s setter function, however, *replaces* the entire state value; for objects, you must manually merge by spreading the previous state.",
          "analysisPoints": [
            "Distinguishing `setState` (merge) vs. `useState` setter (replace).",
            "Understanding implications for object updates."
          ],
          "keyConcepts": [
            "setState",
            "useState",
            "Merging",
            "Replacing",
            "State Differences"
          ],
          "evaluationCriteria": [
            "Quick recall of key differences between class and functional state management."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Class Components",
            "Functional Components",
            "State",
            "setState",
            "useState"
          ],
          "prerequisites": [
            "theory_class_component_state_basics",
            "theory_functional_component_state_useState"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_component_state_useState_1",
          "topic": "Functional Component State - useState Hook",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following correctly initializes a state variable `username` with an empty string in a functional component using `useState`?",
          "answer": "```javascript\nconst [username, setUsername] = useState('');\n```",
          "options": [
            "```javascript\nconst username = useState('');\n```",
            "```javascript\nconst [username] = useState('');\n```",
            "```javascript\nconst [username, setUsername] = useState('');\n```",
            "```javascript\nlet username = '';\n```"
          ],
          "analysisPoints": [
            "Understanding `useState` returns an array.",
            "Correctly applying array destructuring `[state, setState]`.",
            "Identifying the correct `useState` syntax."
          ],
          "keyConcepts": [
            "useState",
            "Functional Components",
            "Hooks",
            "State Initialization"
          ],
          "evaluationCriteria": [
            "Basic syntax knowledge of `useState`."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction LoginForm() {\n  const [username, setUsername] = useState(''); // Correct initialization\n  // ... rest of component\n}\n```\nExplanation: `useState` returns a pair: the current state value and a function to update it. Array destructuring `[username, setUsername]` is the standard way to capture these values. Simply assigning `useState('')` to `username` would result in `username` being the entire array `['', Function]`, which is not what's intended for the state value itself.",
          "tags": [
            "React",
            "Functional Components",
            "Hooks",
            "useState"
          ],
          "prerequisites": [
            "javascript_es6_features"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_functional_component_state_useState_2",
          "topic": "Functional Component State - Functional Updates",
          "level": "medium",
          "type": "open",
          "question": "Consider a functional component with state `count` initialized to 0. You have a button that, when clicked, calls `setCount(count + 1);` twice. What will be the final `count` value if the initial `count` is 0, and why? How would you modify the code to ensure it increments by 2 correctly?",
          "answer": "N/A",
          "analysisPoints": [
            "Explaining the concept of 'stale closures' or 'stale state' when `setCount(count + 1)` is called multiple times.",
            "Understanding that `count` in `setCount(count + 1)` refers to the value from the render when the function was created.",
            "Identifying that React batches `useState` updates similarly to `setState`.",
            "Providing the correct solution using the functional update form `setCount(prevCount => prevCount + 1)`."
          ],
          "keyConcepts": [
            "useState",
            "Functional Updates",
            "Stale Closures",
            "Batching",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Ability to explain functional update necessity.",
            "Understanding of React's update lifecycle in hooks."
          ],
          "example": "If `count` is initially 0, and `setCount(count + 1)` is called twice:  \n```typescript\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const incrementTwice = () => {\n    setCount(count + 1); // count is 0, so setCount(1)\n    setCount(count + 1); // count is still 0 in this render's closure, so setCount(1) again\n  };\n\n  return <button onClick={incrementTwice}>Increment Twice</button>;\n}\n```\nThe final `count` will be 1, not 2. This is because both `setCount(count + 1)` calls in `incrementTwice` closure refer to the `count` value from the *initial render* when `incrementTwice` was defined, which was 0. Even though React batches these updates, both updates try to set the count to 1 based on that initial 0.\n\nTo correct this, use the functional update form:\n```typescript\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const incrementTwiceCorrect = () => {\n    setCount(prevCount => prevCount + 1); // prevCount is 0 -> 1\n    setCount(prevCount => prevCount + 1); // prevCount is 1 -> 2\n  };\n\n  return <button onClick={incrementTwiceCorrect}>Increment Twice Correctly</button>;\n}\n```\nWith the functional update, `prevCount` in each `setCount` call is guaranteed to be the most recent state value, ensuring correct sequential updates.",
          "tags": [
            "React",
            "Functional Components",
            "useState",
            "Functional Updates",
            "Stale Closures",
            "Batching"
          ],
          "prerequisites": [
            "theory_functional_component_state_useState"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_component_state_useState_3",
          "topic": "useState Initial State Performance",
          "level": "medium",
          "type": "mcq",
          "question": "Which `useState` initialization method is more performant if `calculateInitialValue` is a computationally expensive function?",
          "answer": "```javascript\nconst [value, setValue] = useState(() => calculateInitialValue());\n```",
          "options": [
            "```javascript\nconst [value, setValue] = useState(calculateInitialValue());\n```",
            "```javascript\nconst [value, setValue] = useState(() => calculateInitialValue());\n```",
            "Both are equally performant.",
            "It depends on the React version."
          ],
          "analysisPoints": [
            "Understanding that `useState` accepts a function for lazy initialization.",
            "Recognizing that `useState(expensiveFn())` executes the function on every render.",
            "Identifying that `useState(() => expensiveFn())` executes the function only once on the initial render."
          ],
          "keyConcepts": [
            "useState",
            "Performance",
            "Lazy Initialization",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Knowledge of `useState` initialization nuances for performance."
          ],
          "example": "```typescript\nfunction calculateExpensiveValue() {\n  console.log('Calculating initial value...'); // This will be logged on every render if not lazy initialized\n  // Imagine complex computations here\n  return 100;\n}\n\nfunction MyComponent() {\n  // Option 1: calculateExpensiveValue() runs on every render\n  // const [value1, setValue1] = useState(calculateExpensiveValue());\n\n  // Option 2: calculateExpensiveValue() runs ONLY on initial render\n  const [value2, setValue2] = useState(() => calculateExpensiveValue());\n\n  return <p>Value: {value2}</p>;\n}\n```\nExplanation: When `useState(calculateInitialValue())` is used, `calculateInitialValue()` is executed on every render because it's called directly during the render phase. If this function is expensive, it can lead to performance issues. However, when `useState(() => calculateInitialValue())` is used, the function `calculateInitialValue` is passed as a *lazy initializer*. React will only execute this function once, during the initial render, to determine the initial state. Subsequent re-renders will reuse the previously stored state value without re-executing the initializer function, making it more performant for expensive initializations.",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "Performance",
            "Optimization"
          ],
          "prerequisites": [
            "theory_functional_component_state_useState"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_component_state_useState_4",
          "topic": "useState Immutability",
          "level": "flashcard",
          "question": "What is the key difference in how `useState`'s setter handles object updates compared to `this.setState` in class components?",
          "answer": "`useState`'s setter *replaces* the entire object, requiring manual merging with the spread operator. `this.setState` *merges* the new object into the existing state automatically.",
          "analysisPoints": [
            "Understanding the 'replace' behavior of `useState`'s setter for objects.",
            "Understanding the 'merge' behavior of `this.setState` for objects."
          ],
          "keyConcepts": [
            "useState",
            "setState",
            "Object Updates",
            "Merge vs Replace",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Quick recall of critical behavioral differences."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "setState",
            "Immutability"
          ],
          "prerequisites": [
            "theory_class_component_functional_and_complex_updates",
            "theory_functional_component_state_useState"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_component_complex_useState_1",
          "topic": "Functional Component Complex State Update",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following functional component state:\n```javascript\nconst [form, setForm] = useState({\n  personal: { firstName: '', lastName: '' },\n  address: { street: '', city: '' }\n});\n```\nWhich code snippet correctly updates only the `firstName` to 'Jane'?",
          "answer": "```javascript\nsetForm(prevForm => ({\n  ...prevForm,\n  personal: { ...prevForm.personal, firstName: 'Jane' }\n}));\n```",
          "options": [
            "```javascript\nsetForm({ firstName: 'Jane' });\n```",
            ""
          ],
          "analysisPoints": [
            "Understanding that `useState` setter replaces the entire state object, not merges.",
            "Applying immutability by spreading at each level of the nested object.",
            "Avoiding direct mutation of the state object.",
            "Using the functional updater form for reliability."
          ],
          "keyConcepts": [
            "useState",
            "Complex State",
            "Immutability",
            "Functional Update",
            "Spread Operator"
          ],
          "evaluationCriteria": [
            "Ability to correctly update deeply nested state in functional components.",
            "Strong grasp of immutability."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction MyForm() {\n  const [form, setForm] = useState({\n    personal: { firstName: 'John', lastName: 'Doe' },\n    address: { street: '123 Main St', city: 'Anytown' }\n  });\n\n  const updateFirstName = () => {\n    // Incorrect: Replaces the whole form object\n    // setForm({ firstName: 'Jane' });\n\n    // Incorrect: Mutates state directly, might not re-render\n    // setForm(prevForm => {\n    //   prevForm.personal.firstName = 'Jane';\n    //   return prevForm;\n    // });\n\n    // Correct way:\n    setForm(prevForm => ({\n      ...prevForm,\n      personal: { ...prevForm.personal, firstName: 'Jane' }\n    }));\n  };\n\n  return (\n    <div>\n      <p>First Name: {form.personal.firstName}</p>\n      <button onClick={updateFirstName}>Update First Name</button>\n    </div>\n  );\n}\n```\nExplanation: Option 1 (`setForm({ firstName: 'Jane' });`) is incorrect because `useState` replaces the entire state object; it would remove `personal.lastName`, `address`, etc. Option 2 and 4 directly mutate the `prevForm` or `form` object, which is an anti-pattern and might not trigger a re-render because the reference to the object itself doesn't change. Option 3 is correct. It uses the functional update form and the spread operator at each level (`...prevForm` and `...prevForm.personal`) to create new objects, preserving other properties while immutably updating `firstName`. This ensures React detects the change and re-renders correctly.",
          "tags": [
            "React",
            "Functional Components",
            "useState",
            "Complex State",
            "Immutability",
            "Spread Operator"
          ],
          "prerequisites": [
            "theory_functional_component_state_useState"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_component_complex_useState_2",
          "topic": "Functional Component State - Array Updates",
          "level": "hard",
          "type": "code",
          "question": "You are building a `TaskList` functional component. The component's state `tasks` is an array of objects, where each object has `id` (number), `text` (string), and `completed` (boolean). Implement the `toggleTaskCompletion` function which takes a `taskId` and toggles the `completed` status of the matching task. Ensure the update is immutable.",
          "answer": "N/A",
          "analysisPoints": [
            "Correctly identifying that array methods like `map` are suitable for immutable updates.",
            "Creating a new array and new task objects for updated elements.",
            "Avoiding direct mutation of the array or its elements.",
            "Using functional `setTasks` for reliable updates."
          ],
          "keyConcepts": [
            "useState",
            "Array State",
            "Immutability",
            "Functional Update",
            "map",
            "Spread Operator"
          ],
          "evaluationCriteria": [
            "Ability to perform immutable updates on array state.",
            "Understanding of array manipulation methods for immutability."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction TaskList() {\n  const [tasks, setTasks] = useState([\n    { id: 1, text: 'Buy groceries', completed: false },\n    { id: 2, text: 'Do laundry', completed: true },\n    { id: 3, text: 'Call mom', completed: false }\n  ]);\n\n  const toggleTaskCompletion = (taskId) => {\n    setTasks(prevTasks =>\n      prevTasks.map(task =>\n        task.id === taskId ? { ...task, completed: !task.completed } : task\n      )\n    );\n  };\n\n  return (\n    <div>\n      <h3>My Tasks</h3>\n      <ul>\n        {tasks.map(task => (\n          <li key={task.id} onClick={() => toggleTaskCompletion(task.id)} style={{ textDecoration: task.completed ? 'line-through' : 'none', cursor: 'pointer' }}>\n            {task.text}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "Functional Components",
            "useState",
            "Array State",
            "Immutability",
            "Coding Challenge"
          ],
          "prerequisites": [
            "theory_functional_component_state_useState",
            "theory_functional_component_complex_useState"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_functional_component_complex_useState_3",
          "topic": "useState vs. useReducer",
          "level": "open",
          "question": "For what kind of state management scenarios might `useReducer` be preferred over `useState` in functional components?",
          "answer": "N/A",
          "analysisPoints": [
            "Identifying complex state logic (multiple interrelated state transitions).",
            "Situations where the next state depends on the previous one in a complex way.",
            "Managing multiple pieces of state that often change together.",
            "When passing state update logic down to child components without prop drilling (dispatch function is stable).",
            "Replacing redux-like patterns for local component state."
          ],
          "keyConcepts": [
            "useState",
            "useReducer",
            "Complex State",
            "State Logic",
            "Prop Drilling",
            "Hooks"
          ],
          "evaluationCriteria": [
            "Understanding the strengths and weaknesses of different React hooks for state management.",
            "Ability to identify appropriate tools for specific problems."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "useReducer",
            "State Management",
            "Design Patterns"
          ],
          "prerequisites": [
            "theory_functional_component_complex_useState"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_functional_component_complex_useState_4",
          "topic": "State Immutability Recap",
          "level": "flashcard",
          "question": "What is the primary reason for using the spread operator (`...`) when updating objects or arrays in React state?",
          "answer": "To create a shallow copy of the existing object or array, ensuring immutability. This allows you to update specific properties while keeping others, and more importantly, ensures React detects the change and triggers a re-render.",
          "analysisPoints": [
            "Connecting spread operator to immutability.",
            "Linking immutability to React's rendering mechanism."
          ],
          "keyConcepts": [
            "Immutability",
            "Spread Operator",
            "State Updates",
            "Re-render"
          ],
          "evaluationCriteria": [
            "Quick recall of a fundamental React best practice."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Immutability",
            "Spread Operator",
            "Best Practices"
          ],
          "prerequisites": [
            "theory_class_component_functional_and_complex_updates",
            "theory_functional_component_complex_useState"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_class_component_counter",
          "title": "Build a Simple Class Component Counter",
          "description": "\nCreate a React class component named `SimpleCounter` that manages a single piece of state: `count` (initialized to 0).\n\nRequirements:\n1. Display the current `count` value.\n2. Include two buttons: 'Increment' and 'Decrement'.\n3. The 'Increment' button should increase the `count` by 1. Use the functional form of `setState` for this update to ensure reliability against batching.\n4. The 'Decrement' button should decrease the `count` by 1. Use the direct object form of `setState` for this update.\n5. Add a third button 'Reset' that sets the count back to 0.\n\nYour solution should demonstrate basic state management in a class component, including both direct and functional `setState` approaches.",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\n\nclass SimpleCounter extends React.Component {\n  // TODO: Initialize state\n  \n  // TODO: Implement increment method (functional setState)\n  \n  // TODO: Implement decrement method (direct setState)\n\n  // TODO: Implement reset method\n\n  render() {\n    return (\n      <div>\n        <h2>Simple Counter</h2>\n        {/* TODO: Display count */}\n        {/* TODO: Add Increment, Decrement, Reset buttons */}\n      </div>\n    );\n  }\n}\n\nexport default SimpleCounter;\n",
          "solutionCode": "import React from 'react';\n\nclass SimpleCounter extends React.Component {\n  state = {\n    count: 0\n  };\n\n  increment = () => {\n    this.setState(prevState => ({\n      count: prevState.count + 1\n    }));\n  };\n\n  decrement = () => {\n    this.setState({ count: this.state.count - 1 });\n  };\n\n  reset = () => {\n    this.setState({ count: 0 });\n  };\n\n  render() {\n    return (\n      <div>\n        <h2>Simple Counter</h2>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n        <button onClick={this.decrement}>Decrement</button>\n        <button onClick={this.reset}>Reset</button>\n      </div>\n    );\n  }\n}\n\nexport default SimpleCounter;\n",
          "testCases": [
            "Initial render: Count should be 0.",
            "Clicking 'Increment': Count should increase by 1.",
            "Clicking 'Decrement': Count should decrease by 1.",
            "Clicking 'Increment' multiple times rapidly: Count should increase correctly due to functional update.",
            "Clicking 'Reset': Count should return to 0.",
            "Interacting with all buttons: State should update predictably."
          ],
          "hints": [
            "Remember to use `this.state` for reading state and `this.setState()` for updating it.",
            "For functional updates, the callback function receives `prevState` as its argument.",
            "Make sure to bind `this` to your event handlers if not using arrow functions for class methods (though arrow functions are preferred for brevity here)."
          ],
          "tags": [
            "React",
            "Class Components",
            "State",
            "setState",
            "Functional setState",
            "Basic"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "theory_class_component_state_basics",
            "theory_class_component_functional_and_complex_updates"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "react_event_handling"
          ]
        },
        {
          "id": "task_class_component_form",
          "title": "Build a Class Component User Profile Form",
          "description": "\nCreate a React class component named `UserProfileForm` that manages a complex state object representing a user's profile.\n\nRequirements:\n1.  The component's state should include a `user` object with the following structure:\n    ```javascript\n    user: {\n      firstName: string,\n      lastName: string,\n      contact: {\n        email: string,\n        phone: string\n      },\n      preferences: {\n        newsletter: boolean,\n        smsNotifications: boolean\n      }\n    }\n    ```\n    Initialize all string fields to empty strings and boolean fields to `false`.\n2.  Render input fields for `firstName`, `lastName`, `email`, and `phone`.\n3.  Render checkboxes for `newsletter` and `smsNotifications`.\n4.  Implement change handlers for all input types (`onChange` for text inputs, `onChange` for checkboxes) that correctly update the corresponding state properties.\n5.  **Crucially**: All state updates must be immutable. Use the spread operator (`...`) to copy existing state properties at each level of nesting. Use the functional form of `setState` where necessary (e.g., for toggling booleans or when an update depends on previous nested state).\n6.  Display the current state (e.g., using `JSON.stringify`) to visually verify updates.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass UserProfileForm extends React.Component {\n  state = {\n    // TODO: Initialize complex user state\n  };\n\n  // TODO: Implement handleChange for text inputs (firstName, lastName, email, phone)\n  // Remember to handle nested properties immutably.\n\n  // TODO: Implement handleToggle for checkboxes (newsletter, smsNotifications)\n  // Remember to handle deeply nested properties immutably with functional setState.\n\n  render() {\n    const { user } = this.state;\n    return (\n      <div>\n        <h2>User Profile Editor (Class Component)</h2>\n        {/* TODO: Render input fields and checkboxes */}\n        {/* TODO: Display current state */}\n      </div>\n    );\n  }\n}\n\nexport default UserProfileForm;\n",
          "solutionCode": "import React from 'react';\n\nclass UserProfileForm extends React.Component {\n  state = {\n    user: {\n      firstName: '',\n      lastName: '',\n      contact: {\n        email: '',\n        phone: ''\n      },\n      preferences: {\n        newsletter: false,\n        smsNotifications: false\n      }\n    }\n  };\n\n  handleTextChange = (event) => {\n    const { name, value } = event.target;\n    this.setState(prevState => {\n      // Split name by dot for nested properties, e.g., 'contact.email'\n      const nameParts = name.split('.');\n      if (nameParts.length === 1) {\n        // Top-level property of user\n        return {\n          user: {\n            ...prevState.user,\n            [name]: value\n          }\n        };\n      } else if (nameParts.length === 2) {\n        // Nested property, e.g., contact.email or preferences.newsletter\n        const [parent, child] = nameParts;\n        return {\n          user: {\n            ...prevState.user,\n            [parent]: {\n              ...prevState.user[parent],\n              [child]: value\n            }\n          }\n        };\n      }\n      return prevState; // Should not reach here\n    });\n  };\n\n  handleToggleChange = (event) => {\n    const { name, checked } = event.target;\n    this.setState(prevState => {\n      const nameParts = name.split('.');\n      if (nameParts.length === 2) {\n        const [parent, child] = nameParts;\n        return {\n          user: {\n            ...prevState.user,\n            [parent]: {\n              ...prevState.user[parent],\n              [child]: checked\n            }\n          }\n        };\n      }\n      return prevState; // Should not reach here\n    });\n  };\n\n  render() {\n    const { user } = this.state;\n    return (\n      <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n        <h2>User Profile Editor (Class Component)</h2>\n        <div>\n          <label>First Name:</label>\n          <input type=\"text\" name=\"firstName\" value={user.firstName} onChange={this.handleTextChange} />\n        </div>\n        <div>\n          <label>Last Name:</label>\n          <input type=\"text\" name=\"lastName\" value={user.lastName} onChange={this.handleTextChange} />\n        </div>\n        <h3>Contact Info</h3>\n        <div>\n          <label>Email:</label>\n          <input type=\"email\" name=\"contact.email\" value={user.contact.email} onChange={this.handleTextChange} />\n        </div>\n        <div>\n          <label>Phone:</label>\n          <input type=\"text\" name=\"contact.phone\" value={user.contact.phone} onChange={this.handleTextChange} />\n        </div>\n        <h3>Preferences</h3>\n        <div>\n          <label>\n            <input type=\"checkbox\" name=\"preferences.newsletter\" checked={user.preferences.newsletter} onChange={this.handleToggleChange} />\n            Receive Newsletter\n          </label>\n        </div>\n        <div>\n          <label>\n            <input type=\"checkbox\" name=\"preferences.smsNotifications\" checked={user.preferences.smsNotifications} onChange={this.handleToggleChange} />\n            SMS Notifications\n          </label>\n        </div>\n        <hr/>\n        <h4>Current State:</h4>\n        <pre>{JSON.stringify(user, null, 2)}</pre>\n      </div>\n    );\n  }\n}\n\nexport default UserProfileForm;\n",
          "testCases": [
            "Initial render: All fields should match initial state (empty strings, false booleans).",
            "Typing in 'First Name' field: Only `user.firstName` should update.",
            "Typing in 'Email' field: Only `user.contact.email` should update, `firstName`, `lastName`, etc., should remain unchanged.",
            "Toggling 'Receive Newsletter': Only `user.preferences.newsletter` should toggle, other state values unaffected.",
            "Rapid typing in multiple fields: All updates should be applied correctly due to immutable updates and functional setState.",
            "Verify JSON.stringify output matches expected state after various interactions."
          ],
          "hints": [
            "For handling generic `onChange` for different input types, consider using the `name` attribute of the input elements and `event.target.name` to identify which property to update.",
            "When updating nested objects, remember to spread (`...`) all sibling properties to avoid losing them.",
            "The functional form of `setState` (`prevState => newState`) is highly recommended for complex updates to ensure you're always operating on the most up-to-date state."
          ],
          "tags": [
            "React",
            "Class Components",
            "State Management",
            "Form Handling",
            "Immutability",
            "Complex State",
            "setState"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_class_component_state_basics",
            "theory_class_component_functional_and_complex_updates"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "react_forms",
            "javascript_spread_operator"
          ]
        },
        {
          "id": "task_functional_counter_app",
          "title": "Build a Feature-Rich Functional Counter with useState",
          "description": "\nCreate a React functional component named `FeatureCounter` that demonstrates advanced `useState` usage.\n\nRequirements:\n1.  Initialize the `count` state with a default value of 0.\n2.  Display the current `count`.\n3.  Implement an 'Increment' button that increases the count by 1. Use the functional update form (`prevCount => prevCount + 1`).\n4.  Implement a 'Decrement' button that decreases the count by 1, ensuring the count never goes below 0.\n5.  Implement a 'Reset' button that sets the count back to 0.\n6.  Add an input field and a 'Set Count' button. When the button is clicked, it should set the count to the value entered in the input field. Validate that the input is a valid number before updating the state; if not, show an error message and do not update count.\n7.  Implement a 'Fast Increment' button that increments the count by 5 in a single click. Demonstrate that using the functional update form sequentially results in the correct total increment (e.g., `setCount(prev => prev + 1)` called 5 times).",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\nfunction FeatureCounter() {\n  // TODO: Initialize count state\n  // TODO: Initialize error state for input validation\n\n  // TODO: Implement increment, decrement, reset functions\n\n  // TODO: Implement handleSetCount function with validation\n\n  // TODO: Implement fastIncrement function\n\n  return (\n    <div>\n      <h2>Feature-Rich Counter (Functional Component)</h2>\n      {/* TODO: Display count, buttons, input field, and error message */}\n    </div>\n  );\n}\n\nexport default FeatureCounter;\n",
          "solutionCode": "import React, { useState } from 'react';\n\nfunction FeatureCounter() {\n  const [count, setCount] = useState(0);\n  const [inputValue, setInputValue] = useState('');\n  const [error, setError] = useState('');\n\n  const increment = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  const decrement = () => {\n    setCount(prevCount => Math.max(0, prevCount - 1));\n  };\n\n  const reset = () => {\n    setCount(0);\n    setError(''); // Clear error on reset\n    setInputValue('');\n  };\n\n  const handleInputChange = (event) => {\n    setInputValue(event.target.value);\n    setError(''); // Clear error as user types\n  };\n\n  const handleSetCount = () => {\n    const num = parseInt(inputValue, 10);\n    if (isNaN(num)) {\n      setError('Please enter a valid number.');\n    } else {\n      setCount(num);\n      setError('');\n    }\n  };\n\n  const fastIncrement = () => {\n    // Calling functional update multiple times in a batch ensures correct increment\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <h2>Feature-Rich Counter (Functional Component)</h2>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n      <button onClick={reset}>Reset</button>\n      <hr />\n      <div>\n        <input\n          type=\"text\"\n          value={inputValue}\n          onChange={handleInputChange}\n          placeholder=\"Enter number\"\n        />\n        <button onClick={handleSetCount}>Set Count</button>\n        {error && <p style={{ color: 'red' }}>{error}</p>}\n      </div>\n      <hr />\n      <button onClick={fastIncrement}>Fast Increment (+5)</button>\n    </div>\n  );\n};\n\nexport default FeatureCounter;\n",
          "testCases": [
            "Initial render: Count should be 0, input empty, no error.",
            "Increment button: Count should increase by 1.",
            "Decrement button: Count should decrease by 1, but not below 0.",
            "Reset button: Count should return to 0.",
            "Set Count: Enter '10', click Set Count -> Count becomes 10.",
            "Set Count: Enter 'abc', click Set Count -> Error message appears, Count remains unchanged.",
            "Fast Increment: Click button -> Count increases by exactly 5, demonstrating functional updates handling batching."
          ],
          "hints": [
            "Remember to use `Math.max()` to prevent the count from going below zero.",
            "For the 'Set Count' feature, use `parseInt()` to convert the input string to a number and `isNaN()` to check for valid numbers.",
            "The `setCount` function from `useState` can also accept a function as an argument, which is crucial for the 'Fast Increment' feature to work reliably when multiple updates are batched."
          ],
          "tags": [
            "React",
            "Functional Components",
            "Hooks",
            "useState",
            "State Management",
            "Input Validation",
            "Batching"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_functional_component_state_useState"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "react_forms",
            "javascript_type_conversion"
          ]
        },
        {
          "id": "task_functional_shopping_cart",
          "title": "Implement a Functional Shopping Cart with Nested State",
          "description": "\nCreate a React functional component `ShoppingCart` that manages a list of items in a shopping cart. The state should be an array of objects, where each object represents a cart item.\n\nRequirements:\n1.  **State Structure**: The `cartItems` state should be an array of objects, e.g.:\n    ```javascript\n    [\n      { id: 1, name: 'Laptop', price: 1200, quantity: 1 },\n      { id: 2, name: 'Mouse', price: 25, quantity: 2 }\n    ]\n    ```\n    Initialize with at least two sample items.\n2.  **Display Cart**: Render the current items in the cart, showing name, price, quantity, and a subtotal for each item (`price * quantity`). Display the overall total price of all items in the cart.\n3.  **Add Item**: Implement a function `addItem(newItem)` that adds a new item to the cart. If the item (by `id`) already exists, increment its quantity; otherwise, add it as a new item. Ensure this is an immutable update.\n4.  **Remove Item**: Implement a function `removeItem(itemId)` that removes an item from the cart by its `id`. This should also be immutable.\n5.  **Update Quantity**: Implement a function `updateQuantity(itemId, newQuantity)` that changes an item's quantity. Ensure quantity cannot go below 1. This must be an immutable update.\n6.  **All state updates must be immutable**. Use the `useState` functional updater form (`prevItems => ...`) for all modifications to guarantee consistency.\n7.  Add buttons or input fields to trigger these actions for demonstration.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\n\nfunction ShoppingCart() {\n  // TODO: Initialize cartItems state with sample data\n\n  // TODO: Implement addItem function\n\n  // TODO: Implement removeItem function\n\n  // TODO: Implement updateQuantity function\n\n  // TODO: Calculate total price\n\n  return (\n    <div>\n      <h2>My Shopping Cart (Functional Component)</h2>\n      {/* TODO: Render cart items and total */}\n      {/* TODO: Add controls for addItem, removeItem, updateQuantity */}\n    </div>\n  );\n}\n\nexport default ShoppingCart;\n",
          "solutionCode": "import React, { useState, useMemo } from 'react';\n\nfunction ShoppingCart() {\n  const [cartItems, setCartItems] = useState([\n    { id: 1, name: 'Laptop', price: 1200, quantity: 1 },\n    { id: 2, name: 'Mouse', price: 25, quantity: 2 },\n    { id: 3, name: 'Keyboard', price: 75, quantity: 1 }\n  ]);\n\n  const addItem = (itemToAdd) => {\n    setCartItems(prevItems => {\n      const existingItem = prevItems.find(item => item.id === itemToAdd.id);\n      if (existingItem) {\n        // If item exists, update its quantity\n        return prevItems.map(item =>\n          item.id === itemToAdd.id ? { ...item, quantity: item.quantity + 1 } : item\n        );\n      } else {\n        // If item is new, add it to the cart\n        return [...prevItems, { ...itemToAdd, quantity: 1 }];\n      }\n    });\n  };\n\n  const removeItem = (itemId) => {\n    setCartItems(prevItems => prevItems.filter(item => item.id !== itemId));\n  };\n\n  const updateQuantity = (itemId, newQuantity) => {\n    setCartItems(prevItems =>\n      prevItems.map(item =>\n        item.id === itemId ? { ...item, quantity: Math.max(1, newQuantity) } : item\n      )\n    );\n  };\n\n  // Calculate total price using useMemo for performance\n  const total = useMemo(() => {\n    return cartItems.reduce((sum, item) => sum + item.price * item.quantity, 0);\n  }, [cartItems]);\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <h2>My Shopping Cart (Functional Component)</h2>\n      <div>\n        <h3>Items:</h3>\n        {cartItems.length === 0 ? (\n          <p>Your cart is empty.</p>\n        ) : (\n          <ul>\n            {cartItems.map(item => (\n              <li key={item.id} style={{ marginBottom: '10px' }}>\n                {item.name} - ${item.price} x \n                <button onClick={() => updateQuantity(item.id, item.quantity - 1)}>-</button>\n                {item.quantity}\n                <button onClick={() => updateQuantity(item.id, item.quantity + 1)}>+</button>\n                (Subtotal: ${(item.price * item.quantity).toFixed(2)})\n                <button onClick={() => removeItem(item.id)} style={{ marginLeft: '10px', color: 'red' }}>Remove</button>\n              </li>\n            ))}\n          </ul>\n        )}\n        <h3>Total: ${total.toFixed(2)}</h3>\n      </div>\n      <hr />\n      <div>\n        <h4>Add new items:</h4>\n        <button onClick={() => addItem({ id: 4, name: 'Monitor', price: 300 })}>Add Monitor</button>\n        <button onClick={() => addItem({ id: 1, name: 'Laptop', price: 1200 })} style={{ marginLeft: '10px' }}>Add Laptop (existing)</button>\n      </div>\n    </div>\n  );\n}\n\nexport default ShoppingCart;\n",
          "testCases": [
            "Initial render: Cart displays sample items and correct total.",
            "Click 'Add Monitor': Monitor should appear with quantity 1, total updates.",
            "Click 'Add Laptop' (existing): Laptop quantity should increment, total updates.",
            "Click '-' button on an item: Quantity decreases, but not below 1. Total updates.",
            "Click '+' button on an item: Quantity increases, total updates.",
            "Click 'Remove' button: Item disappears, total updates.",
            "Remove all items: Cart shows 'empty' message, total is 0.",
            "Verify immutability: Ensure no direct modification of `cartItems` array or item objects."
          ],
          "hints": [
            "When adding or removing items from an array, think about `filter` and spreading the array (`[...array, newItem]`).",
            "When updating an item's property within an array, `map` is your friend. Remember to create a new object for the modified item as well (`{ ...item, key: newValue }`).",
            "Always use the functional form of `setCartItems` to ensure you're working with the latest `prevItems`."
          ],
          "tags": [
            "React",
            "Functional Components",
            "Hooks",
            "useState",
            "Complex State",
            "Array State",
            "Immutability",
            "Shopping Cart",
            "Coding Challenge"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_functional_component_state_useState",
            "theory_functional_component_complex_useState"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "javascript_array_methods",
            "react_use_memo"
          ]
        }
      ]
    }
  }
]