[
  {
    "id": "fc01bbfd-4217-41a5-8f6b-34fe201ee2b4",
    "startLine": 16700,
    "endLine": 16799,
    "processedDate": "2025-06-17T15:32:50.188Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_state_and_hooks",
          "title": "React State Management and Essential Hooks (`useState`, `useEffect`, `useRef`)",
          "content": "This section covers the fundamental React Hooks (`useState`, `useEffect`, `useRef`) as demonstrated in the provided search component. These hooks are crucial for managing component state, handling side effects, and directly interacting with the DOM.\n\n## `useState` Hook\n`useState` is a React Hook that lets you add state variables to your functional components. It returns a pair: the current state value and a function that lets you update it. When the state updater function is called, React re-renders the component.\n\n**Syntax:** `const [state, setState] = useState(initialState);`\n\n*   `state`: The current value of the state.\n*   `setState`: A function to update the state. It can accept a new value directly or a function that receives the previous state and returns the new state (useful for updates based on previous state).\n*   `initialState`: The initial value of the state variable.\n\nIn the provided code, `searchTerm`, `searchResults`, `selectedIndex`, and `isDropdownOpen` are all managed using `useState`, reflecting user input, search outcomes, UI navigation, and UI visibility.\n\n## `useEffect` Hook\n`useEffect` is a React Hook that lets you synchronize a component with an external system. It's commonly used for side effects like data fetching, subscriptions, or manually changing the DOM.\n\n**Syntax:** `useEffect(() => { /* side effect */ }, [dependencies]);`\n\n*   The first argument is a function containing the side effect logic.\n*   The second argument is an optional dependency array. If provided, the effect will only re-run if any value in the array changes. An empty array (`[]`) means the effect runs only once after the initial render (like `componentDidMount`). Omitting the array means the effect runs after every render.\n\nIn the example, `useEffect` is used to `scrollIntoView` the selected search result. This effect depends on `selectedIndex` and `isDropdownOpen`, ensuring the scrolling happens only when the dropdown is open and the selected item changes.\n\n## `useRef` Hook\n`useRef` is a React Hook that lets you reference a value that's not needed for rendering. It's often used to access a DOM element directly or to persist a mutable value across renders without causing re-renders when it changes.\n\n**Syntax:** `const ref = useRef(initialValue);`\n\n*   It returns a mutable `ref` object whose `.current` property is initialized to the passed `initialValue`.\n*   The `ref.current` property can be updated directly, and these updates do not trigger re-renders.\n\nIn the provided code, `searchInputRef` is used to directly reference the input element, and `resultsContainerRef` is used for the results container, enabling imperative DOM manipulations like `scrollIntoView`.\n\n### Relationship Between Hooks and Component Lifecycle\nWhile hooks don't directly map to lifecycle methods, they provide equivalent functionality:\n*   **Mounting:** `useEffect(() => {}, [])`\n*   **Updating:** `useEffect(() => {}, [dependencies])`\n*   **Unmounting:** `useEffect(() => { return () => { /* cleanup */ }; }, [])` (The return function is the cleanup function.)",
          "examples": [
            {
              "id": "example_usestate_1",
              "title": "Basic useState Example",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <button onClick={() => setCount(prevCount => prevCount - 1)}>Decrement</button>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates `useState` to manage a simple counter. `setCount(count + 1)` directly sets the new value, while `setCount(prevCount => prevCount - 1)` uses a functional update, which is safer when the new state depends on the previous state.",
              "language": "typescript"
            },
            {
              "id": "example_useeffect_useref_1",
              "title": "useEffect and useRef for Focus Management",
              "code": "import React, { useEffect, useRef } from 'react';\n\nfunction MyInput() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // Focus the input element on component mount\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Empty dependency array means this runs once on mount\n\n  return <input type=\"text\" ref={inputRef} placeholder=\"I will be focused!\" />;\n}",
              "explanation": "This example shows `useRef` to get a direct reference to a DOM input element. `useEffect` then uses this ref to call the `focus()` method on the input element once the component mounts.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_usestate_functional_update_mcq",
            "question_useeffect_dependencies_mcq",
            "question_useref_purpose_flashcard",
            "question_state_vs_ref_open"
          ],
          "relatedTasks": [
            "task_refactor_usestate_toreducer",
            "task_implement_debounced_search"
          ],
          "tags": [
            "React",
            "Hooks",
            "State Management",
            "useEffect",
            "useState",
            "useRef"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript_basics",
            "DOM_manipulation_basics",
            "Functional_programming_concepts"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Complex_UI_development",
            "Custom_hooks",
            "Performance_optimization_in_React"
          ]
        },
        {
          "id": "theory_event_handling_and_keyboard_navigation",
          "title": "React Event Handling and Keyboard Navigation",
          "content": "This section details how React handles events and specifically focuses on implementing robust keyboard navigation, which is critical for accessibility in interactive components like search autocomplete or dropdowns.\n\n## React Event System\nReact uses a synthetic event system that wraps browser's native events. This system provides a consistent cross-browser API for events and also enables event delegation for performance optimization.\n\nKey event handlers used in the example:\n*   `onChange`: Fired when the value of an input element changes.\n*   `onKeyDown`: Fired when a key is pressed down.\n*   `onClick`: Fired when an element is clicked.\n*   `onMouseEnter`: Fired when the pointer is moved onto an element.\n*   `onFocus`: Fired when an element receives focus.\n\nThe event object (`e`) passed to event handlers is a synthetic event. It has properties like `e.target` (the DOM element that triggered the event), `e.target.value` (for input elements), and `e.key` (for keyboard events).\n\n## Keyboard Navigation\nThe provided component implements keyboard navigation for its search results dropdown, which is a key accessibility feature. This involves:\n\n1.  **Detecting Key Presses**: Using the `onKeyDown` event handler.\n2.  **Identifying Specific Keys**: Checking `e.key` property (e.g., `'ArrowDown'`, `'ArrowUp'`, `'Enter'`, `'Escape'`)\n3.  **Preventing Default Behavior**: Calling `e.preventDefault()` to stop the browser's default action for certain keys (e.g., preventing arrow keys from scrolling the page).\n4.  **Updating State Based on Key**: Modifying `selectedIndex` for arrow keys, or triggering an action for `Enter` (selection) or `Escape` (closing dropdown).\n5.  **Conditional Execution**: Ensuring keyboard navigation only works when the dropdown is open (`if (!isDropdownOpen) return;`).\n\nThis robust keyboard handling ensures users can navigate and select items without a mouse, significantly improving usability and accessibility.",
          "examples": [
            {
              "id": "example_event_handling_1",
              "title": "Input Change and Key Press Handling",
              "code": "import React, { useState } from 'react';\n\nfunction InputLogger() {\n  const [text, setText] = useState('');\n\n  const handleChange = (e) => {\n    setText(e.target.value);\n    console.log('Input changed:', e.target.value);\n  };\n\n  const handleKeyPress = (e) => {\n    if (e.key === 'A') {\n      console.log('You pressed A!');\n    }\n    if (e.key === 'Enter') {\n      e.preventDefault(); // Prevents new line in a textarea\n      console.log('Enter pressed! Current text:', text);\n    }\n  };\n\n  return (\n    <input\n      type=\"text\"\n      value={text}\n      onChange={handleChange}\n      onKeyDown={handleKeyPress}\n      placeholder=\"Type something...\"\n    />\n  );\n}",
              "explanation": "This example demonstrates `onChange` to capture input value changes and `onKeyDown` to react to specific key presses. It also shows `e.preventDefault()` to stop the browser's default behavior for the 'Enter' key in a text input.",
              "language": "typescript"
            },
            {
              "id": "example_keyboard_nav_scroll_1",
              "title": "Simplified Keyboard Navigation with Scrolling",
              "code": "import React, { useState, useEffect, useRef } from 'react';\n\nfunction ListNavigator({ items }) {\n  const [selectedIndex, setSelectedIndex] = useState(-1);\n  const listRef = useRef(null);\n\n  useEffect(() => {\n    if (listRef.current && selectedIndex !== -1) {\n      const selectedElement = listRef.current.children[selectedIndex];\n      if (selectedElement) {\n        selectedElement.scrollIntoView({ block: 'nearest', behavior: 'smooth' });\n      }\n    }\n  }, [selectedIndex, items]);\n\n  const handleKeyDown = (e) => {\n    if (items.length === 0) return;\n\n    switch (e.key) {\n      case 'ArrowDown':\n        e.preventDefault();\n        setSelectedIndex(prev => (prev < items.length - 1) ? prev + 1 : prev);\n        break;\n      case 'ArrowUp':\n        e.preventDefault();\n        setSelectedIndex(prev => (prev > 0) ? prev - 1 : 0);\n        break;\n      case 'Enter':\n        e.preventDefault();\n        if (selectedIndex !== -1) {\n          console.log('Selected:', items[selectedIndex]);\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  return (\n    <div onKeyDown={handleKeyDown} tabIndex={0} style={{ outline: 'none' }}>\n      <ul ref={listRef} style={{ height: '150px', overflowY: 'auto', border: '1px solid gray' }}>\n        {items.map((item, index) => (\n          <li\n            key={item.id || index}\n            style={{\n              padding: '8px',\n              background: index === selectedIndex ? '#eee' : 'transparent'\n            }}\n          >\n            {item.name || item}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nconst sampleItems = [\n  { id: 1, name: 'Apple' },\n  { id: 2, name: 'Banana' },\n  { id: 3, name: 'Cherry' },\n  { id: 4, name: 'Date' },\n  { id: 5, name: 'Elderberry' },\n  { id: 6, name: 'Fig' }\n];\n\n// Usage:\n// <ListNavigator items={sampleItems} />",
              "explanation": "This example showcases how `onKeyDown` and `useEffect` work together for keyboard navigation within a scrollable list. `setSelectedIndex` updates the active item, and `useEffect` then ensures the selected item is brought into view using `scrollIntoView`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_event_object_properties_mcq",
            "question_preventdefault_open",
            "question_keyboard_nav_best_practices_open",
            "question_arrow_keys_flashcard"
          ],
          "relatedTasks": [
            "task_add_aria_attributes",
            "task_implement_debounced_search"
          ],
          "tags": [
            "React",
            "Event Handling",
            "Keyboard Navigation",
            "Accessibility",
            "UI/UX"
          ],
          "technology": "React",
          "prerequisites": [
            "HTML_events",
            "JavaScript_DOM_events",
            "React_components"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Accessible_component_development",
            "Interactive_UI_patterns"
          ]
        },
        {
          "id": "theory_search_filtering_and_list_rendering",
          "title": "Search, Filtering Logic, and Dynamic List Rendering",
          "content": "This section delves into the core logic of the search component: how data is filtered based on user input and how the filtered results are dynamically rendered as a list in React.\n\n## Search and Filtering Logic (`searchUsers` Function)\nThe `searchUsers` function is responsible for filtering a given list of `users` based on a `searchTerm`. It demonstrates several common JavaScript array and string methods:\n\n*   **`Array.prototype.filter()`**: This method creates a new array with all elements that pass the test implemented by the provided function. In the example, it's used to iterate over the `MOCK_USERS` array and select users matching the search criteria.\n*   **`String.prototype.toLowerCase()`**: Used for case-insensitive matching. Both the `searchTerm` and the user properties (name, address, purchased items) are converted to lowercase before comparison.\n*   **`String.prototype.includes()`**: This method determines whether one string may be found within another string, returning `true` or `false` as appropriate. It's used to check if the user's name, address, or zip code contains the `lowerCaseQuery`.\n*   **`Array.prototype.some()`**: This method tests whether at least one element in the array passes the test implemented by the provided function. It returns a boolean value. In the example, it's used to check if *any* of the `user.purchased` items include the search query.\n\nThe logic combines these methods to create a flexible search that looks across multiple user properties.\n\n## Dynamic List Rendering (`.map()`)\nReact components often need to display lists of data. In functional components, this is typically achieved using the `Array.prototype.map()` method in conjunction with JSX.\n\n*   **`Array.prototype.map()`**: This method creates a new array populated with the results of calling a provided function on every element in the calling array. In React, you `map` over an array of data and return a JSX element for each item.\n*   **`key` Prop**: When rendering a list of elements in React, it is crucial to provide a unique `key` prop for each item. The `key` helps React identify which items have changed, are added, or are removed, allowing it to efficiently update the UI. Without a stable `key`, React's reconciliation process can be inefficient and lead to bugs.\n    *   The `key` should be a stable and unique identifier for the item (e.g., `user.id`). Using an array index as a key (`index`) is generally discouraged if the list items can be reordered, added, or removed, as it can lead to performance issues and incorrect component state.\n\nThe example effectively uses `searchResults.map` to render `user-item` divs, assigning a unique `key` based on `user.id` and an `id` for direct DOM access (for `scrollIntoView`). Conditional CSS class (`selected`) is also applied based on `selectedIndex` for visual feedback.",
          "examples": [
            {
              "id": "example_filter_map_1",
              "title": "Filtering and Mapping Data",
              "code": "import React from 'react';\n\nconst products = [\n  { id: 1, name: 'Laptop', category: 'Electronics', price: 1200 },\n  { id: 2, name: 'Keyboard', category: 'Electronics', price: 75 },\n  { id: 3, name: 'Mouse', category: 'Electronics', price: 25 },\n  { id: 4, name: 'Desk Chair', category: 'Furniture', price: 300 },\n  { id: 5, name: 'Monitor', category: 'Electronics', price: 400 }\n];\n\nfunction ProductList({ query }) {\n  const filteredProducts = products.filter(product => \n    product.name.toLowerCase().includes(query.toLowerCase())\n  );\n\n  return (\n    <div>\n      <h2>Products:</h2>\n      {filteredProducts.length > 0 ? (\n        <ul>\n          {filteredProducts.map(product => (\n            <li key={product.id}>\n              {product.name} ({product.category}) - ${product.price}\n            </li>\n          ))}\n        </ul>\n      ) : (\n        <p>No products found for \"{query}\"</p>\n      )}\n    </div>\n  );\n}\n\n// Usage:\n// <ProductList query=\"lap\" />\n// <ProductList query=\"e\" />\n// <ProductList query=\"xyz\" />",
              "explanation": "This example demonstrates filtering a list of `products` based on a search `query` using `filter()` and then rendering the `filteredProducts` using `map()`. It also shows conditional rendering for when no results are found and the importance of the `key` prop.",
              "language": "typescript"
            },
            {
              "id": "example_array_some_1",
              "title": "Using Array.some() for Conditional Checks",
              "code": "const tags = ['react', 'javascript', 'frontend', 'hooks'];\n\nfunction hasSpecificTag(tagList, specificTag) {\n  return tagList.some(tag => tag === specificTag);\n}\n\nconsole.log(hasSpecificTag(tags, 'react'));     // true\nconsole.log(hasSpecificTag(tags, 'angular'));    // false\n\nconst userPermissions = ['admin', 'edit_posts', 'view_dashboard'];\n\nfunction canUserPerformAction(userPermissions, requiredPermission) {\n  return userPermissions.some(permission => permission === requiredPermission);\n}\n\nconsole.log(canUserPerformAction(userPermissions, 'admin')); // true\nconsole.log(canUserPerformAction(userPermissions, 'delete_users')); // false",
              "explanation": "This example illustrates the `Array.prototype.some()` method. It's useful when you need to check if at least one element in an array satisfies a given condition, returning `true` as soon as a match is found, or `false` otherwise.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_array_filter_mcq",
            "question_string_includes_flashcard",
            "question_map_key_importance_open",
            "question_array_some_use_case_mcq"
          ],
          "relatedTasks": [
            "task_enhance_search_function",
            "task_refactor_usestate_toreducer"
          ],
          "tags": [
            "JavaScript",
            "Arrays",
            "String Methods",
            "React",
            "List Rendering",
            "Filtering",
            "Search"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "JavaScript_arrays",
            "JavaScript_strings",
            "ES6_arrow_functions"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Data_manipulation",
            "Dynamic_UI",
            "Search_components"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_usestate_functional_update_mcq",
          "topic": "React useState Hook",
          "level": "easy",
          "type": "mcq",
          "question": "Given the following React state update for `selectedIndex`:\n```javascript\nsetSelectedIndex(prev => (prev < searchResults.length - 1) ? prev + 1 : prev);\n```\nWhat is the primary reason for using the functional update form (`prev => ...`) instead of directly `setSelectedIndex(selectedIndex + 1)`?",
          "answer": "To ensure the update uses the most recent state, especially in asynchronous updates or when multiple updates are batched.",
          "options": [
            "It is syntactically shorter and more readable.",
            "It automatically prevents component re-renders.",
            "To ensure the update uses the most recent state, especially in asynchronous updates or when multiple updates are batched.",
            "It allows for direct modification of the previous state object."
          ],
          "analysisPoints": [
            "Functional updates receive the previous state as an argument, guaranteeing that the update is based on the most current state value.",
            "This is particularly important in scenarios where state updates might be batched or asynchronous, preventing stale closures.",
            "Direct updates like `setCount(count + 1)` can lead to incorrect state when React batches updates or when `count` is captured from an earlier render scope."
          ],
          "keyConcepts": [
            "React useState",
            "Functional State Updates",
            "Asynchronous State Updates",
            "State Batching"
          ],
          "evaluationCriteria": [
            "Understanding of useState's functional update mechanism.",
            "Awareness of potential issues with direct state updates.",
            "Knowledge of React's state update behavior."
          ],
          "example": "```javascript\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    // If this is called multiple times quickly, \n    // using 'count + 1' might use a stale 'count' value.\n    // Using 'prevCount => prevCount + 1' ensures each update\n    // is based on the latest available state.\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return <button onClick={handleClick}>Increment {count}</button>;\n}\n```",
          "tags": [
            "React",
            "useState",
            "Hooks",
            "State Management",
            "Best Practices"
          ],
          "prerequisites": [
            "React_functional_components",
            "JavaScript_arrow_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_useeffect_dependencies_mcq",
          "topic": "React useEffect Hook",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `useEffect` hook from the component:\n```javascript\nuseEffect(() => {\n  if (isDropdownOpen && resultsContainerRef.current) {\n    const selectedElement = document.getElementById(`user-item-${selectedIndex}`);\n    if (selectedElement) {\n      selectedElement.scrollIntoView({ block: 'nearest', behavior: 'smooth' });\n    }\n  }\n}, [selectedIndex, isDropdownOpen]);\n```\nWhat would be the effect if `isDropdownOpen` was removed from the dependency array, making it `[selectedIndex]`?",
          "answer": "The scroll effect would run whenever `selectedIndex` changes, even if `isDropdownOpen` is false, potentially causing errors or unexpected behavior.",
          "options": [
            "The effect would only run once on component mount.",
            "The scroll effect would run whenever `selectedIndex` changes, even if `isDropdownOpen` is false, potentially causing errors or unexpected behavior.",
            "The component would enter an infinite re-render loop.",
            "The `resultsContainerRef.current` would always be null."
          ],
          "analysisPoints": [
            "Dependencies in `useEffect` control when the effect re-runs. If a value used inside the effect (like `isDropdownOpen`) is not in the dependency array, the effect might 'see' a stale value from a previous render.",
            "In this specific case, if `isDropdownOpen` is omitted, the `if (isDropdownOpen && resultsContainerRef.current)` check inside the effect would use the `isDropdownOpen` value from the render when the effect was initially set up, not its current value.",
            "This means if `selectedIndex` changes while `isDropdownOpen` is `false`, the effect would still execute its body with the potentially stale `isDropdownOpen` value, leading to the `if` condition evaluating based on the stale state, or if the initial `isDropdownOpen` was true, the scroll logic attempting to run even when it should not."
          ],
          "keyConcepts": [
            "React useEffect",
            "Dependency Array",
            "Stale Closures",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Understanding of `useEffect`'s dependency array.",
            "Ability to predict the impact of missing dependencies.",
            "Knowledge of how `useEffect` interacts with state changes."
          ],
          "example": "```javascript\nimport React, { useState, useEffect } from 'react';\n\nfunction StaleStateExample() {\n  const [count, setCount] = useState(0);\n  const [isActive, setIsActive] = useState(true);\n\n  useEffect(() => {\n    // If isActive is not in dependencies, this effect will only 'see' the\n    // isActive value from the render it was set up in. If isActive changes later,\n    // this effect will still use the old isActive value when count changes.\n    console.log(`Count: ${count}, Is Active: ${isActive}`);\n  }, [count]); // Missing isActive in dependencies\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\n      <button onClick={() => setIsActive(!isActive)}>Toggle Active ({String(isActive)})</button>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "useEffect",
            "Hooks",
            "Debugging",
            "Side Effects"
          ],
          "prerequisites": [
            "React_Hooks",
            "JavaScript_closures"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_useref_purpose_flashcard",
          "topic": "React useRef Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `useRef` hook in React, as seen with `searchInputRef` and `resultsContainerRef`?",
          "answer": "To get a direct reference to a DOM element or to persist a mutable value across renders without causing re-renders.",
          "analysisPoints": [
            "Focus on its utility for imperative DOM manipulation (like `focus()` or `scrollIntoView`).",
            "Mention its use for storing mutable values that don't trigger re-renders, unlike `useState`."
          ],
          "keyConcepts": [
            "React useRef",
            "DOM References",
            "Imperative Programming",
            "Mutable Values"
          ],
          "evaluationCriteria": [
            "Basic understanding of `useRef`.",
            "Ability to distinguish it from `useState`.",
            "Recognition of its common use cases."
          ],
          "example": "```javascript\nimport React, { useRef, useEffect } from 'react';\n\nfunction AutoFocusInput() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    inputRef.current.focus();\n  }, []);\n\n  return <input ref={inputRef} type=\"text\" />;\n}\n```",
          "tags": [
            "React",
            "useRef",
            "Hooks",
            "DOM"
          ],
          "prerequisites": [
            "React_Hooks"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_vs_ref_open",
          "topic": "React State Management",
          "level": "medium",
          "type": "open",
          "question": "The search component uses `useState` for `searchTerm` (user's input) and `useRef` for `searchInputRef` (the input element itself). Explain the fundamental difference in when you would choose to use `useState` versus `useRef` in a React component, providing examples for each from the context of this search component.",
          "answer": "When to use `useState` vs. `useRef`:\n\n*   **`useState`**: Use `useState` when the value needs to trigger a re-render of the component whenever it changes. It's for data that impacts the component's UI output or flow.\n    *   **Example from component**: `searchTerm` (the text in the search input). When `searchTerm` changes, the component needs to re-render to reflect the new input value and update the search results. `searchResults`, `selectedIndex`, and `isDropdownOpen` also fall into this category because changes to them directly affect what the user sees.\n\n*   **`useRef`**: Use `useRef` when you need to store a mutable value that does *not* trigger a re-render when it changes, or when you need a direct reference to a DOM element. It's for values that persist across renders but whose changes don't inherently require a UI update.\n    *   **Example from component**: `searchInputRef` and `resultsContainerRef`. These refs are used to gain direct access to the underlying DOM elements. For example, to call `element.focus()` or `element.scrollIntoView()`. Changing the `.current` property of a ref does not cause the component to re-render, which is appropriate for these imperative DOM operations.",
          "analysisPoints": [
            "Clear distinction between re-rendering behavior.",
            "Appropriate examples from the provided code.",
            "Understanding of the core purpose of each hook.",
            "Ability to articulate use cases for each."
          ],
          "keyConcepts": [
            "React useState",
            "React useRef",
            "State Management",
            "DOM Manipulation",
            "Component Re-renders"
          ],
          "evaluationCriteria": [
            "Accuracy of definitions.",
            "Relevance and correctness of examples.",
            "Demonstration of conceptual understanding.",
            "Clarity and conciseness of explanation."
          ],
          "example": "```javascript\nimport React, { useState, useRef } from 'react';\n\nfunction StateVsRef() {\n  // State: Changes here cause re-renders, displayed in UI\n  const [message, setMessage] = useState('Hello');\n\n  // Ref: Changes here do NOT cause re-renders, used for direct DOM access or mutable non-UI values\n  const inputRef = useRef(null);\n\n  const handleChange = (e) => setMessage(e.target.value);\n  const handleFocusClick = () => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  };\n\n  return (\n    <div>\n      <input ref={inputRef} value={message} onChange={handleChange} />\n      <p>Current Message: {message}</p>\n      <button onClick={handleFocusClick}>Focus Input</button>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "useRef",
            "State Management"
          ],
          "prerequisites": [
            "React_Hooks"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_object_properties_mcq",
          "topic": "React Event Handling",
          "level": "easy",
          "type": "mcq",
          "question": "In the `handleInputChange` function, `e.target.value` is used to get the current value of the input field. If `handleKeyDown` also needed to know the current value of the input field, which property of the `e` (synthetic event) object would it use?",
          "answer": "`e.target.value`",
          "options": [
            "`e.key`",
            "`e.keyCode`",
            "`e.target.value`",
            "`e.value`"
          ],
          "analysisPoints": [
            "`e.target` refers to the DOM element on which the event occurred.",
            "For input elements, `e.target.value` consistently provides the current value.",
            "`e.key` is specific to keyboard events and indicates which key was pressed.",
            "`e.keyCode` is deprecated."
          ],
          "keyConcepts": [
            "React Synthetic Events",
            "Event Object Properties",
            "Input Event Handling",
            "Keyboard Event Handling"
          ],
          "evaluationCriteria": [
            "Understanding of common event object properties.",
            "Knowledge of how to access input values.",
            "Distinction between different event types."
          ],
          "example": "```javascript\nimport React, { useState } from 'react';\n\nfunction InputValueChecker() {\n  const [inputValue, setInputValue] = useState('');\n\n  const handleGenericEvent = (e) => {\n    console.log('Event target value:', e.target.value);\n    if (e.key) {\n      console.log('Key pressed:', e.key);\n    }\n  };\n\n  return (\n    <input\n      type=\"text\"\n      value={inputValue}\n      onChange={handleGenericEvent}\n      onKeyDown={handleGenericEvent}\n      placeholder=\"Type and press keys\"\n    />\n  );\n}\n```",
          "tags": [
            "React",
            "Event Handling",
            "DOM Events",
            "Input"
          ],
          "prerequisites": [
            "JavaScript_DOM_events"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_preventdefault_open",
          "topic": "React Event Handling and Accessibility",
          "level": "medium",
          "type": "open",
          "question": "The `handleKeyDown` function uses `e.preventDefault()` for `ArrowDown`, `ArrowUp`, `Enter`, and `Escape` keys. Explain why `e.preventDefault()` is crucial here and what would happen if it were omitted for these specific keys.",
          "answer": "`e.preventDefault()` is crucial in `handleKeyDown` to stop the browser's default behavior for certain keys, which would interfere with the custom keyboard navigation implemented for the search dropdown.\n\n*   **`ArrowDown` and `ArrowUp`**: Without `e.preventDefault()`, these keys would cause the browser to scroll the entire page up or down. This would conflict with the component's intended behavior of navigating through the search results list, leading to a confusing user experience where pressing an arrow key scrolls the page instead of changing the selected item.\n*   **`Enter`**: If `e.preventDefault()` is omitted for `Enter` on an input field within a form, it might submit the form. Even without an explicit form, some browsers might trigger a click on a default button or submit the current input value in unexpected ways. Preventing default ensures `Enter` only triggers the custom user selection logic (`handleSelectUser`).\n*   **`Escape`**: Depending on the context (e.g., if the input is part of a dialog or modal), `Escape` might close the entire dialog. In this search component, `e.preventDefault()` ensures that `Escape` specifically closes the dropdown, preventing any unintended side effects from browser defaults.",
          "analysisPoints": [
            "Understanding of `e.preventDefault()`'s purpose.",
            "Identification of specific browser default behaviors for common keys.",
            "Explanation of how these defaults conflict with custom UI logic.",
            "Emphasis on improving user experience and accessibility."
          ],
          "keyConcepts": [
            "Event Object",
            "e.preventDefault()",
            "Browser Default Behavior",
            "Keyboard Accessibility",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Thorough explanation of `preventDefault`.",
            "Accurate description of consequences for each key.",
            "Connection to accessibility and UX.",
            "Clarity and detail."
          ],
          "example": "```javascript\nfunction handleInputKeyDown(e) {\n  if (e.key === 'Enter') {\n    e.preventDefault(); // Prevents form submission or new line in textareas\n    console.log('Enter pressed, default prevented.');\n  }\n  if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {\n    e.preventDefault(); // Prevents page scrolling\n    console.log(`Arrow key pressed: ${e.key}, default prevented.`);\n  }\n}\n\n// In JSX:\n// <input type=\"text\" onKeyDown={handleInputKeyDown} />\n```",
          "tags": [
            "JavaScript",
            "Event Handling",
            "Accessibility",
            "Frontend Development"
          ],
          "prerequisites": [
            "HTML_event_defaults"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_keyboard_nav_best_practices_open",
          "topic": "Keyboard Navigation and Accessibility",
          "level": "hard",
          "type": "open",
          "question": "Beyond the basic `ArrowUp`/`ArrowDown`/`Enter`/`Escape` handling shown, what other accessibility best practices or keyboard navigation features should a production-ready search autocomplete component implement? Discuss at least three, explaining their importance.",
          "answer": "A production-ready search autocomplete should implement several additional accessibility best practices:\n\n1.  **ARIA Attributes (Accessible Rich Internet Applications)**: These attributes provide semantic meaning to UI elements, making them understandable to assistive technologies (like screen readers). Essential ARIA attributes for an autocomplete include:\n    *   `role=\"combobox\"` on the input's container.\n    *   `aria-autocomplete=\"list\"` on the input.\n    *   `aria-controls=\"[ID_of_results_list]\"` on the input.\n    *   `aria-expanded=\"true\"` or `\"false\"` on the input to indicate dropdown visibility.\n    *   `aria-activedescendant=\"[ID_of_selected_item]\"` on the input, updated as `selectedIndex` changes, to inform screen readers which item is currently 'selected' by keyboard navigation.\n    *   `role=\"listbox\"` on the results container.\n    *   `role=\"option\"` on each result item.\n    *   **Importance**: These attributes are crucial for screen reader users to understand the component's purpose, its current state (e.g., is the dropdown open?), and how to interact with it, especially which item is currently highlighted.\n\n2.  **Focus Management (Tab and Shift+Tab)**: Users should be able to tab into the search input and then, with further tabs, move out of the component or to the next logical element on the page, or use `Shift+Tab` to go backward. Crucially, when the dropdown is open, pressing `Tab` should either select the currently highlighted item or move focus *into* the dropdown itself (e.g., to the first result), and `Shift+Tab` should move focus back to the input.\n    *   **Importance**: Ensures predictable and intuitive navigation flow for keyboard users, preventing them from getting 'trapped' within the component.\n\n3.  **Live Region (`aria-live`) for Search Status/No Results**: For dynamically updating content like search results, a 'live region' can inform screen readers about changes without explicitly moving focus. For example, when results load or when 'No results found' appears, this information can be conveyed.\n    *   **Importance**: Provides immediate feedback to screen reader users about the outcome of their search query, especially in cases of no results, improving confidence and usability.\n\n4.  **Click Outside/Focus Out Handling**: The dropdown should close when a user clicks outside the component or when the input loses focus (e.g., by tabbing away). While `Escape` handles explicit closing, this covers more general user interaction patterns.\n    *   **Importance**: Improves usability and prevents the UI from becoming cluttered with persistently open dropdowns.",
          "analysisPoints": [
            "Comprehensive coverage of advanced accessibility features.",
            "Specific ARIA attributes and their application.",
            "Detailed explanation of focus management strategies.",
            "Discussion of live regions for dynamic content.",
            "Justification for each feature's importance.",
            "Demonstration of a deeper understanding of frontend accessibility beyond basic keyboard events."
          ],
          "keyConcepts": [
            "Accessibility (A11y)",
            "ARIA Attributes",
            "Keyboard Navigation",
            "Focus Management",
            "Screen Readers",
            "Usability"
          ],
          "evaluationCriteria": [
            "Depth of knowledge on accessibility standards.",
            "Ability to propose practical, specific solutions.",
            "Understanding of the 'why' behind each recommendation.",
            "Structure and clarity of the answer."
          ],
          "example": "```jsx\n// Example of aria-activedescendant\n<input\n  ref={searchInputRef}\n  type=\"text\"\n  placeholder=\"Search users...\"\n  value={searchTerm}\n  onChange={handleInputChange}\n  onKeyDown={handleKeyDown}\n  onFocus={() => setIsDropdownOpen(searchResults.length > 0)}\n  aria-autocomplete=\"list\"\n  aria-controls=\"search-results-list\"\n  aria-expanded={isDropdownOpen}\n  aria-activedescendant={isDropdownOpen && selectedIndex !== -1 ? `user-item-${searchResults[selectedIndex]?.id}` : undefined}\n/>\n\n// Example of aria-live region (for no results)\n{searchResults.length === 0 && searchTerm && !isDropdownOpen && (\n  <div aria-live=\"polite\" className=\"no-results\">\n    No users found for \"{searchTerm}\"\n  </div>\n)}\n```",
          "tags": [
            "Accessibility",
            "A11y",
            "ARIA",
            "Keyboard Navigation",
            "UI/UX",
            "Best Practices"
          ],
          "prerequisites": [
            "Web_Accessibility_basics",
            "Semantic_HTML"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "expert"
        },
        {
          "id": "question_arrow_keys_flashcard",
          "topic": "Keyboard Navigation",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of `e.key === 'ArrowDown'` in the `handleKeyDown` function?",
          "answer": "To detect when the user presses the 'Arrow Down' key, enabling custom navigation logic for the search results dropdown.",
          "analysisPoints": [
            "Focus on identifying the specific key.",
            "Relate it to the custom navigation logic."
          ],
          "keyConcepts": [
            "Keyboard Events",
            "e.key",
            "Conditional Logic"
          ],
          "evaluationCriteria": [
            "Basic understanding of keyboard event properties.",
            "Ability to infer purpose from code snippet."
          ],
          "example": "```javascript\nconst handleKeyPress = (e) => {\n  if (e.key === 'ArrowUp') {\n    console.log('User wants to go up!');\n  }\n};\n```",
          "tags": [
            "Keyboard Events",
            "JavaScript",
            "Event Handling"
          ],
          "prerequisites": [
            "JavaScript_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_filter_mcq",
          "topic": "JavaScript Array Methods",
          "level": "easy",
          "type": "mcq",
          "question": "Consider the `searchUsers` function, which uses `Array.prototype.filter()`. Which of the following best describes what `filter()` does?",
          "answer": "Creates a new array containing only the elements for which the provided callback function returns `true`.",
          "options": [
            "Modifies the original array by removing elements that don't satisfy a condition.",
            "Returns the first element that satisfies a condition.",
            "Executes a provided function once for each array element, producing a new array of results.",
            "Creates a new array containing only the elements for which the provided callback function returns `true`."
          ],
          "analysisPoints": [
            "Distinguish `filter` from `map` (produces new array of transformed elements) and `forEach` (no return value, side effects).",
            "Emphasize that `filter` *does not* modify the original array.",
            "Highlight that the callback function must return a boolean."
          ],
          "keyConcepts": [
            "JavaScript Arrays",
            "Array.prototype.filter",
            "Functional Programming",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Correct definition of `filter`.",
            "Understanding of array immutability.",
            "Ability to differentiate from similar array methods."
          ],
          "example": "```javascript\nconst numbers = [1, 2, 3, 4, 5];\nconst evenNumbers = numbers.filter(num => num % 2 === 0);\n// evenNumbers will be [2, 4]\n// numbers remains [1, 2, 3, 4, 5]\n```",
          "tags": [
            "JavaScript",
            "Arrays",
            "Methods",
            "Filtering"
          ],
          "prerequisites": [
            "JavaScript_arrays"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_string_includes_flashcard",
          "topic": "JavaScript String Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of `item.toLowerCase().includes(lowerCaseQuery)` within the `searchUsers` function?",
          "answer": "To check if a specific `item` (or any string) contains the `lowerCaseQuery` string, performing a case-insensitive search.",
          "analysisPoints": [
            "Focus on `includes` for substring checking.",
            "Highlight `toLowerCase` for case insensitivity.",
            "Connect it to search functionality."
          ],
          "keyConcepts": [
            "JavaScript Strings",
            "String.prototype.includes",
            "String.prototype.toLowerCase",
            "Case-insensitive Search"
          ],
          "evaluationCriteria": [
            "Basic understanding of string methods.",
            "Ability to explain combined method usage."
          ],
          "example": "```javascript\nconst text = \"Hello World\";\nconsole.log(text.includes(\"World\")); // true\nconsole.log(text.toLowerCase().includes(\"hello\")); // true\nconsole.log(text.includes(\"world\")); // false (case-sensitive)\n```",
          "tags": [
            "JavaScript",
            "Strings",
            "Methods",
            "Search"
          ],
          "prerequisites": [
            "JavaScript_strings"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_map_key_importance_open",
          "topic": "React List Rendering",
          "level": "medium",
          "type": "open",
          "question": "In the `searchResults.map` rendering, each `user-item` `div` has a `key={user.id}` prop. Explain the importance of the `key` prop in React lists, especially in a dynamic list like search results where items can be added, removed, or reordered.",
          "answer": "The `key` prop is a special string attribute you need to include when creating lists of elements in React. Its importance in dynamic lists like search results is critical for several reasons:\n\n1.  **Efficient Reconciliation**: React uses the `key` prop to identify which items in a list have changed, are added, or are removed. When the list of `searchResults` changes (e.g., new results appear, old ones disappear, or their order changes), React uses the keys to efficiently reconcile the new list with the old list. Without keys, or with unstable keys (like array indices when items can be reordered), React might re-render or re-mount components unnecessarily or incorrectly.\n\n2.  **Maintaining Component State**: If list items have internal state (e.g., an input field within each `user-item` holding its own value), React uses the `key` to correctly associate that state with the correct item. If keys are missing or unstable, React might accidentally reuse component instances for different data, leading to state bugs where the wrong data is shown or manipulated.\n\n3.  **Performance Optimization**: By identifying precisely which items have changed, React can perform minimal DOM manipulations, leading to better performance, especially for large lists.\n\n4.  **Preventing Bugs**: Using a stable, unique key (like `user.id` which is a unique identifier for each user) prevents many subtle bugs that can arise from React's reconciliation algorithm making incorrect assumptions about item identities.\n\n**Why not use `index` as a key?**\nUsing `index` as a `key` is problematic if the list items can be reordered, filtered, or added/removed from the middle. If an item is inserted at the beginning, all subsequent items shift their indices, causing React to think that every component has changed, leading to inefficient updates and potential state issues. `user.id` is stable regardless of the item's position or the list's changes, making it ideal.",
          "analysisPoints": [
            "Explanation of React's reconciliation process.",
            "Role of keys in identifying items for efficient updates.",
            "Impact on component state preservation.",
            "Performance implications.",
            "Clear explanation of why `index` is generally a bad key.",
            "Demonstration of `user.id` as a good key."
          ],
          "keyConcepts": [
            "React Reconciliation",
            "Key Prop",
            "List Rendering",
            "Performance Optimization",
            "Component State",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of `key` prop.",
            "Ability to explain its benefits and pitfalls.",
            "Clear distinction between good and bad key choices.",
            "Demonstrates knowledge of React internals."
          ],
          "example": "```javascript\n// BAD example (if items can change order/be removed)\nlistItems.map((item, index) => (\n  <div key={index}>{item.name}</div>\n));\n\n// GOOD example (stable and unique ID)\nlistItems.map((item) => (\n  <div key={item.id}>{item.name}</div>\n));\n```",
          "tags": [
            "React",
            "List Rendering",
            "Key Prop",
            "Performance",
            "Best Practices"
          ],
          "prerequisites": [
            "React_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_some_use_case_mcq",
          "topic": "JavaScript Array Methods",
          "level": "medium",
          "type": "mcq",
          "question": "The `searchUsers` function checks `if (user.purchased.some(item => item.toLowerCase().includes(lowerCaseQuery)))`. Why is `some()` a suitable method here, compared to, for example, `filter()` or `map()`?",
          "answer": "`some()` is suitable because it efficiently checks if *any* purchased item matches the query, returning `true` as soon as one match is found without needing to process the entire array or create a new one.",
          "options": [
            "`filter()` would modify the original `purchased` array, which is undesirable.",
            "`map()` would return a new array of booleans, and we only need a single boolean result.",
            "`some()` efficiently checks if *any* purchased item matches the query, returning `true` as soon as one match is found without needing to process the entire array or create a new one.",
            "`some()` allows for synchronous iteration, which is faster than other methods."
          ],
          "analysisPoints": [
            "Focus on `some()`'s short-circuiting behavior (returns `true` immediately upon first match).",
            "Distinguish its purpose (checking existence/condition) from `filter()` (creating a subset) and `map()` (transforming elements).",
            "Emphasize that `some()` returns a single boolean, which is exactly what the `if` condition needs."
          ],
          "keyConcepts": [
            "JavaScript Arrays",
            "Array.prototype.some",
            "Array.prototype.filter",
            "Array.prototype.map",
            "Efficiency",
            "Boolean Logic"
          ],
          "evaluationCriteria": [
            "Correct understanding of `Array.prototype.some()`.",
            "Ability to compare and contrast array methods.",
            "Recognition of optimal method for a given use case.",
            "Understanding of efficiency implications."
          ],
          "example": "```javascript\nconst fruits = ['apple', 'banana', 'cherry'];\n\n// Using some(): Checks if ANY fruit starts with 'a'\nconst hasApple = fruits.some(fruit => fruit.startsWith('a')); // true, stops after 'apple'\n\n// Using filter(): Creates a new array of fruits starting with 'a'\nconst fruitsStartingWithA = fruits.filter(fruit => fruit.startsWith('a')); // ['apple']\n\n// Using map(): Creates a new array of booleans for each fruit\nconst startsWithABooleans = fruits.map(fruit => fruit.startsWith('a')); // [true, false, false]\n\n// If the goal is just to know IF a condition exists, some() is most efficient.\n```",
          "tags": [
            "JavaScript",
            "Arrays",
            "Methods",
            "Optimization"
          ],
          "prerequisites": [
            "JavaScript_arrays",
            "Boolean_logic"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_refactor_usestate_toreducer",
          "title": "Refactor Search Component State with `useReducer`",
          "description": "\nRefactor the state management of the search component from using multiple `useState` hooks to a single `useReducer` hook. This should consolidate `searchTerm`, `searchResults`, `selectedIndex`, and `isDropdownOpen` into a single state object.\n\n**Requirements:**\n1.  Define a reducer function (`searchReducer`) that handles different actions (e.g., `SET_SEARCH_TERM`, `SET_SEARCH_RESULTS`, `KEY_DOWN`, `SELECT_USER`).\n2.  Initialize the reducer with an initial state object containing all necessary properties.\n3.  Replace all `setSearchTerm`, `setSearchResults`, `setSelectedIndex`, and `setIsDropdownOpen` calls with `dispatch` calls.\n4.  Ensure all existing functionality (search filtering, keyboard navigation, selection, dropdown visibility) works correctly after the refactor.\n5.  The `searchUsers` function does not need to be part of the reducer, but its integration with the `dispatch` logic should be correct.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect, useRef, useReducer } from 'react';\n\n// Assume MOCK_USERS is defined elsewhere or passed as a prop\nconst MOCK_USERS = [\n  { id: 1, name: 'Alice Smith', purchased: ['Laptop', 'Mouse'], address: '123 Main St', zipCode: '10001' },\n  { id: 2, name: 'Bob Johnson', purchased: ['Keyboard'], address: '456 Oak Ave', zipCode: '20002' },\n  { id: 3, name: 'Charlie Brown', purchased: ['Monitor', 'Webcam'], address: '789 Pine Ln', zipCode: '30003' },\n  { id: 4, name: 'Diana Prince', purchased: ['Headphones'], address: '101 Elm Blvd', zipCode: '10001' }\n];\n\n// Initial state for useReducer (you will define the reducer)\nconst initialState = {\n  searchTerm: '',\n  searchResults: [],\n  selectedIndex: 0,\n  isDropdownOpen: false,\n};\n\n// TODO: Define searchReducer function here\nfunction searchReducer(state, action) {\n  switch (action.type) {\n    // Implement action handlers\n    default:\n      return state;\n  }\n}\n\nfunction UserSearchComponent() {\n  // const [searchTerm, setSearchTerm] = useState('');\n  // const [searchResults, setSearchResults] = useState([]);\n  // const [selectedIndex, setSelectedIndex] = useState(0);\n  // const [isDropdownOpen, setIsDropdownOpen] = useState(false);\n\n  const [state, dispatch] = useReducer(searchReducer, initialState);\n  const { searchTerm, searchResults, selectedIndex, isDropdownOpen } = state;\n\n  const searchInputRef = useRef(null);\n  const resultsContainerRef = useRef(null);\n\n  // Search logic (remains outside reducer, but uses its state and dispatches actions)\n  const searchUsers = (query) => {\n    if (!query) return [];\n    const lowerCaseQuery = query.toLowerCase();\n    return MOCK_USERS.filter(user => {\n      if (user.name.toLowerCase().includes(lowerCaseQuery)) return true;\n      if (user.purchased.some(item => item.toLowerCase().includes(lowerCaseQuery))) return true;\n      if (user.address.toLowerCase().includes(lowerCaseQuery)) return true;\n      if (user.zipCode.includes(lowerCaseQuery)) return true;\n      return false;\n    });\n  };\n  \n  // Handle input change\n  const handleInputChange = (e) => {\n    const value = e.target.value;\n    // TODO: Dispatch action to set search term\n    // TODO: Dispatch action to set search results\n    // TODO: Dispatch action to reset selected index\n    // TODO: Dispatch action to manage dropdown visibility\n\n    // const results = searchUsers(value);\n    // setSearchTerm(value);\n    // setSearchResults(results);\n    // setSelectedIndex(0);\n    // setIsDropdownOpen(results.length > 0);\n  };\n  \n  // Handle keyboard navigation\n  const handleKeyDown = (e) => {\n    // TODO: Dispatch actions based on key presses\n    if (!isDropdownOpen) return;\n    \n    switch (e.key) {\n      case 'ArrowDown':\n        e.preventDefault();\n        // setSelectedIndex(prev => (prev < searchResults.length - 1) ? prev + 1 : prev);\n        break;\n      case 'ArrowUp':\n        e.preventDefault();\n        // setSelectedIndex(prev => (prev > 0) ? prev - 1 : 0);\n        break;\n      case 'Enter':\n        e.preventDefault();\n        // if (searchResults[selectedIndex]) {\n        //   handleSelectUser(searchResults[selectedIndex]);\n        // }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        // setIsDropdownOpen(false);\n        break;\n      default:\n        break;\n    }\n  };\n  \n  // Scroll selected item into view\n  useEffect(() => {\n    if (isDropdownOpen && resultsContainerRef.current) {\n      const selectedElement = document.getElementById(`user-item-${selectedIndex}`);\n      if (selectedElement) {\n        selectedElement.scrollIntoView({ block: 'nearest', behavior: 'smooth' });\n      }\n    }\n  }, [selectedIndex, isDropdownOpen]);\n  \n  // Handle user selection\n  const handleSelectUser = (user) => {\n    console.log('Selected user:', user);\n    // TODO: Dispatch actions to clear search term and close dropdown\n    // setSearchTerm('');\n    // setIsDropdownOpen(false);\n  };\n  \n  return (\n    <div className=\"user-search\">\n      <div className=\"search-container\">\n        <input\n          ref={searchInputRef}\n          type=\"text\"\n          placeholder=\"Search users by name, items, address...\"\n          value={searchTerm}\n          onChange={handleInputChange}\n          onKeyDown={handleKeyDown}\n          onFocus={() => { /* TODO: Dispatch action to open dropdown if results exist */ /* setIsDropdownOpen(searchResults.length > 0) */ }}\n        />\n        \n        {isDropdownOpen && (\n          <div className=\"search-results\" ref={resultsContainerRef}>\n            {searchResults.length > 0 ? (\n              searchResults.map((user, index) => (\n                <div\n                  id={`user-item-${index}`}\n                  key={user.id}\n                  className={`user-item ${index === selectedIndex ? 'selected' : ''}`}\n                  onClick={() => handleSelectUser(user)}\n                  onMouseEnter={() => { /* TODO: Dispatch action to set selected index */ /* setSelectedIndex(index) */ }}\n                >\n                  <div className=\"user-name\">{user.name}</div>\n                </div>\n              ))\n            ) : (\n              <div className=\"no-results\">No results found.</div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default UserSearchComponent;\n",
          "solutionCode": "import React, { useEffect, useRef, useReducer } from 'react';\n\nconst MOCK_USERS = [\n  { id: 1, name: 'Alice Smith', purchased: ['Laptop', 'Mouse'], address: '123 Main St', zipCode: '10001' },\n  { id: 2, name: 'Bob Johnson', purchased: ['Keyboard'], address: '456 Oak Ave', zipCode: '20002' },\n  { id: 3, name: 'Charlie Brown', purchased: ['Monitor', 'Webcam'], address: '789 Pine Ln', zipCode: '30003' },\n  { id: 4, name: 'Diana Prince', purchased: ['Headphones'], address: '101 Elm Blvd', zipCode: '10001' },\n  { id: 5, name: 'Eve Adams', purchased: ['Desk'], address: '202 River Rd', zipCode: '40004' },\n  { id: 6, name: 'Frank White', purchased: ['Chair'], address: '303 Hill Dr', zipCode: '50005' }\n];\n\nconst initialState = {\n  searchTerm: '',\n  searchResults: [],\n  selectedIndex: -1, // Changed to -1 to indicate no selection initially\n  isDropdownOpen: false,\n};\n\nfunction searchReducer(state, action) {\n  switch (action.type) {\n    case 'SET_SEARCH_TERM':\n      return { ...state, searchTerm: action.payload };\n    case 'SET_SEARCH_RESULTS':\n      return { ...state, searchResults: action.payload };\n    case 'SET_SELECTED_INDEX':\n      return { ...state, selectedIndex: action.payload };\n    case 'SET_DROPDOWN_OPEN':\n      return { ...state, isDropdownOpen: action.payload };\n    case 'NAVIGATE_DOWN':\n      return {\n        ...state,\n        selectedIndex: (state.selectedIndex < state.searchResults.length - 1)\n          ? state.selectedIndex + 1\n          : state.selectedIndex,\n      };\n    case 'NAVIGATE_UP':\n      return {\n        ...state,\n        selectedIndex: (state.selectedIndex > 0) ? state.selectedIndex - 1 : 0,\n      };\n    case 'SELECT_ITEM':\n      // Log selected user and reset state\n      console.log('Selected user:', action.payload);\n      return { ...initialState }; // Reset to initial state after selection\n    case 'CLEAR_SEARCH':\n      return { ...initialState };\n    default:\n      return state;\n  }\n}\n\nfunction UserSearchComponent() {\n  const [state, dispatch] = useReducer(searchReducer, initialState);\n  const { searchTerm, searchResults, selectedIndex, isDropdownOpen } = state;\n\n  const searchInputRef = useRef(null);\n  const resultsContainerRef = useRef(null);\n\n  const searchUsers = (query) => {\n    if (!query) return [];\n    const lowerCaseQuery = query.toLowerCase();\n    return MOCK_USERS.filter(user => {\n      if (user.name.toLowerCase().includes(lowerCaseQuery)) return true;\n      if (user.purchased.some(item => item.toLowerCase().includes(lowerCaseQuery))) return true;\n      if (user.address.toLowerCase().includes(lowerCaseQuery)) return true;\n      if (user.zipCode.includes(lowerCaseQuery)) return true;\n      return false;\n    });\n  };\n  \n  const handleInputChange = (e) => {\n    const value = e.target.value;\n    dispatch({ type: 'SET_SEARCH_TERM', payload: value });\n    const results = searchUsers(value);\n    dispatch({ type: 'SET_SEARCH_RESULTS', payload: results });\n    dispatch({ type: 'SET_SELECTED_INDEX', payload: results.length > 0 ? 0 : -1 });\n    dispatch({ type: 'SET_DROPDOWN_OPEN', payload: results.length > 0 });\n  };\n  \n  const handleKeyDown = (e) => {\n    if (!isDropdownOpen) return;\n    \n    switch (e.key) {\n      case 'ArrowDown':\n        e.preventDefault();\n        dispatch({ type: 'NAVIGATE_DOWN' });\n        break;\n      case 'ArrowUp':\n        e.preventDefault();\n        dispatch({ type: 'NAVIGATE_UP' });\n        break;\n      case 'Enter':\n        e.preventDefault();\n        if (selectedIndex !== -1 && searchResults[selectedIndex]) {\n          dispatch({ type: 'SELECT_ITEM', payload: searchResults[selectedIndex] });\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        dispatch({ type: 'SET_DROPDOWN_OPEN', payload: false });\n        break;\n      default:\n        break;\n    }\n  };\n  \n  useEffect(() => {\n    if (isDropdownOpen && resultsContainerRef.current && selectedIndex !== -1) {\n      const selectedElement = document.getElementById(`user-item-${selectedIndex}`);\n      if (selectedElement) {\n        selectedElement.scrollIntoView({ block: 'nearest', behavior: 'smooth' });\n      }\n    }\n  }, [selectedIndex, isDropdownOpen]);\n  \n  const handleSelectUser = (user) => {\n    dispatch({ type: 'SELECT_ITEM', payload: user });\n  };\n  \n  return (\n    <div className=\"user-search\">\n      <div className=\"search-container\">\n        <input\n          ref={searchInputRef}\n          type=\"text\"\n          placeholder=\"Search users by name, items, address...\"\n          value={searchTerm}\n          onChange={handleInputChange}\n          onKeyDown={handleKeyDown}\n          onFocus={() => dispatch({ type: 'SET_DROPDOWN_OPEN', payload: searchResults.length > 0 })}\n        />\n        \n        {isDropdownOpen && (\n          <div className=\"search-results\" ref={resultsContainerRef}>\n            {searchResults.length > 0 ? (\n              searchResults.map((user, index) => (\n                <div\n                  id={`user-item-${index}`}\n                  key={user.id}\n                  className={`user-item ${index === selectedIndex ? 'selected' : ''}`}\n                  onClick={() => handleSelectUser(user)}\n                  onMouseEnter={() => dispatch({ type: 'SET_SELECTED_INDEX', payload: index })}\n                >\n                  <div className=\"user-name\">{user.name}</div>\n                </div>\n              ))\n            ) : (\n              <div className=\"no-results\">No results found.</div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default UserSearchComponent;\n",
          "testCases": [
            "**Initial Load**: Component renders with empty search term, no results, dropdown closed.",
            "**Typing 'a'**: `searchTerm` updates to 'a', `searchResults` shows Alice, Diana, Charlie, `selectedIndex` is 0, `isDropdownOpen` is true.",
            "**Typing 'apple'**: `searchTerm` updates, `searchResults` shows Alice, `selectedIndex` is 0, `isDropdownOpen` is true.",
            "**Typing 'xyz' (no match)**: `searchTerm` updates, `searchResults` is empty, `isDropdownOpen` is false.",
            "**ArrowDown**: Pressing ArrowDown navigates `selectedIndex` from 0 to 1, then to 2, etc. (with results for 'a').",
            "**ArrowUp**: Pressing ArrowUp navigates `selectedIndex` from 2 to 1, then to 0 (with results for 'a').",
            "**Enter Selection**: With 'Alice Smith' selected (index 0), pressing Enter clears search, closes dropdown, logs 'Selected user: Alice Smith'.",
            "**Escape**: Pressing Escape closes dropdown and clears selected index (but not search term).",
            "**Focus In/Out**: `onFocus` opens dropdown if results exist. Clicking outside (implied, not direct testable by code alone) should close it."
          ],
          "hints": [
            "Start by defining your `initialState` and a basic `searchReducer` function with a `default` case.",
            "Identify all places where `useState` setters (`setSearchTerm`, etc.) are called and replace them with `dispatch({ type: 'ACTION_NAME', payload: value })`.",
            "For actions like `NAVIGATE_DOWN` or `NAVIGATE_UP`, the reducer logic should calculate the new `selectedIndex` based on the current `state.selectedIndex` and `state.searchResults.length`.",
            "The `SELECT_ITEM` action is a good candidate for resetting the state back to its initial empty/closed condition."
          ],
          "tags": [
            "React",
            "useReducer",
            "State Management",
            "Refactoring",
            "Hooks",
            "Intermediate"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_react_state_and_hooks",
            "JavaScript_reducer_pattern"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Redux_pattern",
            "Flux_architecture",
            "Centralized_state"
          ]
        },
        {
          "id": "task_implement_debounced_search",
          "title": "Implement Debounced Search Input",
          "description": "\nEnhance the `handleInputChange` function to debounce the search operation. This means the `searchUsers` function should only be called after the user has stopped typing for a certain period (e.g., 300ms). This is a common performance optimization for search inputs.\n\n**Requirements:**\n1.  Introduce a debouncing mechanism to delay the execution of `searchUsers`.\n2.  The `setSearchTerm` (or `dispatch` equivalent) should update immediately, but `setSearchResults` (or `dispatch` equivalent) should be delayed.\n3.  Ensure that if the user types quickly, `searchUsers` is only called once after a pause.\n4.  Upon component unmount or when the effect cleans up, any pending debounce timer should be cleared.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect, useRef } from 'react';\n\nconst MOCK_USERS = [\n  { id: 1, name: 'Alice Smith', purchased: ['Laptop', 'Mouse'], address: '123 Main St', zipCode: '10001' },\n  { id: 2, name: 'Bob Johnson', purchased: ['Keyboard'], address: '456 Oak Ave', zipCode: '20002' },\n  { id: 3, name: 'Charlie Brown', purchased: ['Monitor', 'Webcam'], address: '789 Pine Ln', zipCode: '30003' },\n  { id: 4, name: 'Diana Prince', purchased: ['Headphones'], address: '101 Elm Blvd', zipCode: '10001' }\n];\n\nfunction UserSearchComponent() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [searchResults, setSearchResults] = useState([]);\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  const [isDropdownOpen, setIsDropdownOpen] = useState(false);\n\n  const searchInputRef = useRef(null);\n  const resultsContainerRef = useRef(null);\n\n  const searchUsers = (query) => {\n    if (!query) return [];\n    console.log('Performing search for:', query); // Add this to observe debounce effect\n    const lowerCaseQuery = query.toLowerCase();\n    return MOCK_USERS.filter(user => {\n      if (user.name.toLowerCase().includes(lowerCaseQuery)) return true;\n      if (user.purchased.some(item => item.toLowerCase().includes(lowerCaseQuery))) return true;\n      if (user.address.toLowerCase().includes(lowerCaseQuery)) return true;\n      if (user.zipCode.includes(lowerCaseQuery)) return true;\n      return false;\n    });\n  };\n  \n  const handleInputChange = (e) => {\n    const value = e.target.value;\n    setSearchTerm(value);\n    \n    // TODO: Implement debouncing here. \n    // The following lines should be moved inside the debounced function.\n    // const results = searchUsers(value);\n    // setSearchResults(results);\n    // setSelectedIndex(0);\n    // setIsDropdownOpen(results.length > 0);\n  };\n  \n  const handleKeyDown = (e) => {\n    if (!isDropdownOpen) return;\n    \n    switch (e.key) {\n      case 'ArrowDown':\n        e.preventDefault();\n        setSelectedIndex(prev => (prev < searchResults.length - 1) ? prev + 1 : prev);\n        break;\n      case 'ArrowUp':\n        e.preventDefault();\n        setSelectedIndex(prev => (prev > 0) ? prev - 1 : 0);\n        break;\n      case 'Enter':\n        e.preventDefault();\n        if (searchResults[selectedIndex]) {\n          handleSelectUser(searchResults[selectedIndex]);\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        setIsDropdownOpen(false);\n        break;\n      default:\n        break;\n    }\n  };\n  \n  useEffect(() => {\n    if (isDropdownOpen && resultsContainerRef.current) {\n      const selectedElement = document.getElementById(`user-item-${selectedIndex}`);\n      if (selectedElement) {\n        selectedElement.scrollIntoView({ block: 'nearest', behavior: 'smooth' });\n      }\n    }\n  }, [selectedIndex, isDropdownOpen]);\n  \n  const handleSelectUser = (user) => {\n    console.log('Selected user:', user);\n    setSearchTerm('');\n    setIsDropdownOpen(false);\n  };\n  \n  return (\n    <div className=\"user-search\">\n      <div className=\"search-container\">\n        <input\n          ref={searchInputRef}\n          type=\"text\"\n          placeholder=\"Search users by name, items, address...\"\n          value={searchTerm}\n          onChange={handleInputChange}\n          onKeyDown={handleKeyDown}\n          onFocus={() => setIsDropdownOpen(searchResults.length > 0)}\n        />\n        \n        {isDropdownOpen && (\n          <div className=\"search-results\" ref={resultsContainerRef}>\n            {searchResults.length > 0 ? (\n              searchResults.map((user, index) => (\n                <div\n                  id={`user-item-${index}`}\n                  key={user.id}\n                  className={`user-item ${index === selectedIndex ? 'selected' : ''}`}\n                  onClick={() => handleSelectUser(user)}\n                  onMouseEnter={() => setSelectedIndex(index)}\n                >\n                  <div className=\"user-name\">{user.name}</div>\n                </div>\n              ))\n            ) : (\n              <div className=\"no-results\">No results found.</div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default UserSearchComponent;\n",
          "solutionCode": "import React, { useState, useEffect, useRef, useCallback } from 'react';\n\nconst MOCK_USERS = [\n  { id: 1, name: 'Alice Smith', purchased: ['Laptop', 'Mouse'], address: '123 Main St', zipCode: '10001' },\n  { id: 2, name: 'Bob Johnson', purchased: ['Keyboard'], address: '456 Oak Ave', zipCode: '20002' },\n  { id: 3, name: 'Charlie Brown', purchased: ['Monitor', 'Webcam'], address: '789 Pine Ln', zipCode: '30003' },\n  { id: 4, name: 'Diana Prince', purchased: ['Headphones'], address: '101 Elm Blvd', zipCode: '10001' },\n  { id: 5, name: 'Eve Adams', purchased: ['Desk'], address: '202 River Rd', zipCode: '40004' },\n  { id: 6, name: 'Frank White', purchased: ['Chair'], address: '303 Hill Dr', zipCode: '50005' }\n];\n\nfunction UserSearchComponent() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [searchResults, setSearchResults] = useState([]);\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  const [isDropdownOpen, setIsDropdownOpen] = useState(false);\n\n  const searchInputRef = useRef(null);\n  const resultsContainerRef = useRef(null);\n\n  const searchUsers = (query) => {\n    if (!query) return [];\n    console.log('Performing search for:', query); // Add this to observe debounce effect\n    const lowerCaseQuery = query.toLowerCase();\n    return MOCK_USERS.filter(user => {\n      if (user.name.toLowerCase().includes(lowerCaseQuery)) return true;\n      if (user.purchased.some(item => item.toLowerCase().includes(lowerCaseQuery))) return true;\n      if (user.address.toLowerCase().includes(lowerCaseQuery)) return true;\n      if (user.zipCode.includes(lowerCaseQuery)) return true;\n      return false;\n    });\n  };\n\n  // Custom debounce hook/function could be extracted for reusability\n  const debouncedSearchTerm = useDebounce(searchTerm, 300);\n\n  useEffect(() => {\n    if (debouncedSearchTerm !== undefined) { // To prevent initial empty string search on mount\n      const results = searchUsers(debouncedSearchTerm);\n      setSearchResults(results);\n      setSelectedIndex(0);\n      setIsDropdownOpen(results.length > 0);\n    }\n  }, [debouncedSearchTerm]);\n  \n  const handleInputChange = (e) => {\n    const value = e.target.value;\n    setSearchTerm(value); // Update immediately for UI feedback\n  };\n  \n  const handleKeyDown = (e) => {\n    if (!isDropdownOpen) return;\n    \n    switch (e.key) {\n      case 'ArrowDown':\n        e.preventDefault();\n        setSelectedIndex(prev => \n          (prev < searchResults.length - 1) ? prev + 1 : prev);\n        break;\n      case 'ArrowUp':\n        e.preventDefault();\n        setSelectedIndex(prev => (prev > 0) ? prev - 1 : 0);\n        break;\n      case 'Enter':\n        e.preventDefault();\n        if (searchResults[selectedIndex]) {\n          handleSelectUser(searchResults[selectedIndex]);\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        setIsDropdownOpen(false);\n        break;\n      default:\n        break;\n    }\n  };\n  \n  useEffect(() => {\n    if (isDropdownOpen && resultsContainerRef.current) {\n      const selectedElement = document.getElementById(`user-item-${selectedIndex}`);\n      if (selectedElement) {\n        selectedElement.scrollIntoView({ block: 'nearest', behavior: 'smooth' });\n      }\n    }\n  }, [selectedIndex, isDropdownOpen]);\n  \n  const handleSelectUser = (user) => {\n    console.log('Selected user:', user);\n    setSearchTerm('');\n    setIsDropdownOpen(false);\n  };\n  \n  return (\n    <div className=\"user-search\">\n      <div className=\"search-container\">\n        <input\n          ref={searchInputRef}\n          type=\"text\"\n          placeholder=\"Search users by name, items, address...\"\n          value={searchTerm}\n          onChange={handleInputChange}\n          onKeyDown={handleKeyDown}\n          onFocus={() => setIsDropdownOpen(searchResults.length > 0)}\n        />\n        \n        {isDropdownOpen && (\n          <div className=\"search-results\" ref={resultsContainerRef}>\n            {searchResults.length > 0 ? (\n              searchResults.map((user, index) => (\n                <div\n                  id={`user-item-${index}`}\n                  key={user.id}\n                  className={`user-item ${index === selectedIndex ? 'selected' : ''}`}\n                  onClick={() => handleSelectUser(user)}\n                  onMouseEnter={() => setSelectedIndex(index)}\n                >\n                  <div className=\"user-name\">{user.name}</div>\n                </div>\n              ))\n            ) : (\n              <div className=\"no-results\">No results found.</div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\n// Custom Hook for Debouncing\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\nexport default UserSearchComponent;\n",
          "testCases": [
            "**Immediate Feedback**: Typing 'a' updates the input field instantly.",
            "**Debounce Delay**: Type 'ap' quickly. `searchUsers` should NOT be called after 'a' or 'p'. It should only be called after a 300ms pause after typing 'p'.",
            "**Continuous Typing**: Type 'apple' without pausing for 300ms between characters. `searchUsers` should only be called once, after you stop typing 'apple'.",
            "**Clearing Input**: Clear the input quickly. `searchUsers` should be called with an empty string after debounce delay.",
            "**Cleanup**: Verify no memory leaks by ensuring `setTimeout` is cleared on unmount or re-render of the effect."
          ],
          "hints": [
            "Consider creating a custom `useDebounce` hook that takes a `value` and a `delay`.",
            "Inside the `useDebounce` hook, use `useEffect` with `setTimeout` to delay setting the debounced value.",
            "Remember to return a cleanup function from `useEffect` to `clearTimeout` when the component unmounts or the `value`/`delay` changes.",
            "The `searchUsers` function should then be triggered by the `debouncedSearchTerm` within a separate `useEffect` in the main component."
          ],
          "tags": [
            "React",
            "Hooks",
            "Performance",
            "Debouncing",
            "Optimization",
            "useEffect"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_react_state_and_hooks",
            "JavaScript_closures",
            "JavaScript_timers"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Throttling",
            "Custom_hooks",
            "Performance_optimization"
          ]
        },
        {
          "id": "task_enhance_search_function",
          "title": "Enhance Search Functionality with Fuzzy Matching and Multiple Keywords",
          "description": "\nEnhance the `searchUsers` function to provide more flexible search capabilities. The current function only supports exact substring matching on individual fields. Your task is to:\n\n1.  **Support Multiple Keywords**: Allow the user to search for multiple keywords (e.g., 'alice laptop'). A user should match if *all* keywords are found in *any* of the searchable fields (name, purchased items, address, zip code).\n2.  **Basic Fuzzy Matching (Optional, for Harder Challenge)**: Implement a very basic form of fuzzy matching for name and address fields (e.g., 'alce' matches 'alice'). This could be done by allowing one character difference or using a simple Levenshtein distance check (if time permits, otherwise just focus on multiple keywords).\n\n**Requirements:**\n*   Modify `searchUsers` to split the `query` into individual keywords.\n*   Each user must match *all* keywords for them to be included in the results.\n*   The matching should still be case-insensitive.\n*   If implementing fuzzy matching, clearly state your approach (e.g., 'allows 1 typo').\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useEffect, useRef } from 'react';\n\nconst MOCK_USERS = [\n  { id: 1, name: 'Alice Smith', purchased: ['Laptop', 'Mouse'], address: '123 Main St', zipCode: '10001' },\n  { id: 2, name: 'Bob Johnson', purchased: ['Keyboard'], address: '456 Oak Ave', zipCode: '20002' },\n  { id: 3, name: 'Charlie Brown', purchased: ['Monitor', 'Webcam'], address: '789 Pine Ln', zipCode: '30003' },\n  { id: 4, name: 'Diana Prince', purchased: ['Headphones'], address: '101 Elm Blvd', zipCode: '10001' },\n  { id: 5, name: 'Eve Adams', purchased: ['Desk'], address: '202 River Rd', zipCode: '40004' },\n  { id: 6, name: 'Frank White', purchased: ['Chair'], address: '303 Hill Dr', zipCode: '50005' },\n  { id: 7, name: 'Grace Taylor', purchased: ['Tablet'], address: '404 Creek Rd', zipCode: '60006' }\n];\n\nfunction UserSearchComponent() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [searchResults, setSearchResults] = useState([]);\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  const [isDropdownOpen, setIsDropdownOpen] = useState(false);\n\n  const searchInputRef = useRef(null);\n  const resultsContainerRef = useRef(null);\n\n  // TODO: Modify this searchUsers function\n  const searchUsers = (query) => {\n    if (!query) return [];\n    const lowerCaseQuery = query.toLowerCase();\n    return MOCK_USERS.filter(user => {\n      if (user.name.toLowerCase().includes(lowerCaseQuery)) return true;\n      if (user.purchased.some(item => item.toLowerCase().includes(lowerCaseQuery))) return true;\n      if (user.address.toLowerCase().includes(lowerCaseQuery)) return true;\n      if (user.zipCode.includes(lowerCaseQuery)) return true;\n      return false;\n    });\n  };\n  \n  const handleInputChange = (e) => {\n    const value = e.target.value;\n    setSearchTerm(value);\n    \n    const results = searchUsers(value);\n    setSearchResults(results);\n    setSelectedIndex(0);\n    setIsDropdownOpen(results.length > 0);\n  };\n  \n  const handleKeyDown = (e) => {\n    if (!isDropdownOpen) return;\n    \n    switch (e.key) {\n      case 'ArrowDown':\n        e.preventDefault();\n        setSelectedIndex(prev => \n          (prev < searchResults.length - 1) ? prev + 1 : prev);\n        break;\n      case 'ArrowUp':\n        e.preventDefault();\n        setSelectedIndex(prev => (prev > 0) ? prev - 1 : 0);\n        break;\n      case 'Enter':\n        e.preventDefault();\n        if (searchResults[selectedIndex]) {\n          handleSelectUser(searchResults[selectedIndex]);\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        setIsDropdownOpen(false);\n        break;\n      default:\n        break;\n    }\n  };\n  \n  useEffect(() => {\n    if (isDropdownOpen && resultsContainerRef.current) {\n      const selectedElement = document.getElementById(`user-item-${selectedIndex}`);\n      if (selectedElement) {\n        selectedElement.scrollIntoView({ block: 'nearest', behavior: 'smooth' });\n      }\n    }\n  }, [selectedIndex, isDropdownOpen]);\n  \n  const handleSelectUser = (user) => {\n    console.log('Selected user:', user);\n    setSearchTerm('');\n    setIsDropdownOpen(false);\n  };\n  \n  return (\n    <div className=\"user-search\">\n      <div className=\"search-container\">\n        <input\n          ref={searchInputRef}\n          type=\"text\"\n          placeholder=\"Search users by name, items, address...\"\n          value={searchTerm}\n          onChange={handleInputChange}\n          onKeyDown={handleKeyDown}\n          onFocus={() => setIsDropdownOpen(searchResults.length > 0)}\n        />\n        \n        {isDropdownOpen && (\n          <div className=\"search-results\" ref={resultsContainerRef}>\n            {searchResults.length > 0 ? (\n              searchResults.map((user, index) => (\n                <div\n                  id={`user-item-${index}`}\n                  key={user.id}\n                  className={`user-item ${index === selectedIndex ? 'selected' : ''}`}\n                  onClick={() => handleSelectUser(user)}\n                  onMouseEnter={() => setSelectedIndex(index)}\n                >\n                  <div className=\"user-name\">{user.name}</div>\n                </div>\n              ))\n            ) : (\n              <div className=\"no-results\">No results found.</div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default UserSearchComponent;\n",
          "solutionCode": "import React, { useState, useEffect, useRef } from 'react';\n\nconst MOCK_USERS = [\n  { id: 1, name: 'Alice Smith', purchased: ['Laptop', 'Mouse'], address: '123 Main St', zipCode: '10001' },\n  { id: 2, name: 'Bob Johnson', purchased: ['Keyboard'], address: '456 Oak Ave', zipCode: '20002' },\n  { id: 3, name: 'Charlie Brown', purchased: ['Monitor', 'Webcam'], address: '789 Pine Ln', zipCode: '30003' },\n  { id: 4, name: 'Diana Prince', purchased: ['Headphones'], address: '101 Elm Blvd', zipCode: '10001' },\n  { id: 5, name: 'Eve Adams', purchased: ['Desk'], address: '202 River Rd', zipCode: '40004' },\n  { id: 6, name: 'Frank White', purchased: ['Chair'], address: '303 Hill Dr', zipCode: '50005' },\n  { id: 7, name: 'Grace Taylor', purchased: ['Tablet'], address: '404 Creek Rd', zipCode: '60006' }\n];\n\n// Helper for basic fuzzy match (1 character difference allowed)\nconst isFuzzyMatch = (text, query) => {\n  if (text.includes(query)) return true;\n  if (query.length < 2) return false; // Needs at least 2 chars for meaningful fuzzy\n\n  // Allows for one character difference (insertion, deletion, substitution)\n  for (let i = 0; i <= text.length; i++) {\n    // Insertion\n    if (text.slice(0, i) + query + text.slice(i) === query) return true; // not needed, just for conceptual clarity\n  }\n\n  // Simple 1-char difference check:\n  // Check if query can be formed by adding/removing/changing one char in text\n  if (Math.abs(text.length - query.length) > 1) return false; // Too many differences\n\n  let diffCount = 0;\n  let tIdx = 0;\n  let qIdx = 0;\n\n  while (tIdx < text.length && qIdx < query.length) {\n    if (text[tIdx] !== query[qIdx]) {\n      diffCount++;\n      if (diffCount > 1) return false;\n\n      // Try skipping a char in text (deletion in query)\n      if (text.length > query.length) {\n        tIdx++;\n      } else if (query.length > text.length) {\n        // Try skipping a char in query (insertion in query)\n        qIdx++;\n      } else {\n        // Substitution\n        tIdx++;\n        qIdx++;\n      }\n    } else {\n      tIdx++;\n      qIdx++;\n    }\n  }\n  diffCount += Math.abs((text.length - tIdx) - (query.length - qIdx));\n\n  return diffCount <= 1;\n};\n\n\nfunction UserSearchComponent() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [searchResults, setSearchResults] = useState([]);\n  const [selectedIndex, setSelectedIndex] = useState(0);\n  const [isDropdownOpen, setIsDropdownOpen] = useState(false);\n\n  const searchInputRef = useRef(null);\n  const resultsContainerRef = useRef(null);\n\n  const searchUsers = (query) => {\n    if (!query) return [];\n    const lowerCaseKeywords = query.toLowerCase().split(' ').filter(k => k.length > 0);\n\n    if (lowerCaseKeywords.length === 0) return [];\n\n    return MOCK_USERS.filter(user => {\n      // Combine all searchable fields into a single string for each user\n      const userSearchableText = (\n        user.name + ' ' +\n        user.address + ' ' +\n        user.zipCode + ' ' +\n        user.purchased.join(' ')\n      ).toLowerCase();\n\n      // Check if ALL keywords are present in the user's searchable text (or fuzzy match)\n      return lowerCaseKeywords.every(keyword => {\n        // Original exact match\n        if (userSearchableText.includes(keyword)) return true;\n        // Fuzzy match for name and address fields\n        const nameAndAddress = (user.name + ' ' + user.address).toLowerCase();\n        return isFuzzyMatch(nameAndAddress, keyword); // Apply fuzzy match only to relevant fields\n      });\n    });\n  };\n  \n  const handleInputChange = (e) => {\n    const value = e.target.value;\n    setSearchTerm(value);\n    \n    const results = searchUsers(value);\n    setSearchResults(results);\n    setSelectedIndex(0);\n    setIsDropdownOpen(results.length > 0);\n  };\n  \n  const handleKeyDown = (e) => {\n    if (!isDropdownOpen) return;\n    \n    switch (e.key) {\n      case 'ArrowDown':\n        e.preventDefault();\n        setSelectedIndex(prev => \n          (prev < searchResults.length - 1) ? prev + 1 : prev);\n        break;\n      case 'ArrowUp':\n        e.preventDefault();\n        setSelectedIndex(prev => (prev > 0) ? prev - 1 : 0);\n        break;\n      case 'Enter':\n        e.preventDefault();\n        if (searchResults[selectedIndex]) {\n          handleSelectUser(searchResults[selectedIndex]);\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        setIsDropdownOpen(false);\n        break;\n      default:\n        break;\n    }\n  };\n  \n  useEffect(() => {\n    if (isDropdownOpen && resultsContainerRef.current) {\n      const selectedElement = document.getElementById(`user-item-${selectedIndex}`);\n      if (selectedElement) {\n        selectedElement.scrollIntoView({ block: 'nearest', behavior: 'smooth' });\n      }\n    }\n  }, [selectedIndex, isDropdownOpen]);\n  \n  const handleSelectUser = (user) => {\n    console.log('Selected user:', user);\n    setSearchTerm('');\n    setIsDropdownOpen(false);\n  };\n  \n  return (\n    <div className=\"user-search\">\n      <div className=\"search-container\">\n        <input\n          ref={searchInputRef}\n          type=\"text\"\n          placeholder=\"Search users by name, items, address...\"\n          value={searchTerm}\n          onChange={handleInputChange}\n          onKeyDown={handleKeyDown}\n          onFocus={() => setIsDropdownOpen(searchResults.length > 0)}\n        />\n        \n        {isDropdownOpen && (\n          <div className=\"search-results\" ref={resultsContainerRef}>\n            {searchResults.length > 0 ? (\n              searchResults.map((user, index) => (\n                <div\n                  id={`user-item-${index}`}\n                  key={user.id}\n                  className={`user-item ${index === selectedIndex ? 'selected' : ''}`}\n                  onClick={() => handleSelectUser(user)}\n                  onMouseEnter={() => setSelectedIndex(index)}\n                >\n                  <div className=\"user-name\">{user.name}</div>\n                </div>\n              ))\n            ) : (\n              <div className=\"no-results\">No results found.</div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default UserSearchComponent;\n",
          "testCases": [
            "**Multi-keyword (Name + Item)**: Search for 'alice laptop'. Should return Alice Smith.",
            "**Multi-keyword (Item + Address)**: Search for 'keyboard oak'. Should return Bob Johnson.",
            "**Multi-keyword (Non-matching pair)**: Search for 'alice keyboard'. Should return no results (Alice has Laptop, Mouse; Bob has Keyboard).",
            "**Single Keyword (Existing)**: Search for 'frank'. Should return Frank White.",
            "**Fuzzy Matching (Name)**: Search for 'alce'. Should return Alice Smith.",
            "**Fuzzy Matching (Address)**: Search for '123 min'. Should return Alice Smith.",
            "**Fuzzy Matching (Multiple typos)**: Search for 'alca'. Should return no results (if 1-typo rule applies).",
            "**Empty Query**: `searchUsers('')` should return an empty array.",
            "**Query with Spaces**: `searchUsers('  ')` should return an empty array."
          ],
          "hints": [
            "Start by splitting the `query` string into an array of keywords using `split(' ')` and then `filter` out empty strings.",
            "Use `Array.prototype.every()` on the `lowerCaseKeywords` array inside the `user.filter()` callback. This ensures all keywords must match.",
            "For each `keyword`, you'll need to check if it `includes` any of the user's relevant fields (name, purchased, address, zipCode). Consider concatenating all searchable fields for a user into a single string for simpler `includes` checks.",
            "For basic fuzzy matching, you could implement a simple `isFuzzyMatch(text, query)` helper function that returns true if `text` contains `query` with, say, one character difference (e.g., using a simplified Levenshtein distance or a loop checking for one substitution/insertion/deletion)."
          ],
          "tags": [
            "JavaScript",
            "Algorithms",
            "Search",
            "Filtering",
            "String Manipulation",
            "Optimization"
          ],
          "timeEstimate": 120,
          "prerequisites": [
            "theory_search_filtering_and_list_rendering",
            "JavaScript_array_methods"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Levenshtein_distance",
            "Text_search_algorithms",
            "Data_normalization"
          ]
        }
      ]
    }
  }
]