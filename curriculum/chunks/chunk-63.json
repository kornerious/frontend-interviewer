[
  {
    "id": "0e0505ae-25f5-4faf-b0be-73ac61d29917",
    "startLine": 12600,
    "endLine": 12699,
    "processedDate": "2025-06-17T13:03:24.094Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_memoization",
          "title": "React Performance Optimization with useMemo, useCallback, and React.memo",
          "content": "React provides several hooks and HOCs (Higher-Order Components) to optimize component re-renders and improve application performance. The core idea behind these optimizations is 'memoization', a technique that caches the result of a function call and returns the cached result when the same inputs occur again, avoiding re-computation or re-rendering.\n\n## `useMemo` Hook\n`useMemo` is a React Hook that lets you cache the result of an expensive calculation between re-renders. It takes two arguments: a 'create' function and a dependency array. The create function is executed only when one of the dependencies in the array changes. If the dependencies are the same as the last render, `useMemo` returns the previously computed value, preventing unnecessary re-calculations.\n\n### When to use `useMemo`:\n*   **Expensive Calculations**: For computations that consume significant CPU time or resources.\n*   **Preventing Re-renders of Child Components**: When a calculated value is passed as a prop to a child component, `useMemo` can ensure the child only re-renders if the calculated value itself changes, and not just because the parent re-rendered.\n*   **Referential Equality**: When you need to preserve object or array reference equality across re-renders for comparisons (e.g., in `useEffect` dependencies or `React.memo` checks).\n\n## `useCallback` Hook\n`useCallback` is a React Hook that lets you cache a function definition between re-renders. It also takes a function and a dependency array. It returns a memoized version of the callback function that only changes if one of the dependencies has changed. This is particularly useful for optimizing child components that rely on referential equality checks for their props (e.g., components wrapped with `React.memo`). If a parent component re-renders, a function defined directly within it would be re-created on every render, leading to unnecessary re-renders in memoized child components.\n\n### When to use `useCallback`:\n*   **Passing Callbacks to Memoized Child Components**: To prevent unnecessary re-renders of child components that are wrapped in `React.memo` and receive callback functions as props.\n*   **Optimizing `useEffect` Dependencies**: To prevent `useEffect` from re-running unnecessarily when a callback function is part of its dependency array.\n\n## `React.memo` HOC\n`React.memo` is a higher-order component that wraps a functional component and memoizes its rendered output. It prevents a functional component from re-rendering if its props have not changed. By default, `React.memo` performs a shallow comparison of the props. If you need more control over the comparison, you can provide a custom comparison function as the second argument to `React.memo`.\n\n### When to use `React.memo`:\n*   **Pure Functional Components**: For components that render the same output given the same props.\n*   **Heavy Components**: Components with complex UI or many nested components that are expensive to render.\n*   **Frequent Re-renders**: Components that re-render often due to parent re-renders but whose props frequently remain the same.\n\n**Important Considerations for Memoization:**\n*   **Overhead**: Memoization itself has a small overhead (memory for caching, comparison logic). It should only be used when the cost of re-rendering or re-computing outweighs this overhead.\n*   **Correct Dependencies**: Incorrect or missing dependencies can lead to stale closures or values, causing bugs. Always ensure the dependency array is accurate.\n*   **Debugging**: Memoization can sometimes make debugging more complex as components might not re-render when expected, leading to stale UI if not correctly implemented.",
          "examples": [
            {
              "id": "example_react_memoization_1",
              "title": "Basic useMemo and useCallback",
              "code": "import React, { useMemo, useCallback, useState } from 'react';\n\nfunction ExpensiveCalculationDisplay({ numbers }) {\n  const sum = useMemo(() => {\n    console.log('Calculating sum...');\n    return numbers.reduce((acc, num) => acc + num, 0);\n  }, [numbers]); // Recalculates only if 'numbers' array changes\n\n  return <p>Sum: {sum}</p>;\n}\n\n// Memoized child component for demonstration\nconst Button = React.memo(({ onClick, label }) => {\n  console.log(`Rendering ${label} Button`);\n  return <button onClick={onClick}>{label}</button>;\n});\n\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n  const [data, setData] = useState([1, 2, 3]);\n\n  // This function would be re-created on every render without useCallback\n  // and cause Button to re-render even if its props haven't conceptually changed.\n  const incrementCount = useCallback(() => {\n    setCount(prevCount => prevCount + 1);\n  }, []); // Empty dependency array means it's created once\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <Button onClick={incrementCount} label=\"Increment\" />\n      <ExpensiveCalculationDisplay numbers={data} />\n      <button onClick={() => setData([...data, Math.random()])}>Add Random Number</button>\n      <button onClick={() => setCount(count + 1)}>Force Parent Re-render</button>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates `useMemo` to cache an expensive sum calculation for the `ExpensiveCalculationDisplay` component, only re-computing when `numbers` changes. `useCallback` is used to memoize the `incrementCount` function, ensuring that the `Button` component (which is wrapped in `React.memo`) does not re-render unnecessarily when `ParentComponent` re-renders due to `data` changes, only when its `onClick` prop (the memoized `incrementCount`) actually changes, which it won't due to `useCallback` with an empty dependency array.",
              "language": "typescript"
            },
            {
              "id": "example_react_memoization_2",
              "title": "React.memo with Custom Comparison",
              "code": "import React from 'react';\n\ninterface ItemProps {\n  item: { id: number; value: string; timestamp: number; };\n  onClick: (id: number) => void;\n}\n\n// Custom comparison function for React.memo\n// Only re-render if id or value changes, ignore timestamp\nconst areEqual = (prevProps: ItemProps, nextProps: ItemProps) => {\n  return (\n    prevProps.item.id === nextProps.item.id &&\n    prevProps.item.value === nextProps.item.value &&\n    prevProps.onClick === nextProps.onClick // Ensure callback is stable\n  );\n};\n\nconst MemoizedListItem = React.memo(({\n  item,\n  onClick\n}: ItemProps) => {\n  console.log(`Rendering Item: ${item.value}`);\n  return (\n    <li onClick={() => onClick(item.id)}>\n      {item.value} (ID: {item.id})\n    </li>\n  );\n}, areEqual);\n\nfunction ItemList({ items, onItemClick }) {\n  return (\n    <ul>\n      {items.map(item => (\n        <MemoizedListItem key={item.id} item={item} onClick={onItemClick} />\n      ))}\n    </ul>\n  );\n}",
              "explanation": "This example shows `React.memo` with a custom comparison function (`areEqual`). The `MemoizedListItem` will only re-render if its `id`, `value`, or `onClick` prop changes. The `timestamp` property on the `item` object is explicitly ignored in the comparison, demonstrating how to fine-tune re-render behavior for specific use cases where a shallow comparison might be too broad or too narrow.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Performance",
            "Optimization",
            "Hooks",
            "useMemo",
            "useCallback",
            "React.memo",
            "Memoization"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "large_scale_react_apps",
            "performance_tuning"
          ]
        },
        {
          "id": "theory_virtual_dom_keys",
          "title": "Virtual DOM Optimization: Keys for Efficient List Rendering",
          "content": "React uses a Virtual DOM to optimize updates to the actual DOM. When state or props of a component change, React creates a new Virtual DOM tree and then efficiently compares it with the previous Virtual DOM tree (a process called 'reconciliation') to identify the minimal set of changes needed for the actual DOM. This diffing algorithm is crucial for performance.\n\n## The Role of `key` Prop in Lists\nWhen rendering lists of elements in React (e.g., using `map`), it's essential to provide a unique `key` prop to each list item. The `key` prop helps React identify which items have changed, are added, or are removed. Without keys, or with non-unique keys (like array indices), React's reconciliation algorithm becomes less efficient and can lead to:\n\n1.  **Performance Issues**: Without stable keys, React might re-render or re-order elements unnecessarily, especially when items are added, removed, or reordered within the list. It might re-mount components instead of updating them.\n2.  **State Problems**: Input fields or other components within list items might lose their internal state when the list changes, as React might incorrectly identify items due to unstable keys.\n3.  **Bugs with Animations/Transitions**: Animations tied to component lifecycles might behave unexpectedly.\n\n### Best Practices for `key`:\n*   **Unique and Stable**: Keys must be unique among siblings and stable (i.e., they should not change between re-renders for the same item). The best source for a key is a unique ID from your data (e.g., `item.id`).\n*   **Avoid Using Array Index as Key**: Using an array index (`index`) as a key is generally discouraged, especially if the list can be reordered, filtered, or new items can be added in the middle. While it might seem convenient, it leads to the exact performance and state issues mentioned above. It's only acceptable if the list is static and will never be reordered, filtered, or have items added/removed.\n*   **Avoid `Math.random()` or other volatile values**: These values change on every render, defeating the purpose of keys and forcing unnecessary re-renders.\n\nBy providing a stable and unique `key`, React can efficiently update the DOM by reordering existing elements rather than re-creating them, maintaining their state, and significantly improving performance.",
          "examples": [
            {
              "id": "example_virtual_dom_keys_1",
              "title": "Correct Key Usage in Lists",
              "code": "import React from 'react';\n\ninterface Todo { id: string; text: string; completed: boolean; }\n\nfunction TodoList({ todos }: { todos: Todo[] }) {\n  return (\n    <ul>\n      {todos.map(todo => (\n        // Using a unique ID from the data as the key\n        <li key={todo.id}>{todo.text}</li>\n      ))}\n    </ul>\n  );\n}",
              "explanation": "This example demonstrates the correct usage of the `key` prop for list items. Each `todo` object has a unique `id`, which is used as the `key`. This allows React to efficiently identify and update individual `li` elements when the `todos` array changes (e.g., an item is added, removed, or its properties are updated).",
              "language": "typescript"
            },
            {
              "id": "example_virtual_dom_keys_2",
              "title": "Incorrect Key Usage (and its consequences)",
              "code": "import React, { useState } from 'react';\n\nfunction BadTodoList() {\n  const [items, setItems] = useState([\n    { id: 'a', text: 'Item A' },\n    { id: 'b', text: 'Item B' },\n    { id: 'c', text: 'Item C' },\n  ]);\n\n  const addItemAtBeginning = () => {\n    const newItem = { id: Date.now().toString(), text: `New Item ${Date.now()}` };\n    setItems([newItem, ...items]);\n  };\n\n  return (\n    <div>\n      <button onClick={addItemAtBeginning}>Add Item at Beginning</button>\n      <ul>\n        {items.map((item, index) => (\n          // BAD PRACTICE: Using index as key when items can be reordered/added\n          <li key={index}>\n            {item.text} <input type=\"text\" placeholder=\"Enter something\" />\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
              "explanation": "This example illustrates the problematic use of array `index` as a `key`. When a new item is added to the beginning of the `items` array, all subsequent items shift their indices. React sees that `item[0]` now contains the *new* item, but it assumes `item[1]` (which was `item[0]` before) is the *same* element. This can lead to incorrect state preservation (e.g., the input values might shift incorrectly) and inefficient re-renders, as React re-mounts or re-renders more elements than necessary.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Virtual DOM",
            "Keys",
            "Lists",
            "Performance",
            "Reconciliation",
            "Optimization"
          ],
          "technology": "React",
          "prerequisites": [
            "react_rendering_process",
            "react_lists"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "efficient_list_rendering",
            "large_scale_react_apps"
          ]
        },
        {
          "id": "theory_web_components_in_react",
          "title": "Web Components in React",
          "content": "Web Components are a set of standardized web platform APIs that allow developers to create new custom, reusable, and encapsulated HTML elements. They are composed of four main specifications:\n\n1.  **Custom Elements**: Allow you to define new HTML tags (e.g., `<my-button>`).\n2.  **Shadow DOM**: Provides a way to encapsulate a component's internal structure, styles, and behavior, isolating them from the main document's DOM. This prevents style leaks and global CSS conflicts.\n3.  **HTML Templates**: `<template>` and `<slot>` elements enable defining reusable markup templates.\n4.  **ES Modules**: Provide a standardized way to define, import, and export JavaScript modules, which is used for importing Web Components.\n\nWhile React components and Web Components serve different purposes (React components for building application UIs with declarative syntax and state management, Web Components for creating reusable low-level UI elements), they can work together seamlessly.\n\n### Integrating Web Components with React:\nWeb Components can be used directly within JSX as if they were standard HTML elements. React passes data to Web Components as attributes. For complex data types (objects, arrays), you might need to stringify them or use properties directly if the Web Component exposes a way to set properties via JavaScript.\n\n#### Key Benefits of Using Web Components with React:\n1.  **Encapsulation**: Web Components use Shadow DOM, which provides strong style and markup encapsulation. This means the styles defined within a Web Component won't leak out and affect other parts of your React application, and vice-versa. This is particularly useful for creating truly isolated UI widgets.\n2.  **Reusability**: Custom elements can be used across different frameworks (React, Angular, Vue, etc.) or even without any framework, as they are based on native web standards. This makes them highly portable and ideal for design systems or component libraries that need to be framework-agnostic.\n3.  **Standard-based**: Being built upon web standards ensures long-term compatibility and reduces reliance on specific framework implementations or proprietary solutions.\n4.  **Framework Agnostic**: Web Components work natively in the browser, making them a 'write once, use anywhere' solution for UI elements. This portability is a significant advantage for large organizations using multiple frontend technologies or for distributing UI components.\n\n#### Considerations:\n*   **Event Handling**: Web Components use standard DOM events. React's synthetic event system may not always capture events from Shadow DOM. You might need to attach event listeners directly to the DOM element using `useRef` and `addEventListener` or ensure the Web Component dispatches custom events that bubble up.\n*   **Passing Complex Data**: React's prop system passes primitives and simple objects as attributes. For complex objects or arrays, you might need to set properties on the underlying DOM node using refs, as attributes are always strings.\n*   **Tooling/SSR**: Server-Side Rendering (SSR) and tooling for Web Components can sometimes be less mature or require different setups compared to React's own ecosystem.\n\nDespite these considerations, Web Components offer a powerful way to integrate highly reusable, encapsulated, and framework-agnostic UI elements into a React application, enhancing interoperability and long-term maintainability.",
          "examples": [
            {
              "id": "example_web_components_in_react_1",
              "title": "Using a Vaadin Web Component in React",
              "code": "import React, { Component } from 'react';\nimport '@vaadin/vaadin-date-picker'; // Importing the Web Component\n\nclass WebComponentExample extends Component {\n  // For handling events from Web Components, you might need a ref\n  datePickerRef = React.createRef<any>();\n\n  componentDidMount() {\n    // Accessing the native Web Component element to attach event listeners\n    if (this.datePickerRef.current) {\n      this.datePickerRef.current.addEventListener('value-changed', (event: CustomEvent) => {\n        console.log('Date changed:', event.detail.value);\n      });\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        {/* Using the Web Component within React, passing a prop as attribute */}\n        <vaadin-date-picker\n          label=\"When were you born?\"\n          ref={this.datePickerRef} // Attach ref to access native element\n        ></vaadin-date-picker>\n        <p>This is a standard React paragraph.</p>\n      </div>\n    );\n  }\n}\n\nexport default WebComponentExample;",
              "explanation": "This example shows how to import and use a `vaadin-date-picker` Web Component directly within a React component's JSX. The `label` prop is passed as an HTML attribute. It also demonstrates how to use a `ref` and `addEventListener` in `componentDidMount` (or `useEffect` for functional components) to listen to custom events dispatched by the Web Component, which is often necessary because React's synthetic event system might not automatically capture events from inside Shadow DOM.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Web Components",
            "Custom Elements",
            "Shadow DOM",
            "Framework Agnostic",
            "Interoperability",
            "Front-end Architecture"
          ],
          "technology": "React",
          "prerequisites": [
            "html_custom_elements",
            "react_components",
            "dom_events"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "requiredFor": [
            "design_systems",
            "micro_frontends",
            "legacy_integration"
          ]
        },
        {
          "id": "theory_javascript_build_tools_npm",
          "title": "Modern JavaScript Build Tools and Workflow: Package Managers (NPM)",
          "content": "Modern JavaScript development heavily relies on a robust ecosystem of build tools and package managers to manage dependencies, automate tasks, optimize code, and prepare applications for deployment. These tools are fundamental for efficient and scalable frontend development.\n\n## Package Managers\nPackage managers are essential tools for installing, updating, configuring, and removing libraries and dependencies used in a software project. They automate the process of managing external code modules.\n\n### NPM (Node Package Manager)\nNPM is the default and most widely used package manager for the Node.js runtime environment. It comes bundled automatically with every Node.js installation. NPM serves a dual purpose:\n\n1.  **Command-Line Interface (CLI)**: A tool to interact with the NPM registry, allowing developers to install, publish, and manage packages.\n2.  **Online Registry**: A public database of open-source Node.js packages (and frontend libraries). This registry hosts millions of packages, making it the largest software registry in the world.\n\n#### Key functionalities of NPM CLI:\n*   **`npm init`**: Initializes a new Node.js project, creating a `package.json` file which stores project metadata and dependency information.\n*   **`npm install [package-name]`**: Installs a specific package. By default, it installs the latest version. It adds the package to `node_modules` and saves it as a dependency in `package.json` (as a `dependency` or `devDependency`).\n*   **`npm install`**: Installs all dependencies listed in the `package.json` file. This is crucial for setting up a project on a new machine or after cloning a repository.\n*   **`npm uninstall [package-name]`**: Removes a package from `node_modules` and `package.json`.\n*   **`npm update [package-name]`**: Updates a specific package to its latest compatible version.\n*   **`npm run [script-name]`**: Executes custom scripts defined in the `scripts` section of `package.json`. This is commonly used for running build processes, tests, development servers, etc.\n*   **`npm audit`**: Scans your project for security vulnerabilities in your dependencies.\n\n#### `package.json` and `package-lock.json`\n*   **`package.json`**: This file is at the heart of any Node.js/JavaScript project. It contains metadata about the project (name, version, description, author), defines scripts, and lists project dependencies and devDependencies with semantic versioning ranges (e.g., `^1.0.0`).\n*   **`package-lock.json`**: This file is automatically generated and updated by NPM (and Yarn). It records the *exact* versions of all installed packages (including transitive dependencies) and their checksums. Its purpose is to ensure that future `npm install` operations produce the identical `node_modules` tree, regardless of when `npm install` is run or which version of NPM is used. This guarantees consistent builds across different environments and team members.\n\nNPM (along with Yarn and pnpm) is an indispensable tool for managing the complex dependency graphs common in modern web development.",
          "examples": [
            {
              "id": "example_npm_1",
              "title": "Basic NPM Commands and package.json structure",
              "code": "// To initialize a new project and create package.json\nnpm init -y\n\n// Install a package (e.g., React)\nnpm install react react-dom\n\n// Install a dev dependency (e.g., Webpack)\nnpm install webpack --save-dev\n\n// Running a custom script defined in package.json\nnpm run start\n\n/* Example package.json content: */\n{\n  \"name\": \"my-react-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A simple React app.\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\"\n  },\n  \"keywords\": [],\n  \"author\": \"Your Name\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\"\n  },\n  \"devDependencies\": {\n    \"webpack\": \"^5.88.2\"\n  }\n}",
              "explanation": "This example shows common NPM CLI commands and a basic `package.json` structure. `npm init -y` quickly sets up a project. `npm install` commands add packages to `dependencies` or `devDependencies` in `package.json`. The `scripts` section defines runnable commands, which can be executed with `npm run <script-name>`. This illustrates the central role of `package.json` in managing project dependencies and scripts.",
              "language": "shell"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "JavaScript",
            "Node.js",
            "NPM",
            "Package Manager",
            "Build Tools",
            "Workflow",
            "Dependencies",
            "package.json",
            "package-lock.json"
          ],
          "technology": "Node.js",
          "prerequisites": [
            "javascript_basics",
            "command_line_basics"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "beginner",
          "requiredFor": [
            "any_javascript_project",
            "frontend_development"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_react_memoization_1",
          "topic": "React Performance Optimization",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React functional component. What is the primary purpose of wrapping `MyComponent` with `React.memo` as `MemoizedComponent`?\n\n```jsx\nimport React, { useMemo, useCallback } from 'react';\n\nfunction MyComponent({ data, onItemClick }) {\n  const processedData = useMemo(() => {\n    return data.map(item => performExpensiveOperation(item));\n  }, [data]);\n  \n  const handleClick = useCallback((id) => {\n    onItemClick(id);\n  }, [onItemClick]);\n  \n  return (\n    <ul>\n      {processedData.map(item => (\n        <li key={item.id} onClick={() => handleClick(item.id)}>\n          {item.name}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\nconst MemoizedComponent = React.memo(MyComponent);\n```",
          "answer": "To prevent `MyComponent` from re-rendering if its props (`data` and `onItemClick`) have not changed.",
          "options": [
            "To make `processedData` recalculate only when `data` changes.",
            "To ensure `handleClick` is created only once.",
            "To prevent `MyComponent` from re-rendering if its props (`data` and `onItemClick`) have not changed.",
            "To optimize the initial render time of `MyComponent`."
          ],
          "analysisPoints": [
            "`React.memo` is a HOC that memoizes a functional component, preventing re-renders if props are shallowly equal.",
            "`useMemo` memoizes a value (like `processedData`), not the component itself.",
            "`useCallback` memoizes a function (like `handleClick`), not the component itself.",
            "`React.memo` optimizes subsequent re-renders, not the initial render."
          ],
          "keyConcepts": [
            "React.memo",
            "Memoization",
            "Performance Optimization",
            "Component Re-rendering"
          ],
          "evaluationCriteria": [
            "Understanding of `React.memo`'s functionality.",
            "Ability to differentiate `React.memo` from `useMemo` and `useCallback`."
          ],
          "example": "The `React.memo` HOC is designed to optimize functional components by preventing unnecessary re-renders. When `MemoizedComponent` is used, React will only re-render it if the `data` prop or the `onItemClick` prop (or any other prop passed to it) has changed shallowly compared to the previous render. This saves performance by skipping the execution of `MyComponent`'s render logic.",
          "tags": [
            "React",
            "Performance",
            "React.memo",
            "MCQ"
          ],
          "prerequisites": [
            "react_functional_components",
            "react_props"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_memoization_2",
          "topic": "React Performance Optimization",
          "level": "medium",
          "type": "open",
          "question": "Explain the difference between `useMemo` and `useCallback` in React. Provide a scenario where using `useCallback` is particularly beneficial, even when `useMemo` might seem similar.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "`useMemo` memoizes the *result* of a function (a value). `useCallback` memoizes the *function itself* (a reference).",
            "Both take a function and a dependency array. `useMemo` executes the function and caches its return value; `useCallback` returns the memoized function reference.",
            "Scenario for `useCallback`: Passing a callback to a `React.memo` wrapped child component. If the parent re-renders, the function reference would change without `useCallback`, forcing the `React.memo` child to re-render even if its actual logic hasn't changed. `useCallback` ensures the function reference remains stable across parent renders, allowing `React.memo` to effectively prevent re-renders of the child."
          ],
          "keyConcepts": [
            "useMemo",
            "useCallback",
            "Memoization",
            "Referential Equality",
            "React.memo",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of definitions.",
            "Understanding of when to apply each hook.",
            "Ability to articulate the specific benefit of `useCallback` in a practical scenario (e.g., with `React.memo` children)."
          ],
          "example": "```typescript\nimport React, { useState, useCallback, useMemo } from 'react';\n\nconst ChildComponent = React.memo(({ onClick, value }) => {\n  console.log('ChildComponent re-rendered');\n  return <button onClick={onClick}>Child Button: {value}</button>;\n});\n\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('Hello');\n\n  // Scenario for useCallback: Passing a stable callback to a memoized child\n  const handleChildClick = useCallback(() => {\n    setCount(prev => prev + 1);\n  }, []); // Empty dependency array means this function reference is stable\n\n  // Example for useMemo: Expensive calculation\n  const expensiveValue = useMemo(() => {\n    console.log('Calculating expensive value...');\n    let sum = 0;\n    for (let i = 0; i < 10000000; i++) {\n      sum += i;\n    }\n    return sum + count; // Recalculates if count changes\n  }, [count]);\n\n  return (\n    <div>\n      <p>Parent Count: {count}</p>\n      <p>Parent Text: {text}</p>\n      <p>Expensive Value: {expensiveValue}</p>\n      <ChildComponent onClick={handleChildClick} value={count} />\n      <button onClick={() => setText(text + '!')}>Change Parent Text (Forces Parent Re-render)</button>\n    </div>\n  );\n}\n```\nIn `ParentComponent`, if `setText` is called, `ParentComponent` re-renders. Without `useCallback` for `handleChildClick`, a *new* function reference would be created on each render. Even though the *logic* of `handleChildClick` hasn't changed, its reference would. Since `ChildComponent` is `React.memo`-ized, it performs a shallow prop comparison. A new function reference for `onClick` would cause `ChildComponent` to re-render unnecessarily. `useCallback` prevents this by returning the same function reference unless its dependencies change.",
          "tags": [
            "React",
            "useMemo",
            "useCallback",
            "React.memo",
            "Performance",
            "Hooks",
            "Open-Ended"
          ],
          "prerequisites": [
            "react_hooks",
            "react_functional_components",
            "referential_equality"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_memoization_3",
          "topic": "React Performance Optimization",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using `React.memo`?",
          "answer": "It prevents a functional component from re-rendering if its props have not changed (based on a shallow comparison by default).",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React.memo",
            "Memoization",
            "Performance"
          ],
          "evaluationCriteria": [],
          "example": null,
          "tags": [
            "React",
            "React.memo",
            "Performance",
            "Flashcard"
          ],
          "prerequisites": [
            "react_functional_components"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_memoization_4",
          "topic": "React Performance Optimization",
          "level": "hard",
          "type": "code",
          "question": "Optimize the following React component to prevent unnecessary re-renders of the `ListItem` component. The `ListItem` should only re-render if its `item`'s `text` or `completed` status changes, or if the `onToggle` callback changes. The `items` array in `ParentComponent` can frequently update with new `timestamp` values for existing items. Also, ensure the `filterCompleted` calculation is memoized.\n\n```jsx\nimport React, { useState } from 'react';\n\nfunction ListItem({ item, onToggle }) {\n  console.log(`Rendering ListItem: ${item.text}`);\n  return (\n    <li style={{ textDecoration: item.completed ? 'line-through' : 'none' }}>\n      {item.text}\n      <button onClick={() => onToggle(item.id)}>Toggle</button>\n    </li>\n  );\n}\n\nfunction ParentComponent() {\n  const [items, setItems] = useState([\n    { id: 1, text: 'Buy milk', completed: false, timestamp: Date.now() },\n    { id: 2, text: 'Walk dog', completed: true, timestamp: Date.now() },\n  ]);\n  const [filter, setFilter] = useState('all'); // 'all', 'completed', 'active'\n\n  const handleToggle = (id) => {\n    setItems(prevItems =>\n      prevItems.map(item =>\n        item.id === id ? { ...item, completed: !item.completed, timestamp: Date.now() } : item\n      )\n    );\n  };\n\n  const filteredItems = items.filter(item => {\n    console.log('Filtering items...');\n    if (filter === 'completed') return item.completed;\n    if (filter === 'active') return !item.completed;\n    return true;\n  });\n\n  return (\n    <div>\n      <button onClick={() => setFilter('all')}>All</button>\n      <button onClick={() => setFilter('active')}>Active</button>\n      <button onClick={() => setFilter('completed')}>Completed</button>\n      <ul>\n        {filteredItems.map(item => (\n          <ListItem key={item.id} item={item} onToggle={handleToggle} />\n        ))}\n      </ul>\n    </div>\n  );\n}\n```",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Wrap `ListItem` with `React.memo` and provide a custom comparison function that checks `item.id`, `item.text`, `item.completed`, and `onToggle`.",
            "Memoize `handleToggle` using `useCallback` with an empty dependency array (or `[]` if it doesn't depend on outer scope, or `[setItems]` if it needs `setItems`). Given `setItems` is stable, `[]` is fine.",
            "Memoize `filteredItems` using `useMemo` with `items` and `filter` as dependencies."
          ],
          "keyConcepts": [
            "React.memo",
            "useCallback",
            "useMemo",
            "Custom Comparison Function",
            "Performance Optimization",
            "Referential Equality"
          ],
          "evaluationCriteria": [
            "Correct application of `React.memo` with a custom comparison.",
            "Correct application of `useCallback` for stable function references.",
            "Correct application of `useMemo` for expensive calculations.",
            "Understanding of dependency arrays.",
            "Ability to identify and address specific re-rendering issues."
          ],
          "example": "```typescript\nimport React, { useState, useCallback, useMemo } from 'react';\n\ninterface TodoItem {\n  id: number;\n  text: string;\n  completed: boolean;\n  timestamp: number;\n}\n\ninterface ListItemProps {\n  item: TodoItem;\n  onToggle: (id: number) => void;\n}\n\n// Custom comparison for ListItem\nconst areEqualListItem = (prevProps: ListItemProps, nextProps: ListItemProps) => {\n  return (\n    prevProps.item.id === nextProps.item.id &&\n    prevProps.item.text === nextProps.item.text &&\n    prevProps.item.completed === nextProps.item.completed &&\n    prevProps.onToggle === nextProps.onToggle\n  );\n};\n\nconst MemoizedListItem = React.memo(function ListItem({ item, onToggle }: ListItemProps) {\n  console.log(`Rendering ListItem: ${item.text}`);\n  return (\n    <li style={{ textDecoration: item.completed ? 'line-through' : 'none' }}>\n      {item.text}\n      <button onClick={() => onToggle(item.id)}>Toggle</button>\n    </li>\n  );\n}, areEqualListItem);\n\nfunction ParentComponent() {\n  const [items, setItems] = useState<TodoItem[]>([\n    { id: 1, text: 'Buy milk', completed: false, timestamp: Date.now() },\n    { id: 2, text: 'Walk dog', completed: true, timestamp: Date.now() },\n  ]);\n  const [filter, setFilter] = useState<'all' | 'completed' | 'active'>('all');\n\n  // Memoize handleToggle to prevent unnecessary re-renders of MemoizedListItem\n  const handleToggle = useCallback((id: number) => {\n    setItems(prevItems =>\n      prevItems.map(item =>\n        item.id === id ? { ...item, completed: !item.completed, timestamp: Date.now() } : item\n      )\n    );\n  }, []); // setItems from useState is guaranteed to be stable, so empty array is fine\n\n  // Memoize filteredItems calculation\n  const filteredItems = useMemo(() => {\n    console.log('Filtering items...');\n    return items.filter(item => {\n      if (filter === 'completed') return item.completed;\n      if (filter === 'active') return !item.completed;\n      return true;\n    });\n  }, [items, filter]); // Recalculate only if items or filter changes\n\n  return (\n    <div>\n      <button onClick={() => setFilter('all')}>All</button>\n      <button onClick={() => setFilter('active')}>Active</button>\n      <button onClick={() => setFilter('completed')}>Completed</button>\n      <ul>\n        {filteredItems.map(item => (\n          <MemoizedListItem key={item.id} item={item} onToggle={handleToggle} />\n        ))}\n      </ul>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "Performance",
            "Optimization",
            "Hooks",
            "React.memo",
            "useCallback",
            "useMemo",
            "Code"
          ],
          "prerequisites": [
            "react_functional_components",
            "react_hooks",
            "react_memoization"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_virtual_dom_keys_1",
          "topic": "Virtual DOM Optimization: Keys",
          "level": "easy",
          "type": "flashcard",
          "question": "Why do elements rendered in a list in React need a unique `key` prop?",
          "answer": "Keys help React identify which items have changed, are added, or are removed during reconciliation, leading to efficient updates of the DOM.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Keys",
            "Virtual DOM",
            "Reconciliation",
            "List Rendering"
          ],
          "evaluationCriteria": [],
          "example": null,
          "tags": [
            "React",
            "Keys",
            "Virtual DOM",
            "Flashcard"
          ],
          "prerequisites": [
            "react_lists"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_virtual_dom_keys_2",
          "topic": "Virtual DOM Optimization: Keys",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following scenarios is MOST likely to cause issues (performance or state) if array indices are used as `key` props for a list in React?\n\n```jsx\nfunction ItemList({ items }) {\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={index}>{item.text} <input type=\"text\" /></li>\n      ))}\n    </ul>\n  );\n}\n```",
          "answer": "Adding a new item to the beginning or middle of the `items` array.",
          "options": [
            "Adding a new item to the end of the `items` array.",
            "Removing an item from the end of the `items` array.",
            "Only updating a property of an existing item (e.g., `item.text`).",
            "Adding a new item to the beginning or middle of the `items` array."
          ],
          "analysisPoints": [
            "Using index as a key is problematic when the order of items can change, or when items can be added/removed from the middle/beginning.",
            "If an item is added to the beginning, all existing items shift their indices, causing React to mistakenly think existing items have changed, leading to re-mounting or incorrect state preservation.",
            "Adding to the end or removing from the end generally does not cause issues with index keys, as existing items' indices don't change."
          ],
          "keyConcepts": [
            "Keys",
            "Array Index",
            "Reconciliation",
            "List Performance",
            "State Preservation"
          ],
          "evaluationCriteria": [
            "Understanding of the pitfalls of using array index as a key.",
            "Ability to identify scenarios where index keys cause problems."
          ],
          "example": "When an item is added to the beginning, say we have `['A', 'B']` with keys `0, 1`. If we add 'X' at the beginning, the array becomes `['X', 'A', 'B']`. With index keys, React sees `X` at index `0`, `A` at index `1`, `B` at index `2`. It might try to 'update' the old `A` (at index 0) into `X`, and the old `B` (at index 1) into `A`, rather than simply inserting `X` at the beginning and preserving `A` and `B`. This leads to inefficient DOM manipulations and potential loss of internal component state (like an `<input>`'s value).",
          "tags": [
            "React",
            "Keys",
            "Virtual DOM",
            "MCQ",
            "List Rendering"
          ],
          "prerequisites": [
            "react_lists",
            "react_virtual_dom"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_keys_3",
          "topic": "Virtual DOM Optimization: Keys",
          "level": "medium",
          "type": "open",
          "question": "You are building a chat application where new messages appear at the bottom of the list. Each message has a unique `id`. Would you use `Math.random()` as a `key` for each message? Explain why or why not, and propose a better alternative.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "No, `Math.random()` should never be used as a key.",
            "Reason: `Math.random()` generates a new, unique value on *every* render. This defeats the purpose of keys, as React will perceive every list item as a 'new' item on every re-render, even if the content hasn't changed. This leads to maximum inefficiency (forcing re-creation of all DOM nodes and re-mounting of components) and potential state loss.",
            "Better alternative: Use the unique `id` provided for each message. If no stable ID is available from the data, consider generating one when the data is first created (e.g., using a UUID library).",
            "Even if new messages are only added to the end, using `Math.random()` still causes unnecessary re-renders of the *entire* list, as keys are unstable."
          ],
          "keyConcepts": [
            "Keys",
            "Stability of Keys",
            "Performance Implications",
            "Virtual DOM",
            "Reconciliation"
          ],
          "evaluationCriteria": [
            "Understanding of key stability requirements.",
            "Ability to explain the negative consequences of unstable keys.",
            "Ability to propose correct and robust solutions for key generation."
          ],
          "example": "```jsx\n// Bad example: Do NOT do this!\nfunction ChatMessage({ message }) {\n  return <li key={Math.random()}>{message.text}</li>; // Key changes on every render\n}\n\n// Good example:\nfunction ChatMessage({ message }) {\n  return <li key={message.id}>{message.text}</li>; // Stable, unique ID\n}\n```\nUsing `Math.random()` as a key forces React to re-render the entire `li` element and its children every single time the `ChatMessage` component's parent re-renders, even if the message content hasn't changed. This negates all benefits of React's Virtual DOM reconciliation.",
          "tags": [
            "React",
            "Keys",
            "Performance",
            "Anti-pattern",
            "Open-Ended"
          ],
          "prerequisites": [
            "react_lists",
            "react_virtual_dom"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_web_components_in_react_1",
          "topic": "Web Components in React",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a primary benefit of using Web Components within a React application?",
          "answer": "They automatically share React's component state management.",
          "options": [
            "They provide strong encapsulation of styles and markup using Shadow DOM.",
            "They can be reused across different JavaScript frameworks or without any framework.",
            "They are based on web standards, ensuring long-term compatibility.",
            "They automatically share React's component state management."
          ],
          "analysisPoints": [
            "Web Components provide encapsulation, reusability, and are standard-based, as explicitly stated in the theory.",
            "Web Components are framework-agnostic. They do not automatically integrate with or share React's specific state management (like `useState`, `useReducer`, or Context API). They have their own internal state, and communication with React components typically happens via props (attributes) and custom DOM events."
          ],
          "keyConcepts": [
            "Web Components",
            "React",
            "Encapsulation",
            "Reusability",
            "Framework Agnostic",
            "Standard-based",
            "State Management"
          ],
          "evaluationCriteria": [
            "Understanding of the core benefits of Web Components.",
            "Ability to identify common misconceptions about Web Component integration with frameworks."
          ],
          "example": "Web Components exist independently of React. While you can pass data to them as attributes or properties, and listen for their custom events, they manage their own internal state using their own mechanisms, not React's. For a Web Component to interact with React's state, you would typically pass a callback from React that updates React's state based on an event dispatched by the Web Component.",
          "tags": [
            "Web Components",
            "React",
            "MCQ",
            "Interoperability"
          ],
          "prerequisites": [
            "web_components_basics",
            "react_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_web_components_in_react_2",
          "topic": "Web Components in React",
          "level": "hard",
          "type": "open",
          "question": "You've integrated a custom Web Component `<my-custom-slider>` into your React application. This slider dispatches a custom event `slider-value-changed` when its value changes, with the new value in `event.detail.value`. How would you typically handle this event in a React functional component to update React's state?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Recognize that React's synthetic event system might not capture custom DOM events from Shadow DOM directly.",
            "The standard approach is to use `useRef` to get a direct reference to the DOM element where the Web Component is rendered.",
            "Attach an event listener using `addEventListener` to this DOM element within a `useEffect` hook.",
            "Ensure the `useEffect` cleanup function removes the event listener to prevent memory leaks.",
            "Inside the event listener, access `event.detail.value` and update the React component's state using `useState` or `useReducer`."
          ],
          "keyConcepts": [
            "Web Components",
            "React Hooks",
            "useRef",
            "useEffect",
            "Event Handling",
            "Custom Events",
            "Shadow DOM",
            "Interoperability"
          ],
          "evaluationCriteria": [
            "Knowledge of `useRef` and `useEffect` for direct DOM interaction.",
            "Understanding of Web Component event mechanisms (custom events, `event.detail`).",
            "Ability to correctly implement event listener setup and cleanup in React hooks.",
            "Problem-solving for interoperability challenges."
          ],
          "example": "```typescript\nimport React, { useRef, useEffect, useState } from 'react';\n\n// Assume this is your actual Web Component definition (e.g., in a separate file)\n// Or it's a globally registered component imported earlier\n// class MyCustomSlider extends HTMLElement {\n//   constructor() {\n//     super();\n//     const shadowRoot = this.attachShadow({ mode: 'open' });\n//     shadowRoot.innerHTML = `<input type=\"range\" min=\"0\" max=\"100\" value=\"0\">`;\n//     const input = shadowRoot.querySelector('input');\n//     input.addEventListener('input', (e) => {\n//       const event = new CustomEvent('slider-value-changed', {\n//         detail: { value: (e.target as HTMLInputElement).value },\n//         bubbles: true, // important for events to bubble up\n//         composed: true // important for events to cross shadow DOM boundaries\n//       });\n//       this.dispatchEvent(event);\n//     });\n//   }\n// }\n// customElements.define('my-custom-slider', MyCustomSlider);\n\nfunction SliderControl() {\n  const sliderRef = useRef<any>(null); // Ref to the Web Component DOM element\n  const [sliderValue, setSliderValue] = useState(0);\n\n  useEffect(() => {\n    const currentSlider = sliderRef.current;\n\n    if (currentSlider) {\n      const handleValueChange = (event: Event) => {\n        // Type assertion for CustomEvent to access detail\n        const customEvent = event as CustomEvent;\n        console.log('Web Component value changed:', customEvent.detail.value);\n        setSliderValue(parseInt(customEvent.detail.value, 10));\n      };\n\n      // Attach the native DOM event listener\n      currentSlider.addEventListener('slider-value-changed', handleValueChange);\n\n      // Cleanup function to remove the event listener\n      return () => {\n        currentSlider.removeEventListener('slider-value-changed', handleValueChange);\n      };\n    }\n  }, []); // Empty dependency array means this effect runs once on mount\n\n  return (\n    <div>\n      <h2>Web Component Slider Example</h2>\n      <my-custom-slider ref={sliderRef} initial-value=\"50\"></my-custom-slider>\n      <p>Current Slider Value (React State): {sliderValue}</p>\n    </div>\n  );\n}\n```\nThis example uses `useRef` to get a direct reference to the `<my-custom-slider>` DOM element. A `useEffect` hook then attaches an `addEventListener` to this native element for the `slider-value-changed` custom event. The `handleValueChange` function extracts the value from `event.detail.value` and updates the React component's `sliderValue` state. The cleanup function ensures the event listener is removed when the component unmounts.",
          "tags": [
            "Web Components",
            "React",
            "Event Handling",
            "useRef",
            "useEffect",
            "Custom Events",
            "Open-Ended"
          ],
          "prerequisites": [
            "react_hooks",
            "dom_events",
            "web_components_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_javascript_build_tools_npm_1",
          "topic": "JavaScript Build Tools and Workflow: NPM",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary role of `package.json` in a Node.js/JavaScript project?",
          "answer": "It serves as the manifest for the project, storing metadata, defining scripts, and listing all project dependencies and devDependencies.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "package.json",
            "NPM",
            "Project Metadata",
            "Dependencies"
          ],
          "evaluationCriteria": [],
          "example": null,
          "tags": [
            "NPM",
            "package.json",
            "Flashcard",
            "Build Tools"
          ],
          "prerequisites": [
            "node_js_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_javascript_build_tools_npm_2",
          "topic": "JavaScript Build Tools and Workflow: NPM",
          "level": "medium",
          "type": "mcq",
          "question": "You've cloned a new frontend project from a Git repository. Which NPM command would you typically run first to get the project set up and ready for development?",
          "answer": "`npm install`",
          "options": [
            "`npm init`",
            "`npm start`",
            "`npm install`",
            "`npm update`"
          ],
          "analysisPoints": [
            "`npm install` reads the `package.json` and `package-lock.json` files and installs all listed dependencies into the `node_modules` directory.",
            "`npm init` initializes a *new* project, which is not what you do when cloning an existing one.",
            "`npm start` runs a script, but dependencies must be installed first.",
            "`npm update` updates *existing* packages, which implies they are already installed."
          ],
          "keyConcepts": [
            "NPM Commands",
            "Project Setup",
            "Dependencies",
            "package.json"
          ],
          "evaluationCriteria": [
            "Understanding of common NPM workflow for project setup.",
            "Knowledge of `npm install`'s purpose."
          ],
          "example": "When you clone a repository, the `node_modules` folder (where packages are stored) is usually not committed to Git. The `package.json` file, however, *is* committed, containing a list of all required packages. Running `npm install` (without any package name) tells NPM to read `package.json` and `package-lock.json` and download/install all those specified dependencies, making the project's code runnable.",
          "tags": [
            "NPM",
            "CLI",
            "Project Workflow",
            "MCQ"
          ],
          "prerequisites": [
            "command_line_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_javascript_build_tools_npm_3",
          "topic": "JavaScript Build Tools and Workflow: NPM",
          "level": "medium",
          "type": "open",
          "question": "What is the purpose of `package-lock.json` and why is it important in a team development environment?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Purpose: `package-lock.json` records the *exact* versions of every installed package, including transitive dependencies, along with their checksums and sources.",
            "Importance in team environment: It ensures that every developer (and CI/CD pipeline) installing the project's dependencies will get the *identical* dependency tree. This guarantees consistent builds and prevents 'it works on my machine' issues caused by subtle differences in dependency versions that might occur if only `package.json` (with its semantic version ranges) were used."
          ],
          "keyConcepts": [
            "package-lock.json",
            "package.json",
            "Dependency Management",
            "Reproducible Builds",
            "Semantic Versioning",
            "Team Collaboration"
          ],
          "evaluationCriteria": [
            "Clear distinction between `package.json` and `package-lock.json`.",
            "Understanding of the problem `package-lock.json` solves (version drift, inconsistent environments).",
            "Ability to explain its role in collaborative development."
          ],
          "example": "Imagine `package.json` specifies `\"react\": \"^18.0.0\"`. This means any React version from 18.0.0 up to (but not including) 19.0.0 is acceptable. If a new `18.2.0` is released, one developer might install `18.0.0` while another installs `18.2.0`, potentially leading to different behavior. `package-lock.json` pins the exact version (e.g., `18.0.0` or `18.2.0`) along with all its sub-dependencies, ensuring that `npm install` always yields the exact same dependency graph, regardless of when it's run.",
          "tags": [
            "NPM",
            "package-lock.json",
            "Dependencies",
            "Collaboration",
            "Open-Ended"
          ],
          "prerequisites": [
            "semantic_versioning",
            "package_json"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_react_memoization_1",
          "title": "Build a Performance-Optimized Product List",
          "description": "\nImplement a React application that displays a list of products. The application should include:\n\n1.  A `ProductList` component that receives an array of products.\n2.  A `ProductCard` component for each product, displaying its name, price, and a button to add it to a cart.\n3.  A `ShoppingCart` component that displays the total number of items in the cart.\n4.  A 'Refresh Products' button in the `App` component that randomly updates a property (e.g., `lastUpdated` timestamp) on some products, simulating data changes that don't always affect core product display info (name, price).\n\n**Optimization Requirements:**\n*   `ProductCard` should only re-render if its `product`'s `id`, `name`, or `price` changes, or if the `onAddToCart` callback changes. It should NOT re-render if only the `lastUpdated` timestamp on the product object changes or if other products in the list change.\n*   The `onAddToCart` callback passed to `ProductCard` must be memoized to prevent unnecessary re-renders of `ProductCard` when the parent component re-renders (e.g., due to `ShoppingCart` updates).\n*   The `ShoppingCart` component should only re-render if the `totalItems` count changes.\n\nYour solution should use `React.memo` and `useCallback` effectively to meet these performance goals. Include console logs in `ProductCard` and `ShoppingCart` to demonstrate when they re-render.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  lastUpdated: number; // This property can change often\n}\n\ninterface ProductCardProps {\n  product: Product;\n  onAddToCart: (productId: number) => void;\n}\n\n// TODO: Optimize ProductCard\nfunction ProductCard({ product, onAddToCart }: ProductCardProps) {\n  console.log(`Rendering ProductCard: ${product.name}`);\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '10px', width: '200px' }}>\n      <h3>{product.name}</h3>\n      <p>Price: ${product.price.toFixed(2)}</p>\n      <button onClick={() => onAddToCart(product.id)}>Add to Cart</button>\n    </div>\n  );\n}\n\ninterface ProductListProps {\n  products: Product[];\n  onAddToCart: (productId: number) => void;\n}\n\nfunction ProductList({ products, onAddToCart }: ProductListProps) {\n  return (\n    <div style={{ display: 'flex', flexWrap: 'wrap' }}>\n      {products.map(product => (\n        <ProductCard key={product.id} product={product} onAddToCart={onAddToCart} />\n      ))}\n    </div>\n  );\n}\n\ninterface ShoppingCartProps {\n  totalItems: number;\n}\n\n// TODO: Optimize ShoppingCart\nfunction ShoppingCart({ totalItems }: ShoppingCartProps) {\n  console.log('Rendering ShoppingCart');\n  return (\n    <div style={{ border: '1px solid green', padding: '10px', margin: '10px' }}>\n      <h2>Shopping Cart</h2>\n      <p>Total Items: {totalItems}</p>\n    </div>\n  );\n}\n\nexport default function App() {\n  const [products, setProducts] = useState<Product[]>([\n    { id: 1, name: 'Laptop', price: 1200, lastUpdated: Date.now() },\n    { id: 2, name: 'Mouse', price: 25, lastUpdated: Date.now() },\n    { id: 3, name: 'Keyboard', price: 75, lastUpdated: Date.now() },\n  ]);\n  const [cartItems, setCartItems] = useState<number>(0);\n\n  const handleAddToCart = (productId: number) => {\n    setCartItems(prev => prev + 1);\n    console.log(`Added product ${productId} to cart.`);\n  };\n\n  const refreshProducts = () => {\n    // Simulate updating some products (e.g., a timestamp)\n    setProducts(prevProducts => prevProducts.map(p => \n      p.id === 1 ? { ...p, lastUpdated: Date.now() } : p\n    ));\n  };\n\n  return (\n    <div>\n      <h1>Our Store</h1>\n      <button onClick={refreshProducts}>Refresh Products</button>\n      <ShoppingCart totalItems={cartItems} />\n      <ProductList products={products} onAddToCart={handleAddToCart} />\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState, useCallback } from 'react';\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  lastUpdated: number; // This property can change often\n}\n\ninterface ProductCardProps {\n  product: Product;\n  onAddToCart: (productId: number) => void;\n}\n\n// Optimized ProductCard with custom comparison\nconst ProductCard = React.memo(function ProductCard({ product, onAddToCart }: ProductCardProps) {\n  console.log(`Rendering ProductCard: ${product.name}`);\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '10px', width: '200px' }}>\n      <h3>{product.name}</h3>\n      <p>Price: ${product.price.toFixed(2)}</p>\n      <button onClick={() => onAddToCart(product.id)}>Add to Cart</button>\n    </div>\n  );\n}, (prevProps, nextProps) => {\n  // Only re-render if id, name, price, or onAddToCart reference changes\n  return (\n    prevProps.product.id === nextProps.product.id &&\n    prevProps.product.name === nextProps.product.name &&\n    prevProps.product.price === nextProps.product.price &&\n    prevProps.onAddToCart === nextProps.onAddToCart\n  );\n});\n\ninterface ProductListProps {\n  products: Product[];\n  onAddToCart: (productId: number) => void;\n}\n\nfunction ProductList({ products, onAddToCart }: ProductListProps) {\n  return (\n    <div style={{ display: 'flex', flexWrap: 'wrap' }}>\n      {products.map(product => (\n        <ProductCard key={product.id} product={product} onAddToCart={onAddToCart} />\n      ))}\n    </div>\n  );\n}\n\ninterface ShoppingCartProps {\n  totalItems: number;\n}\n\n// Optimized ShoppingCart with React.memo (default shallow comparison is fine here)\nconst ShoppingCart = React.memo(function ShoppingCart({ totalItems }: ShoppingCartProps) {\n  console.log('Rendering ShoppingCart');\n  return (\n    <div style={{ border: '1px solid green', padding: '10px', margin: '10px' }}>\n      <h2>Shopping Cart</h2>\n      <p>Total Items: {totalItems}</p>\n    </div>\n  );\n});\n\nexport default function App() {\n  const [products, setProducts] = useState<Product[]>([\n    { id: 1, name: 'Laptop', price: 1200, lastUpdated: Date.now() },\n    { id: 2, name: 'Mouse', price: 25, lastUpdated: Date.now() },\n    { id: 3, name: 'Keyboard', price: 75, lastUpdated: Date.now() },\n  ]);\n  const [cartItems, setCartItems] = useState<number>(0);\n\n  // Memoize handleAddToCart using useCallback\n  const handleAddToCart = useCallback((productId: number) => {\n    setCartItems(prev => prev + 1);\n    console.log(`Added product ${productId} to cart.`);\n  }, []); // Empty dependency array as setCartItems is guaranteed stable by React\n\n  const refreshProducts = () => {\n    // Simulate updating some products (e.g., a timestamp)\n    setProducts(prevProducts => prevProducts.map(p => \n      p.id === 1 ? { ...p, lastUpdated: Date.now() } : p\n    ));\n  };\n\n  return (\n    <div>\n      <h1>Our Store</h1>\n      <button onClick={refreshProducts}>Refresh Products</button>\n      <ShoppingCart totalItems={cartItems} />\n      <ProductList products={products} onAddToCart={handleAddToCart} />\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: All components (App, ShoppingCart, ProductList, all ProductCards) should render once.",
            "Click 'Add to Cart' on any product: `handleAddToCart` should execute. `App` and `ShoppingCart` should re-render. `ProductCard` components should NOT re-render (because `onAddToCart` is memoized and their `product` props haven't changed the relevant fields).",
            "Click 'Refresh Products': `App` should re-render. The `ProductCard` for the updated product (ID 1) should NOT re-render because its `name` and `price` (and `onAddToCart`) didn't change, only `lastUpdated` which is ignored by the custom comparison. Other `ProductCard`s should also not re-render.",
            "Add a new product to the list (manual test): Only the new `ProductCard` should render. Existing ones should not re-render.",
            "Change price of a product (manual test): Only the `ProductCard` for that specific product should re-render."
          ],
          "hints": [
            "Remember that `React.memo` performs a shallow comparison by default. For objects/arrays, this means comparing references. If an object property changes but the object reference doesn't, or vice-versa, you might need a custom comparison.",
            "Callbacks passed down to memoized children should often be wrapped in `useCallback` to maintain referential equality.",
            "Think about what specific props need to be checked for `ProductCard`'s re-render condition.",
            "The `setCartItems` function provided by `useState` is stable across re-renders, so `useCallback`'s dependency array for `handleAddToCart` can be empty."
          ],
          "tags": [
            "React",
            "Performance",
            "Optimization",
            "useCallback",
            "React.memo",
            "Front-end Architecture"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_functional_components",
            "react_hooks",
            "react_state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "memoization",
            "referential_equality",
            "shallow_comparison",
            "component_re_rendering"
          ]
        },
        {
          "id": "task_virtual_dom_keys_1",
          "title": "Implement a Dynamic Todo List with Proper Keys and Input State",
          "description": "\nCreate a React component for a dynamic todo list. The list should support:\n\n1.  Adding new todos at the top of the list.\n2.  Marking todos as completed (toggling a checkbox).\n3.  Each todo item should have an associated `<input type=\"text\" />` field to add notes.\n\n**Requirements:**\n*   Ensure that when new todos are added to the list, the existing todo items (especially their associated input fields) do not lose their current input values or focus. This implies correct usage of `key` props.\n*   Each todo item must have a unique and stable identifier. If your mock data doesn't provide it, generate one upon creation.\n*   Demonstrate the issue of using array `index` as a key and then provide the correct solution.\n\nYour solution should clearly show the importance of correct key usage in maintaining component state within dynamic lists.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\ninterface Todo {\n  id: string; // Or number\n  text: string;\n  completed: boolean;\n}\n\nfunction BadTodoItem({ todo, onToggleComplete }: { todo: Todo; onToggleComplete: (id: string) => void }) {\n  console.log(`Rendering TodoItem (Bad Keys): ${todo.text}`);\n  return (\n    <li style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n      <input\n        type=\"checkbox\"\n        checked={todo.completed}\n        onChange={() => onToggleComplete(todo.id)}\n      />\n      {todo.text}\n      <input type=\"text\" placeholder=\"Add notes here\" style={{ marginLeft: '10px' }} />\n    </li>\n  );\n}\n\nexport default function App() {\n  const [todos, setTodos] = useState<Todo[]>([\n    { id: '1', text: 'Learn React Hooks', completed: false },\n    { id: '2', text: 'Master TypeScript', completed: false },\n    { id: '3', text: 'Build a Portfolio', completed: false },\n  ]);\n  const [newTodoText, setNewTodoText] = useState('');\n\n  const handleAddTodo = () => {\n    if (newTodoText.trim() === '') return;\n    const newTodo: Todo = {\n      id: String(Date.now()), // Simple ID generation for now\n      text: newTodoText,\n      completed: false,\n    };\n    setTodos([newTodo, ...todos]); // Add to the beginning\n    setNewTodoText('');\n  };\n\n  const handleToggleComplete = (id: string) => {\n    setTodos(prevTodos =>\n      prevTodos.map(todo =>\n        todo.id === id ? { ...todo, completed: !todo.completed } : todo\n      )\n    );\n  };\n\n  return (\n    <div>\n      <h1>My Todo List (Bad Keys)</h1>\n      <div>\n        <input\n          type=\"text\"\n          value={newTodoText}\n          onChange={(e) => setNewTodoText(e.target.value)}\n          placeholder=\"New todo...\"\n        />\n        <button onClick={handleAddTodo}>Add Todo</button>\n      </div>\n      <ul>\n        {/* TODO: This uses index as key - observe the problem */}\n        {todos.map((todo, index) => (\n          <BadTodoItem key={index} todo={todo} onToggleComplete={handleToggleComplete} />\n        ))}\n      </ul>\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState } from 'react';\n\ninterface Todo {\n  id: string;\n  text: string;\n  completed: boolean;\n}\n\n// Correctly implemented TodoItem (no change needed in its internal logic)\nfunction GoodTodoItem({ todo, onToggleComplete }: { todo: Todo; onToggleComplete: (id: string) => void }) {\n  console.log(`Rendering TodoItem (Good Keys): ${todo.text}`);\n  return (\n    <li style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n      <input\n        type=\"checkbox\"\n        checked={todo.completed}\n        onChange={() => onToggleComplete(todo.id)}\n      />\n      {todo.text}\n      <input type=\"text\" placeholder=\"Add notes here\" style={{ marginLeft: '10px' }} />\n    </li>\n  );\n}\n\nexport default function App() {\n  const [todos, setTodos] = useState<Todo[]>([\n    { id: '1', text: 'Learn React Hooks', completed: false },\n    { id: '2', text: 'Master TypeScript', completed: false },\n    { id: '3', text: 'Build a Portfolio', completed: false },\n  ]);\n  const [newTodoText, setNewTodoText] = useState('');\n\n  const handleAddTodo = () => {\n    if (newTodoText.trim() === '') return;\n    const newTodo: Todo = {\n      id: String(Date.now()), // Generating a unique, stable ID\n      text: newTodoText,\n      completed: false,\n    };\n    setTodos([newTodo, ...todos]); // Add to the beginning\n    setNewTodoText('');\n  };\n\n  const handleToggleComplete = (id: string) => {\n    setTodos(prevTodos =>\n      prevTodos.map(todo =>\n        todo.id === id ? { ...todo, completed: !todo.completed } : todo\n      )\n    );\n  };\n\n  return (\n    <div>\n      <h1>My Todo List (Good Keys)</h1>\n      <div>\n        <input\n          type=\"text\"\n          value={newTodoText}\n          onChange={(e) => setNewTodoText(e.target.value)}\n          placeholder=\"New todo...\"\n        />\n        <button onClick={handleAddTodo}>Add Todo</button>\n      </div>\n      <ul>\n        {/* SOLUTION: Use todo.id as key */}\n        {todos.map(todo => (\n          <GoodTodoItem key={todo.id} todo={todo} onToggleComplete={handleToggleComplete} />\n        ))}\n      </ul>\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: All three todos should display.",
            "Type notes into the input fields of existing todos.",
            "Add a new todo item: Enter text in the 'New todo...' input and click 'Add Todo'. Observe that the new todo appears at the top. Critically, observe that the notes you typed into the input fields of the *original* todos are preserved.",
            "Toggle completion of a todo: The checkbox should update, and the strikethrough should apply/remove without affecting input field values."
          ],
          "hints": [
            "The problem occurs when an item's position in the array changes, but its `key` (index) remains the same as another item's previous key.",
            "React uses keys to identify unique components in a list. If the key is not stable, React cannot correctly track components and their internal state.",
            "A robust `id` for each todo item is crucial. `Date.now()` is a simple way to generate unique IDs for demo purposes, but in a real application, you might use a UUID library or a backend-generated ID."
          ],
          "tags": [
            "React",
            "Keys",
            "Virtual DOM",
            "List Rendering",
            "State Management",
            "Performance"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_lists",
            "react_state"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "reconciliation",
            "component_lifecycle",
            "forms_in_react"
          ]
        },
        {
          "id": "task_web_components_in_react_1",
          "title": "Integrate a Custom Web Component with React for Form Input",
          "description": "\nCreate a React application that integrates a custom Web Component serving as an enhanced text input. The Web Component should:\n\n1.  Be defined as `<my-text-input>`.\n2.  Have an internal `<input type=\"text\">` element.\n3.  Accept a `label` attribute/prop for its label text.\n4.  Dispatch a custom event `input-changed` when its internal input's value changes, with the new value in `event.detail.value`.\n\nYour React application should:\n*   Render an instance of `<my-text-input>`.\n*   Display its value in a React component's state.\n*   Demonstrate how to pass the `label` prop to the Web Component.\n*   Correctly handle the `input-changed` custom event to update the React component's state.\n*   Ensure proper cleanup of event listeners when the React component unmounts.\n\nUse TypeScript for both the Web Component (if defining it in TS) and the React application.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useRef, useEffect } from 'react';\n\n// --- Web Component Definition (for demonstration, assume it's globally available or imported)\n// You can define this in a separate file like 'my-text-input.ts' and import it.\n// For simplicity, we define it here, but typically you'd import it as `import './my-text-input';`\nclass MyTextInput extends HTMLElement {\n  private inputElement: HTMLInputElement;\n  private labelElement: HTMLLabelElement;\n\n  constructor() {\n    super();\n    const shadowRoot = this.attachShadow({ mode: 'open' });\n\n    const wrapper = document.createElement('div');\n    wrapper.style.padding = '10px';\n    wrapper.style.border = '1px solid #ddd';\n    wrapper.style.borderRadius = '5px';\n\n    this.labelElement = document.createElement('label');\n    this.labelElement.style.marginRight = '5px';\n    this.labelElement.style.fontWeight = 'bold';\n\n    this.inputElement = document.createElement('input');\n    this.inputElement.type = 'text';\n    this.inputElement.style.padding = '8px';\n    this.inputElement.style.border = '1px solid #ccc';\n    this.inputElement.style.borderRadius = '3px';\n\n    this.inputElement.addEventListener('input', (e) => {\n      const event = new CustomEvent('input-changed', {\n        detail: { value: (e.target as HTMLInputElement).value },\n        bubbles: true, // Allow event to bubble up through shadow DOM boundary\n        composed: true // Allow event to cross shadow DOM boundary\n      });\n      this.dispatchEvent(event);\n    });\n\n    wrapper.appendChild(this.labelElement);\n    wrapper.appendChild(this.inputElement);\n    shadowRoot.appendChild(wrapper);\n  }\n\n  // Observe changes to the 'label' attribute\n  static get observedAttributes() {\n    return ['label'];\n  }\n\n  attributeChangedCallback(name: string, oldValue: string | null, newValue: string | null) {\n    if (name === 'label') {\n      this.labelElement.textContent = newValue ? newValue + ':' : '';\n    }\n  }\n\n  // Method to set value programmatically if needed (optional for this task)\n  // set value(val: string) {\n  //   this.inputElement.value = val;\n  // }\n  // get value(): string {\n  //   return this.inputElement.value;\n  // }\n}\n\n// Register the custom element if it hasn't been already\nif (!customElements.get('my-text-input')) {\n  customElements.define('my-text-input', MyTextInput);\n}\n\n// --- React Component\nexport default function App() {\n  const [inputValue, setInputValue] = useState('');\n  const inputRef = useRef<HTMLElement>(null); // Ref to hold the Web Component element\n\n  // TODO: Implement useEffect to handle Web Component's custom event\n\n  return (\n    <div>\n      <h1>Web Component Integration</h1>\n      <p>Value from Web Component: <strong>{inputValue}</strong></p>\n\n      {/* TODO: Use the Web Component and pass props/ref */}\n      <my-text-input label=\"Your Name\"></my-text-input>\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState, useRef, useEffect } from 'react';\n\n// --- Web Component Definition (for demonstration, assume it's globally available or imported)\nclass MyTextInput extends HTMLElement {\n  private inputElement: HTMLInputElement;\n  private labelElement: HTMLLabelElement;\n\n  constructor() {\n    super();\n    const shadowRoot = this.attachShadow({ mode: 'open' });\n\n    const wrapper = document.createElement('div');\n    wrapper.style.padding = '10px';\n    wrapper.style.border = '1px solid #ddd';\n    wrapper.style.borderRadius = '5px';\n\n    this.labelElement = document.createElement('label');\n    this.labelElement.style.marginRight = '5px';\n    this.labelElement.style.fontWeight = 'bold';\n\n    this.inputElement = document.createElement('input');\n    this.inputElement.type = 'text';\n    this.inputElement.style.padding = '8px';\n    this.inputElement.style.border = '1px solid #ccc';\n    this.inputElement.style.borderRadius = '3px';\n\n    this.inputElement.addEventListener('input', (e) => {\n      const event = new CustomEvent('input-changed', {\n        detail: { value: (e.target as HTMLInputElement).value },\n        bubbles: true,\n        composed: true\n      });\n      this.dispatchEvent(event);\n    });\n\n    wrapper.appendChild(this.labelElement);\n    wrapper.appendChild(this.inputElement);\n    shadowRoot.appendChild(wrapper);\n  }\n\n  static get observedAttributes() {\n    return ['label'];\n  }\n\n  attributeChangedCallback(name: string, oldValue: string | null, newValue: string | null) {\n    if (name === 'label') {\n      this.labelElement.textContent = newValue ? newValue + ':' : '';\n    }\n  }\n}\n\nif (!customElements.get('my-text-input')) {\n  customElements.define('my-text-input', MyTextInput);\n}\n\n// --- React Component\nexport default function App() {\n  const [inputValue, setInputValue] = useState('');\n  const inputRef = useRef<HTMLElement>(null); // Ref to hold the Web Component element\n\n  useEffect(() => {\n    const currentInput = inputRef.current;\n\n    const handleInputChange = (event: Event) => {\n      const customEvent = event as CustomEvent;\n      setInputValue(customEvent.detail.value);\n    };\n\n    if (currentInput) {\n      // Attach the native DOM event listener to the Web Component\n      currentInput.addEventListener('input-changed', handleInputChange);\n    }\n\n    // Cleanup function to remove the event listener when component unmounts\n    return () => {\n      if (currentInput) {\n        currentInput.removeEventListener('input-changed', handleInputChange);\n      }\n    };\n  }, []); // Empty dependency array means this effect runs once on mount and cleans up on unmount\n\n  return (\n    <div>\n      <h1>Web Component Integration</h1>\n      <p>Value from Web Component: <strong>{inputValue}</strong></p>\n\n      {/* Use the Web Component and pass the ref */}\n      <my-text-input label=\"Your Name\" ref={inputRef}></my-text-input>\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: The `my-text-input` Web Component should appear with the label 'Your Name:'. The 'Value from Web Component' text should be empty.",
            "Type text into the Web Component's input field: As you type, the 'Value from Web Component' text should update in real-time, reflecting the Web Component's internal value.",
            "Unmount the component (e.g., by navigating away or conditionally rendering it off): Verify that no memory leaks occur from unremoved event listeners (difficult to test directly, but code structure ensures it)."
          ],
          "hints": [
            "Remember that React's synthetic event system doesn't automatically listen for custom DOM events originating from inside a Shadow DOM.",
            "You'll need `useRef` to get a direct reference to the `my-text-input` DOM element.",
            "The `useEffect` hook is the place to attach and clean up manual DOM event listeners.",
            "Pay attention to the `detail` property of the `CustomEvent` to get the value.",
            "Ensure `bubbles: true` and `composed: true` are set when dispatching custom events from the Web Component if you want them to cross Shadow DOM boundaries and bubble up."
          ],
          "tags": [
            "React",
            "Web Components",
            "Interoperability",
            "Hooks",
            "useRef",
            "useEffect",
            "Event Handling",
            "Custom Elements"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "react_functional_components",
            "react_hooks",
            "web_components_basics",
            "dom_events"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "relatedConcepts": [
            "shadow_dom",
            "custom_events",
            "forms_in_react"
          ]
        },
        {
          "id": "task_javascript_build_tools_npm_1",
          "title": "Manage a Small Frontend Project with NPM",
          "description": "\nSet up and manage a small, hypothetical frontend project using NPM. You don't need to write a full React application, but demonstrate core NPM functionalities.\n\n**Requirements:**\n1.  **Initialize a project**: Create a new project directory and initialize it with `npm init` (accepting defaults where appropriate).\n2.  **Install dependencies**: Install two common frontend libraries:\n    *   `axios` (for making HTTP requests) as a regular dependency.\n    *   `webpack` and `webpack-cli` as development dependencies.\n3.  **Inspect `package.json` and `package-lock.json`**: Describe what you observe in these files after installation.\n4.  **Create a custom script**: Add a custom `start` script to `package.json` that simply echoes a message like 'Starting my amazing frontend project!' or runs a simple `echo` command.\n5.  **Run the custom script**: Execute your newly created `start` script using NPM.\n6.  **Simulate re-installation**: Delete `node_modules` and `package-lock.json` (if it was generated), then demonstrate how to re-install everything to the *exact same versions* using only `package.json` (and `package-lock.json` once it's regenerated).\n7.  **Bonus**: Try to install a non-existent package and observe the error message.\n",
          "difficulty": "easy",
          "startingCode": "/*\nNo starting code required. This task involves command-line interactions and observing file changes.\n\nFollow these steps in your terminal:\n\n1.  Create a new directory: `mkdir my-npm-project && cd my-npm-project`\n2.  Initialize the project: `npm init -y`\n3.  Open `package.json` and observe its initial content.\n4.  Install dependencies:\n    *   `npm install axios`\n    *   `npm install webpack webpack-cli --save-dev`\n5.  Observe changes in `package.json` and the creation of `package-lock.json` and `node_modules`.\n6.  Add a custom script to `package.json` under the `scripts` section:\n    ```json\n    \"scripts\": {\n      \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n      \"start\": \"echo \\\"Starting my amazing frontend project!\\\"\"\n    }\n    ```\n7.  Run the script: `npm run start`\n8.  Clean up for re-installation demo: `rm -rf node_modules package-lock.json` (or `rd /s /q node_modules package-lock.json` on Windows).\n9.  Re-install: `npm install`\n10. (Bonus) Try installing a non-existent package: `npm install non-existent-package-12345`\n*/\n",
          "solutionCode": "/*\nThis task is primarily command-line based. The 'solution' is the series of commands and observations.\n\n1.  **Initialize a project**\n    ```bash\n    mkdir my-npm-project\n    cd my-npm-project\n    npm init -y\n    # Output: package.json created\n    ```\n\n2.  **Install dependencies**\n    ```bash\n    npm install axios\n    npm install webpack webpack-cli --save-dev\n    # Output: Packages installed, added to package.json and package-lock.json, node_modules created.\n    ```\n\n3.  **Inspect `package.json` and `package-lock.json`**\n    *   **`package.json` observation**: `dependencies` section will now list `\"axios\": \"^X.Y.Z\"`. `devDependencies` section will list `\"webpack\": \"^X.Y.Z\"` and `\"webpack-cli\": \"^X.Y.Z\"`. Script section is still default.\n    *   **`package-lock.json` observation**: This file will be much larger. It precisely lists `axios`, `webpack`, `webpack-cli`, and all *their* transitive dependencies with exact versions, integrity hashes, and resolved URLs.\n\n4.  **Create a custom script**\n    Modify `package.json` manually:\n    ```json\n    {\n      \"name\": \"my-npm-project\",\n      \"version\": \"1.0.0\",\n      \"description\": \"\",\n      \"main\": \"index.js\",\n      \"scripts\": {\n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n        \"start\": \"echo \\\"Starting my amazing frontend project!\\\"\"\n      },\n      \"keywords\": [],\n      \"author\": \"\",\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"axios\": \"^1.6.8\"\n      },\n      \"devDependencies\": {\n        \"webpack\": \"^5.90.3\",\n        \"webpack-cli\": \"^5.1.4\"\n      }\n    }\n    ```\n\n5.  **Run the custom script**\n    ```bash\n    npm run start\n    # Output: Starting my amazing frontend project!\n    ```\n\n6.  **Simulate re-installation**\n    ```bash\n    rm -rf node_modules package-lock.json # On Windows: rmdir /s /q node_modules && del package-lock.json\n    npm install\n    # Output: All dependencies re-installed based on package.json (and new package-lock.json regenerated).\n    # The key observation is that after this, `node_modules` is populated with the *same exact versions* as before due to package-lock.json's influence.\n    ```\n\n7.  **Bonus: Install non-existent package**\n    ```bash\n    npm install non-existent-package-12345\n    # Output: Error message indicating package not found in registry (e.g., 'npm ERR! 404 Not Found - GET .../non-existent-package-12345')\n    ```\n*/\n",
          "testCases": [
            "Directory 'my-npm-project' should be created.",
            "`package.json` should exist after `npm init -y` with basic metadata.",
            "`node_modules` directory and `package-lock.json` should be created after `npm install` commands.",
            "`package.json` should correctly list `axios` under `dependencies` and `webpack`, `webpack-cli` under `devDependencies` with semantic version ranges.",
            "`package-lock.json` should contain exact versions and integrity hashes for all installed packages (including transitive dependencies of axios and webpack).",
            "Running `npm run start` should output the custom message.",
            "After deleting `node_modules` and `package-lock.json`, running `npm install` again should successfully re-create them with the *same* exact dependency versions as before (verify by checking `package-lock.json` or module versions within `node_modules`).",
            "Attempting to install a non-existent package should result in a clear error message from NPM."
          ],
          "hints": [
            "Pay attention to the output of each NPM command.",
            "Use a text editor to view the contents of `package.json` and `package-lock.json` before and after installation steps.",
            "Remember the difference between `dependencies` and `devDependencies` and how they are typically specified during `npm install`.",
            "The `-y` flag for `npm init` bypasses interactive questions."
          ],
          "tags": [
            "NPM",
            "CLI",
            "Package Management",
            "Build Tools",
            "Project Setup",
            "Workflow"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "command_line_basics",
            "node_js_installation"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "beginner",
          "relatedConcepts": [
            "semantic_versioning",
            "node_modules",
            "dependency_graph"
          ]
        }
      ]
    }
  },
  {
    "id": "d365ecc1-1663-4b97-859c-422b59bd7dbe",
    "startLine": 12700,
    "endLine": 12799,
    "processedDate": "2025-06-17T13:05:26.701Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_npm_basics",
          "title": "NPM Basics: Project Initialization, Dependency Management, and Script Execution",
          "content": "NPM (Node Package Manager) is the default package manager for Node.js. It allows developers to share and reuse code, manage project dependencies, and automate various development tasks via scripts defined in `package.json`.\n\n## Key Concepts\n\n### Project Initialization (`npm init`)\n`npm init` is used to create a new `package.json` file in your project directory. This file is a manifest for your project, containing metadata such as the project's name, version, description, entry point, test commands, and most importantly, dependencies.\n\nRunning `npm init` interactively prompts you to enter various details about your project, creating a `package.json` based on your input. You can also use `npm init -y` or `npm init --yes` to quickly generate a default `package.json` without prompts.\n\n### Installing Dependencies (`npm install`)\n`npm install <package-name>` adds a specified package to your project's `node_modules` directory and updates the `dependencies` section in your `package.json` file. These dependencies are typically required for your application to run in production.\n\n`npm install <package-name> --save-dev` (or `-D`) adds a package as a development dependency. These packages are only needed during the development process (e.g., testing frameworks, build tools, linters) and are not required for the application to run in production. They are listed under the `devDependencies` section in `package.json`.\n\nRunning `npm install` without any package name in a directory containing a `package.json` file will install all dependencies (both `dependencies` and `devDependencies`) listed in that file.\n\n### Running Scripts (`npm run`)\n`npm run <script-name>` executes custom scripts defined in the `scripts` section of your `package.json` file. This is a powerful feature for automating common tasks like starting a development server, compiling code, running tests, or building production assets.\n\nFor example, if you have a `\"start\": \"node server.js\"` script defined, running `npm run start` will execute `node server.js`. Some common scripts like `start`, `test`, `build`, `dev` can often be run without `run`, e.g., `npm start`.\n\n### `node_modules` Directory\nWhen you install packages, NPM places them in a `node_modules` directory at the root of your project. This directory typically contains all installed packages and their respective dependencies. It is usually excluded from version control (e.g., using `.gitignore`) because it can become very large, and its contents can be recreated by running `npm install` based on `package.json` and `package-lock.json`.\n\n### `package-lock.json`\nThis file is automatically generated by NPM and records the exact versions of all packages installed in `node_modules`, including nested dependencies. Its purpose is to ensure that subsequent installations (e.g., by other developers on the team or in a CI/CD pipeline) use the exact same dependency tree, preventing potential issues caused by dependency version drift.",
          "examples": [
            {
              "id": "example_npm_init",
              "title": "Initializing a Project",
              "code": "npm init -y",
              "explanation": "This command quickly initializes a new Node.js project and creates a `package.json` file with default values, skipping the interactive prompts. It's often used for quick setups or when default values are acceptable."
            },
            {
              "id": "example_npm_install_deps",
              "title": "Installing Dependencies",
              "code": "npm install express\nnpm install webpack --save-dev",
              "explanation": "The first command installs 'express' as a regular dependency (required for runtime). The second command installs 'webpack' as a development dependency (only needed for building, not runtime). Both will be added to `package.json` and `node_modules`."
            },
            {
              "id": "example_npm_run_script",
              "title": "Running a Custom Script",
              "code": "// package.json\n{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"node app.js\",\n    \"build\": \"webpack --config webpack.prod.js\"\n  }\n}\n\n// Command to run:\nnpm run start\nnpm run build",
              "explanation": "This demonstrates how to define and execute custom scripts. `npm run start` will execute `node app.js` and `npm run build` will execute `webpack --config webpack.prod.js`. This centralizes common commands."
            }
          ],
          "relatedQuestions": [
            "question_npm_yarn_compare",
            "question_npm_dev_dependency",
            "question_package_json_purpose",
            "question_npm_init_purpose",
            "question_npm_run_script_purpose",
            "question_node_modules_purpose"
          ],
          "relatedTasks": [
            "task_npm_yarn_project_setup"
          ],
          "tags": [
            "NPM",
            "Package Manager",
            "Node.js",
            "Dependencies",
            "DevOps",
            "Frontend Build Tools"
          ],
          "technology": "Node.js, NPM",
          "prerequisites": [
            "Basic understanding of command line",
            "Node.js environment setup"
          ],
          "complexity": 4,
          "interviewRelevance": 8,
          "learningPath": "beginner",
          "requiredFor": [
            "Any Node.js/Frontend project",
            "Understanding project structure"
          ]
        },
        {
          "id": "theory_yarn_basics",
          "title": "Yarn Basics: An Alternative Package Manager",
          "content": "Yarn is an alternative package manager for Node.js, developed by Facebook (now Meta) in collaboration with Google, Exponent, and Tilde. It was created to address some limitations and concerns of NPM, particularly regarding performance, security, and reproducibility of builds, which were more prominent in NPM's earlier versions.\n\nWhile NPM has significantly improved since Yarn's inception, Yarn still offers compelling features and a slightly different command syntax.\n\n## Key Concepts\n\n### Yarn's Advantages (Historically)\n*   **Performance:** Yarn introduced parallel installations and caching mechanisms that often resulted in faster dependency installations compared to older NPM versions.\n*   **Security:** It uses checksums to verify the integrity of packages before installation, providing a layer of security.\n*   **Reproducibility:** Yarn introduced the `yarn.lock` file (similar to NPM's `package-lock.json`) to ensure that every installation results in the exact same `node_modules` tree across different environments, preventing 'it works on my machine' issues.\n\n### Project Initialization (`yarn init`)\nSimilar to `npm init`, `yarn init` creates a `package.json` file. It also offers interactive prompts or a quick default generation.\n\n### Installing Dependencies (`yarn add`)\n`yarn add <package-name>` installs a package as a regular dependency and adds it to the `dependencies` section of `package.json`. It also updates `yarn.lock`.\n\n`yarn add <package-name> --dev` (or `-D`) installs a package as a development dependency, adding it to the `devDependencies` section. `yarn add` without any package name installs all dependencies listed in `package.json`.\n\n### Running Scripts (`yarn <script-name>`)\nTo run scripts defined in `package.json`, Yarn simplifies the command. Instead of `npm run <script-name>`, you typically use `yarn <script-name>`. For standard scripts like `start`, `test`, `build`, you can just use `yarn start`, `yarn test`, etc.\n\n### `yarn.lock` File\nThis file is Yarn's equivalent of `package-lock.json`. It records the exact versions of all installed packages, ensuring consistent installations across different environments.",
          "examples": [
            {
              "id": "example_yarn_init",
              "title": "Initializing a Project with Yarn",
              "code": "yarn init -y",
              "explanation": "This command quickly initializes a new project with Yarn, generating a `package.json` file with default values. It's parallel to `npm init -y`."
            },
            {
              "id": "example_yarn_add_deps",
              "title": "Installing Dependencies with Yarn",
              "code": "yarn add react\nyarn add typescript --dev",
              "explanation": "The first command installs 'react' as a regular dependency. The second command installs 'typescript' as a development dependency. Both commands update `package.json` and `yarn.lock`."
            },
            {
              "id": "example_yarn_run_script",
              "title": "Running a Custom Script with Yarn",
              "code": "// package.json\n{\n  \"name\": \"my-yarn-app\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"serve\": \"live-server ./dist\",\n    \"lint\": \"eslint .\"\n  }\n}\n\n// Command to run:\nyarn serve\nyarn lint",
              "explanation": "This demonstrates running custom scripts with Yarn. `yarn serve` executes `live-server ./dist` and `yarn lint` executes `eslint .`. Notice the absence of `run` keyword for running scripts compared to `npm run`."
            }
          ],
          "relatedQuestions": [
            "question_npm_yarn_compare",
            "question_yarn_security_feature",
            "question_yarn_vs_npm_speed",
            "question_yarn_lock_purpose"
          ],
          "relatedTasks": [
            "task_npm_yarn_project_setup"
          ],
          "tags": [
            "Yarn",
            "Package Manager",
            "Node.js",
            "Dependencies",
            "Frontend Build Tools"
          ],
          "technology": "Node.js, Yarn",
          "prerequisites": [
            "Basic understanding of command line",
            "Node.js environment setup"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "requiredFor": [
            "Any Node.js/Frontend project",
            "Understanding project alternatives"
          ]
        },
        {
          "id": "theory_gulp_task_runner",
          "title": "Gulp: Automating Frontend Workflow with Task Runner",
          "content": "Gulp is a JavaScript-based task runner that helps automate time-consuming and repetitive tasks in your development workflow. Unlike some other build tools that rely on declarative configuration files, Gulp uses a 'code-over-configuration' approach, where you write JavaScript code to define your build tasks. This makes it highly flexible and extensible.\n\n## Key Concepts\n\n### What Gulp Automates\nGulp is commonly used for tasks such as:\n*   **Compiling Preprocessors:** Converting Sass/Less to CSS, TypeScript/Babel to JavaScript.\n*   **Minification & Concatenation:** Reducing file sizes and combining multiple files for production.\n*   **Linting:** Checking code for errors and stylistic issues.\n*   **Optimizing Assets:** Compressing images, optimizing fonts.\n*   **Live Reloading:** Automatically refreshing the browser on code changes.\n*   **Running Tests:** Automating test execution.\n\n### Code-over-Configuration\nWith Gulp, you define your tasks programmatically in a `gulpfile.js` file. This means you use JavaScript to specify what files to process, what operations to perform on them, and where to output the results. This offers more power and flexibility compared to XML or JSON-based configuration.\n\n### Streams\nGulp leverages Node.js streams. Instead of reading a file from disk, performing an operation, writing it back to disk, then reading it again for the next operation, Gulp passes files through a series of 'pipes' in memory. This 'streaming' approach is highly efficient as it avoids excessive disk I/O, speeding up build processes. Each `pipe()` function typically takes a Gulp plugin that performs a specific transformation on the streamed files.\n\n### Core Gulp API Methods\n*   `gulp.task(name, fn)`: Defines a new task. (Older syntax, `gulp.series` and `gulp.parallel` are preferred for chaining).\n*   `gulp.src(globs)`: Specifies the input files for a task using glob patterns (e.g., `**/*.scss` for all SCSS files in any subdirectory).\n*   `gulp.pipe(plugin())`: Pipes the files through a Gulp plugin, which transforms them.\n*   `gulp.dest(path)`: Specifies the output directory for processed files.\n*   `gulp.watch(globs, tasks)`: Watches files for changes and runs specified tasks when changes are detected.\n*   `gulp.series(...tasks)`: Runs tasks sequentially.\n*   `gulp.parallel(...tasks)`: Runs tasks concurrently.\n\n### `gulpfile.js` Example Breakdown\nThe provided `gulpfile.js` demonstrates:\n1.  **Dependencies:** `gulp`, `gulp-sass`, `gulp-autoprefixer` are required.\n2.  **`sass` Task:**\n    *   `gulp.src('./src/scss/**/*.scss')`: Selects all SCSS files within the `src/scss` directory and its subdirectories.\n    *   `.pipe(sass())`: Compiles SCSS to CSS using `gulp-sass`.\n    *   `.pipe(autoprefixer())`: Adds vendor prefixes to CSS properties using `gulp-autoprefixer`.\n    *   `.pipe(gulp.dest('./dist/css'))`: Saves the resulting CSS files to the `dist/css` directory.\n3.  **`watch` Task:**\n    *   `gulp.watch('./src/scss/**/*.scss', gulp.series('sass'))`: Monitors SCSS files. If any changes are detected, it runs the `sass` task sequentially.\n4.  **`default` Task:**\n    *   `gulp.task('default', gulp.series('sass', 'watch'))`: Defines a default task that runs the `sass` task once, and then starts the `watch` task. This is the task that executes when you simply run `gulp` in the terminal.",
          "examples": [
            {
              "id": "example_gulp_basic_setup",
              "title": "Basic Gulpfile Structure",
              "code": "const gulp = require('gulp');\n\nfunction clean(cb) {\n  // Task to clean build directory\n  console.log('Cleaning build directory...');\n  cb(); // Callback to signal task completion\n}\n\nfunction copyHtml() {\n  return gulp.src('./src/**/*.html')\n    .pipe(gulp.dest('./dist'));\n}\n\nexports.clean = clean;\nexports.copyHtml = copyHtml;\nexports.build = gulp.series(clean, copyHtml);\nexports.default = exports.build;\n",
              "explanation": "This example shows a modern Gulp 4 setup using `exports` for tasks. `clean` is a simple task that uses a callback to signal completion. `copyHtml` copies HTML files from `src` to `dist`. `exports.build` defines a series of tasks (`clean` then `copyHtml`), and `exports.default` makes `build` the default task, run by typing `gulp`."
            },
            {
              "id": "example_gulp_scss_pipeline",
              "title": "SCSS Compilation and Autoprefixing",
              "code": "// gulpfile.js\nconst gulp = require('gulp');\nconst sass = require('gulp-sass')(require('sass')); // Node-sass or dart-sass required\nconst autoprefixer = require('gulp-autoprefixer');\n\nfunction compileSass() {\n  return gulp.src('./src/scss/**/*.scss')\n    .pipe(sass().on('error', sass.logError))\n    .pipe(autoprefixer({\n      overrideBrowserslist: ['last 2 versions'],\n      cascade: false\n    }))\n    .pipe(gulp.dest('./dist/css'));\n}\n\nexports.sass = compileSass;\nexports.watch = function() {\n  gulp.watch('./src/scss/**/*.scss', compileSass);\n};\nexports.default = gulp.series(compileSass, exports.watch);\n",
              "explanation": "This is an enhanced version of the provided Gulpfile example. It explicitly uses `require('sass')` with `gulp-sass` (which prefers Dart Sass). It also adds error logging for Sass and configures `autoprefixer` with `overrideBrowserslist` for better browser compatibility control. This pipeline efficiently compiles, prefixes, and outputs CSS."
            }
          ],
          "relatedQuestions": [
            "question_gulp_purpose",
            "question_gulp_streams",
            "question_gulp_code_over_config",
            "question_gulp_src_dest",
            "question_gulp_watch_explain",
            "question_task_runner_definition"
          ],
          "relatedTasks": [
            "task_extend_gulp_build"
          ],
          "tags": [
            "Gulp",
            "Task Runner",
            "Automation",
            "Frontend Build Tools",
            "Webpack Alternative",
            "Streams",
            "SCSS",
            "CSS"
          ],
          "technology": "Node.js, Gulp",
          "prerequisites": [
            "Basic JavaScript",
            "Node.js environment setup",
            "Command line basics"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced Frontend Development",
            "Build Process Optimization"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_npm_yarn_compare",
          "topic": "NPM vs. Yarn",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast NPM and Yarn as package managers. Discuss their historical context, key features, and primary differences in command usage and underlying philosophy. What are the advantages of one over the other in different scenarios?",
          "answer": "N/A",
          "analysisPoints": [
            "Historical context: Yarn's origin addressing NPM's earlier issues (speed, security, reproducibility).",
            "Performance: Discuss parallel installations, caching (Yarn's initial advantage, NPM's improvements).",
            "Security: Yarn's checksums, NPM's audit features.",
            "Reproducibility: `package-lock.json` vs `yarn.lock`.",
            "Command syntax differences: `npm install` vs `yarn add`, `npm run` vs `yarn`.",
            "Philosophy: NPM being Node.js default, Yarn as an open-source alternative backed by Facebook.",
            "Current state: Both are highly capable; choice often depends on team preference or existing project setup."
          ],
          "keyConcepts": [
            "NPM",
            "Yarn",
            "Package Manager",
            "Dependencies",
            "package.json",
            "package-lock.json",
            "yarn.lock"
          ],
          "evaluationCriteria": [
            "Depth of historical understanding.",
            "Accuracy of technical comparison (performance, security, reproducibility).",
            "Correctness of command syntax differences.",
            "Ability to articulate nuanced advantages/disadvantages.",
            "Structured and clear explanation."
          ],
          "example": "A good answer would cover how Yarn emerged due to NPM's early performance and security gaps, introducing features like parallel installs and checksum verification. It would contrast `npm install <pkg>` with `yarn add <pkg>` and `npm run <script>` with `yarn <script>`. While NPM has caught up significantly, Yarn might still be preferred for its strictness in `yarn.lock` for reproducibility or its CLI aesthetics for some developers.",
          "tags": [
            "NPM",
            "Yarn",
            "Package Manager",
            "Comparison"
          ],
          "prerequisites": [
            "theory_npm_basics",
            "theory_yarn_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_npm_dev_dependency",
          "topic": "NPM Dependencies",
          "level": "easy",
          "type": "mcq",
          "question": "Which command installs `eslint` as a development dependency for a project?",
          "answer": "npm install eslint --save-dev",
          "options": [
            "npm install eslint",
            "npm add eslint --dev",
            "npm install eslint --save-dev",
            "npm build eslint"
          ],
          "analysisPoints": [
            "Understanding the distinction between regular and development dependencies.",
            "Knowing the correct flag for development dependencies in NPM.",
            "Familiarity with common NPM commands."
          ],
          "keyConcepts": [
            "NPM",
            "Dependencies",
            "devDependencies",
            "package.json"
          ],
          "evaluationCriteria": [
            "Correct identification of the `save-dev` flag.",
            "Understanding `npm install` command.",
            "Distinguishing between `dependencies` and `devDependencies`."
          ],
          "example": "The `--save-dev` (or `-D`) flag is crucial for designating a package as a development dependency, meaning it's only needed during development time (e.g., for linting, testing, or building) and not for the application's runtime in production. `npm install eslint` would add it as a regular dependency, which is usually not desired for linters.",
          "tags": [
            "NPM",
            "Dependencies",
            "CLI"
          ],
          "prerequisites": [
            "theory_npm_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_package_json_purpose",
          "topic": "package.json",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `package.json` file in a Node.js/frontend project?",
          "answer": "The `package.json` file serves as a manifest for a Node.js project. It contains metadata about the project (name, version, author), defines scripts for automation, and lists all project dependencies and development dependencies.",
          "analysisPoints": [
            "Metadata storage.",
            "Script definitions.",
            "Dependency management."
          ],
          "keyConcepts": [
            "package.json",
            "NPM",
            "Yarn",
            "Dependencies",
            "Scripts"
          ],
          "evaluationCriteria": [
            "Ability to articulate the core functions of `package.json`."
          ],
          "example": "The `package.json` is like the ID card of your project, specifying essential information and allowing package managers to understand how to set up the project's environment and run its commands.",
          "tags": [
            "NPM",
            "Yarn",
            "package.json",
            "Flashcard"
          ],
          "prerequisites": [
            "theory_npm_basics",
            "theory_yarn_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_gulp_purpose",
          "topic": "Gulp Task Runner",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following best describes the primary purpose of Gulp in a frontend development workflow?",
          "answer": "To automate repetitive tasks like compiling Sass, minifying JavaScript, and optimizing images.",
          "options": [
            "To manage and install Node.js packages and their dependencies.",
            "To provide a framework for building single-page applications.",
            "To automate repetitive tasks like compiling Sass, minifying JavaScript, and optimizing images.",
            "To provide a server-side runtime environment for JavaScript."
          ],
          "analysisPoints": [
            "Distinguishing task runners from package managers, frameworks, and runtime environments.",
            "Identifying common tasks automated by Gulp.",
            "Understanding the core value proposition of build tools."
          ],
          "keyConcepts": [
            "Gulp",
            "Task Runner",
            "Automation",
            "Frontend Build Tools"
          ],
          "evaluationCriteria": [
            "Correctly identifying Gulp's role.",
            "Understanding what Gulp automates."
          ],
          "example": "Gulp is not a package manager like NPM/Yarn (option A), nor a SPA framework (option B like React/Vue), nor a runtime (option D like Node.js). Its core function is automating repetitive tasks, which is crucial for efficient frontend development.",
          "tags": [
            "Gulp",
            "Task Runner",
            "Automation",
            "MCQ"
          ],
          "prerequisites": [
            "theory_gulp_task_runner"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_gulp_streams",
          "topic": "Gulp Streams",
          "level": "hard",
          "type": "open",
          "question": "Gulp leverages 'streams' for efficiency. Explain what streams are in the context of Gulp, how they contribute to performance, and illustrate with an example pipeline.",
          "answer": "N/A",
          "analysisPoints": [
            "Definition of streams (data flowing through pipes).",
            "How Gulp uses streams (in-memory processing vs. disk I/O).",
            "Performance benefits (reduced disk operations, faster builds).",
            "Explanation of a `gulp.src().pipe().pipe().dest()` pipeline.",
            "Analogy to physical pipes or assembly lines."
          ],
          "keyConcepts": [
            "Gulp",
            "Streams",
            "Performance Optimization",
            "Build Tools",
            "Node.js"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of stream definition.",
            "Ability to connect streams to Gulp's performance.",
            "Effectiveness of the example pipeline.",
            "Depth of understanding of file processing in build systems."
          ],
          "example": "In Gulp, streams allow data (files) to be passed from one operation (plugin) to the next in memory, rather than writing to disk after each step. For instance, `gulp.src('*.js').pipe(uglify()).pipe(rename('*.min.js')).pipe(gulp.dest('dist'))` will read JS files, minify them, rename them, and then save them to disk, all as a continuous flow. This minimizes slow disk I/O, significantly speeding up build times.",
          "tags": [
            "Gulp",
            "Streams",
            "Performance",
            "Advanced"
          ],
          "prerequisites": [
            "theory_gulp_task_runner"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_yarn_security_feature",
          "topic": "Yarn Features",
          "level": "medium",
          "type": "flashcard",
          "question": "What security feature did Yarn introduce (compared to older NPM versions) to verify package integrity?",
          "answer": "Yarn introduced the use of checksums to verify the integrity of packages before installation, ensuring that downloaded packages haven't been tampered with.",
          "analysisPoints": [
            "Checksums.",
            "Package integrity.",
            "Prevention of tampering."
          ],
          "keyConcepts": [
            "Yarn",
            "Security",
            "Checksums",
            "Package Manager"
          ],
          "evaluationCriteria": [
            "Correctly identifying the security mechanism."
          ],
          "example": "This feature helps mitigate risks associated with malicious package injection by ensuring the downloaded package matches its expected cryptographic hash.",
          "tags": [
            "Yarn",
            "Security",
            "Flashcard"
          ],
          "prerequisites": [
            "theory_yarn_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_npm_init_purpose",
          "topic": "NPM Initialization",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary function of the `npm init` command?",
          "answer": "The `npm init` command is used to initialize a new Node.js project by creating a `package.json` file in the current directory, which stores project metadata and configuration.",
          "analysisPoints": [
            "Project initialization.",
            "Creation of `package.json`.",
            "Metadata storage."
          ],
          "keyConcepts": [
            "NPM",
            "npm init",
            "package.json",
            "Project Setup"
          ],
          "evaluationCriteria": [
            "Accurate description of `npm init`'s role."
          ],
          "example": "It's the first step to set up any Node.js or frontend project that uses NPM for dependency management.",
          "tags": [
            "NPM",
            "CLI",
            "Flashcard"
          ],
          "prerequisites": [
            "theory_npm_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_npm_run_script_purpose",
          "topic": "NPM Scripts",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you execute a custom script named `dev` defined in `package.json` using NPM?",
          "answer": "You execute it using `npm run dev`.",
          "analysisPoints": [
            "Correct command syntax for running scripts."
          ],
          "keyConcepts": [
            "NPM",
            "Scripts",
            "package.json",
            "CLI"
          ],
          "evaluationCriteria": [
            "Correct command usage."
          ],
          "example": "If `package.json` has `\"scripts\": { \"dev\": \"webpack serve\" }`, then `npm run dev` will start the webpack development server.",
          "tags": [
            "NPM",
            "Scripts",
            "Flashcard"
          ],
          "prerequisites": [
            "theory_npm_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_node_modules_purpose",
          "topic": "`node_modules` and `package-lock.json`",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose of the `node_modules` directory and the `package-lock.json` file in a Node.js project. Why is `node_modules` typically excluded from version control while `package-lock.json` is included?",
          "answer": "N/A",
          "analysisPoints": [
            "`node_modules` stores actual installed package code.",
            "`package-lock.json` records exact dependency tree for reproducibility.",
            "Reasons for excluding `node_modules` (large size, easily reproducible).",
            "Reasons for including `package-lock.json` (consistent builds, preventing dependency drift).",
            "Role of `npm install` in recreating `node_modules` from `package-lock.json`."
          ],
          "keyConcepts": [
            "node_modules",
            "package-lock.json",
            "NPM",
            "Yarn",
            "Dependencies",
            "Version Control",
            "Reproducibility"
          ],
          "evaluationCriteria": [
            "Clear distinction between `node_modules` and `package-lock.json`.",
            "Accurate reasons for Gitignore practices.",
            "Understanding of dependency resolution and consistent builds."
          ],
          "example": "`node_modules` is where all your project's dependencies actually reside, making it very large. `package-lock.json` (or `yarn.lock`) ensures that when someone else installs dependencies, they get the exact same versions as you, guaranteeing a consistent build environment across all developers and CI/CD pipelines. Since `node_modules` can be recreated from `package-lock.json`, it's not committed to Git.",
          "tags": [
            "NPM",
            "package-lock.json",
            "node_modules",
            "Version Control"
          ],
          "prerequisites": [
            "theory_npm_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_gulp_code_over_config",
          "topic": "Gulp Philosophy",
          "level": "medium",
          "type": "flashcard",
          "question": "What does 'code-over-configuration' mean in the context of Gulp?",
          "answer": "In Gulp, 'code-over-configuration' means that build tasks are defined by writing JavaScript code in `gulpfile.js`, rather than relying on declarative configuration files (like XML or JSON). This approach offers greater flexibility and programmatic control over the build process.",
          "analysisPoints": [
            "Tasks defined as JavaScript functions.",
            "Flexibility and programmatic control.",
            "Contrast with declarative configuration."
          ],
          "keyConcepts": [
            "Gulp",
            "Code-over-configuration",
            "Build Tools",
            "Flexibility"
          ],
          "evaluationCriteria": [
            "Accurate definition of the term.",
            "Understanding its implication for Gulp development."
          ],
          "example": "Instead of filling out an XML file with `<task name='sass-compile'>...</task>`, you write `function compileSass() { /* ... */ }` in JavaScript, giving you the full power of the language for complex logic.",
          "tags": [
            "Gulp",
            "Philosophy",
            "Flashcard"
          ],
          "prerequisites": [
            "theory_gulp_task_runner"
          ],
          "complexity": 5,
          "interviewFrequency": 5,
          "learningPath": "intermediate"
        },
        {
          "id": "question_gulp_src_dest",
          "topic": "Gulp API",
          "level": "easy",
          "type": "flashcard",
          "question": "Explain the roles of `gulp.src()` and `gulp.dest()` in a Gulp task pipeline.",
          "answer": "`gulp.src()` defines the source files that a task will process (input), using glob patterns. `gulp.dest()` specifies the destination directory where the processed files will be saved (output).",
          "analysisPoints": [
            "Input vs. Output.",
            "File selection using `gulp.src()`.",
            "Output directory for `gulp.dest()`."
          ],
          "keyConcepts": [
            "Gulp",
            "API",
            "Filesystem Operations",
            "Build Pipeline"
          ],
          "evaluationCriteria": [
            "Clear distinction between source and destination."
          ],
          "example": "Think of `src` as 'where do I get the files from?' and `dest` as 'where do I put the finished files?'.",
          "tags": [
            "Gulp",
            "API",
            "Flashcard"
          ],
          "prerequisites": [
            "theory_gulp_task_runner"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_gulp_watch_explain",
          "topic": "Gulp Watch",
          "level": "medium",
          "type": "open",
          "question": "Describe the purpose and typical usage of `gulp.watch()` in a Gulp workflow. How does it contribute to developer productivity?",
          "answer": "N/A",
          "analysisPoints": [
            "Purpose: Monitoring file changes.",
            "Triggering tasks automatically.",
            "Syntax and parameters (`globs`, `tasks`).",
            "Contribution to productivity: live reloading, instant feedback, reduced manual intervention.",
            "Integration with a 'default' or 'dev' task."
          ],
          "keyConcepts": [
            "Gulp",
            "Automation",
            "Live Reloading",
            "Developer Experience",
            "Watchers"
          ],
          "evaluationCriteria": [
            "Accurate explanation of `gulp.watch()`'s function.",
            "Insight into productivity benefits.",
            "Understanding of its role in a development loop."
          ],
          "example": "`gulp.watch('./src/**/*.css', compileCss)` means that whenever any CSS file in `src` changes, the `compileCss` task will automatically run. This is invaluable for development, as changes are reflected immediately in the browser (often via browser-sync or similar tools), eliminating the need to manually re-run build commands.",
          "tags": [
            "Gulp",
            "Automation",
            "Developer Experience"
          ],
          "prerequisites": [
            "theory_gulp_task_runner"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_task_runner_definition",
          "topic": "Task Runners",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a 'task runner' in the context of frontend development?",
          "answer": "A task runner is a software tool that automates repetitive, common development tasks (like compilation, minification, linting, testing) to streamline the development workflow and improve efficiency.",
          "analysisPoints": [
            "Automation of repetitive tasks.",
            "Examples of tasks (compilation, minification, linting).",
            "Goal: efficiency and workflow streamlining."
          ],
          "keyConcepts": [
            "Task Runner",
            "Automation",
            "Frontend Tools",
            "Gulp"
          ],
          "evaluationCriteria": [
            "Concise and accurate definition."
          ],
          "example": "Gulp is an example of a task runner.",
          "tags": [
            "General",
            "Frontend Tools",
            "Flashcard"
          ],
          "prerequisites": [
            "theory_gulp_task_runner"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_yarn_vs_npm_speed",
          "topic": "Yarn Performance",
          "level": "medium",
          "type": "mcq",
          "question": "Historically, Yarn was often preferred over NPM due to its performance benefits. Which of the following best describes a key mechanism Yarn used to achieve faster dependency installations?",
          "answer": "Parallel installation of dependencies.",
          "options": [
            "It used a smaller registry for packages.",
            "It only installed necessary production dependencies by default.",
            "Parallel installation of dependencies.",
            "It performed deep tree flattening more aggressively than NPM."
          ],
          "analysisPoints": [
            "Understanding Yarn's core performance enhancement.",
            "Distinguishing actual mechanisms from plausible but incorrect options.",
            "Awareness of how package managers optimize installation."
          ],
          "keyConcepts": [
            "Yarn",
            "NPM",
            "Performance",
            "Package Manager",
            "Installation"
          ],
          "evaluationCriteria": [
            "Correctly identifying parallel installation as a key performance feature.",
            "Understanding the technical reason for speed improvements."
          ],
          "example": "Earlier versions of NPM would install dependencies sequentially, while Yarn optimized this process by fetching and installing multiple packages simultaneously, leading to significantly faster initial and subsequent installations. While NPM has since adopted similar optimizations, parallel installation was a major differentiator for Yarn.",
          "tags": [
            "Yarn",
            "Performance",
            "MCQ"
          ],
          "prerequisites": [
            "theory_yarn_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_npm_yarn_project_setup",
          "title": "Initialize a Frontend Project and Manage Dependencies/Scripts",
          "description": "\nThis task requires you to set up a minimal frontend project using both NPM and Yarn, demonstrate dependency installation, and define/run custom scripts.\n\n**Requirements:**\n1.  **Project Initialization:** Create a new directory `my-frontend-app`. Initialize a new NPM project inside it, accepting default values.\n2.  **Add Dependencies:**\n    *   Install a production dependency: `lodash` (a utility library).\n    *   Install a development dependency: `eslint` (a linter).\n3.  **Define Scripts:** In `package.json`:\n    *   Add a `\"start\"` script that simply prints \"Starting frontend application...\".\n    *   Add a `\"lint\"` script that runs `eslint --init` (to simulate linting setup).\n4.  **Run Scripts:** Execute both the `start` and `lint` scripts using NPM.\n5.  **Replicate with Yarn:** In the same `my-frontend-app` directory (after NPM steps), demonstrate Yarn's equivalent commands:\n    *   If `node_modules` exists, delete it. Delete `package-lock.json`.\n    *   Run Yarn's equivalent command to install all dependencies listed in `package.json`.\n    *   Run both the `start` and `lint` scripts using Yarn's syntax.\n6.  **Verification:** Ensure `lodash` and `eslint` are present in `node_modules` and correctly listed in `package.json`.\n",
          "difficulty": "medium",
          "startingCode": "# Instructions for setup:\n# 1. Create directory: mkdir my-frontend-app && cd my-frontend-app\n\n# --- NPM Steps ---\n# 2. Initialize NPM project:\n# npm init -y\n\n# 3. Install production dependency (lodash):\n# npm install lodash\n\n# 4. Install development dependency (eslint):\n# npm install eslint --save-dev\n\n# 5. Modify package.json to add scripts:\n/*\n// package.json snippet\n{\n  \"name\": \"my-frontend-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n    // TODO: Add \"start\" and \"lint\" scripts here\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"lodash\": \"^4.17.21\"\n  },\n  \"devDependencies\": {\n    \"eslint\": \"^8.0.0\"\n  }\n}\n*/\n\n# 6. Run NPM scripts:\n# npm run start\n# npm run lint\n\n# --- Yarn Steps ---\n# 7. Clean up NPM specific files (if they exist):\n# rm -rf node_modules package-lock.json\n\n# 8. Run Yarn's install command (based on existing package.json):\n# yarn install\n\n# 9. Run Yarn scripts:\n# yarn start\n# yarn lint\n",
          "solutionCode": "# Step 1: Create directory and navigate\nmkdir my-frontend-app && cd my-frontend-app\n\n# --- NPM Steps ---\n# Step 2: Initialize NPM project\nnpm init -y\n\n# Step 3: Install production dependency (lodash)\nnpm install lodash\n\n# Step 4: Install development dependency (eslint)\nnpm install eslint --save-dev\n\n# Step 5: Modify package.json to add scripts\n# (Manually edit package.json or use a tool to insert)\n# The 'scripts' section should look like this:\n/*\n{\n  \"name\": \"my-frontend-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"start\": \"echo \\\"Starting frontend application...\\\"\",\n    \"lint\": \"eslint --init\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"lodash\": \"^4.17.21\"\n  },\n  \"devDependencies\": {\n    \"eslint\": \"^8.45.0\"\n  }\n}\n*/\n\n# Step 6: Run NPM scripts\nnpm run start\nnpm run lint\n\n# --- Yarn Steps ---\n# Step 7: Clean up NPM specific files\nrm -rf node_modules package-lock.json\n\n# Step 8: Run Yarn's install command (based on existing package.json)\nyarn install\n\n# Step 9: Run Yarn scripts\nyarn start\nyarn lint\n",
          "testCases": [
            "Verify `package.json` is created with basic info after `npm init -y`.",
            "Verify `lodash` is listed under `dependencies` in `package.json`.",
            "Verify `eslint` is listed under `devDependencies` in `package.json`.",
            "Verify `node_modules` directory exists after `npm install` and contains `lodash` and `eslint`.",
            "Verify `package-lock.json` is created by NPM.",
            "Verify `npm run start` prints 'Starting frontend application...'.",
            "Verify `npm run lint` attempts to run `eslint --init` (may prompt for setup).",
            "Verify `yarn.lock` is created by Yarn after `yarn install`.",
            "Verify `node_modules` is re-created by Yarn and contains `lodash` and `eslint`.",
            "Verify `yarn start` prints 'Starting frontend application...'.",
            "Verify `yarn lint` attempts to run `eslint --init`."
          ],
          "hints": [
            "Remember that `npm init -y` skips interactive prompts.",
            "The `--save-dev` flag is essential for development dependencies with NPM.",
            "For Yarn, `yarn add --dev` is the equivalent.",
            "When defining scripts in `package.json`, ensure the commands are executable in the shell.",
            "Yarn's equivalent to `npm install` (to install existing dependencies) is simply `yarn install` or `yarn`."
          ],
          "tags": [
            "NPM",
            "Yarn",
            "CLI",
            "Project Setup",
            "Dependencies",
            "Scripts"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_npm_basics",
            "theory_yarn_basics"
          ],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "beginner",
          "relatedConcepts": [
            "package.json",
            "node_modules",
            "package-lock.json",
            "yarn.lock"
          ]
        },
        {
          "id": "task_extend_gulp_build",
          "title": "Extend a Gulp Build Workflow",
          "description": "\nThis task requires you to extend an existing `gulpfile.js` to add new common frontend automation tasks, demonstrating your understanding of Gulp's API and pipeline concept.\n\n**Requirements:**\n1.  **Initial Setup:** Create a `src` directory with a `scss` subdirectory and a `js` subdirectory.\n    *   `src/scss/main.scss` (with some basic Sass rules, e.g., `$color: blue; body { color: $color; }`)\n    *   `src/js/app.js` (with some basic JS, e.g., `console.log('Hello Gulp!');`)\n    *   `src/index.html` (a simple HTML file, e.g., `<!DOCTYPE html><html><head><link rel=\"stylesheet\" href=\"./css/main.css\"></head><body><h1>Gulp Demo</h1><script src=\"./js/app.min.js\"></script></body></html>`)\n2.  **Integrate Given Gulpfile:** Use the provided Gulpfile structure as a starting point. Ensure the `sass` task correctly compiles `main.scss` to `dist/css/main.css`.\n3.  **Add JavaScript Minification Task:**\n    *   Create a new Gulp task named `minifyJs`.\n    *   This task should take JavaScript files from `src/js/**/*.js`.\n    *   Use `gulp-uglify` to minify the JavaScript.\n    *   Rename the minified file to `.min.js` (e.g., `app.js` becomes `app.min.js`) using `gulp-rename`.\n    *   Output the minified files to `dist/js`.\n4.  **Add HTML Copy Task:**\n    *   Create a new Gulp task named `copyHtml`.\n    *   This task should simply copy all HTML files from `src/*.html` to the `dist` directory.\n5.  **Refactor `default` Task:**\n    *   Modify the `default` task to run all build-related tasks (`sass`, `minifyJs`, `copyHtml`) sequentially first, and then start the `watch` task.\n    *   Ensure the `watch` task also watches for changes in JS and HTML files and triggers their respective build tasks.\n6.  **Run and Verify:** Execute the default Gulp task and confirm that:\n    *   `dist/css/main.css` exists and contains compiled/prefixed CSS.\n    *   `dist/js/app.min.js` exists, is minified, and renamed.\n    *   `dist/index.html` exists.\n    *   Changes to SCSS, JS, or HTML files trigger re-compilation/copying.\n",
          "difficulty": "hard",
          "startingCode": "const gulp = require('gulp');\nconst sass = require('gulp-sass')(require('sass'));\nconst autoprefixer = require('gulp-autoprefixer');\n\n// TODO: Require gulp-uglify and gulp-rename\n\n// Compile SCSS to CSS\nfunction compileSass() {\n  return gulp.src('./src/scss/**/*.scss')\n    .pipe(sass().on('error', sass.logError))\n    .pipe(autoprefixer({\n      overrideBrowserslist: ['last 2 versions'],\n      cascade: false\n    }))\n    .pipe(gulp.dest('./dist/css'));\n}\n\n// TODO: Create a 'minifyJs' task\n\n// TODO: Create a 'copyHtml' task\n\n// Watch for changes\nfunction watchFiles() {\n  gulp.watch('./src/scss/**/*.scss', compileSass);\n  // TODO: Add watchers for JS and HTML files\n}\n\n// Default task\nexports.sass = compileSass;\nexports.watch = watchFiles;\n// TODO: Modify exports.default to run all build tasks before watching\nexports.default = gulp.series(compileSass, watchFiles);\n",
          "solutionCode": "const gulp = require('gulp');\nconst sass = require('gulp-sass')(require('sass'));\nconst autoprefixer = require('gulp-autoprefixer');\nconst uglify = require('gulp-uglify'); // Added\nconst rename = require('gulp-rename'); // Added\n\n// Compile SCSS to CSS\nfunction compileSass() {\n  return gulp.src('./src/scss/**/*.scss')\n    .pipe(sass().on('error', sass.logError))\n    .pipe(autoprefixer({\n      overrideBrowserslist: ['last 2 versions'],\n      cascade: false\n    }))\n    .pipe(gulp.dest('./dist/css'));\n}\n\n// Minify JavaScript\nfunction minifyJs() {\n  return gulp.src('./src/js/**/*.js')\n    .pipe(uglify()) // Minify JS\n    .pipe(rename({ suffix: '.min' })) // Add .min suffix\n    .pipe(gulp.dest('./dist/js'));\n}\n\n// Copy HTML files\nfunction copyHtml() {\n  return gulp.src('./src/*.html')\n    .pipe(gulp.dest('./dist'));\n}\n\n// Watch for changes\nfunction watchFiles() {\n  gulp.watch('./src/scss/**/*.scss', compileSass);\n  gulp.watch('./src/js/**/*.js', minifyJs); // Watch JS\n  gulp.watch('./src/*.html', copyHtml); // Watch HTML\n}\n\n// Export tasks\nexports.sass = compileSass;\nexports.minifyJs = minifyJs;\nexports.copyHtml = copyHtml;\nexports.watch = watchFiles;\n\n// Define a 'build' task to run all compilation/copy tasks\nconst build = gulp.series(compileSass, minifyJs, copyHtml);\n\n// Default task: run build then start watching\nexports.default = gulp.series(build, watchFiles);\n",
          "testCases": [
            "Run `npm install gulp gulp-sass sass gulp-autoprefixer gulp-uglify gulp-rename`.",
            "Create `src/scss/main.scss` with `@charset 'UTF-8'; $primary-color: #333; body { color: $primary-color; }`",
            "Create `src/js/app.js` with `function greet(name) { console.log('Hello, ' + name + '!'); } greet('Gulp');`",
            "Create `src/index.html` with `<!DOCTYPE html><html><head><link rel=\"stylesheet\" href=\"./css/main.css\"></head><body><h1>Gulp Demo</h1><script src=\"./js/app.min.js\"></script></body></html>`",
            "Execute `gulp` (or `npm start` if default script is set up).",
            "Verify `dist/css/main.css` exists, contains minified/prefixed CSS.",
            "Verify `dist/js/app.min.js` exists, is minified (e.g., `function greet(e){console.log(\"Hello, \"+e+\"!\")}greet(\"Gulp\");`), and correctly renamed.",
            "Verify `dist/index.html` exists and is identical to `src/index.html`.",
            "Make a small change to `src/scss/main.scss` and confirm `dist/css/main.css` updates automatically.",
            "Make a small change to `src/js/app.js` and confirm `dist/js/app.min.js` updates automatically.",
            "Make a small change to `src/index.html` and confirm `dist/index.html` updates automatically."
          ],
          "hints": [
            "Remember to install all necessary Gulp plugins using `npm install <plugin-name>`.",
            "Use `gulp-uglify` for JavaScript minification.",
            "Use `gulp-rename` to add the `.min` suffix to minified files.",
            "The `gulp.series()` and `gulp.parallel()` functions are crucial for chaining tasks in Gulp 4.",
            "For `gulp.watch()`, you can pass an array of tasks or use `gulp.series()` if multiple tasks need to be triggered sequentially for a single watch event."
          ],
          "tags": [
            "Gulp",
            "Task Runner",
            "Automation",
            "JavaScript",
            "SCSS",
            "HTML",
            "Build Tools"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_gulp_task_runner",
            "NPM basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Frontend Workflow",
            "Minification",
            "Compilation",
            "Asset Optimization",
            "Watchers"
          ]
        }
      ]
    }
  },
  {
    "id": "01a040f1-77d2-4b87-9848-49d27e4565fa",
    "startLine": 12800,
    "endLine": 12899,
    "processedDate": "2025-06-17T13:06:34.046Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_grunt_task_runner",
          "title": "Grunt: A Configuration-Based Task Runner",
          "content": "Grunt is an older, but still relevant, JavaScript task runner that emphasizes a configuration-over-code approach. It automates repetitive tasks such as minification, compilation, unit testing, linting, and more. Unlike newer bundlers that focus on module resolution and dependency graphs, Grunt operates by executing predefined tasks based on configurations specified in its `Gruntfile.js`.\n\n## Key Concepts\n*   **Task Runner**: Automates repetitive development tasks.\n*   **Configuration-based**: Tasks are defined and configured using JavaScript objects within `Gruntfile.js`.\n*   **Plugins**: Grunt's functionality is extended through a wide ecosystem of plugins, which handle specific operations (e.g., `grunt-contrib-sass` for SASS compilation, `grunt-contrib-watch` for file watching).\n*   **Gruntfile.js**: The main configuration file where tasks are defined, configured, and registered.\n*   **`grunt.initConfig()`**: Used to define project-specific configurations for tasks. This is where options for plugins are set.\n*   **`grunt.loadNpmTasks()`**: Loads a Grunt plugin, making its tasks available.\n*   **`grunt.registerTask()`**: Registers a new task, which can be a combination of other tasks or a custom function. The `default` task is executed when Grunt is run without any specific task name.\n\n## How it Works\nWhen Grunt is executed, it reads the `Gruntfile.js`. It then applies the configurations defined in `grunt.initConfig()` to the loaded plugins. When a task is invoked (e.g., `grunt default`), Grunt executes the specified series of sub-tasks in order. It's particularly useful for operations that need to be run sequentially or conditionally based on file changes.",
          "examples": [
            {
              "id": "example_grunt_basic_config",
              "title": "Basic Gruntfile.js Configuration",
              "code": "module.exports = function(grunt) {\n  // Project configuration.\n  grunt.initConfig({\n    // Configuration for the 'sass' task\n    sass: {\n      dist: {\n        files: {\n          'dist/css/main.css': 'src/scss/main.scss' // Output:Input mapping\n        }\n      }\n    },\n    // Configuration for the 'watch' task\n    watch: {\n      scss: {\n        files: ['src/scss/**/*.scss'], // Files to watch\n        tasks: ['sass'] // Tasks to run when files change\n      }\n    }\n  });\n\n  // Load Grunt plugins\n  grunt.loadNpmTasks('grunt-contrib-sass');\n  grunt.loadNpmTasks('grunt-contrib-watch');\n\n  // Register a default task alias.\n  // Running 'grunt' in the terminal will execute 'sass' then 'watch'.\n  grunt.registerTask('default', ['sass', 'watch']);\n};",
              "explanation": "This `Gruntfile.js` demonstrates a typical setup for Grunt. It initializes configurations for `sass` and `watch` tasks. The `sass` task compiles a SCSS file into a CSS file. The `watch` task monitors SCSS files and automatically triggers the `sass` task whenever changes are detected. Finally, `grunt.loadNpmTasks` includes the necessary plugins, and `grunt.registerTask` defines a `default` task that runs both `sass` and `watch` sequentially.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_grunt_config_over_code",
            "question_grunt_vs_webpack_flashcard",
            "question_grunt_task_registration",
            "question_grunt_plugin_loading",
            "question_gruntfile_structure_mcq"
          ],
          "relatedTasks": [
            "task_grunt_css_minification"
          ],
          "tags": [
            "Grunt",
            "Task Runner",
            "Build Tools",
            "Automation",
            "Frontend Development"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "Node.js",
            "npm"
          ],
          "complexity": 5,
          "interviewRelevance": 6,
          "learningPath": "intermediate",
          "requiredFor": [
            "Legacy Project Maintenance",
            "Automation Workflows"
          ]
        },
        {
          "id": "theory_module_bundlers_overview",
          "title": "Module Bundlers: Webpack and Rollup",
          "content": "Module bundlers are sophisticated tools crucial for modern JavaScript development. They process and combine various types of files (JavaScript, CSS, images, etc.) into optimized bundles for deployment. Their primary role is to resolve dependencies between modules, transform code (e.g., Babel for ES6+ to ES5), and optimize the output for production environments (e.g., minification, tree-shaking).\n\nUnlike traditional task runners like Grunt, which automate discrete tasks, module bundlers focus on understanding the dependency graph of an entire application. They start from an entry point and traverse all imports to create a complete graph of everything the application needs, then process these modules into optimized bundles.\n\n## Common Features of Module Bundlers\n*   **Dependency Resolution**: Understanding `import`/`require` statements and building a dependency graph.\n*   **Transpilation**: Converting modern JavaScript (ES6+) or TypeScript into backward-compatible JavaScript (ES5) using tools like Babel or TypeScript compiler.\n*   **Asset Management**: Handling non-JavaScript assets like CSS, images, fonts, by treating them as modules.\n*   **Code Splitting**: Dividing code into smaller chunks that can be loaded on demand, improving initial load times.\n*   **Optimization**: Minification, uglification, tree-shaking (removing unused code), scope hoisting.\n*   **Development Server**: Often include a dev server with hot module replacement (HMR) for a faster development workflow.\n*   **Plugins and Loaders/Plugins**: Extensible architectures to customize bundling behavior.",
          "examples": [],
          "relatedQuestions": [
            "question_module_bundler_purpose",
            "question_bundler_vs_task_runner",
            "question_code_splitting_benefits",
            "question_tree_shaking_definition_flashcard",
            "question_bundler_loader_plugin_mcq"
          ],
          "relatedTasks": [],
          "tags": [
            "Module Bundler",
            "Frontend Build Tools",
            "Webpack",
            "Rollup",
            "Development Workflow",
            "Optimization"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "JavaScript Modules",
            "Node.js",
            "npm"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Modern Web Development",
            "Performance Optimization",
            "Large Scale Applications"
          ]
        },
        {
          "id": "theory_webpack_bundler",
          "title": "Webpack: A Static Module Bundler",
          "content": "Webpack is the most popular static module bundler for modern JavaScript applications. It builds a dependency graph of all modules (JavaScript, CSS, images, etc.) in your project and generates one or more bundles. \"Static\" refers to its ability to analyze dependencies at build time, rather than runtime.\n\n## Core Concepts\n*   **Entry**: The starting point(s) of your application's dependency graph. Webpack begins bundling from here.\n*   **Output**: Specifies where Webpack should emit the bundles it creates and how to name these files.\n*   **Loaders**: Webpack itself only understands JavaScript. Loaders transform other types of files (e.g., TypeScript, Sass, images) into valid modules that can be added to the dependency graph. They allow you to `import` any type of file directly in your JavaScript.\n    *   `test`: A regular expression that matches the file types to be transformed.\n    *   `exclude`: Files or folders to exclude from transformation (e.g., `node_modules`).\n    *   `use`: An array of loaders to apply to the matched files. Loaders are applied from right to left (or bottom to top).\n*   **Plugins**: Used to perform a wider range of tasks than loaders, such as bundle optimization, asset management, and environment variable injection. Plugins hook into Webpack's build process at various stages.\n    *   `HtmlWebpackPlugin`: Simplifies creation of HTML files to serve your webpack bundles, especially useful for injecting bundled JavaScript automatically.\n*   **Mode**: Configures Webpack to optimize for development, production, or none. (`development`, `production`, `none`). Production mode enables optimizations like minification and tree-shaking by default.\n*   **DevServer**: Provides a live-reloading development server.",
          "examples": [
            {
              "id": "example_webpack_config_js",
              "title": "Example webpack.config.js for React/CSS",
              "code": "const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js', // Application's entry point\n  output: {\n    path: path.resolve(__dirname, 'dist'), // Output directory\n    filename: 'bundle.js' // Name of the bundled file\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, // Apply to .js files\n        exclude: /node_modules/, // Exclude node_modules\n        use: {\n          loader: 'babel-loader', // Use babel-loader\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react'] // Babel presets for ES6+ and React\n          }\n        }\n      },\n      {\n        test: /\\.css$/, // Apply to .css files\n        use: ['style-loader', 'css-loader'] // Use style-loader and css-loader\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html' // Use this HTML file as a template\n    })\n  ],\n  // Optional: Add development mode for better debugging and faster builds\n  mode: 'development'\n};",
              "explanation": "This Webpack configuration sets up bundling for a typical React application with CSS. It defines `src/index.js` as the entry point and outputs `bundle.js` into the `dist` folder. It uses `babel-loader` to transpile `.js` files (excluding `node_modules`) for ES6+ and React support. `style-loader` and `css-loader` are used to handle CSS files, embedding them into the bundle. The `HtmlWebpackPlugin` automatically injects the generated `bundle.js` into `src/index.html` and outputs it to `dist/index.html`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_webpack_entry_output",
            "question_webpack_loaders_vs_plugins",
            "question_webpack_babel_loader_purpose",
            "question_webpack_module_rules_order",
            "question_htmlwebpackplugin_purpose_flashcard",
            "question_webpack_mode_impact_mcq"
          ],
          "relatedTasks": [
            "task_webpack_react_app_setup",
            "task_webpack_image_handling"
          ],
          "tags": [
            "Webpack",
            "Module Bundler",
            "JavaScript",
            "React",
            "Frontend Build Tools",
            "Loaders",
            "Plugins",
            "Dependency Graph"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "JavaScript Modules",
            "ES6+",
            "Node.js",
            "npm"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "requiredFor": [
            "React Development",
            "Single Page Applications (SPAs)",
            "Complex Frontend Builds"
          ]
        },
        {
          "id": "theory_rollup_bundler",
          "title": "Rollup: A Module Bundler for Libraries and Applications",
          "content": "Rollup is another powerful module bundler for JavaScript, often preferred for building JavaScript libraries and small applications due to its efficient output and focus on ES modules. It excels at producing highly optimized, flattened bundles, particularly benefiting from a feature called 'tree-shaking'.\n\n## Key Characteristics\n*   **ES Modules First**: Rollup deeply understands ES Modules (`import`/`export`) and leverages their static analysis capabilities to perform highly efficient tree-shaking and scope hoisting.\n*   **Tree-shaking (Dead Code Elimination)**: A core strength of Rollup. It analyzes the dependency graph and only includes the code that is actually used, leading to smaller bundle sizes. It excels here because ES modules allow for static analysis of imports/exports.\n*   **Scope Hoisting**: Rollup can merge multiple modules into a single scope (instead of wrapping each module in a function), reducing overhead and often resulting in faster execution.\n*   **Output Formats**: Supports various output formats including `iife` (Immediately Invoked Function Expression), `esm` (ES Module), `cjs` (CommonJS), `umd` (Universal Module Definition), useful for different distribution targets.\n*   **Plugins**: Similar to Webpack, Rollup's functionality is extended through plugins (e.g., `@rollup/plugin-node-resolve` for resolving node modules, `@rollup/plugin-babel` for transpilation).\n\n## Webpack vs. Rollup (Brief Comparison)\n*   **Primary Use Case**: Webpack is generally better for complex Single Page Applications (SPAs) with many assets and dynamic imports, while Rollup is often preferred for JavaScript libraries, component libraries, and simpler applications due to its highly optimized output for standalone modules.\n*   **Bundle Size**: Rollup often produces smaller bundles for libraries due to its superior tree-shaking and scope hoisting with ES Modules.\n*   **Configuration Complexity**: Webpack configuration can be more complex due to its vast feature set; Rollup is often simpler for basic library bundling.\n*   **Hot Module Replacement (HMR)**: Webpack has mature HMR support, which is less of a focus for Rollup (as libraries don't typically need HMR).",
          "examples": [
            {
              "id": "example_rollup_config_js",
              "title": "Example rollup.config.js for a Library",
              "code": "import resolve from '@rollup/plugin-node-resolve'; // Resolves third-party modules from node_modules\nimport babel from '@rollup/plugin-babel';       // Transpiles JavaScript using Babel\n\nexport default {\n  input: 'src/main.js', // Entry point for the bundle\n  output: {\n    file: 'dist/bundle.js', // Output file path\n    format: 'iife' // Output format: Immediately Invoked Function Expression\n  },\n  plugins: [\n    resolve(), // Allows Rollup to find third-party modules\n    babel({\n      babelHelpers: 'bundled', // Or 'runtime' for smaller output but requires @babel/runtime\n      presets: ['@babel/preset-env'] // Transpiles to a compatible JS version\n    })\n  ]\n};",
              "explanation": "This `rollup.config.js` sets up a build for a JavaScript library. It takes `src/main.js` as input and outputs a bundled file named `bundle.js` in `iife` format, which is suitable for direct inclusion in a browser via a `<script>` tag. The `@rollup/plugin-node-resolve` plugin enables Rollup to find modules from `node_modules`, and `@rollup/plugin-babel` transpiles the code using Babel, ensuring compatibility with older environments. The `babelHelpers: 'bundled'` option ensures that Babel's helper functions are included directly in the bundle.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_rollup_es_modules_focus",
            "question_rollup_tree_shaking",
            "question_rollup_output_formats_mcq",
            "question_webpack_vs_rollup_comparison",
            "question_scope_hoisting_flashcard"
          ],
          "relatedTasks": [
            "task_rollup_library_build"
          ],
          "tags": [
            "Rollup",
            "Module Bundler",
            "JavaScript",
            "Libraries",
            "Tree-shaking",
            "ES Modules",
            "Frontend Build Tools",
            "Optimization"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "JavaScript Modules",
            "ES6+",
            "Node.js",
            "npm"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "Library Development",
            "Framework Development",
            "Optimized Bundles"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_grunt_config_over_code",
          "topic": "Grunt Task Runner",
          "level": "easy",
          "type": "open",
          "question": "Explain what is meant by Grunt's 'configuration-over-code' approach and how it differs from a more programmatic approach.",
          "answer": "Grunt's 'configuration-over-code' approach means that tasks are primarily defined and customized through structured configuration objects (JSON-like structures) within the `Gruntfile.js`, rather than through extensive custom JavaScript logic. Developers specify *what* to do (e.g., compile Sass, minify JavaScript) and *how* to do it (e.g., input/output paths, specific options) by setting properties in these configuration objects. This differs from a programmatic approach where developers might write explicit JavaScript functions to perform each step, providing more flexibility but potentially more boilerplate.",
          "analysisPoints": [
            "Understanding of declarative vs. imperative programming paradigms.",
            "Ability to articulate the benefits (simplicity, readability for common tasks) and drawbacks (less flexibility for complex custom logic) of configuration-based tools.",
            "Contrast with tools that use more programmatic APIs (e.g., Gulp, or even custom Node.js scripts)."
          ],
          "keyConcepts": [
            "Grunt",
            "Configuration-based",
            "Declarative programming",
            "Task runner"
          ],
          "evaluationCriteria": [
            "Clarity of explanation of 'configuration-over-code'.",
            "Accuracy of comparison with programmatic approaches."
          ],
          "example": "In Grunt, you specify file mappings for SASS compilation in a `files` object: `{ 'dist/css/main.css': 'src/scss/main.scss' }`. In a programmatic approach, you might write code to read `src/scss/main.scss`, process it, and then write the output to `dist/css/main.css`.",
          "tags": [
            "Grunt",
            "Task Runner",
            "Configuration",
            "Paradigm"
          ],
          "prerequisites": [
            "Basic JavaScript",
            "Build Tools Concepts"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_grunt_task_registration",
          "topic": "Grunt Task Runner",
          "level": "medium",
          "type": "code",
          "question": "Given the following `Gruntfile.js` snippet, write the `grunt.registerTask` line(s) required to create a 'build' task that first lints JavaScript files, then compiles TypeScript files, and finally runs unit tests. Assume 'lint', 'typescript', and 'test' are existing Grunt tasks.",
          "answer": "```javascript\nmodule.exports = function(grunt) {\n  grunt.initConfig({\n    // ... other configurations for 'lint', 'typescript', 'test'\n  });\n\n  // Load necessary plugins\n  grunt.loadNpmTasks('grunt-contrib-lint'); // Placeholder, actual plugin name may vary\n  grunt.loadNpmTasks('grunt-typescript'); // Placeholder\n  grunt.loadNpmTasks('grunt-contrib-test'); // Placeholder\n\n  // Register the 'build' task\n  grunt.registerTask('build', ['lint', 'typescript', 'test']);\n};\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `grunt.registerTask`.",
            "Understanding of task chaining and order of execution.",
            "Ability to interpret requirements into Grunt syntax."
          ],
          "keyConcepts": [
            "Grunt tasks",
            "Task registration",
            "Task chaining"
          ],
          "evaluationCriteria": [
            "Syntactic correctness of the `registerTask` call.",
            "Logical order of tasks within the array."
          ],
          "example": "The `grunt.registerTask('build', ['lint', 'typescript', 'test']);` line defines a new task named 'build'. When `grunt build` is executed, it will run 'lint', then 'typescript', then 'test' in sequence. This demonstrates how Grunt allows combining multiple sub-tasks into a single, higher-level task.",
          "tags": [
            "Grunt",
            "Task Runner",
            "Configuration",
            "Code Example"
          ],
          "prerequisites": [
            "Grunt Basics",
            "JavaScript"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_grunt_plugin_loading",
          "topic": "Grunt Task Runner",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of `grunt.loadNpmTasks()` in a `Gruntfile.js`?",
          "answer": "`grunt.loadNpmTasks()` is used to load a Grunt plugin, making its tasks available for use within the `Gruntfile.js`. Without loading the plugin, tasks defined by it (like `sass` from `grunt-contrib-sass`) cannot be referenced or configured.",
          "analysisPoints": [
            "Understanding of Grunt's plugin system.",
            "Role of this specific API call."
          ],
          "keyConcepts": [
            "Grunt plugins",
            "Gruntfile.js",
            "Task availability"
          ],
          "evaluationCriteria": [
            "Concise and accurate definition."
          ],
          "example": null,
          "tags": [
            "Grunt",
            "Flashcard",
            "Task Runner",
            "Plugins"
          ],
          "prerequisites": [
            "Grunt Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_gruntfile_structure_mcq",
          "topic": "Grunt Task Runner",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following Gruntfile.js structure:\n\n```javascript\n// Gruntfile.js\nmodule.exports = function(grunt) {\n  grunt.initConfig({\n    taskA: { /* config */ },\n    taskB: { /* config */ }\n  });\n\n  grunt.loadNpmTasks('plugin-for-taskA');\n  grunt.loadNpmTasks('plugin-for-taskB');\n\n  grunt.registerTask('myCustomTask', ['taskA', 'taskB']);\n};\n```\n\nIf you run `grunt myCustomTask` from the terminal, what is the expected order of execution?",
          "answer": "TaskA then TaskB",
          "options": [
            "TaskB then TaskA",
            "TaskA then TaskB",
            "Both TaskA and TaskB run in parallel",
            "It depends on the operating system"
          ],
          "analysisPoints": [
            "Understanding of `grunt.registerTask` and task chaining.",
            "Knowledge that Grunt tasks in an array are executed sequentially.",
            "Distinction between sequential and parallel execution in build tools."
          ],
          "keyConcepts": [
            "Grunt task execution order",
            "Sequential tasks",
            "registerTask"
          ],
          "evaluationCriteria": [
            "Correct identification of sequential execution.",
            "Exclusion of incorrect assumptions like parallelism or OS dependency."
          ],
          "example": "The `grunt.registerTask('myCustomTask', ['taskA', 'taskB']);` line explicitly defines that `taskA` will be run first, and only after `taskA` completes successfully, `taskB` will begin. Grunt processes tasks listed in an array sequentially by default.",
          "tags": [
            "Grunt",
            "Task Runner",
            "Execution Order",
            "MCQ"
          ],
          "prerequisites": [
            "Grunt Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_module_bundler_purpose",
          "topic": "Module Bundlers",
          "level": "easy",
          "type": "open",
          "question": "What is the primary purpose of a module bundler in modern web development?",
          "answer": "The primary purpose of a module bundler is to combine multiple JavaScript modules (and other assets like CSS, images) into a single or a few optimized bundles. This process allows developers to use modern JavaScript features (like ES Modules) and various pre-processors (e.g., TypeScript, Sass) in their development workflow, while ensuring the output is compatible with browsers and optimized for performance (e.g., smaller file sizes, fewer HTTP requests) for production deployment.",
          "analysisPoints": [
            "Identification of core function: combining modules.",
            "Recognition of benefits: compatibility, performance optimization.",
            "Understanding of the context: modern web development practices."
          ],
          "keyConcepts": [
            "Module bundler",
            "Dependency graph",
            "Optimization",
            "Compatibility",
            "Development workflow"
          ],
          "evaluationCriteria": [
            "Completeness of the explanation, covering both technical function and benefits."
          ],
          "example": null,
          "tags": [
            "Module Bundler",
            "Frontend Development",
            "Optimization"
          ],
          "prerequisites": [
            "JavaScript Modules"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_bundler_vs_task_runner",
          "topic": "Module Bundlers vs. Task Runners",
          "level": "medium",
          "type": "open",
          "question": "Differentiate between a 'task runner' like Grunt and a 'module bundler' like Webpack, focusing on their primary responsibilities and how they achieve their goals.",
          "answer": "A **Task Runner (e.g., Grunt)** primarily automates repetitive, discrete development tasks (like linting, compiling Sass, minifying files, running tests). It operates based on configurations, executing defined tasks in a specified sequence. Its goal is workflow automation, replacing manual CLI commands or scripts.\n\nA **Module Bundler (e.g., Webpack)**, on the other hand, focuses on building a comprehensive dependency graph of an entire application. Its main responsibility is to resolve all module dependencies, process various asset types (JS, CSS, images) through 'loaders', and combine them into optimized bundles for deployment. Its goal is to create production-ready code that is efficient for browsers, supports modern JavaScript features, and handles module resolution.\n\nThe key difference lies in their scope and approach: Task runners automate *tasks*, while bundlers *transform and combine modules* to build an application's deployable assets.",
          "analysisPoints": [
            "Clear definition of task runner's role (automation of discrete tasks).",
            "Clear definition of module bundler's role (dependency graph, bundling, optimization).",
            "Ability to highlight the core conceptual difference: task automation vs. application asset compilation.",
            "Use of examples to illustrate the point."
          ],
          "keyConcepts": [
            "Task runner",
            "Module bundler",
            "Grunt",
            "Webpack",
            "Automation",
            "Dependency graph",
            "Bundling"
          ],
          "evaluationCriteria": [
            "Accuracy and conciseness of definitions.",
            "Effectiveness of comparison in highlighting key differences."
          ],
          "example": null,
          "tags": [
            "Task Runner",
            "Module Bundler",
            "Comparison",
            "Grunt",
            "Webpack"
          ],
          "prerequisites": [
            "Grunt",
            "Webpack"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_code_splitting_benefits",
          "topic": "Module Bundlers",
          "level": "medium",
          "type": "open",
          "question": "What is code splitting in the context of module bundlers, and what are its main benefits for web application performance?",
          "answer": "Code splitting is a feature of module bundlers that allows dividing your application's code into smaller, separate chunks that can be loaded on demand or in parallel, rather than bundling everything into a single large file. \n\n**Main benefits:**\n1.  **Faster Initial Load Times**: By only loading the necessary code for the current view, the initial bundle size is reduced, leading to quicker page loads.\n2.  **Improved User Experience**: Users can interact with the page sooner as less data needs to be downloaded and parsed upfront.\n3.  **Better Caching**: Changes to one part of the application only invalidate the cache for that specific chunk, allowing users to reuse cached code for other parts of the application.\n4.  **Resource Management**: Reduces memory footprint and parsing/execution time, especially on lower-end devices.",
          "analysisPoints": [
            "Correct definition of code splitting.",
            "Ability to articulate multiple performance benefits.",
            "Understanding of how it impacts user experience and resource utilization."
          ],
          "keyConcepts": [
            "Code splitting",
            "Performance optimization",
            "Lazy loading",
            "Bundle size",
            "Caching"
          ],
          "evaluationCriteria": [
            "Clarity and completeness of explanation.",
            "Identification of all key benefits."
          ],
          "example": null,
          "tags": [
            "Module Bundler",
            "Performance",
            "Optimization",
            "Code Splitting"
          ],
          "prerequisites": [
            "Web Performance",
            "Bundling"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_tree_shaking_definition_flashcard",
          "topic": "Module Bundlers",
          "level": "easy",
          "type": "flashcard",
          "question": "Define 'tree-shaking' in the context of JavaScript module bundling.",
          "answer": "Tree-shaking (also known as 'dead code elimination') is an optimization technique used by module bundlers to remove unused code from the final bundle. It relies on the static analysis capabilities of ES Modules to determine which `import` statements are actually used, discarding any code that is imported but never executed.",
          "analysisPoints": [
            "Correct definition.",
            "Mention of ES Modules' role in enabling it.",
            "Reference to 'dead code elimination'."
          ],
          "keyConcepts": [
            "Tree-shaking",
            "Dead code elimination",
            "ES Modules",
            "Optimization",
            "Bundle size"
          ],
          "evaluationCriteria": [
            "Concise and accurate definition."
          ],
          "example": null,
          "tags": [
            "Module Bundler",
            "Flashcard",
            "Optimization",
            "Tree-shaking"
          ],
          "prerequisites": [
            "JavaScript Modules"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_webpack_entry_output",
          "topic": "Webpack",
          "level": "easy",
          "type": "flashcard",
          "question": "In Webpack, what is the purpose of the `entry` and `output` configurations?",
          "answer": "`entry` specifies the starting point(s) of your application, from which Webpack begins building its internal dependency graph. `output` specifies where Webpack should emit the bundled files and how to name them.",
          "analysisPoints": [
            "Correctly identifies the role of `entry` as the starting point.",
            "Correctly identifies the role of `output` for bundle location and naming."
          ],
          "keyConcepts": [
            "Webpack configuration",
            "Entry point",
            "Output bundle"
          ],
          "evaluationCriteria": [
            "Concise and accurate definitions for both terms."
          ],
          "example": null,
          "tags": [
            "Webpack",
            "Flashcard",
            "Configuration"
          ],
          "prerequisites": [
            "Webpack Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_webpack_loaders_vs_plugins",
          "topic": "Webpack",
          "level": "medium",
          "type": "open",
          "question": "Distinguish between 'loaders' and 'plugins' in Webpack, providing an example use case for each.",
          "answer": "**Loaders** in Webpack are used to transform files of different types (non-JavaScript assets) into valid modules that can be consumed by your application and added to the dependency graph. Webpack only understands JavaScript natively, so loaders are crucial for processing other file types.\n*   **Example**: `babel-loader` transforms ES6+ JavaScript into ES5. `css-loader` and `style-loader` process CSS files.\n\n**Plugins** in Webpack are more powerful and can perform a wider range of tasks, hooking into various stages of Webpack's compilation process. They can modify how bundles are optimized, manage assets, inject environment variables, etc.\n*   **Example**: `HtmlWebpackPlugin` generates an HTML file and automatically injects your bundled scripts. `MiniCssExtractPlugin` extracts CSS into separate files.",
          "analysisPoints": [
            "Clear definition of loaders and their purpose (transforming modules).",
            "Clear definition of plugins and their broader capabilities (hooking into build process).",
            "Relevant and accurate examples for both.",
            "Understanding of Webpack's internal module handling."
          ],
          "keyConcepts": [
            "Webpack loaders",
            "Webpack plugins",
            "Module transformation",
            "Build process hooks",
            "Dependency graph"
          ],
          "evaluationCriteria": [
            "Accuracy of definitions.",
            "Relevance and clarity of examples.",
            "Ability to differentiate between their distinct roles."
          ],
          "example": null,
          "tags": [
            "Webpack",
            "Loaders",
            "Plugins",
            "Core Concepts"
          ],
          "prerequisites": [
            "Webpack Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_webpack_babel_loader_purpose",
          "topic": "Webpack",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following Webpack `module.rules` configuration:\n\n```javascript\n{\n  test: /\\.js$/,\n  exclude: /node_modules/,\n  use: {\n    loader: 'babel-loader',\n    options: {\n      presets: ['@babel/preset-env', '@babel/preset-react']\n    }\n  }\n}\n```\n\nWhat is the primary purpose of `babel-loader` with these presets in a Webpack setup?",
          "answer": "To transpile modern JavaScript (ES6+) and JSX into older, browser-compatible JavaScript (ES5).",
          "options": [
            "To minify JavaScript files for production.",
            "To transpile modern JavaScript (ES6+) and JSX into older, browser-compatible JavaScript (ES5).",
            "To convert CSS files into JavaScript modules.",
            "To resolve Node.js modules from `node_modules`."
          ],
          "analysisPoints": [
            "Understanding of `babel-loader`'s function.",
            "Knowledge of `@babel/preset-env` and `@babel/preset-react`'s roles.",
            "Distinction between transpilation and other build processes (minification, CSS handling, module resolution)."
          ],
          "keyConcepts": [
            "Webpack loaders",
            "Babel",
            "Transpilation",
            "ES6+",
            "JSX"
          ],
          "evaluationCriteria": [
            "Correct identification of `babel-loader`'s primary role.",
            "Exclusion of incorrect options that describe other tools or processes."
          ],
          "example": "When a `.js` file containing `const greeting = () => <p>Hello</p>;` is processed by this `babel-loader` configuration, it would be transformed into equivalent ES5 JavaScript and `React.createElement` calls, making it runnable in older browsers that don't support arrow functions or JSX directly.",
          "tags": [
            "Webpack",
            "Loader",
            "Babel",
            "Transpilation",
            "MCQ"
          ],
          "prerequisites": [
            "Webpack Loaders",
            "Babel Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_webpack_module_rules_order",
          "topic": "Webpack",
          "level": "medium",
          "type": "code",
          "question": "Suppose you have a `.less` file that needs to be compiled to CSS, then processed by `postcss-loader` for vendor prefixes, and finally injected into the DOM by `style-loader`. Write the `module.rules` entry for this scenario, ensuring the correct order of loaders.",
          "answer": "```javascript\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.less$/,\n        use: [\n          'style-loader', // 3. Injects CSS into the DOM\n          'css-loader',   // 2. Interprets @import and url() like import/require()\n          'postcss-loader', // 1. Processes CSS with PostCSS (e.g., autoprefixer)\n          'less-loader'   // 0. Compiles Less to CSS\n        ]\n      }\n    ]\n  }\n  // ...\n};\n```",
          "options": [],
          "analysisPoints": [
            "Correct `test` regex for `.less` files.",
            "Correct `use` array for multiple loaders.",
            "Understanding that loaders in `use` are applied from right-to-left (or bottom-to-top in array).",
            "Knowledge of typical CSS loader chain (Less -> PostCSS -> CSS Loader -> Style Loader)."
          ],
          "keyConcepts": [
            "Webpack loaders",
            "Loader order",
            "CSS pre-processors",
            "Asset processing"
          ],
          "evaluationCriteria": [
            "Syntactic correctness of the rule.",
            "Logical order of loaders."
          ],
          "example": "The key here is the order in the `use` array. `less-loader` runs first to convert `.less` to CSS. Then `postcss-loader` applies transformations like autoprefixing. `css-loader` interprets `@import` and `url()` statements, and finally `style-loader` takes the resulting CSS and injects it into the HTML `<head>` tag at runtime.",
          "tags": [
            "Webpack",
            "Loaders",
            "CSS",
            "Code Example"
          ],
          "prerequisites": [
            "Webpack Loaders"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_htmlwebpackplugin_purpose_flashcard",
          "topic": "Webpack",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main function of the `HtmlWebpackPlugin` in a Webpack configuration?",
          "answer": "The `HtmlWebpackPlugin` simplifies the creation of HTML files to serve your Webpack bundles. It can generate an HTML file from scratch or use a template, and it automatically injects your bundled JavaScript files (and optionally CSS) into the generated HTML, removing the need for manual `<script>` and `<link>` tag management.",
          "analysisPoints": [
            "Identification of its core purpose: HTML generation and script injection.",
            "Understanding its role in simplifying the setup process."
          ],
          "keyConcepts": [
            "Webpack plugins",
            "HTML generation",
            "Script injection",
            "Automation"
          ],
          "evaluationCriteria": [
            "Concise and accurate definition."
          ],
          "example": null,
          "tags": [
            "Webpack",
            "Flashcard",
            "Plugins",
            "HTML"
          ],
          "prerequisites": [
            "Webpack Plugins"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_webpack_mode_impact_mcq",
          "topic": "Webpack",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is TRUE regarding Webpack's `mode` configuration (e.g., `development`, `production`)?",
          "answer": "Setting `mode: 'production'` enables built-in optimizations like minification and tree-shaking by default.",
          "options": [
            "Setting `mode: 'development'` optimizes the bundle for smallest file size.",
            "The `mode` setting primarily affects the type of module resolution (CommonJS vs. ES Modules).",
            "Setting `mode: 'production'` enables built-in optimizations like minification and tree-shaking by default.",
            "The `mode` configuration is only relevant for the `webpack-dev-server` and has no impact on the final build output."
          ],
          "analysisPoints": [
            "Understanding the impact of `mode` on Webpack's built-in optimizations.",
            "Distinguishing between `development` and `production` modes' goals.",
            "Dispelling common misconceptions about `mode`'s effects (e.g., on module resolution or only dev server)."
          ],
          "keyConcepts": [
            "Webpack mode",
            "Development mode",
            "Production mode",
            "Optimization",
            "Minification",
            "Tree-shaking"
          ],
          "evaluationCriteria": [
            "Correct identification of `production` mode's effects.",
            "Ability to differentiate from incorrect statements."
          ],
          "example": "In `production` mode, Webpack automatically applies `UglifyJsPlugin` (or a similar minifier) and sets certain environment variables for performance, leading to a smaller, more performant bundle. In `development` mode, it prioritizes speed and helpful debugging information, often foregoing aggressive minification.",
          "tags": [
            "Webpack",
            "Configuration",
            "Optimization",
            "MCQ"
          ],
          "prerequisites": [
            "Webpack Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rollup_es_modules_focus",
          "topic": "Rollup",
          "level": "medium",
          "type": "open",
          "question": "Rollup is known for its strong focus on ES Modules. Explain why this focus is beneficial, particularly for features like tree-shaking.",
          "answer": "Rollup's strong focus on ES Modules (`import`/`export`) is beneficial because ES Modules are static. This means their imports and exports can be determined at build time without executing the code. This static nature allows Rollup to perform highly effective **tree-shaking (dead code elimination)** and **scope hoisting**.\n\nFor tree-shaking, Rollup can precisely analyze the dependency graph and identify exactly which exports are imported and used by other modules. Any code that is imported but never referenced, or any entire modules that are never imported, can be safely removed from the final bundle, leading to significantly smaller output sizes, especially for libraries. CommonJS modules, being dynamic, make such static analysis and efficient tree-shaking much harder.",
          "analysisPoints": [
            "Understanding of ES Modules' static nature.",
            "Connection between static analysis and tree-shaking.",
            "Explanation of how tree-shaking benefits bundle size.",
            "Implicit understanding of CommonJS limitations for static analysis."
          ],
          "keyConcepts": [
            "Rollup",
            "ES Modules",
            "Static analysis",
            "Tree-shaking",
            "Scope hoisting",
            "Bundle size optimization"
          ],
          "evaluationCriteria": [
            "Clarity on static nature of ES Modules.",
            "Direct link to tree-shaking efficacy.",
            "Mention of bundle size benefits."
          ],
          "example": null,
          "tags": [
            "Rollup",
            "ES Modules",
            "Tree-shaking",
            "Optimization"
          ],
          "prerequisites": [
            "JavaScript Modules",
            "ES6+"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_rollup_tree_shaking",
          "topic": "Rollup",
          "level": "hard",
          "type": "code",
          "question": "Consider the following JavaScript code. If this code were bundled with Rollup, which functions would likely be included in the final production bundle, assuming aggressive tree-shaking, and why?\n\n`src/utils.js`:\n```javascript\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function subtract(a, b) {\n  console.log('Subtracting...');\n  return a - b;\n}\n\nexport function multiply(a, b) {\n  return a * b;\n}\n\nfunction divide(a, b) { // Not exported\n  return a / b;\n}\n```\n\n`src/main.js`:\n```javascript\nimport { add, multiply } from './utils.js';\n\nconst result1 = add(5, 3);\nconst result2 = multiply(4, 2);\n\nconsole.log(result1, result2);\n```",
          "answer": "Functions likely included: `add` and `multiply`.\n\n**Explanation:**\nRollup's tree-shaking works by statically analyzing ES module imports and exports. In `src/main.js`, only `add` and `multiply` are explicitly imported from `src/utils.js`. Because `subtract` is imported but never used, and `divide` is not exported at all, Rollup's tree-shaking mechanism will identify these as dead code and exclude them from the final bundle. This leads to a smaller, more optimized output.",
          "options": [],
          "analysisPoints": [
            "Understanding of tree-shaking principles.",
            "Ability to trace module imports and usage.",
            "Distinction between exported and unexported functions for tree-shaking.",
            "Recognition that unused imported functions are eliminated."
          ],
          "keyConcepts": [
            "Rollup",
            "Tree-shaking",
            "ES Modules",
            "Dead code elimination",
            "Static analysis"
          ],
          "evaluationCriteria": [
            "Correct identification of included functions.",
            "Accurate explanation of why specific functions are included/excluded based on tree-shaking logic."
          ],
          "example": null,
          "tags": [
            "Rollup",
            "Tree-shaking",
            "Code Example",
            "Optimization"
          ],
          "prerequisites": [
            "Rollup Basics",
            "ES Modules"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_rollup_output_formats_mcq",
          "topic": "Rollup",
          "level": "medium",
          "type": "mcq",
          "question": "Which Rollup output format is typically used for a JavaScript library that needs to be consumed directly in a browser via a `<script>` tag and wrap its code in an Immediately Invoked Function Expression (IIFE)?",
          "answer": "`iife`",
          "options": [
            "`esm`",
            "`cjs`",
            "`umd`",
            "`iife`"
          ],
          "analysisPoints": [
            "Knowledge of Rollup's `output.format` options.",
            "Understanding of the purpose and structure of different module formats (IIFE, ESM, CJS, UMD).",
            "Ability to match a use case to the appropriate format."
          ],
          "keyConcepts": [
            "Rollup output formats",
            "IIFE",
            "ES Modules",
            "CommonJS",
            "UMD",
            "Library distribution"
          ],
          "evaluationCriteria": [
            "Correct identification of the `iife` format for the specified use case."
          ],
          "example": "The `iife` format (Immediately Invoked Function Expression) wraps the bundled code in a function that executes immediately. This is suitable for adding a library to a global scope in a browser environment, preventing variable leaks and ensuring the code runs upon loading without requiring specific module loaders.",
          "tags": [
            "Rollup",
            "Output Format",
            "IIFE",
            "Library Development",
            "MCQ"
          ],
          "prerequisites": [
            "JavaScript Module Formats"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_webpack_vs_rollup_comparison",
          "topic": "Webpack vs. Rollup",
          "level": "hard",
          "type": "open",
          "question": "Compare Webpack and Rollup, highlighting their strengths and weaknesses, and suggest typical use cases where one might be preferred over the other.",
          "answer": "**Webpack:**\n*   **Strengths**: Extremely versatile, robust for complex Single Page Applications (SPAs) with many assets (JS, CSS, images, fonts), excellent Hot Module Replacement (HMR) for development, mature ecosystem with vast loaders/plugins, supports dynamic imports and code splitting well.\n*   **Weaknesses**: Can be more complex to configure, especially for beginners. Output bundles for libraries can sometimes be larger due to wrapping each module in a function.\n*   **Use Cases**: Large-scale SPAs (e.g., React, Angular, Vue applications), projects requiring extensive asset management, code splitting, and a rich development experience.\n\n**Rollup:**\n*   **Strengths**: Produces highly optimized, smaller bundles, especially for libraries, due to superior tree-shaking and scope hoisting (thanks to its ES Modules-first approach). Simpler configuration for library builds. Supports various output formats (IIFE, CJS, ESM, UMD).\n*   **Weaknesses**: Less focus on HMR or dev server features compared to Webpack. Can be less suitable for complex SPAs with dynamic imports or numerous non-JavaScript assets without more intricate plugin setups.\n*   **Use Cases**: JavaScript libraries, component libraries, frameworks (e.g., React, Vue, Svelte use Rollup for their core builds), simple applications where minimal bundle size is critical.",
          "analysisPoints": [
            "Comprehensive comparison of strengths and weaknesses for both tools.",
            "Identification of their primary design philosophies.",
            "Accurate suggestion of typical use cases based on their strengths.",
            "Mention of key features like HMR, tree-shaking, configuration complexity."
          ],
          "keyConcepts": [
            "Webpack",
            "Rollup",
            "Module bundler comparison",
            "SPA",
            "Library development",
            "Tree-shaking",
            "HMR",
            "Configuration complexity"
          ],
          "evaluationCriteria": [
            "Balanced and detailed comparison.",
            "Clear distinction in typical use cases.",
            "Accuracy of listed features/downsides."
          ],
          "example": null,
          "tags": [
            "Webpack",
            "Rollup",
            "Comparison",
            "Module Bundler",
            "Frontend Architecture"
          ],
          "prerequisites": [
            "Webpack",
            "Rollup"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_scope_hoisting_flashcard",
          "topic": "Rollup",
          "level": "medium",
          "type": "flashcard",
          "question": "What is 'scope hoisting' in the context of module bundling, and which bundler mentioned heavily leverages it?",
          "answer": "Scope hoisting (also known as 'module concatenation' or 'hoisting') is an optimization technique where multiple modules are combined into a single function scope instead of being wrapped in separate function closures. This reduces overhead, leading to smaller bundle sizes and faster runtime execution because the JavaScript engine has less scope hierarchy to traverse. Rollup heavily leverages scope hoisting due to its ES Modules-first approach, which allows for static analysis necessary for this optimization.",
          "analysisPoints": [
            "Correct definition of scope hoisting.",
            "Understanding of its benefits (smaller size, faster execution).",
            "Identification of Rollup as a primary proponent.",
            "Connection to ES Modules and static analysis."
          ],
          "keyConcepts": [
            "Scope hoisting",
            "Module concatenation",
            "Optimization",
            "Rollup",
            "ES Modules"
          ],
          "evaluationCriteria": [
            "Concise and accurate definition.",
            "Correctly links it to Rollup."
          ],
          "example": null,
          "tags": [
            "Rollup",
            "Flashcard",
            "Optimization",
            "Scope Hoisting"
          ],
          "prerequisites": [
            "JavaScript Scopes",
            "Module Bundling"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_grunt_vs_webpack_flashcard",
          "topic": "Build Tools Comparison",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the fundamental difference in purpose between Grunt and Webpack?",
          "answer": "Grunt is a task runner focused on automating arbitrary development tasks (like linting, minifying). Webpack is a module bundler focused on building a dependency graph and bundling application modules (JS, CSS, etc.) into optimized assets for deployment.",
          "analysisPoints": [
            "Clear distinction between task automation and module bundling/asset compilation.",
            "Identification of each tool's primary role."
          ],
          "keyConcepts": [
            "Grunt",
            "Webpack",
            "Task Runner",
            "Module Bundler",
            "Purpose comparison"
          ],
          "evaluationCriteria": [
            "Concise and accurate distinction."
          ],
          "example": null,
          "tags": [
            "Grunt",
            "Webpack",
            "Comparison",
            "Flashcard"
          ],
          "prerequisites": [
            "Basic Build Tools"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_bundler_loader_plugin_mcq",
          "topic": "Webpack Concepts",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements accurately describes the role of a Webpack Loader?",
          "answer": "A Webpack Loader transforms non-JavaScript files into modules that Webpack can process.",
          "options": [
            "A Webpack Loader is used to optimize the overall bundle size by removing unused code.",
            "A Webpack Loader defines the entry point(s) of an application.",
            "A Webpack Loader performs a wider range of tasks, like asset management or environment injection, by hooking into the compilation lifecycle.",
            "A Webpack Loader transforms non-JavaScript files into modules that Webpack can process."
          ],
          "analysisPoints": [
            "Correct identification of Loader's purpose (transformation).",
            "Distinction from other Webpack concepts like Plugins (broader tasks), Entry (start point), and Optimizations (overall bundle).",
            "Understanding that Webpack inherently understands only JS."
          ],
          "keyConcepts": [
            "Webpack Loader",
            "Transformation",
            "Module processing",
            "Webpack internals"
          ],
          "evaluationCriteria": [
            "Accurate description of a Loader's function.",
            "Rejection of descriptions for other Webpack components."
          ],
          "example": "For instance, `css-loader` reads a `.css` file and transforms it into a JavaScript module that exports the CSS as a string, allowing it to be included in the Webpack dependency graph. Without a loader, Webpack would throw an error if it encountered an `import 'style.css'` statement.",
          "tags": [
            "Webpack",
            "Loader",
            "MCQ",
            "Core Concepts"
          ],
          "prerequisites": [
            "Webpack Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_grunt_css_minification",
          "title": "Automate CSS Minification with Grunt",
          "description": "\nAs a frontend developer, you need to set up a Grunt task to automatically minify CSS files for production deployment. Your task is to:\n\n1.  Set up a `Gruntfile.js`.\n2.  Install the necessary Grunt plugin for CSS minification (e.g., `grunt-contrib-cssmin`).\n3.  Configure a `cssmin` task to take an input CSS file from `src/css/styles.css` and output a minified version to `dist/css/styles.min.css`.\n4.  Create a `default` Grunt task that runs your `cssmin` task.\n5.  (Optional but recommended for testing) Add a `watch` task that triggers `cssmin` when `src/css/styles.css` changes.\n\nYour solution should demonstrate correct Grunt configuration syntax and plugin usage.\n",
          "difficulty": "medium",
          "startingCode": "// Gruntfile.js\nmodule.exports = function(grunt) {\n  // 1. Initialize Grunt configuration\n  grunt.initConfig({\n    // 2. Configure the cssmin task here\n    // cssmin: {\n    //   options: { /* ... */ },\n    //   dist: {\n    //     files: { /* ... */ }\n    //   }\n    // },\n    // Optional: watch configuration\n    // watch: { /* ... */ }\n  });\n\n  // 3. Load Grunt plugins here\n  // grunt.loadNpmTasks('...');\n\n  // 4. Register the default task here\n  // grunt.registerTask('default', ['...']);\n};\n",
          "solutionCode": "// Gruntfile.js\nmodule.exports = function(grunt) {\n  // Project configuration.\n  grunt.initConfig({\n    cssmin: {\n      options: {\n        level: {\n          1: {\n            // Add more aggressive minification options here if needed\n            // For example, removing comments, optimizing colors etc.\n          }\n        }\n      },\n      dist: {\n        files: {\n          'dist/css/styles.min.css': 'src/css/styles.css'\n        }\n      }\n    },\n    watch: {\n      css: {\n        files: ['src/css/**/*.css'],\n        tasks: ['cssmin'],\n        options: {\n          spawn: false // For faster reloads with watch\n        }\n      }\n    }\n  });\n\n  // Load Grunt plugins.\n  grunt.loadNpmTasks('grunt-contrib-cssmin');\n  grunt.loadNpmTasks('grunt-contrib-watch');\n\n  // Register default task(s).\n  grunt.registerTask('default', ['cssmin', 'watch']);\n};\n",
          "testCases": [
            "Run `npm install grunt grunt-contrib-cssmin grunt-contrib-watch` in a new project.",
            "Create `src/css/styles.css` with some unminified CSS.",
            "Run `grunt` from the terminal.",
            "Verify `dist/css/styles.min.css` is created and contains minified CSS.",
            "Modify `src/css/styles.css` and verify `dist/css/styles.min.css` updates automatically when `grunt watch` is running."
          ],
          "hints": [
            "Remember to install `grunt` globally or locally, and then specific plugins using `npm install --save-dev`.",
            "The `files` object in Grunt configuration uses a `destination: source` mapping.",
            "For the `watch` task, the `files` property should be a glob pattern (e.g., `**/*.css`) and `tasks` an array of Grunt task names."
          ],
          "tags": [
            "Grunt",
            "Task Automation",
            "CSS",
            "Minification",
            "Build Tool"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "Node.js",
            "npm",
            "Grunt Basics"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Grunt Configuration",
            "Grunt Plugins",
            "Frontend Performance"
          ]
        },
        {
          "id": "task_webpack_react_app_setup",
          "title": "Configure Webpack for a Basic React Application",
          "description": "\nYour task is to set up a minimal Webpack configuration for a simple React application. This configuration should:\n\n1.  Define `src/index.js` as the entry point.\n2.  Output the bundled JavaScript to `dist/bundle.js`.\n3.  Transpile JavaScript files (including JSX) using `babel-loader` with `@babel/preset-env` and `@babel/preset-react`. Ensure `node_modules` are excluded.\n4.  Process CSS files (`.css`) using `style-loader` and `css-loader`.\n5.  Generate an `index.html` file in the `dist` directory from a template (`src/index.html`) and automatically inject the bundled JavaScript.\n6.  Set the Webpack `mode` to 'development' for better debugging.\n\nProvide the `webpack.config.js` and placeholder `package.json` with scripts.\n",
          "difficulty": "medium",
          "startingCode": "const path = require('path');\n// const HtmlWebpackPlugin = require('html-webpack-plugin'); // Don't forget to import\n\nmodule.exports = {\n  // 1. Define entry\n  // entry: '',\n\n  // 2. Define output\n  // output: {\n  //   path: path.resolve(__dirname, 'dist'),\n  //   filename: ''\n  // },\n\n  // 3. Define module rules (loaders)\n  // module: {\n  //   rules: [\n  //     // Rule for JS/JSX\n  //     // Rule for CSS\n  //   ]\n  // },\n\n  // 4. Define plugins\n  // plugins: [\n  //   // Add HtmlWebpackPlugin here\n  // ],\n\n  // 5. Set mode\n  // mode: ''\n};\n",
          "solutionCode": "const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react']\n          }\n        }\n      },\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  mode: 'development',\n  devServer: {\n    static: { // Changed from 'contentBase' in older versions\n      directory: path.join(__dirname, 'dist'),\n    },\n    compress: true,\n    port: 9000,\n    open: true, // Open browser automatically\n  },\n};\n\n/* Example package.json scripts:\n{\n  \"name\": \"webpack-react-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"webpack serve --open\",\n    \"build\": \"webpack --mode production\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.23.3\",\n    \"@babel/preset-env\": \"^7.23.3\",\n    \"@babel/preset-react\": \"^7.23.3\",\n    \"babel-loader\": \"^9.1.3\",\n    \"css-loader\": \"^6.8.1\",\n    \"html-webpack-plugin\": \"^5.5.3\",\n    \"style-loader\": \"^3.3.3\",\n    \"webpack\": \"^5.89.0\",\n    \"webpack-cli\": \"^5.1.4\",\n    \"webpack-dev-server\": \"^4.15.1\"\n  },\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\"\n  }\n}\n*/",
          "testCases": [
            "Create project structure: `src/index.js`, `src/index.html`, `src/App.js`, `src/styles.css`.",
            "Populate `src/index.js` with basic React render, `src/App.js` with a simple component.",
            "Add some CSS to `src/styles.css` and import it in `index.js`.",
            "Run `npm install` for all devDependencies and dependencies.",
            "Run `npm run build` and check `dist/bundle.js` and `dist/index.html`.",
            "Run `npm start` and verify the app serves correctly with hot reloading."
          ],
          "hints": [
            "Remember that Webpack `module.rules.use` array applies loaders from right to left.",
            "The `test` property in module rules uses a regular expression to match file extensions.",
            "For `HtmlWebpackPlugin`, ensure your `src/index.html` is a valid HTML template.",
            "Check `webpack-dev-server` configuration for the `static` option instead of `contentBase` for newer Webpack versions."
          ],
          "tags": [
            "Webpack",
            "React",
            "Bundling",
            "Configuration",
            "Frontend Frameworks"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "JavaScript Modules",
            "React Basics",
            "Node.js",
            "npm"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Webpack Loaders",
            "Webpack Plugins",
            "Babel Transpilation",
            "React Ecosystem"
          ]
        },
        {
          "id": "task_webpack_image_handling",
          "title": "Configure Webpack to Handle Image Assets",
          "description": "\nExtend the previous Webpack configuration (or start a new minimal one) to properly handle image assets (`.png`, `.jpg`, `.jpeg`, `.gif`, `.svg`). Your goal is to:\n\n1.  Configure Webpack to import image files.\n2.  Use Webpack's built-in asset modules (Asset Modules) to serve images, either as inline base64 data (for small images) or as separate files (for large images).\n3.  Ensure that images imported in JavaScript or CSS are correctly processed and included in the output bundle or `dist` folder.\n\nYour `webpack.config.js` should demonstrate the use of `asset/resource` and `asset/inline` or `asset` module types based on file size thresholds.\n",
          "difficulty": "medium",
          "startingCode": "const path = require('path');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n    assetModuleFilename: 'images/[name][ext][query]' // Optional: output path for assets\n  },\n  module: {\n    rules: [\n      // Existing rules for JS/CSS...\n      // Add rule for images here\n      // {\n      //   test: /\\.(png|svg|jpg|jpeg|gif)$/i,\n      //   type: 'asset',\n      //   parser: { dataUrlCondition: { maxSize: 8 * 1024 } } // 8kb limit\n      // },\n    ]\n  }\n  // ... other configs\n};\n\n/* Example usage in src/index.js:\nimport imageUrl from './assets/my-image.png';\nconst img = document.createElement('img');\nimg.src = imageUrl;\ndocument.body.appendChild(img);\n*/\n",
          "solutionCode": "const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n    clean: true, // Cleans the output directory before each build\n    assetModuleFilename: 'images/[name][ext][query]' // Specifies output path for assets\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react']\n          }\n        }\n      },\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      },\n      {\n        test: /\\.(png|svg|jpg|jpeg|gif)$/i, // Regex to match common image formats\n        type: 'asset', // Use Webpack 5's Asset Modules\n        parser: {\n          dataUrlCondition: {\n            maxSize: 8 * 1024 // 8kb - assets smaller than this will be inlined as data URIs\n          }\n        },\n        generator: { // Optional: Customize output filename of resource assets\n          filename: 'assets/images/[name].[hash:8][ext]',\n        },\n      },\n      {\n        test: /\\.(woff|woff2|eot|ttf|otf)$/i, // Rule for fonts\n        type: 'asset/resource',\n      },\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  mode: 'development',\n  devServer: {\n    static: {\n      directory: path.join(__dirname, 'dist'),\n    },\n    compress: true,\n    port: 9000,\n    open: true,\n  },\n};\n\n/* Example package.json scripts (same as previous task, just add a few more devDependencies):\n  \"devDependencies\": {\n    // ... (previous devDependencies)\n    \"file-loader\": \"^6.2.0\", // Not strictly needed with asset modules, but useful for context\n    \"url-loader\": \"^4.1.1\"   // Not strictly needed with asset modules, but useful for context\n  }\n*/",
          "testCases": [
            "Create `src/assets/small-image.png` (e.g., < 8KB) and `src/assets/large-image.jpg` (e.g., > 8KB).",
            "In `src/index.js`, import both images and add them to the DOM (e.g., `<img>` tags).",
            "Add a CSS rule that uses `background-image: url(...)` with one of the images.",
            "Run `npm run build`.",
            "Verify that `small-image.png` is inlined as a data URI in `bundle.js` or `index.html`.",
            "Verify that `large-image.jpg` is output as a separate file in `dist/images/` (or `dist/assets/images/`) and its path is correctly referenced in the bundle.",
            "Verify images loaded via CSS are also handled correctly."
          ],
          "hints": [
            "Webpack 5 introduced 'Asset Modules' (`type: 'asset'`, `type: 'asset/resource'`, `type: 'asset/inline'`) which replace `file-loader` and `url-loader`.",
            "Use `type: 'asset'` combined with `parser.dataUrlCondition.maxSize` to automatically switch between inlining and emitting separate files.",
            "The `output.assetModuleFilename` property can customize the output filename and path for emitted assets."
          ],
          "tags": [
            "Webpack",
            "Assets",
            "Images",
            "Configuration",
            "Loaders",
            "Optimization"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "Webpack Configuration",
            "Frontend Assets"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Asset Management",
            "Performance Optimization",
            "Webpack 5 Features"
          ]
        },
        {
          "id": "task_rollup_library_build",
          "title": "Build a Simple JavaScript Utility Library with Rollup",
          "description": "\nYour task is to use Rollup to build a small JavaScript utility library that exports multiple functions. The library should:\n\n1.  Have `src/main.js` as its entry point.\n2.  Export at least three functions from `src/utils.js` (e.g., `add`, `subtract`, `isEven`).\n3.  Consume these functions in `src/main.js` (but not necessarily all of them to demonstrate tree-shaking).\n4.  Output a bundled file named `dist/my-library.js`.\n5.  Use the `iife` (Immediately Invoked Function Expression) format for browser compatibility.\n6.  Transpile ES6+ code using `@rollup/plugin-babel` with `@babel/preset-env`.\n7.  Include `@rollup/plugin-node-resolve` to handle any potential `node_modules` imports (even if minimal for this task).\n\nYour solution should provide the `rollup.config.js` and example source files.\n",
          "difficulty": "medium",
          "startingCode": "import resolve from '@rollup/plugin-node-resolve';\nimport babel from '@rollup/plugin-babel';\n\nexport default {\n  // 1. Define input\n  // input: '',\n\n  // 2. Define output\n  // output: {\n  //   file: '',\n  //   format: ''\n  // },\n\n  // 3. Define plugins\n  // plugins: [\n  //   // Add resolve() and babel() here\n  // ]\n};\n\n// Example src/utils.js\n// export function add(a, b) { /* ... */ }\n// export function subtract(a, b) { /* ... */ }\n\n// Example src/main.js\n// import { add } from './utils';\n// console.log(add(1, 2));\n",
          "solutionCode": "import resolve from '@rollup/plugin-node-resolve';\nimport babel from '@rollup/plugin-babel';\n\nexport default {\n  input: 'src/main.js',\n  output: {\n    file: 'dist/my-library.js',\n    format: 'iife', // For browser compatibility\n    name: 'MyLibrary', // Global variable name if format is iife/umd\n    sourcemap: true, // Generate sourcemap for debugging\n  },\n  plugins: [\n    resolve(), // Allows Rollup to find modules in node_modules\n    babel({\n      babelHelpers: 'bundled', // Ensures babel helpers are included in the bundle\n      presets: ['@babel/preset-env'], // Transpiles to target environment\n      exclude: 'node_modules/**', // Exclude node_modules from transpilation\n    }),\n  ],\n};\n\n/* Example Project Structure and Files:\n\n// package.json (devDependencies):\n//   \"@babel/core\": \"^7.23.3\",\n//   \"@babel/preset-env\": \"^7.23.3\",\n//   \"@rollup/plugin-babel\": \"^6.0.4\",\n//   \"@rollup/plugin-node-resolve\": \"^15.2.3\",\n//   \"rollup\": \"^4.6.0\"\n// Scripts:\n//   \"build\": \"rollup -c\"\n\n// src/utils.js\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function subtract(a, b) {\n  // This function might be tree-shaken if not imported\n  console.log('Subtracting ' + a + ' and ' + b);\n  return a - b;\n}\n\nexport function multiply(a, b) {\n  return a * b;\n}\n\n// src/main.js\nimport { add, multiply } from './utils.js';\n\nconst sum = add(10, 5);\nconst product = multiply(10, 5);\n\nconsole.log('Sum:', sum);\nconsole.log('Product:', product);\n\n// A function that is never called, demonstrating potential for tree-shaking\nexport function unusedFunction() {\n  console.log('This function is not used.');\n}\n\n*/",
          "testCases": [
            "Create `src/utils.js` and `src/main.js` as described, ensuring `main.js` only imports a subset of functions from `utils.js`.",
            "Run `npm install` for required Rollup and Babel plugins.",
            "Run `rollup -c` from the terminal (assuming `rollup` is in `package.json` scripts).",
            "Verify `dist/my-library.js` is created and is in `iife` format.",
            "Examine `dist/my-library.js` to confirm that `subtract` (if not imported by `main.js`) and `unusedFunction` (if not called) are *not* present in the final bundle, demonstrating tree-shaking."
          ],
          "hints": [
            "The `output.name` property is crucial for `iife` and `umd` formats, defining the global variable name.",
            "Ensure `babelHelpers: 'bundled'` is set for `@rollup/plugin-babel` if you want Babel's helper functions included in your bundle.",
            "To run Rollup from the command line, typically you'd add `\"build\": \"rollup -c\"` to your `package.json` scripts."
          ],
          "tags": [
            "Rollup",
            "Library Development",
            "Bundling",
            "ES Modules",
            "Tree-shaking",
            "Babel"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "JavaScript Modules",
            "ES6+",
            "Node.js",
            "npm"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Rollup Configuration",
            "Tree-shaking",
            "ES Modules",
            "JavaScript Library Design"
          ]
        }
      ]
    }
  }
]