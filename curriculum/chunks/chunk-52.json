[
  {
    "id": "1b6683e1-07cd-482a-8295-68db72aa08ac",
    "startLine": 10600,
    "endLine": 10699,
    "processedDate": "2025-06-17T11:41:05.910Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_advanced_git_techniques",
          "title": "Advanced Git Techniques: Workflow, Hooks, and Submodules",
          "content": "## Git Workflow Best Practices\nEffective Git workflows are crucial for team collaboration and maintaining a clean, understandable project history. Adopting best practices can significantly improve code review, debugging, and overall development efficiency.\n\n### 1. Pull with rebase for cleaner history\nUsing `git pull --rebase` instead of a standard `git pull` (which performs a merge) ensures a linear project history. When you rebase, your local commits are temporarily put aside, the remote changes are fetched and applied, and then your local commits are reapplied on top. This avoids unnecessary merge commits, making the history easier to read and follow.\n\n### 2. Use branches for features and fixes\nBranching is fundamental in Git. Each new feature or bug fix should be developed on its own dedicated branch. This isolates changes, prevents conflicts with the main development line (e.g., `master`/`main`), and allows for concurrent development. Descriptive branch names (e.g., `feature/new-login`, `fix/header-alignment`, `bugfix/issue-123`) are essential for organization and clarity.\n\n### 3. Resolve merge conflicts properly\nConflicts occur when Git cannot automatically combine changes from different branches. Resolving them involves manually editing the conflicted files to combine the desired changes from both branches. After editing, the files must be staged (`git add`) and the merge committed (`git commit`). Understanding conflict markers (`<<<<<<<`, `=======`, `>>>>>>>`) is key.\n\n### 4. Use .gitignore for project-specific files\nThe `.gitignore` file specifies intentionally untracked files that Git should ignore. This is vital for keeping your repository clean by excluding generated files (e.g., `build/`, `dist/`), dependency directories (`node_modules/`), environment-specific configurations (`.env`), personal IDE settings (`.idea/`, `.vscode/`), and temporary files. A well-maintained `.gitignore` prevents irrelevant files from cluttering the repository and causing issues across different development environments.\n\n### 5. Commit atomically\nAtomic commits mean that each commit should represent a single, complete, logical change. For example, a commit might introduce a new feature, fix a single bug, or refactor a specific part of the code. This practice makes code reviews easier, simplifies reverting changes (if necessary), and provides a clear narrative of how the project evolves.\n\n## Git Hooks\nGit hooks are custom scripts that Git automatically executes before or after events like committing, pushing, or receiving commits. They are stored in the `.git/hooks` directory of a repository. Hooks allow developers and teams to automate tasks, enforce coding standards, and streamline workflows. While default hooks are examples, custom scripts can be written in any language (e.g., shell scripts, Python, Node.js).\n\nCommon Git hooks include:\n-   `pre-commit`: Runs *before* a commit is created. Often used to run linters, formatters, or tests to ensure code quality before it's even committed.\n-   `commit-msg`: Runs *after* a commit message has been provided but *before* the commit is finalized. Used to validate the format or content of commit messages (e.g., enforcing a specific prefix like `feat:`, `fix:`).\n-   `pre-push`: Runs *before* pushing to a remote repository. Can be used to run full test suites, build checks, or ensure that the local branch is up-to-date with the remote to prevent pushing breaking changes.\n\n## Git Submodules\nGit submodules allow you to embed one Git repository inside another as a subdirectory. This is useful when your project depends on a specific version of an external repository, and you want to manage that dependency directly within your main project. Submodules effectively pin the dependency to a specific commit, ensuring consistency across all development environments.\n\n### Key Submodule Commands:\n-   `git submodule add <repository-url> <path>`: Adds a new submodule. The specified repository will be cloned into the given path within your main repository.\n-   `git submodule init`: Initializes new submodules found in the `.gitmodules` file (which tracks submodule configurations). This command essentially registers the submodules.\n-   `git submodule update`: Fetches and checks out the correct commit for the submodules as recorded in the parent repository. This is crucial after cloning a repository with submodules or when a submodule's reference commit has been updated.\n-   `git clone --recurse-submodules <repository-url>`: Clones the main repository and automatically initializes and updates all submodules within it. This is the recommended way to clone a project that contains submodules.",
          "examples": [
            {
              "id": "example_git_workflow_1",
              "title": "Pull with Rebase",
              "code": "git checkout feature/my-feature\ngit add .\ngit commit -m \"Implement part of feature X\"\ngit pull --rebase origin main",
              "explanation": "This sequence demonstrates working on a feature branch, committing local changes, and then rebasing those changes on top of the latest 'main' branch updates from the 'origin' remote. This keeps the branch history linear and avoids a merge commit.",
              "language": "bash"
            },
            {
              "id": "example_git_workflow_2",
              "title": "Adding and Updating Git Submodules",
              "code": "# Add a new submodule\ngit submodule add https://github.com/example/my-library.git lib/my-library\n\n# Initialize and update all submodules after cloning a repo\ngit submodule init\ngit submodule update\n\n# Or clone with submodules directly\ngit clone --recurse-submodules https://github.com/my-org/my-project.git",
              "explanation": "These commands illustrate how to add a new submodule (linking an external repository into a sub-directory), and how to initialize and update existing submodules within a cloned repository. The `git clone --recurse-submodules` command streamlines the process for new clones.",
              "language": "bash"
            },
            {
              "id": "example_git_hooks_1",
              "title": "Basic pre-commit hook (Shell)",
              "code": "#!/bin/sh\n\n# Navigate to the .git/hooks directory for this file\n# Save this as .git/hooks/pre-commit and make it executable (chmod +x)\n\n# Example: Run linting before commit\necho \"Running pre-commit hook...\"\n\nnpm test -- --findRelatedTests $(git diff --cached --name-only)\n\nif [ $? -ne 0 ]; then\n  echo \"Tests failed. Aborting commit.\"\n  exit 1\nfi\n\n# Example: Prevent committing files with specific content (e.g., 'debugger;')\nif git diff --cached | grep -q 'debugger;'; then\n  echo \"ERROR: Found 'debugger;' statements. Please remove them before committing.\"\n  exit 1\nfi\n\necho \"Pre-commit hook finished successfully.\"\nexit 0",
              "explanation": "This shell script demonstrates a `pre-commit` hook. It first attempts to run relevant tests for staged files. If tests fail, the commit is aborted. It also checks for 'debugger;' statements, preventing commits that include them. This ensures basic code quality and prevents debugging remnants from entering the codebase.",
              "language": "bash"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "Git",
            "Version Control",
            "Workflow",
            "Branching",
            "Rebase",
            "Git Hooks",
            "Submodules",
            "Collaboration",
            "Best Practices"
          ],
          "technology": "Git",
          "prerequisites": [
            "Basic Git commands (add, commit, push, pull, checkout)"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "Team Collaboration",
            "Monorepos (Submodules)",
            "CI/CD Automation",
            "Code Quality Enforcement"
          ]
        },
        {
          "id": "theory_redux_selectors",
          "title": "Redux Selectors: Efficient State Access and Derived Data",
          "content": "## Redux Selectors\nSelectors are pure functions that take the Redux store's state as an argument and return a specific slice of that state or a computed, derived piece of data. They are a fundamental pattern in Redux applications for several reasons:\n\n### 1. Centralized Data Access Logic\nSelectors encapsulate the logic for extracting data from the Redux store. Instead of components directly digging into the state structure (e.g., `state.users.data.byId[userId]`), they can call a selector (e.g., `selectUserById(state, userId)`). This makes components simpler and less coupled to the exact shape of the state.\n\n### 2. Reusability\nOnce defined, a selector can be reused across multiple components or even other selectors. If the state structure changes, only the selector needs to be updated, not every component that uses that piece of data.\n\n### 3. Memoization for Performance Optimization\nOne of the most powerful features of selectors, especially when used with libraries like `reselect`, is memoization. Memoized selectors remember the last inputs and outputs. If the inputs to the selector haven't changed, it returns the previously computed result without re-executing its logic. This is critical for performance in React/Redux applications, as it prevents unnecessary re-renders of components that depend on derived data.\n\n### 4. Computing Derived Data\nSelectors are ideal for computing derived data that doesn't need to be stored directly in the Redux state. For example, filtering a list, summing values, or joining data from different parts of the state can all be done efficiently within a selector. This keeps the state minimal and normalized.\n\n### Key Characteristics of Good Selectors:\n-   **Pure Functions**: They should produce the same output for the same input and have no side effects.\n-   **Composable**: Small, focused selectors can be combined to create more complex ones.\n-   **Memoized**: For performance, especially when computing derived data or processing large state slices.",
          "examples": [
            {
              "id": "example_redux_selector_1",
              "title": "Basic Redux Selector",
              "code": "// selectors/userSelectors.js\nexport const selectUserList = (state) => state.users.list;\nexport const selectUserById = (state, userId) => \n  state.users.byId[userId];\n\n// components/UserDetail.js\nimport { useSelector } from 'react-redux';\nimport { selectUserById } from '../selectors/userSelectors';\n\nfunction UserDetail({ userId }) {\n  const user = useSelector(state => selectUserById(state, userId));\n  \n  if (!user) return <div>Loading...</div>;\n  \n  return (\n    <div>\n      <h2>{user.name}</h2>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n}",
              "explanation": "This example shows basic selectors for retrieving a list of users and a specific user by ID. Components use `useSelector` to get data via these selectors, centralizing state access logic and making components cleaner.",
              "language": "javascript"
            },
            {
              "id": "example_redux_selector_2",
              "title": "Memoized Selector with Reselect",
              "code": "import { createSelector } from 'reselect';\n\n// Input selectors\nconst getUsers = (state) => state.users.list;\nconst getActiveFilter = (state) => state.filters.active;\n\n// Memoized selector for filtered users\nexport const selectFilteredUsers = createSelector(\n  [getUsers, getActiveFilter],\n  (users, activeFilter) => {\n    if (activeFilter === 'all') {\n      return users;\n    }\n    return users.filter(user => user.status === activeFilter);\n  }\n);\n\n// Usage in a component\n// const filteredUsers = useSelector(selectFilteredUsers);",
              "explanation": "This example demonstrates `createSelector` from `reselect`. `getUsers` and `getActiveFilter` are 'input selectors'. `selectFilteredUsers` is a memoized selector that will only re-execute its filtering logic if either `users` or `activeFilter` change. This prevents redundant computations and improves performance.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "Redux",
            "State Management",
            "Selectors",
            "Reselect",
            "Performance",
            "Memoization",
            "React",
            "Frontend Architecture"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "Basic Redux concepts (store, reducers, actions)",
            "Functional Programming basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Optimized Redux Applications",
            "Large-scale Frontend Projects",
            "State Management Best Practices"
          ]
        },
        {
          "id": "theory_immutable_js",
          "title": "Immutable.js: Persistent Immutable Data Structures",
          "content": "## Immutable.js\nImmutable.js is a library that provides a set of immutable, persistent data structures. In immutable data structures, operations like adding, removing, or updating elements do not modify the original data structure. Instead, they return a new data structure containing the updated state, while efficiently sharing unchanged parts of the original structure. This 'persistence' means that previous versions of the data remain available.\n\n### Why use Immutable.js?\n-   **Predictability**: Immutability makes state changes predictable and easier to reason about, as data cannot be accidentally modified.\n-   **Performance Optimization (especially with React/Redux)**: In React, `shouldComponentUpdate` and `React.memo` (or `PureComponent`) perform shallow comparisons of props and state. With mutable data, a change deep within an object might not trigger a re-render because the reference to the object itself hasn't changed. Immutable data structures always return a new reference when changed, making shallow comparisons reliable and efficient for detecting true changes, thus preventing unnecessary re-renders.\n-   **Simplifies Undo/Redo**: Since previous states are always preserved, implementing undo/redo functionality becomes much simpler.\n-   **Concurrency**: Immutability naturally leads to thread-safe operations, although this is less critical in single-threaded JavaScript environments.\n\n### Immutable.js Data Structures\nImmutable.js offers several data structures that are analogous to native JavaScript types but with immutable behavior:\n\n#### List\nAn immutable equivalent of JavaScript's `Array`. It provides array-like methods (e.g., `get`, `set`, `push`, `pop`, `map`, `filter`) but all modifying operations return a new `List` instance.\n\n**Key methods for List:**\n-   `List()`: Creates an empty List.\n-   `List(array)`: Creates a List from a JavaScript array.\n-   `get(index)`: Returns the value at the specified index.\n-   `set(index, value)`: Returns a new List with the value at the index updated.\n-   `push(value)`: Returns a new List with the value added to the end.\n-   `pop()`: Returns a new List with the last value removed.\n-   `map(mapper)`: Returns a new List with each value mapped by the provided function.\n-   `toJS()`: Converts the Immutable.js List back to a plain JavaScript Array (and recursively converts nested Immutable collections).\n\n#### Other Data Structures\n-   **Map**: Immutable equivalent of JavaScript `Object`/`Map`.\n-   **Stack**: A LIFO (Last-In-First-Out) collection.\n-   **Set**: A collection of unique values.\n-   **OrderedMap/OrderedSet**: Maintain insertion order.\n-   **Record**: Defines a fixed set of keys and default values, similar to a class or struct.\n\nThese data structures achieve efficiency through structural sharing, meaning that when a change is made, only the altered parts of the data structure are copied, and unchanged parts are referenced from the original structure.",
          "examples": [
            {
              "id": "example_immutable_list_1",
              "title": "Immutable.js List Basic Usage",
              "code": "import { List } from 'immutable';\n\nconst initialList = List([1, 2, 3]);\nconsole.log('Initial List:', initialList.toJS()); // Output: [1, 2, 3]\n\nconst updatedList = initialList.push(4);\nconsole.log('Updated List (new instance):', updatedList.toJS()); // Output: [1, 2, 3, 4]\nconsole.log('Original List (unchanged):', initialList.toJS()); // Output: [1, 2, 3]\n\nconst listWithSet = updatedList.set(0, 100);\nconsole.log('List with element set:', listWithSet.toJS()); // Output: [100, 2, 3, 4]\n\nconst mappedList = listWithSet.map(x => x * 2);\nconsole.log('Mapped List:', mappedList.toJS()); // Output: [200, 4, 6, 8]\n",
              "explanation": "This example demonstrates the core concept of immutability with `Immutable.List`. Operations like `push` and `set` do not modify `initialList` or `updatedList` in place. Instead, they return new `List` instances (`updatedList`, `listWithSet`, `mappedList`) reflecting the changes, leaving the original lists untouched. `toJS()` is used to convert the Immutable.js List back to a standard JavaScript Array for easy console logging.",
              "language": "javascript"
            },
            {
              "id": "example_immutable_performance_2",
              "title": "Immutable.js with React/Redux context",
              "code": "import React from 'react';\nimport { useSelector } from 'react-redux';\nimport { List } from 'immutable';\n\n// Example Reducer (simplified)\nconst initialState = List([]);\nfunction itemsReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      return state.push(action.payload);\n    case 'REMOVE_LAST_ITEM':\n      return state.pop();\n    default:\n      return state;\n  }\n}\n\n// Example Component leveraging shallow comparison\nconst ItemList = React.memo(({ items }) => {\n  console.log('ItemList rendered'); // This will only log if 'items' reference changes\n  return (\n    <ul>\n      {items.toJS().map((item, index) => (\n        <li key={index}>{item}</li>\n      ))}\n    </ul>\n  );\n});\n\nfunction App() {\n  const items = useSelector(state => state.items); // Assuming 'items' is an Immutable.List in Redux state\n\n  // When itemsReducer returns a new Immutable.List instance (due to push/pop),\n  // the 'items' prop reference changes, triggering ItemList to re-render.\n  // If itemsReducer returned the same mutable array, React.memo might miss updates.\n  \n  return (\n    <div>\n      <ItemList items={items} />\n      {/* Buttons to dispatch actions */}\n    </div>\n  );\n}\n",
              "explanation": "This example illustrates how `Immutable.js` integrates with `React.memo` (or `PureComponent`) in a Redux context. When the Redux state, which holds an `Immutable.List`, is updated by the reducer (e.g., `state.push(action.payload)`), a new `List` instance is returned. This ensures that the `items` prop passed to `ItemList` is a *new reference*, triggering `React.memo`'s shallow comparison to detect the change and re-render `ItemList` correctly and efficiently. If a mutable array were used and modified in place, `React.memo` would not detect a reference change, potentially skipping necessary re-renders.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "Immutable.js",
            "Immutability",
            "Data Structures",
            "Redux",
            "React",
            "Performance",
            "State Management",
            "JavaScript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "JavaScript Arrays and Objects",
            "Concepts of Mutability",
            "Basic React and Redux"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Optimizing React/Redux Performance",
            "Complex State Management",
            "Functional Programming Paradigms"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_git_rebase_vs_merge_1",
          "topic": "Git Workflow Best Practices",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following commands is used to incorporate changes from a remote branch into your current local branch while maintaining a linear, clean commit history by avoiding unnecessary merge commits?",
          "answer": "git pull --rebase origin master",
          "options": [
            "git merge origin/master",
            "git rebase master",
            "git pull --rebase origin master",
            "git fetch origin master"
          ],
          "analysisPoints": [
            "`git merge` creates a merge commit, which can clutter history.",
            "`git rebase master` would rebase your current branch onto the local `master`, not pull from remote.",
            "`git fetch` only downloads changes, it doesn't integrate them.",
            "`git pull --rebase origin master` (or `main`) fetches from remote and reapplies local commits on top, ensuring a linear history."
          ],
          "keyConcepts": [
            "Git Rebase",
            "Git Merge",
            "Linear History",
            "Remote Tracking Branches"
          ],
          "evaluationCriteria": [
            "Understanding of `rebase` vs `merge` outcomes.",
            "Knowledge of `git pull` options.",
            "Ability to select the correct command for a specific history goal."
          ],
          "example": "The key is `--rebase`, which tells Git to reapply your local commits on top of the fetched commits from the remote, rather than creating a merge commit. This results in a cleaner, linear history.",
          "tags": [
            "Git",
            "Rebase",
            "Merge",
            "Workflow",
            "History"
          ],
          "prerequisites": [
            "git pull",
            "git merge",
            "git rebase"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_git_branching_strategy_2",
          "topic": "Git Workflow Best Practices",
          "level": "easy",
          "type": "flashcard",
          "question": "Why is it a best practice to create separate branches for new features and bug fixes?",
          "answer": "To isolate changes, prevent conflicts with the main development line, and allow for concurrent development.",
          "analysisPoints": [
            "Isolation: Prevents breaking the main branch.",
            "Collaboration: Allows multiple developers to work on different tasks simultaneously.",
            "Stability: Ensures the main branch remains stable and deployable."
          ],
          "keyConcepts": [
            "Git Branching",
            "Feature Branches",
            "Bugfix Branches"
          ],
          "evaluationCriteria": [
            "Understanding of branching purpose.",
            "Ability to articulate benefits of isolated development."
          ],
          "example": "Using branches like `feature/user-profile` or `fix/login-bug` clearly separates development efforts.",
          "tags": [
            "Git",
            "Branching",
            "Workflow"
          ],
          "prerequisites": [
            "git checkout -b"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_git_gitignore_purpose_3",
          "topic": "Git Workflow Best Practices",
          "level": "easy",
          "type": "open",
          "question": "Explain the purpose of a `.gitignore` file and provide examples of common file types or directories that should be included in it for a typical frontend project.",
          "answer": "A `.gitignore` file specifies intentionally untracked files that Git should ignore. This prevents Git from adding, tracking, or committing these files to the repository. Its primary purpose is to keep the repository clean and relevant by excluding generated files, temporary files, dependency directories, and environment-specific configurations.\n\nCommon examples for a frontend project include:\n-   `node_modules/`: Directory containing project dependencies installed by npm/yarn.\n-   `build/`, `dist/`: Directories containing compiled or bundled output files.\n-   `.env`, `.env.local`: Environment variable files that contain sensitive information or local configurations.\n-   `.DS_Store`: macOS specific hidden files.\n-   `npm-debug.log*`: npm debug logs.\n-   `.vscode/`, `.idea/`: IDE-specific configuration directories (though some teams track shared IDE settings).\n-   `coverage/`: Test coverage reports.",
          "analysisPoints": [
            "Clear definition of `.gitignore`'s role.",
            "Ability to list relevant examples specific to frontend development.",
            "Understanding of *why* certain files should be ignored (e.g., generated, sensitive, environment-specific)."
          ],
          "keyConcepts": [
            ".gitignore",
            "Untracked Files",
            "Repository Cleanliness",
            "Dependency Management"
          ],
          "evaluationCriteria": [
            "Accuracy of `.gitignore` definition.",
            "Relevance and diversity of examples.",
            "Justification for ignoring files."
          ],
          "example": "Ignoring `node_modules` is critical because it keeps the repository small and ensures everyone uses dependencies specified in `package.json`.",
          "tags": [
            "Git",
            ".gitignore",
            "Frontend",
            "Best Practices"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_git_atomic_commits_4",
          "topic": "Git Workflow Best Practices",
          "level": "medium",
          "type": "flashcard",
          "question": "What does it mean to 'commit atomically' in Git, and what are its benefits?",
          "answer": "Committing atomically means making each commit represent a single, complete, logical change. For example, a single commit might fix a bug, implement a small feature, or refactor a specific function, but not a mix of these. Benefits include easier code reviews, simpler debugging (using `git bisect`), and more straightforward reverting of specific changes.",
          "analysisPoints": [
            "Definition of atomic commit.",
            "Clear articulation of benefits (review, bisect, revert)."
          ],
          "keyConcepts": [
            "Atomic Commits",
            "Commit Granularity",
            "Code Review",
            "Git Bisect"
          ],
          "evaluationCriteria": [
            "Clarity and completeness of explanation.",
            "Identification of primary benefits."
          ],
          "example": "Instead of one large commit titled 'Fixes and features', you would have separate commits like 'Fix: Login page CSS alignment' and 'Feat: Add user profile picture upload'.",
          "tags": [
            "Git",
            "Commits",
            "Best Practices",
            "Workflow"
          ],
          "prerequisites": [
            "git commit"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_git_hooks_purpose_5",
          "topic": "Git Hooks",
          "level": "medium",
          "type": "open",
          "question": "Describe what Git hooks are and list three common types of Git hooks, explaining a typical use case for each in a frontend development context.",
          "answer": "Git hooks are custom scripts that Git automatically executes before or after certain events occur (e.g., committing, pushing). They allow for automation and enforcement of policies within a Git workflow.\n\nThree common types and their use cases:\n1.  **`pre-commit`**: Runs *before* a commit is created. \n    *   **Use case**: Running linters (e.g., ESLint, Prettier) to enforce code style and catch syntax errors on staged files, or running unit tests on modified files to prevent broken code from being committed.\n2.  **`commit-msg`**: Runs *after* a commit message has been provided, but *before* the commit is finalized.\n    *   **Use case**: Validating commit message format (e.g., ensuring messages adhere to Conventional Commits specification like `feat:`, `fix:`, `chore:`) to maintain a consistent and parseable commit history.\n3.  **`pre-push`**: Runs *before* pushing commits to a remote repository.\n    *   **Use case**: Running a full suite of integration tests or a build process to ensure that the code being pushed to the remote repository is stable and won't break the CI/CD pipeline or deployment.",
          "analysisPoints": [
            "Accurate definition of Git hooks.",
            "Correct identification of common hook types.",
            "Clear and relevant use cases for frontend development for each hook."
          ],
          "keyConcepts": [
            "Git Hooks",
            "Automation",
            "CI/CD",
            "Code Quality",
            "Workflow Enforcement"
          ],
          "evaluationCriteria": [
            "Understanding of Git hook mechanism.",
            "Ability to apply knowledge to practical scenarios.",
            "Completeness of explanations for each hook."
          ],
          "example": "Many projects use `husky` or `lint-staged` to simplify managing `pre-commit` hooks for linting and formatting.",
          "tags": [
            "Git",
            "Git Hooks",
            "Automation",
            "Frontend Development"
          ],
          "prerequisites": [
            "Basic Git concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_git_submodule_clone_6",
          "topic": "Git Submodules",
          "level": "medium",
          "type": "mcq",
          "question": "You have cloned a Git repository that uses submodules, but the submodule directories appear empty. Which command sequence would you use to properly initialize and populate the submodules?",
          "answer": "git submodule init && git submodule update",
          "options": [
            "git submodule add <url> <path>",
            "git submodule init && git submodule update",
            "git pull --recurse-submodules",
            "git clone --recursive <url>"
          ],
          "analysisPoints": [
            "`git submodule add` is for adding *new* submodules, not populating existing ones after clone.",
            "`git pull --recurse-submodules` isn't a standard command, and `git pull` focuses on merging/rebasing the main repo.",
            "`git clone --recursive` is an alternative way to *initially clone* with submodules, but not for fixing an already cloned repo with empty submodules.",
            "`git submodule init` initializes the local configuration for submodules, and `git submodule update` populates their content."
          ],
          "keyConcepts": [
            "Git Submodules",
            "Submodule Initialization",
            "Submodule Update",
            "Cloning Repositories"
          ],
          "evaluationCriteria": [
            "Knowledge of correct submodule commands.",
            "Understanding of the submodule lifecycle.",
            "Ability to troubleshoot common submodule issues."
          ],
          "example": "After a standard `git clone` of a repository containing submodules, the submodule directories will be present but empty. Running `git submodule init` followed by `git submodule update` will download and checkout the correct versions of the submodules.",
          "tags": [
            "Git",
            "Submodules",
            "Commands"
          ],
          "prerequisites": [
            "git clone"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_selectors_benefits_7",
          "topic": "Redux Selectors",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using Redux selectors in a React application?",
          "answer": "Selectors provide a way to extract specific pieces of information from the Redux store state in a reusable and often memoized manner, leading to improved performance (by preventing unnecessary re-renders) and better state access organization.",
          "analysisPoints": [
            "Reusability: Centralizes state access logic.",
            "Performance: Enables memoization to avoid re-computation and unnecessary re-renders.",
            "Decoupling: Components are less dependent on state shape."
          ],
          "keyConcepts": [
            "Redux Selectors",
            "Memoization",
            "State Management",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Concise summary of benefits.",
            "Emphasis on reusability and performance."
          ],
          "example": "Instead of `state.user.profile.name`, a selector `selectUserName(state)` provides a stable interface.",
          "tags": [
            "Redux",
            "Selectors",
            "React",
            "Performance"
          ],
          "prerequisites": [
            "Redux state"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_selectors_memoization_8",
          "topic": "Redux Selectors",
          "level": "medium",
          "type": "open",
          "question": "Explain how memoization with `reselect` benefits Redux selectors and provide a simple code example demonstrating a memoized selector.",
          "answer": "Memoization is a technique where the result of a function call is cached and returned if the same inputs occur again. With `reselect`, memoized selectors only re-run their computation function if their input selectors' results have changed. This is highly beneficial for Redux applications because:\n1.  **Performance**: Prevents expensive re-computations of derived data, especially if the data processing is complex or involves large datasets.\n2.  **Optimized Re-renders**: In React, if a component's props are derived from Redux state via a memoized selector, and the selector returns the same reference (because its inputs haven't changed), `React.memo` (or `PureComponent`) will skip re-rendering that component, leading to significant performance gains.\n\n```javascript\nimport { createSelector } from 'reselect';\n\n// Input selectors\nconst getProducts = (state) => state.products.list;\nconst getCurrencyRate = (state) => state.settings.currencyRate;\n\n// Memoized selector: Calculates product prices in local currency\nexport const selectProductsInLocalCurrency = createSelector(\n  [getProducts, getCurrencyRate],\n  (products, rate) => {\n    console.log('Recalculating product prices...'); // This message will only appear if products or rate change\n    return products.map(product => ({\n      ...product,\n      priceLocal: product.priceUSD * rate\n    }));\n  }\n);\n\n// Example usage:\n// const products = useSelector(selectProductsInLocalCurrency);\n// If other parts of the state change but products.list and settings.currencyRate do not,\n// 'selectProductsInLocalCurrency' will not re-run, returning the cached result.\n```",
          "analysisPoints": [
            "Clear explanation of memoization.",
            "Specific benefits related to Redux/React performance.",
            "Correct use of `createSelector` with input selectors and computation function.",
            "Demonstration of memoization's effect (e.g., `console.log` example)."
          ],
          "keyConcepts": [
            "Memoization",
            "Reselect",
            "Redux Selectors",
            "Performance Optimization",
            "Pure Functions"
          ],
          "evaluationCriteria": [
            "Technical accuracy of explanation.",
            "Clarity and correctness of the code example.",
            "Ability to connect concept to practical performance gains."
          ],
          "example": "```javascript\n// In a React component:\n// const products = useSelector(selectProductsInLocalCurrency);\n// Even if the entire Redux state object changes, if the `products.list` and `settings.currencyRate` portions\n// of the state remain shallowly equal, the selector will return the cached `products` array,\n// preventing the component from re-rendering unless necessary.\n```",
          "tags": [
            "Redux",
            "Selectors",
            "Reselect",
            "Performance",
            "Memoization"
          ],
          "prerequisites": [
            "Redux basic",
            "JavaScript functions"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_js_core_concept_9",
          "topic": "Immutable.js",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the core principle behind Immutable.js data structures, and how does it differ from native JavaScript arrays/objects in terms of modification?",
          "answer": "The core principle of Immutable.js is that data structures are *immutable and persistent*. This means that once created, they cannot be changed. Any operation that would 'modify' the data (e.g., `set`, `push`) instead returns a *new* data structure with the updated values, leaving the original data structure completely unchanged. In contrast, native JavaScript arrays and objects are *mutable*, meaning operations like `array.push()` or `object.property = value` modify the original data structure in place.",
          "analysisPoints": [
            "Definition of immutability and persistence.",
            "Contrast with mutable native JS types.",
            "Emphasis on new instance creation vs. in-place modification."
          ],
          "keyConcepts": [
            "Immutability",
            "Persistent Data Structures",
            "Mutable vs Immutable",
            "Immutable.js"
          ],
          "evaluationCriteria": [
            "Clear and concise explanation of the core principle.",
            "Accurate comparison to native JavaScript."
          ],
          "example": "```javascript\nconst arr = [1, 2];\narr.push(3); // arr is now [1, 2, 3] (mutable, in-place)\n\nimport { List } from 'immutable';\nconst immutableList = List([1, 2]);\nconst newList = immutableList.push(3); // immutableList is still List([1, 2]), newList is List([1, 2, 3])\n```",
          "tags": [
            "Immutable.js",
            "Immutability",
            "JavaScript",
            "Data Structures"
          ],
          "prerequisites": [
            "JavaScript data types"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_js_react_performance_10",
          "topic": "Immutable.js",
          "level": "medium",
          "type": "open",
          "question": "Explain how using Immutable.js data structures can improve performance in a React application, particularly when integrated with Redux.",
          "answer": "In React, performance optimizations like `React.memo` (or `PureComponent`) rely on shallow comparisons of props and state to determine if a component needs to re-render. With mutable JavaScript objects/arrays, if a nested property changes but the parent object's reference remains the same, a shallow comparison will incorrectly indicate no change, preventing a necessary re-render. Alternatively, if a new mutable object/array is created on every state update (even if its contents are the same), it can trigger unnecessary re-renders.\n\nImmutable.js solves this by ensuring that *any* modification to a data structure (even deep changes) always results in a *new reference* being returned for the top-level data structure. This makes shallow comparisons completely reliable:\n-   If the data truly changed, a new reference is returned, and `React.memo` will correctly trigger a re-render.\n-   If the data did *not* change, the exact same reference is returned (due to structural sharing), and `React.memo` will correctly skip the re-render.\n\nThis predictability eliminates common bugs related to stale UI due to missed updates and prevents wasteful re-renders, significantly optimizing performance in complex React/Redux applications.",
          "analysisPoints": [
            "Explanation of React's shallow comparison mechanism.",
            "Problem with mutable data and shallow comparisons.",
            "How Immutable.js solves this with new references for changes.",
            "Impact on performance (preventing unnecessary re-renders, ensuring necessary ones)."
          ],
          "keyConcepts": [
            "Immutable.js",
            "React.memo",
            "PureComponent",
            "Shallow Comparison",
            "Performance Optimization",
            "Redux",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Clear and accurate explanation of the technical mechanism.",
            "Strong connection between immutability and React's rendering lifecycle.",
            "Emphasis on practical performance benefits."
          ],
          "example": "Imagine a `user` object in Redux state. If it's a mutable JS object and you only change `user.address.street`, the `user` object's reference remains the same, potentially causing `React.memo` to skip a re-render. If `user` is an Immutable.js `Map`, changing `user.setIn(['address', 'street'], 'New St')` would return a *new* `user` Map, correctly triggering `React.memo` to re-render components depending on `user`.",
          "tags": [
            "Immutable.js",
            "React",
            "Redux",
            "Performance",
            "Immutability"
          ],
          "prerequisites": [
            "React component lifecycle",
            "Redux state updates"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_immutable_js_list_mcq_11",
          "topic": "Immutable.js Data Structures",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code using Immutable.js `List`:\n\n```javascript\nimport { List } from 'immutable';\n\nconst originalList = List([10, 20, 30]);\nconst updatedList = originalList.set(1, 25);\nconst pushedList = updatedList.push(40);\n\n// What will be the value of originalList.toJS() and pushedList.toJS() respectively?\n```",
          "answer": "originalList.toJS() will be [10, 20, 30]; pushedList.toJS() will be [10, 25, 30, 40]",
          "options": [
            "originalList.toJS() will be [10, 25, 30, 40]; pushedList.toJS() will be [10, 25, 30, 40]",
            "originalList.toJS() will be [10, 20, 30]; pushedList.toJS() will be [10, 25, 30, 40]",
            "originalList.toJS() will be [10, 20, 30]; pushedList.toJS() will be [10, 20, 30, 40]",
            "originalList.toJS() will be [10, 25, 30]; pushedList.toJS() will be [10, 25, 30, 40]"
          ],
          "analysisPoints": [
            "Immutable.js methods like `set` and `push` do not mutate the original `List` instance.",
            "`originalList` remains unchanged throughout the operations.",
            "`updatedList` is a new `List` with the element at index 1 changed.",
            "`pushedList` is another new `List` based on `updatedList` with an element pushed."
          ],
          "keyConcepts": [
            "Immutable.js List",
            "Immutability",
            "Data Transformation"
          ],
          "evaluationCriteria": [
            "Correct understanding of immutable operations.",
            "Ability to trace state changes in immutable data structures."
          ],
          "example": "```javascript\nimport { List } from 'immutable';\n\nconst originalList = List([10, 20, 30]);\nconst updatedList = originalList.set(1, 25);\nconst pushedList = updatedList.push(40);\n\nconsole.log(originalList.toJS()); // [10, 20, 30] - Unchanged\nconsole.log(updatedList.toJS());  // [10, 25, 30]\nconsole.log(pushedList.toJS());   // [10, 25, 30, 40]\n```\nThis example clearly shows that `originalList` retains its initial state because `set` and `push` operations on Immutable.js Lists return new instances rather than modifying the original.",
          "tags": [
            "Immutable.js",
            "Immutability",
            "List",
            "MCQ"
          ],
          "prerequisites": [
            "Immutable.js basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_git_resolve_conflict_code_12",
          "topic": "Git Workflow Best Practices",
          "level": "medium",
          "type": "code",
          "question": "You are merging `feature/login-page` into `main` and encounter a merge conflict in `src/components/LoginPage.js`. The conflict markers show both `HEAD` (your `main` branch) and `feature/login-page` changes.\n\nWrite down the typical sequence of Git commands and actions you would take to resolve this conflict and complete the merge, including the steps within the conflicting file itself.",
          "answer": "```bash\ngit checkout main\ngit merge feature/login-page\n# At this point, Git reports conflicts. You would then manually edit `src/components/LoginPage.js`.\n\n# --- Inside src/components/LoginPage.js --- START ---\n# Git adds conflict markers like these:\n# <<<<<<< HEAD\n#   // Your changes on 'main'\n#   const user = getUserFromContext();\n# =======\n#   // Incoming changes from 'feature/login-page'\n#   const credentials = getLoginCredentials();\n# >>>>>>> feature/login-page\n\n# You would edit the file to combine the desired changes, removing conflict markers:\n#   const user = getUserFromContext();\n#   const credentials = getLoginCredentials();\n# --- Inside src/components/LoginPage.js --- END ---\n\ngit add src/components/LoginPage.js\n# Add any other files you fixed conflicts in\n\ngit commit -m \"Merge feature/login-page into main and resolve conflicts\"\n# Git will often pre-populate the merge commit message. You can customize it.\n```",
          "analysisPoints": [
            "Correct use of `git merge` to initiate conflict.",
            "Understanding of manual conflict resolution within files (removing markers, combining code).",
            "Correct command (`git add`) to mark conflicts as resolved.",
            "Correct command (`git commit`) to finalize the merge."
          ],
          "keyConcepts": [
            "Git Merge Conflicts",
            "Conflict Markers",
            "Git Add",
            "Git Commit"
          ],
          "evaluationCriteria": [
            "Correct sequence of Git commands.",
            "Demonstration of understanding how to edit conflicting files.",
            "Clarity of explanation for each step."
          ],
          "example": "This flow is essential for collaborating on projects, as merge conflicts are inevitable. Practicing manual resolution is key.",
          "tags": [
            "Git",
            "Merge",
            "Conflicts",
            "Workflow",
            "Code"
          ],
          "prerequisites": [
            "git merge",
            "file editing"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_git_submodule_behavior_13",
          "topic": "Git Submodules",
          "level": "hard",
          "type": "open",
          "question": "A team is considering using Git submodules for managing a shared UI component library within several frontend applications. Discuss the pros and cons of using Git submodules for this use case, and suggest an alternative approach if submodules are deemed unsuitable.",
          "answer": "**Pros of Git Submodules for a Shared UI Library:**\n1.  **Pinning specific versions**: Submodules pin the exact commit of the UI library. This ensures that each consuming application uses a consistent, tested version, preventing unexpected breaking changes from library updates.\n2.  **Decentralized development**: The UI library can be developed in its own repository, maintaining its independent history and release cycle.\n3.  **Local modification**: Developers can make local changes to the submodule for debugging or experimentation within the context of the consuming app, then potentially push those changes back to the library's main repo.\n\n**Cons of Git Submodules:**\n1.  **Complexity**: Submodule commands (`init`, `update`, `add`) add overhead and can be confusing for new developers. Cloning with `--recurse-submodules` is easy to forget.\n2.  **Branching and pushing**: Managing changes within a submodule and pushing them back to the library's repository, then updating the parent project's submodule reference, can be cumbersome and error-prone.\n3.  **No automatic updates**: Submodules don't automatically update to the latest version. Consuming applications must explicitly update their submodule references.\n4.  **Monorepo challenges**: While good for pinning, they don't offer the unified tooling or shared dependencies of true monorepos (e.g., Lerna, Nx).\n5.  **CI/CD complexity**: Build pipelines need to be aware of submodules, often requiring extra steps for cloning and dependency installation.\n\n**Alternative Approach: Package Management (npm/Yarn)**\nA more common and often preferred approach for shared UI component libraries in frontend applications is to publish the library as an npm package (or similar package manager). Consuming applications then install it as a dependency.\n\n**Benefits of Package Management:**\n-   **Simplicity**: Easy to install (`npm install`), update (`npm update`), and manage versions (semver).\n-   **Standard Workflow**: Fits into the existing npm/Yarn ecosystem for dependency management.\n-   **Centralized Registry**: Packages are distributed via a registry (public or private), simplifying discovery and access.\n-   **Build Integration**: Integrates seamlessly with standard frontend build tools (Webpack, Rollup).\n\n**Considerations for Package Management:**\n-   Requires a publishing process (e.g., to npm registry).\n-   Local development of the library alongside consuming apps often requires `npm link` or similar linking strategies, which can sometimes be tricky.",
          "analysisPoints": [
            "Comprehensive listing of pros and cons for submodules.",
            "Focus on frontend-specific challenges (UI component library).",
            "Clear explanation of an alternative (package management).",
            "Discussion of benefits and considerations for the alternative."
          ],
          "keyConcepts": [
            "Git Submodules",
            "Monorepo",
            "Shared Libraries",
            "Package Management (npm/Yarn)",
            "Dependency Management"
          ],
          "evaluationCriteria": [
            "Depth of analysis for submodules.",
            "Ability to propose and justify relevant alternatives.",
            "Understanding of common frontend architectural patterns."
          ],
          "example": "Many large organizations opt for monorepo tools like Lerna or Nx, or dedicated package repositories (e.g., Verdaccio, Nexus) to manage shared components as npm packages. This balances version control with ease of consumption.",
          "tags": [
            "Git",
            "Submodules",
            "Architecture",
            "Frontend",
            "Package Management",
            "Monorepo"
          ],
          "prerequisites": [
            "Git branching",
            "npm/yarn"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_git_workflow_setup",
          "title": "Automate Git Workflow Best Practices",
          "description": "\nAs a frontend developer, you need to set up a new project's Git configuration to enforce some best practices. Your task is to:\n\n1.  **Configure a global Git alias** for `git pull --rebase` to simplify its usage.\n2.  **Create a basic `pre-commit` Git hook** using a shell script that checks for the presence of `console.log` or `debugger` statements in staged JavaScript files. If found, the commit should be aborted with an informative message.\n3.  **Create a `.gitignore` file** that is suitable for a typical React/TypeScript project, including common build outputs, dependency directories, and environment files.\n\nYour solution should demonstrate understanding of Git aliases, custom Git hooks, and `.gitignore` best practices.",
          "difficulty": "medium",
          "startingCode": "# No starting code file, as this involves Git configuration and shell scripting.\n# You will need to create and modify files like .gitconfig, .git/hooks/pre-commit, and .gitignore.",
          "solutionCode": "# 1. Configure git pull --rebase alias (add to ~/.gitconfig or project's .git/config)\n# [alias]\n#   pr = pull --rebase\n\n# Or, set it globally:\ngit config --global alias.pr 'pull --rebase'\n\n# 2. Create .git/hooks/pre-commit script\n# (Make sure to make it executable: chmod +x .git/hooks/pre-commit)\n\n# Content for .git/hooks/pre-commit:\n```bash\n#!/bin/sh\n\n# Check for console.log or debugger in staged .js/.ts files\nSTAGED_JS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\\.(js|jsx|ts|tsx)$')\n\nif [ -n \"$STAGED_JS_FILES\" ]; then\n  if git diff --cached --text -- \"$STAGED_JS_FILES\" | grep -E -q '(console\\.log|debugger);'; then\n    echo \"\\n------------------------------------------------------------\"\n    echo \"🚫 ERROR: Found 'console.log' or 'debugger' statements in staged files.\"\n    echo \"         Please remove them before committing.         \"\n    echo \"------------------------------------------------------------\\n\"\n    exit 1\n  fi\nfi\n\nexit 0\n```\n\n# 3. Create .gitignore file at the project root\n# Content for .gitignore:\n```\n# Dependencies\nnode_modules/\n\n# Build artifacts\nbuild/\ndist/\nout/\n\n# Environment variables\n.env\n.env.local\n.env.*.local\n\n# Logs\nnpm-debug.log*\nyarn-debug.log*\n\n# OS/IDE specific\n.DS_Store\n.idea/\n.vscode/\n\n# Test coverage\ncoverage/\n```\n",
          "testCases": [
            "Verify `git pr origin main` works as `git pull --rebase origin main`.",
            "Attempt to commit a JavaScript file containing `console.log('test')` or `debugger;` statement. The commit should be aborted.",
            "Attempt to commit a JavaScript file without `console.log` or `debugger;`. The commit should succeed.",
            "Verify that `node_modules/` or `build/` directories are not tracked by Git after adding them to `.gitignore` (e.g., `git status` should not list them)."
          ],
          "hints": [
            "Git aliases can be configured in your global `.gitconfig` file or directly via `git config --global alias.<alias_name> '<command>'`.",
            "Git hooks are plain executable scripts in the `.git/hooks` directory of your repository. Remember to make the hook file executable (`chmod +x`).",
            "For the `pre-commit` hook, `git diff --cached` is useful for checking only staged changes. `grep -q` can be used to silently check for patterns, and `grep -E` for extended regex.",
            "Test your `.gitignore` by creating ignored files and running `git status`."
          ],
          "tags": [
            "Git",
            "Workflow",
            "Hooks",
            "Alias",
            ".gitignore",
            "Frontend"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Basic Git commands",
            "Shell Scripting basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Git Workflow Best Practices",
            "Git Hooks"
          ]
        },
        {
          "id": "task_redux_selector_implementation",
          "title": "Implement Memoized Redux Selectors for a Shopping Cart",
          "description": "\nYou are developing a shopping cart feature for an e-commerce application using React and Redux. Your task is to implement memoized selectors to efficiently retrieve cart data and derived calculations.\n\n**Requirements:**\n1.  **`selectCartItems`**: A basic selector to return the raw list of items in the cart.\n2.  **`selectTotalItemsInCart`**: A memoized selector that calculates the total quantity of all items in the cart.\n3.  **`selectTotalPrice`**: A memoized selector that calculates the total price of all items in the cart, considering each item's price and quantity.\n4.  **`selectCartSummary`**: A memoized selector that combines the total items count and total price into a single object `{ totalItems, totalPrice }`.\n\nEnsure that the memoized selectors only re-compute when their relevant input state changes. Include a dummy Redux state structure to test your selectors.\n",
          "difficulty": "medium",
          "startingCode": "import { createSelector } from 'reselect';\n\n// --- Dummy Redux State Structure ---\nconst dummyState = {\n  cart: {\n    items: [\n      { id: 'p1', name: 'Laptop', price: 1200, quantity: 1 },\n      { id: 'p2', name: 'Mouse', price: 25, quantity: 2 },\n      { id: 'p3', name: 'Keyboard', price: 75, quantity: 1 }\n    ]\n  },\n  // Other state parts that should NOT trigger selector re-computation\n  user: { name: 'John Doe' },\n  settings: { theme: 'dark' }\n};\n\n// --- Your Selectors Here ---\n\n// 1. Basic selector for raw cart items\nexport const selectCartItems = (state) => state.cart.items;\n\n// 2. Memoized selector for total quantity\n// export const selectTotalItemsInCart = createSelector(\n//   [/* input selectors */],\n//   (/* inputs */) => {\n//     // computation logic\n//   }\n// );\n\n// 3. Memoized selector for total price\n// export const selectTotalPrice = createSelector(\n//   [/* input selectors */],\n//   (/* inputs */) => {\n//     // computation logic\n//   }\n// );\n\n// 4. Memoized selector for cart summary\n// export const selectCartSummary = createSelector(\n//   [/* input selectors */],\n//   (/* inputs */) => {\n//     // computation logic\n//   }\n// );\n\n// --- Test Calls (for your local verification) ---\n// console.log('Cart Items:', selectCartItems(dummyState));\n// console.log('Total Items:', selectTotalItemsInCart(dummyState));\n// console.log('Total Price:', selectTotalPrice(dummyState));\n// console.log('Cart Summary:', selectCartSummary(dummyState));\n\n// Test memoization: modify non-cart state and re-run\n// const dummyState2 = { ...dummyState, user: { name: 'Jane Doe' } };\n// console.log('Total Items (after user change):', selectTotalItemsInCart(dummyState2)); // Should not re-compute\n\n// Test re-computation: modify cart state\n// const dummyState3 = { \n//   ...dummyState, \n//   cart: { \n//     items: [...dummyState.cart.items, { id: 'p4', name: 'Webcam', price: 50, quantity: 1 }] \n//   }\n// };\n// console.log('Total Items (after cart change):', selectTotalItemsInCart(dummyState3)); // Should re-compute\n",
          "solutionCode": "import { createSelector } from 'reselect';\n\n// --- Dummy Redux State Structure ---\nconst dummyState = {\n  cart: {\n    items: [\n      { id: 'p1', name: 'Laptop', price: 1200, quantity: 1 },\n      { id: 'p2', name: 'Mouse', price: 25, quantity: 2 },\n      { id: 'p3', name: 'Keyboard', price: 75, quantity: 1 }\n    ]\n  },\n  user: { name: 'John Doe' },\n  settings: { theme: 'dark' }\n};\n\n// --- Your Selectors Here ---\n\n// 1. Basic selector for raw cart items\nexport const selectCartItems = (state) => {\n  // console.log('Running selectCartItems'); // For debugging memoization\n  return state.cart.items;\n};\n\n// 2. Memoized selector for total quantity\nexport const selectTotalItemsInCart = createSelector(\n  [selectCartItems],\n  (items) => {\n    console.log('Recalculating total items...'); // Monitor re-computation\n    return items.reduce((total, item) => total + item.quantity, 0);\n  }\n);\n\n// 3. Memoized selector for total price\nexport const selectTotalPrice = createSelector(\n  [selectCartItems],\n  (items) => {\n    console.log('Recalculating total price...'); // Monitor re-computation\n    return items.reduce((total, item) => total + (item.price * item.quantity), 0);\n  }\n);\n\n// 4. Memoized selector for cart summary\nexport const selectCartSummary = createSelector(\n  [selectTotalItemsInCart, selectTotalPrice],\n  (totalItems, totalPrice) => {\n    console.log('Recalculating cart summary...'); // Monitor re-computation\n    return { totalItems, totalPrice };\n  }\n);\n\n// --- Test Calls ---\nconsole.log('--- Initial State Calculation ---');\nconsole.log('Cart Items:', selectCartItems(dummyState));\nconsole.log('Total Items:', selectTotalItemsInCart(dummyState));\nconsole.log('Total Price:', selectTotalPrice(dummyState));\nconsole.log('Cart Summary:', selectCartSummary(dummyState));\n\nconsole.log('\\n--- Changing non-cart state (user name) ---');\nconst dummyState2 = { ...dummyState, user: { name: 'Jane Doe' } };\n// These should NOT log 'Recalculating...' because input selectors (selectCartItems, selectTotalItemsInCart, selectTotalPrice)\n// didn't change their output reference.\nconsole.log('Total Items (after user change):', selectTotalItemsInCart(dummyState2));\nconsole.log('Total Price (after user change):', selectTotalPrice(dummyState2));\nconsole.log('Cart Summary (after user change):', selectCartSummary(dummyState2));\n\nconsole.log('\\n--- Changing cart items state ---');\nconst dummyState3 = {\n  ...dummyState,\n  cart: {\n    items: [...dummyState.cart.items, { id: 'p4', name: 'Webcam', price: 50, quantity: 1 }]\n  }\n};\n// These SHOULD log 'Recalculating...' because selectCartItems' output reference changes.\nconsole.log('Total Items (after cart change):', selectTotalItemsInCart(dummyState3));\nconsole.log('Total Price (after cart change):', selectTotalPrice(dummyState3));\nconsole.log('Cart Summary (after cart change):', selectCartSummary(dummyState3));\n",
          "testCases": [
            "Initial state: `selectCartItems` should return the array of 3 items.",
            "Initial state: `selectTotalItemsInCart` should return `4` (1+2+1).",
            "Initial state: `selectTotalPrice` should return `1375` (1200*1 + 25*2 + 75*1).",
            "Initial state: `selectCartSummary` should return `{ totalItems: 4, totalPrice: 1375 }`.",
            "Modify a non-cart part of the state (e.g., `state.user`). Calls to `selectTotalItemsInCart`, `selectTotalPrice`, and `selectCartSummary` should *not* trigger re-computation (check console logs for 'Recalculating...').",
            "Modify the `cart.items` array (e.g., add a new item). Calls to `selectTotalItemsInCart`, `selectTotalPrice`, and `selectCartSummary` *should* trigger re-computation and reflect new correct values."
          ],
          "hints": [
            "Remember that `createSelector` takes an array of input selectors as its first argument and a 'result function' as its second.",
            "The result function of `createSelector` receives the outputs of the input selectors as its arguments.",
            "For `selectCartSummary`, you can use the other memoized selectors (`selectTotalItemsInCart`, `selectTotalPrice`) as its input selectors, demonstrating selector composition.",
            "Use `console.log` inside the result functions of your memoized selectors to visually confirm when they re-compute."
          ],
          "tags": [
            "Redux",
            "Selectors",
            "Reselect",
            "Performance",
            "State Management",
            "Frontend"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "Redux concepts",
            "JavaScript array methods (reduce, map)",
            "`reselect` library"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Redux Selectors",
            "Memoization",
            "Reselect"
          ]
        },
        {
          "id": "task_immutable_list_operations",
          "title": "Manage User Preferences with Immutable.js List",
          "description": "\nYou are building a user settings panel where users can manage a list of their preferred categories (e.g., 'Sports', 'News', 'Technology'). You decide to use Immutable.js `List` to manage this data to ensure predictable state updates and optimize React re-renders.\n\n**Requirements:**\n1.  **`addCategory(preferencesList, categoryName)`**: A function that takes an existing `Immutable.List` of categories and a new category name (string). It should return a new `Immutable.List` with the new category added, ensuring no duplicates.\n2.  **`removeCategory(preferencesList, categoryName)`**: A function that takes an existing `Immutable.List` and a category name. It should return a new `Immutable.List` with the specified category removed, if it exists.\n3.  **`toggleCategory(preferencesList, categoryName)`**: A function that checks if a category exists in the list. If it does, it removes it; otherwise, it adds it (ensuring no duplicates).\n4.  **`getCategoryByIndex(preferencesList, index)`**: A function to retrieve a category by its index, returning `undefined` if the index is out of bounds.\n\nImplement these functions, ensuring all operations return new `Immutable.List` instances and the original list remains unchanged.",
          "difficulty": "medium",
          "startingCode": "import { List } from 'immutable';\n\nconst initialPreferences = List(['Sports', 'Technology']);\n\n// 1. Function to add a category\nfunction addCategory(preferencesList, categoryName) {\n  // TODO: Implement this function\n  return preferencesList;\n}\n\n// 2. Function to remove a category\nfunction removeCategory(preferencesList, categoryName) {\n  // TODO: Implement this function\n  return preferencesList;\n}\n\n// 3. Function to toggle a category (add if not present, remove if present)\nfunction toggleCategory(preferencesList, categoryName) {\n  // TODO: Implement this function\n  return preferencesList;\n}\n\n// 4. Function to get a category by index\nfunction getCategoryByIndex(preferencesList, index) {\n  // TODO: Implement this function\n  return undefined;\n}\n\n// --- Test Cases (for your local verification) ---\n// console.log('Initial:', initialPreferences.toJS());\n\n// const addedList = addCategory(initialPreferences, 'News');\n// console.log('After adding News:', addedList.toJS());\n// console.log('Original unchanged:', initialPreferences.toJS());\n\n// const removedList = removeCategory(addedList, 'Technology');\n// console.log('After removing Technology:', removedList.toJS());\n\n// const toggledAddList = toggleCategory(removedList, 'Politics');\n// console.log('After toggling (add) Politics:', toggledAddList.toJS());\n\n// const toggledRemoveList = toggleCategory(toggledAddList, 'Sports');\n// console.log('After toggling (remove) Sports:', toggledRemoveList.toJS());\n\n// console.log('Category at index 0:', getCategoryByIndex(initialPreferences, 0));\n// console.log('Category at invalid index:', getCategoryByIndex(initialPreferences, 100));\n",
          "solutionCode": "import { List } from 'immutable';\n\nconst initialPreferences = List(['Sports', 'Technology']);\n\n// 1. Function to add a category\nfunction addCategory(preferencesList, categoryName) {\n  if (preferencesList.includes(categoryName)) {\n    return preferencesList; // Category already exists, return original list for immutability\n  }\n  return preferencesList.push(categoryName);\n}\n\n// 2. Function to remove a category\nfunction removeCategory(preferencesList, categoryName) {\n  const index = preferencesList.indexOf(categoryName);\n  if (index === -1) {\n    return preferencesList; // Category not found, return original list\n  }\n  return preferencesList.delete(index);\n}\n\n// 3. Function to toggle a category (add if not present, remove if present)\nfunction toggleCategory(preferencesList, categoryName) {\n  if (preferencesList.includes(categoryName)) {\n    return removeCategory(preferencesList, categoryName);\n  } else {\n    return addCategory(preferencesList, categoryName);\n  }\n}\n\n// 4. Function to get a category by index\nfunction getCategoryByIndex(preferencesList, index) {\n  return preferencesList.get(index);\n}\n\n// --- Test Cases ---\nconsole.log('Initial:', initialPreferences.toJS()); // [ 'Sports', 'Technology' ]\n\n// Test Add\nconst addedList = addCategory(initialPreferences, 'News');\nconsole.log('After adding News:', addedList.toJS()); // [ 'Sports', 'Technology', 'News' ]\nconsole.log('Original unchanged:', initialPreferences.toJS()); // [ 'Sports', 'Technology' ]\nconst addedExistingList = addCategory(addedList, 'Sports');\nconsole.log('After adding existing Sports (should be same as addedList):', addedExistingList.toJS()); // [ 'Sports', 'Technology', 'News' ]\n\n// Test Remove\nconst removedList = removeCategory(addedList, 'Technology');\nconsole.log('After removing Technology from addedList:', removedList.toJS()); // [ 'Sports', 'News' ]\nconst removedNonExistent = removeCategory(removedList, 'Politics');\nconsole.log('After removing non-existent Politics (should be same as removedList):', removedNonExistent.toJS()); // [ 'Sports', 'News' ]\n\n// Test Toggle\nconst toggledAddList = toggleCategory(removedList, 'Politics');\nconsole.log('After toggling (add) Politics:', toggledAddList.toJS()); // [ 'Sports', 'News', 'Politics' ]\nconst toggledRemoveList = toggleCategory(toggledAddList, 'Sports');\nconsole.log('After toggling (remove) Sports:', toggledRemoveList.toJS()); // [ 'News', 'Politics' ]\n\n// Test Get By Index\nconsole.log('Category at index 0 of initial:', getCategoryByIndex(initialPreferences, 0)); // Sports\nconsole.log('Category at index 1 of initial:', getCategoryByIndex(initialPreferences, 1)); // Technology\nconsole.log('Category at invalid index:', getCategoryByIndex(initialPreferences, 100)); // undefined\n",
          "testCases": [
            "Adding a new category: `addCategory(initial, 'News')` should return `['Sports', 'Technology', 'News']`. Original should be unchanged.",
            "Adding an existing category: `addCategory(listWithNews, 'Sports')` should return the list unchanged (no duplicate, new reference only if a change actually occurred).",
            "Removing an existing category: `removeCategory(listWithNews, 'Technology')` should return `['Sports', 'News']`. Original should be unchanged.",
            "Removing a non-existent category: `removeCategory(listWithNews, 'Finance')` should return the list unchanged.",
            "Toggling to add: `toggleCategory(initial, 'Finance')` should return `['Sports', 'Technology', 'Finance']`.",
            "Toggling to remove: `toggleCategory(listWithFinance, 'Sports')` should return `['Technology', 'Finance']`.",
            "Getting by valid index: `getCategoryByIndex(initial, 0)` should return `'Sports'`.",
            "Getting by invalid index: `getCategoryByIndex(initial, 10)` should return `undefined`."
          ],
          "hints": [
            "Remember that Immutable.js methods like `push`, `delete`, `includes`, `indexOf`, and `get` are your friends.",
            "Always ensure your functions return a new `Immutable.List` instance if any change occurs, or the *same* original instance if no logical change is made (e.g., trying to add an existing item).",
            "The `delete` method on `List` removes an element at a given index and returns a new list.",
            "The `includes` method is useful for checking existence before adding or removing."
          ],
          "tags": [
            "Immutable.js",
            "Immutability",
            "Data Structures",
            "List",
            "Functional Programming"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Basic Immutable.js List methods",
            "JavaScript functional array methods"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Immutable.js",
            "Immutability"
          ]
        }
      ]
    }
  },
  {
    "id": "f42160fa-b85b-48be-8c9b-5e8d88c23bfd",
    "startLine": 10700,
    "endLine": 10799,
    "processedDate": "2025-06-17T11:49:25.950Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_immutable_js_intro",
          "title": "Introduction to Immutable.js and Persistent Data Structures",
          "content": "## What is Immutability?\nImmutability, in programming, means that once an object is created, it cannot be changed. Any operation that appears to modify the object actually returns a new object with the desired changes, leaving the original object untouched.\n\n## Why Immutability in Frontend Development?\n1.  **Predictability:** Immutable data flow is easier to reason about. When data doesn't change, its state is always clear, reducing bugs related to unexpected side effects.\n2.  **Performance Optimization (especially in React/Redux):** In frameworks like React, immutability simplifies change detection. Instead of deep comparisons, a simple reference equality check (`===`) is sufficient to determine if an object has changed. This is crucial for optimizing re-renders in components (e.g., using `PureComponent` or `React.memo`).\n3.  **Structural Sharing:** Immutable.js leverages structural sharing, which means that when a new version of a data structure is created, it reuses as much of the old structure as possible. Only the parts that have actually changed are copied. This minimizes memory consumption and improves performance for large data sets.\n    *   Example: If you have a `List` of 1000 items and you `push` a new item, a new `List` is returned, but it shares the underlying 1000 items with the original list. Only the new item and a small number of internal nodes are truly new.\n4.  **Easier Debugging and Time-Travel Debugging:** With immutable data, you have a complete history of states, making it straightforward to track how data evolved over time. This enables powerful debugging techniques like time-travel debugging in Redux DevTools.\n5.  **Concurrency:** While less critical in single-threaded JavaScript, immutability fundamentally simplifies concurrent programming by eliminating race conditions on shared mutable state.\n\n## What is Immutable.js?\nImmutable.js is a library created by Facebook that provides a collection of immutable, persistent data structures for JavaScript. These structures are highly optimized for performance, especially when dealing with frequent updates to large collections. It offers data structures like `List`, `Map`, `Set`, `Stack`, and `Queue`, which are analogous to their mutable JavaScript counterparts but guarantee immutability.",
          "examples": [],
          "relatedQuestions": [
            "question_immutable_js_intro_1",
            "question_immutable_js_intro_2",
            "question_immutable_js_intro_3",
            "question_immutable_js_intro_4",
            "question_immutable_js_intro_5"
          ],
          "relatedTasks": [
            "task_immutable_js_intro_1"
          ],
          "tags": [
            "Immutable.js",
            "Immutability",
            "Functional Programming",
            "Performance",
            "React"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "JavaScript_basics",
            "Data_structures_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "React_performance_optimization",
            "Redux_state_management"
          ]
        },
        {
          "id": "theory_immutable_list",
          "title": "Immutable.js List",
          "content": "The `Immutable.List` is an immutable, ordered indexed collection, similar to a JavaScript Array. It provides methods that allow you to perform operations like adding, removing, and updating elements, but unlike native arrays, these methods return a *new* List instance, leaving the original unchanged. This adherence to immutability is crucial for predictable state management and performance optimizations in applications.\n\n### Key Characteristics:\n*   **Indexed Collection:** Elements are accessed by numerical index, starting from 0.\n*   **Ordered:** The order of elements is preserved as they are added.\n*   **Persistent Data Structure:** Operations return new instances, enabling structural sharing for efficiency.\n\n### Common Methods:\n*   `Immutable.List([initialValues])`: Creates a new List.\n*   `size`: Returns the number of elements in the list.\n*   `pop()`: Returns a new List with the last element removed.\n*   `push(value1, value2, ...)`: Returns a new List with one or more values appended to the end.\n*   `shift()`: Returns a new List with the first element removed.\n*   `unshift(value1, value2, ...)`: Returns a new List with one or more values prepended to the beginning.\n*   `concat(value1, value2, ...)`: Returns a new List by concatenating one or more values or other collections.\n*   `sort(comparator)`: Returns a new List with elements sorted according to the provided comparator function (or default comparison if none). The original list is not modified.\n*   `get(index)`: Returns the value at the specified index.\n*   `set(index, value)`: Returns a new List with the value at `index` set to `value`.\n*   `splice(index, removeNum, ...values)`: Returns a new List with elements removed and/or added at the specified index.\n*   `map(mapper)`: Applies a function to each element and returns a new List with the results.\n*   `filter(predicate)`: Returns a new List containing only elements for which the predicate returns true.",
          "examples": [
            {
              "id": "example_immutable_list_1",
              "title": "Basic List Operations",
              "code": "import { List } from 'immutable';\n\nlet list = List([1, 3, 2, 4, 5]);\n\nconsole.log('Original list:', list.toJS()); // [1, 3, 2, 4, 5]\nconsole.log('List size:', list.size); // 5\n\nlist = list.pop().pop(); // Removes 5, then 4\nconsole.log('After two pops:', list.toJS()); // [1, 3, 2]\n\nlist = list.push(6);\nconsole.log('After push(6):', list.toJS()); // [1, 3, 2, 6]\n\nlist = list.shift();\nconsole.log('After shift():', list.toJS()); // [3, 2, 6]\n\nlist = list.concat([9, 0, 1, 4]); // Can take multiple args or an array\nconsole.log('After concat(9, 0, 1, 4):', list.toJS()); // [3, 2, 6, 9, 0, 1, 4]\n\nlist = list.sort();\nconsole.log('After sort():', list.toJS()); // [0, 1, 2, 3, 4, 6, 9]\n\nconst originalListAfterOps = List([1, 3, 2, 4, 5]);\nconsole.log('Original list unchanged:', originalListAfterOps.toJS()); // [1, 3, 2, 4, 5]",
              "explanation": "This example demonstrates how common array-like operations (`pop`, `push`, `shift`, `concat`, `sort`) are performed on an `Immutable.List`. Crucially, each operation returns a *new* list, and the `originalListAfterOps` variable still holds its initial state, proving the immutability. The `toJS()` method is used to convert the Immutable List back to a plain JavaScript Array for easier logging.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_immutable_list_1",
            "question_immutable_list_2",
            "question_immutable_list_3",
            "question_immutable_list_4",
            "question_immutable_list_5"
          ],
          "relatedTasks": [
            "task_immutable_list_1"
          ],
          "tags": [
            "Immutable.js",
            "List",
            "Data Structures",
            "Array-like",
            "Immutability"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "theory_immutable_js_intro"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "State_management",
            "UI_list_rendering"
          ]
        },
        {
          "id": "theory_immutable_stack",
          "title": "Immutable.js Stack",
          "content": "An `Immutable.Stack` is an immutable, ordered collection of elements organized according to the LIFO (Last In, First Out) principle. This means the last element added to the stack is the first one to be removed. Stacks are fundamental data structures often used for managing function call contexts, undo/redo operations, or tracking history.\n\n### Key Characteristics:\n*   **LIFO (Last In, First Out):** Elements are added and removed from the 'top' of the stack.\n*   **Ordered:** Insertion order is maintained for elements.\n*   **Persistent Data Structure:** Like other Immutable.js collections, operations return new Stack instances.\n\n### Common Methods:\n*   `new Immutable.Stack([initialValues])`: Creates a new Stack instance.\n*   `push(value1, value2, ...)`: Returns a new Stack with one or more values added to the top (the beginning of the internal list representation).\n*   `pop()`: Returns a new Stack with the top element removed.\n*   `peek()`: Returns the top element of the stack without removing it. (Not shown in markdown, but very common).\n*   `get(index)`: Returns the element at a specific index. For a stack, `get(0)` typically returns the top element, `get(1)` the next, and so on.\n*   `size`: Returns the number of elements in the stack.",
          "examples": [
            {
              "id": "example_immutable_stack_1",
              "title": "Basic Stack Operations",
              "code": "import { Stack } from 'immutable';\n\nlet stack = new Stack();\n\nconsole.log('Initial stack:', stack.toJS()); // []\n\n// Push multiple elements. They are added in order, but the last pushed is at index 0 (top)\nstack = stack.push(2, 1, 0); \nconsole.log('After push(2, 1, 0):', stack.toJS()); // [0, 1, 2] -- Note: `toJS()` might reverse for display convenience, internal order is 0 (top), 1, 2\n\nconsole.log('Stack size:', stack.size); // 3\n\n// get(0) returns the top element (the last one pushed)\nconsole.log('stack.get(0):', stack.get(0)); // 0 \nconsole.log('stack.get(1):', stack.get(1)); // 1\nconsole.log('stack.get(2):', stack.get(2)); // 2\n\n// Pop removes the top element (0)\nstack = stack.pop(); \nconsole.log('After pop():', stack.toJS()); // [1, 2]\n\nconst originalStack = new Stack().push(2,1,0);\nconsole.log('Original stack unchanged:', originalStack.toJS()); // [0, 1, 2]",
              "explanation": "This example demonstrates the LIFO behavior of `Immutable.Stack`. When `push(2, 1, 0)` is called, `0` becomes the 'top' element (at index 0). `get(0)` correctly retrieves `0`. `pop()` removes `0`, making `1` the new top element. The `toJS()` conversion for `Stack` often reverses the internal representation to match typical stack visualization (top at the end of the array), but Immutable.js internal `get(index)` reflects the 'top-first' access. This also highlights immutability as the original stack remains unaffected.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_immutable_stack_1",
            "question_immutable_stack_2",
            "question_immutable_stack_3"
          ],
          "relatedTasks": [
            "task_immutable_stack_1"
          ],
          "tags": [
            "Immutable.js",
            "Stack",
            "Data Structures",
            "LIFO",
            "Immutability"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "theory_immutable_js_intro"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Undo_redo_functionality",
            "History_management"
          ]
        },
        {
          "id": "theory_immutable_map",
          "title": "Immutable.js Map",
          "content": "An `Immutable.Map` is an immutable collection that stores data as key-value pairs, analogous to a JavaScript Object or a hash map. It's ideal for representing structured data where elements are accessed by unique string or numerical keys.\n\n### Key Characteristics:\n*   **Key-Value Pairs:** Stores data in `key: value` format.\n*   **Unordered (by default):** The order of insertion is generally *not* guaranteed for iteration or `toJS()` conversion. For order preservation, use `Immutable.OrderedMap`.\n*   **Unique Keys:** Each key must be unique within the Map.\n*   **Persistent Data Structure:** Operations like `set` and `delete` return a new Map, leaving the original unchanged, which supports structural sharing.\n\n### Common Methods:\n*   `new Immutable.Map([initialData])`: Creates a new Map. `initialData` can be a JS Object or an array of `[key, value]` pairs.\n*   `set(key, value)`: Returns a new Map with the given `key` set to `value`. If `key` already exists, its value is updated.\n*   `get(key, notSetValue)`: Returns the value associated with `key`. If `key` is not found, `notSetValue` is returned (defaults to `undefined`).\n*   `delete(key)`: Returns a new Map with the specified `key` and its value removed.\n*   `has(key)`: Returns `true` if the Map contains the specified `key`, `false` otherwise.\n*   `merge(otherMap)`: Returns a new Map with the keys and values from `otherMap` merged into it. If keys conflict, `otherMap`'s values take precedence.\n*   `toJS()`: Converts the Map to a plain JavaScript object. (Deep conversion for nested Immutable.js structures).\n*   `toJSON()`: Alias for `toJS()` for `Map`.\n*   `toObject()`: Converts the Map to a plain JavaScript object (shallow conversion).",
          "examples": [
            {
              "id": "example_immutable_map_1",
              "title": "Basic Map Operations",
              "code": "import { Map } from 'immutable';\n\nlet map = new Map();\n\nconsole.log('Initial map:', map.toJS()); // {}\n\nmap = map.set('value', 5);\nconsole.log('After set(\\'value\\', 5):', map.toJS()); // {value: 5}\n\nmap = map.set('text', 'Test');\nconsole.log('After set(\\'text\\', \\'Test\\'):', map.toJS()); // {value: 5, text: \"Test\"}\n\nmap = map.delete('text');\nconsole.log('After delete(\\'text\\'):', map.toJS()); // {value: 5}\n\nconst originalMap = new Map().set('value', 5).set('text', 'Test');\nconsole.log('Original map unchanged:', originalMap.toJS()); // {value: 5, text: \"Test\"}\n\nconsole.log('Value of \\'value\\':', map.get('value')); // 5\nconsole.log('Has key \\'value\\':', map.has('value')); // true\nconsole.log('Has key \\'text\\':', map.has('text')); // false",
              "explanation": "This example demonstrates the core `Immutable.Map` operations: `set` and `delete`. Each operation returns a new `Map` instance, ensuring that the `originalMap` remains unchanged. The `toJS()` method converts the Immutable Map to a standard JavaScript object for console output. `get` and `has` methods are also shown for accessing and checking for keys.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_immutable_map_1",
            "question_immutable_map_2",
            "question_immutable_map_3",
            "question_immutable_map_4"
          ],
          "relatedTasks": [
            "task_immutable_map_1"
          ],
          "tags": [
            "Immutable.js",
            "Map",
            "Data Structures",
            "Key-Value",
            "Immutability"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "theory_immutable_js_intro"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "State_management",
            "Configuration_handling"
          ]
        },
        {
          "id": "theory_immutable_orderedmap",
          "title": "Immutable.js OrderedMap",
          "content": "An `Immutable.OrderedMap` is a specialized `Immutable.Map` that guarantees the preservation of the original insertion order of its keys. While a regular `Immutable.Map` does not make guarantees about iteration order, `OrderedMap` ensures that when you iterate over its entries (e.g., using `for...of` or `forEach`), they will appear in the order they were first added.\n\n### Key Characteristics:\n*   **Key-Value Pairs:** Like `Immutable.Map`, it stores data as `key: value` pairs.\n*   **Order Preservation:** The most significant feature; it remembers the order in which keys were first inserted. If a key's value is updated, its position in the order remains the same.\n*   **Persistent Data Structure:** All operations that modify the map (e.g., `set`, `delete`) return a new `OrderedMap` instance.\n\n### When to use `OrderedMap`?\nUse `OrderedMap` when the order of keys matters for your application logic or UI presentation, such as:\n*   Displaying form fields in a specific, user-defined order.\n*   Maintaining a list of configuration options where the sequence is important.\n*   Implementing a cache where older entries need to be evicted based on insertion time (though specific LRU logic would be needed).\n\nKeep in mind that `OrderedMap` might have a slightly higher memory footprint and slightly slower performance for certain operations compared to a regular `Map` due to the overhead of maintaining insertion order.",
          "examples": [
            {
              "id": "example_immutable_orderedmap_1",
              "title": "OrderedMap Iteration",
              "code": "import { OrderedMap } from 'immutable';\n\nlet map = new OrderedMap();\n\nmap = map.set('m', 5);\nmap = map.set('a', 1);\nmap = map.set('p', 8);\n\nconsole.log('OrderedMap content:', map.toJS()); // { m: 5, a: 1, p: 8 }\n\nconsole.log('Iteration order:');\n// Iteration order will be: ['m', 5], ['a', 1], ['p', 8]\nfor(const elem of map) {\n  console.log(elem); // Prints [ 'm', 5 ], [ 'a', 1 ], [ 'p', 8 ] in order\n}\n\n// Updating a value doesn't change its position\nmap = map.set('a', 100);\nconsole.log('After updating \\'a\\':', map.toJS()); // { m: 5, a: 100, p: 8 }\nconsole.log('Iteration order after update:');\nfor(const elem of map) {\n  console.log(elem); // Still [ 'm', 5 ], [ 'a', 100 ], [ 'p', 8 ] in order\n}",
              "explanation": "This example clearly shows the primary feature of `Immutable.OrderedMap`: keys are iterated in the order they were *first inserted*. Even when the value for an existing key (`'a'`) is updated, its position in the iteration order remains fixed. The `for...of` loop demonstrates this explicit ordering.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_immutable_orderedmap_1",
            "question_immutable_orderedmap_2",
            "question_immutable_orderedmap_3"
          ],
          "relatedTasks": [
            "task_immutable_orderedmap_1"
          ],
          "tags": [
            "Immutable.js",
            "OrderedMap",
            "Data Structures",
            "Order Preservation",
            "Immutability"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "theory_immutable_js_intro",
            "theory_immutable_map"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Ordered_configuration",
            "Dynamic_form_generation"
          ]
        },
        {
          "id": "theory_immutable_set",
          "title": "Immutable.js Set",
          "content": "An `Immutable.Set` is an immutable collection of unique values, analogous to a JavaScript `Set`. It's designed for scenarios where you need to store a collection of items but are only concerned with their presence, not their order or count of occurrences.\n\n### Key Characteristics:\n*   **Unique Values:** Automatically ensures that each value added to the set is unique. Duplicate values are ignored.\n*   **Unordered (by default):** The order of insertion is generally *not* guaranteed when iterating over an `Immutable.Set`. For order preservation, use `Immutable.OrderedSet`.\n*   **Persistent Data Structure:** Operations like `add`, `delete`, `union`, `intersect` return a new `Set` instance.\n\n### Common Methods:\n*   `Immutable.Set([initialValues])`: Creates a new Set. `initialValues` can be an array or any iterable.\n*   `add(value)`: Returns a new Set with `value` added. If `value` already exists, it returns the same Set instance (due to structural sharing and no change).\n*   `delete(value)`: Returns a new Set with `value` removed.\n*   `has(value)`: Returns `true` if the Set contains `value`, `false` otherwise.\n*   `count()` / `size`: Both methods return the number of unique elements in the Set.\n*   `union(...collections)`: Returns a new Set containing all unique values from this Set and the provided collections.\n*   `intersect(...collections)`: Returns a new Set containing only the values that are present in this Set and all provided collections.\n*   `subtract(...collections)`: Returns a new Set containing values from this Set that are not present in any of the provided collections.\n*   `toJS()`: Converts the Set to a plain JavaScript Array. (Deep conversion).\n*   `toArray()`: Alias for `toJS()` for `Set`.\n*   `toJSON()`: Alias for `toJS()` for `Set`.",
          "examples": [
            {
              "id": "example_immutable_set_1",
              "title": "Basic Set Operations",
              "code": "import { Set } from 'immutable';\n\nvar s1 = Set([2, 1]);\nvar s2 = Set([2, 3, 3]); // Duplicates are removed here\nvar s3 = Set([1, 1, 1]);\n\nconsole.log('s1 (from [2, 1]):', s1.toJS()); // [1, 2] (order not guaranteed, often sorted by JS engine)\nconsole.log('s2 (from [2, 3, 3]):', s2.toJS()); // [2, 3]\nconsole.log('s3 (from [1, 1, 1]):', s3.toJS()); // [1]\n\nconsole.log('Count s1, s2, s3:', s1.count(), s2.size, s3.count()); // 2 2 1\n\n// toJS(), toArray(), toJSON() are aliases for Set\nconsole.log('s1.toJS():', s1.toJS()); // [1, 2]\nconsole.log('s2.toArray():', s2.toArray()); // [2, 3]\nconsole.log('s3.toJSON():', s3.toJSON()); // [1]\n\nvar s1S2Intersect = s1.intersect(s2);\nconsole.log('s1 intersect s2:', s1S2Intersect.toJSON()); // [2]\n\nconsole.log('s1 has 1:', s1.has(1)); // true\nconsole.log('s1 has 5:', s1.has(5)); // false\n\nconst originalS1 = Set([2, 1]);\nconsole.log('Original s1 unchanged:', originalS1.toJS()); // [1, 2]",
              "explanation": "This example showcases the core features of `Immutable.Set`: maintaining unique values and performing set operations like intersection. Notice how `s2` and `s3` automatically remove duplicates during creation. `count()` and `size` both return the number of unique elements. The `intersect()` method returns a new Set containing only the common elements. `toJS()`, `toArray()`, and `toJSON()` are demonstrated for converting back to plain JavaScript arrays. Immutability is maintained as original sets are not altered.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_immutable_set_1",
            "question_immutable_set_2",
            "question_immutable_set_3"
          ],
          "relatedTasks": [
            "task_immutable_set_1"
          ],
          "tags": [
            "Immutable.js",
            "Set",
            "Data Structures",
            "Unique Values",
            "Immutability"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "theory_immutable_js_intro"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Managing_unique_tags",
            "Feature_toggles"
          ]
        },
        {
          "id": "theory_immutable_orderedset",
          "title": "Immutable.js OrderedSet",
          "content": "An `Immutable.OrderedSet` combines the uniqueness constraint of a `Set` with the order preservation of an `OrderedMap`. It is an immutable collection of unique values that maintains the original insertion order of its elements.\n\n### Key Characteristics:\n*   **Unique Values:** Ensures that all elements are unique.\n*   **Order Preservation:** Elements are iterated in the order they were first added.\n*   **Persistent Data Structure:** Operations return a new `OrderedSet` instance.\n\n### When to use `OrderedSet`?\n`OrderedSet` is useful when you need a collection of unique items where the order of their addition is significant for display or logic. Examples include:\n*   A list of recently viewed unique items, where the order reflects recency.\n*   Managing a unique list of tags that should appear in the order they were selected.\n*   Implementing a custom deduplicated event log where the sequence of events is crucial.\n\nSimilar to `OrderedMap`, `OrderedSet` might have a slight performance or memory overhead compared to a regular `Set` due to the need to maintain insertion order.",
          "examples": [
            {
              "id": "example_immutable_orderedset_1",
              "title": "OrderedSet Union Operation",
              "code": "import { OrderedSet } from 'immutable';\n\nvar s1 = OrderedSet([2, 1]);\nvar s2 = OrderedSet([2, 3, 3]); // Duplicates are removed, order from [2, 3]\nvar s3 = OrderedSet([1, 1, 1]); // Duplicates removed, order from [1]\n\nconsole.log('s1 (OrderedSet([2, 1])):', s1.toJS()); // [2, 1]\nconsole.log('s2 (OrderedSet([2, 3, 3])):', s2.toJS()); // [2, 3]\nconsole.log('s3 (OrderedSet([1, 1, 1])):', s3.toJS()); // [1]\n\n// Union operation combines unique elements, preserving first seen order\nvar s1S2S3Union = s1.union(s2, s3);\nconsole.log('s1 union s2 union s3:', s1S2S3Union.toJSON()); // [2, 1, 3]\n\n// Explanation of union result: \n// From s1: 2, 1\n// From s2: 2 (already seen), 3 (new, added after 1)\n// From s3: 1 (already seen)\n// Result: [2, 1, 3]\n\nconst originalS1 = OrderedSet([2, 1]);\nconsole.log('Original s1 unchanged:', originalS1.toJS()); // [2, 1]",
              "explanation": "This example demonstrates `Immutable.OrderedSet`'s behavior, particularly with the `union()` method. It highlights that duplicates are removed while the *first observed insertion order* of unique elements from all combined sets is preserved. In the `union` example, `2` from `s1` is seen first, then `1` from `s1`, then `3` from `s2` (as `2` was already seen). `1` from `s3` is also already seen, so it doesn't change the order or add a duplicate. This results in the ordered unique collection `[2, 1, 3]`. Immutability ensures the original sets remain untouched.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_immutable_orderedset_1",
            "question_immutable_orderedset_2",
            "question_immutable_orderedset_3"
          ],
          "relatedTasks": [
            "task_immutable_orderedset_1"
          ],
          "tags": [
            "Immutable.js",
            "OrderedSet",
            "Data Structures",
            "Unique Values",
            "Order Preservation",
            "Immutability"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "theory_immutable_js_intro",
            "theory_immutable_set"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Maintaining_ordered_unique_lists",
            "UI_tag_display"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_immutable_js_intro_1",
          "topic": "Immutability Concepts",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the core principle of immutability in programming?",
          "answer": "Once an object is created, it cannot be changed. Any operation that appears to modify it returns a new object.",
          "options": [],
          "analysisPoints": [
            "Understanding of the fundamental definition of immutability.",
            "Ability to distinguish it from mutable data manipulation."
          ],
          "keyConcepts": [
            "Immutability",
            "Persistent data structures"
          ],
          "evaluationCriteria": [
            "Direct recall of definition"
          ],
          "example": "Immutable data structures are those that cannot be modified after they are created. Instead of modifying an existing structure, any operation that would typically modify it (like adding an element) returns a new, modified version of that structure, leaving the original intact.",
          "tags": [
            "Immutability",
            "Core Concepts"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_js_intro_2",
          "topic": "Benefits of Immutability",
          "level": "medium",
          "type": "open",
          "question": "Explain at least three key benefits of using immutable data structures in a frontend application, particularly in the context of React or similar frameworks.",
          "answer": "Benefits include: 1. Predictability: Easier to reason about data flow as state doesn't change unexpectedly. 2. Performance Optimization: Simplifies change detection (reference equality checks instead of deep comparisons), crucial for React's `PureComponent` or `React.memo`. 3. Structural Sharing: Saves memory and improves performance by reusing unchanged parts of data structures. 4. Easier Debugging: Provides a clear history of state changes, enabling time-travel debugging. 5. Concurrency (less relevant for single-threaded JS, but a general benefit): Eliminates race conditions.",
          "options": [],
          "analysisPoints": [
            "Ability to articulate core advantages beyond just 'no side effects'.",
            "Connecting immutability to specific frontend framework benefits (e.g., React re-renders).",
            "Understanding of structural sharing concept."
          ],
          "keyConcepts": [
            "Immutability",
            "React performance",
            "Structural sharing",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Completeness of the answer (minimum 3 distinct benefits).",
            "Clarity and accuracy of explanations.",
            "Ability to apply concepts to real-world scenarios (React)."
          ],
          "example": "Consider a React component that re-renders only when its props or state change. If data is mutable, a deep comparison is needed to detect changes, which can be expensive. With immutable data, a simple `===` check is enough because any modification results in a new object reference.",
          "tags": [
            "Immutability",
            "React",
            "Performance",
            "Frontend Architecture"
          ],
          "prerequisites": [
            "theory_immutable_js_intro"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_js_intro_3",
          "topic": "Structural Sharing",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following best describes 'structural sharing' in the context of Immutable.js?",
          "answer": "When an immutable data structure is modified, only the changed parts are copied, and the unchanged parts retain references to the original data.",
          "options": [
            "When an immutable data structure is modified, the entire structure is deeply cloned.",
            "It refers to the ability to share mutable objects across different parts of an application.",
            "When an immutable data structure is modified, only the changed parts are copied, and the unchanged parts retain references to the original data.",
            "It's a technique to share DOM elements between different React components."
          ],
          "analysisPoints": [
            "Understanding the core mechanism of structural sharing.",
            "Distinguishing it from deep cloning.",
            "Recognizing its memory and performance implications."
          ],
          "keyConcepts": [
            "Structural Sharing",
            "Immutability",
            "Performance"
          ],
          "evaluationCriteria": [
            "Accurate definition of structural sharing.",
            "Rejection of misleading or incorrect options."
          ],
          "example": "If you have an `Immutable.List` of 1000 items and you `push` one new item, Immutable.js doesn't copy all 1000 items. Instead, it creates new nodes only for the path leading to the new item, while the vast majority of the original 1000 items are still referenced by the new list, saving memory and CPU cycles.",
          "tags": [
            "Immutability",
            "Performance",
            "Data Structures"
          ],
          "prerequisites": [
            "theory_immutable_js_intro"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_js_intro_4",
          "topic": "Immutable.js Basic Usage",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary way to convert an Immutable.js collection back to a plain JavaScript collection?",
          "answer": "Using the `.toJS()` method.",
          "options": [],
          "analysisPoints": [
            "Recall of common conversion methods.",
            "Understanding the need for explicit conversion."
          ],
          "keyConcepts": [
            "Immutable.js",
            "Conversion"
          ],
          "evaluationCriteria": [
            "Direct recall of method name"
          ],
          "example": "```typescript\nimport { List } from 'immutable';\n\nconst immutableList = List([1, 2, 3]);\nconst jsArray = immutableList.toJS();\n\nconsole.log(jsArray); // [1, 2, 3]\nconsole.log(Array.isArray(jsArray)); // true\n```",
          "tags": [
            "Immutable.js",
            "Conversion"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_js_intro_5",
          "topic": "Immutable.js Purpose",
          "level": "easy",
          "type": "mcq",
          "question": "What is the main problem that Immutable.js aims to solve in JavaScript applications?",
          "answer": "Managing mutable state and its unpredictable side effects.",
          "options": [
            "Optimizing DOM manipulation performance.",
            "Managing mutable state and its unpredictable side effects.",
            "Providing an alternative syntax for asynchronous operations.",
            "Implementing server-side rendering for JavaScript applications."
          ],
          "analysisPoints": [
            "Identifying the core pain point addressed by immutability.",
            "Filtering out irrelevant or secondary concerns."
          ],
          "keyConcepts": [
            "Immutability",
            "State Management",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Correctly identifying the primary problem.",
            "Understanding the context of Immutable.js."
          ],
          "example": "In complex applications, especially with shared state, modifying objects directly can lead to unexpected behaviors in other parts of the application that hold references to the same object. Immutable.js eliminates this by ensuring every 'modification' results in a new, distinct state.",
          "tags": [
            "Immutability",
            "State Management",
            "Problem Solving"
          ],
          "prerequisites": [
            "theory_immutable_js_intro"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_list_1",
          "topic": "Immutable.List Operations",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following Immutable.js code:\n\n```typescript\nimport { List } from 'immutable';\n\nlet myList = List([10, 20, 30, 40]);\nconst originalList = myList;\n\nmyList = myList.pop();\nmyList = myList.unshift(5);\nmyList = myList.concat(50, 60);\n\nconst result = myList.toJS();\n```\n\nWhat will be the value of `result` and `originalList.toJS()` after these operations?",
          "answer": "result: [5, 10, 20, 50, 60], originalList.toJS(): [10, 20, 30, 40]",
          "options": [
            "result: [5, 10, 20, 30, 40, 50, 60], originalList.toJS(): [10, 20, 30, 40]",
            "result: [5, 10, 20, 50, 60], originalList.toJS(): [5, 10, 20, 50, 60]",
            "result: [5, 10, 20, 50, 60], originalList.toJS(): [10, 20, 30, 40]",
            "result: [5, 10, 20], originalList.toJS(): [10, 20, 30, 40, 50, 60]"
          ],
          "analysisPoints": [
            "Correct application of `pop()`, `unshift()`, and `concat()` on `Immutable.List`.",
            "Understanding that each operation returns a *new* list, preserving the original.",
            "Ability to trace the state of the list through multiple immutable operations."
          ],
          "keyConcepts": [
            "Immutable.List",
            "Immutability",
            "Chainable operations"
          ],
          "evaluationCriteria": [
            "Accuracy of the final list content.",
            "Correct understanding of immutability (original list unchanged)."
          ],
          "example": "1. `myList = List([10, 20, 30, 40]);`\n2. `originalList` points to `[10, 20, 30, 40]`.\n3. `myList.pop()`: returns `[10, 20, 30]`. `myList` is reassigned.\n4. `myList.unshift(5)`: returns `[5, 10, 20, 30]`. `myList` is reassigned.\n5. `myList.concat(50, 60)`: returns `[5, 10, 20, 30, 50, 60]`. `myList` is reassigned.\nTherefore, `result` is `[5, 10, 20, 30, 50, 60]`, and `originalList` remains `[10, 20, 30, 40]`.",
          "tags": [
            "Immutable.List",
            "Operations",
            "Immutability",
            "Debugging"
          ],
          "prerequisites": [
            "theory_immutable_list"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_list_2",
          "topic": "Immutable.List vs. JS Array",
          "level": "medium",
          "type": "open",
          "question": "What is the primary difference in behavior between `Array.prototype.push()` and `Immutable.List.prototype.push()`?",
          "answer": "The primary difference is mutability. `Array.prototype.push()` is a mutable operation; it modifies the original array in place and returns the new length of the array. `Immutable.List.prototype.push()`, however, is an immutable operation; it does *not* modify the original `Immutable.List` but instead returns a *new* `Immutable.List` instance with the element appended, leaving the original list untouched.",
          "options": [],
          "analysisPoints": [
            "Clearly articulating the mutable vs. immutable distinction.",
            "Explaining the return value difference.",
            "Highlighting the concept of a new instance vs. in-place modification."
          ],
          "keyConcepts": [
            "Immutable.List",
            "JavaScript Array",
            "Mutability",
            "Immutability",
            "Side effects"
          ],
          "evaluationCriteria": [
            "Accurate comparison of behavior.",
            "Emphasis on the immutability aspect.",
            "Understanding of return values."
          ],
          "example": "```typescript\nconst arr = [1, 2];\narr.push(3); // arr is now [1, 2, 3]\n\nimport { List } from 'immutable';\nlet list = List([1, 2]);\nconst newList = list.push(3); // list is still List([1, 2]), newList is List([1, 2, 3])\n```",
          "tags": [
            "Immutable.List",
            "JavaScript Array",
            "Comparison",
            "Mutability"
          ],
          "prerequisites": [
            "theory_immutable_list"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_list_3",
          "topic": "Immutable.List Method Understanding",
          "level": "easy",
          "type": "flashcard",
          "question": "Which `Immutable.List` method would you use to remove elements from the beginning of the list?",
          "answer": "`shift()`",
          "options": [],
          "analysisPoints": [
            "Recall of specific `Immutable.List` methods.",
            "Mapping method names to their functionality."
          ],
          "keyConcepts": [
            "Immutable.List",
            "Methods",
            "Manipulation"
          ],
          "evaluationCriteria": [
            "Direct recall"
          ],
          "example": "```typescript\nimport { List } from 'immutable';\n\nlet list = List([1, 2, 3]);\nlist = list.shift();\nconsole.log(list.toJS()); // [2, 3]\n```",
          "tags": [
            "Immutable.List",
            "Methods"
          ],
          "prerequisites": [
            "theory_immutable_list"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_list_4",
          "topic": "Immutable.List Conversion",
          "level": "easy",
          "type": "mcq",
          "question": "Given an `Immutable.List` named `myImmutableList`, what is the correct way to convert it to a standard JavaScript array?",
          "answer": "`myImmutableList.toJS()`",
          "options": [
            "`myImmutableList.toArray()`",
            "`myImmutableList.toJS()`",
            "`Array.from(myImmutableList)`",
            "`JSON.parse(JSON.stringify(myImmutableList))`"
          ],
          "analysisPoints": [
            "Correctly identifying the standard conversion method for Immutable.js.",
            "Understanding that `toArray()` is also valid for List, but `toJS()` is more general for deep conversion.",
            "Discarding incorrect or inefficient methods."
          ],
          "keyConcepts": [
            "Immutable.List",
            "Conversion"
          ],
          "evaluationCriteria": [
            "Knowing the primary conversion method.",
            "Understanding its purpose."
          ],
          "example": "Both `toJS()` and `toArray()` work for `Immutable.List`. `toJS()` is generally preferred as it recursively converts nested Immutable.js collections, while `toArray()` would only convert the top-level list to an array, leaving nested Immutable.js collections intact if they exist.",
          "tags": [
            "Immutable.List",
            "Conversion"
          ],
          "prerequisites": [
            "theory_immutable_list",
            "theory_immutable_js_intro"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_list_5",
          "topic": "Immutable.List Sorting",
          "level": "medium",
          "type": "code",
          "question": "Write a TypeScript function `sortNumbersInList` that takes an `Immutable.List<number>` and returns a new `Immutable.List<number>` with the numbers sorted in ascending order. Ensure the original list is not modified.",
          "answer": "```typescript\nimport { List } from 'immutable';\n\nfunction sortNumbersInList(list: List<number>): List<number> {\n  // The sort method on Immutable.List returns a new sorted list\n  return list.sort();\n}\n\n// Example usage:\nconst originalList = List([5, 2, 8, 1, 9, 3]);\nconst sortedList = sortNumbersInList(originalList);\n\nconsole.log('Original List:', originalList.toJS()); // [5, 2, 8, 1, 9, 3]\nconsole.log('Sorted List:', sortedList.toJS());   // [1, 2, 3, 5, 8, 9]\n\nconst anotherList = List([10, 0, -5, 7]);\nconst anotherSortedList = sortNumbersInList(anotherList);\nconsole.log('Another Sorted List:', anotherSortedList.toJS()); // [-5, 0, 7, 10]\n```",
          "options": [],
          "analysisPoints": [
            "Correct usage of `List.prototype.sort()`.",
            "Understanding that `sort()` returns a new list, adhering to immutability.",
            "TypeScript type annotations."
          ],
          "keyConcepts": [
            "Immutable.List",
            "Sorting",
            "Immutability",
            "TypeScript"
          ],
          "evaluationCriteria": [
            "Functional correctness (list is sorted).",
            "Adherence to immutability (original list unchanged).",
            "Proper function signature and types."
          ],
          "example": "The key is to use the `sort()` method directly on the `Immutable.List`. Unlike JavaScript's `Array.prototype.sort()`, `Immutable.List.prototype.sort()` is pure and returns a new sorted `List` instance.",
          "tags": [
            "Immutable.List",
            "Coding Challenge",
            "Sorting",
            "Immutability"
          ],
          "prerequisites": [
            "theory_immutable_list"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_stack_1",
          "topic": "Immutable.Stack LIFO",
          "level": "easy",
          "type": "mcq",
          "question": "What does LIFO stand for in the context of `Immutable.Stack`?",
          "answer": "Last In, First Out",
          "options": [
            "Last In, First Out",
            "Lowest Input, Fastest Output",
            "Lazy Initialization, Fast Operations",
            "List In, First Out"
          ],
          "analysisPoints": [
            "Understanding of common data structure acronyms.",
            "Correct association of LIFO with Stack."
          ],
          "keyConcepts": [
            "Immutable.Stack",
            "LIFO",
            "Data Structures"
          ],
          "evaluationCriteria": [
            "Accurate definition of LIFO."
          ],
          "example": "A stack of plates: you add new plates to the top (last in), and when you take a plate, you take it from the top (first out).",
          "tags": [
            "Immutable.Stack",
            "Data Structures",
            "Concepts"
          ],
          "prerequisites": [
            "theory_immutable_stack"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_stack_2",
          "topic": "Immutable.Stack Operations",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following Immutable.js code:\n\n```typescript\nimport { Stack } from 'immutable';\n\nlet myStack = Stack();\nmyStack = myStack.push('A', 'B'); // 'B' is top, then 'A'\nmyStack = myStack.push('C'); // 'C' is top\nmyStack = myStack.pop();\nconst topElement = myStack.get(0);\nconst size = myStack.size;\n```\n\nWhat will be the value of `topElement` and `size`?",
          "answer": "topElement: 'A', size: 2",
          "options": [
            "topElement: 'C', size: 2",
            "topElement: 'B', size: 3",
            "topElement: 'A', size: 2",
            "topElement: 'B', size: 2"
          ],
          "analysisPoints": [
            "Correctly tracing `push` and `pop` operations on a stack.",
            "Understanding that `push` adds to the 'top' (index 0 for `get`).",
            "Accurate calculation of `size` after operations."
          ],
          "keyConcepts": [
            "Immutable.Stack",
            "LIFO",
            "Stack Operations"
          ],
          "evaluationCriteria": [
            "Accuracy of top element determination.",
            "Correct size calculation.",
            "Understanding of stack behavior."
          ],
          "example": "1. `myStack = Stack();` // Stack: []\n2. `myStack = myStack.push('A', 'B');` // Stack: ['B', 'A'] (B is top, at index 0)\n3. `myStack = myStack.push('C');` // Stack: ['C', 'B', 'A'] (C is top, at index 0)\n4. `myStack = myStack.pop();` // Stack: ['B', 'A'] (C removed)\n5. `topElement = myStack.get(0);` // 'B'\n6. `size = myStack.size;` // 2",
          "tags": [
            "Immutable.Stack",
            "Operations",
            "LIFO",
            "Debugging"
          ],
          "prerequisites": [
            "theory_immutable_stack"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_stack_3",
          "topic": "Immutable.Stack Use Case",
          "level": "medium",
          "type": "open",
          "question": "Describe a common real-world use case where `Immutable.Stack` would be a suitable data structure. Provide a brief explanation of why it fits the LIFO principle.",
          "answer": "A common use case for `Immutable.Stack` is implementing an **undo/redo functionality** in an application. When a user performs an action, the state before the action is 'pushed' onto an undo stack. To undo, the last state 'popped' from the undo stack is restored. Similarly, for redo, undone states can be pushed onto a redo stack. This fits the LIFO principle because the last action performed is the first one to be undone, and the last undone action is the first to be redone.",
          "options": [],
          "analysisPoints": [
            "Identifying a relevant and practical use case.",
            "Clearly explaining how the LIFO principle applies to that use case.",
            "Demonstrating understanding of stack's strengths."
          ],
          "keyConcepts": [
            "Immutable.Stack",
            "LIFO",
            "Use Cases",
            "Undo/Redo"
          ],
          "evaluationCriteria": [
            "Relevance of the use case.",
            "Logical connection between use case and LIFO.",
            "Clarity of explanation."
          ],
          "example": "Imagine a text editor. Every time you type a character or apply formatting, the previous document state is added to an undo stack. If you hit 'undo', the most recent state is popped off, and the document reverts to the state before that change.",
          "tags": [
            "Immutable.Stack",
            "Use Cases",
            "Architecture",
            "Design Patterns"
          ],
          "prerequisites": [
            "theory_immutable_stack"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_map_1",
          "topic": "Immutable.Map Basic Operations",
          "level": "medium",
          "type": "mcq",
          "question": "What is the output of `map.toJS()` after the following operations?\n\n```typescript\nimport { Map } from 'immutable';\n\nlet map = Map({ a: 1, b: 2 });\nmap = map.set('c', 3);\nmap = map.delete('a');\nmap = map.set('b', 10);\n\nconsole.log(map.toJS());\n```",
          "answer": "{ b: 10, c: 3 }",
          "options": [
            "{ a: 1, b: 2, c: 3 }",
            "{ b: 2, c: 3 }",
            "{ b: 10, c: 3 }",
            "{ a: 1, c: 3 }"
          ],
          "analysisPoints": [
            "Correctly tracing `set` and `delete` operations on `Immutable.Map`.",
            "Understanding that `set` can update existing keys.",
            "Awareness of the immutability (each operation returns a new Map)."
          ],
          "keyConcepts": [
            "Immutable.Map",
            "Operations",
            "Key-Value"
          ],
          "evaluationCriteria": [
            "Accuracy of final Map content.",
            "Correct application of `set` for updates."
          ],
          "example": "1. `map = Map({ a: 1, b: 2 });` // Map: { a: 1, b: 2 }\n2. `map = map.set('c', 3);` // Map: { a: 1, b: 2, c: 3 }\n3. `map = map.delete('a');` // Map: { b: 2, c: 3 }\n4. `map = map.set('b', 10);` // Map: { b: 10, c: 3 }\nOutput: `{ b: 10, c: 3 }`",
          "tags": [
            "Immutable.Map",
            "Operations",
            "Debugging"
          ],
          "prerequisites": [
            "theory_immutable_map"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_map_2",
          "topic": "Immutable.Map vs. JavaScript Object",
          "level": "medium",
          "type": "open",
          "question": "When would you prefer using `Immutable.Map` over a plain JavaScript object for storing key-value data in a frontend application?",
          "answer": "You would prefer `Immutable.Map` over a plain JavaScript object when:\n1.  **State Management:** In complex applications, especially with libraries like React and Redux, where predictable state changes are critical for debugging and consistency.\n2.  **Performance Optimization:** When dealing with frequent updates to large data structures, `Immutable.Map`'s structural sharing allows for efficient change detection (reference equality checks) and avoids costly deep cloning operations.\n3.  **Preventing Accidental Mutations:** To ensure data integrity by guaranteeing that data is never unexpectedly modified by different parts of the application.\n4.  **Complex Keys:** `Immutable.Map` (and `JS Map`) allows non-string keys (e.g., other objects), which plain JS objects do not handle natively.\n5.  **Functional Programming Paradigms:** It aligns better with functional programming principles by promoting pure functions without side effects.",
          "options": [],
          "analysisPoints": [
            "Understanding the benefits of immutability in practical scenarios.",
            "Connecting it to performance, state management, and debugging.",
            "Identifying specific features (like complex keys) that distinguish it from plain objects."
          ],
          "keyConcepts": [
            "Immutable.Map",
            "JavaScript Object",
            "Comparison",
            "Use Cases",
            "Performance"
          ],
          "evaluationCriteria": [
            "Providing multiple valid reasons.",
            "Clear explanation of why `Immutable.Map` is superior in those scenarios.",
            "Demonstrating knowledge of immutability's impact."
          ],
          "example": "Imagine a user profile object in a Redux store. If it's a plain JS object, a component might accidentally mutate it, leading to subtle bugs and difficult-to-trace state changes. An `Immutable.Map` ensures that any 'modification' returns a new object, forcing explicit updates and making state changes transparent.",
          "tags": [
            "Immutable.Map",
            "JavaScript Object",
            "Comparison",
            "Use Cases"
          ],
          "prerequisites": [
            "theory_immutable_map",
            "theory_immutable_js_intro"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_immutable_map_3",
          "topic": "Immutable.Map Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Which `Immutable.Map` method is used to add or update a key-value pair?",
          "answer": "`set(key, value)`",
          "options": [],
          "analysisPoints": [
            "Recall of fundamental Map operations.",
            "Correct method signature."
          ],
          "keyConcepts": [
            "Immutable.Map",
            "Methods"
          ],
          "evaluationCriteria": [
            "Direct recall"
          ],
          "example": "```typescript\nimport { Map } from 'immutable';\n\nlet user = Map({ name: 'Alice' });\nuser = user.set('age', 30); // Add new key\nuser = user.set('name', 'Bob'); // Update existing key\nconsole.log(user.toJS()); // { name: 'Bob', age: 30 }\n```",
          "tags": [
            "Immutable.Map",
            "Methods"
          ],
          "prerequisites": [
            "theory_immutable_map"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_map_4",
          "topic": "Immutable.Map Merging",
          "level": "medium",
          "type": "code",
          "question": "Implement a TypeScript function `mergeUserData` that takes an initial `Immutable.Map<string, any>` representing user data and a partial `Immutable.Map<string, any>` representing updates. The function should return a new `Immutable.Map` with the updates applied, ensuring immutability. If a key exists in both, the update's value should take precedence.",
          "answer": "```typescript\nimport { Map } from 'immutable';\n\nfunction mergeUserData(\n  initialData: Map<string, any>,\n  updates: Map<string, any>\n): Map<string, any> {\n  // The merge method correctly combines maps, with the latter taking precedence for conflicts\n  return initialData.merge(updates);\n}\n\n// Example usage:\nconst currentUser = Map({\n  id: 'user123',\n  name: 'Alice',\n  email: 'alice@example.com',\n  settings: Map({ theme: 'dark', notifications: true })\n});\n\nconst partialUpdate = Map({\n  email: 'alice.smith@example.com',\n  status: 'active',\n  settings: Map({ theme: 'light' }) // Nested map is also merged, but shallowly here\n});\n\nconst updatedUser = mergeUserData(currentUser, partialUpdate);\n\nconsole.log('Original User:', currentUser.toJS());\n/*\n{ \n  id: 'user123',\n  name: 'Alice',\n  email: 'alice@example.com',\n  settings: { theme: 'dark', notifications: true }\n}\n*/\n\nconsole.log('Updated User:', updatedUser.toJS());\n/*\n{ \n  id: 'user123',\n  name: 'Alice',\n  email: 'alice.smith@example.com',\n  status: 'active',\n  settings: { theme: 'light' } // Note: settings map is replaced entirely if not deep merged\n}\n*/\n\n// If deep merge is desired for nested maps, use mergeDeep\nconst deepUpdatedUser = currentUser.mergeDeep(partialUpdate);\nconsole.log('Deep Merged User:', deepUpdatedUser.toJS());\n/*\n{ \n  id: 'user123',\n  name: 'Alice',\n  email: 'alice.smith@example.com',\n  status: 'active',\n  settings: { theme: 'light', notifications: true } // 'notifications' is preserved\n}\n*/\n```",
          "options": [],
          "analysisPoints": [
            "Correctly using the `merge()` method of `Immutable.Map`.",
            "Understanding that `merge()` returns a new `Map`.",
            "Consideration of deep merging vs. shallow merging for nested structures (`mergeDeep` vs `merge`)."
          ],
          "keyConcepts": [
            "Immutable.Map",
            "Merging",
            "Immutability",
            "TypeScript"
          ],
          "evaluationCriteria": [
            "Functional correctness of merge logic.",
            "Adherence to immutability.",
            "Proper function signature and types."
          ],
          "example": "The `merge()` method is perfect for this. It takes another `Map` (or a plain object) and combines its entries. If there are duplicate keys, the values from the `updates` map will overwrite those from `initialData`. For nested Immutable structures, `mergeDeep()` might be more appropriate if you want to merge objects at all levels rather than replacing them.",
          "tags": [
            "Immutable.Map",
            "Coding Challenge",
            "Merging",
            "Immutability"
          ],
          "prerequisites": [
            "theory_immutable_map"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_orderedmap_1",
          "topic": "Immutable.OrderedMap Order Preservation",
          "level": "medium",
          "type": "mcq",
          "question": "What is the key distinguishing feature of `Immutable.OrderedMap` compared to `Immutable.Map`?",
          "answer": "It preserves the original insertion order of keys.",
          "options": [
            "It allows duplicate keys.",
            "It stores data more efficiently for very large datasets.",
            "It provides faster access to values by key.",
            "It preserves the original insertion order of keys."
          ],
          "analysisPoints": [
            "Identifying the primary benefit and difference of `OrderedMap`.",
            "Discarding distractors that might apply to `Map` generally or are incorrect."
          ],
          "keyConcepts": [
            "Immutable.OrderedMap",
            "Immutable.Map",
            "Order Preservation",
            "Comparison"
          ],
          "evaluationCriteria": [
            "Accurate identification of the distinguishing feature."
          ],
          "example": "If you create `new Map().set('b', 2).set('a', 1)`, the iteration order of 'a' and 'b' is not guaranteed. However, with `new OrderedMap().set('b', 2).set('a', 1)`, iterating will always yield 'b' then 'a'.",
          "tags": [
            "Immutable.OrderedMap",
            "Comparison",
            "Concepts"
          ],
          "prerequisites": [
            "theory_immutable_orderedmap",
            "theory_immutable_map"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_orderedmap_2",
          "topic": "Immutable.OrderedMap Iteration",
          "level": "medium",
          "type": "mcq",
          "question": "What will be the output order of keys when iterating over `myMap` using `for...of` in the following code?\n\n```typescript\nimport { OrderedMap } from 'immutable';\n\nlet myMap = OrderedMap();\nmyMap = myMap.set('zebra', 1);\nmyMap = myMap.set('apple', 2);\nmyMap = myMap.set('banana', 3);\nmyMap = myMap.set('apple', 10); // Update existing key\n\n// for (const [key, value] of myMap) { console.log(key); }\n```",
          "answer": "zebra, apple, banana",
          "options": [
            "zebra, apple, banana",
            "apple, banana, zebra",
            "banana, apple, zebra",
            "Order is not guaranteed with OrderedMap."
          ],
          "analysisPoints": [
            "Understanding that `OrderedMap` preserves *initial* insertion order.",
            "Recognizing that updating an existing key does not change its position.",
            "Tracing the insertion sequence."
          ],
          "keyConcepts": [
            "Immutable.OrderedMap",
            "Iteration Order",
            "Insertion Order"
          ],
          "evaluationCriteria": [
            "Correct prediction of iteration order.",
            "Understanding of update behavior in `OrderedMap`."
          ],
          "example": "1. `set('zebra', 1)`: 'zebra' is first.\n2. `set('apple', 2)`: 'apple' is second.\n3. `set('banana', 3)`: 'banana' is third.\n4. `set('apple', 10)`: 'apple' already exists, its value is updated, but its position (second) remains the same.\nSo the order is always: 'zebra', 'apple', 'banana'.",
          "tags": [
            "Immutable.OrderedMap",
            "Iteration",
            "Order"
          ],
          "prerequisites": [
            "theory_immutable_orderedmap"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_orderedmap_3",
          "topic": "Immutable.OrderedMap Use Cases",
          "level": "open",
          "type": "open",
          "question": "Provide a practical scenario in frontend development where `Immutable.OrderedMap` would be more appropriate than `Immutable.Map`, and explain why.",
          "answer": "A practical scenario for `Immutable.OrderedMap` is managing **dynamic form fields** where the order of fields is determined by user input or specific business logic and must be preserved for display. For example, a form builder that allows users to add custom fields (e.g., 'Name', 'Email', 'Address') and reorder them.\n\n`Immutable.OrderedMap` is more appropriate because:\n1.  **UI Consistency:** The order of fields in the UI directly depends on the order they were added or rearranged by the user. A regular `Immutable.Map` does not guarantee insertion order, so the fields might render inconsistently or unpredictably.\n2.  **Serialization/Deserialization:** If you need to serialize the form schema to JSON and later deserialize it, `OrderedMap` ensures that the fields are restored in the exact same sequence, which is critical for consistent user experience and data processing.\n\n`Immutable.Map` would be insufficient because its iteration order is not guaranteed, meaning the form fields might appear in a different sequence each time the component renders, leading to a poor user experience.",
          "options": [],
          "analysisPoints": [
            "Identifying a real-world scenario where order is crucial.",
            "Clearly articulating why `OrderedMap` is superior in that scenario.",
            "Contrasting it with `Immutable.Map` to highlight the difference."
          ],
          "keyConcepts": [
            "Immutable.OrderedMap",
            "Use Cases",
            "Order Preservation",
            "UI Development"
          ],
          "evaluationCriteria": [
            "Relevance and clarity of the use case.",
            "Logical reasoning for choosing `OrderedMap`.",
            "Understanding of the limitations of `Immutable.Map`."
          ],
          "example": "In a dashboard builder, users can add widgets like 'Sales Chart', 'User List', 'Recent Activity'. If they arrange them in a specific column order, using `OrderedMap` to store the widget configuration ensures they always load and display in that exact custom order.",
          "tags": [
            "Immutable.OrderedMap",
            "Use Cases",
            "Frontend Architecture"
          ],
          "prerequisites": [
            "theory_immutable_orderedmap"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_immutable_set_1",
          "topic": "Immutable.Set Uniqueness",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is the primary characteristic of `Immutable.Set`?",
          "answer": "It stores only unique values.",
          "options": [
            "It stores only unique values.",
            "It preserves the order of insertion.",
            "It allows fast access to values by index.",
            "It can store key-value pairs."
          ],
          "analysisPoints": [
            "Identifying the fundamental property of a Set (uniqueness).",
            "Distinguishing it from other collection types."
          ],
          "keyConcepts": [
            "Immutable.Set",
            "Uniqueness",
            "Characteristics"
          ],
          "evaluationCriteria": [
            "Accurate identification of the primary characteristic."
          ],
          "example": "If you try to add the value `5` to an `Immutable.Set` that already contains `5`, the set will remain unchanged (it won't add a duplicate), and the operation will return the same set instance, leveraging structural sharing.",
          "tags": [
            "Immutable.Set",
            "Concepts",
            "Uniqueness"
          ],
          "prerequisites": [
            "theory_immutable_set"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_set_2",
          "topic": "Immutable.Set Operations",
          "level": "medium",
          "type": "mcq",
          "question": "What is the output of `s1.intersect(s2).toJS()` given the following code?\n\n```typescript\nimport { Set } from 'immutable';\n\nconst s1 = Set([1, 2, 3, 4]);\nconst s2 = Set([3, 4, 5, 6]);\n\nconst result = s1.intersect(s2).toJS();\nconsole.log(result);\n```",
          "answer": "[3, 4]",
          "options": [
            "[1, 2, 3, 4, 5, 6]",
            "[3, 4]",
            "[1, 2]",
            "[5, 6]"
          ],
          "analysisPoints": [
            "Correctly applying the `intersect()` set operation.",
            "Understanding what `intersect` means (common elements).",
            "Knowing how `toJS()` converts the Set to an Array."
          ],
          "keyConcepts": [
            "Immutable.Set",
            "Set Operations",
            "Intersection"
          ],
          "evaluationCriteria": [
            "Accuracy of the intersection result.",
            "Correct conversion to JS Array."
          ],
          "example": "The `intersect()` method finds elements that are common to *both* sets. In this case, `1` and `2` are only in `s1`, and `5` and `6` are only in `s2`. `3` and `4` are present in both `s1` and `s2`, hence they are the intersection.",
          "tags": [
            "Immutable.Set",
            "Operations",
            "Set Logic"
          ],
          "prerequisites": [
            "theory_immutable_set"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_set_3",
          "topic": "Immutable.Set Conversion",
          "level": "easy",
          "type": "flashcard",
          "question": "Name three methods that convert an `Immutable.Set` instance to a plain JavaScript Array.",
          "answer": "`toJS()`, `toArray()`, `toJSON()`",
          "options": [],
          "analysisPoints": [
            "Recall of multiple conversion methods for Sets.",
            "Understanding that they are aliases for Set."
          ],
          "keyConcepts": [
            "Immutable.Set",
            "Conversion",
            "Methods"
          ],
          "evaluationCriteria": [
            "Direct recall of method names"
          ],
          "example": "```typescript\nimport { Set } from 'immutable';\n\nconst mySet = Set([1, 2, 3]);\nconsole.log(mySet.toJS());   // [1, 2, 3]\nconsole.log(mySet.toArray()); // [1, 2, 3]\nconsole.log(mySet.toJSON());  // [1, 2, 3]\n```",
          "tags": [
            "Immutable.Set",
            "Methods",
            "Conversion"
          ],
          "prerequisites": [
            "theory_immutable_set"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_orderedset_1",
          "topic": "Immutable.OrderedSet vs. Set",
          "level": "medium",
          "type": "open",
          "question": "What is the primary difference and a suitable use case distinguishing `Immutable.OrderedSet` from `Immutable.Set`?",
          "answer": "The primary difference is **order preservation**. While both `Immutable.Set` and `Immutable.OrderedSet` ensure that all values are unique, `Immutable.OrderedSet` additionally guarantees that the order in which elements were *first inserted* is maintained when iterating or converting to a JavaScript array. `Immutable.Set` does not guarantee any specific order.\n\nA suitable use case for `Immutable.OrderedSet` would be managing a list of **unique search tags or filters** that a user has applied, where the visual display order of these tags on the UI needs to reflect the order in which the user selected them. For example, if a user filters by 'red', then 'small', then 'new', the tags should consistently appear as 'red', 'small', 'new' in the UI.",
          "options": [],
          "analysisPoints": [
            "Clearly identifying order preservation as the key differentiator.",
            "Providing a concrete, logical use case where this difference matters.",
            "Explaining *why* order matters in the given use case."
          ],
          "keyConcepts": [
            "Immutable.OrderedSet",
            "Immutable.Set",
            "Comparison",
            "Order Preservation",
            "Use Cases"
          ],
          "evaluationCriteria": [
            "Accurate comparison.",
            "Relevant and well-explained use case.",
            "Demonstrating practical application."
          ],
          "example": "If you add `['apple', 'banana', 'apple', 'cherry']` to an `Immutable.OrderedSet`, converting it `toJS()` will yield `['apple', 'banana', 'cherry']` in that exact order. An `Immutable.Set` might return `['apple', 'cherry', 'banana']` or `['banana', 'apple', 'cherry']` depending on internal hash collision resolution or JS engine specifics.",
          "tags": [
            "Immutable.OrderedSet",
            "Comparison",
            "Use Cases"
          ],
          "prerequisites": [
            "theory_immutable_orderedset",
            "theory_immutable_set"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_orderedset_2",
          "topic": "Immutable.OrderedSet Union",
          "level": "medium",
          "type": "mcq",
          "question": "What is the output of `s1.union(s2).toJS()` given the following code?\n\n```typescript\nimport { OrderedSet } from 'immutable';\n\nconst s1 = OrderedSet(['a', 'b']);\nconst s2 = OrderedSet(['b', 'c', 'a']);\n\nconst result = s1.union(s2).toJS();\nconsole.log(result);\n```",
          "answer": "['a', 'b', 'c']",
          "options": [
            "['a', 'b', 'c']",
            "['b', 'c', 'a']",
            "['a', 'b', 'b', 'c', 'a']",
            "['a', 'b']"
          ],
          "analysisPoints": [
            "Correctly applying the `union()` set operation for `OrderedSet`.",
            "Understanding that `union` combines unique elements.",
            "Preservation of first-seen insertion order from the combined sets."
          ],
          "keyConcepts": [
            "Immutable.OrderedSet",
            "Set Operations",
            "Union",
            "Order Preservation"
          ],
          "evaluationCriteria": [
            "Accuracy of the union result.",
            "Correct order of elements in the result."
          ],
          "example": "1. `s1` contributes 'a', then 'b'.\n2. `s2` contributes 'b' (already seen), then 'c' (new), then 'a' (already seen).\nTherefore, the first time 'a' is seen is from `s1`, then 'b' from `s1`, then 'c' from `s2`. The unique, ordered result is `['a', 'b', 'c']`.",
          "tags": [
            "Immutable.OrderedSet",
            "Operations",
            "Order",
            "Set Logic"
          ],
          "prerequisites": [
            "theory_immutable_orderedset"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_orderedset_3",
          "topic": "Immutable.OrderedSet Functionality",
          "level": "easy",
          "type": "flashcard",
          "question": "Does `Immutable.OrderedSet` allow duplicate values?",
          "answer": "No, like `Immutable.Set`, it only stores unique values. The 'Ordered' part refers to preserving insertion order among unique values.",
          "options": [],
          "analysisPoints": [
            "Understanding the core uniqueness property of all Sets.",
            "Distinguishing the 'Ordered' aspect as related to order, not uniqueness."
          ],
          "keyConcepts": [
            "Immutable.OrderedSet",
            "Uniqueness",
            "Order Preservation"
          ],
          "evaluationCriteria": [
            "Direct recall of uniqueness property"
          ],
          "example": "```typescript\nimport { OrderedSet } from 'immutable';\n\nlet myOrderedSet = OrderedSet([1, 2, 2, 3, 1]);\nconsole.log(myOrderedSet.toJS()); // [1, 2, 3]\nconsole.log(myOrderedSet.size); // 3\n```",
          "tags": [
            "Immutable.OrderedSet",
            "Concepts",
            "Uniqueness"
          ],
          "prerequisites": [
            "theory_immutable_orderedset"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_immutable_js_intro_1",
          "title": "Migrate and Manage Product Data Immutably",
          "description": "\nYour task is to refactor an existing product data management system to use `Immutable.js` for better state predictability and performance. You need to convert plain JavaScript arrays and objects into Immutable.js collections, perform some common operations immutably, and then convert them back for display.\n\n**Requirements:**\n1.  Create an initial product catalog using `Immutable.List` of `Immutable.Map`s from a given plain JS array of objects.\n2.  Implement a function `addProduct` that takes the current immutable catalog and a new product object (plain JS), and returns a new immutable catalog with the product added.\n3.  Implement a function `updateProductPrice` that takes the current immutable catalog, a product ID, and a new price. It should return a new immutable catalog with the specified product's price updated. This update must be done immutably.\n4.  Implement a function `removeProduct` that takes the current immutable catalog and a product ID, and returns a new immutable catalog with the product removed.\n5.  Finally, implement a function `getJsCatalog` that converts the final immutable catalog back to a plain JavaScript array of objects.\n",
          "difficulty": "medium",
          "startingCode": "import { List, Map } from 'immutable';\n\ninterface Product { \n  id: string; \n  name: string; \n  price: number; \n  inStock: boolean; \n}\n\nconst initialProducts: Product[] = [\n  { id: 'p1', name: 'Laptop', price: 1200, inStock: true },\n  { id: 'p2', name: 'Mouse', price: 25, inStock: true },\n  { id: 'p3', name: 'Keyboard', price: 75, inStock: false }\n];\n\n// 1. Function to initialize immutable catalog\nfunction initializeCatalog(products: Product[]): List<Map<string, any>> {\n  // TODO: Implement this\n  return List();\n}\n\n// 2. Function to add a product\nfunction addProduct(catalog: List<Map<string, any>>, newProduct: Product): List<Map<string, any>> {\n  // TODO: Implement this\n  return catalog;\n}\n\n// 3. Function to update product price\nfunction updateProductPrice(catalog: List<Map<string, any>>, productId: string, newPrice: number): List<Map<string, any>> {\n  // TODO: Implement this\n  return catalog;\n}\n\n// 4. Function to remove a product\nfunction removeProduct(catalog: List<Map<string, any>>, productId: string): List<Map<string, any>> {\n  // TODO: Implement this\n  return catalog;\n}\n\n// 5. Function to convert immutable catalog to plain JS\nfunction getJsCatalog(catalog: List<Map<string, any>>): Product[] {\n  // TODO: Implement this\n  return [];\n}\n\n// Example Usage (for testing your functions):\nconst immutableCatalog = initializeCatalog(initialProducts);\nconsole.log('Initial Immutable Catalog (JS):', getJsCatalog(immutableCatalog));\n\nconst newProduct = { id: 'p4', name: 'Monitor', price: 300, inStock: true };\nconst catalogAfterAdd = addProduct(immutableCatalog, newProduct);\nconsole.log('Catalog After Add (JS):', getJsCatalog(catalogAfterAdd));\n\nconst catalogAfterUpdate = updateProductPrice(catalogAfterAdd, 'p1', 1150);\nconsole.log('Catalog After Update (JS):', getJsCatalog(catalogAfterUpdate));\n\nconst catalogAfterRemove = removeProduct(catalogAfterUpdate, 'p2');\nconsole.log('Catalog After Remove (JS):', getJsCatalog(catalogAfterRemove));\n\n// Verify original catalog is unchanged\nconsole.log('Original Catalog Still Intact (JS):', getJsCatalog(immutableCatalog));\n",
          "solutionCode": "import { List, Map } from 'immutable';\n\ninterface Product { \n  id: string; \n  name: string; \n  price: number; \n  inStock: boolean; \n}\n\nconst initialProducts: Product[] = [\n  { id: 'p1', name: 'Laptop', price: 1200, inStock: true },\n  { id: 'p2', name: 'Mouse', price: 25, inStock: true },\n  { id: 'p3', name: 'Keyboard', price: 75, inStock: false }\n];\n\n// 1. Function to initialize immutable catalog\nfunction initializeCatalog(products: Product[]): List<Map<string, any>> {\n  return List(products.map(product => Map(product)));\n}\n\n// 2. Function to add a product\nfunction addProduct(catalog: List<Map<string, any>>, newProduct: Product): List<Map<string, any>> {\n  return catalog.push(Map(newProduct));\n}\n\n// 3. Function to update product price\nfunction updateProductPrice(catalog: List<Map<string, any>>, productId: string, newPrice: number): List<Map<string, any>> {\n  const index = catalog.findIndex(product => product.get('id') === productId);\n  if (index !== -1) {\n    return catalog.update(index, product => product.set('price', newPrice));\n  }\n  return catalog; // Return original if not found\n}\n\n// 4. Function to remove a product\nfunction removeProduct(catalog: List<Map<string, any>>, productId: string): List<Map<string, any>> {\n  const index = catalog.findIndex(product => product.get('id') === productId);\n  if (index !== -1) {\n    return catalog.delete(index);\n  }\n  return catalog; // Return original if not found\n}\n\n// 5. Function to convert immutable catalog to plain JS\nfunction getJsCatalog(catalog: List<Map<string, any>>): Product[] {\n  return catalog.toJS() as Product[];\n}\n\n// Example Usage (for testing your functions):\nconst immutableCatalog = initializeCatalog(initialProducts);\nconsole.log('Initial Immutable Catalog (JS):', getJsCatalog(immutableCatalog));\n\nconst newProduct = { id: 'p4', name: 'Monitor', price: 300, inStock: true };\nconst catalogAfterAdd = addProduct(immutableCatalog, newProduct);\nconsole.log('Catalog After Add (JS):', getJsCatalog(catalogAfterAdd));\n\nconst catalogAfterUpdate = updateProductPrice(catalogAfterAdd, 'p1', 1150);\nconsole.log('Catalog After Update (JS):', getJsCatalog(catalogAfterUpdate));\n\nconst catalogAfterRemove = removeProduct(catalogAfterUpdate, 'p2');\nconsole.log('Catalog After Remove (JS):', getJsCatalog(catalogAfterRemove));\n\n// Verify original catalog is unchanged\nconsole.log('Original Catalog Still Intact (JS):', getJsCatalog(immutableCatalog));\n\n// Test edge cases\nconst catalogAfterNonExistentUpdate = updateProductPrice(catalogAfterAdd, 'non-existent', 999);\nconsole.log('Catalog After Non-Existent Update (JS - should be same as catalogAfterAdd):', getJsCatalog(catalogAfterNonExistentUpdate));\n\nconst catalogAfterNonExistentRemove = removeProduct(catalogAfterUpdate, 'non-existent');\nconsole.log('Catalog After Non-Existent Remove (JS - should be same as catalogAfterUpdate):', getJsCatalog(catalogAfterNonExistentRemove));",
          "testCases": [
            "Initialize with empty array: `initializeCatalog([])` should return an empty `List`.",
            "Add multiple products: `addProduct` should correctly add new items to the end.",
            "Update existing product price: `updateProductPrice` should change the price of the correct item and return a new `List`.",
            "Update non-existent product: `updateProductPrice` for a non-existent ID should return the original `List` without modification.",
            "Remove existing product: `removeProduct` should remove the correct item and return a new `List`.",
            "Remove non-existent product: `removeProduct` for a non-existent ID should return the original `List` without modification.",
            "Verify immutability: Ensure that the `initialCatalog` object remains unchanged after all subsequent operations.",
            "Conversion back to JS: `getJsCatalog` should correctly convert nested `Immutable.Map`s back to plain JS objects."
          ],
          "hints": [
            "Remember that `List()` and `Map()` constructors can take plain JavaScript arrays and objects, respectively, to initialize.",
            "For updating an element in a List based on a property (like `id`), you'll likely need `findIndex` followed by `update` or `set`.",
            "`delete(index)` is useful for removing an element at a specific position.",
            "The `.toJS()` method performs a deep conversion, which is exactly what you need for nested Immutable structures.",
            "Always return a new Immutable collection from your functions; never modify the input directly."
          ],
          "tags": [
            "Immutable.js",
            "List",
            "Map",
            "Data Management",
            "Immutability",
            "CRUD"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_immutable_js_intro",
            "theory_immutable_list",
            "theory_immutable_map"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "State_management",
            "Functional_programming"
          ]
        },
        {
          "id": "task_immutable_stack_1",
          "title": "Implement an Undo/Redo Manager with Immutable.Stack",
          "description": "\nDesign and implement a simple undo/redo manager for a generic application state. The manager should use `Immutable.Stack` to keep track of past and future states.\n\n**Requirements:**\n1.  Create a class `UndoRedoManager` that can be initialized with an initial state.\n2.  Implement an `executeAction(newState)` method. This method should:\n    *   Push the *current* state onto an `undoStack`.\n    *   Set the `current state` to `newState`.\n    *   Clear the `redoStack` (as a new action invalidates future 'redo' possibilities).\n3.  Implement an `undo()` method. This method should:\n    *   Pop the `current state` and push it onto the `redoStack`.\n    *   Pop the last state from the `undoStack` and make it the `current state`.\n    *   Return the new `current state`.\n    *   Handle cases where `undoStack` is empty (no more undos).\n4.  Implement a `redo()` method. This method should:\n    *   Pop the `current state` and push it onto the `undoStack`.\n    *   Pop the last state from the `redoStack` and make it the `current state`.\n    *   Return the new `current state`.\n    *   Handle cases where `redoStack` is empty (no more redos).\n5.  Implement a `getCurrentState()` method to retrieve the current application state.\n\nUse `Immutable.js` collections (e.g., `Immutable.Stack`) for `undoStack` and `redoStack`. The states themselves can be simple numbers, strings, or even `Immutable.Map`s (though for this task, simpler types are fine).\n",
          "difficulty": "hard",
          "startingCode": "import { Stack, fromJS } from 'immutable';\n\nclass UndoRedoManager<T> {\n  private undoStack: Stack<T>;\n  private redoStack: Stack<T>;\n  private currentState: T;\n\n  constructor(initialState: T) {\n    this.currentState = initialState;\n    this.undoStack = Stack<T>();\n    this.redoStack = Stack<T>();\n  }\n\n  executeAction(newState: T): T {\n    // TODO: Implement this\n    return newState;\n  }\n\n  undo(): T {\n    // TODO: Implement this\n    return this.currentState;\n  }\n\n  redo(): T {\n    // TODO: Implement this\n    return this.currentState;\n  }\n\n  getCurrentState(): T {\n    return this.currentState;\n  }\n}\n\n// Example Usage:\nconst manager = new UndoRedoManager<string>('Initial State');\nconsole.log('Current:', manager.getCurrentState()); // Initial State\n\nmanager.executeAction('State A');\nconsole.log('Current:', manager.getCurrentState()); // State A\n\nmanager.executeAction('State B');\nconsole.log('Current:', manager.getCurrentState()); // State B\n\nmanager.executeAction('State C');\nconsole.log('Current:', manager.getCurrentState()); // State C\n\nmanager.undo();\nconsole.log('Undo 1:', manager.getCurrentState()); // State B\n\nmanager.undo();\nconsole.log('Undo 2:', manager.getCurrentState()); // State A\n\nmanager.redo();\nconsole.log('Redo 1:', manager.getCurrentState()); // State B\n\nmanager.executeAction('State D'); // New action, should clear redo stack\nconsole.log('Current:', manager.getCurrentState()); // State D\n\nmanager.redo(); // Should do nothing\nconsole.log('Redo after new action:', manager.getCurrentState()); // State D\n\nmanager.undo();\nconsole.log('Undo after new action:', manager.getCurrentState()); // State B\n",
          "solutionCode": "import { Stack, fromJS } from 'immutable';\n\nclass UndoRedoManager<T> {\n  private undoStack: Stack<T>;\n  private redoStack: Stack<T>;\n  private currentState: T;\n\n  constructor(initialState: T) {\n    this.currentState = initialState;\n    this.undoStack = Stack<T>();\n    this.redoStack = Stack<T>();\n  }\n\n  executeAction(newState: T): T {\n    // Push current state onto undo stack\n    this.undoStack = this.undoStack.push(this.currentState);\n    // Update current state\n    this.currentState = newState;\n    // Clear redo stack on new action\n    this.redoStack = Stack<T>();\n    return this.currentState;\n  }\n\n  undo(): T {\n    if (this.undoStack.isEmpty()) {\n      console.warn('Cannot undo: undo stack is empty.');\n      return this.currentState;\n    }\n    // Move current state to redo stack\n    this.redoStack = this.redoStack.push(this.currentState);\n    // Restore previous state from undo stack\n    this.currentState = this.undoStack.peek()!;\n    this.undoStack = this.undoStack.pop();\n    return this.currentState;\n  }\n\n  redo(): T {\n    if (this.redoStack.isEmpty()) {\n      console.warn('Cannot redo: redo stack is empty.');\n      return this.currentState;\n    }\n    // Move current state to undo stack\n    this.undoStack = this.undoStack.push(this.currentState);\n    // Restore next state from redo stack\n    this.currentState = this.redoStack.peek()!;\n    this.redoStack = this.redoStack.pop();\n    return this.currentState;\n  }\n\n  getCurrentState(): T {\n    return this.currentState;\n  }\n\n  // Optional: For debugging/testing\n  getUndoStackSize(): number {\n    return this.undoStack.size;\n  }\n  getRedoStackSize(): number {\n    return this.redoStack.size;\n  }\n}\n\n// Example Usage:\nconst manager = new UndoRedoManager<string>('Initial State');\nconsole.log('Current:', manager.getCurrentState(), 'Undo/Redo Sizes:', manager.getUndoStackSize(), manager.getRedoStackSize()); // Initial State 0 0\n\nmanager.executeAction('State A');\nconsole.log('Current:', manager.getCurrentState(), 'Undo/Redo Sizes:', manager.getUndoStackSize(), manager.getRedoStackSize()); // State A 1 0\n\nmanager.executeAction('State B');\nconsole.log('Current:', manager.getCurrentState(), 'Undo/Redo Sizes:', manager.getUndoStackSize(), manager.getRedoStackSize()); // State B 2 0\n\nmanager.executeAction('State C');\nconsole.log('Current:', manager.getCurrentState(), 'Undo/Redo Sizes:', manager.getUndoStackSize(), manager.getRedoStackSize()); // State C 3 0\n\nmanager.undo();\nconsole.log('Undo 1:', manager.getCurrentState(), 'Undo/Redo Sizes:', manager.getUndoStackSize(), manager.getRedoStackSize()); // State B 2 1\n\nmanager.undo();\nconsole.log('Undo 2:', manager.getCurrentState(), 'Undo/Redo Sizes:', manager.getUndoStackSize(), manager.getRedoStackSize()); // State A 1 2\n\nmanager.redo();\nconsole.log('Redo 1:', manager.getCurrentState(), 'Undo/Redo Sizes:', manager.getUndoStackSize(), manager.getRedoStackSize()); // State B 2 1\n\nmanager.executeAction('State D'); // New action, should clear redo stack\nconsole.log('Current:', manager.getCurrentState(), 'Undo/Redo Sizes:', manager.getUndoStackSize(), manager.getRedoStackSize()); // State D 3 0\n\nmanager.redo(); // Should do nothing\nconsole.log('Redo after new action:', manager.getCurrentState(), 'Undo/Redo Sizes:', manager.getUndoStackSize(), manager.getRedoStackSize()); // State D 3 0\n\nmanager.undo();\nconsole.log('Undo after new action:', manager.getCurrentState(), 'Undo/Redo Sizes:', manager.getUndoStackSize(), manager.getRedoStackSize()); // State B 2 1\n\nmanager.undo();\nmanager.undo();\nmanager.undo(); // Will warn\nconsole.log('After multiple undos:', manager.getCurrentState(), 'Undo/Redo Sizes:', manager.getUndoStackSize(), manager.getRedoStackSize()); // Initial State 0 3\n\nmanager.redo();\nmanager.redo();\nmanager.redo();\nmanager.redo(); // Will warn\nconsole.log('After multiple redos:', manager.getCurrentState(), 'Undo/Redo Sizes:', manager.getUndoStackSize(), manager.getRedoStackSize()); // State D 3 0\n",
          "testCases": [
            "Initial state: Manager should hold the initial state, stacks should be empty.",
            "Execute actions: `executeAction` should push current state to undo stack, update current state, and clear redo stack.",
            "Basic undo: Performing `undo` once should revert to the previous state, move current to redo, and get state from undo.",
            "Multiple undos: Test sequence of `executeAction` followed by multiple `undo` calls.",
            "Basic redo: After `undo`, performing `redo` should revert to the state before undo, move current to undo, and get state from redo.",
            "Multiple redos: Test sequence of `executeAction`, `undo`, `redo` calls.",
            "New action after undo: Verify `executeAction` correctly clears the redo stack if called after `undo` operations.",
            "Edge case: `undo` when `undoStack` is empty (should return current state and not error).",
            "Edge case: `redo` when `redoStack` is empty (should return current state and not error).",
            "Immutability: Ensure that states themselves (if they were Immutable.js structures) are not modified directly, but new instances are passed."
          ],
          "hints": [
            "Remember the LIFO principle of stacks: `push()` adds to the 'top', `pop()` removes from the 'top', and `peek()` inspects the 'top' without removing.",
            "When an action is executed, the `current state` effectively becomes the 'past' state for a potential undo, so it needs to be pushed onto the `undoStack` *before* the `current state` is updated.",
            "A new action (`executeAction`) invalidates any 'future' states that were in the `redoStack`, so `redoStack` should be reset (made empty) when `executeAction` is called.",
            "Handle empty stack conditions (`isEmpty()` method) to prevent errors when trying to pop from an empty stack.",
            "Use `Immutable.Stack.peek()` to get the top element without removing it, if needed, before `pop()`."
          ],
          "tags": [
            "Immutable.js",
            "Stack",
            "Design Pattern",
            "Undo/Redo",
            "State Management",
            "Data Structures"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_immutable_stack"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "LIFO",
            "State_history",
            "Command_pattern"
          ]
        },
        {
          "id": "task_immutable_map_1",
          "title": "Build a User Profile Editor with Immutable.Map",
          "description": "\nCreate a `UserProfile` class that manages user data using `Immutable.Map`. The class should demonstrate immutable updates to user details, including nested preferences.\n\n**Requirements:**\n1.  **Constructor:** Initialize the `UserProfile` with basic user data (e.g., `id`, `name`, `email`) as an `Immutable.Map`.\n2.  **`updateField(key, value)`:** A method to update a top-level field (e.g., `name`, `email`). It should return a *new* `UserProfile` instance with the updated data. The original instance must remain unchanged.\n3.  **`updatePreference(key, value)`:** A method to update a nested preference within a 'preferences' `Immutable.Map` (if it exists, otherwise create it). This also needs to return a new `UserProfile` instance with immutable updates. For example, if the user has `preferences: Map({ theme: 'dark' })`, `updatePreference('notifications', true)` should result in `preferences: Map({ theme: 'dark', notifications: true })`.\n4.  **`getProfile()`:** A method to return the current user profile as a plain JavaScript object (deeply converted).\n5.  **`isEqual(otherProfile)`:** A method to compare two `UserProfile` instances efficiently, leveraging Immutable.js's equality checks.\n",
          "difficulty": "medium",
          "startingCode": "import { Map, is } from 'immutable';\n\ninterface UserData {\n  id: string;\n  name: string;\n  email: string;\n  preferences?: { [key: string]: any };\n}\n\nclass UserProfile {\n  private readonly data: Map<string, any>;\n\n  constructor(initialData: UserData) {\n    // TODO: Initialize data Map, convert nested preferences if present\n    this.data = Map();\n  }\n\n  updateField(key: string, value: any): UserProfile {\n    // TODO: Implement this to return a new UserProfile instance\n    return this;\n  }\n\n  updatePreference(key: string, value: any): UserProfile {\n    // TODO: Implement this for nested preferences, return new UserProfile instance\n    return this;\n  }\n\n  getProfile(): UserData {\n    // TODO: Implement this to return a plain JS object\n    return {} as UserData;\n  }\n\n  isEqual(otherProfile: UserProfile): boolean {\n    // TODO: Implement efficient equality check\n    return false;\n  }\n}\n\n// Example Usage:\nconst initialUserData: UserData = {\n  id: 'u1',\n  name: 'John Doe',\n  email: 'john.doe@example.com',\n  preferences: { theme: 'dark', newsletter: true }\n};\n\nconst user1 = new UserProfile(initialUserData);\nconsole.log('User1 Initial:', user1.getProfile());\n\nconst user2 = user1.updateField('email', 'john.d@newdomain.com');\nconsole.log('User2 after email update:', user2.getProfile());\nconsole.log('User1 (original) after email update:', user1.getProfile()); // Should be unchanged\n\nconst user3 = user2.updatePreference('theme', 'light');\nconsole.log('User3 after theme update:', user3.getProfile());\nconsole.log('User2 (original) after theme update:', user2.getProfile()); // Should be unchanged\n\nconst user4 = user3.updatePreference('notifications', false); // Add new preference\nconsole.log('User4 after add preference:', user4.getProfile());\n\nconsole.log('Is user1 equal to user2?', user1.isEqual(user2)); // Should be false\nconsole.log('Is user2 equal to user3?', user2.isEqual(user3)); // Should be false\nconsole.log('Is user1 equal to user1 (itself)?', user1.isEqual(user1)); // Should be true\n",
          "solutionCode": "import { Map, is, fromJS } from 'immutable';\n\ninterface UserData {\n  id: string;\n  name: string;\n  email: string;\n  preferences?: { [key: string]: any };\n}\n\nclass UserProfile {\n  private readonly data: Map<string, any>;\n\n  constructor(initialData: UserData) {\n    // Use fromJS for deep conversion of initial data, including nested objects/arrays\n    this.data = fromJS(initialData) as Map<string, any>;\n  }\n\n  // Method to update a top-level field\n  updateField(key: string, value: any): UserProfile {\n    const newData = this.data.set(key, value);\n    // Return a new UserProfile instance wrapping the new Immutable Map\n    return new UserProfile(newData.toJS() as UserData); // Re-initialize to ensure proper type inference and instance creation\n  }\n\n  // Method to update a nested preference\n  updatePreference(key: string, value: any): UserProfile {\n    // Use updateIn for nested immutable updates, ensuring preferences map exists\n    const newData = this.data.updateIn(\n      ['preferences', key],\n      val => value // This will set the value if key exists or add if not\n    );\n    // Return a new UserProfile instance\n    return new UserProfile(newData.toJS() as UserData);\n  }\n\n  // Method to return the current user profile as a plain JavaScript object\n  getProfile(): UserData {\n    return this.data.toJS() as UserData;\n  }\n\n  // Method to compare two UserProfile instances efficiently using Immutable.is\n  isEqual(otherProfile: UserProfile): boolean {\n    return is(this.data, otherProfile.data);\n  }\n}\n\n// Example Usage:\nconst initialUserData: UserData = {\n  id: 'u1',\n  name: 'John Doe',\n  email: 'john.doe@example.com',\n  preferences: { theme: 'dark', newsletter: true }\n};\n\nconst user1 = new UserProfile(initialUserData);\nconsole.log('User1 Initial:', user1.getProfile());\n\nconst user2 = user1.updateField('email', 'john.d@newdomain.com');\nconsole.log('User2 after email update:', user2.getProfile());\nconsole.log('User1 (original) after email update:', user1.getProfile()); // Should be unchanged\n\nconst user3 = user2.updatePreference('theme', 'light');\nconsole.log('User3 after theme update:', user3.getProfile());\nconsole.log('User2 (original) after theme update:', user2.getProfile()); // Should be unchanged\n\nconst user4 = user3.updatePreference('notifications', false); // Add new preference\nconsole.log('User4 after add preference:', user4.getProfile());\n\nconsole.log('Is user1 equal to user2?', user1.isEqual(user2)); // Should be false\nconsole.log('Is user2 equal to user3?', user2.isEqual(user3)); // Should be false\nconsole.log('Is user1 equal to user1 (itself)?', user1.isEqual(user1)); // Should be true\n\n// Test edge cases\nconst user5 = new UserProfile({ id: 'u5', name: 'No Prefs', email: 'no@example.com' });\nconsole.log('User5 (no prefs):', user5.getProfile());\nconst user6 = user5.updatePreference('lang', 'en'); // Add preference to a user with no initial preferences\nconsole.log('User6 (added pref to no-pref user):', user6.getProfile()); // Should have { lang: 'en' }\n\nconst user7 = user6.updateField('name', 'No Prefs Updated'); // Update top level field on user with preferences\nconsole.log('User7 (updated field on user with prefs):', user7.getProfile());\n\nconsole.log('Is user5 equal to user6?', user5.isEqual(user6)); // Should be false\nconsole.log('Is user6 equal to user7?', user6.isEqual(user7)); // Should be false\n\nconst user8 = user7.updateField('name', 'No Prefs Updated'); // Update with same value\nconsole.log('Is user7 equal to user8 (same value update)?', user7.isEqual(user8)); // Should be true due to Immutable.js optimization\n",
          "testCases": [
            "Constructor: Initialize with and without a `preferences` object.",
            "Update top-level field: Change `name` or `email`, verify new `UserProfile` instance is returned and original is unchanged.",
            "Update existing preference: Change `theme` from 'dark' to 'light', verify new instance and correct nested update.",
            "Add new preference: Add `notifications` to a user profile, verify it's correctly nested and a new instance is returned.",
            "Add preference to user without initial `preferences` object: Verify `preferences` Map is created correctly.",
            "Convert to JS: `getProfile()` should return a plain JS object, with nested objects also converted.",
            "Equality check: `isEqual` should return `true` for identical profiles (same underlying Immutable.Map) and `false` for different ones.",
            "Equality for identical update: If `updateField` or `updatePreference` is called with the *same value* as currently stored, `isEqual` between the old and new instances should still be `true` (due to Immutable.js optimization returning the same instance if no effective change).",
            "Chained updates: Perform several updates in sequence and verify the final state and that all intermediate objects are distinct."
          ],
          "hints": [
            "Use `Immutable.fromJS()` in the constructor to convert the initial plain JavaScript object (and any nested objects/arrays) into Immutable.js collections automatically.",
            "For `updateField`, the `Map.set()` method is your friend. Remember it returns a new Map.",
            "For `updatePreference`, you'll need to update a nested value. `Map.updateIn(['preferences', key], updaterFunction)` or `Map.setIn(['preferences', key], value)` are suitable. `updateIn` is more robust if `preferences` might initially be missing or `undefined`.",
            "When returning a `UserProfile` instance from `updateField` or `updatePreference`, make sure you create a *new* `UserProfile` instance using the *new* `Immutable.Map` that was returned by `set` or `updateIn`.",
            "For `isEqual`, Immutable.js provides a utility function `Immutable.is()` which performs a deep equality check on Immutable.js collections efficiently."
          ],
          "tags": [
            "Immutable.js",
            "Map",
            "Class Design",
            "State Management",
            "Nested Data",
            "Immutability"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "theory_immutable_map",
            "theory_immutable_js_intro"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Deep_updates",
            "Referential_equality",
            "Data_modeling"
          ]
        },
        {
          "id": "task_immutable_orderedmap_1",
          "title": "Develop a Dynamic Configuration Manager with OrderedMap",
          "description": "\nImplement a `ConfigManager` class using `Immutable.OrderedMap` to handle application configurations where the order of configuration keys is important (e.g., for UI display or processing pipelines).\n\n**Requirements:**\n1.  **Constructor:** Initialize `ConfigManager` with an `Immutable.OrderedMap` or convert a plain JS object to it, preserving order.\n2.  **`addConfig(key, value)`:** Add a new configuration entry. If the key already exists, update its value but *maintain its original position*. Return a new `ConfigManager` instance.\n3.  **`removeConfig(key)`:** Remove a configuration entry. Return a new `ConfigManager` instance.\n4.  **`getOrderedKeys()`:** Return a plain JavaScript array of all configuration keys, ensuring they are in their insertion order.\n5.  **`getConfig(key)`:** Retrieve the value for a given key.\n6.  **`toPlainObject()`:** Convert the entire configuration to a plain JavaScript object, preserving the insertion order of keys (this means iterating the `OrderedMap` and building the object). Note that `toJS()` might not guarantee order for plain JS objects in older environments, so explicit iteration is safer for strict order preservation in plain objects.\n",
          "difficulty": "medium",
          "startingCode": "import { OrderedMap } from 'immutable';\n\nclass ConfigManager {\n  private readonly config: OrderedMap<string, any>;\n\n  constructor(initialConfig?: { [key: string]: any }) {\n    // TODO: Initialize config as OrderedMap, preserving order if initialConfig is provided\n    this.config = OrderedMap();\n  }\n\n  addConfig(key: string, value: any): ConfigManager {\n    // TODO: Add/update config, preserve original insertion order for existing keys\n    return this;\n  }\n\n  removeConfig(key: string): ConfigManager {\n    // TODO: Remove config\n    return this;\n  }\n\n  getOrderedKeys(): string[] {\n    // TODO: Return keys in insertion order\n    return [];\n  }\n\n  getConfig(key: string): any | undefined {\n    // TODO: Get config value\n    return undefined;\n  }\n\n  toPlainObject(): { [key: string]: any } {\n    // TODO: Convert to plain JS object, preserving order\n    return {};\n  }\n}\n\n// Example Usage:\nconst manager = new ConfigManager({ setting1: 'value1', setting2: 123 });\nconsole.log('Initial Config Keys:', manager.getOrderedKeys()); // ['setting1', 'setting2']\nconsole.log('Initial Config Object:', manager.toPlainObject());\n\nconst manager2 = manager.addConfig('setting3', true);\nconsole.log('Config2 Keys (add new):', manager2.getOrderedKeys()); // ['setting1', 'setting2', 'setting3']\n\nconst manager3 = manager2.addConfig('setting1', 'updatedValue'); // Update existing key\nconsole.log('Config3 Keys (update existing):', manager3.getOrderedKeys()); // ['setting1', 'setting2', 'setting3']\nconsole.log('Config3 Object:', manager3.toPlainObject()); // setting1 should be 'updatedValue'\n\nconst manager4 = manager3.removeConfig('setting2');\nconsole.log('Config4 Keys (remove):', manager4.getOrderedKeys()); // ['setting1', 'setting3']\nconsole.log('Config4 Object:', manager4.toPlainObject()); // setting2 should be gone\n\nconsole.log('Original manager keys:', manager.getOrderedKeys()); // Should be unchanged: ['setting1', 'setting2']\n",
          "solutionCode": "import { OrderedMap, fromJS } from 'immutable';\n\nclass ConfigManager {\n  private readonly config: OrderedMap<string, any>;\n\n  constructor(initialConfig?: { [key: string]: any }) {\n    // Use fromJS to convert initial plain JS object, if provided. \n    // OrderedMap constructor can also take a JS object directly.\n    this.config = initialConfig ? OrderedMap(initialConfig) : OrderedMap();\n  }\n\n  addConfig(key: string, value: any): ConfigManager {\n    // OrderedMap.set automatically preserves order if key exists, otherwise adds to end\n    const newConfig = this.config.set(key, value);\n    return new ConfigManager(newConfig.toJS()); // Re-wrap new Immutable.OrderedMap\n  }\n\n  removeConfig(key: string): ConfigManager {\n    const newConfig = this.config.delete(key);\n    return new ConfigManager(newConfig.toJS()); // Re-wrap new Immutable.OrderedMap\n  }\n\n  getOrderedKeys(): string[] {\n    // OrderedMap.keys() returns an Iterator; convert to array\n    return this.config.keySeq().toArray();\n  }\n\n  getConfig(key: string): any | undefined {\n    return this.config.get(key);\n  }\n\n  toPlainObject(): { [key: string]: any } {\n    // OrderedMap.toJS() preserves order when converting to plain JS object\n    return this.config.toJS();\n  }\n}\n\n// Example Usage:\nconst manager = new ConfigManager({ setting1: 'value1', setting2: 123 });\nconsole.log('Initial Config Keys:', manager.getOrderedKeys()); // ['setting1', 'setting2']\nconsole.log('Initial Config Object:', manager.toPlainObject()); // { setting1: 'value1', setting2: 123 }\n\nconst manager2 = manager.addConfig('setting3', true);\nconsole.log('Config2 Keys (add new):', manager2.getOrderedKeys()); // ['setting1', 'setting2', 'setting3']\nconsole.log('Config2 Object:', manager2.toPlainObject()); // { setting1: 'value1', setting2: 123, setting3: true }\n\nconst manager3 = manager2.addConfig('setting1', 'updatedValue'); // Update existing key\nconsole.log('Config3 Keys (update existing):', manager3.getOrderedKeys()); // ['setting1', 'setting2', 'setting3']\nconsole.log('Config3 Object:', manager3.toPlainObject()); // { setting1: 'updatedValue', setting2: 123, setting3: true }\n\nconst manager4 = manager3.removeConfig('setting2');\nconsole.log('Config4 Keys (remove):', manager4.getOrderedKeys()); // ['setting1', 'setting3']\nconsole.log('Config4 Object:', manager4.toPlainObject()); // { setting1: 'updatedValue', setting3: true }\n\nconsole.log('Original manager keys (unchanged):', manager.getOrderedKeys()); // ['setting1', 'setting2']\nconsole.log('Original manager object (unchanged):', manager.toPlainObject()); // { setting1: 'value1', setting2: 123 }\n\n// Test with an empty initial config\nconst emptyManager = new ConfigManager();\nconsole.log('Empty Manager Keys:', emptyManager.getOrderedKeys()); // []\nconst managerWithOne = emptyManager.addConfig('first', 1);\nconsole.log('Manager with one Key:', managerWithOne.getOrderedKeys()); // ['first']\n\n// Test with complex values\nconst complexManager = new ConfigManager();\nconst complex1 = complexManager.addConfig('nestedMap', fromJS({ a: 1, b: { c: 2 } }));\nconst complex2 = complex1.addConfig('nestedList', fromJS([1, 2, 3]));\nconsole.log('Complex Manager Keys:', complex2.getOrderedKeys());\nconsole.log('Complex Manager Object:', complex2.toPlainObject());\n",
          "testCases": [
            "Initial config: `ConfigManager({})` should result in an empty `OrderedMap`. `getOrderedKeys()` should return `[]`.",
            "Initial config with data: `ConfigManager({a: 1, b: 2})` should correctly initialize, and `getOrderedKeys()` should return `['a', 'b']`.",
            "Add new config: `addConfig('c', 3)` should add 'c' to the end of the order.",
            "Update existing config: `addConfig('a', 10)` should update the value of 'a' but its position in `getOrderedKeys()` should remain the same as its initial insertion.",
            "Remove config: `removeConfig('b')` should remove 'b' and return a new `ConfigManager` without it.",
            "Attempt to remove non-existent config: Should return a new `ConfigManager` that is identical to the original (or the same instance for optimization).",
            "Get config value: `getConfig('a')` should return the correct value.",
            "Convert to plain object: `toPlainObject()` should return a plain JavaScript object where keys are in their original insertion order.",
            "Immutability: Verify that the original `ConfigManager` instance remains unchanged after any modification operations."
          ],
          "hints": [
            "The `OrderedMap` constructor can directly take a plain JavaScript object, and it will preserve the order of keys from that object.",
            "The `set()` method of `OrderedMap` automatically handles both adding new keys (at the end) and updating existing keys (preserving their position).",
            "To get ordered keys as a plain array, you can use `this.config.keySeq().toArray()`.",
            "The `OrderedMap.toJS()` method is designed to convert to a plain JavaScript object *while preserving insertion order*, which simplifies the `toPlainObject()` method.",
            "Remember to always return a *new* `ConfigManager` instance wrapping the *new* `OrderedMap` that results from any modification."
          ],
          "tags": [
            "Immutable.js",
            "OrderedMap",
            "Configuration Management",
            "Order Preservation",
            "Immutability"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_immutable_orderedmap",
            "theory_immutable_map"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Dynamic_forms",
            "UI_rendering_order",
            "Data_serialization"
          ]
        },
        {
          "id": "task_immutable_set_1",
          "title": "Manage Unique User Tags with Immutable.Set",
          "description": "\nDevelop a `UserTagManager` class that uses `Immutable.Set` to efficiently manage a user's unique tags. The manager should support adding tags, removing tags, checking for tag existence, and performing set operations like finding common tags with another user.\n\n**Requirements:**\n1.  **Constructor:** Initialize the `UserTagManager` with an initial array of tags (e.g., `['frontend', 'javascript']`). Ensure duplicates are handled correctly by `Immutable.Set`.\n2.  **`addTag(tag)`:** Add a new tag to the user's collection. If the tag already exists, the set should remain unchanged (and return the same instance). Return a new `UserTagManager` instance.\n3.  **`removeTag(tag)`:** Remove a tag from the collection. Return a new `UserTagManager` instance.\n4.  **`hasTag(tag)`:** Check if a tag exists in the collection. Return `boolean`.\n5.  **`getTags()`:** Return all tags as a plain JavaScript array.\n6.  **`getCommonTags(otherTagManager)`:** A static method that takes two `UserTagManager` instances and returns a plain JavaScript array of tags that are present in both users' collections (intersection).\n",
          "difficulty": "medium",
          "startingCode": "import { Set } from 'immutable';\n\nclass UserTagManager {\n  private readonly tags: Set<string>;\n\n  constructor(initialTags: string[] = []) {\n    // TODO: Initialize tags Set, handle duplicates\n    this.tags = Set();\n  }\n\n  addTag(tag: string): UserTagManager {\n    // TODO: Add tag, return new instance\n    return this;\n  }\n\n  removeTag(tag: string): UserTagManager {\n    // TODO: Remove tag, return new instance\n    return this;\n  }\n\n  hasTag(tag: string): boolean {\n    // TODO: Check if tag exists\n    return false;\n  }\n\n  getTags(): string[] {\n    // TODO: Return tags as plain array\n    return [];\n  }\n\n  static getCommonTags(manager1: UserTagManager, manager2: UserTagManager): string[] {\n    // TODO: Implement common tags logic (intersection)\n    return [];\n  }\n}\n\n// Example Usage:\nconst user1Tags = new UserTagManager(['react', 'redux', 'javascript']);\nconsole.log('User1 Tags:', user1Tags.getTags()); // ['react', 'redux', 'javascript'] (order not guaranteed)\n\nconst user2Tags = user1Tags.addTag('typescript');\nconsole.log('User2 Tags (add):', user2Tags.getTags()); // Should include 'typescript'\n\nconst user3Tags = user2Tags.addTag('react'); // Adding duplicate\nconsole.log('User3 Tags (add duplicate - should be same as User2):', user3Tags.getTags());\n\nconst user4Tags = user3Tags.removeTag('redux');\nconsole.log('User4 Tags (remove):', user4Tags.getTags()); // Should not include 'redux'\n\nconsole.log('User1 has react?', user1Tags.hasTag('react')); // true\nconsole.log('User4 has redux?', user4Tags.hasTag('redux')); // false\n\nconst anotherUserTags = new UserTagManager(['angular', 'typescript', 'css']);\nconsole.log('Common tags between User4 and anotherUserTags:', UserTagManager.getCommonTags(user4Tags, anotherUserTags)); // Should be ['typescript']\n",
          "solutionCode": "import { Set } from 'immutable';\n\nclass UserTagManager {\n  private readonly tags: Set<string>;\n\n  constructor(initialTags: string[] = []) {\n    this.tags = Set(initialTags);\n  }\n\n  addTag(tag: string): UserTagManager {\n    const newTags = this.tags.add(tag);\n    // Immutable.js returns the same instance if no change, so we can always create a new manager\n    return new UserTagManager(newTags.toJS());\n  }\n\n  removeTag(tag: string): UserTagManager {\n    const newTags = this.tags.delete(tag);\n    return new UserTagManager(newTags.toJS());\n  }\n\n  hasTag(tag: string): boolean {\n    return this.tags.has(tag);\n  }\n\n  getTags(): string[] {\n    return this.tags.toJS(); // .toArray() also works\n  }\n\n  static getCommonTags(manager1: UserTagManager, manager2: UserTagManager): string[] {\n    const commonSet = manager1.tags.intersect(manager2.tags);\n    return commonSet.toJS();\n  }\n}\n\n// Example Usage:\nconst user1Tags = new UserTagManager(['react', 'redux', 'javascript', 'typescript']);\nconsole.log('User1 Tags:', user1Tags.getTags());\n\nconst user2Tags = user1Tags.addTag('graphql');\nconsole.log('User2 Tags (add graphql):', user2Tags.getTags());\n\nconst user3Tags = user2Tags.addTag('react'); // Adding duplicate 'react'\nconsole.log('User3 Tags (add duplicate - should be same as User2):', user3Tags.getTags());\n\nconst user4Tags = user3Tags.removeTag('redux');\nconsole.log('User4 Tags (remove redux):', user4Tags.getTags());\n\nconsole.log('User1 has react?', user1Tags.hasTag('react')); // true\nconsole.log('User4 has redux?', user4Tags.hasTag('redux')); // false\nconsole.log('User4 has graphql?', user4Tags.hasTag('graphql')); // true\n\nconst anotherUserTags = new UserTagManager(['angular', 'typescript', 'css', 'graphql']);\nconsole.log('Another User Tags:', anotherUserTags.getTags());\nconsole.log('Common tags between User4 and anotherUserTags:', UserTagManager.getCommonTags(user4Tags, anotherUserTags)); // ['graphql', 'typescript'] (order not guaranteed)\n\n// Edge cases:\nconst emptyTags = new UserTagManager();\nconsole.log('Empty Tags:', emptyTags.getTags()); // []\nconst addedToEmpty = emptyTags.addTag('first');\nconsole.log('Added to empty:', addedToEmpty.getTags()); // ['first']\nconst removedFromEmpty = emptyTags.removeTag('non-existent');\nconsole.log('Removed from empty (should be same):', removedFromEmpty.getTags()); // []\n\nconst finalRemoved = addedToEmpty.removeTag('first');\nconsole.log('Removed last tag:', finalRemoved.getTags()); // []\n\nconst originalUser1Tags = new UserTagManager(['react', 'redux', 'javascript', 'typescript']);\nconsole.log('Original user1Tags still intact:', originalUser1Tags.getTags()); // Verify immutability\n",
          "testCases": [
            "Constructor: Initialize with an empty array `[]` (should result in empty set). Initialize with `['a', 'b', 'a']` (should result in `Set(['a', 'b'])`).",
            "Add new tag: `addTag('c')` to `['a', 'b']` should result in `Set(['a', 'b', 'c'])` (new instance).",
            "Add existing tag: `addTag('a')` to `['a', 'b']` should result in the *same instance* of `Set(['a', 'b'])` (due to `Immutable.Set` optimization, though `UserTagManager` wraps a new instance for consistency).",
            "Remove existing tag: `removeTag('b')` from `['a', 'b', 'c']` should result in `Set(['a', 'c'])` (new instance).",
            "Remove non-existent tag: `removeTag('d')` from `['a', 'b']` should return the same instance as original.",
            "Check existence: `hasTag('a')` should be `true`, `hasTag('d')` should be `false`.",
            "Get tags: `getTags()` should convert the `Set` to a plain JS array.",
            "Common tags: `getCommonTags` for two managers with overlapping tags (e.g., `['a', 'b']` and `['b', 'c']` -> `['b']`).",
            "Common tags (no overlap): `getCommonTags` for two managers with no common tags (should return `[]`).",
            "Immutability: Verify that the original `UserTagManager` instance (and its internal `Set`) remains unchanged after `addTag` or `removeTag` operations."
          ],
          "hints": [
            "The `Immutable.Set` constructor automatically handles unique values when initialized from an array.",
            "The `Set.add()` method returns a new `Set` if the value is new, or the *same instance* if the value already exists (this is a key optimization for Immutable.js).",
            "`Set.delete()` removes a value and returns a new `Set`.",
            "`Set.has()` is for checking existence.",
            "For `getCommonTags`, `Immutable.Set.prototype.intersect()` is the perfect method.",
            "Always remember to return a `new UserTagManager()` instance after any modification, wrapping the new `Immutable.Set` returned by Immutable.js methods.",
            "Use `toJS()` or `toArray()` to convert the `Immutable.Set` back to a plain JavaScript array for public methods."
          ],
          "tags": [
            "Immutable.js",
            "Set",
            "Data Management",
            "Unique Values",
            "Immutability",
            "Set Operations"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_immutable_set"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Tagging_systems",
            "Filtering",
            "Set_theory"
          ]
        },
        {
          "id": "task_immutable_orderedset_1",
          "title": "Build a Recent History Manager with OrderedSet",
          "description": "\nCreate a `RecentHistoryManager` class that keeps track of recently viewed items (e.g., product IDs, article titles) as unique entries, while preserving the order in which they were viewed. The manager should have a maximum capacity.\n\n**Requirements:**\n1.  **Constructor:** Initialize with an optional `initialItems` array and a `capacity` (e.g., 5). The initial items should respect uniqueness and order.\n2.  **`viewItem(item)`:** Add an item to the history. If the item already exists, it should be moved to the *most recent* position (the end of the order). If the history reaches `capacity`, the *oldest* item (at the beginning) should be removed.\n3.  **`getHistory()`:** Return the unique items in viewing order as a plain JavaScript array.\n4.  **`hasItem(item)`:** Check if an item is currently in the history.\n5.  **`clearHistory()`:** Reset the history to an empty state.\n\nUse `Immutable.OrderedSet` for the underlying data structure.\n",
          "difficulty": "hard",
          "startingCode": "import { OrderedSet } from 'immutable';\n\nclass RecentHistoryManager<T> {\n  private history: OrderedSet<T>;\n  private readonly capacity: number;\n\n  constructor(capacity: number, initialItems: T[] = []) {\n    this.capacity = capacity;\n    // TODO: Initialize history as OrderedSet, respect capacity and order\n    this.history = OrderedSet();\n  }\n\n  viewItem(item: T): RecentHistoryManager<T> {\n    // TODO: Add/move item to end, handle capacity\n    return this;\n  }\n\n  getHistory(): T[] {\n    // TODO: Return history as plain array\n    return [];\n  }\n\n  hasItem(item: T): boolean {\n    // TODO: Check if item exists\n    return false;\n  }\n\n  clearHistory(): RecentHistoryManager<T> {\n    // TODO: Reset history\n    return this;\n  }\n}\n\n// Example Usage:\nconst manager = new RecentHistoryManager<string>(3);\nconsole.log('Initial History:', manager.getHistory()); // []\n\nconst m1 = manager.viewItem('Product A');\nconsole.log('After A:', m1.getHistory()); // ['Product A']\n\nconst m2 = m1.viewItem('Product B');\nconsole.log('After B:', m2.getHistory()); // ['Product A', 'Product B']\n\nconst m3 = m2.viewItem('Product C');\nconsole.log('After C:', m3.getHistory()); // ['Product A', 'Product B', 'Product C']\n\nconst m4 = m3.viewItem('Product D'); // Capacity reached, A should be removed\nconsole.log('After D (A removed):', m4.getHistory()); // ['Product B', 'Product C', 'Product D']\n\nconst m5 = m4.viewItem('Product B'); // B viewed again, should move to end\nconsole.log('After B again:', m5.getHistory()); // ['Product C', 'Product D', 'Product B']\n\nconsole.log('Has Product C?', m5.hasItem('Product C')); // true\nconsole.log('Has Product A?', m5.hasItem('Product A')); // false\n\nconst m6 = m5.clearHistory();\nconsole.log('After Clear:', m6.getHistory()); // []\n\nconsole.log('Original manager history (unchanged):', manager.getHistory()); // []\n",
          "solutionCode": "import { OrderedSet } from 'immutable';\n\nclass RecentHistoryManager<T> {\n  private history: OrderedSet<T>;\n  private readonly capacity: number;\n\n  constructor(capacity: number, initialItems: T[] = []) {\n    this.capacity = capacity;\n    // Initialize history, taking first 'capacity' unique items from initialItems\n    this.history = OrderedSet(initialItems.slice(0, capacity));\n  }\n\n  viewItem(item: T): RecentHistoryManager<T> {\n    let newHistory = this.history;\n\n    // If item exists, remove it first to re-add to end\n    if (newHistory.has(item)) {\n      newHistory = newHistory.delete(item);\n    }\n\n    // Add the item to the end (most recent)\n    newHistory = newHistory.add(item);\n\n    // If capacity is exceeded, remove the oldest item (first in the OrderedSet)\n    if (newHistory.size > this.capacity) {\n      newHistory = newHistory.shift(); // shift removes the first element\n    }\n\n    return new RecentHistoryManager(this.capacity, newHistory.toJS());\n  }\n\n  getHistory(): T[] {\n    return this.history.toJS();\n  }\n\n  hasItem(item: T): boolean {\n    return this.history.has(item);\n  }\n\n  clearHistory(): RecentHistoryManager<T> {\n    return new RecentHistoryManager(this.capacity); // Re-initialize with empty history\n  }\n}\n\n// Example Usage:\nconst manager = new RecentHistoryManager<string>(3);\nconsole.log('Initial History:', manager.getHistory()); // []\n\nconst m1 = manager.viewItem('Product A');\nconsole.log('After A:', m1.getHistory()); // ['Product A']\n\nconst m2 = m1.viewItem('Product B');\nconsole.log('After B:', m2.getHistory()); // ['Product A', 'Product B']\n\nconst m3 = m2.viewItem('Product C');\nconsole.log('After C:', m3.getHistory()); // ['Product A', 'Product B', 'Product C']\n\nconst m4 = m3.viewItem('Product D'); // Capacity reached, A should be removed\nconsole.log('After D (A removed):', m4.getHistory()); // ['Product B', 'Product C', 'Product D']\n\nconst m5 = m4.viewItem('Product B'); // B viewed again, should move to end\nconsole.log('After B again:', m5.getHistory()); // ['Product C', 'Product D', 'Product B']\n\nconsole.log('Has Product C?', m5.hasItem('Product C')); // true\nconsole.log('Has Product A?', m5.hasItem('Product A')); // false\n\nconst m6 = m5.clearHistory();\nconsole.log('After Clear:', m6.getHistory()); // []\n\nconsole.log('Original manager history (unchanged):', manager.getHistory()); // []\n\n// More edge cases\nconst managerWithInitial = new RecentHistoryManager<number>(2, [10, 20, 10, 30]); // Unique and slice to capacity\nconsole.log('Manager with initial values:', managerWithInitial.getHistory()); // [10, 20] (order of initial elements retained, then truncated)\n\nconst m7 = managerWithInitial.viewItem(40);\nconsole.log('After 40:', m7.getHistory()); // [20, 40] (10 removed)\n\nconst m8 = m7.viewItem(20); // 20 viewed again\nconsole.log('After 20 again:', m8.getHistory()); // [40, 20]\n\nconst managerEmptyCapacity = new RecentHistoryManager<string>(0);\nconsole.log('Empty capacity manager:', managerEmptyCapacity.getHistory()); // []\nconst m9 = managerEmptyCapacity.viewItem('X');\nconsole.log('Add to empty capacity:', m9.getHistory()); // [] (item added then immediately removed)\n",
          "testCases": [
            "Initial state: `RecentHistoryManager(3)` should start empty. `RecentHistoryManager(2, ['a', 'b', 'a', 'c'])` should initialize with `OrderedSet(['a', 'b'])`.",
            "Add new item: `viewItem('X')` should add 'X' to the end.",
            "Add existing item: `viewItem('A')` when 'A' is already present should move 'A' to the most recent position (end).",
            "Capacity management: Add items until capacity is reached. Add one more, verify the oldest item is removed.",
            "Capacity management with existing item: Add items until capacity is reached. View an item that is currently in the middle of the history; verify it moves to the end and the oldest *other* item is removed if capacity is now exceeded (e.g., for capacity 3, history `[A, B, C]`, view `B` -> `[A, C, B]`).",
            "Check existence: `hasItem('X')` should work correctly.",
            "Clear history: `clearHistory()` should return an empty history.",
            "Immutability: All operations should return new `RecentHistoryManager` instances, leaving the originals unchanged.",
            "Edge case: `capacity = 0`. `viewItem` should always result in an empty history.",
            "Edge case: `viewItem` with multiple identical items in `initialItems` (should result in unique set, preserving first encountered order up to capacity)."
          ],
          "hints": [
            "To move an existing item to the end, first `delete()` it, then `add()` it. `OrderedSet` naturally adds to the end.",
            "To enforce capacity, after adding/reordering, check `history.size`. If it exceeds `capacity`, use `history.shift()` to remove the oldest item (which is at the beginning of an `OrderedSet`).",
            "Remember to wrap the new `Immutable.OrderedSet` result in a new `RecentHistoryManager` instance for every modifying operation to maintain immutability.",
            "The constructor for `OrderedSet` can take an iterable (like an array). It will automatically handle uniqueness and initial order."
          ],
          "tags": [
            "Immutable.js",
            "OrderedSet",
            "Data Structures",
            "History Management",
            "LRU",
            "Immutability"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_immutable_orderedset",
            "theory_immutable_list"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Caching",
            "Least_recently_used",
            "UX_patterns"
          ]
        }
      ]
    }
  }
]