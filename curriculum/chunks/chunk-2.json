[
  {
    "id": "ab704af7-a36c-4098-9c2d-a7e4d43abdbc",
    "startLine": 500,
    "endLine": 599,
    "processedDate": "2025-06-17T03:02:31.787Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_type_coercion",
          "title": "JavaScript Type Coercion and Operator Behavior",
          "content": "Type coercion in JavaScript is the automatic or implicit conversion of values from one data type to another. This is a common source of unexpected behavior, especially when using loose equality (`==`) or arithmetic operators.\n\n## Implicit Type Coercion Rules\nJavaScript attempts to convert operands to a compatible type before performing an operation. This conversion is often guided by internal operations like `ToPrimitive`, `ToNumber`, `ToString`, and `ToBoolean`.\n\n### The `+` Operator\n- If one of the operands is a string, the `+` operator performs string concatenation. Both operands are converted to strings (via `ToString`).\n- Otherwise, both operands are converted to numbers (via `ToNumber`) and addition is performed.\n\n### Arithmetic Operators (`-`, `*`, `/`, `%`)\n- These operators always attempt to convert both operands to numbers (via `ToNumber`).\n- If a value cannot be meaningfully converted to a number, the result is `NaN` (Not-a-Number).\n\n### Loose Equality (`==`) vs Strict Equality (`===`)\n- The `==` (loose equality) operator performs type coercion before comparison. If the operands are of different types, JavaScript tries to convert one or both to a common type.\n- The `===` (strict equality) operator compares both the value and the type without any type coercion. This is generally preferred to avoid unexpected behavior.\n\n### Division by Zero\n- In JavaScript, dividing a number by zero does not throw an error but results in `Infinity` for positive numbers and `-Infinity` for negative numbers. Dividing `0` by `0` results in `NaN`.\n\n### Operations with `undefined` and `null`\n- `null` typically converts to `0` in numeric contexts (e.g., `null + 1` is `1`), but `undefined` typically converts to `NaN` (e.g., `undefined + 1` is `NaN`).\n- When comparing with `==`:\n    - `null == undefined` is `true`.\n    - `null` is only `==` to `null` or `undefined`.\n    - `undefined` is only `==` to `undefined` or `null`.\n\n### Logical Operators (`&&`, `||`)\n- Logical operators `&&` (AND) and `||` (OR) are \"short-circuiting\" and return the value of one of their operands, not necessarily a boolean `true` or `false`.\n    - `A && B`: Returns `A` if `A` is falsy, otherwise returns `B`.\n    - `A || B`: Returns `A` if `A` is truthy, otherwise returns `B`.\n\n### Object Property Access\n- When accessing object properties, numeric string keys and number keys are treated as equivalent (e.g., `obj['1']` is the same as `obj[1]`).\n",
          "examples": [
            {
              "id": "example_coercion_1",
              "title": "Complex Coercion Scenario",
              "code": "const result1 = [] + false - null + true;\n// Breakdown:\n// 1. [] + false  \n//    [] (ToPrimitive) -> \"\"\n//    false (ToString) -> \"false\"\n//    \"\" + \"false\" -> \"false\" (string concatenation)\n// 2. \"false\" - null\n//    \"false\" (ToNumber) -> NaN\n//    null (ToNumber) -> 0\n//    NaN - 0 -> NaN\n// 3. NaN + true\n//    NaN + true (ToNumber) -> NaN\n//    NaN + 1 -> NaN\nconsole.log(result1); // NaN",
              "explanation": "This example demonstrates a complex series of type coercions involving array to string, boolean to string/number, and null to number conversions. The presence of `NaN` in an arithmetic operation propagates `NaN` through subsequent operations.",
              "language": "javascript"
            },
            {
              "id": "example_coercion_2",
              "title": "Division by Zero and Undefined Operations",
              "code": "let result2 = 5 / 0; // Infinity\nlet negativeResult2 = -5 / 0; // -Infinity\nlet zeroByZero = 0 / 0; // NaN\nlet undefinedAddition = 5 + undefined; // NaN\nlet nullAddition = 5 + null; // 5\n\nconsole.log(result2, negativeResult2, zeroByZero, undefinedAddition, nullAddition);",
              "explanation": "This illustrates JavaScript's handling of division by zero, which yields `Infinity` or `-Infinity`, and `0/0` which yields `NaN`. It also shows the different numeric coercions of `undefined` (to `NaN`) and `null` (to `0`).",
              "language": "javascript"
            },
            {
              "id": "example_coercion_3",
              "title": "Loose vs. Strict Equality",
              "code": "console.log(0 == false);    // true (0 is loosely equal to false)\nconsole.log(0 === false);   // false (different types)\nconsole.log('1' == 1);      // true (string '1' converted to number 1)\nconsole.log('1' === 1);     // false (different types)\nconsole.log(null == undefined); // true\nconsole.log(null === undefined); // false\nconsole.log([] == 0);       // true ([] -> \"\" -> 0)\nconsole.log([] == \"\");     // true ([] -> \"\")",
              "explanation": "This example highlights the key differences between loose (`==`) and strict (`===`) equality. Loose equality often leads to unexpected results due to implicit type conversions, whereas strict equality avoids this by requiring both value and type to be identical.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_coercion_1",
            "question_coercion_2",
            "question_coercion_3",
            "question_coercion_4",
            "question_coercion_5",
            "question_coercion_6",
            "question_coercion_7",
            "question_coercion_8"
          ],
          "relatedTasks": [
            "task_coercion_quiz",
            "task_analyze_coercion_expression"
          ],
          "tags": [
            "type-coercion",
            "javascript-fundamentals",
            "operators",
            "equality",
            "NaN",
            "infinity"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_datatypes",
            "javascript_operators"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "debugging",
            "writing_robust_code"
          ]
        },
        {
          "id": "theory_hoisting",
          "title": "Variable and Function Hoisting",
          "content": "Hoisting is a JavaScript mechanism where variable and function declarations are moved to the top of their containing scope during the compilation phase, before code execution. This means you can use variables and call functions before they are declared in the code.\n\n## Hoisting Behavior by Declaration Type\n\n### `var` Declarations\n- `var` declarations are hoisted to the top of their function or global scope.\n- They are initialized with `undefined` during the hoisting phase. This means you can access a `var` variable before its declaration, but its value will be `undefined` until the line of its actual assignment is reached.\n\n### Function Declarations\n- Function declarations are fully hoisted. This means both the function name and its definition (the function body) are moved to the top of the scope.\n- You can call a function declared with `function` keyword before its definition in the code.\n\n### `let` and `const` Declarations\n- `let` and `const` declarations are also hoisted, but they are *not initialized* during the hoisting phase.\n- They are placed in a **Temporal Dead Zone (TDZ)** from the start of their block scope until their actual declaration line is executed.\n- Attempting to access a `let` or `const` variable within the TDZ results in a `ReferenceError`.\n- This behavior is designed to make `let` and `const` variables safer by preventing their use before declaration and initialization.\n\n## Hoisting Priority and Overwriting\n- In the same scope, function declarations have a higher hoisting priority than variable declarations (`var`).\n- If a function declaration and a `var` variable share the same name, the function declaration takes precedence and is hoisted first. However, a subsequent `var` assignment or any direct assignment will overwrite the function reference.\n\n",
          "examples": [
            {
              "id": "example_hoisting_1",
              "title": "Var Variable Hoisting",
              "code": "console.log(x); // Outputs: undefined\nvar x = 5;\nconsole.log(x); // Outputs: 5\n\n// Explanation: 'x' is declared and initialized to undefined at the top of the scope.\n// When 'var x = 5;' is encountered, 'x' is assigned the value 5.",
              "explanation": "This example shows that `var` variables are hoisted and initialized to `undefined`. Accessing `x` before its declaration results in `undefined`, not an error, because the declaration itself is moved to the top.",
              "language": "javascript"
            },
            {
              "id": "example_hoisting_2",
              "title": "Function Declaration Hoisting",
              "code": "console.log(foo()); // Outputs: \"bar\"\n\nfunction foo() {\n  return \"bar\";\n}\n\n// Explanation: The entire function declaration 'foo' is moved to the top.\n// So, 'foo()' can be called before its physical declaration.",
              "explanation": "Function declarations are fully hoisted, meaning their entire definition is available at the top of the scope. This allows them to be called before their actual position in the code.",
              "language": "javascript"
            },
            {
              "id": "example_hoisting_3",
              "title": "Let/Const and Temporal Dead Zone",
              "code": "// console.log(z); // Throws ReferenceError: Cannot access 'z' before initialization\nlet z = 5;\nconsole.log(z);\n\n// console.log(y); // Throws ReferenceError: Cannot access 'y' before initialization\nconst y = 10;\nconsole.log(y);",
              "explanation": "This demonstrates the Temporal Dead Zone (TDZ) for `let` and `const`. While hoisted, these variables are not initialized until their declaration line is executed. Any access before this point results in a `ReferenceError`.",
              "language": "javascript"
            },
            {
              "id": "example_hoisting_4",
              "title": "Hoisting Priority: Function vs. Var",
              "code": "(function() {\n  var x = 1;\n  function x() {};\n  console.log(x); // Outputs: 1\n})();\n\n(function() {\n  function y() {};\n  var y = 1;\n  console.log(y); // Outputs: 1\n})();\n\n// Explanation:\n// In both cases, the function declaration 'x' or 'y' is hoisted first.\n// Then, 'var x = 1;' or 'var y = 1;' assigns the value 1 to 'x'/'y', overwriting the function reference.",
              "explanation": "This complex example illustrates that function declarations are hoisted with higher priority than `var` variables. However, if a `var` declaration with an initializer or any assignment to the variable name occurs later, it will overwrite the function reference.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_hoisting_1",
            "question_hoisting_2",
            "question_hoisting_3",
            "question_hoisting_4",
            "question_hoisting_5",
            "question_hoisting_6",
            "question_hoisting_7"
          ],
          "relatedTasks": [
            "task_predict_hoisting_output",
            "task_refactor_for_tdz"
          ],
          "tags": [
            "hoisting",
            "javascript-scope",
            "var",
            "let",
            "const",
            "temporal-dead-zone",
            "function-declaration"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_variables",
            "javascript_functions",
            "javascript_scope"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "understanding_execution_context",
            "debugging_javascript"
          ]
        },
        {
          "id": "theory_function_mechanics",
          "title": "Function Declarations, Expressions, and IIFEs",
          "content": "JavaScript provides several ways to define functions, each with distinct characteristics regarding hoisting, syntax, and `this` binding.\n\n## Function Declaration\n- Defined using the `function` keyword, followed by a name, parameters, and a function body.\n- Example: `function add(a, b) { return a + b; }`\n- **Hoisting**: Function declarations are fully hoisted. This means you can call them before they are physically defined in the code.\n\n## Function Expression\n- Defined as part of an expression, often assigned to a variable.\n- Can be named (named function expression) or anonymous.\n- Example: `const add = function(a, b) { return a + b; };`\n- **Hoisting**: Function expressions are *not* hoisted in the same way as declarations. Only the variable holding the function (e.g., `add` in `const add = ...`) is hoisted according to `var`, `let`, or `const` rules. The function definition itself is only available after the line where it is assigned is executed. Trying to call the function before this assignment will result in an error (`TypeError: ... is not a function` for `var` or `ReferenceError` for `let`/`const`).\n\n### Arrow Functions (Arrow Function Expression)\n- A concise syntax for writing function expressions, introduced in ES6.\n- Example: `const add = (a, b) => a + b;`\n- **No `this` binding**: Arrow functions do not have their own `this` context; they inherit `this` from the enclosing lexical scope.\n- **No `arguments` object**: They do not have their own `arguments` object.\n- **Cannot be used as constructors**: They cannot be called with `new`.\n- **Hoisting**: Like other function expressions, arrow functions are not fully hoisted. The variable they are assigned to is hoisted according to its declaration type (`var`, `let`, `const`).\n\n## IIFE (Immediately Invoked Function Expression)\n- An IIFE is a JavaScript function that runs as soon as it is defined. It's a design pattern that creates a private scope for variables and functions, preventing them from polluting the global namespace.\n- Syntax: `(function() { /* code */ })();` or `(() => { /* code */ })();`\n- **Purpose**: \n    - **Scoping**: Creates a private scope, preventing variable collisions with the global scope.\n    - **Data Privacy**: Encapsulates variables and functions, making them private to the IIFE.\n    - **Initialization**: Can be used to initialize complex modules or libraries.\n    - **Avoiding Global Pollution**: Especially useful in older JavaScript environments or when integrating multiple scripts.\n\n",
          "examples": [
            {
              "id": "example_function_1",
              "title": "Function Declaration vs. Expression Hoisting",
              "code": "// Function Declaration (hoisted)\nconsole.log(declareAdd(1, 2)); // Outputs: 3\nfunction declareAdd(a, b) {\n  return a + b;\n}\n\n// Function Expression (not fully hoisted)\n// console.log(expressAdd(3, 4)); // Throws ReferenceError for let/const or TypeError for var\nconst expressAdd = function(a, b) {\n  return a + b;\n};\nconsole.log(expressAdd(3, 4)); // Outputs: 7\n\n// Arrow Function Expression (not fully hoisted)\n// console.log(arrowAdd(5, 6)); // Throws ReferenceError\nconst arrowAdd = (a, b) => a + b;\nconsole.log(arrowAdd(5, 6)); // Outputs: 11",
              "explanation": "This example clearly shows the hoisting behavior differences. Function declarations can be called before their definition. Function expressions (including arrow functions) are assigned to a variable, and only the variable declaration is hoisted, not the function definition, leading to errors if called prematurely.",
              "language": "javascript"
            },
            {
              "id": "example_function_2",
              "title": "Basic IIFE Structure and Purpose",
              "code": "(function() {\n  var privateVar = \"I am private!\";\n  console.log(privateVar);\n})();\n\n// console.log(privateVar); // Throws ReferenceError: privateVar is not defined\n\n// Arrow IIFE\n(() => {\n  const message = \"Hello from Arrow IIFE!\";\n  console.log(message);\n})();",
              "explanation": "This demonstrates a basic IIFE, showcasing its primary use case: creating a private scope for variables (`privateVar` is not accessible outside the IIFE). This helps in avoiding global scope pollution and achieving modularity.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_function_mechanics_1",
            "question_function_mechanics_2",
            "question_function_mechanics_3",
            "question_function_mechanics_4",
            "question_function_mechanics_5",
            "question_function_mechanics_6"
          ],
          "relatedTasks": [
            "task_refactor_to_iife",
            "task_implement_utility_function"
          ],
          "tags": [
            "functions",
            "function-declaration",
            "function-expression",
            "arrow-functions",
            "IIFE",
            "scoping",
            "hoisting"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_variables",
            "javascript_scope",
            "javascript_es6"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "module_patterns",
            "javascript_patterns"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_coercion_1",
          "topic": "JavaScript Type Coercion",
          "level": "easy",
          "type": "mcq",
          "question": "What will be the result of `\"5\" - 3` in JavaScript?",
          "answer": "The result will be `2`. The `-` operator always attempts to convert its operands to numbers. The string `\"5\"` is successfully converted to the number `5`, and then `5 - 3` is performed.",
          "options": [
            "2",
            "\"53\"",
            "NaN",
            "TypeError"
          ],
          "analysisPoints": [
            "Understanding that the `-` operator implies numeric conversion.",
            "Distinguishing `+` (concatenation/addition) from other arithmetic operators."
          ],
          "keyConcepts": [
            "Type Coercion",
            "Arithmetic Operators",
            "ToNumber internal operation"
          ],
          "evaluationCriteria": [
            "Correct application of arithmetic coercion rules."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "operators",
            "javascript-fundamentals"
          ],
          "prerequisites": [
            "javascript_operators"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_coercion_2",
          "topic": "JavaScript Type Coercion",
          "level": "medium",
          "type": "mcq",
          "question": "What is the output of `[] + {}` in JavaScript?",
          "answer": "The result will be `\"[object Object]\"`. The `+` operator attempts to convert both operands to primitive values. `[]` becomes `\"\"` (empty string). `{}` becomes `\"[object Object]\"`. Then, string concatenation occurs: `\"\" + \"[object Object]\"` results in `\"[object Object]\"`.",
          "options": [
            "\"[object Object]\"",
            "NaN",
            "[object Object]",
            "\"\""
          ],
          "analysisPoints": [
            "Understanding the `ToPrimitive` conversion for arrays and objects.",
            "Knowing how the `+` operator behaves with strings."
          ],
          "keyConcepts": [
            "Type Coercion",
            "ToPrimitive",
            "ToString",
            "Object to String Conversion"
          ],
          "evaluationCriteria": [
            "Ability to trace complex coercion paths involving objects and arrays."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "operators",
            "javascript-fundamentals",
            "object-coercion"
          ],
          "prerequisites": [
            "javascript_datatypes",
            "javascript_operators"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_coercion_3",
          "topic": "JavaScript Type Coercion",
          "level": "hard",
          "type": "open",
          "question": "Explain the step-by-step evaluation of the expression `[] + false - null + true;` to arrive at `NaN`. Detail the internal type coercion rules applied at each binary operation.",
          "answer": "Let's break down the expression `[] + false - null + true;`:\n\n1.  **`[] + false`**: The `+` operator is encountered. Since one operand (`[]`) might resolve to a string, string concatenation is prioritized. `[]` is first converted to its primitive value via `ToPrimitive`, which results in `\"\"` (empty string). `false` is converted to `\"false\"` via `ToString`. Result: `\"\" + \"false\"` which evaluates to `\"false\"`.\n\n2.  **`\"false\" - null`**: The `-` operator is encountered. This operator performs numeric operations, so both operands are converted to numbers via `ToNumber`. `\"false\"` converts to `NaN`. `null` converts to `0`. Result: `NaN - 0` which evaluates to `NaN`.\n\n3.  **`NaN + true`**: The `+` operator is encountered again. Since one operand (`NaN`) is already a number, numeric addition is prioritized. `true` is converted to `1` via `ToNumber`. Result: `NaN + 1` which evaluates to `NaN`.\n\nTherefore, the final result is `NaN`.",
          "analysisPoints": [
            "Understanding the `+` operator's dual behavior (concatenation vs. addition).",
            "Knowing how `ToPrimitive`, `ToString`, and `ToNumber` apply to different data types (`array`, `boolean`, `null`).",
            "Recognizing that `NaN` propagates through arithmetic operations."
          ],
          "keyConcepts": [
            "Type Coercion",
            "Operator Precedence",
            "ToPrimitive",
            "ToString",
            "ToNumber",
            "NaN Propagation"
          ],
          "evaluationCriteria": [
            "Accuracy in detailing each step of coercion.",
            "Correct identification of internal conversion processes.",
            "Logical flow of explanation."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "operators",
            "javascript-interview",
            "NaN"
          ],
          "prerequisites": [
            "javascript_datatypes",
            "javascript_operators"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_coercion_4",
          "topic": "JavaScript Equality Operators",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference between `==` and `===` in JavaScript?",
          "answer": "`==` (loose equality) performs type coercion before comparing values, while `===` (strict equality) compares values and types without any coercion.",
          "analysisPoints": [
            "Distinguishing type coercion behavior.",
            "Understanding the implications for comparison reliability."
          ],
          "keyConcepts": [
            "Loose Equality",
            "Strict Equality",
            "Type Coercion"
          ],
          "evaluationCriteria": [
            "Concise and accurate definition of each operator."
          ],
          "example": null,
          "tags": [
            "equality",
            "operators",
            "flashcard"
          ],
          "prerequisites": [
            "javascript_operators"
          ],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_coercion_5",
          "topic": "JavaScript Operator Behavior",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following expressions will result in `NaN`?",
          "answer": "C) `\"hello\" * 2` is `NaN` because the string `\"hello\"` cannot be converted to a valid number for multiplication. A) `5 / 0` is `Infinity`. B) `true + true` is `2` (`true` converts to `1`). D) `!\"\"` is `true` (`\"\"` is falsy, `!` negates it).",
          "options": [
            "A) `5 / 0`",
            "B) `true + true`",
            "C) `\"hello\" * 2`",
            "D) `!\"\"`"
          ],
          "analysisPoints": [
            "Understanding numeric coercion for multiplication.",
            "Knowing results of division by zero.",
            "Recalling boolean to number coercion for addition.",
            "Understanding logical NOT operator with truthy/falsy values."
          ],
          "keyConcepts": [
            "NaN",
            "Infinity",
            "Type Coercion",
            "Arithmetic Operators",
            "Boolean Coercion"
          ],
          "evaluationCriteria": [
            "Ability to predict outcomes of various operator applications."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "operators",
            "NaN"
          ],
          "prerequisites": [
            "javascript_operators",
            "javascript_datatypes"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_coercion_6",
          "topic": "JavaScript Operator Behavior",
          "level": "medium",
          "type": "open",
          "question": "In JavaScript, `5 / 0` results in `Infinity`, not an error. What are the implications of this behavior for frontend development, and how might you handle it to prevent unexpected application states?",
          "answer": "Implications of `5 / 0` resulting in `Infinity`:\n1.  **Unexpected Display**: Displaying `Infinity` directly to users can be confusing or misleading, especially in calculations (e.g., a 'price per item' suddenly becoming 'Infinity').\n2.  **Further Calculations**: `Infinity` is a valid number, so it can participate in further arithmetic operations, potentially propagating `Infinity` or `NaN` through the application's data flow, leading to incorrect results.\n3.  **Validation**: If not explicitly checked, `Infinity` might pass numeric validation checks that only look for `NaN` or non-numeric types.\n\nHandling strategies:\n1.  **Input Validation**: Before performing division, validate the denominator. If it's `0`, either prevent the calculation, show an error message, or assign a default/fallback value.\n    ```javascript\n    function safeDivide(numerator, denominator) {\n      if (denominator === 0) {\n        console.warn(\"Attempted division by zero.\");\n        return 0; // Or throw an error, or return null/undefined\n      }\n      return numerator / denominator;\n    }\n    ```\n2.  **Output Formatting/Conditional Rendering**: Check the result of division before displaying it. If it's `Infinity` or `NaN`, display a user-friendly message like 'N/A' or 'Calculation Error'.\n    ```javascript\n    const result = value1 / value2;\n    if (result === Infinity || result === -Infinity || isNaN(result)) {\n      document.getElementById('output').textContent = 'Cannot calculate';\n    } else {\n      document.getElementById('output').textContent = result;\n    }\n    ```\n3.  **Error Boundaries/Fallbacks**: In frameworks like React, error boundaries can catch such calculation errors in components and display a fallback UI.\n4.  **Backend Validation**: For critical calculations, perform validation on the backend as well, as frontend validation can be bypassed.",
          "analysisPoints": [
            "Understanding the specific numerical behavior of JavaScript.",
            "Identifying practical problems arising from this behavior in UI/UX.",
            "Proposing concrete, actionable solutions for prevention and handling."
          ],
          "keyConcepts": [
            "Infinity",
            "NaN",
            "Error Handling",
            "Input Validation",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Depth of understanding of `Infinity`'s implications.",
            "Practicality and completeness of proposed solutions.",
            "Awareness of frontend best practices for data display and validation."
          ],
          "example": null,
          "tags": [
            "javascript-gotchas",
            "frontend-development",
            "error-handling",
            "NaN",
            "infinity"
          ],
          "prerequisites": [
            "javascript_operators",
            "javascript_error_handling"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_coercion_7",
          "topic": "JavaScript Logical Operators",
          "level": "medium",
          "type": "mcq",
          "question": "What is the value of `let result = 0 || \"hello\" && null;`?",
          "answer": "B) `null`\n\nExplanation:\n1.  `\"hello\" && null`: The `&&` operator evaluates from left to right. `\"hello\"` is truthy, so it proceeds to `null`. `null` is falsy, so `&&` returns `null`. The expression becomes `0 || null`.\n2.  `0 || null`: The `||` operator evaluates from left to right. `0` is falsy, so it proceeds to `null`. `null` is also falsy, so `||` returns the last falsy value, which is `null`.",
          "options": [
            "A) `0`",
            "B) `null`",
            "C) `\"hello\"`",
            "D) `true`"
          ],
          "analysisPoints": [
            "Understanding operator precedence (`&&` before `||`).",
            "Knowing the short-circuiting behavior of `&&` and `||`.",
            "Identifying truthy and falsy values in JavaScript."
          ],
          "keyConcepts": [
            "Logical Operators",
            "Short-circuiting",
            "Truthy/Falsy Values",
            "Operator Precedence"
          ],
          "evaluationCriteria": [
            "Correctly applying operator precedence.",
            "Accurate prediction of short-circuiting behavior."
          ],
          "example": null,
          "tags": [
            "operators",
            "logical-operators",
            "truthy-falsy"
          ],
          "prerequisites": [
            "javascript_operators"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_coercion_8",
          "topic": "JavaScript Type Coercion",
          "level": "easy",
          "type": "flashcard",
          "question": "What does `5 + undefined` evaluate to in JavaScript?",
          "answer": "`NaN` (Not a Number)",
          "analysisPoints": [
            "Recalling the numeric coercion behavior of `undefined`."
          ],
          "keyConcepts": [
            "NaN",
            "Type Coercion",
            "Undefined"
          ],
          "evaluationCriteria": [
            "Quick recall of fundamental coercion rules."
          ],
          "example": null,
          "tags": [
            "type-coercion",
            "NaN",
            "flashcard"
          ],
          "prerequisites": [
            "javascript_datatypes"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_hoisting_1",
          "topic": "JavaScript Hoisting",
          "level": "easy",
          "type": "mcq",
          "question": "What will be printed to the console by the following code snippet?\n```javascript\nconsole.log(myVar);\nvar myVar = 10;\n```",
          "answer": "B) `undefined`\n\nExplanation: Due to hoisting, the declaration `var myVar` is moved to the top of its scope and initialized with `undefined`. The assignment `myVar = 10` happens only on the second line. Therefore, `console.log(myVar)` outputs `undefined`.",
          "options": [
            "A) `10`",
            "B) `undefined`",
            "C) `ReferenceError`",
            "D) `null`"
          ],
          "analysisPoints": [
            "Understanding `var` hoisting and its initialization behavior.",
            "Distinguishing between declaration and assignment in hoisted variables."
          ],
          "keyConcepts": [
            "Hoisting",
            "Var Keyword",
            "Undefined"
          ],
          "evaluationCriteria": [
            "Correct prediction of `var` hoisting outcome."
          ],
          "example": "\n```javascript\nconsole.log(myVar);\nvar myVar = 10;\n```",
          "tags": [
            "hoisting",
            "var",
            "javascript-fundamentals"
          ],
          "prerequisites": [
            "javascript_variables"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_hoisting_2",
          "topic": "JavaScript Hoisting",
          "level": "medium",
          "type": "mcq",
          "question": "What will be the output of the following code?\n```javascript\nconsole.log(foo());\n\nfunction foo() {\n  return 'Hello';\n}\n\nconsole.log(bar());\n\nvar bar = function() {\n  return 'World';\n};\n```",
          "answer": "C) `Hello` followed by a `TypeError`\n\nExplanation:\n1.  `console.log(foo());`: `foo` is a function declaration, which is fully hoisted. So, `foo()` executes successfully and returns `\"Hello\"`.\n2.  `console.log(bar());`: `bar` is a function expression assigned to a `var` variable. While `var bar` is hoisted and initialized to `undefined`, the function assignment happens later. When `bar()` is called before its assignment, `bar` is `undefined`, and `undefined()` results in a `TypeError` (attempting to call `undefined` as a function).",
          "options": [
            "A) `Hello` followed by `World`",
            "B) `ReferenceError` followed by `World`",
            "C) `Hello` followed by a `TypeError`",
            "D) `TypeError` followed by `TypeError`"
          ],
          "analysisPoints": [
            "Differentiating hoisting behavior of function declarations and function expressions.",
            "Understanding what happens when an `undefined` variable is called as a function."
          ],
          "keyConcepts": [
            "Hoisting",
            "Function Declaration",
            "Function Expression",
            "TypeError",
            "Var Hoisting"
          ],
          "evaluationCriteria": [
            "Correctly identifying the hoisting mechanism for different function types.",
            "Predicting runtime errors based on hoisting."
          ],
          "example": "\n```javascript\nconsole.log(foo());\n\nfunction foo() {\n  return 'Hello';\n}\n\nconsole.log(bar());\n\nvar bar = function() {\n  return 'World';\n};\n```",
          "tags": [
            "hoisting",
            "function-declaration",
            "function-expression",
            "TypeError"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_variables"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoisting_3",
          "topic": "JavaScript Hoisting and TDZ",
          "level": "medium",
          "type": "mcq",
          "question": "What happens when you try to access a `let` variable before its declaration in the same block scope?",
          "answer": "B) It throws a `ReferenceError`.",
          "options": [
            "A) It returns `undefined`.",
            "B) It throws a `ReferenceError`.",
            "C) It returns `null`.",
            "D) The code executes normally if assigned later."
          ],
          "analysisPoints": [
            "Understanding the Temporal Dead Zone (TDZ) concept.",
            "Distinguishing `let`/`const` hoisting from `var` hoisting."
          ],
          "keyConcepts": [
            "Temporal Dead Zone (TDZ)",
            "Let Keyword",
            "Const Keyword",
            "ReferenceError",
            "Hoisting"
          ],
          "evaluationCriteria": [
            "Correctly identifying the error associated with TDZ."
          ],
          "example": "\n```javascript\n// console.log(myLetVar); // This line would throw a ReferenceError\nlet myLetVar = 'value';\n```",
          "tags": [
            "hoisting",
            "let",
            "const",
            "temporal-dead-zone"
          ],
          "prerequisites": [
            "javascript_variables",
            "javascript_es6"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoisting_4",
          "topic": "JavaScript Hoisting Priority",
          "level": "hard",
          "type": "open",
          "question": "Consider the following code. Explain in detail the output and why, focusing on hoisting priority and variable assignment.\n```javascript\n(function() {\n  console.log(funcVar);\n  var funcVar = 1;\n  function funcVar() {};\n  console.log(funcVar);\n})();\n```",
          "answer": "Let's analyze the execution within the IIFE:\n\n1.  **Hoisting Phase**: During compilation, JavaScript processes declarations.\n    *   The `function funcVar() {};` declaration is hoisted to the top of the IIFE's scope. This means `funcVar` is initially a function.\n    *   The `var funcVar = 1;` declaration is also hoisted. Since `function` declarations have higher priority, the `var` declaration does not *overwrite* the function declaration at this stage. However, the `var` declaration means that `funcVar` is now also identified as a variable within the scope, and will participate in variable assignments.\n\n    Conceptually, the code becomes:\n    ```javascript\n    (function() {\n      function funcVar() {}; // Hoisted first\n      var funcVar;          // Hoisted second, but does not overwrite the function yet\n\n      console.log(funcVar); // Line 1 in original code\n      funcVar = 1;          // Assignment part of 'var funcVar = 1;'\n      // The function funcVar() {}; is effectively ignored because funcVar is already declared\n      // as a function and then reassigned below.\n      console.log(funcVar); // Line 2 in original code\n    })();\n    ```\n\n2.  **Execution Phase**:\n    *   **`console.log(funcVar);` (first line)**: At this point, `funcVar` refers to the hoisted function `function funcVar() {}`. So, the console will output the *function definition itself*.\n        Output: `ƒ funcVar() {}` (or the full function code representation).\n\n    *   **`var funcVar = 1;`**: This line executes. The `var` declaration part has already been processed by hoisting, but the assignment `funcVar = 1` occurs now. This assignment *overwrites* the `funcVar` identifier, changing its value from the function to the number `1`.\n\n    *   **`function funcVar() {};`**: This line is effectively ignored during execution because `funcVar` has already been declared (and potentially assigned) earlier in the scope. It doesn't re-declare or re-assign `funcVar`.\n\n    *   **`console.log(funcVar);` (second line)**: Now, `funcVar` holds the value `1` because of the previous assignment. So, the console will output `1`.\n\n**Final Output:**\n```\nƒ funcVar() {}\n1\n```",
          "analysisPoints": [
            "Detailed understanding of the two-phase (hoisting/execution) process.",
            "Accurate application of hoisting priority rules (function declarations over `var` declarations).",
            "Understanding how assignments overwrite hoisted declarations during execution.",
            "Ability to trace variable values through scope and time."
          ],
          "keyConcepts": [
            "Hoisting Priority",
            "Function Declaration",
            "Var Keyword",
            "Scope",
            "Assignment",
            "Execution Context"
          ],
          "evaluationCriteria": [
            "Precision in explaining hoisting mechanisms.",
            "Correctly identifying the value of `funcVar` at each `console.log`.",
            "Clarity of explanation regarding function vs. variable declarations."
          ],
          "example": null,
          "tags": [
            "hoisting",
            "var",
            "function-declaration",
            "scope",
            "javascript-interview"
          ],
          "prerequisites": [
            "javascript_scope",
            "javascript_variables",
            "javascript_functions"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoisting_5",
          "topic": "JavaScript Hoisting",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the Temporal Dead Zone (TDZ) in JavaScript?",
          "answer": "The Temporal Dead Zone (TDZ) is the period of time between the start of a `let` or `const` variable's block scope and the actual declaration line. During this period, the variable cannot be accessed, or it will throw a `ReferenceError`.",
          "analysisPoints": [
            "Defining TDZ accurately.",
            "Associating TDZ with `let` and `const`."
          ],
          "keyConcepts": [
            "Temporal Dead Zone",
            "Let Keyword",
            "Const Keyword",
            "ReferenceError"
          ],
          "evaluationCriteria": [
            "Concise and correct definition."
          ],
          "example": null,
          "tags": [
            "hoisting",
            "TDZ",
            "let",
            "const",
            "flashcard"
          ],
          "prerequisites": [
            "javascript_es6"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoisting_6",
          "topic": "JavaScript Hoisting",
          "level": "medium",
          "type": "code",
          "question": "Given the following code, what will be the output? Explain your reasoning.",
          "answer": "```javascript\nfunction greet() {\n  console.log(message);\n  let message = \"Hello\";\n}\n\ngreet(); // Output: ReferenceError: Cannot access 'message' before initialization\n```\n\n**Explanation:**\nInside the `greet` function, `message` is declared with `let`. While `let` variables are hoisted to the top of their block scope, they are placed in the Temporal Dead Zone (TDZ). This means they are not initialized until their declaration line is executed. Attempting to access `message` on the `console.log(message)` line, before `let message = \"Hello\";` is executed, results in a `ReferenceError` because `message` is in its TDZ.",
          "options": [],
          "analysisPoints": [
            "Understanding lexical scoping for `let`.",
            "Applying the TDZ concept within a function scope.",
            "Correctly identifying the type of error (`ReferenceError`)."
          ],
          "keyConcepts": [
            "Hoisting",
            "Let Keyword",
            "Temporal Dead Zone",
            "Function Scope",
            "ReferenceError"
          ],
          "evaluationCriteria": [
            "Correctly predicting the error.",
            "Providing a clear, concise, and accurate explanation based on TDZ.",
            "Demonstrating knowledge of `let`'s hoisting behavior."
          ],
          "example": "\n```javascript\nfunction greet() {\n  console.log(message);\n  let message = \"Hello\";\n}\n\ngreet();\n```",
          "tags": [
            "hoisting",
            "let",
            "TDZ",
            "scope",
            "ReferenceError"
          ],
          "prerequisites": [
            "javascript_scope",
            "javascript_es6"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoisting_7",
          "topic": "JavaScript Hoisting",
          "level": "hard",
          "type": "open",
          "question": "Discuss the practical implications of JavaScript hoisting for code organization and debugging. Provide examples where understanding hoisting is critical.",
          "answer": "Understanding hoisting is critical for writing robust and debuggable JavaScript code:\n\n**Practical Implications for Code Organization:**\n1.  **`var` - Source of Confusion & Bugs**: Because `var` variables are hoisted and initialized to `undefined`, developers might accidentally use them before their intended assignment, leading to `undefined` values instead of a `ReferenceError`. This makes debugging harder as the error isn't immediate.\n    *   *Example*: Calculating `tax` using `rate` before `rate` is assigned can lead to `NaN` or incorrect results that are hard to trace.\n    ```javascript\n    function calculateTotal(price) {\n      console.log(tax); // undefined, but no error\n      // ... some complex logic ...\n      var tax = price * rate; // 'rate' is also undefined if not declared/assigned\n      var rate = 0.05; // Declared here, but tax was calculated before this assignment\n      return price + tax;\n    }\n    ```\n2.  **`let`/`const` - Encouraging Safer Practices**: The Temporal Dead Zone (TDZ) for `let` and `const` provides early feedback (a `ReferenceError`) if a variable is accessed before its declaration. This forces developers to declare variables before use, leading to more predictable code flow and fewer accidental `undefined` values.\n    *   *Best Practice*: Always declare `let`/`const` variables at the top of their scope if possible, or right before their first use, to minimize the TDZ.\n3.  **Function Declarations - Flexibility and Readability (with caution)**: Full hoisting of function declarations means utility functions can be defined at the bottom of a file or after their calls, which can sometimes improve readability by putting the 'main' logic first. However, over-reliance can lead to 'spaghetti code' where function definitions are scattered, making it hard to find them.\n4.  **Function Expressions - Predictable Order**: Function expressions (especially arrow functions or named function expressions with `let`/`const`) enforce a more synchronous, top-to-bottom execution order, as the function is only callable after its assignment. This can lead to more predictable code flow.\n\n**Criticality for Debugging:**\n1.  **`undefined` vs `ReferenceError`**: When debugging, an `undefined` value from a `var` variable accessed before assignment is much harder to trace than a clear `ReferenceError` from a `let`/`const` in its TDZ. The `ReferenceError` immediately points to the declaration issue.\n2.  **Scope and Closure Interactions**: Hoisting can interact subtly with closures. If a `var` variable is unexpectedly hoisted out of an inner loop, it might lead to closure bugs where all closures capture the *final* value of the variable, not the value at each iteration.\n    *   *Example*: Common loop problem with `var`:\n    ```javascript\n    for (var i = 0; i < 3; i++) {\n      setTimeout(function() {\n        console.log(i); // Outputs 3, 3, 3 (not 0, 1, 2) due to 'i' being function-scoped and hoisted\n      }, 100);\n    }\n    ```\n    Using `let` fixes this: `for (let i = 0; i < 3; i++)` because `let` creates a new `i` for each loop iteration.\n\nIn summary, understanding hoisting prevents `undefined` surprises, helps debug `ReferenceError`s efficiently, and guides choices between `var`, `let`, `const`, and function types for clearer, more maintainable code.",
          "analysisPoints": [
            "Comprehensive discussion of `var`, `let`, `const` and function hoisting implications.",
            "Specific examples illustrating problematic scenarios and how hoisting explains them.",
            "Focus on debugging challenges and how `let`/`const` mitigate them.",
            "Connecting theoretical concepts to practical code organization principles."
          ],
          "keyConcepts": [
            "Hoisting",
            "Var",
            "Let",
            "Const",
            "Temporal Dead Zone",
            "Debugging",
            "Code Organization",
            "Scope",
            "Closures"
          ],
          "evaluationCriteria": [
            "Depth of analysis on practical implications.",
            "Quality and relevance of provided code examples.",
            "Ability to articulate the pros and cons of different declaration types concerning hoisting.",
            "Clarity and structure of the argument."
          ],
          "example": null,
          "tags": [
            "hoisting",
            "best-practices",
            "debugging",
            "javascript-interview",
            "var-let-const"
          ],
          "prerequisites": [
            "javascript_scope",
            "javascript_closures"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_function_mechanics_1",
          "topic": "Function Types",
          "level": "easy",
          "type": "mcq",
          "question": "Which type of function can be called before its definition in the code?",
          "answer": "A) Function Declaration",
          "options": [
            "A) Function Declaration",
            "B) Function Expression",
            "C) Arrow Function",
            "D) IIFE"
          ],
          "analysisPoints": [
            "Understanding the hoisting behavior specific to function declarations."
          ],
          "keyConcepts": [
            "Hoisting",
            "Function Declaration",
            "Function Expression"
          ],
          "evaluationCriteria": [
            "Correctly identifying the function type with full hoisting."
          ],
          "example": null,
          "tags": [
            "functions",
            "hoisting",
            "function-declaration"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_hoisting"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_function_mechanics_2",
          "topic": "Function Types",
          "level": "medium",
          "type": "open",
          "question": "Contrast Function Declarations and Function Expressions in JavaScript. Discuss their hoisting behavior and provide a scenario where choosing one over the other would be beneficial.",
          "answer": "## Function Declaration vs. Function Expression\n\n**Function Declaration:**\n-   **Syntax**: `function functionName(parameters) { /* code */ }`\n-   **Hoisting**: Fully hoisted. Both the function name and its definition are moved to the top of the enclosing scope. This means you can call a function declaration before its definition in the code.\n-   **Named**: Always named.\n-   **Example**: `function greet() { console.log('Hello'); }`\n\n**Function Expression:**\n-   **Syntax**: `const functionName = function(parameters) { /* code */ };` (can also be anonymous or named: `const functionName = function innerName() {}`) or `const functionName = (parameters) => { /* code */ };` (Arrow Function)\n-   **Hoisting**: Not fully hoisted. Only the variable (e.g., `functionName` if declared with `var`, `let`, or `const`) is hoisted. The function's *definition* itself is only available after the line where it is assigned is executed. If declared with `var`, calling it before assignment results in `TypeError: ... is not a function`. If with `let`/`const`, it's a `ReferenceError` (TDZ).\n-   **Named/Anonymous**: Can be anonymous or named (named function expression).\n-   **Example**: `const greet = function() { console.log('Hello'); };` or `const greet = () => console.log('Hello');`\n\n## Scenario for Choosing One Over the Other:\n\n**Benefit of Function Declaration (when readability favors 'main logic first'):**\nConsider a script where you want to immediately show the main application flow, and helper functions are detailed later in the file. Function declarations allow you to call these helper functions at the top of the file even if their definitions are at the bottom.\n```javascript\n// Main application flow\ninitApp(); // Works because initApp and its dependencies are function declarations\n\nfunction initApp() {\n  setupUI();\n  loadData();\n}\n\n// Helper functions (defined later but still hoisted and callable)\nfunction setupUI() {\n  console.log('UI ready');\n}\n\nfunction loadData() {\n  console.log('Data loaded');\n}\n```\n\n**Benefit of Function Expression (for clear execution order and encapsulation):**\nWhen you need to ensure a function is not accessible before a certain point in the code, or when you are assigning functions conditionally or passing them as arguments. For example, using a function expression within an IIFE to create a private scope, or assigning a function dynamically based on a condition.\n```javascript\n// Function expression, not callable here yet (TDZ)\n// greetUser(); // ReferenceError\n\nlet greetUser;\nconst hour = new Date().getHours();\n\nif (hour < 12) {\n  greetUser = function() { // Function expression\n    console.log('Good morning!');\n  };\n} else {\n  greetUser = () => { // Arrow function expression\n    console.log('Good afternoon!');\n  };\n}\n\ngreetUser(); // Callable after assignment, based on condition\n```\n\nIn general, modern JavaScript development often favors function expressions (especially arrow functions with `const`) for their predictable behavior (`let`/`const` TDZ makes it clear when a function is ready) and suitability for functional programming paradigms. Function declarations remain useful for top-level, general-purpose functions.",
          "analysisPoints": [
            "Clear definition of both function types.",
            "Accurate comparison of their hoisting behavior and implications (TDZ, TypeError).",
            "Providing distinct, practical scenarios where each type is advantageous.",
            "Discussing modern preferences and why."
          ],
          "keyConcepts": [
            "Function Declaration",
            "Function Expression",
            "Arrow Function",
            "Hoisting",
            "Temporal Dead Zone",
            "Scope",
            "Readability",
            "Encapsulation"
          ],
          "evaluationCriteria": [
            "Thoroughness of the comparison.",
            "Relevance and clarity of example scenarios.",
            "Understanding of practical implications for code structure.",
            "Demonstration of nuanced understanding of JS function mechanics."
          ],
          "example": null,
          "tags": [
            "functions",
            "hoisting",
            "function-declaration",
            "function-expression",
            "arrow-functions",
            "javascript-interview"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_hoisting",
            "javascript_scope"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_function_mechanics_3",
          "topic": "IIFE (Immediately Invoked Function Expression)",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary benefit of using an IIFE (Immediately Invoked Function Expression) in JavaScript?",
          "answer": "B) To create a private scope for variables and functions, preventing global pollution.",
          "options": [
            "A) To ensure the function is hoisted to the top of the global scope.",
            "B) To create a private scope for variables and functions, preventing global pollution.",
            "C) To allow `this` binding to work correctly in all contexts.",
            "D) To define a function that can be reused multiple times without re-declaration."
          ],
          "analysisPoints": [
            "Identifying the core purpose of IIFEs.",
            "Distinguishing IIFE benefits from other function-related concepts."
          ],
          "keyConcepts": [
            "IIFE",
            "Scope",
            "Global Pollution",
            "Data Privacy"
          ],
          "evaluationCriteria": [
            "Correctly identifying the main advantage of IIFEs."
          ],
          "example": null,
          "tags": [
            "IIFE",
            "scoping",
            "javascript-patterns"
          ],
          "prerequisites": [
            "javascript_scope"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_function_mechanics_4",
          "topic": "Arrow Functions",
          "level": "medium",
          "type": "flashcard",
          "question": "What are two key differences between arrow functions and traditional function expressions regarding `this` and `arguments`?",
          "answer": "Arrow functions do not have their own `this` binding; they lexically inherit `this` from the enclosing scope. They also do not have their own `arguments` object.",
          "analysisPoints": [
            "Recalling the `this` binding difference.",
            "Remembering the absence of `arguments` object."
          ],
          "keyConcepts": [
            "Arrow Functions",
            "This Keyword",
            "Lexical Scoping",
            "Arguments Object"
          ],
          "evaluationCriteria": [
            "Concise and accurate recall of arrow function characteristics."
          ],
          "example": null,
          "tags": [
            "arrow-functions",
            "this",
            "arguments",
            "flashcard"
          ],
          "prerequisites": [
            "javascript_this_keyword",
            "javascript_functions"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_function_mechanics_5",
          "topic": "IIFE (Immediately Invoked Function Expression)",
          "level": "hard",
          "type": "code",
          "question": "Refactor the following code to use an IIFE to encapsulate `secretMessage` and `displayMessage` function, so they are not accessible globally. Then, explain why this pattern is useful for modularity.",
          "answer": "```javascript\n// Original code (global variables and function)\n// var secretMessage = \"This is a secret!\";\n// function displayMessage() {\n//   console.log(secretMessage);\n// }\n// displayMessage();\n\n// Refactored with IIFE\n(function() {\n  var secretMessage = \"This is a secret encapsulated by IIFE!\";\n  function displayMessage() {\n    console.log(secretMessage);\n  }\n\n  // To expose functionality, you might return it, e.g., if it needs to be called later.\n  // For this specific case, it runs immediately and is then gone.\n  displayMessage(); // Invoked immediately within its private scope\n})();\n\n// console.log(secretMessage); // ReferenceError: secretMessage is not defined\n// displayMessage();         // ReferenceError: displayMessage is not defined\n\n// Explanation:\n// The IIFE creates a new function execution context (scope). All variables\n// (like secretMessage) and functions (like displayMessage) declared inside\n// this IIFE are private to it. They are not added to the global scope.\n// This prevents naming collisions and keeps the global namespace clean, which\n// is crucial for modularity, especially in larger applications or when integrating\n// third-party scripts. It ensures that internal logic does not interfere with other\n// parts of the application or with other libraries. While modern JavaScript\n// uses ES Modules for this, IIFEs were a foundational pattern before modules\n// were widely adopted and are still seen in older codebases or for quick, isolated scripts.\n```",
          "options": [],
          "analysisPoints": [
            "Correctly implementing the IIFE pattern.",
            "Demonstrating that variables/functions are no longer global.",
            "Articulating the benefits of IIFE for modularity and global scope protection.",
            "Comparing with modern module systems (optional but good)."
          ],
          "keyConcepts": [
            "IIFE",
            "Scope",
            "Modularity",
            "Global Scope",
            "Encapsulation"
          ],
          "evaluationCriteria": [
            "Functional correctness of the refactored code.",
            "Clear explanation of modularity benefits.",
            "Understanding of scope isolation provided by IIFEs."
          ],
          "example": "\n```typescript\n// Original code (global variables and function)\nvar secretMessage = \"This is a secret!\";\nfunction displayMessage() {\n  console.log(secretMessage);\n}\ndisplayMessage();\n```",
          "tags": [
            "IIFE",
            "scoping",
            "modularity",
            "javascript-patterns"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_scope"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_function_mechanics_6",
          "topic": "Function Mechanics",
          "level": "medium",
          "type": "flashcard",
          "question": "Can an arrow function be used as a constructor with the `new` keyword? Why or why not?",
          "answer": "No, an arrow function cannot be used as a constructor with the `new` keyword. Arrow functions do not have their own `this` binding or a `prototype` property, which are essential for constructor functions to create new instances and establish prototypal inheritance.",
          "analysisPoints": [
            "Recalling the limitations of arrow functions.",
            "Understanding the requirements for constructor functions."
          ],
          "keyConcepts": [
            "Arrow Functions",
            "Constructor Functions",
            "New Keyword",
            "This Keyword",
            "Prototype"
          ],
          "evaluationCriteria": [
            "Correctly stating the limitation.",
            "Providing the underlying technical reason."
          ],
          "example": null,
          "tags": [
            "arrow-functions",
            "constructor",
            "this",
            "prototype",
            "flashcard"
          ],
          "prerequisites": [
            "javascript_oop",
            "javascript_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_coercion_quiz",
          "title": "Predict JavaScript Type Coercion Outcomes",
          "description": "\nYou are given a series of JavaScript expressions involving various operators and data types. Your task is to predict the exact output for each expression, explaining the step-by-step type coercion process that leads to your answer. This task tests your understanding of JavaScript's implicit type conversion rules and operator precedence.\n\n**Requirements:**\n1.  For each `console.log` statement, write down the predicted output.\n2.  For expressions involving coercion, provide a brief explanation of how each step of coercion (e.g., `ToPrimitive`, `ToNumber`, `ToString`) occurs.\n3.  Identify any cases resulting in `NaN`, `Infinity`, `TypeError`, or `ReferenceError` and explain why.\n",
          "difficulty": "medium",
          "startingCode": "console.log(1 + '2' + 3);\nconsole.log('5' - true);\nconsole.log(true == '1');\nconsole.log(null == 0);\nconsole.log(null > 0);\nconsole.log(null >= 0);\nconsole.log(1 / 'abc');\nconsole.log(Boolean(''));\nconsole.log(!!'hello');\nconsole.log(5 && 0);\nconsole.log([] == ![]);\n",
          "solutionCode": "// Predicted Outputs and Explanations:\n\n// 1. console.log(1 + '2' + 3);\n//    1 + '2' -> '12' (number to string, then concatenation)\n//    '12' + 3 -> '123' (number to string, then concatenation)\n//    Output: \"123\"\n\n// 2. console.log('5' - true);\n//    '5' (ToNumber) -> 5\n//    true (ToNumber) -> 1\n//    5 - 1 -> 4\n//    Output: 4\n\n// 3. console.log(true == '1');\n//    true (ToNumber) -> 1\n//    '1' (ToNumber) -> 1\n//    1 == 1 -> true\n//    Output: true\n\n// 4. console.log(null == 0);\n//    Special rule: null only loosely equals null or undefined. It does not coerce to 0 for ==.\n//    Output: false\n\n// 5. console.log(null > 0);\n//    null (ToNumber) -> 0\n//    0 > 0 -> false\n//    Output: false\n\n// 6. console.log(null >= 0);\n//    null (ToNumber) -> 0\n//    0 >= 0 -> true\n//    Output: true\n\n// 7. console.log(1 / 'abc');\n//    'abc' (ToNumber) -> NaN\n//    1 / NaN -> NaN\n//    Output: NaN\n\n// 8. console.log(Boolean(''));\n//    '' is a falsy value. Boolean('') converts it to false.\n//    Output: false\n\n// 9. console.log(!!'hello');\n//    'hello' is a truthy value. !'hello' -> false. !false -> true.\n//    Output: true\n\n// 10. console.log(5 && 0);\n//     5 is truthy, so && evaluates to the second operand.\n//     Output: 0\n\n// 11. console.log([] == ![]);\n//     ![]: [] is truthy, so ![] -> false.\n//     [] == false: [] (ToPrimitive) -> \"\". \"\" (ToNumber) -> 0.\n//     false (ToNumber) -> 0.\n//     0 == 0 -> true\n//     Output: true\n",
          "testCases": [
            "Expected output for `1 + '2' + 3` should be `\"123\"`.",
            "Expected output for `'5' - true` should be `4`.",
            "Expected output for `true == '1'` should be `true`.",
            "Expected output for `null == 0` should be `false`.",
            "Expected output for `null > 0` should be `false`.",
            "Expected output for `null >= 0` should be `true`.",
            "Expected output for `1 / 'abc'` should be `NaN`.",
            "Expected output for `Boolean('')` should be `false`.",
            "Expected output for `!!'hello'` should be `true`.",
            "Expected output for `5 && 0` should be `0`.",
            "Expected output for `[] == ![]` should be `true`."
          ],
          "hints": [
            "Remember the `+` operator's dual nature: string concatenation if any operand is a string, otherwise numeric addition.",
            "Other arithmetic operators (`-`, `*`, `/`) always try to convert operands to numbers.",
            "Pay close attention to the special rules for `null` and `undefined` in comparisons (`==` vs `===`) and arithmetic operations.",
            "Boolean coercion to numbers: `true` is `1`, `false` is `0`.",
            "How do empty arrays (`[]`) and empty objects (`{}`) convert to primitives and then to numbers/strings?",
            "Recall the short-circuiting behavior of logical `&&` and `||` operators."
          ],
          "tags": [
            "type-coercion",
            "operators",
            "javascript-fundamentals",
            "quiz"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "javascript_datatypes",
            "javascript_operators"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_type_coercion"
          ]
        },
        {
          "id": "task_analyze_coercion_expression",
          "title": "Analyze and Correct a Coercion Bug",
          "description": "\nYou are debugging a frontend application where a user's input for a numeric quantity is causing incorrect calculations. The input is initially a string, and a developer tried to perform a calculation that resulted in `NaN`. Your task is to analyze the provided problematic code snippet, identify the source of `NaN` due to type coercion, and then correct it to perform the intended numeric calculation.\n\n**Problematic Code:**\n```javascript\nfunction calculateTotal(price, quantityInput) {\n  // price is a number, e.g., 10.50\n  // quantityInput is a string, e.g., \"2\"\n  // This line is causing issues:\n  const total = price + quantityInput;\n  console.log(`Calculated Total: ${total}`);\n  return total;\n}\n\n// Test cases:\ncalculateTotal(10.50, \"2\"); // Expected: 21.00, Actual: 10.502\ncalculateTotal(5, \"3\");   // Expected: 15, Actual: 53\n```\n\n**Requirements:**\n1.  Explain *why* `price + quantityInput` results in an incorrect value (e.g., `10.502` instead of `21.00`). Detail the type coercion occurring.\n2.  Modify the `calculateTotal` function to correctly perform numeric addition, ensuring `quantityInput` is treated as a number.\n3.  Ensure the corrected function passes the provided test cases.\n",
          "difficulty": "easy",
          "startingCode": "function calculateTotal(price, quantityInput) {\n  // price is a number, e.g., 10.50\n  // quantityInput is a string, e.g., \"2\"\n  // This line is causing issues:\n  const total = price + quantityInput;\n  console.log(`Calculated Total: ${total}`);\n  return total;\n}\n\n// Test cases:\ncalculateTotal(10.50, \"2\"); // Expected: 21.00, Actual: 10.502\ncalculateTotal(5, \"3\");   // Expected: 15, Actual: 53\n",
          "solutionCode": "function calculateTotal(price, quantityInput) {\n  // Explanation of the bug:\n  // The '+' operator in JavaScript performs string concatenation if one of the operands is a string.\n  // Here, 'price' is a number and 'quantityInput' is a string (\"2\").\n  // JavaScript coerces 'price' (10.50) to a string (\"10.50\") and then concatenates it with \"2\",\n  // resulting in \"10.502\", which is not the intended numeric sum.\n\n  // Correction: Explicitly convert quantityInput to a number.\n  // Options: Number(), parseInt(), parseFloat(), or unary plus (+)\n  const numericQuantity = Number(quantityInput); // Or +quantityInput; or parseFloat(quantityInput);\n\n  // Now perform the correct numeric addition\n  const total = price * numericQuantity; // Using multiplication for clarity on price * quantity\n                                        // If the intention was actually price + quantity, then it would be:\n                                        // const total = price + numericQuantity;\n\n  console.log(`Calculated Total: ${total}`);\n  return total;\n}\n\n// Test cases:\nconsole.log(\"Test 1:\");\ncalculateTotal(10.50, \"2\"); // Expected: 21.00\nconsole.log(\"Test 2:\");\ncalculateTotal(5, \"3\");   // Expected: 15\n\n// Bonus: Handle invalid quantity input\nfunction calculateTotalSafe(price, quantityInput) {\n  const numericQuantity = Number(quantityInput);\n  if (isNaN(numericQuantity)) {\n    console.error(\"Invalid quantity input: Not a number\");\n    return NaN; // Or throw an error, or return 0\n  }\n  const total = price * numericQuantity;\n  console.log(`Calculated Total Safe: ${total}`);\n  return total;\n}\n\nconsole.log(\"Test 3 (Safe):\");\ncalculateTotalSafe(10, \"abc\"); // Expected: NaN (or handled error)\nconsole.log(\"Test 4 (Safe):\");\ncalculateTotalSafe(7, \"0\");    // Expected: 0\n",
          "testCases": [
            "Calling `calculateTotal(10.50, \"2\")` should return `21` (or `21.00`).",
            "Calling `calculateTotal(5, \"3\")` should return `15`.",
            "Consider an edge case: `calculateTotal(10, \"0\")` should return `0`.",
            "Consider invalid input: `calculateTotal(10, \"abc\")` should ideally handle gracefully (e.g., return `NaN` or throw an error)."
          ],
          "hints": [
            "The `+` operator has a special behavior when one operand is a string.",
            "To ensure numeric addition, you must explicitly convert the string to a number.",
            "Common ways to convert a string to a number include `Number()`, `parseInt()`, `parseFloat()`, or the unary plus operator (`+str`).",
            "Think about what operation `price` and `quantity` should actually perform: addition or multiplication?"
          ],
          "tags": [
            "type-coercion",
            "debugging",
            "javascript-fundamentals",
            "numeric-conversion"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "javascript_datatypes",
            "javascript_operators"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "theory_type_coercion"
          ]
        },
        {
          "id": "task_predict_hoisting_output",
          "title": "Predict Hoisting Behavior Output",
          "description": "\nThis task presents several JavaScript code snippets involving `var`, `let`, `const`, and function declarations/expressions. Your goal is to predict the exact output of each `console.log` statement and explain your reasoning, specifically focusing on how hoisting, scope, and the Temporal Dead Zone (TDZ) affect the variables and functions.\n\n**Requirements:**\n1.  For each snippet, write down the predicted output for each `console.log` statement.\n2.  Explain *why* that output occurs, referencing hoisting rules, `var` initialization, `let`/`const` TDZ, and function hoisting behavior.\n3.  Identify any `ReferenceError` or `TypeError` and explain their cause.\n",
          "difficulty": "medium",
          "startingCode": "// Snippet 1\nconsole.log(a);\nvar a = 10;\n\n// Snippet 2\nconsole.log(b);\nlet b = 20;\n\n// Snippet 3\nfunction outer() {\n  console.log(c);\n  var c = 30;\n}\nouter();\n\n// Snippet 4\nfunction doSomething() {\n  console.log(myFunc());\n  function myFunc() {\n    return \"Hello from func declaration\";\n  }\n}\ndoSomething();\n\n// Snippet 5\nfunction doAnotherThing() {\n  console.log(myArrowFunc());\n  const myArrowFunc = () => \"Hello from arrow func\";\n}\ndoAnotherThing();\n\n// Snippet 6\n(function() {\n  console.log(x);\n  var x = 1;\n  function x() {};\n  console.log(x);\n})();\n",
          "solutionCode": "// Snippet 1\nconsole.log(a); // Output: undefined\nvar a = 10;\n// Explanation: 'var a' is hoisted to the top and initialized with undefined. The console.log runs before 'a' is assigned 10.\n\n// Snippet 2\n// console.log(b); // Output: ReferenceError: Cannot access 'b' before initialization\n// let b = 20;\n// Explanation: 'let b' is hoisted but placed in the Temporal Dead Zone (TDZ). Accessing it before its declaration line throws a ReferenceError.\n\n// Snippet 3\nfunction outer() {\n  console.log(c); // Output: undefined\n  var c = 30;\n}\nouter();\n// Explanation: 'var c' is hoisted to the top of the 'outer' function's scope and initialized with undefined. So, logging it before assignment yields undefined.\n\n// Snippet 4\nfunction doSomething() {\n  console.log(myFunc()); // Output: \"Hello from func declaration\"\n  function myFunc() {\n    return \"Hello from func declaration\";\n  }\n}\ndoSomething();\n// Explanation: Function declarations (myFunc) are fully hoisted, meaning their definition is available throughout their containing scope. Thus, myFunc() can be called before its definition.\n\n// Snippet 5\nfunction doAnotherThing() {\n  // console.log(myArrowFunc()); // Output: ReferenceError: Cannot access 'myArrowFunc' before initialization\n  const myArrowFunc = () => \"Hello from arrow func\";\n}\ndoAnotherThing();\n// Explanation: Arrow functions are function expressions. They are assigned to a variable (myArrowFunc in this case, declared with const). The 'const' variable is hoisted but is in the Temporal Dead Zone (TDZ). Accessing it before its declaration/initialization results in a ReferenceError.\n\n// Snippet 6\n(function() {\n  console.log(x); // Output: ƒ x() {}\n  var x = 1;\n  function x() {};\n  console.log(x); // Output: 1\n})();\n// Explanation:\n// During hoisting:\n// 1. function x() {} is hoisted first (higher priority).\n// 2. var x; is hoisted second, but does not overwrite the function declaration.\n// First console.log(x): 'x' refers to the hoisted function. So, the function definition is logged.\n// After var x = 1;: The assignment `x = 1` takes place, overwriting the function reference with the number 1.\n// Second console.log(x): 'x' now holds the value 1. So, 1 is logged.\n",
          "testCases": [
            "Snippet 1 should output `undefined`.",
            "Snippet 2 should throw `ReferenceError`.",
            "Snippet 3 should output `undefined`.",
            "Snippet 4 should output `\"Hello from func declaration\"`.",
            "Snippet 5 should throw `ReferenceError`.",
            "Snippet 6 should first output the function definition, then `1`."
          ],
          "hints": [
            "Remember that `var` variables are initialized to `undefined` upon hoisting, while `let` and `const` enter the Temporal Dead Zone (TDZ).",
            "Function *declarations* are fully hoisted, but function *expressions* are not.",
            "Pay attention to the order of declarations and assignments within the scope.",
            "When a `var` variable and a function declaration share the same name, which one takes precedence during hoisting?"
          ],
          "tags": [
            "hoisting",
            "var",
            "let",
            "const",
            "function-declaration",
            "function-expression",
            "temporal-dead-zone"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "javascript_variables",
            "javascript_functions",
            "javascript_scope",
            "javascript_es6"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_hoisting"
          ]
        },
        {
          "id": "task_refactor_for_tdz",
          "title": "Refactor Code to Avoid Temporal Dead Zone Issues",
          "description": "\nYou've inherited a JavaScript codebase with sections that occasionally throw `ReferenceError` due to improper use of `let` and `const`. Your task is to refactor the provided code snippets to eliminate these `ReferenceError`s by correctly handling the Temporal Dead Zone (TDZ).\n\n**Requirements:**\n1.  For each snippet, identify the line causing the `ReferenceError`.\n2.  Modify the code to ensure `let` and `const` variables are accessed only after their declaration, without changing the logical intent or introducing `var`.\n3.  Explain *why* your changes resolve the TDZ issue.\n\n**Snippet 1 (Function Scope):**\n```javascript\nfunction greetUser(name) {\n  console.log(`Hello, ${greeting}`);\n  let greeting = \"Good morning\";\n  console.log(`Hello, ${name}!`);\n}\ngreetUser(\"Alice\");\n```\n\n**Snippet 2 (Block Scope):**\n```javascript\nif (true) {\n  console.log(config);\n  const config = { api: 'v1' };\n  console.log(config.api);\n}\n```\n\n**Snippet 3 (Loop Scope - conceptual):**\n*(No code to fix, but explain how `let` addresses a common `var` loop issue which is related to scope/TDZ conceptual understanding)*\n\n```javascript\n// Consider this common problematic pattern with var (no fix needed for this snippet, just explain):\nfor (var i = 0; i < 3; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, 100);\n}\n// Explain how 'let i' in the loop fixes this and why.\n```\n",
          "difficulty": "medium",
          "startingCode": "function greetUser(name) {\n  console.log(`Hello, ${greeting}`);\n  let greeting = \"Good morning\";\n  console.log(`Hello, ${name}!`);\n}\ngreetUser(\"Alice\");\n\nif (true) {\n  console.log(config);\n  const config = { api: 'v1' };\n  console.log(config.api);\n}\n\n// Consider this common problematic pattern with var (no fix needed for this snippet, just explain):\nfor (var i = 0; i < 3; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, 100);\n}\n// Explain how 'let i' in the loop fixes this and why.\n",
          "solutionCode": "// Snippet 1 (Function Scope) - Solution\nfunction greetUser(name) {\n  let greeting = \"Good morning\"; // Moved declaration above usage\n  console.log(`Hello, ${greeting}`);\n  console.log(`Hello, ${name}!`);\n}\ngreetUser(\"Alice\");\n// Explanation: The 'let greeting' declaration was moved before its first usage in console.log. This ensures 'greeting' is out of its Temporal Dead Zone (TDZ) when accessed, preventing the ReferenceError.\n\n// Snippet 2 (Block Scope) - Solution\nif (true) {\n  const config = { api: 'v1' }; // Moved declaration above usage\n  console.log(config);\n  console.log(config.api);\n}\n// Explanation: Similar to Snippet 1, 'const config' was moved before the console.log. 'const' variables also have a TDZ, and accessing them before declaration results in a ReferenceError. Placing the declaration first resolves this.\n\n// Snippet 3 (Loop Scope - conceptual explanation)\n// Problematic code with var:\nfor (var i = 0; i < 3; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, 100);\n}\n// Output: 3, 3, 3\n// Explanation of the problem: With 'var', 'i' is function-scoped (or global if outside a function). It's effectively one variable shared across all loop iterations. By the time setTimeout's callbacks execute (asynchronously, after the loop finishes), 'i' has already reached its final value of 3. All closures formed by the setTimeout callbacks close over the *same* 'i' variable, which is 3.\n\n// Solution with let:\n// for (let i = 0; i < 3; i++) {\n//   setTimeout(function() {\n//     console.log(i);\n//   }, 100);\n// }\n// Expected Output: 0, 1, 2\n// Explanation of the fix: 'let' creates a new lexical scope for each iteration of the loop. This means a *new* 'i' variable is created and initialized for each pass of the loop. Each setTimeout callback then captures the 'i' specific to its iteration, resolving the closure problem related to the shared variable. This behavior is related to the TDZ because it enforces block-scoping, making variables inaccessible outside their specific iteration's scope until declared within that iteration.\n",
          "testCases": [
            "Snippet 1 should execute without `ReferenceError` and print `Hello, Good morning` then `Hello, Alice!`.",
            "Snippet 2 should execute without `ReferenceError` and print the `config` object then `v1`.",
            "Conceptual explanation for Snippet 3 should correctly describe why `var` causes an issue and how `let` resolves it due to block scoping for each iteration."
          ],
          "hints": [
            "Remember that `let` and `const` variables are hoisted but are in a Temporal Dead Zone until their declaration line is executed.",
            "To resolve a `ReferenceError` caused by TDZ, simply move the declaration of the `let` or `const` variable *before* its first usage.",
            "Think about the difference between function scope (`var`) and block scope (`let`/`const`) when analyzing loops."
          ],
          "tags": [
            "hoisting",
            "let",
            "const",
            "temporal-dead-zone",
            "scope",
            "refactoring",
            "debugging"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "javascript_variables",
            "javascript_scope",
            "javascript_es6",
            "javascript_hoisting"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_hoisting"
          ]
        },
        {
          "id": "task_implement_utility_function",
          "title": "Implement a Secure Utility Function with IIFE or modern modules",
          "description": "\nDesign and implement a JavaScript utility module that provides a simple counter functionality. The module should allow incrementing the counter and retrieving its current value, but the internal counter variable itself should not be directly accessible from outside the module.\n\n**Requirements:**\n1.  Implement this functionality using an Immediately Invoked Function Expression (IIFE) for encapsulation.\n2.  Alternatively, demonstrate how you would achieve the same encapsulation using modern ES Modules syntax if the environment supports it (optional, but encouraged).\n3.  The module should expose a public API with `increment()` and `getValue()` methods.\n4.  Ensure the internal counter cannot be modified or accessed directly.\n\n",
          "difficulty": "medium",
          "startingCode": "/*\nImplement a counter utility module here.\nIt should expose:\n- increment(): increments the internal counter\n- getValue(): returns the current counter value\n\nThe internal counter should be private.\n*/\n\n// Example usage:\n// const counter = YourCounterModule();\n// counter.increment();\n// console.log(counter.getValue()); // Should log 1\n// counter.increment();\n// console.log(counter.getValue()); // Should log 2\n// console.log(counter.internalCounter); // Should be undefined or error\n",
          "solutionCode": "// Solution using IIFE for encapsulation\nconst counterModuleIIFE = (function() {\n  let count = 0; // Private internal variable\n\n  function increment() {\n    count++;\n  }\n\n  function getValue() {\n    return count;\n  }\n\n  // Expose public API\n  return {\n    increment: increment,\n    getValue: getValue\n  };\n})();\n\n// Example usage for IIFE module:\nconsole.log(\"--- IIFE Counter ---\");\ncounterModuleIIFE.increment();\nconsole.log(counterModuleIIFE.getValue()); // Expected: 1\ncounterModuleIIFE.increment();\ncounterModuleIIFE.increment();\nconsole.log(counterModuleIIFE.getValue()); // Expected: 3\n// console.log(counterModuleIIFE.count); // Undefined, demonstrating privacy\n\n\n// Solution using Modern ES Modules (conceptual, as it requires a module environment)\n/*\n// File: counter.js\nlet count = 0; // Private to the module\n\nexport function increment() {\n  count++;\n}\n\nexport function getValue() {\n  return count;\n}\n\n// File: main.js (or any other module importing this)\n// import { increment, getValue } from './counter.js';\n// increment();\n// console.log(getValue());\n// console.log(count); // ReferenceError, count is not exported\n*/\n",
          "testCases": [
            "After initializing the counter, `getValue()` should return 0.",
            "Calling `increment()` once should make `getValue()` return 1.",
            "Calling `increment()` multiple times should correctly increase the value.",
            "Attempting to access `counter.count` (or equivalent internal variable) should result in `undefined` or a `ReferenceError`."
          ],
          "hints": [
            "An IIFE creates a new function scope. Variables declared inside this scope are not accessible from the outside.",
            "To expose functionality from an IIFE, you can return an object containing references to the public methods.",
            "For ES Modules, `export` is used to make functions/variables public, while anything not exported remains private to the module."
          ],
          "tags": [
            "IIFE",
            "encapsulation",
            "modularity",
            "javascript-patterns",
            "closures",
            "es-modules"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "javascript_functions",
            "javascript_scope",
            "javascript_closures"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_function_mechanics"
          ]
        }
      ]
    }
  },
  {
    "id": "d26bdc0e-3d15-4e30-8986-f93d6425d6fe",
    "startLine": 600,
    "endLine": 699,
    "processedDate": "2025-06-17T07:19:58.741Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_iife",
          "title": "Immediately Invoked Function Expressions (IIFE)",
          "content": "An Immediately Invoked Function Expression (IIFE, pronounced \"iffy\") is a JavaScript design pattern that executes a function as soon as it is defined. It consists of two main parts:\n\n1.  **The Function Expression**: An anonymous function (or named, though less common) wrapped in parentheses `(function() { ... })`. This makes it a function expression rather than a function declaration.\n2.  **The Invocation**: The `()` at the end immediately calls the function `(function() { ... })()`. Alternatively, you can place the parentheses inside `(function() { ... }())`.\n\n### Purpose and Benefits\n\n*   **Scope Encapsulation / Data Privacy**: Variables and functions declared inside an IIFE are not accessible from the global scope, preventing them from polluting the global namespace. This helps in avoiding naming collisions, especially in applications with multiple scripts or third-party libraries.\n*   **Creating Private Variables and Closures**: IIFEs can be used to create private variables and methods that are only accessible within the IIFE's scope, similar to private members in object-oriented languages. This is often achieved in conjunction with closures.\n*   **Module Pattern**: IIFEs are fundamental to the module pattern in JavaScript, allowing you to return an object containing public methods while keeping other variables and functions private.\n*   **Aliasing Global Variables**: You can pass global objects (like `window` or `jQuery`) as arguments to an IIFE, aliasing them to shorter, more manageable names within the IIFE's scope, which can also help performance by avoiding repeated scope lookups for global variables.",
          "examples": [
            {
              "id": "example_iife_1",
              "title": "Basic IIFE for Scope Encapsulation",
              "code": "(function() {\n  const privateVar = 'This is private';\n  console.log(privateVar); // Accessible inside\n})();\n\n// console.log(privateVar); // ReferenceError: privateVar is not defined",
              "explanation": "This example shows the basic structure of an IIFE. The `privateVar` is contained within the IIFE's scope and cannot be accessed from outside, demonstrating global scope protection.",
              "language": "javascript"
            },
            {
              "id": "example_iife_2",
              "title": "IIFE with Parameters",
              "code": "(function(name) {\n  console.log(`Hello, ${name}!`);\n})('John');",
              "explanation": "This IIFE takes a parameter `name`. The value `'John'` is passed immediately upon invocation. This is useful for passing global variables or dependencies into the IIFE's private scope.",
              "language": "javascript"
            },
            {
              "id": "example_iife_3",
              "title": "IIFE as a Module Pattern",
              "code": "const counterModule = (function() {\n  let count = 0; // Private variable\n\n  function increment() {\n    count++;\n  }\n\n  function getCount() {\n    return count;\n  }\n\n  return {\n    increment: increment,\n    getCount: getCount\n  };\n})();\n\ncounterModule.increment();\nconsole.log(counterModule.getCount()); // 1\ncounterModule.increment();\nconsole.log(counterModule.getCount()); // 2\n// console.log(counterModule.count); // undefined (private)",
              "explanation": "This example demonstrates how an IIFE can be used to implement the Module Pattern, creating a private `count` variable and exposing only `increment` and `getCount` methods, providing encapsulation.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_iife_1",
            "question_iife_2",
            "question_iife_3",
            "question_iife_4",
            "question_iife_5"
          ],
          "relatedTasks": [
            "task_iife_1"
          ],
          "tags": [
            "JavaScript",
            "Functions",
            "Scope",
            "IIFE",
            "Closures",
            "Module Pattern"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "javascript_scope",
            "javascript_closures"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "module_pattern",
            "frontend_architecture"
          ]
        },
        {
          "id": "theory_function_context_this",
          "title": "Function Context and 'this'",
          "content": "The `this` keyword in JavaScript is a special identifier that refers to the context in which a function is executed. Its value is not fixed but is determined dynamically by how a function is called, also known as the \"invocation pattern\" or \"calling context\". Understanding `this` is crucial for writing correct and predictable JavaScript code, especially when dealing with objects, methods, and event handling.\n\n### Rules for `this` Binding\n\n1.  **Global Context (Default Binding)**:\n    *   When a function is called without any explicit object, `this` refers to the global object (`window` in browsers, `global` in Node.js) in non-strict mode.\n    *   In strict mode (`'use strict';`), `this` will be `undefined` when a function is called without an owning object.\n\n2.  **Method Context (Implicit Binding)**:\n    *   When a function is called as a method of an object (i.e., `object.method()`), `this` refers to the object on which the method was called.\n\n3.  **Event Handler Context**:\n    *   When a function is used as an event handler (e.g., with `addEventListener`), `this` typically refers to the DOM element that the listener is attached to, or the element that triggered the event.\n\n4.  **Arrow Functions (Lexical Binding)**:\n    *   Arrow functions do *not* have their own `this` binding. Instead, `this` inside an arrow function is lexically scoped; it inherits the `this` value from the enclosing execution context (i.e., where the arrow function was defined, not where it was called). This makes them very useful for preserving the `this` context from the surrounding code.\n\n5.  **Explicit Binding (`call`, `apply`, `bind`)**: These methods allow you to explicitly set the value of `this` for a function call. (See the \"Function Borrowing\" theory block for details).\n\n6.  **Constructor Context (`new` binding)**:\n    *   When a function is called with the `new` keyword (as a constructor), `this` refers to the newly created instance of the object.",
          "examples": [
            {
              "id": "example_this_1",
              "title": "'this' in Methods (Implicit Binding)",
              "code": "const user = {\n  name: 'John',\n  greet() {\n    console.log(`Hello, ${this.name}!`);\n  }\n};\nuser.greet(); // Hello, John!\n\nconst greetFunction = user.greet;\ngreetFunction(); // Hello, undefined! (or Hello, ! in browser non-strict mode as 'this' is window)",
              "explanation": "When `greet` is called as a method of `user` (`user.greet()`), `this` inside `greet` refers to `user`. However, when `greet` is assigned to a new variable `greetFunction` and then called directly (`greetFunction()`), `this` loses its context and defaults to the global object (or `undefined` in strict mode), as it's no longer invoked as a method of `user`.",
              "language": "javascript"
            },
            {
              "id": "example_this_2",
              "title": "'this' in Event Handlers (DOM Context)",
              "code": "const button = document.createElement('button');\nbutton.textContent = 'Click Me';\ndocument.body.appendChild(button);\n\nbutton.addEventListener('click', function() {\n  console.log(this.textContent); // refers to the button element ('Click Me')\n});",
              "explanation": "In a traditional function expression used as an event listener, `this` refers to the DOM element on which the event listener was attached (the `button` in this case).",
              "language": "javascript"
            },
            {
              "id": "example_this_3",
              "title": "'this' in Arrow Functions (Lexical Binding)",
              "code": "const button = document.createElement('button');\nbutton.textContent = 'Click Me';\ndocument.body.appendChild(button);\n\nconst myObject = {\n  name: 'Outer Scope',\n  attachListener: function() {\n    // 'this' here refers to myObject\n    button.addEventListener('click', () => {\n      // 'this' here is lexically bound to 'this' of attachListener, which is myObject\n      console.log(`Button clicked. Context: ${this.name}`); \n    });\n  }\n};\n\nmyObject.attachListener();\n// When button is clicked, it logs: 'Button clicked. Context: Outer Scope'",
              "explanation": "Arrow functions do not bind their own `this`. Instead, they inherit `this` from their enclosing lexical scope. In this example, the `this` inside the arrow function `() => { ... }` refers to the `this` of the `attachListener` method, which is `myObject`, not the `button` element.",
              "language": "javascript"
            },
            {
              "id": "example_this_4",
              "title": "'this' in Global Context and Strict Mode",
              "code": "// Non-strict mode (default for browser scripts unless explicitly set)\nfunction showThisNonStrict() {\n  console.log(this); // In browsers, typically window object\n}\nshowThisNonStrict();\n\n// Strict mode\n'use strict';\nfunction showThisStrict() {\n  console.log(this); // undefined\n}\nshowThisStrict();",
              "explanation": "In non-strict mode, `this` defaults to the global object (`window` in browsers) when a function is called without an explicit context. In strict mode, `this` is `undefined` in such standalone function calls, preventing accidental global variable creation.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_this_1",
            "question_this_2",
            "question_this_3",
            "question_this_4",
            "question_this_5",
            "question_this_6",
            "question_this_7"
          ],
          "relatedTasks": [
            "task_this_1"
          ],
          "tags": [
            "JavaScript",
            "Functions",
            "Context",
            "this",
            "Arrow Functions",
            "Scope"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "javascript_objects",
            "javascript_scope"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "object_oriented_js",
            "event_handling",
            "react_components"
          ]
        },
        {
          "id": "theory_function_borrowing",
          "title": "Function Borrowing with call, apply, and bind",
          "content": "Function borrowing is a technique in JavaScript where a function (or method) is called with a `this` context that is different from its original owner. This is achieved using the `call`, `apply`, and `bind` methods, which are all part of `Function.prototype`. These methods are essential for controlling the `this` keyword's value and are commonly used for tasks like explicit context binding, array manipulation, and creating new functions with pre-set contexts.\n\n### 1. `call()`\n*   **Purpose**: Invokes a function immediately with a specified `this` value and arguments provided individually.\n*   **Syntax**: `func.call(thisArg, arg1, arg2, ...)`\n*   **Characteristics**: Executes the function directly. Arguments are passed as a comma-separated list.\n\n### 2. `apply()`\n*   **Purpose**: Invokes a function immediately with a specified `this` value and arguments provided as an array (or an array-like object).\n*   **Syntax**: `func.apply(thisArg, [argsArray])`\n*   **Characteristics**: Executes the function directly. Arguments are passed as a single array.\n*   **Common Use Case**: When you have an array of arguments or when you don't know the number of arguments beforehand (e.g., `Math.max.apply(null, numbersArray)`).\n\n### 3. `bind()`\n*   **Purpose**: Returns a *new function* (a \"bound function\") with a specified `this` value and, optionally, initial arguments. The original function is *not* executed immediately.\n*   **Syntax**: `func.bind(thisArg, arg1, arg2, ...)`\n*   **Characteristics**: Does not execute the function. Creates a new function whose `this` is permanently bound to `thisArg` (and whose initial arguments are permanently bound as well, if provided). The bound function can then be called later.\n*   **Common Use Case**: Event listeners, `setTimeout`/`setInterval` callbacks, or when passing a function to another function that might lose its `this` context.",
          "examples": [
            {
              "id": "example_borrowing_1",
              "title": "Function Borrowing with call()",
              "code": "const person1 = {\n  fullName: function() {\n    return this.firstName + ' ' + this.lastName;\n  }\n};\n\nconst person2 = {\n  firstName: 'John',\n  lastName: 'Doe'\n};\n\nconst person3 = {\n  firstName: 'Jane',\n  lastName: 'Smith'\n};\n\n// person1's fullName method is called with person2 as its 'this' context\nconsole.log(person1.fullName.call(person2)); // \"John Doe\"\nconsole.log(person1.fullName.call(person3)); // \"Jane Smith\"\n\n// Example with arguments\nfunction greet(greeting, punctuation) {\n  return `${greeting}, ${this.firstName} ${this.lastName}${punctuation}`;\n}\n\nconsole.log(greet.call(person2, 'Hello', '!')); // \"Hello, John Doe!\"",
              "explanation": "`call()` immediately invokes the `fullName` function, setting `this` to `person2` (or `person3`). When arguments are needed, they are passed individually after the `thisArg`.",
              "language": "javascript"
            },
            {
              "id": "example_borrowing_2",
              "title": "Function Borrowing with apply()",
              "code": "const person1 = {\n  fullName: function() {\n    return this.firstName + ' ' + this.lastName;\n  }\n};\n\nconst person2 = {\n  firstName: 'John',\n  lastName: 'Doe'\n};\n\n// person1's fullName method is called with person2 as its 'this' context\nconsole.log(person1.fullName.apply(person2)); // \"John Doe\"\n\n// Example with arguments (as an array)\nfunction showDetails(age, city) {\n  return `${this.firstName} is ${age} years old and lives in ${city}.`;\n}\n\nconst detailsArgs = [30, 'New York'];\nconsole.log(showDetails.apply(person2, detailsArgs)); // \"John is 30 years old and lives in New York.\"",
              "explanation": "Similar to `call()`, `apply()` immediately invokes the function and sets `this`. The key difference is that arguments are passed as an array. This is useful when the number of arguments is dynamic or already in an array format.",
              "language": "javascript"
            },
            {
              "id": "example_borrowing_3",
              "title": "Function Borrowing with bind()",
              "code": "const person1 = {\n  fullName: function() {\n    return this.firstName + ' ' + this.lastName;\n  }\n};\n\nconst person2 = {\n  firstName: 'John',\n  lastName: 'Doe'\n};\n\n// bind() returns a NEW function, does not execute immediately\nconst getJohnFullName = person1.fullName.bind(person2);\nconsole.log(getJohnFullName()); // \"John Doe\"\n\n// Example: Binding 'this' for an event listener\nconst button = document.createElement('button');\nbutton.textContent = 'Click Me';\ndocument.body.appendChild(button);\n\nconst handlerObject = {\n  name: 'My Handler',\n  handleClick: function() {\n    console.log(`${this.name} handled the click.`);\n    console.log(`Event target: ${event.target.textContent}`); // 'this' is handlerObject, not button\n  }\n};\n\n// Without bind, 'this' in handleClick would refer to the button\n// With bind, 'this' in handleClick will always refer to handlerObject\nbutton.addEventListener('click', handlerObject.handleClick.bind(handlerObject));\n\n// When button is clicked, it logs:\n// My Handler handled the click.\n// Event target: Click Me",
              "explanation": "`bind()` creates a new function (`getJohnFullName`) where `this` is permanently set to `person2`. This bound function can be called later without losing its context. The event listener example shows its practical use in ensuring `this` refers to the `handlerObject` even when the function is invoked by the DOM.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_borrowing_1",
            "question_borrowing_2",
            "question_borrowing_3",
            "question_borrowing_4",
            "question_borrowing_5",
            "question_borrowing_6"
          ],
          "relatedTasks": [
            "task_borrowing_1"
          ],
          "tags": [
            "JavaScript",
            "Functions",
            "this",
            "Call",
            "Apply",
            "Bind",
            "Context"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "javascript_objects",
            "theory_function_context_this"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_event_handling",
            "higher_order_functions"
          ]
        },
        {
          "id": "theory_currying",
          "title": "Currying",
          "content": "Currying is a functional programming technique that transforms a function that takes multiple arguments into a sequence of functions, each taking a single argument. This transformation allows for partial application of a function, meaning you can supply a subset of arguments and get a new function that expects the remaining arguments.\n\n### How Currying Works\n\nInstead of a function `f(a, b, c)` that takes three arguments at once, currying transforms it into `f(a)(b)(c)`. Each call returns a new function until all arguments are provided, at which point the final result is computed.\n\n### Benefits of Currying\n\n1.  **Reusability and Composability**: Curried functions are highly reusable. By partially applying arguments, you can create specialized versions of a function without rewriting it.\n2.  **Easier Function Composition**: Currying makes it easier to compose functions, as each function in the chain operates on a single input and produces a single output, fitting nicely into a pipeline of operations.\n3.  **Delayed Execution / Partial Application**: You can supply arguments incrementally over time, which is useful in scenarios like event handling or configuration, where not all data is available at once.\n4.  **Reduced Errors**: By ensuring functions only take one argument at a time, it can lead to more predictable and testable code.\n\n### Relationship with Partial Application\n\nCurrying is a form of partial application, but not all partial applications are currying. Currying strictly transforms a function to take one argument at a time. Partial application, more broadly, refers to fixing a number of arguments to a function, producing another function that takes fewer arguments, but not necessarily one at a time.",
          "examples": [
            {
              "id": "example_currying_1",
              "title": "Basic Curried Function",
              "code": "// Regular function\nfunction add(a, b, c) {\n  return a + b + c;\n}\n\n// Curried version\nfunction curriedAdd(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    };\n  };\n}\n\nconsole.log(add(1, 2, 3));        // 6\nconsole.log(curriedAdd(1)(2)(3)); // 6",
              "explanation": "This example shows the transformation from a regular `add` function to its curried equivalent `curriedAdd`. Instead of calling `curriedAdd(1, 2, 3)`, you call it sequentially: `curriedAdd(1)` returns a function, which you then call with `(2)`, which returns another function, finally called with `(3)` to get the result.",
              "language": "javascript"
            },
            {
              "id": "example_currying_2",
              "title": "Practical Currying Example: Discount Calculator",
              "code": "function discount(price) {\n  return function(percent) {\n    return price * (1 - percent / 100);\n  };\n}\n\n// Create specialized discount functions\nconst tenDollarItem = discount(10);\nconst twentyDollarItem = discount(20);\n\n// Apply different percentages\nconsole.log(tenDollarItem(20));  // 8 (20% off $10)\nconsole.log(tenDollarItem(50));  // 5 (50% off $10)\nconsole.log(twentyDollarItem(10)); // 18 (10% off $20)",
              "explanation": "This demonstrates a practical use case for currying. The `discount` function is curried, allowing you to first specify the `price` and then create new, specialized functions (like `tenDollarItem`) that are pre-configured with that price. You then apply different discount `percent` values to these specialized functions, showcasing reusability and partial application.",
              "language": "javascript"
            },
            {
              "id": "example_currying_3",
              "title": "Creating a Generic Curry Helper",
              "code": "function curry(func) {\n  return function curried(...args) {\n    if (args.length >= func.length) {\n      return func.apply(this, args);\n    } else {\n      return function(...args2) {\n        return curried.apply(this, args.concat(args2));\n      }\n    }\n  };\n}\n\nconst add = (a, b, c) => a + b + c;\nconst curriedAdd = curry(add);\n\nconsole.log(curriedAdd(1)(2)(3));    // 6\nconsole.log(curriedAdd(1, 2)(3));   // 6\nconsole.log(curriedAdd(1)(2, 3));   // 6\nconsole.log(curriedAdd(1, 2, 3));   // 6",
              "explanation": "This `curry` helper function takes any function `func` and returns its curried version. It recursively collects arguments until all expected arguments (based on `func.length`) are provided, then it executes the original function. This makes it easy to curry any multi-argument function.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_currying_1",
            "question_currying_2",
            "question_currying_3",
            "question_currying_4",
            "question_currying_5"
          ],
          "relatedTasks": [
            "task_currying_1"
          ],
          "tags": [
            "JavaScript",
            "Functional Programming",
            "Currying",
            "Higher-Order Functions",
            "Partial Application"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "javascript_higher_order_functions",
            "javascript_closures"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "functional_programming",
            "redux_middleware"
          ]
        },
        {
          "id": "theory_memoization",
          "title": "Memoization",
          "content": "Memoization is an optimization technique used primarily to speed up computer programs by caching the results of expensive function calls and returning the cached result when the same inputs occur again. It's a form of caching specifically for function results.\n\n### How Memoization Works\n\nA memoized function typically maintains a cache (often an object or Map) where it stores the results of previous computations. When the function is called:\n\n1.  It first checks if the arguments it received have already been processed and their result stored in the cache.\n2.  If a result for those arguments is found in the cache, it returns the cached result immediately, avoiding re-computation.\n3.  If the arguments are new, the function performs the computation, stores the result in the cache associated with these arguments, and then returns the result.\n\n### When to Use Memoization\n\nMmization is most effective for:\n\n*   **Pure Functions**: Functions that always return the same output for the same input and have no side effects.\n*   **Expensive Computations**: Functions whose execution takes a significant amount of time or resources (e.g., recursive algorithms like Fibonacci, complex calculations, API calls).\n*   **Functions with Frequent Calls to Same Inputs**: If a function is called many times with the same arguments, memoization will yield significant performance benefits.\n\n### Trade-offs and Considerations\n\n*   **Memory Overhead**: Storing results in a cache consumes memory. For functions with a very large number of unique inputs, the cache can grow excessively large.\n*   **Key Generation**: The key used for caching must uniquely represent the function's arguments. For primitive arguments, `JSON.stringify` works, but for objects or complex data structures, a more robust serialization or hashing might be needed to ensure correct caching and avoid reference issues.\n*   **Side Effects**: Memoization should generally be applied only to pure functions. If a function has side effects (e.g., modifies external state, performs network requests), memoizing it might lead to unexpected behavior because the side effects won't occur on subsequent calls from cache.",
          "examples": [
            {
              "id": "example_memoization_1",
              "title": "Basic Memoization Implementation",
              "code": "function memoize(fn) {\n  const cache = {};\n  return function(...args) {\n    const key = JSON.stringify(args); // Simple key for primitive args\n    if (cache[key]) {\n      console.log('Fetching from cache for key:', key);\n      return cache[key];\n    } else {\n      console.log('Calculating result for key:', key);\n      const result = fn.apply(this, args); // Use apply to preserve 'this' context if needed\n      cache[key] = result;\n      return result;\n    }\n  };\n}\n\n// An expensive, pure function (e.g., Fibonacci)\nfunction fibonacci(n) {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nconst memoizedFibonacci = memoize(fibonacci);\n\nconsole.log(memoizedFibonacci(10)); // Calculates, then caches\nconsole.log(memoizedFibonacci(10)); // Fetches from cache\nconsole.log(memoizedFibonacci(5));  // Calculates, then caches\nconsole.log(memoizedFibonacci(5));  // Fetches from cache\nconsole.log(memoizedFibonacci(10)); // Fetches from cache again",
              "explanation": "This example shows a generic `memoize` function that wraps any given function `fn`. It uses a simple object `cache` and `JSON.stringify(args)` to create a unique key for each set of arguments. The `fibonacci` function, which is computationally expensive due to recursion, is then memoized. Subsequent calls with the same input `n` retrieve the result from the cache, significantly speeding up execution.",
              "language": "javascript"
            },
            {
              "id": "example_memoization_2",
              "title": "Memoization with Complex Arguments (Considerations)",
              "code": "function memoizeComplex(fn) {\n  const cache = new Map(); // Using Map for better key handling (e.g., objects)\n  return function(...args) {\n    // A more robust key generation for complex scenarios might involve deep hashing\n    // For this example, we'll keep it simple for demonstration.\n    const key = JSON.stringify(args);\n\n    if (cache.has(key)) {\n      console.log('Fetching from cache (complex) for key:', key);\n      return cache.get(key);\n    } else {\n      console.log('Calculating result (complex) for key:', key);\n      const result = fn.apply(this, args);\n      cache.set(key, result);\n      return result;\n    }\n  };\n}\n\nfunction processData(data, config) {\n  // Simulate a complex operation that depends on data content and config\n  // For real-world, this would be CPU-bound or I/O-bound\n  console.log(`Processing data ${data.id} with config ${config.type}`);\n  return data.value * config.multiplier;\n}\n\nconst memoizedProcessData = memoizeComplex(processData);\n\nconst obj1 = { id: 1, value: 10 };\nconst obj2 = { id: 2, value: 20 };\nconst conf1 = { type: 'A', multiplier: 2 };\nconst conf2 = { type: 'B', multiplier: 3 };\n\nconsole.log(memoizedProcessData(obj1, conf1)); // Calculates (20)\nconsole.log(memoizedProcessData(obj1, conf1)); // Fetches from cache (20)\nconsole.log(memoizedProcessData(obj2, conf1)); // Calculates (40)\nconsole.log(memoizedProcessData(obj1, conf2)); // Calculates (30)\n\n// Note: JSON.stringify for objects works only if object structure and order of keys are consistent.\n// For true object comparison, a more advanced hashing or WeakMap approach would be needed.\nconst obj1_clone = { value: 10, id: 1 }; // Key might differ due to property order\nconsole.log(memoizedProcessData(obj1_clone, conf1)); // Calculates if key differs, otherwise cached\n",
              "explanation": "This example highlights the complexity of key generation for memoization when arguments are objects. While `JSON.stringify` works for simple objects or consistent structures, for robust object comparison, deep equality checks or a different caching strategy (like using a `WeakMap` if arguments are object references and you need garbage collection) might be required. It also shows applying memoization to a function with multiple, non-primitive arguments.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_memoization_1",
            "question_memoization_2",
            "question_memoization_3",
            "question_memoization_4",
            "question_memoization_5"
          ],
          "relatedTasks": [
            "task_memoization_1"
          ],
          "tags": [
            "JavaScript",
            "Optimization",
            "Caching",
            "Memoization",
            "Performance",
            "Pure Functions",
            "Higher-Order Functions"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "javascript_closures",
            "javascript_objects"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "performance_optimization",
            "functional_programming",
            "react_performance_optimization"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_iife_1",
          "topic": "Immediately Invoked Function Expressions (IIFE)",
          "level": "easy",
          "type": "flashcard",
          "question": "What does IIFE stand for?",
          "answer": "Immediately Invoked Function Expression",
          "analysisPoints": [
            "Basic recall of the acronym."
          ],
          "keyConcepts": [
            "IIFE"
          ],
          "evaluationCriteria": [
            "Memorization of terminology."
          ],
          "example": null,
          "tags": [
            "IIFE",
            "JavaScript",
            "Terminology"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_iife_2",
          "topic": "Immediately Invoked Function Expressions (IIFE)",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is the primary benefit of using an IIFE in JavaScript?",
          "answer": "To prevent variable pollution in the global scope.",
          "options": [
            "To prevent variable pollution in the global scope.",
            "To make asynchronous calls synchronous.",
            "To create new classes dynamically.",
            "To enable server-side rendering."
          ],
          "analysisPoints": [
            "Understanding the core purpose of IIFEs.",
            "Distinguishing IIFEs from other JavaScript features."
          ],
          "keyConcepts": [
            "IIFE",
            "Scope",
            "Global Scope",
            "Encapsulation"
          ],
          "evaluationCriteria": [
            "Ability to identify the main advantage of IIFEs.",
            "Knowledge of scope management in JavaScript."
          ],
          "example": "IIFEs encapsulate variables within their own function scope, preventing them from being accidentally declared in or overwriting variables in the global scope.\n\n```javascript\n(function() {\n  const tempVar = 'I am private';\n  // console.log(window.tempVar); // undefined\n})();\n// console.log(tempVar); // ReferenceError\n```",
          "tags": [
            "IIFE",
            "Scope",
            "Global Scope",
            "Encapsulation"
          ],
          "prerequisites": [
            "javascript_scope"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_iife_3",
          "topic": "Immediately Invoked Function Expressions (IIFE)",
          "level": "medium",
          "type": "open",
          "question": "Explain how an IIFE can be used to achieve data privacy in JavaScript. Provide a simple code example.",
          "answer": "An IIFE creates its own private scope. Variables and functions declared inside the IIFE are confined to that scope and are not directly accessible from the outside. This prevents them from polluting the global namespace and allows for the creation of 'private' members, similar to private properties in object-oriented programming. If you need to expose certain functionalities, you can return an object containing public methods, which then form a closure over the private variables.\n\n```javascript\nconst counter = (function() {\n  let privateCount = 0; // This variable is private to the IIFE\n\n  function changeBy(val) {\n    privateCount += val;\n  }\n\n  return {\n    increment: function() {\n      changeBy(1);\n    },\n    decrement: function() {\n      changeBy(-1);\n    },\n    value: function() {\n      return privateCount;\n    }\n  };\n})();\n\nconsole.log(counter.value()); // 0\ncounter.increment();\ncounter.increment();\nconsole.log(counter.value()); // 2\n// console.log(counter.privateCount); // undefined - cannot access privateCount directly\n```",
          "analysisPoints": [
            "Ability to explain the concept of data privacy through IIFEs.",
            "Demonstrates understanding of closures in conjunction with IIFEs.",
            "Provides a correct and relevant code example."
          ],
          "keyConcepts": [
            "IIFE",
            "Scope",
            "Data Privacy",
            "Closures",
            "Module Pattern"
          ],
          "evaluationCriteria": [
            "Clarity of explanation.",
            "Correctness of code example.",
            "Identification of related concepts like closures."
          ],
          "example": null,
          "tags": [
            "IIFE",
            "Data Privacy",
            "Closures",
            "Module Pattern"
          ],
          "prerequisites": [
            "javascript_scope",
            "javascript_closures"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_iife_4",
          "topic": "Immediately Invoked Function Expressions (IIFE)",
          "level": "hard",
          "type": "code",
          "question": "Implement a simple module using an IIFE that manages a collection of items. The module should expose methods to `addItem(item)`, `removeItem(item)`, and `getAllItems()`, but the internal array storing items should remain private.",
          "answer": "```javascript\nconst itemManager = (function() {\n  const items = []; // Private array\n\n  return {\n    addItem: function(item) {\n      if (item) {\n        items.push(item);\n        console.log(`Added: ${item}`);\n      }\n    },\n    removeItem: function(item) {\n      const index = items.indexOf(item);\n      if (index > -1) {\n        items.splice(index, 1);\n        console.log(`Removed: ${item}`);\n      }\n    },\n    getAllItems: function() {\n      // Return a copy to prevent external modification of the private array\n      return [...items]; \n    },\n    getItemCount: function() {\n      return items.length;\n    }\n  };\n})();\n\n// Test cases\nitemManager.addItem('Apple');\nitemManager.addItem('Banana');\nconsole.log('All items:', itemManager.getAllItems()); // Output: [ 'Apple', 'Banana' ]\nconsole.log('Item count:', itemManager.getItemCount()); // Output: 2\n\nitemManager.removeItem('Apple');\nconsole.log('All items:', itemManager.getAllItems()); // Output: [ 'Banana' ]\n\nitemManager.addItem('Orange');\nconsole.log('All items:', itemManager.getAllItems()); // Output: [ 'Banana', 'Orange' ]\n\n// Attempt to modify private array (should fail if getAllItems returns a copy)\nconst currentItems = itemManager.getAllItems();\ncurrentItems.push('Grape'); // Modifies the copy, not the original\nconsole.log('All items after external push:', itemManager.getAllItems()); // Output: [ 'Banana', 'Orange' ] (Grape not present)\n```",
          "analysisPoints": [
            "Correct use of IIFE for encapsulation.",
            "Proper implementation of public methods.",
            "Ensuring the internal array remains private (e.g., returning a copy of the array).",
            "Handling basic logic for add/remove operations."
          ],
          "keyConcepts": [
            "IIFE",
            "Module Pattern",
            "Encapsulation",
            "Data Privacy",
            "Closures",
            "Array Methods"
          ],
          "evaluationCriteria": [
            "Functional correctness.",
            "Adherence to the IIFE pattern.",
            "Effective data encapsulation.",
            "Robustness against external modification (by returning a copy)."
          ],
          "example": null,
          "tags": [
            "IIFE",
            "Module Pattern",
            "Encapsulation",
            "Coding Challenge"
          ],
          "prerequisites": [
            "javascript_arrays",
            "javascript_functions",
            "javascript_scope"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_iife_5",
          "topic": "Immediately Invoked Function Expressions (IIFE)",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main benefit of using an IIFE regarding global variables?",
          "answer": "It prevents pollution of the global namespace.",
          "analysisPoints": [
            "Core understanding of IIFE's scope benefit."
          ],
          "keyConcepts": [
            "IIFE",
            "Global Scope",
            "Pollution"
          ],
          "evaluationCriteria": [
            "Quick recall of a key benefit."
          ],
          "example": null,
          "tags": [
            "IIFE",
            "Scope",
            "Global Scope"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_this_1",
          "topic": "Function Context and 'this'",
          "level": "easy",
          "type": "flashcard",
          "question": "In JavaScript, what determines the value of `this` inside a regular function?",
          "answer": "The way the function is called (its invocation context).",
          "analysisPoints": [
            "Understanding the dynamic nature of `this`."
          ],
          "keyConcepts": [
            "this",
            "Context",
            "Invocation"
          ],
          "evaluationCriteria": [
            "Basic recall of `this` behavior."
          ],
          "example": null,
          "tags": [
            "this",
            "JavaScript",
            "Context"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_this_2",
          "topic": "Function Context and 'this'",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following code snippet:\n\n```javascript\nconst person = {\n  name: 'Alice',\n  greet: function() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n};\n\nconst sayHello = person.greet;\nsayHello();\n```\n\nWhat will be the output of `sayHello()`?",
          "answer": "Hello, my name is undefined",
          "options": [
            "Hello, my name is Alice",
            "Hello, my name is undefined",
            "ReferenceError: name is not defined",
            "TypeError: this.name is not a function"
          ],
          "analysisPoints": [
            "Understanding the loss of `this` context when a method is assigned to a new variable and called without an explicit receiver.",
            "Knowing that in non-strict mode, `this` defaults to global object, and `name` might not exist there, resulting in `undefined`.",
            "Recognizing the difference between implicit and default binding."
          ],
          "keyConcepts": [
            "this",
            "Implicit Binding",
            "Default Binding",
            "Global Object",
            "Strict Mode"
          ],
          "evaluationCriteria": [
            "Ability to predict `this` value in a specific scenario.",
            "Understanding of method detachment and its effect on `this`."
          ],
          "example": "When `person.greet` is called directly as `person.greet()`, `this` refers to `person`. However, when `person.greet` is assigned to `sayHello` and then called as a standalone function `sayHello()`, `this` falls back to the default binding. In non-strict mode (common in browser scripts by default), `this` would be the global object (`window`), and `window.name` is likely `undefined` or an empty string. In strict mode, `this` would be `undefined`, leading to an error if attempting `undefined.name` directly, but `console.log` would output 'undefined'.",
          "tags": [
            "this",
            "Context",
            "JavaScript",
            "Functions"
          ],
          "prerequisites": [
            "javascript_objects",
            "javascript_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_3",
          "topic": "Function Context and 'this'",
          "level": "medium",
          "type": "mcq",
          "question": "What is the key difference in `this` binding between a regular function expression and an arrow function?",
          "answer": "Arrow functions do not have their own 'this' binding; they inherit 'this' from their lexical (enclosing) scope.",
          "options": [
            "Arrow functions do not have their own 'this' binding; they inherit 'this' from their lexical (enclosing) scope.",
            "Regular functions always bind 'this' to the global object, while arrow functions bind 'this' to the local scope.",
            "Arrow functions bind 'this' to the function's arguments, while regular functions bind it to the function itself.",
            "There is no difference; 'this' behaves identically in both."
          ],
          "analysisPoints": [
            "Understanding the lexical `this` binding of arrow functions.",
            "Contrasting it with the dynamic `this` binding of regular functions.",
            "Debunking common misconceptions about `this` behavior."
          ],
          "keyConcepts": [
            "this",
            "Arrow Functions",
            "Lexical Scope",
            "Dynamic Binding",
            "Function Expression"
          ],
          "evaluationCriteria": [
            "Accurate understanding of arrow function `this`.",
            "Ability to differentiate `this` rules for different function types."
          ],
          "example": "```javascript\nconst obj = {\n  value: 42,\n  regularFn: function() {\n    console.log(this.value); // 'this' refers to obj (dynamic binding)\n\n    const arrowFn = () => {\n      console.log(this.value); // 'this' refers to obj (lexical binding, inherits from regularFn's 'this')\n    };\n    arrowFn();\n  },\n  arrowFnDirect: () => {\n    console.log(this.value); // 'this' refers to the global object (window/undefined), as it inherits from the global lexical scope\n  }\n};\n\nobj.regularFn(); // Output: 42, 42\nobj.arrowFnDirect(); // Output: undefined (in strict mode, or depends on global `value` in non-strict)",
          "tags": [
            "this",
            "Arrow Functions",
            "Lexical Scope"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_scope"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_4",
          "topic": "Function Context and 'this'",
          "level": "hard",
          "type": "code",
          "question": "Consider the following HTML and JavaScript. Predict the output of clicking the button twice, and explain why. Then, modify the JavaScript using an `arrow function` or `bind` to ensure that `this.clicks` correctly increments the `clicks` property of the `counter` object.",
          "answer": "Original Output and Explanation:\nWhen the button is clicked the first time, the original `console.log(this.clicks)` will output `undefined`. The second click will also output `undefined`.\n\n**Explanation**: In the original code, the `function() { ... }` used as an event listener has its `this` bound to the `button` DOM element that triggered the event, not the `counter` object. Since the `button` element does not have a `clicks` property, `this.clicks` (i.e., `button.clicks`) will be `undefined`.\n\nModified JavaScript using `bind` (or arrow function below):\n\n```javascript\nconst button = document.createElement('button');\nbutton.textContent = 'Click Me';\ndocument.body.appendChild(button);\n\nconst counter = {\n  clicks: 0,\n  increment: function() {\n    this.clicks++;\n    console.log(`Clicks: ${this.clicks}`);\n  }\n};\n\n// Using .bind(this)\nbutton.addEventListener('click', counter.increment.bind(counter));\n\n// Alternatively, using an arrow function to preserve lexical 'this'\n// button.addEventListener('click', () => {\n//   counter.increment(); // Directly call counter.increment without losing context\n// });\n\n// Or, if increment itself was an arrow function *inside* a method of counter:\n// const counter = {\n//   clicks: 0,\n//   setupListener: function() {\n//     button.addEventListener('click', () => {\n//       this.clicks++; // 'this' here refers to 'counter' due to lexical scoping\n//       console.log(`Clicks: ${this.clicks}`);\n//     });\n//   }\n// };\n// counter.setupListener();\n```\n\n**Modified Output**:\nFirst click: `Clicks: 1`\nSecond click: `Clicks: 2`\n\n**Explanation of Modification**:\n*   **`bind(counter)`**: The `bind` method creates a new function where `this` is permanently set to `counter`. When the event listener fires, the bound function is called, and `this` inside `increment` correctly refers to the `counter` object, allowing `counter.clicks` to be incremented.\n*   **Arrow Function (direct call)**: By using `() => { counter.increment(); }`, we explicitly call `counter.increment()`. In this case, `increment` is called as a method of `counter`, so `this` inside `increment` will correctly refer to `counter`.\n*   **Arrow Function (lexical `this` within `setupListener`)**: If the arrow function is defined within another method of `counter` (e.g., `setupListener`), `this` inside the arrow function will lexically inherit `this` from `setupListener`, which would be `counter` itself.",
          "analysisPoints": [
            "Diagnosing `this` context issues in event handlers.",
            "Proposing and implementing solutions using `bind` or arrow functions.",
            "Explaining the mechanism of `this` binding in both original and corrected code."
          ],
          "keyConcepts": [
            "this",
            "Event Handlers",
            "Bind",
            "Arrow Functions",
            "Lexical Scope",
            "Implicit Binding",
            "Default Binding"
          ],
          "evaluationCriteria": [
            "Correct identification of the problem.",
            "Effective application of `bind` or arrow functions.",
            "Clear and accurate explanation of `this` behavior."
          ],
          "example": null,
          "tags": [
            "this",
            "Event Handling",
            "Bind",
            "Arrow Functions",
            "Coding Challenge"
          ],
          "prerequisites": [
            "theory_function_context_this",
            "theory_function_borrowing",
            "dom_events"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_5",
          "topic": "Function Context and 'this'",
          "level": "easy",
          "type": "flashcard",
          "question": "When a function is called as a method of an object (e.g., `obj.method()`), what does `this` refer to inside that method?",
          "answer": "The object itself (`obj`).",
          "analysisPoints": [
            "Recall of implicit binding rule."
          ],
          "keyConcepts": [
            "this",
            "Implicit Binding",
            "Object Method"
          ],
          "evaluationCriteria": [
            "Basic recall of `this` behavior."
          ],
          "example": null,
          "tags": [
            "this",
            "Context",
            "Objects"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_this_6",
          "topic": "Function Context and 'this'",
          "level": "medium",
          "type": "open",
          "question": "Describe a scenario where using an arrow function for a callback (e.g., in `setTimeout` or `addEventListener`) is particularly beneficial regarding the `this` keyword. Provide a short code example.",
          "answer": "Arrow functions are particularly beneficial for callbacks in scenarios where you want to preserve the `this` context from the surrounding (lexical) scope. Traditional function expressions create their own `this` context, which often defaults to the global object or the event target, leading to `this` being different from what's expected.\n\n**Scenario**: Inside an object method, if you have an asynchronous operation (like `setTimeout`) or an event listener callback, and you need to access properties of the *outer* object using `this`.\n\n**Example**: Without arrow function, `this.count` would be `undefined`.\n\n```javascript\nclass Counter {\n  constructor() {\n    this.count = 0;\n    this.button = document.createElement('button');\n    this.button.textContent = 'Increment';\n    document.body.appendChild(this.button);\n\n    // Using arrow function: 'this' inside the callback refers to the Counter instance\n    this.button.addEventListener('click', () => {\n      this.count++;\n      console.log(`Count: ${this.count}`);\n    });\n\n    // If it were a regular function:\n    // this.button.addEventListener('click', function() {\n    //   console.log(this); // 'this' would be the button element\n    //   // console.log(this.count); // undefined, as button doesn't have a 'count' property\n    // });\n  }\n}\n\nconst myCounter = new Counter();\n```",
          "analysisPoints": [
            "Identifies a common problem with `this` in callbacks.",
            "Explains why arrow functions solve this problem (lexical binding).",
            "Provides a clear and concise code example demonstrating the benefit."
          ],
          "keyConcepts": [
            "this",
            "Arrow Functions",
            "Lexical Scope",
            "Callbacks",
            "Event Handling",
            "setTimeout"
          ],
          "evaluationCriteria": [
            "Clarity of explanation.",
            "Relevance of the scenario.",
            "Correctness and effectiveness of the code example."
          ],
          "example": null,
          "tags": [
            "this",
            "Arrow Functions",
            "Callbacks",
            "Event Handling",
            "Asynchronous JavaScript"
          ],
          "prerequisites": [
            "theory_function_context_this"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_7",
          "topic": "Function Context and 'this'",
          "level": "hard",
          "type": "code",
          "question": "Analyze the following code. What will be logged to the console? Explain your reasoning. Then, rewrite the `logMessage` method to ensure that when `obj.delayedLog()` is called, it correctly logs 'Hello, World!' after a delay, without manually referencing `obj.message` inside `setTimeout`.",
          "answer": "Original Code Analysis:\n```javascript\nconst obj = {\n  message: 'Hello, World!',\n  logMessage: function() {\n    setTimeout(function() {\n      console.log(this.message); \n    }, 100);\n  }\n};\n\nobj.delayedLog(); // Output: undefined (after 100ms)\n```\n\n**Explanation**: When `obj.delayedLog()` is called, `logMessage` is executed as a method of `obj`, so `this` inside `logMessage` initially refers to `obj`. However, `setTimeout` takes a *regular function expression* as its callback. Inside this callback, `this` is **not** bound to `obj`. In non-strict mode, `this` inside the `setTimeout` callback will default to the global object (`window` in a browser), and `window.message` is `undefined` (or empty string). In strict mode, `this` would be `undefined`.\n\nRewritten `logMessage` (using an arrow function or `bind`):\n\n**Option 1: Using an Arrow Function** (preferred for simplicity and common use cases)\n```javascript\nconst obj = {\n  message: 'Hello, World!',\n  delayedLog: function() {\n    setTimeout(() => {\n      console.log(this.message); // 'this' lexically binds to obj from delayedLog's scope\n    }, 100);\n  }\n};\nobj.delayedLog(); // Output: Hello, World! (after 100ms)\n```\n\n**Option 2: Using `bind`**\n```javascript\nconst obj = {\n  message: 'Hello, World!',\n  delayedLog: function() {\n    setTimeout(function() {\n      console.log(this.message);\n    }.bind(this), 100); // .bind(this) ensures 'this' inside callback is 'obj'\n  }\n};\nobj.delayedLog(); // Output: Hello, World! (after 100ms)\n```\n\n**Explanation of Rewrite**: Both solutions successfully preserve the `this` context:\n*   **Arrow Function**: Arrow functions do not have their own `this` context; they inherit `this` from their parent scope. In this case, the `setTimeout` callback (an arrow function) inherits `this` from the `delayedLog` method, where `this` correctly refers to `obj`.\n*   **`bind(this)`**: The `bind()` method creates a *new function* that has its `this` keyword set to the provided value. By binding `this` (which is `obj` at the point of `setTimeout` call) to the callback function, we ensure that `this.message` inside the `setTimeout` callback correctly references `obj.message`.",
          "analysisPoints": [
            "Correctly identify the `this` binding issue with `setTimeout` callbacks.",
            "Explain the default/global binding of `this` in such scenarios.",
            "Provide and justify solutions using arrow functions and/or `bind`.",
            "Demonstrate understanding of lexical vs. dynamic `this`."
          ],
          "keyConcepts": [
            "this",
            "setTimeout",
            "Arrow Functions",
            "Bind",
            "Lexical Scope",
            "Dynamic Binding",
            "Callbacks"
          ],
          "evaluationCriteria": [
            "Accuracy of initial prediction and explanation.",
            "Effectiveness and correctness of the rewritten code.",
            "Thoroughness of explanation for the solutions."
          ],
          "example": null,
          "tags": [
            "this",
            "setTimeout",
            "Asynchronous JavaScript",
            "Coding Challenge",
            "Bind",
            "Arrow Functions"
          ],
          "prerequisites": [
            "theory_function_context_this",
            "theory_function_borrowing",
            "javascript_asynchronous"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_borrowing_1",
          "topic": "Function Borrowing",
          "level": "easy",
          "type": "flashcard",
          "question": "Which `Function.prototype` method returns a *new function* with `this` bound, instead of executing immediately?",
          "answer": "`bind()`",
          "analysisPoints": [
            "Differentiating `bind` from `call` and `apply` based on its return value and immediate execution."
          ],
          "keyConcepts": [
            "bind",
            "Function Borrowing",
            "this"
          ],
          "evaluationCriteria": [
            "Quick recall of method behavior."
          ],
          "example": null,
          "tags": [
            "Bind",
            "JavaScript",
            "Functions"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_borrowing_2",
          "topic": "Function Borrowing",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following objects and function:\n\n```javascript\nconst car = {\n  brand: 'Toyota',\n  getBrand: function() {\n    return this.brand;\n  }\n};\n\nconst anotherCar = {\n  brand: 'Honda'\n};\n\n// What will be the output of:\nconsole.log(car.getBrand.call(anotherCar));\n```",
          "answer": "Honda",
          "options": [
            "Toyota",
            "Honda",
            "undefined",
            "TypeError"
          ],
          "analysisPoints": [
            "Understanding how `call` explicitly sets the `this` context.",
            "Identifying that `this` inside `getBrand` will refer to `anotherCar`."
          ],
          "keyConcepts": [
            "call",
            "Function Borrowing",
            "this",
            "Explicit Binding"
          ],
          "evaluationCriteria": [
            "Ability to correctly predict `this` behavior with `call`.",
            "Understanding of explicit binding."
          ],
          "example": "The `call()` method allows you to invoke `car.getBrand` with `anotherCar` as its `this` context. Therefore, `this.brand` inside `getBrand` will evaluate to `anotherCar.brand`, which is 'Honda'.\n\n```javascript\nconst car = {\n  brand: 'Toyota',\n  getBrand: function() {\n    return this.brand;\n  }\n};\n\nconst anotherCar = {\n  brand: 'Honda'\n};\n\nconsole.log(car.getBrand.call(anotherCar)); // Output: Honda\n```",
          "tags": [
            "call",
            "this",
            "Function Borrowing"
          ],
          "prerequisites": [
            "theory_function_context_this"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_borrowing_3",
          "topic": "Function Borrowing",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast `call()` and `apply()`. When would you choose one over the other?",
          "answer": "Both `call()` and `apply()` are `Function.prototype` methods used for explicit function invocation. They allow you to call a function with a specified `this` context.\n\n**Similarities:**\n*   Both execute the function *immediately*.\n*   Both allow you to explicitly set the `this` value for the function call.\n*   Both take `thisArg` as their first argument.\n\n**Differences:**\n*   **Argument Handling**: `call()` accepts arguments as a comma-separated list (`func.call(thisArg, arg1, arg2, ...)`).\n    `apply()` accepts arguments as an array or an array-like object (`func.apply(thisArg, [argsArray])`).\n\n**When to choose which:**\n*   **Choose `call()`** when you know the arguments beforehand and they are few and distinct, or when you are simply passing individual variables.\n    *   *Example*: `Math.max.call(null, 10, 20, 5);`\n*   **Choose `apply()`** when you have an array of arguments, or when the number of arguments is dynamic and not known at the time of writing the code (e.g., when accepting `arguments` object in a function).\n    *   *Example*: `Math.max.apply(null, [10, 20, 5]);` or `Array.prototype.push.apply(arr1, arr2);` (for concatenating arrays).\n\nIn ES6, with the spread syntax (`...`), the distinction for passing arguments has become less critical, as you can often use `call` with spread: `func.call(thisArg, ...argsArray);`. However, understanding the original intent and historical use cases of `apply` is still important.",
          "analysisPoints": [
            "Accurate comparison of argument handling.",
            "Correct identification of when to use each method.",
            "Mentioning similarities and differences.",
            "Discussing the impact of ES6 spread syntax."
          ],
          "keyConcepts": [
            "call",
            "apply",
            "Function Borrowing",
            "this",
            "Explicit Binding",
            "Arguments"
          ],
          "evaluationCriteria": [
            "Thoroughness of comparison.",
            "Clarity of explanation for use cases.",
            "Accuracy of technical details."
          ],
          "example": null,
          "tags": [
            "call",
            "apply",
            "Function Borrowing",
            "this"
          ],
          "prerequisites": [
            "theory_function_context_this"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_borrowing_4",
          "topic": "Function Borrowing",
          "level": "hard",
          "type": "code",
          "question": "You have a `Logger` object that logs messages with a prefix and timestamp. You want to use its `log` method as a callback for an array iteration, but ensure `this` inside `log` always refers to the `Logger` instance. Write the code to achieve this.\n\n```javascript\nconst logger = {\n  prefix: '[APP]',\n  log: function(message) {\n    const timestamp = new Date().toLocaleTimeString();\n    console.log(`${this.prefix} ${timestamp}: ${message}`);\n  }\n};\n\nconst messages = [\n  'User logged in',\n  'Data fetched',\n  'Error occurred'\n];\n\n// Your code here: Use forEach with logger.log as callback, preserving 'this'\n```\n\nExpected Output (timestamps will vary):\n`[APP] 10:30:00 AM: User logged in`\n`[APP] 10:30:00 AM: Data fetched`\n`[APP] 10:30:00 AM: Error occurred`",
          "answer": "```javascript\nconst logger = {\n  prefix: '[APP]',\n  log: function(message) {\n    const timestamp = new Date().toLocaleTimeString();\n    // 'this' must refer to 'logger' object\n    console.log(`${this.prefix} ${timestamp}: ${message}`);\n  }\n};\n\nconst messages = [\n  'User logged in',\n  'Data fetched',\n  'Error occurred'\n];\n\n// Using .bind() to create a new function with 'this' permanently bound to 'logger'\nmessages.forEach(logger.log.bind(logger));\n\n// Alternative using an arrow function for the forEach callback (less direct function borrowing):\n// messages.forEach(message => logger.log(message));\n```\n\n**Explanation**:\nWhen `messages.forEach(logger.log)` is used directly, the `log` function is called by `forEach`. In this context, `this` inside `log` would typically be `undefined` (in strict mode) or the global object (in non-strict mode), not `logger`. This would cause `this.prefix` to be `undefined`.\n\nBy using `logger.log.bind(logger)`, we create a *new function* (a bound version of `logger.log`) where the `this` context is permanently set to the `logger` object. This bound function is then passed to `forEach`. Now, when `forEach` calls this bound function for each `message`, `this.prefix` correctly resolves to `logger.prefix`.",
          "analysisPoints": [
            "Correctly identify the `this` context issue when `logger.log` is passed as a callback.",
            "Apply `bind` to explicitly set `this` for the `log` method.",
            "Demonstrate proper usage of `forEach` with a bound function."
          ],
          "keyConcepts": [
            "bind",
            "Function Borrowing",
            "this",
            "forEach",
            "Callbacks",
            "Explicit Binding"
          ],
          "evaluationCriteria": [
            "Functional correctness.",
            "Correct application of `bind`.",
            "Understanding of `this` in callbacks."
          ],
          "example": null,
          "tags": [
            "Bind",
            "this",
            "Callbacks",
            "Coding Challenge"
          ],
          "prerequisites": [
            "theory_function_context_this",
            "theory_function_borrowing",
            "javascript_arrays"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_borrowing_5",
          "topic": "Function Borrowing",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference between `call()` and `apply()` in terms of how they handle arguments?",
          "answer": "`call()` takes arguments individually (comma-separated), while `apply()` takes arguments as an array.",
          "analysisPoints": [
            "Differentiating `call` and `apply` based on argument passing."
          ],
          "keyConcepts": [
            "call",
            "apply",
            "Arguments"
          ],
          "evaluationCriteria": [
            "Quick recall of method signatures."
          ],
          "example": null,
          "tags": [
            "call",
            "apply",
            "JavaScript"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_borrowing_6",
          "topic": "Function Borrowing",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following scenarios is `Function.prototype.bind()` most suitable for?\n\n```javascript\nconst data = {\n  value: 10,\n  update: function(newValue) {\n    this.value = newValue;\n    console.log(this.value);\n  }\n};\n\n// You need to pass data.update as a callback to a function \n// that will execute it later, and ensure 'this' always refers to 'data'.\n```",
          "answer": "Using it as an event listener for a DOM element.",
          "options": [
            "Using it as an event listener for a DOM element.",
            "Immediately invoking it with a different 'this' context and a known set of arguments.",
            "Invoking it immediately with a different 'this' context and arguments supplied as an array.",
            "Performing a one-time function call with a specific 'this' for debugging."
          ],
          "analysisPoints": [
            "Understanding that `bind` creates a *new* function for *later* execution.",
            "Recognizing that `call` and `apply` are for immediate execution.",
            "Identifying scenarios where preserving `this` over time is critical."
          ],
          "keyConcepts": [
            "bind",
            "Function Borrowing",
            "this",
            "Callbacks",
            "Event Handling",
            "Partial Application"
          ],
          "evaluationCriteria": [
            "Ability to choose the correct method for a given scenario.",
            "Understanding the `bind` method's primary use cases."
          ],
          "example": "`bind` is ideal when you need to pass a method as a callback to another function or API (like `setTimeout`, `addEventListener`, or React component methods) where the original `this` context would otherwise be lost. It pre-configures the `this` value, returning a new function that can be called anytime later.\n\n```javascript\nconst data = {\n  value: 10,\n  update: function(newValue) {\n    this.value = newValue;\n    console.log(this.value);\n  }\n};\n\nconst button = document.createElement('button');\nbutton.textContent = 'Update';\ndocument.body.appendChild(button);\n\n// Without bind, 'this' inside update would be the button when clicked\n// With bind, 'this' inside update will always be 'data'\nbutton.addEventListener('click', data.update.bind(data, 20)); // Binds 'this' to data and partially applies '20'\n```",
          "tags": [
            "Bind",
            "this",
            "Callbacks",
            "Event Handling"
          ],
          "prerequisites": [
            "theory_function_context_this",
            "theory_function_borrowing"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_currying_1",
          "topic": "Currying",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the core idea behind currying a function?",
          "answer": "Transforming a function that takes multiple arguments into a sequence of functions, each taking a single argument.",
          "analysisPoints": [
            "Basic definition of currying."
          ],
          "keyConcepts": [
            "Currying",
            "Functional Programming",
            "Higher-Order Functions"
          ],
          "evaluationCriteria": [
            "Recall of definition."
          ],
          "example": null,
          "tags": [
            "Currying",
            "Functional Programming"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_currying_2",
          "topic": "Currying",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following curried `multiply` function:\n\n```javascript\nfunction multiply(a) {\n  return function(b) {\n    return function(c) {\n      return a * b * c;\n    };\n  };\n}\n\n// What will be the output of:\nconst multiplyByFive = multiply(5);\nconst multiplyByFiveAndTen = multiplyByFive(10);\nconsole.log(multiplyByFiveAndTen(2));\n```",
          "answer": "100",
          "options": [
            "5",
            "10",
            "100",
            "TypeError"
          ],
          "analysisPoints": [
            "Understanding how curried functions are invoked step-by-step.",
            "Tracing the flow of arguments through nested functions."
          ],
          "keyConcepts": [
            "Currying",
            "Closure",
            "Partial Application"
          ],
          "evaluationCriteria": [
            "Ability to correctly evaluate curried function calls.",
            "Understanding of argument persistence through closures."
          ],
          "example": "The `multiply` function is curried. `multiply(5)` returns a new function (closure) where `a` is 5. `multiplyByFive(10)` then calls this new function, binding `b` to 10 and returning another function. Finally, `multiplyByFiveAndTen(2)` calls the last function, binding `c` to 2, and performs the calculation: `5 * 10 * 2 = 100`.\n\n```javascript\nfunction multiply(a) {\n  return function(b) {\n    return function(c) {\n      return a * b * c;\n    };\n  };\n}\n\nconst multiplyByFive = multiply(5); // a = 5\nconst multiplyByFiveAndTen = multiplyByFive(10); // b = 10\nconsole.log(multiplyByFiveAndTen(2)); // c = 2 -> 5 * 10 * 2 = 100\n```",
          "tags": [
            "Currying",
            "Functional Programming",
            "Closure"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_closures"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_currying_3",
          "topic": "Currying",
          "level": "medium",
          "type": "open",
          "question": "What are some practical benefits or use cases for currying in frontend development?",
          "answer": "Currying offers several practical benefits in frontend development:\n\n1.  **Reusability and Configuration**: You can create specialized, reusable functions by pre-setting some arguments. For example, a `makeHttpRequest` function can be curried to create specific `getJson`, `postXml` functions by fixing the method and content type.\n2.  **Partial Application**: It naturally supports partial application, allowing you to pass arguments incrementally. This is useful for event handlers where you might want to pass some fixed data along with the event object, or for creating utility functions that are configured once and then used multiple times.\n3.  **Function Composition**: Curried functions fit well into function composition pipelines (e.g., using `compose` or `pipe` utilities), as each function takes a single argument and returns a single output, making data flow more predictable.\n4.  **Cleaner Code for Higher-Order Components/Functions**: In frameworks like React, currying can make higher-order components or functions more declarative and easier to read, especially when passing multiple configuration parameters.\n5.  **Simplified Form Validation**: A validator function for an input could be curried to first take the validation rule (e.g., `minLength`, `isEmail`) and then return a function that takes the actual input value.\n\n**Example (Partial Application for Event Handlers)**:\n```javascript\nfunction logEvent(eventType) {\n  return function(event) {\n    console.log(`${eventType} occurred at ${event.target.id || event.target.tagName}`);\n  };\n}\n\nconst button = document.createElement('button');\nbutton.id = 'myButton';\nbutton.textContent = 'Click Me';\ndocument.body.appendChild(button);\n\nbutton.addEventListener('click', logEvent('UserClick'));\n// When button is clicked, logs: 'UserClick occurred at myButton'\n```",
          "analysisPoints": [
            "Identifies multiple benefits beyond just syntax.",
            "Provides relevant frontend specific use cases.",
            "Offers a clear, concise example."
          ],
          "keyConcepts": [
            "Currying",
            "Partial Application",
            "Function Composition",
            "Reusability",
            "Higher-Order Functions"
          ],
          "evaluationCriteria": [
            "Breadth of knowledge on benefits.",
            "Relevance of examples.",
            "Clarity of explanation."
          ],
          "example": null,
          "tags": [
            "Currying",
            "Functional Programming",
            "Frontend Development",
            "Use Cases"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_higher_order_functions"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_currying_4",
          "topic": "Currying",
          "level": "hard",
          "type": "code",
          "question": "Write a generic `curry` helper function that takes any function `func` and returns its curried version. The curried function should support calling with one argument at a time, or multiple arguments until all arguments are satisfied (based on `func.length`).\n\n```javascript\n// Your curry function here\n\nconst sum = (a, b, c) => a + b + c;\nconst curriedSum = curry(sum);\n\nconsole.log(curriedSum(1)(2)(3));   // Should output 6\nconsole.log(curriedSum(1, 2)(3));   // Should output 6\nconsole.log(curriedSum(1)(2, 3));   // Should output 6\nconsole.log(curriedSum(1, 2, 3));   // Should output 6\n```",
          "answer": "```javascript\nfunction curry(func) {\n  // `func.length` gives the number of arguments the function expects\n  return function curried(...args) {\n    // If enough arguments are gathered, execute the original function\n    if (args.length >= func.length) {\n      return func.apply(this, args);\n    } else {\n      // Otherwise, return a new function that expects more arguments\n      // It concatenates the new arguments with the previously gathered ones\n      return function(...args2) {\n        return curried.apply(this, args.concat(args2));\n      };\n    }\n  };\n}\n\nconst sum = (a, b, c) => a + b + c;\nconst curriedSum = curry(sum);\n\nconsole.log(curriedSum(1)(2)(3));   // 6\nconsole.log(curriedSum(1, 2)(3));   // 6\nconsole.log(curriedSum(1)(2, 3));   // 6\nconsole.log(curriedSum(1, 2, 3));   // 6\n\n// Example with a different function\nconst greet = (greeting, name) => `${greeting}, ${name}!`;\nconst curriedGreet = curry(greet);\n\nconsole.log(curriedGreet('Hello')('John')); // Hello, John!\nconsole.log(curriedGreet('Hi', 'Jane'));   // Hi, Jane!\n```",
          "analysisPoints": [
            "Correctly uses recursion or a loop to collect arguments.",
            "Leverages `func.length` to determine when to execute the original function.",
            "Handles `this` context correctly (using `apply` or arrow functions).",
            "Supports both single and multiple arguments per call."
          ],
          "keyConcepts": [
            "Currying",
            "Higher-Order Functions",
            "Recursion",
            "Closures",
            "Rest Parameters",
            "Spread Syntax"
          ],
          "evaluationCriteria": [
            "Functional correctness of the `curry` helper.",
            "Robustness to various argument passing styles.",
            "Efficiency and clarity of the implementation."
          ],
          "example": null,
          "tags": [
            "Currying",
            "Higher-Order Functions",
            "Functional Programming",
            "Coding Challenge"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_closures",
            "javascript_rest_spread"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_currying_5",
          "topic": "Currying",
          "level": "easy",
          "type": "flashcard",
          "question": "True or False: Currying necessarily means a function takes arguments one at a time.",
          "answer": "True",
          "analysisPoints": [
            "Reinforces the strict definition of currying vs. partial application."
          ],
          "keyConcepts": [
            "Currying",
            "Partial Application"
          ],
          "evaluationCriteria": [
            "Accuracy of fundamental definition."
          ],
          "example": null,
          "tags": [
            "Currying",
            "Definition"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_memoization_1",
          "topic": "Memoization",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary goal of memoization?",
          "answer": "To optimize the performance of functions by caching their results.",
          "analysisPoints": [
            "Core purpose of memoization."
          ],
          "keyConcepts": [
            "Memoization",
            "Optimization",
            "Caching"
          ],
          "evaluationCriteria": [
            "Recall of primary goal."
          ],
          "example": null,
          "tags": [
            "Memoization",
            "Optimization"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_memoization_2",
          "topic": "Memoization",
          "level": "medium",
          "type": "mcq",
          "question": "Which type of function is best suited for memoization?",
          "answer": "Pure functions that perform expensive computations and are frequently called with the same inputs.",
          "options": [
            "Functions that have side effects and modify external state.",
            "Functions that rely heavily on random number generation.",
            "Functions that perform frequent I/O operations (e.g., fetching data from a server).",
            "Pure functions that perform expensive computations and are frequently called with the same inputs."
          ],
          "analysisPoints": [
            "Understanding the prerequisites for effective memoization (purity, expense, recurring inputs).",
            "Excluding scenarios where memoization is not suitable (side effects, non-deterministic, I/O)."
          ],
          "keyConcepts": [
            "Memoization",
            "Pure Functions",
            "Performance",
            "Caching"
          ],
          "evaluationCriteria": [
            "Knowledge of ideal memoization candidates.",
            "Ability to identify unsuitable functions."
          ],
          "example": "Memoization works best with pure functions because their output is solely determined by their inputs, making caching reliable. Expensive computations benefit most, and frequent calls with identical inputs ensure the cache is utilized often.\n\n```javascript\n// Good candidate: pure, expensive, potentially repetitive calls\nfunction calculateFactorial(n) {\n  if (n === 0 || n === 1) return 1;\n  let result = 1;\n  for (let i = 2; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\n// Bad candidate: side effect\nlet globalCounter = 0;\nfunction incrementAndReturn(n) {\n  globalCounter++;\n  return n + 1;\n}\n// Memoizing this would lead to globalCounter not incrementing on cache hits.\n```",
          "tags": [
            "Memoization",
            "Pure Functions",
            "Optimization"
          ],
          "prerequisites": [
            "javascript_functions",
            "functional_programming_concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_memoization_3",
          "topic": "Memoization",
          "level": "medium",
          "type": "open",
          "question": "Explain the trade-off involved when using memoization. When might memoization be counterproductive?",
          "answer": "The primary trade-off with memoization is **memory consumption versus computational speed**. While memoization reduces re-computation time by storing results, it consumes memory to maintain the cache.\n\n**Counterproductive scenarios:**\n1.  **Functions with few repeated calls / highly unique inputs**: If a function is rarely called with the same inputs, the overhead of managing the cache (checking, storing) might outweigh the benefit of avoiding re-computation. The cache would mostly store unique results that are never reused.\n2.  **Small / Inexpensive Computations**: For very fast functions, the overhead of cache lookup and key generation might be greater than the time saved by avoiding re-execution, making memoization a net negative for performance.\n3.  **Functions with Complex Object Arguments**: Generating unique and reliable cache keys for complex objects or functions (e.g., using `JSON.stringify` on objects with non-deterministic key order, or functions as arguments) can be tricky and inefficient. Deep equality checks or custom hashing can be expensive.\n4.  **Functions with Side Effects / Non-deterministic Output**: Memoizing functions that have side effects (e.g., modifying global state, making network requests) or return different results for the same input (e.g., `Math.random()`, `Date.now()`) will lead to incorrect or unexpected behavior because the side effects won't re-occur on cache hits, and the non-deterministic output won't be re-calculated.",
          "analysisPoints": [
            "Identifies the memory-speed trade-off.",
            "Lists multiple scenarios where memoization is inappropriate or detrimental.",
            "Explains the reasons behind each counterproductive scenario."
          ],
          "keyConcepts": [
            "Memoization",
            "Trade-offs",
            "Performance Optimization",
            "Pure Functions",
            "Caching"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of memoization's limitations.",
            "Ability to articulate when to avoid it.",
            "Clarity of explanation."
          ],
          "example": null,
          "tags": [
            "Memoization",
            "Optimization",
            "Trade-offs",
            "Performance"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_memoization_4",
          "topic": "Memoization",
          "level": "hard",
          "type": "code",
          "question": "Implement a `memoize` higher-order function that can memoize any single-argument function. Test it with a recursive Fibonacci function. Your memoization function should handle cases where `fn` might be called with `this` context.\n\n```javascript\nfunction memoize(fn) {\n  // Your implementation here\n}\n\n// Test with Fibonacci\nfunction fib(n) {\n  // Simulate heavy computation\n  for (let i = 0; i < 100000; i++) {}; \n  if (n <= 1) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n\nconst memoizedFib = memoize(fib);\n\nconsole.time('fib 15 (no memo)');\nfib(15);\nconsole.timeEnd('fib 15 (no memo)');\n\nconsole.time('memoizedFib 15 (first call)');\nmemoizedFib(15);\nconsole.timeEnd('memoizedFib 15 (first call)');\n\nconsole.time('memoizedFib 15 (second call)');\nmemoizedFib(15);\nconsole.timeEnd('memoizedFib 15 (second call)');\n```\n\nExpected output should show a significant time difference between `memoizedFib 15 (first call)` and `memoizedFib 15 (second call)`.",
          "answer": "```javascript\nfunction memoize(fn) {\n  const cache = {};\n  return function(...args) {\n    // For a single argument, the arg itself can be the key.\n    // For multiple arguments, JSON.stringify or a more complex key generation is needed.\n    const key = args[0]; \n\n    if (cache[key] !== undefined) {\n      // console.log(`Cache hit for ${key}`);\n      return cache[key];\n    } else {\n      // console.log(`Cache miss for ${key}, calculating...`);\n      // Use apply to correctly pass arguments and preserve 'this' context\n      const result = fn.apply(this, args);\n      cache[key] = result;\n      return result;\n    }\n  };\n}\n\n// Test with Fibonacci\nfunction fib(n) {\n  // Simulate heavy computation\n  for (let i = 0; i < 100000; i++) {}; // Simulate work\n  if (n <= 1) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n\nconst memoizedFib = memoize(fib);\n\nconsole.time('fib 15 (no memo)');\nfib(15);\nconsole.timeEnd('fib 15 (no memo)');\n\nconsole.time('memoizedFib 15 (first call)');\nmemoizedFib(15);\nconsole.timeEnd('memoizedFib 15 (first call)');\n\nconsole.time('memoizedFib 15 (second call)');\nmemoizedFib(15);\nconsole.timeEnd('memoizedFib 15 (second call)');\n\n// Expected behavior:\n// fib 15 (no memo): ~[high time]\n// memoizedFib 15 (first call): ~[high time]\n// memoizedFib 15 (second call): ~[very low time]\n```",
          "analysisPoints": [
            "Correctly implements a higher-order `memoize` function.",
            "Uses a cache (e.g., object or Map).",
            "Generates a suitable cache key (simple for single argument, or `JSON.stringify` for multiple/complex).",
            "Correctly applies the original function using `fn.apply(this, args)` to preserve `this`.",
            "Demonstrates performance improvement with `console.time`."
          ],
          "keyConcepts": [
            "Memoization",
            "Higher-Order Functions",
            "Caching",
            "Performance Optimization",
            "Pure Functions",
            "this",
            "apply"
          ],
          "evaluationCriteria": [
            "Functional correctness of memoization logic.",
            "Efficiency improvement demonstration.",
            "Handling of `this` context.",
            "Appropriate use of `console.time` for benchmarking."
          ],
          "example": null,
          "tags": [
            "Memoization",
            "Optimization",
            "Coding Challenge",
            "Higher-Order Functions"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_objects",
            "javascript_closures",
            "theory_function_borrowing"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_memoization_5",
          "topic": "Memoization",
          "level": "easy",
          "type": "flashcard",
          "question": "What data structure is commonly used to store cached results in a memoized function?",
          "answer": "An object or a Map.",
          "analysisPoints": [
            "Common implementation details of memoization."
          ],
          "keyConcepts": [
            "Memoization",
            "Cache",
            "Object",
            "Map"
          ],
          "evaluationCriteria": [
            "Recall of common data structures."
          ],
          "example": null,
          "tags": [
            "Memoization",
            "Data Structures"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_iife_1",
          "title": "Create a User Management IIFE Module",
          "description": "\nImplement a JavaScript module using an Immediately Invoked Function Expression (IIFE) for basic user management. This module should keep user data private and expose only public methods to interact with it.\n\n**Requirements:**\n1.  The module should be encapsulated within an IIFE.\n2.  Maintain a private array `_users` to store user objects (e.g., `{ id: 1, name: 'Alice' }`).\n3.  Expose the following public methods:\n    *   `addUser(userObject)`: Adds a new user to the `_users` array. Assigns a unique `id` (e.g., incrementing counter) if not provided.\n    *   `getUserById(id)`: Returns the user object with the matching `id`, or `undefined` if not found.\n    *   `getAllUsers()`: Returns a *copy* of the `_users` array to prevent external modification.\n    *   `removeUser(id)`: Removes the user with the specified `id` from the array.\n4.  Ensure all internal variables and the `_users` array are not accessible from the global scope.\n",
          "difficulty": "medium",
          "startingCode": "const userManager = (function() {\n  let _nextId = 1; // Private counter for user IDs\n  let _users = []; // Private array to store users\n\n  return {\n    // Implement addUser, getUserById, getAllUsers, removeUser here\n  };\n})();\n\n// Example Usage (for testing your implementation):\n// userManager.addUser({ name: 'Alice' });\n// userManager.addUser({ name: 'Bob' });\n// console.log('All Users:', userManager.getAllUsers());\n// console.log('User with ID 1:', userManager.getUserById(1));\n// userManager.removeUser(1);\n// console.log('All Users after removal:', userManager.getAllUsers());\n// console.log('Attempting to access private _users:', userManager._users); // Should be undefined",
          "solutionCode": "const userManager = (function() {\n  let _nextId = 1;\n  let _users = [];\n\n  return {\n    addUser: function(userObject) {\n      if (!userObject || typeof userObject !== 'object' || !userObject.name) {\n        console.error('Invalid user object. Must have a name.');\n        return;\n      }\n      const newUser = { ...userObject, id: userObject.id || _nextId++ };\n      _users.push(newUser);\n      console.log(`User added: ${newUser.name} (ID: ${newUser.id})`);\n      return newUser;\n    },\n\n    getUserById: function(id) {\n      return _users.find(user => user.id === id);\n    },\n\n    getAllUsers: function() {\n      // Return a shallow copy to prevent direct modification of the private array\n      return [..._users]; \n    },\n\n    removeUser: function(id) {\n      const initialLength = _users.length;\n      _users = _users.filter(user => user.id !== id);\n      if (_users.length < initialLength) {\n        console.log(`User with ID ${id} removed.`);\n        return true;\n      } else {\n        console.warn(`User with ID ${id} not found.`);\n        return false;\n      }\n    }\n  };\n})();\n\n// Test cases\nconsole.log('--- Initial State ---');\nconsole.log('Users:', userManager.getAllUsers());\n\nconsole.log('\\n--- Adding Users ---');\nuserManager.addUser({ name: 'Alice' });\nuserManager.addUser({ name: 'Bob', id: 10 }); // Custom ID\nuserManager.addUser({ name: 'Charlie' });\nconsole.log('All Users:', userManager.getAllUsers());\n\nconsole.log('\\n--- Getting User by ID ---');\nconst alice = userManager.getUserById(1);\nconsole.log('User 1:', alice); // { id: 1, name: 'Alice' }\nconst bob = userManager.getUserById(10);\nconsole.log('User 10:', bob); // { id: 10, name: 'Bob' }\nconst nonExistent = userManager.getUserById(99);\nconsole.log('User 99:', nonExistent); // undefined\n\nconsole.log('\\n--- Removing Users ---');\nuserManager.removeUser(1);\nuserManager.removeUser(99); // Non-existent\nconsole.log('All Users after removals:', userManager.getAllUsers());\n\nconsole.log('\\n--- Testing Privacy ---');\nconst exposedUsers = userManager.getAllUsers();\nexposedUsers.push({ id: 999, name: 'Evil User' }); // This should only modify the copy\nconsole.log('Original private users after external push attempt:', userManager.getAllUsers()); // Should not contain 'Evil User'\n// console.log(userManager._users); // This would cause an error if uncommented (good!)",
          "testCases": [
            "Adding users with and without custom IDs.",
            "Retrieving existing and non-existing users by ID.",
            "Removing existing and non-existing users by ID.",
            "Verifying that `getAllUsers()` returns a copy, not the original private array.",
            "Ensuring private variables (`_nextId`, `_users`) are not globally accessible."
          ],
          "hints": [
            "Remember to use `let` or `const` inside the IIFE for private variables.",
            "The `id` for new users can be a simple incrementing counter.",
            "When returning the array of all users, make sure to return a *copy* to maintain encapsulation. `[...array]` or `array.slice()` can create a shallow copy.",
            "Consider edge cases for `addUser` (e.g., null/invalid user objects) and `removeUser` (user not found)."
          ],
          "tags": [
            "IIFE",
            "Module Pattern",
            "Encapsulation",
            "Data Privacy",
            "Closures",
            "Frontend Architecture"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "javascript_functions",
            "javascript_scope",
            "javascript_arrays",
            "javascript_objects"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "module_pattern",
            "closures",
            "data_hiding"
          ]
        },
        {
          "id": "task_this_1",
          "title": "Build a Simple Carousel Component with 'this' Management",
          "description": "\nCreate a basic JavaScript carousel component that manages its internal state (current slide index) and handles user interactions (next/previous buttons). This task specifically focuses on correctly managing the `this` context within event listeners.\n\n**Requirements:**\n1.  Create a `Carousel` class or constructor function.\n2.  The `Carousel` should have a `currentIndex` property, initialized to 0.\n3.  It should accept an array of `slides` (strings or URLs) in its constructor.\n4.  It should have methods: `nextSlide()`, `prevSlide()`, and `render()`.\n5.  `render()` should create DOM elements for the carousel (e.g., a container, image/text display, and 'Next'/'Prev' buttons). Append these to `document.body`.\n6.  Attach `click` event listeners to the 'Next' and 'Prev' buttons.\n7.  **Crucially**, ensure that `this` inside the event listener callbacks correctly refers to the `Carousel` instance, allowing `this.currentIndex` to be updated and `this.slides` to be accessed.\n8.  Update the displayed slide when buttons are clicked.\n\n**Constraints:**\n*   Do not use arrow functions for the `nextSlide()` and `prevSlide()` methods themselves.\n*   You *must* use either `.bind()` or an arrow function directly in the `addEventListener` call to manage `this` context.\n",
          "difficulty": "hard",
          "startingCode": "class Carousel {\n  constructor(slides) {\n    this.slides = slides; // Array of slide content\n    this.currentIndex = 0;\n\n    // DOM elements\n    this.container = document.createElement('div');\n    this.display = document.createElement('div');\n    this.prevBtn = document.createElement('button');\n    this.nextBtn = document.createElement('button');\n\n    this.prevBtn.textContent = 'Previous';\n    this.nextBtn.textContent = 'Next';\n    this.container.appendChild(this.prevBtn);\n    this.container.appendChild(this.display);\n    this.container.appendChild(this.nextBtn);\n    document.body.appendChild(this.container);\n\n    this.updateDisplay(); // Initial display\n\n    // TODO: Attach event listeners to prevBtn and nextBtn\n    // Ensure 'this' in the event handler correctly refers to the Carousel instance.\n    // e.g., this.prevBtn.addEventListener('click', this.prevSlide.YOUR_BINDING_METHOD_HERE);\n  }\n\n  updateDisplay() {\n    this.display.textContent = `Slide ${this.currentIndex + 1}: ${this.slides[this.currentIndex]}`;\n  }\n\n  nextSlide() {\n    this.currentIndex = (this.currentIndex + 1) % this.slides.length;\n    this.updateDisplay();\n    console.log('Next clicked, current index:', this.currentIndex);\n  }\n\n  prevSlide() {\n    this.currentIndex = (this.currentIndex - 1 + this.slides.length) % this.slides.length;\n    this.updateDisplay();\n    console.log('Prev clicked, current index:', this.currentIndex);\n  }\n}\n\n// Example usage:\n// const myCarousel = new Carousel(['Image 1', 'Image 2', 'Image 3']);\n",
          "solutionCode": "class Carousel {\n  constructor(slides) {\n    this.slides = slides;\n    this.currentIndex = 0;\n\n    this.container = document.createElement('div');\n    this.container.style.border = '1px solid black';\n    this.container.style.padding = '10px';\n    this.container.style.margin = '20px';\n    this.container.style.textAlign = 'center';\n\n    this.display = document.createElement('div');\n    this.display.style.fontSize = '24px';\n    this.display.style.minHeight = '50px';\n    this.display.style.lineHeight = '50px';\n    this.display.style.borderBottom = '1px solid #ccc';\n    this.display.style.marginBottom = '10px';\n\n    this.prevBtn = document.createElement('button');\n    this.nextBtn = document.createElement('button');\n\n    this.prevBtn.textContent = 'Previous';\n    this.nextBtn.textContent = 'Next';\n    this.prevBtn.style.marginRight = '10px';\n\n    this.container.appendChild(this.prevBtn);\n    this.container.appendChild(this.display);\n    this.container.appendChild(this.nextBtn);\n    document.body.appendChild(this.container);\n\n    this.updateDisplay();\n\n    // Method 1: Using .bind(this) to ensure 'this' refers to the Carousel instance\n    this.nextBtn.addEventListener('click', this.nextSlide.bind(this));\n    this.prevBtn.addEventListener('click', this.prevSlide.bind(this));\n\n    // Method 2: Using an arrow function directly in addEventListener\n    // this.nextBtn.addEventListener('click', () => this.nextSlide());\n    // this.prevBtn.addEventListener('click', () => this.prevSlide());\n  }\n\n  updateDisplay() {\n    if (this.slides.length === 0) {\n      this.display.textContent = 'No slides available.';\n      return;\n    }\n    this.display.textContent = `Slide ${this.currentIndex + 1}: ${this.slides[this.currentIndex]}`;\n  }\n\n  nextSlide() {\n    // Ensure 'this' refers to the Carousel instance here\n    this.currentIndex = (this.currentIndex + 1) % this.slides.length;\n    this.updateDisplay();\n    console.log('Next clicked, current index:', this.currentIndex);\n  }\n\n  prevSlide() {\n    // Ensure 'this' refers to the Carousel instance here\n    this.currentIndex = (this.currentIndex - 1 + this.slides.length) % this.slides.length;\n    this.updateDisplay();\n    console.log('Prev clicked, current index:', this.currentIndex);\n  }\n}\n\n// Example usage:\nconst mySlides = ['Hello from Slide 1!', 'This is Slide 2.', 'Final Slide 3.'];\nconst myCarousel = new Carousel(mySlides);\n\n// Test with empty slides\nconst emptyCarousel = new Carousel([]);\n",
          "testCases": [
            "Initialize with a few slides and verify initial display.",
            "Click 'Next' multiple times and verify slide change and wrap-around.",
            "Click 'Previous' multiple times and verify slide change and wrap-around.",
            "Verify `this.currentIndex` updates correctly after each click.",
            "Test with an empty `slides` array to ensure graceful handling.",
            "Verify that `this` inside `nextSlide` and `prevSlide` correctly refers to the `Carousel` instance."
          ],
          "hints": [
            "When `addEventListener` invokes a callback, `this` inside that callback usually refers to the DOM element (`button` in this case).",
            "To preserve the `this` context of your `Carousel` instance, you can use `this.nextSlide.bind(this)` or wrap the call in an arrow function `() => this.nextSlide()`.",
            "Remember to handle the wrap-around logic for `currentIndex` using the modulo operator (`%`) for `next` and a slightly modified calculation for `prev` to ensure it always stays positive."
          ],
          "tags": [
            "this",
            "Event Handling",
            "Bind",
            "Arrow Functions",
            "Classes",
            "DOM Manipulation",
            "Frontend Component"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_function_context_this",
            "theory_function_borrowing",
            "javascript_classes",
            "dom_manipulation"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "event_delegation",
            "component_architecture",
            "state_management"
          ]
        },
        {
          "id": "task_borrowing_1",
          "title": "Create a Flexible Logger with Function Borrowing",
          "description": "\nBuild a `Logger` utility that can be used to log messages to different output targets (e.g., console, a DOM element) using function borrowing techniques (`call`, `apply`, `bind`).\n\n**Requirements:**\n1.  Create a base `logger` object with a `logMessage` method:\n    ```javascript\n    const baseLogger = {\n      logMessage: function(prefix, message) {\n        console.log(`${prefix} ${message}`);\n      }\n    };\n    ```\n2.  Create a `consoleLogger` object that uses `baseLogger.logMessage` to log to the console, always prepending `[CONSOLE]`. Use `bind` for this.\n3.  Create a `domLogger` object. Its `logMessage` method should append messages to a specific DOM element (e.g., a `div` with `id=\"log-output\"`). It should prepend `[DOM]`. Use `call` or `apply` within this method to invoke `baseLogger.logMessage` (or a variation of it) with `[DOM]` prefix, but direct its output to the DOM.\n4.  Demonstrate usage of both loggers. Also, show how to use `baseLogger.logMessage` directly with `call` or `apply` for a one-off log with a custom prefix and context.\n\n**HTML Structure (you can assume this exists):**\n```html\n<div id=\"log-output\"></div>\n```\n",
          "difficulty": "hard",
          "startingCode": "const baseLogger = {\n  logMessage: function(prefix, message) {\n    // This method needs to be flexible enough to be 'borrowed'\n    // It will be invoked with different 'this' contexts and prefixes\n    // For this task, assume 'this' might refer to the actual output target or just be 'null'\n    // and we'll focus on passing the output string directly.\n    // console.log(`${prefix} ${message}`); // Default console behavior\n    \n    // For the DOM logger, we'll need to know where to append. \n    // Let's modify baseLogger slightly to be more generic, or assume \n    // the borrowing function will handle the actual output channel.\n    \n    // Revised baseLogger to return the formatted string, letting the caller handle output\n    formatMessage: function(prefix, message) {\n      return `${prefix} ${new Date().toLocaleTimeString()}: ${message}`;\n    }\n};\n\n// TODO: Implement consoleLogger using bind\nconst consoleLogger = {}; // Fill this in\n\n// TODO: Implement domLogger using call/apply within its method\nconst domLogger = {\n  outputElement: document.getElementById('log-output'),\n  log: function(message) {\n    // Use call/apply here to format the message using baseLogger.formatMessage\n    // Then append to this.outputElement\n  }\n};\n\n// Example Usage (for testing your implementation):\n// consoleLogger.log('Application started');\n// domLogger.log('DOM updated');\n// baseLogger.formatMessage.call(null, '[DIRECT]', 'One-off log');\n",
          "solutionCode": "const baseLogger = {\n  // This method just formats the message, leaving output channel flexible\n  formatMessage: function(prefix, message) {\n    const timestamp = new Date().toLocaleTimeString();\n    return `${prefix} ${timestamp}: ${message}`;\n  }\n};\n\n// 1. Console Logger using bind\n// We bind baseLogger.formatMessage to null (no specific 'this' needed for formatting) \n// and partially apply '[CONSOLE]' as the first argument (prefix).\n// The returned function then only needs the 'message' argument.\nconst consoleLogger = {\n  log: baseLogger.formatMessage.bind(null, '[CONSOLE]'),\n  // This is a simple wrapper, the actual console.log happens here:\n  // The `log` method calls the bound `formatMessage` and then prints it.\n  // A more direct bind would be if baseLogger.logMessage itself did the console.log.\n  // Let's adjust to make it more direct application of bind:\n};\n\n// Revised Console Logger to directly use baseLogger's logMessage functionality if it existed\n// For this example, we make a simple log method and use the formatted message.\nconst consoleOutputLogger = {\n  log: function(message) {\n    console.log(baseLogger.formatMessage('[CONSOLE]', message));\n  }\n};\n\n// 2. DOM Logger using call/apply\nconst domOutputElement = document.createElement('div');\ndomOutputElement.id = 'log-output';\ndomOutputElement.style.border = '1px dashed grey';\ndomOutputElement.style.margin = '10px';\ndomOutputElement.style.padding = '5px';\ndocument.body.appendChild(domOutputElement);\n\nconst domLogger = {\n  outputElement: domOutputElement,\n  log: function(message) {\n    // Use `call` to invoke baseLogger.formatMessage with its context set to null\n    // and pass the prefix '[DOM]' and the 'message' as individual arguments.\n    const formatted = baseLogger.formatMessage.call(null, '[DOM]', message);\n    \n    const p = document.createElement('p');\n    p.textContent = formatted;\n    this.outputElement.appendChild(p); // 'this' here refers to domLogger\n  }\n};\n\n// Example Usage:\nconsole.log('--- Using Loggers ---');\nconsoleOutputLogger.log('Application started successfully.');\ndomLogger.log('DOM logger initialized.');\ndomLogger.log('New item added to list.');\nconsoleOutputLogger.log('Background process completed.');\n\nconsole.log('\\n--- Direct Function Borrowing (One-off) ---');\n// Using .call() for a one-off log to console with a custom prefix\nconsole.log(baseLogger.formatMessage.call(null, '[CUSTOM]', 'This is a direct call message.'));\n\n// Using .apply() for a one-off log with arguments in an array\nconst argsForApply = ['[APPLY]', 'This message came via apply.'];\nconsole.log(baseLogger.formatMessage.apply(null, argsForApply));\n",
          "testCases": [
            "Verify consoleLogger logs messages with `[CONSOLE]` prefix to the console.",
            "Verify domLogger logs messages with `[DOM]` prefix to the specified DOM element.",
            "Check that messages include timestamps.",
            "Ensure `baseLogger.formatMessage.call(null, ...)` works for direct, one-off formatting.",
            "Ensure `baseLogger.formatMessage.apply(null, [...])` works for direct, one-off formatting with an array of arguments."
          ],
          "hints": [
            "For the `consoleLogger`, you can use `bind` to create a new function that always calls `baseLogger.formatMessage` with `[CONSOLE]` as its first argument. Then, wrap this bound function in another function to actually call `console.log`.",
            "For the `domLogger`, inside its `log` method, you'll need to use `baseLogger.formatMessage.call(null, '[DOM]', message)` to get the formatted string. Then, append this string to `this.outputElement`.",
            "Remember to assume the `div#log-output` element exists in the HTML.",
            "The `this` context for `baseLogger.formatMessage` itself doesn't need to be `logger` in this setup, so `null` or `undefined` can be passed as the `thisArg` for `call` and `apply`."
          ],
          "tags": [
            "Function Borrowing",
            "Call",
            "Apply",
            "Bind",
            "this",
            "Logger",
            "DOM Manipulation",
            "Frontend Architecture"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_function_borrowing",
            "theory_function_context_this",
            "dom_manipulation"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "higher_order_functions",
            "design_patterns"
          ]
        },
        {
          "id": "task_currying_1",
          "title": "Implement a Curried Form Validator",
          "description": "\nCreate a flexible form validation system using currying. You will implement a `validator` function that can be partially applied to create specific validation rules, which can then be applied to input values.\n\n**Requirements:**\n1.  Create a curried `validator` function with the signature `validator(rule)(message)(value)`.\n    *   `rule`: A function that takes a `value` and returns `true` if valid, `false` otherwise.\n    *   `message`: The error message string to return if validation fails.\n    *   `value`: The input value to validate.\n    *   The `validator` should return `true` if `rule(value)` is `true`, otherwise it should return the `message`.\n\n2.  Create specific curried validation functions using `validator`:\n    *   `isRequired`: Checks if a string `value` is not empty. Returns \"Field is required\" if empty.\n    *   `minLength(length)`: A curried function that checks if a string `value` has at least `length` characters. Returns \"Must be at least X characters\" if too short.\n    *   `isEmail`: Checks if a string `value` is a valid email format. Returns \"Invalid email format\" if not.\n\n3.  Demonstrate the usage of these curried validators with example input values.\n",
          "difficulty": "hard",
          "startingCode": "// 1. Implement the curried validator function\nfunction validator(rule) {\n  return function(message) {\n    return function(value) {\n      // Your logic here\n    };\n  };\n}\n\n// 2. Define rule functions\nconst notEmpty = (str) => str && str.trim() !== '';\nconst isEmailPattern = (email) => /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$/.test(email);\n\n// 3. Create specific curried validators using `validator`\nconst isRequired = validator(notEmpty)('Field is required');\n\nfunction minLength(minLen) {\n  // This needs to return a curried function based on validator\n  // Hint: You'll need to define the rule function inline or separately.\n  return validator((value) => value.length >= minLen)(`Must be at least ${minLen} characters`);\n}\n\nconst isEmail = validator(isEmailPattern)('Invalid email format');\n\n// Example Usage (for testing):\n// console.log('Required field (valid):', isRequired('hello'));\n// console.log('Required field (invalid):', isRequired(''));\n// console.log('Min length 5 (valid):', minLength(5)('testing'));\n// console.log('Min length 5 (invalid):', minLength(5)('test'));\n// console.log('Email (valid):', isEmail('test@example.com'));\n// console.log('Email (invalid):', isEmail('invalid-email'));\n",
          "solutionCode": "// 1. Implement the curried validator function\nfunction validator(rule) {\n  return function(message) {\n    return function(value) {\n      if (rule(value)) {\n        return true; // Valid\n      } else {\n        return message; // Invalid, return error message\n      }\n    };\n  };\n}\n\n// 2. Define base rule functions (pure functions returning boolean)\nconst notEmpty = (str) => str && str.trim() !== '';\nconst isEmailPattern = (email) => /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/.test(email);\n\n// 3. Create specific curried validators using `validator`\n// Basic rules (message is fixed)\nconst isRequired = validator(notEmpty)('Field is required');\nconst isEmail = validator(isEmailPattern)('Invalid email format');\n\n// Rule with a parameter (minLength), so it's a function returning a curried validator\nconst minLength = (minLen) => {\n  const ruleFn = (value) => value && value.length >= minLen;\n  return validator(ruleFn)(`Must be at least ${minLen} characters`);\n};\n\n// Optional: max Length example\nconst maxLength = (maxLen) => {\n  const ruleFn = (value) => value && value.length <= maxLen;\n  return validator(ruleFn)(`Cannot exceed ${maxLen} characters`);\n};\n\n// Example Usage:\nconsole.log('--- isRequired ---');\nconsole.log('Valid (hello):', isRequired('hello'));    // true\nconsole.log('Invalid (empty):', isRequired(''));       // Field is required\nconsole.log('Invalid (whitespace):', isRequired('   ')); // Field is required\n\nconsole.log('\\n--- minLength(5) ---');\nconst checkMinLength5 = minLength(5);\nconsole.log('Valid (testing):', checkMinLength5('testing')); // true\nconsole.log('Invalid (test):', checkMinLength5('test'));    // Must be at least 5 characters\nconsole.log('Valid (abcde):', checkMinLength5('abcde'));  // true\n\nconsole.log('\\n--- isEmail ---');\nconsole.log('Valid (test@example.com):', isEmail('test@example.com')); // true\nconsole.log('Invalid (invalid-email):', isEmail('invalid-email'));  // Invalid email format\nconsole.log('Invalid (no @):', isEmail('testexample.com')); // Invalid email format\nconsole.log('Invalid (empty):', isEmail('')); // Invalid email format (because notEmpty is not part of this specific email rule)\n\nconsole.log('\\n--- Chaining Validators (Conceptual) ---');\n// In a real system, you'd apply a list of validators to an input\nconst usernameValidators = [\n  isRequired,\n  minLength(3),\n  maxLength(10)\n];\n\nfunction validateInput(value, validators) {\n  for (const validatorFn of validators) {\n    const result = validatorFn(value);\n    if (result !== true) {\n      return result; // Return first error message\n    }\n  }\n  return true; // All good\n}\n\nconsole.log('Validate Username \"john\":', validateInput('john', usernameValidators)); // true\nconsole.log('Validate Username \"jo\":', validateInput('jo', usernameValidators));   // Must be at least 3 characters\nconsole.log('Validate Username \"johndoesnotfit\":', validateInput('johndoesnotfit', usernameValidators)); // Cannot exceed 10 characters\nconsole.log('Validate Username \"\":', validateInput('', usernameValidators));     // Field is required\n",
          "testCases": [
            "Test `isRequired` with empty, whitespace, and valid strings.",
            "Test `minLength` with strings shorter, equal to, and longer than the specified length.",
            "Test `isEmail` with valid and invalid email formats (missing '@', missing domain, etc.).",
            "Ensure the `validator` function correctly returns `true` or the error `message`.",
            "Verify that `minLength` is correctly curried and accepts its length parameter first."
          ],
          "hints": [
            "Remember that currying means each function in the sequence takes only one argument.",
            "The `rule` argument of your `validator` should be a function that returns a boolean.",
            "When implementing `minLength`, the outer function `minLength(len)` needs to *return* the result of calling `validator(rule)(message)` where `rule` itself is a function that checks the length against `len`."
          ],
          "tags": [
            "Currying",
            "Functional Programming",
            "Validation",
            "Higher-Order Functions",
            "Frontend Development"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "theory_currying",
            "javascript_functions",
            "javascript_closures"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "functional_composition",
            "pipeline_pattern",
            "higher_order_components"
          ]
        },
        {
          "id": "task_memoization_1",
          "title": "Implement a Memoized Calculator for Expensive Operations",
          "description": "\nCreate a memoized version of a computationally expensive function. This task will test your understanding of memoization, cache management, and performance optimization.\n\n**Requirements:**\n1.  Implement a generic `memoize` higher-order function:\n    ```javascript\n    function memoize(func) {\n      // Your implementation here\n    }\n    ```\n    *   It should take any function `func` as an argument.\n    *   It should return a new, memoized version of `func`.\n    *   The memoized function should store results in a `cache` (e.g., a JavaScript `Object` or `Map`).\n    *   For the cache key, assume arguments are primitive (numbers, strings, booleans). If multiple arguments are present, concatenate them or use `JSON.stringify` for simplicity.\n    *   Ensure the `this` context is correctly preserved when the original function `func` is called from within the memoized wrapper.\n\n2.  Apply `memoize` to a computationally expensive function:\n    *   `calculateHeavySum(n)`: This function should simulate a heavy computation (e.g., a loop from 0 to `n * 1000000`) and then return the sum of numbers from 1 to `n`.\n\n3.  Demonstrate the performance improvement using `console.time` and `console.timeEnd`:\n    *   Call the original `calculateHeavySum` once.\n    *   Call the `memoizedHeavySum` once (first time, will compute).\n    *   Call the `memoizedHeavySum` again with the *same input* (should be from cache, much faster).\n    *   Call the `memoizedHeavySum` with a *different input* (should compute again).\n",
          "difficulty": "hard",
          "startingCode": "function memoize(func) {\n  const cache = {};\n  return function(...args) {\n    // TODO: Implement cache key generation\n    const key = JSON.stringify(args); // Simple approach for general arguments\n    \n    // TODO: Implement cache lookup and return cached result\n    \n    // TODO: If not in cache, compute result, store, and return\n    // Remember to preserve 'this' context when calling 'func'\n  };\n}\n\n// An expensive function to test memoization\nfunction calculateHeavySum(n) {\n  console.log(`Calculating heavy sum for ${n}...`);\n  // Simulate heavy computation\n  for (let i = 0; i < n * 1000000; i++) {}; \n  \n  // Actual calculation (sum of numbers up to n)\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\n// TODO: Apply memoize to calculateHeavySum\n// const memoizedHeavySum = memoize(calculateHeavySum);\n\n// TODO: Demonstrate performance with console.time\n// console.time('Original Call');\n// calculateHeavySum(100);\n// console.timeEnd('Original Call');\n\n// console.time('Memoized First Call');\n// memoizedHeavySum(100);\n// console.timeEnd('Memoized First Call');\n\n// console.time('Memoized Second Call (cached)');\n// memoizedHeavySum(100);\n// console.timeEnd('Memoized Second Call (cached)');\n\n// console.time('Memoized Different Call');\n// memoizedHeavySum(50);\n// console.timeEnd('Memoized Different Call');\n",
          "solutionCode": "function memoize(func) {\n  const cache = {}; // Using a simple object for cache\n\n  return function(...args) {\n    // A simple key for primitive arguments. For complex objects, \n    // a more sophisticated hashing or deep comparison would be needed.\n    const key = JSON.stringify(args); \n\n    if (cache[key] !== undefined) {\n      console.log(`Cache hit for args: ${key}`);\n      return cache[key];\n    } else {\n      console.log(`Cache miss for args: ${key}. Computing...`);\n      // Use apply to call the original function, preserving 'this' context\n      // and passing arguments as an array.\n      const result = func.apply(this, args);\n      cache[key] = result;\n      return result;\n    }\n  };\n}\n\n// An expensive function to test memoization\nfunction calculateHeavySum(n) {\n  // Simulate heavy computation (e.g., 1 million iterations per 'n')\n  for (let i = 0; i < n * 1000000; i++) {}; \n  \n  // Actual calculation (sum of numbers up to n)\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\n// Apply memoize to calculateHeavySum\nconst memoizedHeavySum = memoize(calculateHeavySum);\n\n// Demonstrate performance\nconst testValue1 = 100;\nconst testValue2 = 50;\n\nconsole.log('\\n--- Original Function Calls ---');\nconsole.time(`Original Call (${testValue1})`);\ncalculateHeavySum(testValue1);\nconsole.timeEnd(`Original Call (${testValue1})`);\n\nconsole.time(`Original Call (${testValue2})`);\ncalculateHeavySum(testValue2);\nconsole.timeEnd(`Original Call (${testValue2})`);\n\nconsole.log('\\n--- Memoized Function Calls ---');\n\nconsole.time(`Memoized First Call (${testValue1})`);\nmemoizedHeavySum(testValue1);\nconsole.timeEnd(`Memoized First Call (${testValue1})`);\n\nconsole.time(`Memoized Second Call (cached) (${testValue1})`);\nmemoizedHeavySum(testValue1);\nconsole.timeEnd(`Memoized Second Call (cached) (${testValue1})`);\n\nconsole.time(`Memoized Different Call (${testValue2})`);\nmemoizedHeavySum(testValue2);\nconsole.timeEnd(`Memoized Different Call (${testValue2})`);\n\nconsole.time(`Memoized Cached Call (${testValue2})`);\nmemoizedHeavySum(testValue2);\nconsole.timeEnd(`Memoized Cached Call (${testValue2})`);\n\n// Example with a function that uses 'this'\nconst calculator = {\n  multiplier: 2,\n  multiplyAndAdd: function(a, b) {\n    for (let i = 0; i < 500000; i++) {}; // Simulate work\n    return (a + b) * this.multiplier;\n  }\n};\n\nconst memoizedMultiplyAndAdd = memoize(calculator.multiplyAndAdd);\n\nconsole.log('\\n--- Memoized Function with `this` Context ---');\nconsole.time('Memoized `this` first call (5, 10)');\nconsole.log(memoizedMultiplyAndAdd.call(calculator, 5, 10)); // Pass calculator as 'this' context\nconsole.timeEnd('Memoized `this` first call (5, 10)');\n\nconsole.time('Memoized `this` second call (5, 10)');\nconsole.log(memoizedMultiplyAndAdd.call(calculator, 5, 10)); // Cache hit\nconsole.timeEnd('Memoized `this` second call (5, 10)');\n\n// If `this` changes, it's a new call for simple keying, or the keying needs to incorporate `this`.\n// For this setup, we assume 'this' is part of the call but not part of the key unless explicitly added.\n// For full robustness, you might stringify `this` as part of the key, but it has implications.\n// console.time('Memoized `this` different context (5, 10)');\n// console.log(memoizedMultiplyAndAdd.call({ multiplier: 3 }, 5, 10)); // Different 'this'\n// console.timeEnd('Memoized `this` different context (5, 10)');\n",
          "testCases": [
            "Calling the memoized function multiple times with the same input to verify cache hits (significant time reduction).",
            "Calling the memoized function with new inputs to verify new computations.",
            "Verifying the correct result is returned from both calculations and cache hits.",
            "Testing a function that utilizes `this` to ensure the `this` context is correctly passed and preserved through `func.apply(this, args)`."
          ],
          "hints": [
            "An object (`{}`) or `Map` is suitable for the `cache`.",
            "For the cache `key`, `JSON.stringify(args)` is a simple way to create a unique string from an array of primitive arguments. Be aware of its limitations with non-primitive arguments (objects, functions, non-deterministic order of keys).",
            "When calling the original `func` inside the memoized wrapper, use `func.apply(this, args)` or `func.call(this, ...args)` to correctly pass the `this` context and arguments."
          ],
          "tags": [
            "Memoization",
            "Optimization",
            "Higher-Order Functions",
            "Performance",
            "Caching",
            "Functional Programming",
            "this"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_memoization",
            "javascript_functions",
            "javascript_closures",
            "javascript_objects",
            "theory_function_borrowing"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "dynamic_programming",
            "pure_functions",
            "performance_tuning"
          ]
        }
      ]
    }
  }
]