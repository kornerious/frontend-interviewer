[
  {
    "id": "e14fd79b-957c-45c4-bdee-5719d6a3687d",
    "startLine": 6700,
    "endLine": 6799,
    "processedDate": "2025-06-17T10:05:47.116Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_redux_router_setup",
          "title": "Redux Store Configuration with React Router Redux",
          "content": "This section details how to integrate `react-router-redux` with your Redux store, enabling the router's state to be managed by Redux and allowing for programmatic navigation. The core idea is to combine `react-router` with `redux` using `react-router-redux`.\n\n## Key Components\n\n*   **`createHistory()`**: This function, typically imported from the `history` library, creates a history object (e.g., `browserHistory` or `hashHistory`) that React Router uses to keep track of the application's navigation state. This history object is then passed to `ConnectedRouter` and `routerMiddleware`.\n*   **`configureStore(initialState, history)`**: A central function responsible for setting up the Redux store. It uses Redux's `createStore` to combine the root reducer, initial state, and enhancers.\n*   **`routerMiddleware(history)`**: This middleware from `react-router-redux` connects the browser history to Redux. It dispatches actions whenever the browser history changes (e.g., URL changes) and also listens for `react-router-redux` specific actions (like `PUSH`, `REPLACE`, `GO`) to update the browser history.\n*   **`applyMiddleware(...middlewares)`**: A Redux utility that applies various middlewares to the store, enhancing its capabilities (e.g., handling asynchronous actions, routing).\n*   **`compose`**: A Redux utility that composes functions from right to left. It's used here to chain multiple store enhancers (like `applyMiddleware` and `Redux DevTools`).\n*   **`Redux DevTools Extension`**: A powerful browser extension for debugging Redux applications. The setup includes logic to conditionally enable `window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__` in development environments, which allows integrating the DevTools with other enhancers.\n*   **`Provider` (from `react-redux`)**: Makes the Redux store available to any nested components that have been wrapped in the `connect()` function.\n*   **`ConnectedRouter` (from `react-router-redux`)**: A wrapper around `react-router`'s `Router` component that uses the Redux store to keep the router's state in sync. It takes the `history` object as a prop.\n*   **`Route` (from `react-router-dom`)**: Renders a UI component when its path matches the current URL.",
          "examples": [
            {
              "id": "example_redux_router_setup_1",
              "title": "Main Application Entry Point (index.tsx)",
              "code": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { ConnectedRouter } from 'react-router-redux';\nimport { Route } from 'react-router-dom';\nimport { createBrowserHistory } from 'history'; // Using createBrowserHistory for web apps\nimport configureStore from './store';\nimport App from './App';\n\nconst rootElement = document.getElementById('root');\nconst initialState = {};\nconst history = createBrowserHistory(); // Initialize browser history\nconst store = configureStore(initialState, history);\n\nReactDOM.render(\n  <Provider store={store}>\n    <ConnectedRouter history={history}>\n      <Route path=\"/\" component={App} />\n    </ConnectedRouter>\n  </Provider>,\n  rootElement\n);\n",
              "explanation": "This is the main entry point of a React application integrated with Redux and React Router Redux. It sets up the Redux `Provider` to make the store available, and `ConnectedRouter` to synchronize React Router's state with Redux. The `history` object is created and passed to both the store configuration and `ConnectedRouter`.",
              "language": "typescript"
            },
            {
              "id": "example_redux_router_setup_2",
              "title": "Redux Store Configuration (store.ts)",
              "code": "import { createStore, applyMiddleware, compose } from 'redux';\nimport { routerMiddleware } from 'react-router-redux';\nimport rootReducer from './rootReducer'; // Assuming you have a rootReducer defined\n\nexport default function configureStore(initialState: any, history: any) {\n  const routerMW = routerMiddleware(history);\n  \n  const middleWares = [\n    routerMW,\n    // Add other middleware here, e.g., redux-thunk or redux-saga\n  ];\n  \n  const enhancers = [\n    applyMiddleware(...middleWares)\n  ];\n  \n  // Conditionally add Redux DevTools Extension if available and not in production\n  const composeEnhancers =\n    process.env.NODE_ENV !== 'production' &&\n    typeof window === 'object' &&\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : compose;\n  \n  const store = createStore(\n    rootReducer,\n    initialState,\n    composeEnhancers(...enhancers),\n  );\n  \n  return store;\n}",
              "explanation": "This `configureStore` function demonstrates how to set up a Redux store with `routerMiddleware`. It applies the router middleware along with any other application-specific middlewares. It also includes the crucial step of integrating with the Redux DevTools Extension for easier debugging during development.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_redux_router_setup_1",
            "question_redux_router_setup_2",
            "question_redux_router_setup_3",
            "question_redux_router_setup_4",
            "question_redux_router_setup_5",
            "question_redux_router_setup_6",
            "question_redux_router_setup_7",
            "question_redux_router_setup_8"
          ],
          "relatedTasks": [
            "task_configure_redux_router_store"
          ],
          "tags": [
            "Redux",
            "React-Router-Redux",
            "Store Configuration",
            "Middleware",
            "DevTools",
            "React"
          ],
          "technology": "TypeScript",
          "prerequisites": [
            "React Basics",
            "Redux Core Concepts",
            "React Router Basics",
            "JavaScript ES6"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced Redux Patterns",
            "Complex SPA Development",
            "State Management Integration"
          ]
        },
        {
          "id": "theory_router_state_navigation",
          "title": "Accessing Router State and Programmatic Navigation in Redux",
          "content": "Once `react-router-redux` is integrated, the router's state becomes a part of your Redux store, typically under a key like `router` (if using `routerReducer` from `react-router-redux`). This allows components connected to Redux to access navigation-related information directly from the store, and also dispatch actions to trigger navigation.\n\n## Accessing Router State\n\nThe router state in Redux generally includes the following structure:\n\n*   **`state.router.location`**: Contains details about the current URL, including:\n    *   `pathname`: The path of the URL (e.g., `/dashboard`).\n    *   `search`: The query string portion of the URL (e.g., `?name=John&age=30`).\n    *   `query`: An object representation of the query string parameters (parsed from `search`).\n    *   `hash`: The URL fragment identifier (e.g., `#section1`).\n*   **`state.router.match`**: Contains details about how the current URL matched a route, including:\n    *   `params`: An object containing key-value pairs of URL parameters (e.g., for `/users/:id`, `match.params.id` would hold the actual ID).\n    *   `isExact`: A boolean indicating if the match was exact.\n    *   `path`: The path pattern used to match (e.g., `/users/:id`).\n    *   `url`: The matched portion of the URL.\n\nThese pieces of information can be mapped to component props using `mapStateToProps`.\n\n## Programmatic Navigation\n\n`react-router-redux` provides action creators to perform navigation programmatically by dispatching Redux actions. The most common action creators are:\n\n*   **`push(path)`**: Navigates to a new URL and adds a new entry to the browser's history stack.\n*   **`replace(path)`**: Navigates to a new URL and replaces the current entry in the history stack, preventing the user from navigating back to the previous page using the browser's back button.\n*   **`go(delta)`**: Navigates forward or backward in the history stack by a given number (e.g., `go(-1)` for back, `go(1)` for forward).\n\nThese actions can be dispatched using `mapDispatchToProps`.",
          "examples": [
            {
              "id": "example_router_state_navigation_1",
              "title": "Accessing Route Parameters from Redux State",
              "code": "import { connect } from 'react-redux';\n\ninterface RootState {\n  router: {\n    location: { \n      pathname: string; \n      search: string; \n      query: { [key: string]: string };\n    };\n    match: { \n      params: { [key: string]: string };\n    };\n  };\n}\n\nconst mapStateToProps = (state: RootState) => ({\n  currentPath: state.router.location.pathname,\n  queryParams: state.router.location.query, // for query parameters (e.g., ?page=2)\n  pathParams: state.router.match.params // for path parameters (e.g., /users/:id)\n});\n\n// Example usage within a connected component:\n// class MyComponent extends React.Component<typeof mapStateToProps> { ... }\n// const ConnectedMyComponent = connect(mapStateToProps)(MyComponent);\n",
              "explanation": "This example shows how to use `mapStateToProps` to extract various router-related pieces of information from the Redux store. `state.router.location` provides details about the current URL, while `state.router.match` provides information about route matching, specifically path parameters.",
              "language": "typescript"
            },
            {
              "id": "example_router_state_navigation_2",
              "title": "Programmatic Navigation Using Redux Actions",
              "code": "import { connect } from 'react-redux';\nimport { push } from 'react-router-redux';\n\ninterface MyComponentProps {\n  navigateTo: (path: string) => void;\n}\n\n// In a React component (e.g., functional component or class component method)\nconst mapDispatchToProps = (dispatch: any) => ({\n  navigateTo: (path: string) => dispatch(push(path))\n});\n\n// Example usage in a class component:\n// class MyComponent extends React.Component<MyComponentProps> {\n//   handleButtonClick = () => {\n//     this.props.navigateTo('/dashboard');\n//   };\n//   render() {\n//     return <button onClick={this.handleButtonClick}>Go to Dashboard</button>;\n//   }\n// }\n// const ConnectedMyComponent = connect(null, mapDispatchToProps)(MyComponent);\n\n// Example usage in a functional component with useDispatch hook (if not using connect)\n// import { useDispatch } from 'react-redux';\n// import { push } from 'react-router-redux';\n// function MyFunctionalComponent() {\n//   const dispatch = useDispatch();\n//   const navigateToDashboard = () => dispatch(push('/dashboard'));\n//   return <button onClick={navigateToDashboard}>Go to Dashboard</button>;\n// }\n",
              "explanation": "This example demonstrates how `mapDispatchToProps` can be used to bind the `push` action creator from `react-router-redux` to a component's props. This allows the component to trigger navigation programmatically by simply calling `this.props.navigateTo('/some-path')`, dispatching a Redux action that `routerMiddleware` intercepts to update the browser's history.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_router_state_navigation_1",
            "question_router_state_navigation_2",
            "question_router_state_navigation_3",
            "question_router_state_navigation_4",
            "question_router_state_navigation_5",
            "question_router_state_navigation_6",
            "question_router_state_navigation_7",
            "question_router_state_navigation_8",
            "question_router_state_navigation_9"
          ],
          "relatedTasks": [
            "task_route_info_navigation_component"
          ],
          "tags": [
            "Redux State",
            "React-Router-Redux",
            "Navigation",
            "mapStateToProps",
            "mapDispatchToProps",
            "Programmatic Navigation",
            "URL Parameters"
          ],
          "technology": "TypeScript",
          "prerequisites": [
            "Redux Connect",
            "React Router Basics",
            "Redux Actions"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Dynamic Routing",
            "User Experience Optimization",
            "Data Fetching on Route Change"
          ]
        },
        {
          "id": "theory_url_parameters",
          "title": "Working with URL Parameters in React Router",
          "content": "URL parameters are dynamic segments in a URL that allow a route to capture variable data. They are crucial for building applications with dynamic content, such as user profiles, product details, or specific article pages. React Router provides mechanisms to define and access these parameters.\n\n## Route Definition\n\nIn React Router, you define a route with parameters using a colon `:` followed by the parameter name. For example, `path=\"/users/:id\"` defines a route where `:id` is a dynamic parameter.\n\n## Accessing Parameters in a Component\n\nWhen a `Route` matches a URL with parameters, the matched component receives `match` object in its `props`. This `match` object contains a `params` property, which is an object holding the key-value pairs of the URL parameters.\n\n*   **`this.props.match.params`**: This is the standard way to access path parameters directly within a class component rendered by a `Route`. For functional components, you can use the `useParams` hook (part of React Router v5+ hooks API) or `withRouter` HOC.\n\n## Accessing Parameters from Redux State\n\nAs discussed in the previous section, if `react-router-redux` is configured, route parameters can also be accessed from the Redux store via `state.router.match.params`. Similarly, query parameters (e.g., `?search=term`) are available under `state.router.location.query`.\n\nThis is particularly useful when you need to access route information in parts of your application that are not directly rendered by a `Route` component, or when performing data fetching in Redux sagas/thunks based on URL parameters.",
          "examples": [
            {
              "id": "example_url_parameters_1",
              "title": "Route Definition with URL Parameter",
              "code": "import { Route } from 'react-router-dom';\nimport UserProfile from './UserProfile';\n\n// In your App.tsx or routes configuration\n<Route path=\"/users/:id\" component={UserProfile} />\n\n// Example URL: /users/123 -> id = '123'\n// Example URL: /users/abc-def -> id = 'abc-def'\n",
              "explanation": "This demonstrates how to define a route that expects a dynamic segment (`:id`). When a URL like `/users/123` is matched, `123` will be captured as the `id` parameter and passed to the `UserProfile` component.",
              "language": "typescript"
            },
            {
              "id": "example_url_parameters_2",
              "title": "Accessing Path Parameters in a Class Component",
              "code": "import React from 'react';\nimport { RouteComponentProps } from 'react-router-dom';\n\ninterface UserProfileParams {\n  id: string;\n}\n\ninterface UserProfileProps extends RouteComponentProps<UserProfileParams> {\n  fetchUserData: (userId: string) => void; // Assume this prop is passed via Redux connect or parent\n}\n\nclass UserProfile extends React.Component<UserProfileProps> {\n  componentDidMount() {\n    // Access the 'id' parameter from this.props.match.params\n    const userId = this.props.match.params.id;\n    console.log('Fetching user data for ID:', userId);\n    // Example: this.props.fetchUserData(userId); // Dispatch an action to fetch data\n  }\n  \n  componentDidUpdate(prevProps: UserProfileProps) {\n    // Re-fetch data if the ID parameter changes (e.g., from /users/1 to /users/2)\n    if (prevProps.match.params.id !== this.props.match.params.id) {\n      const userId = this.props.match.params.id;\n      console.log('Refetching user data for ID:', userId);\n      // this.props.fetchUserData(userId);\n    }\n  }\n\n  render() {\n    const { id } = this.props.match.params;\n    return (\n      <div>\n        <h2>User Profile for ID: {id}</h2>\n        {/* Render user data here */}\n      </div>\n    );\n  }\n}\n\nexport default UserProfile;\n",
              "explanation": "This `UserProfile` class component demonstrates how to access the `id` URL parameter via `this.props.match.params.id`. It also includes a common pattern for fetching data in `componentDidMount` and `componentDidUpdate` to react to initial load and parameter changes, respectively.",
              "language": "typescript"
            },
            {
              "id": "example_url_parameters_3",
              "title": "Accessing Query Parameters from Redux State",
              "code": "import { connect } from 'react-redux';\n\ninterface RootState {\n  routing: {\n    locationBeforeTransitions: {\n      query: { [key: string]: string | string[] | undefined };\n    };\n  };\n}\n\nconst mapStateToProps = (state: RootState) => ({\n  // For react-router-redux v4 or older, state.routing.locationBeforeTransitions might be used\n  // For react-router-redux v5, it's typically state.router.location.query\n  userIdFromQuery: state.routing.locationBeforeTransitions.query.id, // Example: /users?id=123\n  page: state.routing.locationBeforeTransitions.query.page\n});\n\n// Usage in a connected component:\n// class MyComponent extends React.Component<typeof mapStateToProps> {\n//   componentDidMount() {\n//     const { userIdFromQuery, page } = this.props;\n//     console.log('User ID from query:', userIdFromQuery, 'Page:', page);\n//   }\n//   render() { return <div>User ID: {this.props.userIdFromQuery}</div>; }\n// }\n",
              "explanation": "This example shows how query parameters (e.g., `?id=123&page=1`) can be accessed from the Redux store. Depending on the `react-router-redux` version, the exact path to `query` might differ (e.g., `state.routing.locationBeforeTransitions.query` or `state.router.location.query`). It's useful for accessing parameters that are not part of the URL path itself.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_url_parameters_1",
            "question_url_parameters_2",
            "question_url_parameters_3",
            "question_url_parameters_4",
            "question_url_parameters_5",
            "question_url_parameters_6"
          ],
          "relatedTasks": [
            "task_fetch_user_data_by_url_param"
          ],
          "tags": [
            "React Router",
            "URL Parameters",
            "Route Matching",
            "Query Parameters",
            "Redux State Access"
          ],
          "technology": "TypeScript",
          "prerequisites": [
            "React Components",
            "React Router Basics",
            "Redux State Access"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Dynamic Content Loading",
            "RESTful API Integration",
            "SEO friendly URLs"
          ]
        },
        {
          "id": "theory_react_hooks_placeholder",
          "title": "React Hooks (No Content Provided)",
          "content": "The markdown content includes a heading for 'React Hooks' but provides no further details or examples related to them. Therefore, this section will briefly define what React Hooks are, but cannot offer specific theory, questions, or tasks based on the original content.\n\n## What are React Hooks?\n\nReact Hooks are functions that let you 'hook into' React state and lifecycle features from functional components. They allow you to write functional components with state and side effects, without needing to convert them into class components. Key hooks include:\n\n*   **`useState`**: For adding state to functional components.\n*   **`useEffect`**: For performing side effects (data fetching, subscriptions, manual DOM manipulations, etc.).\n*   **`useContext`**: For subscribing to React context.\n*   **`useReducer`**: An alternative to `useState` for more complex state logic.\n*   **`useCallback` / `useMemo`**: For performance optimizations.\n\nWhile this content is important for modern React development, the provided markdown does not elaborate on it.",
          "examples": [],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React Hooks",
            "Functional Components",
            "State Management",
            "Side Effects"
          ],
          "technology": "React",
          "prerequisites": [
            "React Components",
            "JavaScript ES6"
          ],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Modern React Development",
            "Performance Optimization",
            "Component Reusability"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_redux_router_setup_1",
          "topic": "Redux Store Configuration",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of `routerMiddleware` in `react-router-redux`?",
          "answer": "To synchronize the browser's history with the Redux store and vice versa.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of a key component in the integration.",
            "Differentiates it from other Redux middlewares."
          ],
          "keyConcepts": [
            "routerMiddleware",
            "Redux Middleware",
            "React-Router-Redux"
          ],
          "evaluationCriteria": [
            "Recall of fundamental purpose",
            "Understanding of synchronization role"
          ],
          "example": "routerMiddleware bridges the gap between `history` actions (like `push`, `pop`, `replace`) and Redux actions, allowing navigation events to update the Redux state and Redux actions to trigger navigation.",
          "tags": [
            "Redux",
            "React-Router-Redux",
            "Middleware"
          ],
          "prerequisites": [
            "Redux Core Concepts",
            "React Router Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_redux_router_setup_2",
          "topic": "Redux Store Configuration",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following `configureStore` function, what is the role of `composeEnhancers`?",
          "answer": "To combine multiple store enhancers, including `applyMiddleware` and the Redux DevTools Extension, into a single function.",
          "options": [
            "To combine multiple store enhancers, including `applyMiddleware` and the Redux DevTools Extension, into a single function.",
            "To combine multiple reducers into a single root reducer.",
            "To apply multiple middleware functions sequentially.",
            "To create a history object for React Router."
          ],
          "analysisPoints": [
            "Tests understanding of Redux's `compose` utility.",
            "Highlights the conditional integration of Redux DevTools.",
            "Distinguishes `composeEnhancers` from `combineReducers` or `applyMiddleware` directly."
          ],
          "keyConcepts": [
            "compose",
            "Store Enhancers",
            "Redux DevTools",
            "applyMiddleware"
          ],
          "evaluationCriteria": [
            "Understanding of Redux composition",
            "Knowledge of Redux DevTools integration"
          ],
          "example": "```typescript\nimport { createStore, applyMiddleware, compose } from 'redux';\n\nconst composeEnhancers =\n    process.env.NODE_ENV !== 'production' &&\n    typeof window === 'object' &&\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : compose;\n\n// Used like: createStore(rootReducer, initialState, composeEnhancers(...enhancers));\n```\n`composeEnhancers` is essential for applying multiple store enhancers. In development, it typically includes the Redux DevTools Extension's composer to allow the extension to intercept store actions and state, while in production or if the extension is unavailable, it falls back to Redux's standard `compose` function.",
          "tags": [
            "Redux",
            "Store Configuration",
            "DevTools",
            "Middleware"
          ],
          "prerequisites": [
            "Redux Core Concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_router_setup_3",
          "topic": "React Router Redux Integration",
          "level": "easy",
          "type": "mcq",
          "question": "Which component is responsible for making the Redux store available to connected components in a React application?",
          "answer": "`Provider`",
          "options": [
            "`ConnectedRouter`",
            "`Route`",
            "`Provider`",
            "`App`"
          ],
          "analysisPoints": [
            "Tests basic knowledge of `react-redux` fundamentals.",
            "Ensures understanding of the role of `Provider`."
          ],
          "keyConcepts": [
            "Provider",
            "Redux",
            "React-Redux"
          ],
          "evaluationCriteria": [
            "Basic recall of `react-redux` API",
            "Understanding of dependency injection"
          ],
          "example": "The `Provider` component from `react-redux` is always at the top level of your component tree and takes the Redux store as a prop. This allows any component wrapped with `connect` (or using `useSelector`/`useDispatch` hooks) to access the store.",
          "tags": [
            "Redux",
            "React",
            "State Management"
          ],
          "prerequisites": [
            "React Basics",
            "Redux Basics"
          ],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_redux_router_setup_4",
          "topic": "React Router Redux Integration",
          "level": "medium",
          "type": "open",
          "question": "Explain the relationship between `createHistory()`, `routerMiddleware`, and `ConnectedRouter` in setting up `react-router-redux`.",
          "answer": "These three components work together to integrate React Router's navigation state with Redux.\n\n1.  **`createHistory()`**: This function (from the `history` library) initializes a history object (e.g., `browserHistory` or `hashHistory`). This object is the source of truth for the browser's URL and history stack.\n2.  **`routerMiddleware(history)`**: This Redux middleware takes the `history` object as an argument. It serves two main purposes:\n    *   It listens for changes in the browser's history (e.g., user clicks back/forward, URL changes) and dispatches corresponding Redux actions (e.g., `LOCATION_CHANGE`) to update the router state in the Redux store.\n    *   It intercepts `react-router-redux` specific actions dispatched from your application (e.g., `PUSH`, `REPLACE`, `GO`) and uses the `history` object to perform the actual browser navigation.\n3.  **`ConnectedRouter history={history}`**: This component acts as the React Router's `Router` but is specifically designed to work with `react-router-redux`. It receives the same `history` object as the middleware. It listens to the Redux store for router state changes (dispatched by `routerMiddleware`) and updates its internal React Router state accordingly, re-rendering components based on the new route.\n\nIn essence, `createHistory()` provides the history object, `routerMiddleware` synchronizes this history with the Redux store, and `ConnectedRouter` uses this synced history to render the correct React components.",
          "options": [],
          "analysisPoints": [
            "Tests comprehensive understanding of the setup flow.",
            "Requires explaining the role and interaction of multiple components.",
            "Highlights the bidirectional data flow."
          ],
          "keyConcepts": [
            "createHistory",
            "routerMiddleware",
            "ConnectedRouter",
            "React-Router-Redux",
            "History API"
          ],
          "evaluationCriteria": [
            "Clarity of explanation",
            "Accuracy of component roles",
            "Demonstrates understanding of system architecture"
          ],
          "example": "",
          "tags": [
            "Redux",
            "React Router",
            "Architecture",
            "Integration"
          ],
          "prerequisites": [
            "Redux Middleware",
            "React Router API"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_router_setup_5",
          "topic": "Redux Store Configuration",
          "level": "medium",
          "type": "code",
          "question": "Complete the `configureStore` function below to correctly integrate `routerMiddleware` and conditionally enable Redux DevTools Extension. Assume `rootReducer` and `createBrowserHistory` are imported.",
          "answer": "```typescript\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport { routerMiddleware } from 'react-router-redux';\nimport rootReducer from './rootReducer';\n\nexport default function configureStore(initialState: any, history: any) {\n  const routerMW = routerMiddleware(history);\n  \n  const middleWares = [\n    routerMW,\n    // other middleware like thunk or saga\n  ];\n  \n  const enhancers = [\n    applyMiddleware(...middleWares)\n  ];\n  \n  const composeEnhancers =\n    process.env.NODE_ENV !== 'production' &&\n    typeof window === 'object' &&\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : compose;\n  \n  const store = createStore(\n    rootReducer,\n    initialState,\n    composeEnhancers(...enhancers),\n  );\n  \n  return store;\n}\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to correctly apply Redux middleware.",
            "Checks understanding of conditional DevTools setup.",
            "Verifies knowledge of `compose` and `applyMiddleware` syntax."
          ],
          "keyConcepts": [
            "createStore",
            "applyMiddleware",
            "compose",
            "routerMiddleware",
            "Redux DevTools"
          ],
          "evaluationCriteria": [
            "Correct syntax and API usage",
            "Logical implementation of conditional DevTools",
            "Proper middleware application"
          ],
          "example": "This task requires synthesizing the store configuration logic, ensuring that `routerMiddleware` is part of the `middleWares` array and that `composeEnhancers` correctly handles the DevTools integration.",
          "tags": [
            "Redux",
            "Store Configuration",
            "Coding Task"
          ],
          "prerequisites": [
            "Redux API",
            "JavaScript Syntax"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_state_navigation_1",
          "topic": "Accessing Router State",
          "level": "easy",
          "type": "flashcard",
          "question": "What Redux state path typically holds the current URL's pathname when using `react-router-redux`?",
          "answer": "`state.router.location.pathname`",
          "options": [],
          "analysisPoints": [
            "Tests quick recall of common state structure.",
            "Essential for connecting components to router data."
          ],
          "keyConcepts": [
            "Router State",
            "Redux State Path",
            "pathname"
          ],
          "evaluationCriteria": [
            "Accurate path recall"
          ],
          "example": "If the URL is `http://example.com/dashboard/settings`, then `state.router.location.pathname` would be `/dashboard/settings`.",
          "tags": [
            "Redux State",
            "React-Router-Redux"
          ],
          "prerequisites": [
            "Redux State Access"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_router_state_navigation_2",
          "topic": "Accessing Router State",
          "level": "medium",
          "type": "mcq",
          "question": "If your route is defined as `<Route path=\"/products/:category/:id\" component={ProductDetail} />` and the current URL is `/products/electronics/123`, which `mapStateToProps` snippet correctly extracts both `category` and `id`?",
          "answer": "```typescript\nconst mapStateToProps = (state) => ({\n  category: state.router.match.params.category,\n  productId: state.router.match.params.id\n});\n```",
          "options": [
            "```typescript\nconst mapStateToProps = (state) => ({\n  category: state.router.location.query.category,\n  productId: state.router.location.query.id\n});\n```",
            "```typescript\nconst mapStateToProps = (state) => ({\n  category: state.router.match.params.category,\n  productId: state.router.match.params.id\n});\n```",
            "```typescript\nconst mapStateToProps = (state) => ({\n  category: state.router.location.pathname.split('/')[2],\n  productId: state.router.location.pathname.split('/')[3]\n});\n```",
            "```typescript\nconst mapStateToProps = (state) => ({\n  category: state.router.params.category,\n  productId: state.router.params.id\n});\n```"
          ],
          "analysisPoints": [
            "Tests understanding of the difference between path parameters (`match.params`) and query parameters (`location.query`).",
            "Checks knowledge of the Redux state structure provided by `react-router-redux`."
          ],
          "keyConcepts": [
            "mapStateToProps",
            "Path Parameters",
            "Query Parameters",
            "Router State"
          ],
          "evaluationCriteria": [
            "Correctly identifies parameter source",
            "Accurate state path usage"
          ],
          "example": "Path parameters are defined within the route path itself (e.g., `/products/:id`), and `react-router-redux` exposes them via `state.router.match.params`. Query parameters (e.g., `?category=electronics`) are appended after `?` and are available via `state.router.location.query`.",
          "tags": [
            "Redux State",
            "URL Parameters",
            "mapStateToProps"
          ],
          "prerequisites": [
            "React Router Parameters",
            "Redux Connect"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_state_navigation_3",
          "topic": "Programmatic Navigation",
          "level": "easy",
          "type": "flashcard",
          "question": "Which action creator from `react-router-redux` is used to navigate to a new URL and add an entry to the browser's history stack?",
          "answer": "`push`",
          "options": [],
          "analysisPoints": [
            "Tests recall of the most common navigation action.",
            "Distinguishes it from `replace`."
          ],
          "keyConcepts": [
            "push action",
            "Programmatic Navigation",
            "History Stack"
          ],
          "evaluationCriteria": [
            "Correct action creator identification"
          ],
          "example": "Dispatching `push('/new-route')` behaves like clicking a `<Link to=\"/new-route\">` and allows the user to press the browser's back button to return to the previous page.",
          "tags": [
            "React-Router-Redux",
            "Navigation"
          ],
          "prerequisites": [
            "Redux Actions"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_router_state_navigation_4",
          "topic": "Programmatic Navigation",
          "level": "medium",
          "type": "code",
          "question": "Write a `mapDispatchToProps` function that provides a prop `navigateToHome` to a component, which, when called, dispatches a Redux action to navigate to the `/` path using `react-router-redux`.",
          "answer": "```typescript\nimport { push } from 'react-router-redux';\n\nconst mapDispatchToProps = (dispatch: any) => ({\n  navigateToHome: () => dispatch(push('/'))\n});\n\n// Example usage in a component:\n// class MyComponent extends React.Component<any, any> {\n//   render() {\n//     return <button onClick={this.props.navigateToHome}>Go Home</button>;\n//   }\n// }\n// export default connect(null, mapDispatchToProps)(MyComponent);\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to use `mapDispatchToProps` correctly.",
            "Verifies knowledge of dispatching `react-router-redux` actions."
          ],
          "keyConcepts": [
            "mapDispatchToProps",
            "push action",
            "Programmatic Navigation",
            "Redux Dispatch"
          ],
          "evaluationCriteria": [
            "Correct `mapDispatchToProps` signature",
            "Proper action creator usage",
            "Functionality of dispatch"
          ],
          "example": "This solution demonstrates how to create a dispatch function that maps to a prop, allowing the component to trigger navigation without directly importing `dispatch` or `push`.",
          "tags": [
            "Redux",
            "Navigation",
            "Coding Task"
          ],
          "prerequisites": [
            "Redux Connect",
            "Redux Actions"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_state_navigation_5",
          "topic": "Router State vs. Component Props",
          "level": "hard",
          "type": "open",
          "question": "In a React application using `react-router-redux`, describe scenarios where it's more beneficial to access router state (like URL parameters or current path) from the Redux store rather than directly from `this.props.match` or `this.props.location` in a component. Provide at least two distinct scenarios.",
          "answer": "While `this.props.match` and `this.props.location` (provided by React Router directly to components rendered by `<Route>`) are convenient, accessing router state from the Redux store offers advantages in specific scenarios:\n\n1.  **Global Access/Cross-Component Consumption**: If router information (e.g., current path, specific URL parameters) is needed by a component that is *not* directly rendered by a `<Route>` (e.g., a header, sidebar, or a deeply nested child component that shouldn't receive all router props directly through prop drilling), accessing it from the Redux store is more efficient. Any connected component can then subscribe to the relevant slice of router state without needing to be `withRouter` wrapped or having props passed down multiple levels.\n\n2.  **Logic in Redux (Sagas/Thunks)**: When asynchronous operations or complex business logic within Redux middleware (like Redux-Saga or Redux-Thunk) depend on the current route or its parameters, accessing this information directly from the Redux store's state is essential. For example, a saga might need to fetch user data based on a `userId` parameter from the URL when a `LOCATION_CHANGE` action is dispatched, or before performing an API call triggered by an unrelated action.\n\n3.  **State Persistence/Hydration**: If you need to persist or rehydrate the application's entire state, including navigation state, across page refreshes or between sessions, having the router state in Redux makes this straightforward. The Redux store is designed for state serialization and deserialization.\n\n4.  **Time Travel Debugging**: Integrating router state into Redux allows it to participate in Redux DevTools' time-travel debugging capabilities. You can step through navigation changes, inspect the router state at each point, and even 'replay' navigation sequences, which is invaluable for debugging complex routing issues.",
          "options": [],
          "analysisPoints": [
            "Tests deep understanding of Redux-Router integration benefits.",
            "Requires critical thinking beyond basic component-level access.",
            "Evaluates knowledge of Redux's broader ecosystem (middleware, dev tools)."
          ],
          "keyConcepts": [
            "Router State",
            "Redux Store",
            "Global State",
            "Middleware Logic",
            "Debugging",
            "Prop Drilling"
          ],
          "evaluationCriteria": [
            "Identification of valid, distinct scenarios",
            "Depth of explanation for each scenario",
            "Demonstration of architectural insight"
          ],
          "example": "",
          "tags": [
            "Architecture",
            "Redux",
            "React Router",
            "Best Practices"
          ],
          "prerequisites": [
            "Redux Advanced",
            "React Router Advanced"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_router_state_navigation_6",
          "topic": "Programmatic Navigation",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary difference between dispatching `push('/new-path')` and `replace('/new-path')` from `react-router-redux`?",
          "answer": "`push` adds a new entry to the history stack, while `replace` overwrites the current entry.",
          "options": [
            "`push` causes a full page reload, while `replace` does not.",
            "`push` adds a new entry to the history stack, while `replace` overwrites the current entry.",
            "`push` is synchronous, while `replace` is asynchronous.",
            "`push` is for internal navigation, `replace` is for external links."
          ],
          "analysisPoints": [
            "Tests understanding of `push` vs. `replace` behavior in browser history.",
            "Crucial for correct user experience with back/forward navigation."
          ],
          "keyConcepts": [
            "push action",
            "replace action",
            "History API",
            "Programmatic Navigation"
          ],
          "evaluationCriteria": [
            "Accurate distinction between history stack manipulation",
            "Understanding of user impact"
          ],
          "example": "If you are on `/pageA` and dispatch `push('/pageB')`, your history becomes `[pageA, pageB]`. Pressing back takes you to `/pageA`. If you were on `/pageA` and dispatched `replace('/pageB')`, your history becomes `[pageB]`. Pressing back from `/pageB` (if it was the replaced entry) would take you to the page *before* `/pageA`.",
          "tags": [
            "React-Router-Redux",
            "Navigation",
            "History Management"
          ],
          "prerequisites": [
            "Browser History API"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_state_navigation_7",
          "topic": "Accessing Router State",
          "level": "medium",
          "type": "code",
          "question": "Write a `mapStateToProps` function for a React component that needs to display the current URL's pathname and any query parameters (e.g., `?search=react&type=library`). Assume the Redux state structure as `state.router.location`.",
          "answer": "```typescript\nimport { connect } from 'react-redux';\n\ninterface RootState {\n  router: {\n    location: {\n      pathname: string;\n      query: { [key: string]: string | string[] | undefined };\n    };\n  };\n}\n\ninterface MyComponentProps {\n  currentPath: string;\n  queryParams: { [key: string]: string | string[] | undefined };\n}\n\nconst mapStateToProps = (state: RootState): MyComponentProps => ({\n  currentPath: state.router.location.pathname,\n  queryParams: state.router.location.query\n});\n\n// Example usage in a connected component:\n// class MySearchComponent extends React.Component<MyComponentProps> {\n//   render() {\n//     const { currentPath, queryParams } = this.props;\n//     return (\n//       <div>\n//         <p>Current Path: {currentPath}</p>\n//         <p>Search Term: {queryParams.search || 'N/A'}</p>\n//         <p>Type: {queryParams.type || 'N/A'}</p>\n//       </div>\n//     );\n//   }\n// }\n// export default connect(mapStateToProps)(MySearchComponent);\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to correctly map `pathname` and `query` from Redux state.",
            "Checks understanding of the router state object structure."
          ],
          "keyConcepts": [
            "mapStateToProps",
            "pathname",
            "query parameters",
            "Redux State"
          ],
          "evaluationCriteria": [
            "Accurate state access paths",
            "Correct return object structure",
            "TypeScript type awareness"
          ],
          "example": "This solution directly maps the required router properties from `state.router.location` to component props, making them easily accessible for display or logic within the component.",
          "tags": [
            "Redux",
            "mapStateToProps",
            "URL Parameters",
            "Coding Task"
          ],
          "prerequisites": [
            "Redux Connect",
            "JavaScript Objects"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_state_navigation_8",
          "topic": "Redux and React Router Ecosystem",
          "level": "medium",
          "type": "open",
          "question": "What is the primary benefit of using `react-router-redux` over simply letting React Router manage its own internal state?",
          "answer": "The primary benefit of using `react-router-redux` is that it makes the router's state (current location, URL parameters, query parameters, etc.) a first-class citizen within your Redux store. This unification offers several advantages:\n\n1.  **Centralized State Management**: All application state, including navigation, is managed in one predictable Redux store. This simplifies debugging and makes state changes more transparent.\n2.  **Predictable State Updates**: Navigation changes become regular Redux actions, allowing you to use Redux middleware (e.g., Redux-Saga, Redux-Thunk) to intercept, log, or perform side effects based on route transitions. This is incredibly powerful for data fetching, analytics, or authentication checks tied to navigation.\n3.  **Global Accessibility**: Any part of your application connected to the Redux store can access the current router state without needing to be directly rendered by a `<Route>` or wrapped by `withRouter`. This reduces prop drilling and makes router information available where it's needed (e.g., in a header component that displays the current page title based on the route).\n4.  **Time-Travel Debugging**: With router state in Redux, you can leverage the Redux DevTools Extension to inspect, replay, and time-travel through navigation actions and state changes, significantly improving the debugging experience for routing-related issues.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of the 'why' behind the integration.",
            "Highlights key advantages of Redux's architecture.",
            "Emphasizes benefits for debugging and application logic."
          ],
          "keyConcepts": [
            "Centralized State",
            "Redux Middleware",
            "Debugging",
            "Predictability",
            "Global Access"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of benefits",
            "Clear articulation of Redux principles",
            "Identification of practical advantages"
          ],
          "example": "",
          "tags": [
            "Redux",
            "React Router",
            "Architecture",
            "Benefits"
          ],
          "prerequisites": [
            "Redux Core Concepts",
            "React Router Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_router_state_navigation_9",
          "topic": "Router State",
          "level": "medium",
          "type": "flashcard",
          "question": "How do you access the path parameters (e.g., `id` from `/users/:id`) from the Redux store when using `react-router-redux`?",
          "answer": "Through `state.router.match.params`",
          "options": [],
          "analysisPoints": [
            "Tests specific knowledge of the Redux state structure for route matching.",
            "Distinguishes from `location` properties."
          ],
          "keyConcepts": [
            "Path Parameters",
            "Redux State",
            "match.params"
          ],
          "evaluationCriteria": [
            "Accurate path recall"
          ],
          "example": "If the URL is `/users/42`, then `state.router.match.params.id` would be `\"42\"`.",
          "tags": [
            "Redux State",
            "URL Parameters",
            "React-Router-Redux"
          ],
          "prerequisites": [
            "Redux State Access",
            "React Router Parameters"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_url_parameters_1",
          "topic": "URL Parameters",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you define a URL parameter in a React Router `Route` path?",
          "answer": "By prefixing the parameter name with a colon, e.g., `/users/:id`.",
          "options": [],
          "analysisPoints": [
            "Tests basic syntax for route definition.",
            "Fundamental to dynamic routing."
          ],
          "keyConcepts": [
            "Route Definition",
            "URL Parameters",
            "React Router"
          ],
          "evaluationCriteria": [
            "Correct syntax recall"
          ],
          "example": "<Route path=\"/posts/:slug\" component={PostDetail} />",
          "tags": [
            "React Router",
            "Routing"
          ],
          "prerequisites": [
            "React Router Basics"
          ],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_url_parameters_2",
          "topic": "URL Parameters",
          "level": "medium",
          "type": "mcq",
          "question": "In a class component rendered by React Router, if the route is `/products/:productId` and the URL is `/products/book-123`, how would you access `book-123` within the component?",
          "answer": "`this.props.match.params.productId`",
          "options": [
            "`this.props.location.query.productId`",
            "`this.props.params.productId`",
            "`this.props.match.productId`",
            "`this.props.match.params.productId`"
          ],
          "analysisPoints": [
            "Tests knowledge of the `match` prop structure.",
            "Distinguishes `match.params` from other prop properties.",
            "Ensures understanding of parameter naming matching the route definition."
          ],
          "keyConcepts": [
            "match prop",
            "Path Parameters",
            "RouteComponentProps"
          ],
          "evaluationCriteria": [
            "Accurate prop access",
            "Understanding of parameter object structure"
          ],
          "example": "```typescript\ninterface ProductDetailParams { productId: string; }\ninterface ProductDetailProps extends RouteComponentProps<ProductDetailParams> { /* ... */ }\n\nclass ProductDetail extends React.Component<ProductDetailProps> {\n  componentDidMount() {\n    console.log(this.props.match.params.productId); // Outputs: 'book-123'\n  }\n  render() { /* ... */ }\n}\n```",
          "tags": [
            "React Router",
            "URL Parameters",
            "Component Props"
          ],
          "prerequisites": [
            "React Component Props",
            "React Router Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_url_parameters_3",
          "topic": "URL Parameters",
          "level": "medium",
          "type": "open",
          "question": "When fetching data in a React component based on a URL parameter, what lifecycle methods (for class components) or hooks (for functional components) would you typically use, and why?",
          "answer": "For class components, you would typically use `componentDidMount` and `componentDidUpdate`:\n\n*   **`componentDidMount()`**: This method is called once when the component is first mounted (inserted into the DOM). It's the ideal place to perform initial data fetching based on the URL parameter, as the component is ready and the `match.params` are available.\n*   **`componentDidUpdate(prevProps)`**: This method is called after every re-render (except the initial one). You need to use this to handle cases where the URL parameter changes *without* the component unmounting and remounting (e.g., navigating from `/users/1` to `/users/2`). Inside `componentDidUpdate`, you would compare `this.props.match.params.id` with `prevProps.match.params.id` and re-fetch data if they differ.\n\nFor functional components (using React Hooks, introduced in React 16.8):\n\n*   **`useEffect`**: This hook is used for side effects. You would typically use `useEffect` to fetch data. The dependencies array of `useEffect` is crucial here:\n    ```typescript\n    import React, { useEffect } from 'react';\n    import { useParams } from 'react-router-dom';\n\n    function UserProfile() {\n      const { userId } = useParams<{ userId: string }>();\n\n      useEffect(() => {\n        if (userId) {\n          console.log('Fetching user data for ID:', userId);\n          // fetchUserData(userId);\n        }\n      }, [userId]); // Dependency array: effect runs when userId changes\n\n      return <div>User ID: {userId}</div>;\n    }\n    ```\n    By including `userId` in the dependency array, the effect will run initially and also whenever the `userId` parameter in the URL changes, mimicking the behavior of `componentDidMount` and `componentDidUpdate` combined for this specific data fetching pattern.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of component lifecycle for data fetching.",
            "Covers both class components and functional components with Hooks.",
            "Emphasizes the importance of handling parameter changes (updates)."
          ],
          "keyConcepts": [
            "componentDidMount",
            "componentDidUpdate",
            "useEffect",
            "URL Parameters",
            "Data Fetching",
            "React Lifecycle"
          ],
          "evaluationCriteria": [
            "Correct lifecycle method/hook identification",
            "Clear explanation of their purpose",
            "Handling of parameter changes"
          ],
          "example": "",
          "tags": [
            "React",
            "Data Fetching",
            "Lifecycle Methods",
            "React Hooks"
          ],
          "prerequisites": [
            "React Component Lifecycle",
            "React Hooks Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_url_parameters_4",
          "topic": "URL Parameters",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the difference between `path parameters` and `query parameters` in a URL?",
          "answer": "Path parameters are integral parts of the URL path that identify a specific resource (e.g., `/users/123`). Query parameters are appended to the URL after a `?` and provide additional filtering or sorting options (e.g., `/users?status=active&page=2`).",
          "options": [],
          "analysisPoints": [
            "Tests fundamental URL structure understanding.",
            "Crucial for correct route and data handling."
          ],
          "keyConcepts": [
            "Path Parameters",
            "Query Parameters",
            "URL Structure"
          ],
          "evaluationCriteria": [
            "Accurate definition of each parameter type"
          ],
          "example": "URL: `/products/electronics?sort=price_asc&limit=10`\nPath parameter: `electronics` (from `/products/:category`)\nQuery parameters: `sort=price_asc`, `limit=10`",
          "tags": [
            "URL",
            "Routing",
            "Web Fundamentals"
          ],
          "prerequisites": [
            "Web Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_url_parameters_5",
          "topic": "URL Parameters",
          "level": "medium",
          "type": "code",
          "question": "Given a route `<Route path=\"/search\" component={SearchPage} />` and a URL `/search?query=react&page=1`, write the `mapStateToProps` function to extract `query` and `page` parameters from the Redux state (assuming `state.router.location.query` structure).",
          "answer": "```typescript\nimport { connect } from 'react-redux';\n\ninterface RootState {\n  router: {\n    location: {\n      query: { [key: string]: string | string[] | undefined };\n    };\n  };\n}\n\ninterface SearchPageProps {\n  searchTerm?: string;\n  currentPage?: string;\n}\n\nconst mapStateToProps = (state: RootState): SearchPageProps => ({\n  searchTerm: state.router.location.query.query, // 'query' is the name of the URL query param\n  currentPage: state.router.location.query.page\n});\n\n// Example usage in a connected component:\n// class SearchPage extends React.Component<SearchPageProps> {\n//   render() {\n//     const { searchTerm, currentPage } = this.props;\n//     return (\n//       <div>\n//         <p>Search Term: {searchTerm || 'N/A'}</p>\n//         <p>Current Page: {currentPage || '1'}</p>\n//       </div>\n//     );\n//   }\n// }\n// export default connect(mapStateToProps)(SearchPage);\n```",
          "options": [],
          "analysisPoints": [
            "Tests correct access of query parameters from Redux state.",
            "Verifies understanding of how `location.query` object works."
          ],
          "keyConcepts": [
            "Query Parameters",
            "mapStateToProps",
            "Redux State",
            "location.query"
          ],
          "evaluationCriteria": [
            "Accurate state path for query parameters",
            "Correct property access within `query` object"
          ],
          "example": "This solution correctly extracts `query` and `page` from the `state.router.location.query` object, making them available as `searchTerm` and `currentPage` props to the component.",
          "tags": [
            "Redux",
            "URL Parameters",
            "mapStateToProps",
            "Coding Task"
          ],
          "prerequisites": [
            "Redux Connect",
            "JavaScript Objects"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_url_parameters_6",
          "topic": "React Router Props",
          "level": "medium",
          "type": "open",
          "question": "Outline the `this.props` object structure that a component receives when rendered by a React Router `Route`, focusing on the properties relevant to URL and route matching.",
          "answer": "When a React component is rendered by a React Router `Route`, it receives an object as `this.props` (for class components) or as arguments (for functional components using `useRouteMatch`, `useLocation`, `useParams`). The key properties relevant to URL and route matching are:\n\n1.  **`match`**: An object containing information about how the `<Route path>` matched the URL. It has the following properties:\n    *   `path`: (string) The path pattern used to match (e.g., `/users/:id`).\n    *   `url`: (string) The matched portion of the URL (e.g., `/users/123`). This is useful for building nested routes.\n    *   `isExact`: (boolean) `true` if the entire URL was matched exactly.\n    *   `params`: (object) An object containing key-value pairs of URL parameters. The keys correspond to the named segments in the `path` (e.g., if `path` is `/users/:id`, `params` would be `{ id: '123' }`).\n\n2.  **`location`**: An object representing the current URL. It has the following properties:\n    *   `pathname`: (string) The path of the URL (e.g., `/dashboard/settings`).\n    *   `search`: (string) The URL's query string (e.g., `?name=John&age=30`). This string includes the leading `?`.\n    *   `hash`: (string) The URL's hash fragment (e.g., `#section1`). This string includes the leading `#`.\n    *   `state`: (any) A value that was passed to `push` or `replace` via the `state` option.\n\n3.  **`history`**: An object containing methods to manipulate the browser's session history (e.g., `history.push()`, `history.replace()`, `history.goBack()`).\n\nThese props provide comprehensive access to the current route context, allowing components to read URL parameters, query strings, and programmatically navigate.",
          "options": [],
          "analysisPoints": [
            "Tests detailed knowledge of React Router's prop structure.",
            "Requires breakdown of `match`, `location`, and `history` objects.",
            "Emphasizes the utility of each sub-property."
          ],
          "keyConcepts": [
            "match prop",
            "location prop",
            "history prop",
            "URL Parameters",
            "Query Parameters",
            "RouteComponentProps"
          ],
          "evaluationCriteria": [
            "Accuracy and completeness of property descriptions",
            "Clarity of explanation for each sub-property",
            "Structural understanding of props object"
          ],
          "example": "",
          "tags": [
            "React Router",
            "Component Props",
            "Routing Fundamentals"
          ],
          "prerequisites": [
            "React Router Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_configure_redux_router_store",
          "title": "Configure Redux Store with `react-router-redux` and DevTools",
          "description": "\nImplement the `configureStore` function that sets up a Redux store, integrating `react-router-redux` middleware and enabling the Redux DevTools Extension for development environments.\n\n**Requirements:**\n1.  The function should accept `initialState` and a `history` object as arguments.\n2.  It must apply `routerMiddleware` using the provided `history` object.\n3.  It should use `rootReducer` (assume it's available and correctly imported).\n4.  It must conditionally enable the Redux DevTools Extension using `window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__` in non-production environments.\n5.  Return the configured Redux store.\n",
          "difficulty": "medium",
          "startingCode": "import { createStore, applyMiddleware, compose } from 'redux';\nimport { routerMiddleware } from 'react-router-redux';\nimport rootReducer from './rootReducer'; // Assume rootReducer is defined elsewhere\n\n/**\n * Configures and returns a Redux store with router middleware and DevTools integration.\n * @param initialState The initial state of the Redux store.\n * @param history The history object from 'history' library (e.g., createBrowserHistory()).\n * @returns The configured Redux store.\n */\nexport default function configureStore(initialState: any, history: any) {\n  // TODO: Implement the store configuration\n  // 1. Create router middleware\n  // 2. Define other middlewares (if any)\n  // 3. Create store enhancers array\n  // 4. Conditionally setup composeEnhancers for Redux DevTools\n  // 5. Create and return the store\n  \n  return null; // Replace with your store instance\n}\n",
          "solutionCode": "import { createStore, applyMiddleware, compose } from 'redux';\nimport { routerMiddleware } from 'react-router-redux';\nimport rootReducer from './rootReducer'; // Assume rootReducer is defined elsewhere\n\nexport default function configureStore(initialState: any, history: any) {\n  const routerMW = routerMiddleware(history);\n  \n  const middleWares = [\n    routerMW,\n    // You can add other middleware here, e.g., thunk or saga:\n    // thunk, \n    // sagaMiddleware\n  ];\n  \n  const enhancers = [\n    applyMiddleware(...middleWares)\n  ];\n  \n  // Conditionally add Redux DevTools Extension if available\n  // This ensures DevTools only loads in development and if the extension is present.\n  const composeEnhancers =\n    process.env.NODE_ENV !== 'production' &&\n    typeof window === 'object' &&\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?\n    (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : compose;\n  \n  const store = createStore(\n    rootReducer,\n    initialState,\n    composeEnhancers(...enhancers),\n  );\n  \n  return store;\n}\n",
          "testCases": [
            "Test that `configureStore` returns a Redux store object.",
            "Test that `routerMiddleware` is applied to the store (can be inferred by store setup).",
            "Test that `composeEnhancers` is used correctly (e.g., inspect `store.dispatch` in a mock environment).",
            "Verify that DevTools integration logic is conditional based on `process.env.NODE_ENV`."
          ],
          "hints": [
            "Remember to spread the `middleWares` array when passing it to `applyMiddleware`.",
            "The `composeEnhancers` logic needs to check both `NODE_ENV` and the existence of the DevTools extension on the `window` object.",
            "Ensure `rootReducer` is correctly passed as the first argument to `createStore`."
          ],
          "tags": [
            "Redux",
            "Store Configuration",
            "Middleware",
            "DevTools",
            "React-Router-Redux",
            "TypeScript"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "Redux Core Concepts",
            "JavaScript Modules",
            "Environment Variables"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Redux `createStore`",
            "Redux `applyMiddleware`",
            "Redux `compose`",
            "`react-router-redux` basics"
          ]
        },
        {
          "id": "task_route_info_navigation_component",
          "title": "Implement Route Info Display and Programmatic Navigation Component",
          "description": "\nCreate a React class component named `NavigationDashboard` that is connected to the Redux store. This component should:\n\n1.  Display the current URL's `pathname` from the Redux store.\n2.  Display any `query parameters` (e.g., `?lang=en&theme=dark`) from the Redux store.\n3.  Display any `path parameters` (e.g., `id` from `/users/:id`) from the Redux store. Assume a route like `/detail/:id` for testing path parameters.\n4.  Include a button that, when clicked, programmatically navigates to a new route (e.g., `/settings`) by dispatching a Redux action using the `push` action creator from `react-router-redux`.\n\n**Assumptions:**\n*   Your Redux store is configured with `react-router-redux`.\n*   `state.router.location` and `state.router.match` are available in your Redux state.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport { connect } from 'react-redux';\nimport { push } from 'react-router-redux';\n\ninterface RootState {\n  router: {\n    location: {\n      pathname: string;\n      query: { [key: string]: string | string[] | undefined };\n    };\n    match: {\n      params: { [key: string]: string | undefined };\n    };\n  };\n}\n\ninterface NavigationDashboardProps {\n  currentPath: string;\n  queryParams: { [key: string]: string | string[] | undefined };\n  pathParams: { [key: string]: string | undefined };\n  navigateTo: (path: string) => void;\n}\n\nclass NavigationDashboard extends React.Component<NavigationDashboardProps> {\n  handleNavigateClick = () => {\n    // TODO: Dispatch action to navigate to '/settings'\n  };\n\n  render() {\n    const { currentPath, queryParams, pathParams } = this.props;\n    \n    return (\n      <div>\n        <h2>Navigation Dashboard</h2>\n        <p>Current Path: <strong>{currentPath}</strong></p>\n        <p>Query Params: <code>{JSON.stringify(queryParams)}</code></p>\n        <p>Path Params: <code>{JSON.stringify(pathParams)}</code></p>\n        <button onClick={this.handleNavigateClick}>Go to Settings</button>\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = (state: RootState) => ({\n  // TODO: Map router state to props\n  currentPath: '', // Placeholder\n  queryParams: {}, // Placeholder\n  pathParams: {},  // Placeholder\n});\n\nconst mapDispatchToProps = (dispatch: any) => ({\n  // TODO: Map navigation action to props\n  navigateTo: (path: string) => {}\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(NavigationDashboard);\n",
          "solutionCode": "import React from 'react';\nimport { connect } from 'react-redux';\nimport { push } from 'react-router-redux';\n\ninterface RootState {\n  router: {\n    location: {\n      pathname: string;\n      query: { [key: string]: string | string[] | undefined };\n    };\n    match: {\n      params: { [key: string]: string | undefined };\n    };\n  };\n}\n\ninterface NavigationDashboardProps {\n  currentPath: string;\n  queryParams: { [key: string]: string | string[] | undefined };\n  pathParams: { [key: string]: string | undefined };\n  navigateTo: (path: string) => void;\n}\n\nclass NavigationDashboard extends React.Component<NavigationDashboardProps> {\n  handleNavigateClick = () => {\n    this.props.navigateTo('/settings');\n  };\n\n  render() {\n    const { currentPath, queryParams, pathParams } = this.props;\n    \n    return (\n      <div>\n        <h2>Navigation Dashboard</h2>\n        <p>Current Path: <strong>{currentPath}</strong></p>\n        <p>Query Params: <code>{JSON.stringify(queryParams)}</code></p>\n        <p>Path Params: <code>{JSON.stringify(pathParams)}</code></p>\n        <button onClick={this.handleNavigateClick}>Go to Settings</button>\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = (state: RootState) => ({\n  currentPath: state.router.location.pathname,\n  queryParams: state.router.location.query,\n  pathParams: state.router.match.params,\n});\n\nconst mapDispatchToProps = (dispatch: any) => ({\n  navigateTo: (path: string) => dispatch(push(path))\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(NavigationDashboard);\n",
          "testCases": [
            "Render the component on path `/`. Verify `Current Path` is `/`, and `Query/Path Params` are empty objects.",
            "Render the component on path `/products/123?color=red`. Verify `Current Path` is `/products/123`, `Query Params` contains `{ color: 'red' }`, and `Path Params` contains `{ id: '123' }` (assuming route `/products/:id`).",
            "Click the 'Go to Settings' button. Verify that a navigation action to `/settings` is dispatched and the URL changes (requires mocking history or running in a browser environment)."
          ],
          "hints": [
            "Ensure the `mapStateToProps` function correctly accesses the `router` slice of your Redux state and its `location` and `match` sub-properties.",
            "For `mapDispatchToProps`, import the `push` action creator from `react-router-redux`.",
            "Remember to call `this.props.navigateTo` with the target path in your button click handler."
          ],
          "tags": [
            "React",
            "Redux",
            "React-Router-Redux",
            "mapStateToProps",
            "mapDispatchToProps",
            "Programmatic Navigation",
            "URL Parameters",
            "TypeScript"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Components",
            "Redux Connect",
            "Basic React Router"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Redux state access",
            "Component-Redux connection",
            "React event handling"
          ]
        },
        {
          "id": "task_fetch_user_data_by_url_param",
          "title": "Fetch User Data Based on URL Parameter",
          "description": "\nImplement a React class component named `UserProfile` that displays user details. This component should:\n\n1.  Be rendered by a React Router `Route` with a path parameter for user ID (e.g., `/users/:id`).\n2.  Extract the `id` parameter from `this.props.match.params`.\n3.  Simulate fetching user data when the component mounts and whenever the `id` parameter in the URL changes.\n4.  Display the fetched `userId` and a loading indicator.\n\n**Requirements:**\n*   Use `componentDidMount` for initial data fetch.\n*   Use `componentDidUpdate` to re-fetch data if the `id` parameter changes.\n*   Simulate data fetching with a `setTimeout` to mimic an asynchronous API call.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport { RouteComponentProps } from 'react-router-dom';\n\ninterface UserProfileParams {\n  id: string;\n}\n\ninterface UserProfileProps extends RouteComponentProps<UserProfileParams> {}\n\ninterface UserProfileState {\n  loading: boolean;\n  userId: string | null;\n}\n\nclass UserProfile extends React.Component<UserProfileProps, UserProfileState> {\n  state: UserProfileState = {\n    loading: false,\n    userId: null,\n  };\n\n  componentDidMount() {\n    // TODO: Fetch user data for the initial ID\n  }\n\n  componentDidUpdate(prevProps: UserProfileProps) {\n    // TODO: Check if ID changed and re-fetch data\n  }\n\n  fetchUserData = (id: string) => {\n    this.setState({ loading: true, userId: null });\n    setTimeout(() => {\n      // Simulate API call success\n      this.setState({ loading: false, userId: id });\n      console.log(`User data fetched for ID: ${id}`);\n    }, 1000);\n  };\n\n  render() {\n    const { loading, userId } = this.state;\n    const currentParamId = this.props.match.params.id;\n\n    return (\n      <div>\n        <h2>User Profile</h2>\n        <p>Current URL Param ID: <strong>{currentParamId}</strong></p>\n        {loading ? (\n          <p>Loading user data...</p>\n        ) : userId ? (\n          <p>Displaying data for User ID: {userId}</p>\n        ) : (\n          <p>No user data loaded.</p>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default UserProfile;\n",
          "solutionCode": "import React from 'react';\nimport { RouteComponentProps } from 'react-router-dom';\n\ninterface UserProfileParams {\n  id: string;\n}\n\ninterface UserProfileProps extends RouteComponentProps<UserProfileParams> {}\n\ninterface UserProfileState {\n  loading: boolean;\n  userId: string | null;\n}\n\nclass UserProfile extends React.Component<UserProfileProps, UserProfileState> {\n  state: UserProfileState = {\n    loading: false,\n    userId: null,\n  };\n\n  componentDidMount() {\n    const userId = this.props.match.params.id;\n    if (userId) {\n      this.fetchUserData(userId);\n    }\n  }\n\n  componentDidUpdate(prevProps: UserProfileProps) {\n    const currentUserId = this.props.match.params.id;\n    const prevUserId = prevProps.match.params.id;\n\n    // Re-fetch only if the ID has actually changed\n    if (currentUserId !== prevUserId) {\n      if (currentUserId) {\n        this.fetchUserData(currentUserId);\n      }\n    }\n  }\n\n  fetchUserData = (id: string) => {\n    this.setState({ loading: true, userId: null });\n    setTimeout(() => {\n      // Simulate API call success\n      this.setState({ loading: false, userId: id });\n      console.log(`User data fetched for ID: ${id}`);\n    }, 1000);\n  };\n\n  render() {\n    const { loading, userId } = this.state;\n    const currentParamId = this.props.match.params.id;\n\n    return (\n      <div>\n        <h2>User Profile</h2>\n        <p>Current URL Param ID: <strong>{currentParamId}</strong></p>\n        {loading ? (\n          <p>Loading user data...</p>\n        ) : userId ? (\n          <p>Displaying data for User ID: {userId}</p>\n        ) : (\n          <p>No user data loaded.</p>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default UserProfile;\n",
          "testCases": [
            "Render `UserProfile` for `/users/1`. Verify 'Loading...' appears, then 'Displaying data for User ID: 1'.",
            "Navigate from `/users/1` to `/users/2` without unmounting the component. Verify 'Loading...' appears again, then 'Displaying data for User ID: 2'.",
            "Render `UserProfile` for `/users/abc`. Verify it fetches data for 'abc'."
          ],
          "hints": [
            "The `id` parameter is available via `this.props.match.params.id`.",
            "In `componentDidUpdate`, compare `this.props.match.params.id` with `prevProps.match.params.id` to determine if a re-fetch is necessary.",
            "Ensure your `fetchUserData` function correctly updates the component's state for loading and data."
          ],
          "tags": [
            "React",
            "React Router",
            "URL Parameters",
            "Lifecycle Methods",
            "Data Fetching",
            "State Management",
            "TypeScript"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "React Class Components",
            "React Router Basics",
            "Asynchronous JavaScript"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component lifecycle",
            "Conditional rendering",
            "Asynchronous operations in React"
          ]
        }
      ]
    }
  },
  {
    "id": "3a25c798-a73d-4e5f-a7d8-25481a1caaf2",
    "startLine": 6800,
    "endLine": 6899,
    "processedDate": "2025-06-17T10:07:31.844Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_hooks_introduction",
          "title": "Introduction to React Hooks",
          "content": "React Hooks, introduced in React 16.8, are functions that allow you to \"hook into\" React state and lifecycle features from function components. Before Hooks, these features were primarily available only in class components. Hooks enable developers to write functional components that can manage state, side effects, and other React features, leading to more concise, readable, and reusable code.\n\n### Why Hooks?\n\nBefore Hooks, managing state and side effects in functional components was not possible. Developers had to convert functional components to class components to use features like `state`, `componentDidMount`, etc. Hooks provide an alternative to classes, allowing for:\n\n*   **Reusability:** Custom Hooks can encapsulate reusable stateful logic.\n*   **Simplicity:** Often leads to less boilerplate code compared to classes.\n*   **Readability:** Easier to follow the logic within components.\n*   **Improved stateful logic sharing:** Stateful logic can be extracted and tested independently.\n\n### Basic Rules of Hooks\n\nWhile not explicitly in the provided text, understanding these rules is crucial for correct Hook usage:\n\n1.  **Only call Hooks at the top level:** Don't call Hooks inside loops, conditions, or nested functions.\n2.  **Only call Hooks from React Function Components:** Don't call Hooks from regular JavaScript functions (unless it's a custom Hook).",
          "examples": [],
          "relatedQuestions": [
            "question_hooks_intro_1",
            "question_hooks_intro_2",
            "question_hooks_intro_3",
            "question_hooks_intro_4"
          ],
          "relatedTasks": [],
          "tags": [
            "React",
            "Hooks",
            "Introduction",
            "Functional Components",
            "State Management"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "javascript_es6_features"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_state_management",
            "react_lifecycle_methods",
            "custom_hooks"
          ]
        },
        {
          "id": "theory_react_usestate_hook",
          "title": "The useState Hook: Managing Component State",
          "content": "The `useState` hook is a fundamental React Hook that allows functional components to manage and update their internal state. It provides a way to declare a state variable within a functional component, enabling it to be dynamic and interactive.\n\n### Basic Usage\n\nTo use `useState`, you import it from React and call it inside your functional component. It returns an array with two elements:\n\n1.  **Current State Value:** The current value of the state variable.\n2.  **State Updater Function:** A function to update that state variable. When this function is called, React re-renders the component with the new state value.\n\nThe `useState` hook takes one argument: the initial value for the state variable. This initial value is only used during the component's initial render.\n\n```typescript\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  // Declare a state variable named \"count\" with initial value 0\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n```\n\nIn the `Counter` example:\n*   `count` is the current state value (initially `0`).\n*   `setCount` is the function used to update `count`.\n*   `useState(0)` initializes `count` to `0`.\n*   Clicking the button calls `setCount(count + 1)`, which updates `count` and triggers a re-render.\n\n### Multiple State Variables\n\nYou can declare multiple state variables within a single functional component by calling `useState` multiple times. This is often useful when different pieces of state are unrelated or are updated independently.\n\n```typescript\nfunction UserForm() {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n  const [age, setAge] = useState(0);\n  \n  return (\n    <form>\n      <input\n        value={name}\n        onChange={e => setName(e.target.value)}\n        placeholder=\"Name\"\n      />\n      <input\n        value={email}\n        onChange={e => setEmail(e.target.value)}\n        placeholder=\"Email\"\n      />\n      <input\n        type=\"number\"\n        value={age}\n        onChange={e => setAge(Number(e.target.value))}\n        placeholder=\"Age\"\n      />\n    </form>\n  );\n}\n```\n\nThis `UserForm` component uses three separate `useState` calls for `name`, `email`, and `age`. Each state variable can be updated independently without affecting the others.\n\n### Object State\n\nWhen you have related pieces of state, it's often more organized to group them into a single object and manage that object as a single state variable. However, when updating object state, you must remember that React state updates are merged for objects only if you use a class component's `setState`. With `useState`, you **must manually merge** (or spread) the previous state with the new updates, as `useState` replaces the old state entirely with the new value you pass to the setter function.\n\nTo ensure proper updates and avoid losing parts of your state, it's common practice to use the functional update form of the setter function (`setProfile(prevProfile => ({ ...prevProfile, [name]: value }))`). This form receives the *previous* state as an argument, ensuring you're working with the most up-to-date state when performing updates.\n\n```typescript\nfunction ProfileForm() {\n  const [profile, setProfile] = useState({\n    name: '',\n    email: '',\n    bio: ''\n  });\n  \n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setProfile(prevProfile => ({\n      ...prevProfile,\n      [name]: value\n    }));\n  };\n  \n  return (\n    <form>\n      <input\n        name=\"name\"\n        value={profile.name}\n        onChange={handleChange}\n        placeholder=\"Name\"\n      />\n      <input\n        name=\"email\"\n        value={profile.email}\n        onChange={handleChange}\n        placeholder=\"Email\"\n      />\n      <textarea\n        name=\"bio\"\n        value={profile.bio}\n        onChange={handleChange}\n        placeholder=\"Bio\"\n      />\n    </form>\n  );\n}\n```\n\nIn `ProfileForm`:\n*   `profile` is a single state object.\n*   `handleChange` uses the `setProfile` updater function with a callback `prevProfile => ({ ...prevProfile, [name]: value })`. This ensures that other properties of `profile` (e.g., `email` and `bio` when `name` is updated) are preserved, and only the specific property `[name]` is updated with its `value`.",
          "examples": [
            {
              "id": "example_usestate_basic_counter",
              "title": "Basic Counter with useState",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates the simplest use of `useState` to manage a numerical counter. `count` holds the current value, and `setCount` is used to increment it. The component re-renders every time `setCount` is called, displaying the updated `count`.",
              "language": "typescript"
            },
            {
              "id": "example_usestate_multiple_variables",
              "title": "Managing Multiple Independent State Variables",
              "code": "import React, { useState } from 'react';\n\nfunction UserForm() {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n  const [age, setAge] = useState(0);\n  \n  return (\n    <form>\n      <input\n        value={name}\n        onChange={e => setName(e.target.value)}\n        placeholder=\"Name\"\n      />\n      <input\n        value={email}\n        onChange={e => setEmail(e.target.value)}\n        placeholder=\"Email\"\n      />\n      <input\n        type=\"number\"\n        value={age}\n        onChange={e => setAge(Number(e.target.value))}\n        placeholder=\"Age\"\n      />\n    </form>\n  );\n}",
              "explanation": "This example shows how to use multiple `useState` calls for independent pieces of state (`name`, `email`, `age`). Each state variable has its own setter function, allowing for granular updates without affecting other state variables.",
              "language": "typescript"
            },
            {
              "id": "example_usestate_object_state",
              "title": "Managing State as an Object with Immutable Updates",
              "code": "import React, { useState } from 'react';\n\nfunction ProfileForm() {\n  const [profile, setProfile] = useState({\n    name: '',\n    email: '',\n    bio: ''\n  });\n  \n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    // Use the functional update form and spread operator to ensure immutability\n    setProfile(prevProfile => ({\n      ...prevProfile,\n      [name]: value\n    }));\n  };\n  \n  return (\n    <form>\n      <input\n        name=\"name\"\n        value={profile.name}\n        onChange={handleChange}\n        placeholder=\"Name\"\n      />\n      <input\n        name=\"email\"\n        value={profile.email}\n        onChange={handleChange}\n        placeholder=\"Email\"\n      />\n      <textarea\n        name=\"bio\"\n        value={profile.bio}\n        onChange={handleChange}\n        placeholder=\"Bio\"\n      />\n    </form>\n  );\n}",
              "explanation": "This example demonstrates managing related state as a single object. Crucially, when updating a property within the `profile` object, the `setProfile` function uses a functional update (`prevProfile => ...`) and the spread syntax (`...prevProfile`) to create a new object. This ensures immutability, preventing direct modification of the previous state object and ensuring React detects the change and re-renders.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_usestate_1",
            "question_usestate_2",
            "question_usestate_3",
            "question_usestate_4",
            "question_usestate_5",
            "question_usestate_6",
            "question_usestate_7",
            "question_usestate_8",
            "question_usestate_9",
            "question_usestate_10"
          ],
          "relatedTasks": [
            "task_todo_list",
            "task_user_profile_editor",
            "task_filterable_product_grid"
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "State Management",
            "Functional Components",
            "Immutability",
            "Forms"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "javascript_array_destructuring",
            "javascript_objects",
            "javascript_spread_syntax"
          ],
          "complexity": 7,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_forms",
            "react_data_flow",
            "react_performance_optimization"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_hooks_intro_1",
          "topic": "Introduction to React Hooks",
          "level": "easy",
          "type": "flashcard",
          "question": "What are React Hooks?",
          "answer": "Functions that let you \"hook into\" React state and lifecycle features from function components.",
          "options": [],
          "analysisPoints": [
            "Defines Hooks as functions.",
            "Highlights their purpose: accessing state and lifecycle features.",
            "Specifies their usage in function components."
          ],
          "keyConcepts": [
            "React Hooks",
            "Functional Components",
            "State Management",
            "Lifecycle Methods"
          ],
          "evaluationCriteria": [
            "Ability to define core concepts.",
            "Understanding of Hooks' basic utility."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Definition"
          ],
          "prerequisites": [
            "react_functional_components"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_hooks_intro_2",
          "topic": "Introduction to React Hooks",
          "level": "easy",
          "type": "mcq",
          "question": "When were React Hooks introduced?",
          "answer": "React 16.8",
          "options": [
            "React 15.0",
            "React 16.0",
            "React 16.8",
            "React 17.0"
          ],
          "analysisPoints": [
            "Tests factual recall of a specific React version.",
            "Confirms understanding of the timeline of React features."
          ],
          "keyConcepts": [
            "React Hooks",
            "React Version"
          ],
          "evaluationCriteria": [
            "Factual recall.",
            "Knowledge of React's evolution."
          ],
          "example": "React 16.8 marked a significant release that brought Hooks, enabling stateful logic in functional components without relying on class components.",
          "tags": [
            "React",
            "Hooks",
            "History"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_hooks_intro_3",
          "topic": "Introduction to React Hooks",
          "level": "medium",
          "type": "open",
          "question": "What problem do React Hooks aim to solve compared to traditional class components?",
          "answer": "React Hooks aim to solve several problems associated with class components, primarily:\n\n1.  **Complexity of Class Components:** Classes can be confusing for both humans and machines, especially with concepts like `this` binding, which often leads to boilerplate code.\n2.  **Difficulty in Reusing Stateful Logic:** It was hard to reuse stateful logic between components. Patterns like Higher-Order Components (HOCs) and Render Props help, but they add nesting and complexity (wrapper hell).\n3.  **Complex Lifecycle Methods:** Lifecycle methods like `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` often contained related but separate logic (e.g., data fetching and event listeners), making them difficult to understand and refactor.\n4.  **No state/lifecycle in Functional Components:** Before Hooks, functional components were stateless and couldn't use lifecycle methods, limiting their utility for complex UIs.",
          "analysisPoints": [
            "Identifies issues with `this` binding in classes.",
            "Explains the difficulty of code reuse without Hooks (HOCs/Render Props adding complexity).",
            "Discusses the problem of scattered logic across lifecycle methods.",
            "Highlights the limitation of functional components before Hooks."
          ],
          "keyConcepts": [
            "React Hooks",
            "Class Components",
            "State Management",
            "Lifecycle Methods",
            "Code Reusability"
          ],
          "evaluationCriteria": [
            "Depth of understanding of Hooks' motivation.",
            "Ability to articulate the limitations of class components.",
            "Knowledge of common design patterns before Hooks."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Class Components",
            "Comparison",
            "Motivation"
          ],
          "prerequisites": [
            "react_class_components",
            "react_functional_components"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_intro_4",
          "topic": "Introduction to React Hooks",
          "level": "medium",
          "type": "flashcard",
          "question": "Can you use Hooks inside conditional statements (e.g., `if` statements) or loops?",
          "answer": "No, Hooks must be called at the top level of your React functional component. They cannot be called inside loops, conditions, or nested functions. This rule ensures that Hooks are called in the same order on every render, which is crucial for React to correctly associate local state with each Hook.",
          "options": [],
          "analysisPoints": [
            "Confirms knowledge of the 'Rules of Hooks'.",
            "Explains the underlying reason for the rule (consistent order of calls).",
            "Emphasizes the importance for React's internal mechanism."
          ],
          "keyConcepts": [
            "React Hooks",
            "Rules of Hooks",
            "Component Re-render"
          ],
          "evaluationCriteria": [
            "Knowledge of core Hook rules.",
            "Understanding of implications of rule violations."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Rules",
            "Best Practices"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_usestate_1",
          "topic": "useState Hook - Basic Usage",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `useState` Hook?",
          "answer": "The `useState` hook allows functional components to have state.",
          "options": [],
          "analysisPoints": [
            "Identifies the core function of `useState`.",
            "Connects `useState` specifically to functional components."
          ],
          "keyConcepts": [
            "useState",
            "React State",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Basic understanding of `useState`'s role."
          ],
          "example": "",
          "tags": [
            "React",
            "useState",
            "State Management"
          ],
          "prerequisites": [
            "react_functional_components"
          ],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_usestate_2",
          "topic": "useState Hook - Basic Usage",
          "level": "easy",
          "type": "mcq",
          "question": "Consider the following React component:\n\n```jsx\nimport React, { useState } from 'react';\n\nfunction Greeter() {\n  const [message, setMessage] = useState('Hello');\n  \n  return (\n    <div>\n      <p>{message}</p>\n      <button onClick={() => setMessage('Hola!')}>Change Greeting</button>\n    </div>\n  );\n}\n```\nWhat will be displayed on the screen immediately after the component first renders?",
          "answer": "Hello",
          "options": [
            "Hello",
            "Hola!",
            "Undefined",
            "An empty string"
          ],
          "analysisPoints": [
            "Tests understanding of `useState`'s initial value.",
            "Confirms that the initial state is rendered first."
          ],
          "keyConcepts": [
            "useState",
            "Initial State",
            "Component Rendering"
          ],
          "evaluationCriteria": [
            "Ability to trace state initialization.",
            "Understanding of initial component render."
          ],
          "example": "The `useState('Hello')` call sets the initial value of the `message` state variable to 'Hello'. Therefore, when the component first renders, `<p>{message}</p>` will display 'Hello'. The button click event, which updates the state to 'Hola!', will only execute after the user interacts with the button.",
          "tags": [
            "React",
            "useState",
            "Initial State",
            "Rendering"
          ],
          "prerequisites": [
            "react_basics",
            "react_functional_components"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_usestate_3",
          "topic": "useState Hook - Return Value",
          "level": "medium",
          "type": "mcq",
          "question": "What does the `useState` hook return?",
          "answer": "An array with the current state value and a function to update it.",
          "options": [
            "An object containing the state and a setState method.",
            "Only the current state value.",
            "A function to update the state, and the state value itself.",
            "An array with the current state value and a function to update it."
          ],
          "analysisPoints": [
            "Tests precise knowledge of `useState`'s return signature.",
            "Distinguishes `useState` from class component `this.state` and `this.setState`.",
            "Highlights the array destructuring pattern."
          ],
          "keyConcepts": [
            "useState",
            "Array Destructuring",
            "State Updater Function"
          ],
          "evaluationCriteria": [
            "Accuracy in describing `useState`'s return type.",
            "Understanding of array destructuring in the context of Hooks."
          ],
          "example": "The `useState` hook returns a pair of values in an array: `[stateVariable, setStateVariable]`. `stateVariable` holds the current state, and `setStateVariable` is the function that allows you to update that state. This is why we use array destructuring `const [count, setCount] = useState(0);`.",
          "tags": [
            "React",
            "useState",
            "API",
            "Destructuring"
          ],
          "prerequisites": [
            "javascript_array_destructuring"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_usestate_4",
          "topic": "useState Hook - Object State Updates",
          "level": "medium",
          "type": "mcq",
          "question": "Given the `ProfileForm` component from the theory:\n\n```jsx\nfunction ProfileForm() {\n  const [profile, setProfile] = useState({\n    name: '',\n    email: '',\n    bio: ''\n  });\n  \n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setProfile(prevProfile => ({\n      ...prevProfile,\n      [name]: value\n    }));\n  };\n  \n  return (\n    <form>\n      <input name=\"name\" value={profile.name} onChange={handleChange} placeholder=\"Name\" />\n      <input name=\"email\" value={profile.email} onChange={handleChange} placeholder=\"Email\" />\n      <textarea name=\"bio\" value={profile.bio} onChange={handleChange} placeholder=\"Bio\" />\n    </form>\n  );\n}\n```\n\nIf the user types 'Alice' into the 'Name' input field, and the initial `profile` state was `{ name: '', email: 'test@example.com', bio: '...' }`, what will the `profile` state be after the change?",
          "answer": "{ name: 'Alice', email: 'test@example.com', bio: '...' }",
          "options": [
            "{ name: 'Alice' }",
            "{ name: 'Alice', email: '', bio: '' }",
            "{ name: 'Alice', email: 'test@example.com', bio: '...' }",
            "Undefined"
          ],
          "analysisPoints": [
            "Tests understanding of immutable updates for object state with `useState`.",
            "Confirms knowledge of the spread operator (`...prevProfile`) to preserve existing state.",
            "Highlights the importance of functional updates to get the latest state."
          ],
          "keyConcepts": [
            "useState",
            "Object State",
            "Immutability",
            "Spread Syntax",
            "Functional Update"
          ],
          "evaluationCriteria": [
            "Ability to trace state changes in complex scenarios.",
            "Understanding of why `...prevProfile` is necessary.",
            "Recognition of correct state update patterns."
          ],
          "example": "The `handleChange` function uses `setProfile(prevProfile => ({ ...prevProfile, [name]: value }))`. The `...prevProfile` part ensures that all existing properties (`email`, `bio`) from the previous state are copied into the new state object. Then, `[name]: value` (which becomes `name: 'Alice'`) overrides or adds the specific property. Thus, the `email` and `bio` fields retain their original values, while `name` is updated.",
          "tags": [
            "React",
            "useState",
            "Object State",
            "Immutability",
            "Forms"
          ],
          "prerequisites": [
            "javascript_spread_syntax",
            "react_functional_updates"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_usestate_5",
          "topic": "useState Hook - Multiple vs. Object State",
          "level": "medium",
          "type": "open",
          "question": "When would you prefer to use multiple `useState` calls for individual state variables instead of a single `useState` call with an object for all related states?",
          "answer": "You would typically prefer multiple `useState` calls for individual state variables when:\n\n1.  **Independent Updates:** The state variables are largely independent and are updated separately. For example, a form with unrelated fields like `firstName`, `lastName`, and `isSubmitting` might use separate states if `isSubmitting` doesn't directly relate to `firstName` or `lastName`'s updates.\n2.  **Performance Optimization (less common):** When you only update one small part of a large state object, `useState` with an object would still cause a re-render of the component. If you have many deeply nested properties and frequent updates to only a few, separate `useState` calls might lead to more granular re-renders (though `React.memo` and `useCallback` are usually better tools for performance).\n3.  **Simplicity for Primitive Types:** For simple primitive values (numbers, strings, booleans), individual `useState` calls are often simpler and more straightforward than wrapping them in an object.\n4.  **Avoiding Accidental Overwrites:** When using an object, if you forget to spread the previous state (`...prevProfile`), you will accidentally overwrite the entire object, losing other state properties. Separate `useState` calls prevent this specific pitfall.",
          "analysisPoints": [
            "Discusses the independence of state updates.",
            "Mentions potential, albeit less common, performance implications.",
            "Highlights simplicity for primitive types.",
            "Addresses the risk of accidental state overwrites with objects."
          ],
          "keyConcepts": [
            "useState",
            "Multiple State",
            "Object State",
            "Performance",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Ability to weigh pros and cons of different state management approaches.",
            "Understanding of practical scenarios for each method.",
            "Awareness of common pitfalls."
          ],
          "example": "",
          "tags": [
            "React",
            "useState",
            "Best Practices",
            "Design Patterns"
          ],
          "prerequisites": [
            "react_state_management",
            "react_performance"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_usestate_6",
          "topic": "useState Hook - Functional Updates",
          "level": "hard",
          "type": "mcq",
          "question": "Consider the following component:\n\n```jsx\nimport React, { useState } from 'react';\n\nfunction CrazyCounter() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    setCount(count + 1); // Line 1\n    setCount(count + 1); // Line 2\n    setCount(count + 1); // Line 3\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Increment Thrice</button>\n    </div>\n  );\n}\n```\n\nIf the current `count` is 0, what will `count` be after the 'Increment Thrice' button is clicked once?",
          "answer": "1",
          "options": [
            "0",
            "1",
            "2",
            "3"
          ],
          "analysisPoints": [
            "Tests understanding of asynchronous nature of `setState` (or `setCount`).",
            "Explains how multiple updates within the same render cycle batch.",
            "Contrasts direct value updates with functional updates (`prevCount => prevCount + 1`)."
          ],
          "keyConcepts": [
            "useState",
            "Asynchronous Updates",
            "State Batching",
            "Functional Updates"
          ],
          "evaluationCriteria": [
            "Deep understanding of `useState`'s update mechanism.",
            "Ability to predict state changes with multiple synchronous updates.",
            "Knowledge of React's batching behavior."
          ],
          "example": "When `handleClick` is called, React batches the state updates. All three `setCount(count + 1)` calls will read the `count` value from the *closure* of that specific render, which is `0`. So, effectively, all three calls are `setCount(0 + 1)`, resulting in `setCount(1)`. Due to batching, only one re-render occurs, and the final `count` will be `1`. To correctly increment by 3, you would use the functional update form: `setCount(prevCount => prevCount + 1);` three times.",
          "tags": [
            "React",
            "useState",
            "Advanced",
            "Batching",
            "Asynchronous"
          ],
          "prerequisites": [
            "javascript_closures",
            "react_state_updates"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_usestate_7",
          "topic": "useState Hook - Immutability",
          "level": "medium",
          "type": "open",
          "question": "Why is it important to update state immutably when using `useState` with objects or arrays, and what might happen if you don't?",
          "answer": "It is crucial to update state immutably when using `useState` with objects or arrays because:\n\n1.  **React's Change Detection:** React relies on shallow comparison to determine if a component needs to re-render. If you mutate the original state object or array directly, the reference to that object/array remains the same. React's shallow comparison will not detect a change, and thus, the component will not re-render, leading to an outdated UI.\n2.  **Side Effects & Predictability:** Direct mutation can lead to unpredictable behavior and hard-to-debug issues, especially when state is shared or passed down to child components. It breaks the concept of unidirectional data flow.\n3.  **Optimizations:** Immutability facilitates performance optimizations like `React.memo` or `useMemo`/`useCallback`, which rely on referential equality checks to prevent unnecessary re-renders.\n\n**What might happen if you don't:**\n\n*   **UI Not Updating:** The most common issue is that your UI will not reflect the latest state changes, as React won't trigger a re-render.\n*   **Difficult Debugging:** It becomes very hard to track when and where state was mutated, making debugging challenging.\n*   **Broken Optimizations:** Components wrapped with `React.memo` or using `useMemo`/`useCallback` might not re-render or re-compute when they should, leading to stale data being displayed or incorrect logic.",
          "analysisPoints": [
            "Explains React's shallow comparison mechanism.",
            "Highlights the impact on UI updates and re-renders.",
            "Discusses the benefits for predictability and debugging.",
            "Connects immutability to React's performance optimizations.",
            "Clearly outlines the negative consequences of mutable updates."
          ],
          "keyConcepts": [
            "useState",
            "Immutability",
            "State Updates",
            "Re-rendering",
            "Shallow Comparison",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of immutability's importance.",
            "Ability to explain the underlying mechanisms (shallow comparison).",
            "Knowledge of practical consequences of violating immutability."
          ],
          "example": "",
          "tags": [
            "React",
            "useState",
            "Immutability",
            "Best Practices",
            "Debugging",
            "Performance"
          ],
          "prerequisites": [
            "javascript_object_reference",
            "react_state_updates"
          ],
          "complexity": 8,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_usestate_8",
          "topic": "useState Hook - Code Challenge",
          "level": "medium",
          "type": "code",
          "question": "Create a React functional component named `ToggleButton` that displays text 'OFF' and a button. When the button is clicked, the text should toggle between 'ON' and 'OFF'.",
          "answer": "```typescript\nimport React, { useState } from 'react';\n\nfunction ToggleButton() {\n  const [isOn, setIsOn] = useState(false); // Initial state is 'OFF'\n\n  const toggleState = () => {\n    setIsOn(prevIsOn => !prevIsOn); // Toggle the boolean state\n  };\n\n  return (\n    <div>\n      <p>{isOn ? 'ON' : 'OFF'}</p>\n      <button onClick={toggleState}>Toggle</button>\n    </div>\n  );\n}\n\n// Example Usage (for testing):\n// function App() {\n//   return <ToggleButton />;\n// }\n// export default App;\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `useState` to manage boolean state.",
            "Implements a toggle mechanism using the setter function.",
            "Renders dynamic text based on state.",
            "Attaches event handler correctly to the button."
          ],
          "keyConcepts": [
            "useState",
            "Boolean State",
            "Event Handling",
            "Conditional Rendering"
          ],
          "evaluationCriteria": [
            "Correct application of `useState`.",
            "Ability to implement basic UI interactions.",
            "Clean and readable code structure."
          ],
          "example": "This component uses `useState(false)` to initialize a boolean `isOn` state. The `toggleState` function uses the functional update `prevIsOn => !prevIsOn` to ensure the state is correctly toggled based on its previous value, even if updates are batched. The `p` tag uses a ternary operator to display 'ON' or 'OFF' based on the `isOn` state.",
          "tags": [
            "React",
            "useState",
            "Code Challenge",
            "Beginner"
          ],
          "prerequisites": [
            "react_functional_components",
            "javascript_boolean"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_usestate_9",
          "topic": "useState Hook - Flashcard",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of the `prevProfile` argument in the `setProfile` callback: `setProfile(prevProfile => ({ ...prevProfile, [name]: value }))`?",
          "answer": "`prevProfile` represents the most recent *previous* state of the `profile` object at the time the update is performed. Using it ensures you're basing your new state on the actual current state, which is crucial for correct updates, especially when updates are asynchronous or batched.",
          "options": [],
          "analysisPoints": [
            "Defines `prevProfile` as the previous state.",
            "Explains its importance for correctness with asynchronous updates.",
            "Connects it to batching behavior."
          ],
          "keyConcepts": [
            "useState",
            "Functional Updates",
            "Asynchronous Updates",
            "State Batching",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Understanding of functional update form.",
            "Knowledge of state update nuances."
          ],
          "example": "",
          "tags": [
            "React",
            "useState",
            "Functional Updates",
            "Immutability"
          ],
          "prerequisites": [
            "react_state_updates"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_usestate_10",
          "topic": "useState Hook - Code Challenge",
          "level": "hard",
          "type": "code",
          "question": "Refactor the `UserForm` component to manage all form fields (name, email, age) using a single `useState` call with an object. Ensure updates are immutable.",
          "answer": "```typescript\nimport React, { useState } from 'react';\n\nfunction UserFormRefactored() {\n  const [formData, setFormData] = useState({\n    name: '',\n    email: '',\n    age: 0\n  });\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n    const { name, value } = e.target;\n    setFormData(prevFormData => ({\n      ...prevFormData,\n      [name]: name === 'age' ? Number(value) : value, // Handle age conversion\n    }));\n  };\n  \n  return (\n    <form>\n      <input\n        name=\"name\"\n        value={formData.name}\n        onChange={handleChange}\n        placeholder=\"Name\"\n      />\n      <input\n        name=\"email\"\n        value={formData.email}\n        onChange={handleChange}\n        placeholder=\"Email\"\n      />\n      <input\n        type=\"number\"\n        name=\"age\"\n        value={formData.age}\n        onChange={handleChange}\n        placeholder=\"Age\"\n      />\n    </form>\n  );\n}\n\n// Example Usage (for testing):\n// function App() {\n//   return <UserFormRefactored />;\n// }\n// export default App;\n```",
          "options": [],
          "analysisPoints": [
            "Successfully consolidates multiple `useState` calls into one object state.",
            "Correctly implements the immutable update pattern using functional `setFormData` and spread syntax.",
            "Handles type conversion for number inputs (`age`).",
            "Uses dynamic key access (`[name]`) for generic change handler."
          ],
          "keyConcepts": [
            "useState",
            "Object State",
            "Immutability",
            "Functional Updates",
            "Dynamic Keys",
            "Forms"
          ],
          "evaluationCriteria": [
            "Ability to refactor and optimize state management.",
            "Proficiency in immutable object updates.",
            "Handling of different input types.",
            "Creating a generic change handler."
          ],
          "example": "This solution refactors the `UserForm` to use a single `formData` state object. The `handleChange` function is made generic: it extracts `name` and `value` from the event target. It then uses the functional update form `setFormData(prevFormData => ({ ...prevFormData, [name]: value }))` to create a new state object that includes all previous properties and updates only the specific property corresponding to the input's `name` attribute. Special handling for `age` ensures it's converted to a number.",
          "tags": [
            "React",
            "useState",
            "Refactoring",
            "Code Challenge",
            "Forms",
            "Immutability"
          ],
          "prerequisites": [
            "react_forms",
            "javascript_spread_syntax",
            "javascript_dynamic_object_keys"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_todo_list",
          "title": "Implement a Basic To-Do List with useState",
          "description": "\nCreate a React functional component for a simple To-Do List application. Your component should:\n\n1.  Allow users to add new To-Do items via an input field and a 'Add To-Do' button.\n2.  Display the list of To-Do items below the input.\n3.  Each To-Do item should have a 'Delete' button next to it.\n4.  When the 'Delete' button is clicked, the corresponding To-Do item should be removed from the list.\n5.  Display a count of active (undeleted) To-Do items.\n\nYour solution should primarily use the `useState` hook for state management.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\nfunction TodoList() {\n  // TODO: Declare state variables for new todo item input and the list of todos\n  \n  // TODO: Implement functions for adding a todo, deleting a todo\n  \n  return (\n    <div>\n      <h1>Simple To-Do List</h1>\n      <div>\n        <input \n          type=\"text\"\n          placeholder=\"Add a new todo\"\n          // TODO: Bind value and onChange\n        />\n        <button // TODO: Add onClick handler\n        >Add To-Do</button>\n      </div>\n      <p>Active Todos: { /* TODO: Display active todo count */ }</p>\n      <ul>\n        {/* TODO: Map over todos and render each item with a delete button */}\n      </ul>\n    </div>\n  );\n}\n\n// Example usage:\n// function App() {\n//   return <TodoList />;\n// }\n// export default App;\n",
          "solutionCode": "import React, { useState } from 'react';\n\nfunction TodoList() {\n  const [newTodo, setNewTodo] = useState('');\n  const [todos, setTodos] = useState([]);\n\n  const handleAddTodo = () => {\n    if (newTodo.trim() !== '') {\n      setTodos(prevTodos => [...prevTodos, { id: Date.now(), text: newTodo }]);\n      setNewTodo(''); // Clear input after adding\n    }\n  };\n\n  const handleDeleteTodo = (idToDelete) => {\n    setTodos(prevTodos => prevTodos.filter(todo => todo.id !== idToDelete));\n  };\n\n  return (\n    <div>\n      <h1>Simple To-Do List</h1>\n      <div>\n        <input \n          type=\"text\"\n          value={newTodo}\n          onChange={(e) => setNewTodo(e.target.value)}\n          onKeyPress={(e) => { // Allow adding with Enter key\n            if (e.key === 'Enter') {\n              handleAddTodo();\n            }\n          }}\n          placeholder=\"Add a new todo\"\n        />\n        <button onClick={handleAddTodo}>Add To-Do</button>\n      </div>\n      <p>Active Todos: {todos.length}</p>\n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id}>\n            {todo.text}\n            <button onClick={() => handleDeleteTodo(todo.id)} style={{ marginLeft: '10px' }}>Delete</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n",
          "testCases": [
            "Should display 'Simple To-Do List' heading and 'Active Todos: 0' initially.",
            "Typing 'Learn React' into the input and clicking 'Add To-Do' should add 'Learn React' to the list and increment active todos to 1. Input should clear.",
            "Adding multiple items ('Buy groceries', 'Walk dog') should add them to the list and update the count correctly.",
            "Clicking 'Delete' next to an item should remove it from the list and decrement the active todo count.",
            "Adding an empty or whitespace-only string should not add an item to the list and should not clear the input.",
            "Should correctly handle adding items by pressing 'Enter' key in the input field."
          ],
          "hints": [
            "You will need two `useState` hooks: one for the current input value and another for the array of todo items.",
            "Remember that state updates for arrays (and objects) must be immutable. Use the spread operator (`...`) when adding or filtering items.",
            "Each todo item in your array should probably have a unique ID (e.g., using `Date.now()` or a counter) for the `key` prop when rendering lists."
          ],
          "tags": [
            "React",
            "useState",
            "Forms",
            "List Rendering",
            "Immutability",
            "CRUD"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_functional_components",
            "javascript_array_methods",
            "javascript_events"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "react_keys",
            "react_event_handling",
            "javascript_array_filter",
            "javascript_array_map"
          ]
        },
        {
          "id": "task_user_profile_editor",
          "title": "Build a User Profile Editor with Complex Object State",
          "description": "\nDevelop a React functional component called `UserProfileEditor` that allows editing user profile information. The profile should include:\n\n*   `firstName` (string)\n*   `lastName` (string)\n*   `email` (string)\n*   `address` (an object with `street`, `city`, `zipCode` - all strings)\n\nRequirements:\n\n1.  Manage all profile data using a **single `useState` hook** with a nested object.\n2.  Create input fields for `firstName`, `lastName`, `email`, `street`, `city`, and `zipCode`.\n3.  Implement a generic `handleChange` function that correctly updates the nested `address` object immutably, as well as top-level properties.\n4.  Display the current JSON representation of the `profile` state below the form for debugging purposes.\n5.  Add a 'Reset' button that reverts all fields to their initial empty state.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\n\nfunction UserProfileEditor() {\n  const initialProfileState = {\n    firstName: '',\n    lastName: '',\n    email: '',\n    address: {\n      street: '',\n      city: '',\n      zipCode: ''\n    }\n  };\n\n  const [profile, setProfile] = useState(initialProfileState);\n\n  // TODO: Implement a generic handleChange function\n  const handleChange = (e) => {\n    // Hint: Consider how to handle nested objects. \n    // You might need to check the 'name' attribute for properties inside 'address'.\n    // Remember to use functional updates and spread syntax for immutability.\n  };\n\n  // TODO: Implement reset function\n  const handleReset = () => {\n    // Hint: How can you leverage the initialProfileState?\n  };\n\n  return (\n    <div>\n      <h1>User Profile Editor</h1>\n      <form>\n        {/* TODO: Add input fields for firstName, lastName, email */}\n        <input name=\"firstName\" value={profile.firstName} onChange={handleChange} placeholder=\"First Name\" />\n        {/* ... other top-level inputs ... */}\n\n        <h2>Address</h2>\n        {/* TODO: Add input fields for street, city, zipCode */}\n        <input name=\"street\" value={profile.address.street} onChange={handleChange} placeholder=\"Street\" />\n        {/* ... other address inputs ... */}\n\n        <button type=\"button\" onClick={handleReset}>Reset</button>\n      </form>\n      \n      <h3>Current Profile State:</h3>\n      <pre>{JSON.stringify(profile, null, 2)}</pre>\n    </div>\n  );\n}\n\n// Example usage:\n// function App() {\n//   return <UserProfileEditor />;\n// }\n// export default App;\n",
          "solutionCode": "import React, { useState } from 'react';\n\nfunction UserProfileEditor() {\n  const initialProfileState = {\n    firstName: '',\n    lastName: '',\n    email: '',\n    address: {\n      street: '',\n      city: '',\n      zipCode: ''\n    }\n  };\n\n  const [profile, setProfile] = useState(initialProfileState);\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const { name, value } = e.target;\n\n    setProfile(prevProfile => {\n      // Check if the field is part of the address object\n      if (name in prevProfile.address) {\n        return {\n          ...prevProfile,\n          address: {\n            ...prevProfile.address, // Spread previous address properties\n            [name]: value           // Update specific address property\n          }\n        };\n      } else {\n        // Otherwise, update top-level properties\n        return {\n          ...prevProfile,\n          [name]: value\n        };\n      }\n    });\n  };\n\n  const handleReset = () => {\n    setProfile(initialProfileState);\n  };\n\n  return (\n    <div style={{ maxWidth: '500px', margin: '20px auto', padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <h1>User Profile Editor</h1>\n      <form style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>\n        <label>First Name:\n          <input name=\"firstName\" value={profile.firstName} onChange={handleChange} placeholder=\"First Name\" />\n        </label>\n        <label>Last Name:\n          <input name=\"lastName\" value={profile.lastName} onChange={handleChange} placeholder=\"Last Name\" />\n        </label>\n        <label>Email:\n          <input name=\"email\" type=\"email\" value={profile.email} onChange={handleChange} placeholder=\"Email\" />\n        </label>\n\n        <h2>Address</h2>\n        <label>Street:\n          <input name=\"street\" value={profile.address.street} onChange={handleChange} placeholder=\"Street\" />\n        </label>\n        <label>City:\n          <input name=\"city\" value={profile.address.city} onChange={handleChange} placeholder=\"City\" />\n        </label>\n        <label>Zip Code:\n          <input name=\"zipCode\" value={profile.address.zipCode} onChange={handleChange} placeholder=\"Zip Code\" />\n        </label>\n\n        <button type=\"button\" onClick={handleReset} style={{ marginTop: '15px', padding: '10px', backgroundColor: '#f44336', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>Reset</button>\n      </form>\n      \n      <h3>Current Profile State:</h3>\n      <pre style={{ backgroundColor: '#f0f0f0', padding: '10px', borderRadius: '4px', overflowX: 'auto' }}>\n        {JSON.stringify(profile, null, 2)}\n      </pre>\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: All fields should be empty, and the JSON display should match `initialProfileState`.",
            "Updating 'firstName': Typing 'John' should update `profile.firstName` to 'John' without affecting other fields. JSON should reflect this.",
            "Updating 'street': Typing '123 Main St' should update `profile.address.street` without affecting other fields. JSON should reflect this.",
            "Updating 'email': Typing 'john@example.com' should update `profile.email` correctly.",
            "Updating multiple fields: Change `firstName`, `city`, and `zipCode`. All changes should be reflected correctly in the `profile` state.",
            "Clicking 'Reset': All fields should revert to their initial empty values, and the JSON display should match `initialProfileState`."
          ],
          "hints": [
            "The `handleChange` function will need to determine if the input field's `name` corresponds to a top-level property or a nested property (like inside `address`).",
            "For nested objects, you'll need to create *new* objects at each level of nesting using the spread syntax (`...`) to maintain immutability.",
            "The 'Reset' function can simply set the state back to your `initialProfileState` constant."
          ],
          "tags": [
            "React",
            "useState",
            "Object State",
            "Forms",
            "Immutability",
            "Nested State"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_forms",
            "javascript_spread_syntax",
            "javascript_dynamic_object_keys",
            "javascript_object_methods"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "react_controlled_components",
            "react_functional_updates",
            "javascript_immutability"
          ]
        },
        {
          "id": "task_filterable_product_grid",
          "title": "Create a Filterable Product Grid",
          "description": "\nBuild a React functional component `ProductGrid` that displays a list of products and allows users to filter them.\n\nRequirements:\n\n1.  Initialize a list of mock product data (at least 5-7 products with `id`, `name`, `category`, `price`).\n2.  Implement an input field for searching products by `name`.\n3.  Implement a dropdown (select element) for filtering products by `category`.\n4.  Use `useState` to manage the search term and the selected category.\n5.  Dynamically display only the products that match both the current search term (case-insensitive, partial match) AND the selected category.\n6.  If no category is selected, all categories should be considered.\n7.  Display a message if no products match the current filters.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\n\nconst mockProducts = [\n  { id: 1, name: 'Laptop', category: 'Electronics', price: 1200 },\n  { id: 2, name: 'Keyboard', category: 'Electronics', price: 75 },\n  { id: 3, name: 'T-Shirt', category: 'Apparel', price: 25 },\n  { id: 4, name: 'Jeans', category: 'Apparel', price: 60 },\n  { id: 5, name: 'Coffee Maker', category: 'Home Goods', price: 100 },\n  { id: 6, name: 'Mouse', category: 'Electronics', price: 30 },\n  { id: 7, name: 'Blender', category: 'Home Goods', price: 80 },\n];\n\nfunction ProductGrid() {\n  // TODO: Declare state for search term and selected category\n\n  // TODO: Implement filtering logic\n  const filteredProducts = mockProducts.filter(product => {\n    // Your filtering logic here\n    return true; // Placeholder\n  });\n\n  const categories = [...new Set(mockProducts.map(p => p.category))];\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h1>Product Catalog</h1>\n      <div style={{ marginBottom: '20px' }}>\n        {/* TODO: Add search input */}\n        <input\n          type=\"text\"\n          placeholder=\"Search products...\"\n          // TODO: Bind value and onChange\n        />\n        {/* TODO: Add category dropdown */}\n        <select // TODO: Bind value and onChange\n        >\n          <option value=\"\">All Categories</option>\n          {categories.map(cat => (\n            <option key={cat} value={cat}>{cat}</option>\n          ))}\n        </select>\n      </div>\n      \n      <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '20px' }}>\n        {filteredProducts.length === 0 ? (\n          <p>No products match your filters.</p>\n        ) : (\n          filteredProducts.map(product => (\n            <div key={product.id} style={{ border: '1px solid #ddd', padding: '15px', borderRadius: '8px' }}>\n              <h3>{product.name}</h3>\n              <p>Category: {product.category}</p>\n              <p>Price: ${product.price}</p>\n            </div>\n          ))\n        )}\n      </div>\n    </div>\n  );\n}\n\n// Example usage:\n// function App() {\n//   return <ProductGrid />;\n// }\n// export default App;\n",
          "solutionCode": "import React, { useState } from 'react';\n\nconst mockProducts = [\n  { id: 1, name: 'Laptop', category: 'Electronics', price: 1200 },\n  { id: 2, name: 'Keyboard', category: 'Electronics', price: 75 },\n  { id: 3, name: 'T-Shirt', category: 'Apparel', price: 25 },\n  { id: 4, name: 'Jeans', category: 'Apparel', price: 60 },\n  { id: 5, name: 'Coffee Maker', category: 'Home Goods', price: 100 },\n  { id: 6, name: 'Mouse', category: 'Electronics', price: 30 },\n  { id: 7, name: 'Blender', category: 'Home Goods', price: 80 },\n];\n\nfunction ProductGrid() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [selectedCategory, setSelectedCategory] = useState('');\n\n  const filteredProducts = mockProducts.filter(product => {\n    const matchesSearch = product.name.toLowerCase().includes(searchTerm.toLowerCase());\n    const matchesCategory = selectedCategory === '' || product.category === selectedCategory;\n    return matchesSearch && matchesCategory;\n  });\n\n  const categories = [...new Set(mockProducts.map(p => p.category))];\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h1>Product Catalog</h1>\n      <div style={{ marginBottom: '20px', display: 'flex', gap: '10px' }}>\n        <input\n          type=\"text\"\n          placeholder=\"Search products...\"\n          value={searchTerm}\n          onChange={(e) => setSearchTerm(e.target.value)}\n          style={{ padding: '8px', borderRadius: '4px', border: '1px solid #ddd', flex: 1 }}\n        />\n        <select\n          value={selectedCategory}\n          onChange={(e) => setSelectedCategory(e.target.value)}\n          style={{ padding: '8px', borderRadius: '4px', border: '1px solid #ddd' }}\n        >\n          <option value=\"\">All Categories</option>\n          {categories.map(cat => (\n            <option key={cat} value={cat}>{cat}</option>\n          ))}\n        </select>\n      </div>\n      \n      <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '20px' }}>\n        {filteredProducts.length === 0 ? (\n          <p style={{ gridColumn: '1 / -1', textAlign: 'center', color: '#888' }}>No products match your filters.</p>\n        ) : (\n          filteredProducts.map(product => (\n            <div key={product.id} style={{ border: '1px solid #ddd', padding: '15px', borderRadius: '8px', boxShadow: '2px 2px 5px rgba(0,0,0,0.1)' }}>\n              <h3 style={{ margin: '0 0 10px 0', color: '#333' }}>{product.name}</h3>\n              <p style={{ margin: '0', fontSize: '0.9em', color: '#666' }}>Category: {product.category}</p>\n              <p style={{ margin: '5px 0 0 0', fontWeight: 'bold', color: '#007bff' }}>Price: ${product.price}</p>\n            </div>\n          ))\n        )}\n      </div>\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: All mock products should be displayed.",
            "Search by name: Typing 'mouse' into search bar should show only 'Mouse'.",
            "Search by name (case-insensitive): Typing 'laptop' should show 'Laptop'.",
            "Filter by category: Selecting 'Apparel' from dropdown should show 'T-Shirt' and 'Jeans'.",
            "Combine filters: Search 'key' and select 'Electronics' should show 'Keyboard'.",
            "No matching products: Search 'xyz' and select 'Electronics' should show 'No products match your filters.'",
            "Clearing category filter: Select 'Electronics', then select 'All Categories'. All currently matching search results should reappear.",
            "Empty search term: With an empty search term, all products in the selected category should be shown.",
            "Empty category selection: With 'All Categories' selected, only the search term should filter the products."
          ],
          "hints": [
            "You'll need two separate `useState` variables: one for the `searchTerm` (string) and one for the `selectedCategory` (string).",
            "The filtering logic will involve `Array.prototype.filter()`. Remember to convert strings to a consistent case (e.g., lowercase) for case-insensitive search.",
            "The category filter condition needs to handle the 'All Categories' case, where `selectedCategory` might be an empty string.",
            "The `categories` array for the dropdown can be dynamically generated from `mockProducts` using `new Set()` to get unique categories."
          ],
          "tags": [
            "React",
            "useState",
            "Filtering",
            "Search",
            "Dynamic Content",
            "Data Display"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "react_forms",
            "javascript_array_methods",
            "javascript_string_methods",
            "javascript_sets"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "react_controlled_components",
            "javascript_higher_order_functions",
            "react_hooks_patterns"
          ]
        }
      ]
    }
  },
  {
    "id": "b527fff4-a1d1-449f-88cb-b9696f82b8d6",
    "startLine": 6900,
    "endLine": 6999,
    "processedDate": "2025-06-17T10:08:49.299Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_lazy_initial_state",
          "title": "Lazy Initial State with useState Hook",
          "content": "The `useState` hook in React allows functional components to manage local state. When the initial state calculation is computationally expensive, React provides a mechanism to perform this calculation only once, during the component's initial render. This is achieved by passing a function (an 'initializer function') to `useState` instead of the direct initial value.\n\nWhen `useState` receives a function, it executes that function only during the first render to derive the initial state. Subsequent re-renders of the component will not re-execute this initializer function, thus optimizing performance by avoiding unnecessary computations. This is particularly useful when the initial state depends on complex calculations, heavy data processing, or involves reading from local storage.\n\n## Key Concepts\n-   **Initializer Function**: A function passed to `useState` that computes and returns the initial state.\n-   **Lazy Initialization**: The initializer function is executed only once, on the very first render of the component.\n-   **Performance Optimization**: Prevents expensive calculations from running on every re-render, improving application efficiency.\n\n## Syntax\n```typescript\nconst [state, setState] = useState(() => {\n  // Expensive calculation here\n  return initialValue;\n});\n```\n",
          "examples": [
            {
              "id": "example_lazy_initial_state_1",
              "title": "Basic Lazy Initial State",
              "code": "import React, { useState } from 'react';\n\nfunction computeExpensiveValue() {\n  // Simulate a heavy calculation\n  console.log('Performing expensive initial calculation...');\n  let sum = 0;\n  for (let i = 0; i < 1000000; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\nfunction ExpensiveInitialState() {\n  const [count, setCount] = useState(() => {\n    console.log('Computing initial state in useState...');\n    return computeExpensiveValue();\n  });\n  \n  console.log('Component rendered or re-rendered...');\n\n  return (\n    <div>\n      <h2>Lazy Initial State Example</h2>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\n      <button onClick={() => setCount(prev => prev - 1)}>Decrement Count</button>\n    </div>\n  );\n}\n\nexport default ExpensiveInitialState;",
              "explanation": "This example demonstrates the use of a function to initialize state. The `computeExpensiveValue()` function, which simulates a long-running calculation, is called only once when the `ExpensiveInitialState` component first mounts. Subsequent clicks on the 'Increment Count' or 'Decrement Count' buttons will cause the component to re-render, but `computeExpensiveValue()` will not be invoked again, as indicated by the console logs. This ensures that the expensive operation is not unnecessarily repeated.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_lazy_state_1",
            "question_lazy_state_2",
            "question_lazy_state_3"
          ],
          "relatedTasks": [
            "task_lazy_initial_state_1"
          ],
          "tags": [
            "React",
            "useState",
            "Hooks",
            "Performance",
            "Optimization"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_useState_hook"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_performance_optimization",
            "custom_hooks_with_expensive_state"
          ]
        },
        {
          "id": "theory_array_state_management_immutability",
          "title": "Array State Management and Immutability in React",
          "content": "Managing array state in React requires careful adherence to immutability principles. React components re-render when their state or props change. For objects and arrays, React performs a shallow comparison to detect changes. If you mutate the original array directly (e.g., using `push`, `pop`, `splice`), the reference to the array in memory remains the same, even though its contents have changed. React's shallow comparison might then miss the update, leading to unexpected behavior or components not re-rendering.\n\nTo ensure React detects state changes and re-renders correctly, you must always update arrays (and objects) immutably. This means creating a *new* array with the desired changes, rather than modifying the existing one. This new array will have a different memory reference, prompting React to recognize the state change and trigger a re-render.\n\n## Key Immutable Approaches for Array Updates:\n\n-   **Adding Items**: Use the spread syntax (`...`) to create a new array that includes all existing items plus the new item(s).\n    ```typescript\n    setItems([...items, newItem]); // Add to end\n    setItems([newItem, ...items]); // Add to beginning\n    ```\n\n-   **Removing Items**: Use the `filter()` method to create a new array containing only the items that should remain.\n    ```typescript\n    setItems(items.filter((item, index) => index !== indexToRemove));\n    // Or if items have unique IDs:\n    setItems(items.filter(item => item.id !== idToRemove));\n    ```\n\n-   **Updating Items**: Use the `map()` method to iterate over the array and return a *new* array. For the item(s) you want to update, return the modified version; for others, return the original item.\n    ```typescript\n    setItems(items.map((item, index) => \n      index === indexToUpdate ? { ...item, key: newValue } : item\n    ));\n    // Or if items have unique IDs:\n    setItems(items.map(item => \n      item.id === idToUpdate ? { ...item, key: newValue } : item\n    ));\n    ```\n\n-   **General Principle**: Never directly modify the original array with methods like `push()`, `pop()`, `splice()`, `sort()`, `reverse()`, `fill()`, or direct index assignment (e.g., `items[0] = newValue`). These methods mutate the array in place.\n\nBy consistently applying these immutable update patterns, you ensure predictable state management and reliable component re-renders in your React applications.\n",
          "examples": [
            {
              "id": "example_array_state_1",
              "title": "Array State Management Operations",
              "code": "import React, { useState } from 'react';\n\nfunction ArrayStateExample() {\n  const [items, setItems] = useState(['Apple', 'Banana', 'Cherry']);\n\n  const addItem = (newItem) => {\n    setItems([...items, newItem]);\n  };\n\n  const removeItem = (indexToRemove) => {\n    setItems(items.filter((_, index) => index !== indexToRemove));\n  };\n\n  const updateItem = (indexToUpdate, newValue) => {\n    setItems(\n      items.map((item, index) => \n        index === indexToUpdate ? newValue : item\n      )\n    );\n  };\n\n  return (\n    <div>\n      <h2>Array State Management Example</h2>\n      <ul>\n        {items.map((item, index) => (\n          <li key={index} style={{ marginBottom: '5px' }}>\n            {item}\n            <button onClick={() => removeItem(index)} style={{ marginLeft: '10px' }}>Remove</button>\n            <button onClick={() => updateItem(index, `Updated ${item}`)} style={{ marginLeft: '5px' }}>Update</button>\n          </li>\n        ))}\n      </ul>\n      <input type=\"text\" id=\"newItemInput\" placeholder=\"New item\" />\n      <button onClick={() => addItem(document.getElementById('newItemInput').value || `Item ${items.length + 1}`)} style={{ marginTop: '10px' }}>Add Item</button>\n    </div>\n  );\n}\n\nexport default ArrayStateExample;",
              "explanation": "This example demonstrates correct immutable updates for an array state in React. `addItem` uses the spread operator, `removeItem` uses `filter()`, and `updateItem` uses `map()`. Each operation returns a *new* array, ensuring React detects the state change and re-renders the component correctly. The `key={index}` is used here for simplicity in a small example, but in real-world applications, unique and stable IDs are preferred for keys when available to avoid potential issues with list re-ordering or dynamic changes.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_array_state_1",
            "question_array_state_2",
            "question_array_state_3",
            "question_array_state_4"
          ],
          "relatedTasks": [
            "task_array_state_1",
            "task_array_state_2"
          ],
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Arrays",
            "Hooks",
            "Best Practices"
          ],
          "technology": "React",
          "prerequisites": [
            "react_useState_hook",
            "javascript_array_methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "complex_forms",
            "data_tables",
            "list_rendering_optimization"
          ]
        },
        {
          "id": "theory_use_effect_hook",
          "title": "The useEffect Hook for Side Effects",
          "content": "The `useEffect` hook in React allows you to perform side effects in functional components. Side effects are operations that interact with the outside world or have an impact beyond the component's render output. Common examples include data fetching, subscriptions, manually changing the DOM (like setting `document.title`), timers, and logging.\n\n`useEffect` runs *after* every render by default. It's designed to replace lifecycle methods from class components like `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`.\n\n## Key Concepts\n-   **Side Effects**: Operations that interact with the world outside the component (e.g., network requests, DOM manipulation, subscriptions).\n-   **Synchronization**: `useEffect` synchronizes your component with an external system after rendering.\n-   **Dependency Array**: An optional second argument to `useEffect` that controls when the effect re-runs.\n    -   **No Dependency Array**: The effect runs after *every* render.\n    -   **Empty Dependency Array (`[]`)**: The effect runs only once after the initial render (similar to `componentDidMount`) and its cleanup function runs on unmount (similar to `componentWillUnmount`).\n    -   **With Dependencies (`[dep1, dep2]`)**: The effect runs after the initial render and then re-runs only if any of the values in the dependency array change between renders.\n-   **Cleanup Function**: The `useEffect` hook can optionally return a function. This function is called when the component unmounts, or before the effect re-runs (if dependencies change). This is crucial for cleaning up subscriptions, timers, or any resources to prevent memory leaks.\n\n## Lifecycle Equivalence (Conceptual)\n-   `useEffect(() => { /* effect */ });` -> `componentDidMount` and `componentDidUpdate` (for every render)\n-   `useEffect(() => { /* effect */ }, []);` -> `componentDidMount` (once on mount) and `componentWillUnmount` (for cleanup)\n-   `useEffect(() => { /* effect */ }, [dep1, dep2]);` -> `componentDidMount` and `componentDidUpdate` (when dependencies change), `componentWillUnmount` (for cleanup).\n",
          "examples": [
            {
              "id": "example_use_effect_1",
              "title": "Updating Document Title with useEffect",
              "code": "import React, { useState, useEffect } from 'react';\n\nfunction DocumentTitleExample() {\n  const [count, setCount] = useState(0);\n  const [message, setMessage] = useState('Hello');\n  \n  // This effect runs after every render, as there is no dependency array.\n  // It updates the document title based on the 'count' state.\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n    console.log(`Document title updated to: You clicked ${count} times`);\n  }); // No dependency array\n\n  // This effect runs only once on mount and cleans up on unmount.\n  // It sets up a console log for demonstration.\n  useEffect(() => {\n    console.log('Component mounted or effect re-ran due to message change (once)');\n    return () => {\n      console.log('Component unmounted or effect cleanup due to message change (once)');\n    };\n  }, [message]); // Dependency array with 'message'\n\n  // This effect runs only once after the initial render (empty dependency array)\n  useEffect(() => {\n    console.log('This effect runs only once on initial mount.');\n    const timer = setInterval(() => {\n      console.log('Timer ticking...');\n    }, 1000);\n\n    return () => {\n      console.log('Cleaning up timer on unmount.');\n      clearInterval(timer);\n    };\n  }, []); // Empty dependency array\n  \n  return (\n    <div>\n      <h2>useEffect Hook Example</h2>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me to update count</button>\n      <p>Message: {message}</p>\n      <button onClick={() => setMessage(message === 'Hello' ? 'World' : 'Hello')}>Toggle Message</button>\n    </div>\n  );\n}\n\nexport default DocumentTitleExample;",
              "explanation": "This example demonstrates `useEffect` in different scenarios:\n1.  **No dependency array**: The first `useEffect` updates `document.title` and runs after *every* render, reacting to any state change (like `count` or `message`).\n2.  **Dependency array with `message`**: The second `useEffect` runs on initial mount and then only when the `message` state changes. It includes a cleanup function that will run before the effect re-runs or when the component unmounts.\n3.  **Empty dependency array (`[]`)**: The third `useEffect` runs only once after the initial render, setting up a `setInterval`. The returned cleanup function is crucial here; it clears the interval when the component unmounts, preventing memory leaks.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_use_effect_1",
            "question_use_effect_2",
            "question_use_effect_3",
            "question_use_effect_4",
            "question_use_effect_5"
          ],
          "relatedTasks": [
            "task_use_effect_1",
            "task_use_effect_2"
          ],
          "tags": [
            "React",
            "useEffect",
            "Hooks",
            "Side Effects",
            "Lifecycle",
            "Cleanup",
            "Dependency Array"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_useState_hook"
          ],
          "complexity": 7,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_fetching",
            "integrating_third_party_libraries",
            "performance_optimization"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_lazy_state_1",
          "topic": "Lazy Initial State",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of using a function as the initial state argument in `useState`?",
          "answer": "To perform expensive initial state calculations only once, on the component's initial render, thereby optimizing performance.",
          "options": [],
          "analysisPoints": [
            "Identifies the core benefit: performance optimization.",
            "Understands the 'only once' execution."
          ],
          "keyConcepts": [
            "useState",
            "Lazy Initialization",
            "Performance"
          ],
          "evaluationCriteria": [
            "Recall of `useState` advanced usage",
            "Understanding of performance implications"
          ],
          "example": "",
          "tags": [
            "React",
            "useState",
            "Hooks",
            "Performance"
          ],
          "prerequisites": [
            "react_useState_hook"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lazy_state_2",
          "topic": "Lazy Initial State",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React component:\n\n```jsx\nfunction ExpensiveComponent() {\n  const [value, setValue] = useState(() => {\n    console.log('Calculating initial value...');\n    // Simulate expensive calculation\n    let result = 0;\n    for (let i = 0; i < 1000000; i++) result += i;\n    return result;\n  });\n\n  console.log('Component rendered');\n\n  return (\n    <div>\n      <p>Value: {value}</p>\n      <button onClick={() => setValue(value + 1)}>Increment</button>\n    </div>\n  );\n}\n```\n\nHow many times will 'Calculating initial value...' be logged when the component mounts and then the 'Increment' button is clicked once?",
          "answer": "1 time",
          "options": [
            "0 times",
            "1 time",
            "2 times",
            "Every time the component re-renders"
          ],
          "analysisPoints": [
            "Tests understanding of lazy initialization execution.",
            "Distinguishes between initial render and subsequent re-renders.",
            "Highlights the performance benefit."
          ],
          "keyConcepts": [
            "useState",
            "Lazy Initialization",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Ability to trace component behavior with `useState` initializer.",
            "Understanding of React's re-rendering mechanism."
          ],
          "example": "The initializer function passed to `useState` is executed only once, specifically during the very first render of the component to compute the initial state. Subsequent re-renders (triggered by `setValue` in this case) will not re-execute the initializer function, as the state has already been initialized. Therefore, 'Calculating initial value...' will only be logged once.",
          "tags": [
            "React",
            "useState",
            "Hooks",
            "Performance",
            "MCQ"
          ],
          "prerequisites": [
            "react_useState_hook"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lazy_state_3",
          "topic": "Lazy Initial State",
          "level": "medium",
          "type": "open",
          "question": "Describe a scenario where using lazy initial state with `useState` would significantly benefit application performance. Provide a conceptual code snippet demonstrating this.",
          "answer": "",
          "analysisPoints": [
            "Requires identifying a real-world use case for lazy initialization.",
            "Demands understanding of 'expensive calculation'.",
            "Expects conceptual code illustrating the use case."
          ],
          "keyConcepts": [
            "useState",
            "Lazy Initialization",
            "Performance Optimization",
            "Real-world Applications"
          ],
          "evaluationCriteria": [
            "Problem-solving and scenario identification.",
            "Conceptual coding ability.",
            "Understanding of performance bottlenecks."
          ],
          "example": "A scenario where lazy initial state would be beneficial is when the initial state needs to be loaded from `localStorage` or `sessionStorage`, or when it involves complex parsing of a large JSON string. These operations can be synchronous and time-consuming, blocking the main thread if done directly on every render.\n\n```typescript\nfunction UserSettings() {\n  const [settings, setSettings] = useState(() => {\n    console.log('Loading settings from localStorage...');\n    const savedSettings = localStorage.getItem('userPreferences');\n    // Simulate parsing a large JSON string\n    return savedSettings ? JSON.parse(savedSettings) : { theme: 'light', notifications: true };\n  });\n\n  // ...rest of the component logic\n}\n```\n\nIn this example, `localStorage.getItem` and `JSON.parse` can be expensive if the stored data is large. By wrapping it in a function, it's guaranteed to run only once on the initial mount, preventing unnecessary re-reads and parsing on subsequent re-renders.",
          "tags": [
            "React",
            "useState",
            "Hooks",
            "Performance",
            "Open-ended"
          ],
          "prerequisites": [
            "react_useState_hook",
            "javascript_web_storage_api"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_state_1",
          "topic": "Array State Management",
          "level": "easy",
          "type": "flashcard",
          "question": "Why is it important to update array state immutably in React?",
          "answer": "To ensure React's change detection mechanism (shallow comparison) correctly identifies state updates, triggering necessary re-renders and preventing unexpected UI behavior or performance issues.",
          "options": [],
          "analysisPoints": [
            "Highlights the role of shallow comparison.",
            "Connects immutability to re-rendering.",
            "Mentions preventing bugs/performance issues."
          ],
          "keyConcepts": [
            "Immutability",
            "React State",
            "Re-rendering",
            "Shallow Comparison"
          ],
          "evaluationCriteria": [
            "Recall of React's rendering principles",
            "Understanding of immutability's necessity"
          ],
          "example": "",
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Best Practices"
          ],
          "prerequisites": [
            "react_useState_hook"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_state_2",
          "topic": "Array State Management",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is the **correct** way to add a new item to an array state in React?",
          "answer": "A. `setItems([...items, newItem]);`",
          "options": [
            "A. `setItems([...items, newItem]);`",
            "B. `items.push(newItem); setItems(items);`",
            "C. `setItems(items.concat(newItem));`",
            "D. `items[items.length] = newItem; setItems(items);`"
          ],
          "analysisPoints": [
            "Identifies the correct immutable approach (spread syntax).",
            "Recognizes direct mutations (`push`, `direct assignment`) are incorrect.",
            "Notes that `concat` also returns a new array and is a valid but less common way than spread."
          ],
          "keyConcepts": [
            "Immutability",
            "Array State",
            "Spread Syntax",
            "Array Methods"
          ],
          "evaluationCriteria": [
            "Knowledge of immutable array update patterns.",
            "Ability to distinguish between mutable and immutable operations."
          ],
          "example": "Option A (`setItems([...items, newItem]);`) correctly uses the spread syntax to create a *new* array, incorporating all existing items and the new item. This is the idiomatic and most recommended way to add items immutably in React.\n\nOption B and D directly mutate the `items` array and then pass the *same* array reference back to `setItems`, which React's shallow comparison might not detect. While `setItems(items)` would technically trigger a re-render if the component is already scheduled to update, it's a bad practice as it relies on a re-render being scheduled by other means and doesn't explicitly tell React the array *content* has changed in an immutable way.\n\nOption C (`setItems(items.concat(newItem));`) is also a correct immutable way to add items as `concat` returns a new array, but spread syntax is generally preferred for its conciseness.",
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "MCQ"
          ],
          "prerequisites": [
            "react_useState_hook",
            "javascript_array_methods"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_state_3",
          "topic": "Array State Management",
          "level": "hard",
          "type": "code",
          "question": "You have a React component managing a list of `todo` objects, each with an `id` (unique number), `text` (string), and `completed` (boolean). Write a function `toggleTodoCompletion(id)` that updates the `completed` status of a specific todo item in the state immutably. The function should return the updated array.",
          "answer": "```typescript\nfunction toggleTodoCompletion(todos: { id: number; text: string; completed: boolean }[], idToToggle: number): { id: number; text: string; completed: boolean }[] {\n  return todos.map(todo => \n    todo.id === idToToggle \n      ? { ...todo, completed: !todo.completed } \n      : todo\n  );\n}\n\n// Example usage within a component:\n// const [todos, setTodos] = useState([\n//   { id: 1, text: 'Learn React Hooks', completed: false },\n//   { id: 2, text: 'Master Immutability', completed: true }\n// ]);\n\n// const handleToggle = (id) => {\n//   setTodos(prevTodos => toggleTodoCompletion(prevTodos, id));\n// };\n```",
          "options": [],
          "analysisPoints": [
            "Requires use of `map` for updating items.",
            "Demands immutable object update within the array (spreading the item).",
            "Tests understanding of state updater function (`prevTodos`)."
          ],
          "keyConcepts": [
            "Immutability",
            "Array State",
            "map method",
            "Object Spread",
            "State Updater"
          ],
          "evaluationCriteria": [
            "Correct application of `map` for array transformation.",
            "Correct immutable update of nested objects.",
            "Syntactical correctness and efficiency."
          ],
          "example": "",
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Coding Challenge",
            "Arrays"
          ],
          "prerequisites": [
            "javascript_array_methods",
            "javascript_object_spread",
            "react_useState_hook"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_state_4",
          "topic": "Array State Management",
          "level": "medium",
          "type": "open",
          "question": "Explain why using `Array.prototype.splice()` directly on a state array in React is considered an anti-pattern. What are the potential consequences, and how would you achieve the same effect immutably?",
          "answer": "",
          "analysisPoints": [
            "Identifies `splice` as a mutable operation.",
            "Explains the consequence of mutation (React's shallow comparison failing).",
            "Discusses resulting bugs (no re-render, stale UI).",
            "Provides immutable alternatives (`filter` for removal, `slice` and spread for insertion/replacement)."
          ],
          "keyConcepts": [
            "Immutability",
            "Array.prototype.splice()",
            "React Re-rendering",
            "Shallow Comparison",
            "Anti-pattern"
          ],
          "evaluationCriteria": [
            "Deep understanding of React's rendering mechanism.",
            "Knowledge of mutable vs. immutable array methods.",
            "Ability to articulate consequences and provide solutions."
          ],
          "example": "`Array.prototype.splice()` is an anti-pattern in React when used directly on a state array because it **mutates the original array in place**. React's state update mechanism (specifically, the `useState` hook) relies on shallow comparison to determine if a re-render is necessary for arrays and objects. If you modify an array using `splice()`, the array's reference in memory remains the same, even though its contents have changed. React's shallow comparison will see the same reference and conclude that the state has not changed, thus **failing to trigger a re-render**.\n\n**Potential Consequences:**\n1.  **Stale UI**: The component's UI will not update to reflect the changes in the array state, leading to a mismatch between the internal state and what the user sees.\n2.  **Difficult Debugging**: It can be very hard to debug why the UI isn't updating when the underlying state 'appears' to have changed.\n3.  **Unexpected Behavior**: Other parts of your application that might be relying on the state updating correctly could behave unpredictably.\n4.  **Performance Pitfalls**: If you try to force re-renders (e.g., by creating a new array from the mutated one just to trigger an update), it defeats the purpose of React's efficient reconciliation.\n\n**How to achieve the same effect immutably:**\n\nInstead of `splice()`, which can remove, add, or replace elements, you typically combine `slice()` and the spread syntax or use `filter()` and `map()`.\n\n-   **To remove an item (like `splice(index, 1)`):** Use `filter()`.\n    ```typescript\n    setItems(items.filter((_, idx) => idx !== indexToRemove));\n    ```\n\n-   **To insert an item (like `splice(index, 0, newItem)`):** Use `slice()` and spread.\n    ```typescript\n    setItems([\n      ...items.slice(0, indexToInsert),\n      newItem,\n      ...items.slice(indexToInsert)\n    ]);\n    ```\n\n-   **To replace an item (like `splice(index, 1, newItem)`):** Use `map()`.\n    ```typescript\n    setItems(items.map((item, idx) => idx === indexToReplace ? newItem : item));\n    ```\n\nThese methods all return a *new* array, ensuring React detects the state change and correctly re-renders the component.",
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Anti-patterns",
            "Open-ended"
          ],
          "prerequisites": [
            "react_useState_hook",
            "javascript_array_methods"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_effect_1",
          "topic": "useEffect Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `useEffect` hook in React?",
          "answer": "To perform side effects in functional components, such as data fetching, subscriptions, or direct DOM manipulation, after render.",
          "options": [],
          "analysisPoints": [
            "Defines side effects.",
            "Mentions post-render execution."
          ],
          "keyConcepts": [
            "useEffect",
            "Side Effects",
            "Hooks"
          ],
          "evaluationCriteria": [
            "Basic recall of hook purpose"
          ],
          "example": "",
          "tags": [
            "React",
            "useEffect",
            "Hooks"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 10,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_effect_2",
          "topic": "useEffect Hook",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `useEffect` hook with different dependency arrays:\n\n```jsx\nimport React, { useState, useEffect } from 'react';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('');\n\n  useEffect(() => {\n    console.log('Effect A: Runs always');\n  }); // Effect A\n\n  useEffect(() => {\n    console.log('Effect B: Runs on initial mount and when count changes');\n  }, [count]); // Effect B\n\n  useEffect(() => {\n    console.log('Effect C: Runs only on initial mount');\n    return () => console.log('Cleanup C');\n  }, []); // Effect C\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\n      <input value={name} onChange={e => setName(e.target.value)} placeholder=\"Enter name\" />\n    </div>\n  );\n}\n```\n\nIf the component mounts, then the 'Increment Count' button is clicked once, and then a character is typed into the input field once, what will be the sequence of console logs for 'Effect A', 'Effect B', and 'Effect C' (ignoring 'Cleanup C' for now)?",
          "answer": "Effect A, Effect B, Effect C, Effect A, Effect B, Effect A",
          "options": [
            "A. Effect A, Effect B, Effect C, Effect A, Effect A",
            "B. Effect A, Effect B, Effect C, Effect A, Effect B, Effect A",
            "C. Effect A, Effect B, Effect C, Effect B, Effect A",
            "D. Effect A, Effect B, Effect C, Effect A, Effect B, Effect C, Effect A"
          ],
          "analysisPoints": [
            "Tests understanding of `useEffect` with no dependency array (runs on every render).",
            "Tests understanding of `useEffect` with a dependency array (runs when dependencies change).",
            "Tests understanding of `useEffect` with an empty dependency array (runs only once on mount).",
            "Requires tracking state changes and component re-renders."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Component Lifecycle",
            "Re-rendering"
          ],
          "evaluationCriteria": [
            "Accurate prediction of `useEffect` execution flow.",
            "Ability to distinguish effects based on dependency array.",
            "Understanding of React's render cycles."
          ],
          "example": "Let's trace the execution:\n1.  **Initial Mount**: All effects run.\n    *   `Effect A: Runs always`\n    *   `Effect B: Runs on initial mount and when count changes`\n    *   `Effect C: Runs only on initial mount`\n2.  **Click 'Increment Count'**: `count` state changes, component re-renders.\n    *   `Effect A` runs (no dependency array).\n    *   `Effect B` runs (`count` changed).\n    *   `Effect C` does NOT run (empty dependency array).\n3.  **Type character into input**: `name` state changes, component re-renders.\n    *   `Effect A` runs (no dependency array).\n    *   `Effect B` does NOT run (`count` did not change).\n    *   `Effect C` does NOT run (empty dependency array).\n\nCombining these, the sequence is: Effect A, Effect B, Effect C, Effect A, Effect B, Effect A.",
          "tags": [
            "React",
            "useEffect",
            "Hooks",
            "MCQ",
            "Lifecycle"
          ],
          "prerequisites": [
            "react_useState_hook"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_effect_3",
          "topic": "useEffect Hook",
          "level": "hard",
          "type": "code",
          "question": "Write a React functional component `Timer` that displays a countdown from a given `initialSeconds` prop. Use `useEffect` to manage the timer logic (starting and stopping). The timer should decrement every second and stop at 0. Ensure proper cleanup to prevent memory leaks.",
          "answer": "```typescript\nimport React, { useState, useEffect } from 'react';\n\ninterface TimerProps {\n  initialSeconds: number;\n}\n\nfunction Timer({ initialSeconds }: TimerProps) {\n  const [seconds, setSeconds] = useState(initialSeconds);\n  const [isRunning, setIsRunning] = useState(true);\n\n  useEffect(() => {\n    if (!isRunning || seconds <= 0) {\n      return; // Do not start or continue timer if not running or already 0\n    }\n\n    const timerId = setInterval(() => {\n      setSeconds(prevSeconds => prevSeconds - 1);\n    }, 1000);\n\n    return () => {\n      // Cleanup function: Clear the interval when component unmounts\n      // or when dependencies (isRunning, seconds) change and effect re-runs\n      clearInterval(timerId);\n    };\n  }, [isRunning, seconds]); // Re-run effect if isRunning or seconds changes\n\n  // Optional: Effect to stop timer when seconds reach 0\n  useEffect(() => {\n    if (seconds <= 0) {\n      setIsRunning(false);\n    }\n  }, [seconds]);\n\n  return (\n    <div>\n      <h2>Countdown Timer</h2>\n      <p>Time Left: {seconds} seconds</p>\n      {seconds <= 0 && <p>Time's Up!</p>}\n      <button onClick={() => setIsRunning(!isRunning)}>\n        {isRunning ? 'Pause' : 'Resume'}\n      </button>\n      <button onClick={() => { setSeconds(initialSeconds); setIsRunning(true); }}>Reset</button>\n    </div>\n  );\n}\n\nexport default Timer;\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `setInterval` and `clearInterval` for timer management.",
            "Proper cleanup function return from `useEffect`.",
            "Understanding of `useEffect` dependency array to control re-execution.",
            "Managing `initialSeconds` and current `seconds` state.",
            "Handling edge cases like `seconds <= 0`."
          ],
          "keyConcepts": [
            "useEffect",
            "Side Effects",
            "Cleanup",
            "Dependency Array",
            "setInterval",
            "clearInterval",
            "State Management"
          ],
          "evaluationCriteria": [
            "Implementation of a functional timer.",
            "Demonstration of `useEffect` cleanup.",
            "Correct handling of component lifecycle for side effects.",
            "Ability to manage multiple state variables."
          ],
          "example": "",
          "tags": [
            "React",
            "useEffect",
            "Hooks",
            "Coding Challenge",
            "Timers",
            "Cleanup"
          ],
          "prerequisites": [
            "react_useState_hook",
            "javascript_timers"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_effect_4",
          "topic": "useEffect Hook",
          "level": "medium",
          "type": "open",
          "question": "Explain the role of the cleanup function returned by `useEffect`. When and why is it executed?",
          "answer": "",
          "analysisPoints": [
            "Defines the purpose (resource liberation, preventing memory leaks).",
            "Explains 'when' (unmount, before re-run due to dependency change).",
            "Explains 'why' (preventing issues like stale closures, subscriptions running multiple times, memory leaks).",
            "Provides examples of what to clean up (subscriptions, timers, event listeners)."
          ],
          "keyConcepts": [
            "useEffect",
            "Cleanup Function",
            "Memory Leaks",
            "Subscriptions",
            "Timers",
            "Event Listeners"
          ],
          "evaluationCriteria": [
            "Thorough understanding of `useEffect`'s cleanup mechanism.",
            "Ability to articulate consequences of not cleaning up.",
            "Knowledge of common cleanup scenarios."
          ],
          "example": "The cleanup function returned by `useEffect` is an optional but crucial part of managing side effects. Its primary role is to **undo** or **clean up** any resources or subscriptions that the effect might have set up. This prevents memory leaks, ensures resource efficiency, and avoids unexpected behavior.\n\n**When is it executed?**\n1.  **Before the component unmounts**: This is similar to `componentWillUnmount` in class components. When the component is removed from the DOM, the cleanup function is called.\n2.  **Before the effect re-runs**: If the `useEffect` hook has dependencies (a dependency array is provided and its values change), the cleanup function from the *previous* effect run will execute *before* the *new* effect function runs. This ensures that the old effect's resources are released before new ones are potentially set up.\n\n**Why is it executed?**\n-   **Prevent Memory Leaks**: If you subscribe to an external data source (like a WebSocket or an event listener) and don't unsubscribe, that subscription might continue to exist even after the component that created it is gone, leading to memory leaks and unnecessary processing.\n-   **Avoid Stale Closures/Duplicate Behavior**: For effects that set up timers or listeners, cleaning up ensures that you don't have multiple timers running or multiple listeners attached simultaneously as the component re-renders (especially if there are no dependencies or changing dependencies).\n-   **Resource Management**: For operations like creating DOM elements manually or opening connections, cleanup ensures these resources are properly released when no longer needed.\n\n**Examples of what to clean up:**\n-   Clearing `setInterval` or `setTimeout` timers.\n-   Unsubscribing from event listeners (`removeEventListener`).\n-   Canceling network requests.\n-   Closing WebSocket connections.\n-   Cleaning up manually created DOM elements.",
          "tags": [
            "React",
            "useEffect",
            "Hooks",
            "Cleanup",
            "Memory Leaks",
            "Open-ended"
          ],
          "prerequisites": [
            "react_functional_components"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_effect_5",
          "topic": "useEffect Hook",
          "level": "medium",
          "type": "flashcard",
          "question": "What happens if `useEffect` is called without a dependency array?",
          "answer": "The effect function will run after every render of the component.",
          "options": [],
          "analysisPoints": [
            "Identifies the 'every render' behavior.",
            "Distinguishes from specific dependency array behaviors."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Re-rendering"
          ],
          "evaluationCriteria": [
            "Recall of `useEffect` behavior"
          ],
          "example": "",
          "tags": [
            "React",
            "useEffect",
            "Hooks"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_lazy_initial_state_1",
          "title": "Implement a User Settings Component with Lazy Initial State",
          "description": "\nCreate a React functional component `UserSettings` that manages user preferences. The initial preferences should be loaded from `localStorage` using a potentially expensive deserialization process.\n\n**Requirements:**\n1.  Use `useState` with a lazy initializer function to load `userPreferences` from `localStorage`.\n2.  Simulate an 'expensive calculation' (e.g., a `for` loop or a `JSON.parse` on a large string) inside the initializer.\n3.  The component should display the current settings (e.g., `theme` and `notifications`).\n4.  Include buttons to toggle a setting (e.g., 'Toggle Theme') and update the state. Verify in the console that the expensive calculation runs only once on initial mount.\n\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// Simulate a large stored preference string\nconst LARGE_PREF_STRING = JSON.stringify({\n  theme: 'dark',\n  notifications: true,\n  language: 'en',\n  fontSize: 16,\n  data: Array(1000).fill('some-large-data-item').join('') // Simulate large data\n});\n\nfunction getInitialPreferences() {\n  console.log('--- Performing expensive initial preferences load ---');\n  // Simulate a delay or heavy computation\n  for (let i = 0; i < 1000000; i++) {}\n  const saved = localStorage.getItem('userPreferences');\n  return saved ? JSON.parse(saved) : { theme: 'light', notifications: true };\n}\n\ninterface UserPreferences {\n  theme: string;\n  notifications: boolean;\n  [key: string]: any;\n}\n\nfunction UserSettings() {\n  // TODO: Implement lazy initial state here\n  // const [preferences, setPreferences] = useState(/* YOUR CODE HERE */);\n\n  const handleToggleTheme = () => {\n    // TODO: Update theme immutably and save to localStorage\n    // setPreferences(prev => ({ ...prev, theme: prev.theme === 'light' ? 'dark' : 'light' }));\n  };\n\n  return (\n    <div>\n      <h2>User Settings</h2>\n      {/* TODO: Display preferences */}\n      {/* <p>Theme: {preferences.theme}</p> */}\n      {/* <p>Notifications: {preferences.notifications ? 'On' : 'Off'}</p> */}\n      <button onClick={handleToggleTheme}>Toggle Theme</button>\n      <button onClick={() => { /* some other action */ }}>Just a re-render trigger</button>\n    </div>\n  );\n}\n\nexport default UserSettings;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nconst LARGE_PREF_STRING = JSON.stringify({\n  theme: 'dark',\n  notifications: true,\n  language: 'en',\n  fontSize: 16,\n  data: Array(1000).fill('some-large-data-item').join('') // Simulate large data\n});\n\nfunction getInitialPreferences(): UserPreferences {\n  console.log('--- Performing expensive initial preferences load ---');\n  // Simulate a delay or heavy computation\n  let sum = 0;\n  for (let i = 0; i < 5000000; i++) { sum += i; }\n  \n  const saved = localStorage.getItem('userPreferences');\n  console.log('--- Initial preferences computed ---');\n  return saved ? JSON.parse(saved) : { theme: 'light', notifications: true };\n}\n\ninterface UserPreferences {\n  theme: string;\n  notifications: boolean;\n  [key: string]: any;\n}\n\nfunction UserSettings() {\n  const [preferences, setPreferences] = useState<UserPreferences>(() => {\n    // Optionally, pre-set a large string to localStorage for testing\n    localStorage.setItem('userPreferences', LARGE_PREF_STRING);\n    return getInitialPreferences();\n  });\n\n  // Using useEffect to save preferences when they change, for persistence\n  useEffect(() => {\n    console.log('Saving preferences to localStorage...');\n    localStorage.setItem('userPreferences', JSON.stringify(preferences));\n  }, [preferences]);\n\n  const handleToggleTheme = () => {\n    setPreferences(prev => ({ \n      ...prev, \n      theme: prev.theme === 'light' ? 'dark' : 'light' \n    }));\n  };\n\n  const handleToggleNotifications = () => {\n    setPreferences(prev => ({ \n      ...prev, \n      notifications: !prev.notifications \n    }));\n  };\n\n  return (\n    <div>\n      <h2>User Settings</h2>\n      <p>Theme: {preferences.theme}</p>\n      <p>Notifications: {preferences.notifications ? 'On' : 'Off'}</p>\n      <button onClick={handleToggleTheme}>Toggle Theme</button>\n      <button onClick={handleToggleNotifications}>Toggle Notifications</button>\n    </div>\n  );\n}\n\nexport default UserSettings;\n",
          "testCases": [
            "Component renders for the first time: '--- Performing expensive initial preferences load ---' should appear in console exactly once.",
            "Click 'Toggle Theme' button: The theme should switch, component re-renders, but the initial preferences load message should NOT appear again.",
            "Click 'Toggle Notifications' button: Notifications state should toggle, component re-renders, and the initial preferences load message should NOT appear again.",
            "Verify `localStorage` is updated with new preferences after state changes (optional, but good practice for persistent settings)."
          ],
          "hints": [
            "Remember to pass a function to `useState` for lazy initialization.",
            "The expensive calculation should only be inside this function.",
            "For updating the state, ensure you spread the previous state to maintain other properties."
          ],
          "tags": [
            "React",
            "useState",
            "Hooks",
            "Performance",
            "LocalStorage"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_useState_hook",
            "javascript_json",
            "javascript_web_storage_api"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "lazy_initialization",
            "useState_initializer",
            "performance_optimization"
          ]
        },
        {
          "id": "task_array_state_1",
          "title": "Implement a Tag Input Component",
          "description": "\nCreate a React functional component `TagInput` that allows users to add and remove tags. The component should manage a list of tags in its state.\n\n**Requirements:**\n1.  Display a list of tags (e.g., `['React', 'JavaScript', 'CSS']`).\n2.  Provide an input field and a button to add new tags. New tags should be added to the end of the list.\n3.  Each tag in the list should have a 'Remove' button next to it. Clicking this button should remove the corresponding tag.\n4.  All array state updates must be **immutable**.\n5.  Ensure proper `key` prop usage when rendering the list of tags.\n\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\nfunction TagInput() {\n  const [tags, setTags] = useState(['React', 'JavaScript', 'CSS']);\n  const [newTag, setNewTag] = useState('');\n\n  const handleAddTag = () => {\n    // TODO: Implement adding a tag immutably\n    // if (newTag.trim() !== '') {\n    //   setTags(/* YOUR CODE HERE */);\n    //   setNewTag('');\n    // }\n  };\n\n  const handleRemoveTag = (tagToRemove: string) => {\n    // TODO: Implement removing a tag immutably\n    // setTags(/* YOUR CODE HERE */);\n  };\n\n  return (\n    <div>\n      <h2>Tag Input</h2>\n      <div style={{ marginBottom: '10px' }}>\n        <input \n          type=\"text\" \n          value={newTag} \n          onChange={(e) => setNewTag(e.target.value)} \n          placeholder=\"Add a new tag\"\n        />\n        <button onClick={handleAddTag}>Add Tag</button>\n      </div>\n      <div style={{ border: '1px solid #ccc', padding: '10px', minHeight: '50px' }}>\n        {/* TODO: Render tags */} \n        {/* {tags.map((tag, index) => (\n          <span key={tag} style={{ \n            display: 'inline-block', \n            backgroundColor: '#eee', \n            padding: '5px 10px', \n            margin: '0 5px 5px 0', \n            borderRadius: '3px'\n          }}>\n            {tag}\n            <button \n              onClick={() => handleRemoveTag(tag)}\n              style={{ marginLeft: '5px', background: 'none', border: 'none', cursor: 'pointer' }}\n            >\n              x\n            </button>\n          </span>\n        ))}*/}\n      </div>\n    </div>\n  );\n}\n\nexport default TagInput;\n",
          "solutionCode": "import React, { useState } from 'react';\n\nfunction TagInput() {\n  const [tags, setTags] = useState(['React', 'JavaScript', 'CSS']);\n  const [newTag, setNewTag] = useState('');\n\n  const handleAddTag = () => {\n    if (newTag.trim() !== '' && !tags.includes(newTag.trim())) {\n      setTags([...tags, newTag.trim()]); // Immutable add\n      setNewTag('');\n    }\n  };\n\n  const handleRemoveTag = (tagToRemove: string) => {\n    setTags(tags.filter(tag => tag !== tagToRemove)); // Immutable remove\n  };\n\n  return (\n    <div>\n      <h2>Tag Input</h2>\n      <div style={{ marginBottom: '10px' }}>\n        <input \n          type=\"text\" \n          value={newTag} \n          onChange={(e) => setNewTag(e.target.value)} \n          onKeyPress={(e) => { if (e.key === 'Enter') handleAddTag(); }} // Add on Enter key press\n          placeholder=\"Add a new tag\"\n        />\n        <button onClick={handleAddTag}>Add Tag</button>\n      </div>\n      <div style={{ border: '1px solid #ccc', padding: '10px', minHeight: '50px' }}>\n        {tags.map((tag) => (\n          <span \n            key={tag} // Use tag itself as key if tags are unique\n            style={{ \n              display: 'inline-block', \n              backgroundColor: '#eee', \n              padding: '5px 10px', \n              margin: '0 5px 5px 0', \n              borderRadius: '3px'\n            }}\n          >\n            {tag}\n            <button \n              onClick={() => handleRemoveTag(tag)}\n              style={{ marginLeft: '5px', background: 'none', border: 'none', cursor: 'pointer' }}\n            >\n              x\n            </button>\n          </span>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport default TagInput;\n",
          "testCases": [
            "Initial render: Component displays 'React', 'JavaScript', 'CSS'.",
            "Adding a tag: Type 'TypeScript' into the input and click 'Add Tag'. 'TypeScript' should appear in the list. Input field should clear. The `tags` array state should be `['React', 'JavaScript', 'CSS', 'TypeScript']`.",
            "Adding an empty or whitespace-only tag: Input '   ' and click 'Add Tag'. No new tag should be added. Input field should clear.",
            "Adding a duplicate tag: Add 'React' again. No new tag should be added (optional, but good for robust input).",
            "Removing a tag: Click 'x' next to 'JavaScript'. 'JavaScript' should be removed from the list. The `tags` array state should be `['React', 'CSS']` (assuming previous state).",
            "Removing the last tag: Remove all tags. The list should become empty.",
            "Key prop usage: Verify that `key` prop is used for each rendered tag."
          ],
          "hints": [
            "For adding, remember the spread syntax `[...array, newItem]`.",
            "For removing, `filter()` is your friend: `array.filter(item => item !== itemToRemove)`.",
            "Always ensure you create a NEW array for state updates.",
            "Consider trimming whitespace from new tags and preventing duplicates."
          ],
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Arrays",
            "UI Components"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_useState_hook",
            "javascript_array_methods",
            "javascript_es6_spread"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "array_immutability",
            "list_rendering",
            "useState_updater"
          ]
        },
        {
          "id": "task_array_state_2",
          "title": "Implement a Shopping Cart Item Editor",
          "description": "\nDevelop a React component `ShoppingCart` that displays a list of shopping cart items. Each item has an `id`, `name`, `price`, and `quantity`. The component should allow users to:\n\n1.  **Add a new item** to the cart.\n2.  **Increase/Decrease the quantity** of an existing item.\n3.  **Remove an item** from the cart.\n\n**Constraints:**\n-   All state updates for the `cartItems` array must be **immutable**.\n-   Quantity cannot go below 1. If an item's quantity is decreased to 0, it should be removed from the cart.\n-   Use stable, unique `id`s for list keys where applicable.\n\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } => 'react';\n\ninterface CartItem {\n  id: number;\n  name: string;\n  price: number;\n  quantity: number;\n}\n\nfunction ShoppingCart() {\n  const [cartItems, setCartItems] = useState<CartItem[]>([\n    { id: 1, name: 'Laptop', price: 1200, quantity: 1 },\n    { id: 2, name: 'Mouse', price: 25, quantity: 2 }\n  ]);\n\n  const [newItemName, setNewItemName] = useState('');\n  const [newItemPrice, setNewItemPrice] = useState('');\n\n  const handleAddItem = () => {\n    // TODO: Implement adding an item immutably\n  };\n\n  const handleUpdateQuantity = (id: number, delta: number) => {\n    // TODO: Implement quantity update immutably\n    // Remember to remove if quantity drops to 0 or below\n  };\n\n  const handleRemoveItem = (id: number) => {\n    // TODO: Implement removing an item immutably\n  };\n\n  const calculateTotal = () => {\n    return cartItems.reduce((total, item) => total + item.price * item.quantity, 0);\n  };\n\n  return (\n    <div>\n      <h2>Shopping Cart</h2>\n      <div>\n        <input type=\"text\" placeholder=\"Item Name\" value={newItemName} onChange={(e) => setNewItemName(e.target.value)} />\n        <input type=\"number\" placeholder=\"Price\" value={newItemPrice} onChange={(e) => setNewItemPrice(e.target.value)} />\n        <button onClick={handleAddItem}>Add Item</button>\n      </div>\n      <ul>\n        {cartItems.map(item => (\n          <li key={item.id} style={{ marginBottom: '10px' }}>\n            {item.name} (${item.price}) x {item.quantity}\n            <button onClick={() => handleUpdateQuantity(item.id, 1)}>+</button>\n            <button onClick={() => handleUpdateQuantity(item.id, -1)}>-</button>\n            <button onClick={() => handleRemoveItem(item.id)}>Remove</button>\n          </li>\n        ))}\n      </ul>\n      <h3>Total: ${calculateTotal().toFixed(2)}</h3>\n    </div>\n  );\n}\n\nexport default ShoppingCart;\n",
          "solutionCode": "import React, { useState } from 'react';\n\ninterface CartItem {\n  id: number;\n  name: string;\n  price: number;\n  quantity: number;\n}\n\nfunction ShoppingCart() {\n  const [cartItems, setCartItems] = useState<CartItem[]>([\n    { id: 1, name: 'Laptop', price: 1200, quantity: 1 },\n    { id: 2, name: 'Mouse', price: 25, quantity: 2 }\n  ]);\n\n  const [newItemName, setNewItemName] = useState('');\n  const [newItemPrice, setNewItemPrice] = useState('');\n  const [nextId, setNextId] = useState(3); // To generate unique IDs for new items\n\n  const handleAddItem = () => {\n    if (newItemName.trim() === '' || isNaN(parseFloat(newItemPrice))) {\n      alert('Please enter valid item name and price.');\n      return;\n    }\n    const newItem: CartItem = {\n      id: nextId,\n      name: newItemName.trim(),\n      price: parseFloat(newItemPrice),\n      quantity: 1,\n    };\n    setCartItems([...cartItems, newItem]); // Immutable add\n    setNewItemName('');\n    setNewItemPrice('');\n    setNextId(nextId + 1);\n  };\n\n  const handleUpdateQuantity = (id: number, delta: number) => {\n    setCartItems(prevItems => {\n      const updatedItems = prevItems.map(item => {\n        if (item.id === id) {\n          const newQuantity = item.quantity + delta;\n          // If new quantity is 0 or less, we'll filter this item out later\n          return { ...item, quantity: newQuantity };\n        }\n        return item;\n      }).filter(item => item.quantity > 0); // Remove items with quantity <= 0\n      return updatedItems;\n    });\n  };\n\n  const handleRemoveItem = (id: number) => {\n    setCartItems(cartItems.filter(item => item.id !== id)); // Immutable remove\n  };\n\n  const calculateTotal = () => {\n    return cartItems.reduce((total, item) => total + item.price * item.quantity, 0);\n  };\n\n  return (\n    <div>\n      <h2>Shopping Cart</h2>\n      <div style={{ marginBottom: '20px', border: '1px solid #ddd', padding: '15px' }}>\n        <h3>Add New Item</h3>\n        <input \n          type=\"text\" \n          placeholder=\"Item Name\" \n          value={newItemName} \n          onChange={(e) => setNewItemName(e.target.value)} \n          style={{ marginRight: '10px', padding: '8px' }}\n        />\n        <input \n          type=\"number\" \n          placeholder=\"Price\" \n          value={newItemPrice} \n          onChange={(e) => setNewItemPrice(e.target.value)}\n          style={{ marginRight: '10px', padding: '8px' }}\n        />\n        <button onClick={handleAddItem} style={{ padding: '8px 15px' }}>Add Item</button>\n      </div>\n      {\n        cartItems.length === 0 ? (\n          <p>Your cart is empty.</p>\n        ) : (\n          <ul>\n            {cartItems.map(item => (\n              <li key={item.id} style={{ \n                marginBottom: '10px', \n                padding: '8px 0', \n                borderBottom: '1px dashed #eee',\n                display: 'flex', \n                alignItems: 'center'\n              }}>\n                <span style={{ flexGrow: 1 }}>{item.name} (${item.price.toFixed(2)}) x {item.quantity}</span>\n                <button onClick={() => handleUpdateQuantity(item.id, 1)} style={{ marginRight: '5px' }}>+</button>\n                <button onClick={() => handleUpdateQuantity(item.id, -1)} style={{ marginRight: '5px' }}>-</button>\n                <button onClick={() => handleRemoveItem(item.id)}>Remove</button>\n              </li>\n            ))}\n          </ul>\n        )\n      }\n      <h3>Total: ${calculateTotal().toFixed(2)}</h3>\n    </div>\n  );\n}\n\nexport default ShoppingCart;\n",
          "testCases": [
            "Initial render: Displays 'Laptop' (quantity 1) and 'Mouse' (quantity 2), total $1250.",
            "Add new item: Input 'Keyboard', price '75'. Click 'Add Item'. List should show Keyboard (quantity 1). Total should update. Input fields should clear.",
            "Increase quantity: Click '+' next to 'Mouse'. Quantity should become 3. Total should update.",
            "Decrease quantity: Click '-' next to 'Laptop'. Quantity should become 0. 'Laptop' should be removed from the cart. Total should update.",
            "Decrease quantity to negative: Try to decrease a quantity of 1 to 0 or less. Item should be removed, not show negative quantity.",
            "Remove item: Click 'Remove' next to 'Mouse'. 'Mouse' should be removed. Total should update.",
            "Add item with invalid input: Try adding with empty name or non-numeric price. Should handle gracefully (e.g., alert).",
            "Empty cart: Remove all items. Component should display 'Your cart is empty.'"
          ],
          "hints": [
            "Use `map()` for updating individual items and `filter()` for removing items.",
            "When updating an item's quantity, remember to spread the item (`{ ...item, quantity: newQuantity }`) to create a new object.",
            "You'll need a way to generate unique `id`s for new items (e.g., a simple counter in state).",
            "Consider using the state updater function `setCartItems(prevItems => ...)` when your new state depends on the previous state."
          ],
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Arrays",
            "Complex UI",
            "CRUD"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "react_useState_hook",
            "javascript_array_methods",
            "javascript_object_spread",
            "react_functional_components_props"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "immutable_updates",
            "list_rendering",
            "derived_state"
          ]
        },
        {
          "id": "task_use_effect_1",
          "title": "Implement a Data Fetching Component with Loading and Error States",
          "description": "\nCreate a React functional component `UserProfile` that fetches user data from a simulated API. The component should display loading, success, and error states using `useEffect`.\n\n**Requirements:**\n1.  Use `useEffect` to fetch user data when the component mounts.\n2.  Manage three states: `loading` (boolean), `error` (string or null), and `user` (object or null).\n3.  Simulate an API call using `setTimeout` (e.g., 1-second delay).\n4.  The API should randomly succeed (return user data) or fail (return an error message).\n5.  Display 'Loading...' when fetching.\n6.  Display user data (e.g., 'Name: John Doe, Email: john@example.com') on success.\n7.  Display an error message on failure.\n8.  Include a 'Refetch Data' button that triggers a new API call.\n9.  Ensure proper cleanup if the component unmounts while fetching.\n\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\ninterface UserData {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// Simulate an API call\nconst simulateFetchUser = (): Promise<UserData> => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const isSuccess = Math.random() > 0.3; // 70% success rate\n      if (isSuccess) {\n        resolve({\n          id: 1,\n          name: 'John Doe',\n          email: 'john.doe@example.com'\n        });\n      } else {\n        reject('Failed to fetch user data. Please try again.');\n      }\n    }, 1000);\n  });\n};\n\nfunction UserProfile() {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [user, setUser] = useState<UserData | null>(null);\n  const [fetchTrigger, setFetchTrigger] = useState(0); // Used to re-trigger fetch\n\n  useEffect(() => {\n    // TODO: Implement data fetching logic here\n    // Set loading state\n    // Call simulateFetchUser\n    // Handle success (setUser) and error (setError)\n    // Ensure cleanup for unmounted component\n    \n  }, [fetchTrigger]); // Dependency to re-fetch\n\n  const handleRefetch = () => {\n    setFetchTrigger(prev => prev + 1);\n  };\n\n  return (\n    <div>\n      <h2>User Profile</h2>\n      <button onClick={handleRefetch}>Refetch Data</button>\n      {/* TODO: Render loading, error, or user data */}\n      {/* {loading && <p>Loading...</p>}\n      {error && <p style={{ color: 'red' }}>Error: {error}</p>}\n      {user && (\n        <div>\n          <p>Name: {user.name}</p>\n          <p>Email: {user.email}</p>\n        </div>\n      )} */}\n    </div>\n  );\n}\n\nexport default UserProfile;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\ninterface UserData {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// Simulate an API call\nconst simulateFetchUser = (): Promise<UserData | string> => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const isSuccess = Math.random() > 0.3; // 70% success rate\n      if (isSuccess) {\n        resolve({\n          id: Math.floor(Math.random() * 100) + 1,\n          name: 'John Doe ' + Math.floor(Math.random() * 100),\n          email: 'john.doe' + Math.floor(Math.random() * 100) + '@example.com'\n        });\n      } else {\n        reject('Failed to fetch user data. Please try again.');\n      }\n    }, 1000);\n  });\n};\n\nfunction UserProfile() {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [user, setUser] = useState<UserData | null>(null);\n  const [fetchTrigger, setFetchTrigger] = useState(0); // Used to re-trigger fetch\n\n  useEffect(() => {\n    let isMounted = true; // Flag to prevent state update on unmounted component\n\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      setUser(null);\n\n      try {\n        const data = await simulateFetchUser();\n        if (isMounted) {\n          setUser(data as UserData); // Cast to UserData because simulateFetchUser can resolve string on error\n        }\n      } catch (err) {\n        if (isMounted) {\n          setError(err instanceof Error ? err.message : String(err));\n        }\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    fetchData();\n\n    return () => {\n      isMounted = false; // Cleanup: Set flag to false when component unmounts\n    };\n  }, [fetchTrigger]); // Re-run effect when fetchTrigger changes\n\n  const handleRefetch = () => {\n    setFetchTrigger(prev => prev + 1);\n  };\n\n  return (\n    <div>\n      <h2>User Profile</h2>\n      <button onClick={handleRefetch}>Refetch Data</button>\n      <div style={{ marginTop: '20px', padding: '15px', border: '1px solid #eee' }}>\n        {loading && <p>Loading user data...</p>}\n        {error && <p style={{ color: 'red' }}>Error: {error}</p>}\n        {user && (\n          <div>\n            <p><strong>Name:</strong> {user.name}</p>\n            <p><strong>Email:</strong> {user.email}</p>\n          </div>\n        )}\n        {!loading && !error && !user && <p>Click 'Refetch Data' to load user info.</p>}\n      </div>\n    </div>\n  );\n}\n\nexport default UserProfile;\n",
          "testCases": [
            "Initial render: Displays 'Loading...' for ~1 second, then either user data or an error message.",
            "Click 'Refetch Data' button: 'Loading...' should appear again, then new data or error.",
            "Success scenario: User data is displayed correctly.",
            "Error scenario: Error message is displayed in red.",
            "Component unmount during fetch: No 'Can't perform a React state update on an unmounted component' warning/error should occur (verify by conditionally rendering `UserProfile` in a parent and unmounting it quickly after initiating a fetch).",
            "Multiple rapid refetches: Ensure only the latest fetch's result updates the state (handled by `isMounted` flag or `AbortController` in real scenarios, `isMounted` is simpler for this task)."
          ],
          "hints": [
            "Declare an `async` function inside `useEffect` to handle promises, but remember that `useEffect` itself cannot be `async`.",
            "Use a boolean flag (e.g., `isMounted`) and set it to `false` in the cleanup function to prevent state updates on an unmounted component. Check this flag before calling `setLoading`, `setError`, or `setUser`.",
            "The `fetchTrigger` state variable is a common pattern to re-run an effect that otherwise has an empty or static dependency array.",
            "Handle both `resolve` (success) and `reject` (error) cases of the promise.",
            "Reset `user` and `error` states to `null` and `loading` to `true` at the start of each fetch."
          ],
          "tags": [
            "React",
            "useEffect",
            "Hooks",
            "Data Fetching",
            "Error Handling",
            "Loading States",
            "Cleanup"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "react_useState_hook",
            "javascript_promises",
            "javascript_async_await"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "side_effects",
            "dependency_array",
            "component_lifecycle",
            "error_handling"
          ]
        },
        {
          "id": "task_use_effect_2",
          "title": "Build a Window Resizer Component",
          "description": "\nCreate a React functional component `WindowResizer` that displays the current width and height of the browser window. Use `useEffect` to add and remove an event listener for window resizing.\n\n**Requirements:**\n1.  Display the current `window.innerWidth` and `window.innerHeight`.\n2.  Use `useEffect` to add a `resize` event listener to the `window` object when the component mounts.\n3.  Update the displayed width and height whenever the window is resized.\n4.  Implement a cleanup function in `useEffect` to **remove** the event listener when the component unmounts to prevent memory leaks.\n\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\nfunction WindowResizer() {\n  const [width, setWidth] = useState(window.innerWidth);\n  const [height, setHeight] = useState(window.innerHeight);\n\n  useEffect(() => {\n    const handleResize = () => {\n      // TODO: Update width and height state\n      // setWidth(/* YOUR CODE HERE */);\n      // setHeight(/* YOUR CODE HERE */);\n    };\n\n    // TODO: Add event listener\n    // window.addEventListener(/* YOUR CODE HERE */);\n\n    return () => {\n      // TODO: Remove event listener for cleanup\n      // window.removeEventListener(/* YOUR CODE HERE */);\n    };\n  }, []); // Empty dependency array means this effect runs once on mount and cleans up on unmount\n\n  return (\n    <div>\n      <h2>Window Resizer</h2>\n      <p>Window Width: {width}px</p>\n      <p>Window Height: {height}px</p>\n      <p>Try resizing your browser window!</p>\n    </div>\n  );\n}\n\nexport default WindowResizer;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction WindowResizer() {\n  const [width, setWidth] = useState(window.innerWidth);\n  const [height, setHeight] = useState(window.innerHeight);\n\n  useEffect(() => {\n    const handleResize = () => {\n      setWidth(window.innerWidth);\n      setHeight(window.innerHeight);\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    return () => {\n      console.log('Cleaning up resize event listener...');\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []); // Empty dependency array ensures effect runs only once on mount and cleans up on unmount\n\n  return (\n    <div>\n      <h2>Window Resizer</h2>\n      <p>Window Width: {width}px</p>\n      <p>Window Height: {height}px</p>\n      <p>Try resizing your browser window!</p>\n    </div>\n  );\n}\n\nexport default WindowResizer;\n",
          "testCases": [
            "Initial render: Displays correct initial width and height.",
            "Resize browser window: Width and height displayed should update dynamically.",
            "Component unmounts: The `useEffect` cleanup function should log 'Cleaning up resize event listener...' to the console (verify by toggling visibility of the component in a parent).",
            "No memory leaks: Ensure no multiple event listeners are added on re-renders (guaranteed by empty dependency array and proper cleanup)."
          ],
          "hints": [
            "The `resize` event listener should be added to the `window` object.",
            "The effect should only run once on mount, so use an empty dependency array (`[]`).",
            "The cleanup function is critical to `removeEventListener` when the component unmounts."
          ],
          "tags": [
            "React",
            "useEffect",
            "Hooks",
            "Event Listeners",
            "Cleanup",
            "DOM Manipulation"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_useState_hook",
            "javascript_dom_events"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "side_effects",
            "dependency_array",
            "cleanup_function",
            "event_handling"
          ]
        }
      ]
    }
  }
]