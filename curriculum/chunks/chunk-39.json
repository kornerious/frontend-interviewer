[
  {
    "id": "8bfac07b-3b21-4611-9bb0-b21da9585e34",
    "startLine": 7600,
    "endLine": 7699,
    "processedDate": "2025-06-17T10:25:10.939Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_context_reducer_pattern",
          "title": "React Context and Reducer Pattern for State Management",
          "content": "The provided code demonstrates a powerful pattern for managing global state in React applications, combining the `useContext` and `useReducer` hooks. This approach centralizes state logic, makes state updates predictable, and simplifies component structure.\n\n## Key Concepts\n\n### `useReducer` Hook\n`useReducer` is an alternative to `useState` for managing more complex state logic that involves multiple sub-values or when the next state depends on the previous one. It's often preferred over `useState` when state transitions are more intricate, similar to how Redux works.\n\nIt takes a `reducer` function and an `initialState` as arguments and returns the current state and a `dispatch` function. The `reducer` function takes the current state and an `action` object, and returns the new state. The `action` object typically has a `type` property and an optional `payload`.\n\n### `useContext` Hook\n`useContext` allows components to subscribe to a Context object without prop drilling. Context provides a way to pass data through the component tree without having to pass props down manually at every level. It's commonly used for global data like themes, user authentication status, or, as in this case, application-wide state managed by a reducer.\n\n### Combining `useReducer` and `useContext`\nThis pattern involves:\n1.  **Creating a Context:** A `React.createContext()` call establishes the context that will hold the state and dispatch function.\n2.  **Creating a Provider Component:** A component (e.g., `TodoProvider`) wraps `useReducer` to manage the state. It then provides the state and the `dispatch` function through the Context Provider's `value` prop to all its children.\n3.  **Creating a Custom Hook (Optional but Recommended):** A custom hook (e.g., `useTodo`) simplifies consumption of the context. Components can then use this hook to easily access the state and dispatch function without directly importing `useContext` and the Context object.\n\n## Advantages of this Pattern\n1.  **Centralized State Logic:** All state transitions and the logic for updating state (`reducer`) are defined in one place, making it easier to understand and maintain.\n2.  **Predictable State Updates:** State can only be updated by dispatching actions, which makes the flow of data unidirectional and easier to debug.\n3.  **Easy to Test:** Reducers are pure functions (given the same state and action, they always return the same new state) and can be tested in isolation without needing to render components.\n4.  **No External Dependencies:** This pattern uses only built-in React features, avoiding the need for external state management libraries for many use cases.\n5.  **DevTools Integration:** Works seamlessly with React DevTools for component inspection, allowing you to see the state and prop changes.\n\n## Implementation Steps\n1. Define your reducer function.\n2. Create a Context using `React.createContext`.\n3. Create a Provider component that uses `useReducer` and provides the state and dispatch via the context.\n4. Create a custom hook to consume the context.\n5. Wrap your application or relevant parts with the Provider.",
          "examples": [
            {
              "id": "example_reducer_context_1",
              "title": "Basic Todo Reducer and Context Setup",
              "code": "import React, { createContext, useReducer, useContext, useState } from 'react';\n\n// 1. Define the Reducer function\nconst todoReducer = (state, action) => {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [...state, { id: Date.now(), text: action.payload, completed: false }];\n    case 'TOGGLE_TODO':\n      return state.map(todo =>\n        todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo\n      );\n    case 'DELETE_TODO':\n      return state.filter(todo => todo.id !== action.payload);\n    default:\n      return state;\n  }\n};\n\n// 2. Create Context\nconst TodoContext = createContext(null);\n\n// 3. Create Provider Component\nexport const TodoProvider = ({ children }) => {\n  const [todos, dispatch] = useReducer(todoReducer, []);\n\n  return (\n    <TodoContext.Provider value={{ todos, dispatch }}>\n      {children}\n    </TodoContext.Provider>\n  );\n};\n\n// 4. Create Custom Hook to use the Context\nexport const useTodo = () => {\n  const context = useContext(TodoContext);\n  if (!context) {\n    throw new Error('useTodo must be used within a TodoProvider');\n  }\n  return context;\n};\n\n// 5. Example usage in components\n// AddTodo component\nfunction AddTodo() {\n  const [text, setText] = useState('');\n  const { dispatch } = useTodo();\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (text.trim()) {\n      dispatch({ type: 'ADD_TODO', payload: text });\n      setText('');\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input \n        value={text} \n        onChange={(e) => setText(e.target.value)} \n        placeholder=\"Add a todo\"\n      />\n      <button type=\"submit\">Add</button>\n    </form>\n  );\n}\n\n// TodoList component\nfunction TodoList() {\n  const { todos, dispatch } = useTodo();\n  \n  return (\n    <ul>\n      {todos.map(todo => (\n        <li \n          key={todo.id} \n          style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}\n        >\n          <span \n            onClick={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })} \n            style={{ cursor: 'pointer' }}\n          >\n            {todo.text}\n          </span>\n          <button \n            onClick={() => dispatch({ type: 'DELETE_TODO', payload: todo.id })} \n            style={{ marginLeft: '10px' }}\n          >\n            Delete\n          </button>\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Main App Component\nfunction TodoApp() {\n  return (\n    <TodoProvider>\n      <h1>Todo App</h1>\n      <AddTodo />\n      <TodoList />\n    </TodoProvider>\n  );\n}\n\nexport default TodoApp;\n",
              "explanation": "This example provides the full implementation of the Todo application shown in the markdown, demonstrating how `useReducer` defines the state logic, `TodoContext` provides the state and `dispatch` function, `TodoProvider` wraps the application to make the context available, and `useTodo` simplifies consumption of the context by child components. It illustrates the centralized state management and predictable updates through dispatched actions.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "State Management",
            "Hooks",
            "useReducer",
            "useContext",
            "Context API",
            "Redux Pattern"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "Functional Components",
            "useState"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Complex State Management",
            "Building Scalable React Apps",
            "Understanding Redux"
          ]
        },
        {
          "id": "theory_react_virtual_dom",
          "title": "Virtual DOM in React",
          "content": "The Virtual DOM (VDOM) is a core concept in React's architecture that significantly contributes to its performance benefits and declarative programming model. It's a key reason why React applications often feel fast and responsive.\n\n## What is Virtual DOM?\n\nThe Virtual DOM is a lightweight, in-memory representation of the actual DOM (Document Object Model). It's a JavaScript object that mirrors the structure of the browser's real DOM elements, their attributes, and content. React uses this virtual representation as an intermediary step to efficiently calculate and apply updates to the actual browser DOM.\n\n## How it Works (Reconciliation Process):\n\n1.  **Initial Render:** When a React component is first rendered, React creates a Virtual DOM tree that corresponds to the component's output and renders it to the actual DOM.\n2.  **State or Prop Change:** When a component's state or props change, React does not immediately update the real DOM. Instead, it:\n    *   Creates a new Virtual DOM tree representing the updated UI.\n    *   **Reconciliation:** React then compares this new Virtual DOM tree with the previous Virtual DOM tree. This comparison process is called 'reconciliation'.\n3.  **Diffing Algorithm:** React's highly optimized diffing algorithm identifies the minimal set of changes (differences) between the old and new Virtual DOM trees.\n4.  **Actual DOM Update:** Finally, React efficiently applies only these specific, minimal changes to the real DOM. This batching of updates and minimizing direct DOM manipulations is crucial for performance.\n\n## Benefits of Virtual DOM:\n\n1.  **Performance Optimization:** Direct manipulation of the real DOM is an expensive operation. By batching updates and only applying the necessary changes, the Virtual DOM minimizes these expensive operations, leading to faster and smoother UI updates.\n2.  **Cross-platform Compatibility:** The Virtual DOM abstracts away platform-specific details of the actual DOM. This abstraction allows React to be used not just for web applications (React DOM), but also for mobile (React Native), VR (React 360), and other platforms, as it only needs to know how to render the Virtual DOM to a specific target environment.\n3.  **Declarative Programming:** Developers describe the desired UI state, and React handles the underlying DOM updates. This declarative approach simplifies UI development, as developers don't need to worry about the imperative steps of manipulating the DOM directly.\n4.  **Easier Debugging:** The predictable state changes and rendering process, facilitated by the Virtual DOM's one-way data flow and reconciliation, make applications easier to understand and debug.",
          "examples": [],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Virtual DOM",
            "Performance",
            "Reconciliation",
            "Diffing Algorithm",
            "Declarative UI"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "DOM"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Optimizing React Performance",
            "Understanding React Internals"
          ]
        },
        {
          "id": "theory_react_concurrent_mode",
          "title": "React Concurrent Mode",
          "content": "React Concurrent Mode is a set of experimental features (as of React 18, many of these concepts are part of the 'concurrent rendering' architecture by default) designed to help React applications remain responsive and gracefully adapt to varying device capabilities and network speeds. It allows React to work on multiple tasks concurrently, improving the user experience, especially in applications with complex or data-intensive UIs.\n\n## Key Concepts:\n\n1.  **Interruptible Rendering:** In traditional React, rendering is synchronous; once it starts, it must complete. Concurrent Mode introduces the ability for React to pause rendering work to handle more urgent updates (e.g., user input like typing or clicking) and then resume the interrupted work later. This prevents the UI from freezing or becoming unresponsive during heavy computations.\n\n2.  **Priority-Based Rendering:** Updates in Concurrent Mode can be assigned different priorities. High-priority updates (e.g., direct user interactions) can interrupt and take precedence over lower-priority background work (e.g., rendering a large list of search results or fetching data). React can discard outdated low-priority work if a new, higher-priority update comes in.\n\n3.  **Suspense for Data Fetching:** Suspense is a feature that allows components to \"suspend\" rendering while they are waiting for data to be fetched. Instead of showing an empty screen or managing loading states manually, Suspense allows you to specify a fallback UI (like a spinner or skeleton screen) that React can display while the data is being loaded. Once the data is ready, React automatically renders the full component. This simplifies the management of loading states and provides a smoother user experience.\n\n    *   **How Suspense works:** A component throws a `Promise` when data is not yet available. React catches this `Promise` and renders the fallback defined in the nearest `<Suspense>` boundary above it. When the `Promise` resolves, React retries rendering the component.\n\n## Benefits:\n*   **Improved User Experience:** Applications feel more responsive by prioritizing user interactions and showing appropriate loading states.\n*   **Smoother Transitions:** Prevents UI jank and allows for seamless transitions between different states or views.\n*   **Simplified Data Fetching:** Suspense simplifies the logic for handling asynchronous data loading and error boundaries.",
          "examples": [
            {
              "id": "example_suspense_for_data",
              "title": "Basic Suspense for Data Fetching",
              "code": "import React, { Suspense, useState, useEffect } from 'react';\n\n// Simulate an asynchronous data fetch\nconst fetchData = (id) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({ id, name: `User ${id}`, email: `user${id}@example.com` });\n    }, 2000);\n  });\n};\n\n// A resource wrapper to manage promise state for Suspense\n// In a real app, you'd use a Suspense-ready library like React Query or SWR\nlet userCache = {};\nconst createUserResource = (id) => {\n  if (!userCache[id]) {\n    let status = 'pending';\n    let result;\n    const suspender = fetchData(id).then(\n      r => {\n        status = 'success';\n        result = r;\n      },\n      e => {\n        status = 'error';\n        result = e;\n      }\n    );\n    userCache[id] = {\n      read() {\n        if (status === 'pending') {\n          throw suspender; // Suspense catches this promise\n        } else if (status === 'error') {\n          throw result; // Propagate error\n        } else if (status === 'success') {\n          return result; // Return data\n        }\n      },\n    };\n  }\n  return userCache[id];\n};\n\n// Component that uses Suspense-ready data\nfunction UserProfile({ userId }) {\n  const userResource = createUserResource(userId);\n  const user = userResource.read(); // This will throw a promise if data is not ready\n\n  return (\n    <div>\n      <h3>User Details</h3>\n      <p>ID: {user.id}</p>\n      <p>Name: {user.name}</p>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n}\n\n// Main App Component using Suspense\nfunction App() {\n  const [userId, setUserId] = useState(1);\n\n  return (\n    <div>\n      <h1>Concurrent Mode & Suspense Example</h1>\n      <button onClick={() => setUserId(userId === 1 ? 2 : 1)}>\n        Toggle User (Wait 2s)\n      </button>\n      <Suspense fallback={<div>Loading user data...</div>}>\n        <UserProfile userId={userId} />\n      </Suspense>\n    </div>\n  );\n}\n\nexport default App;\n",
              "explanation": "This example demonstrates how `Suspense` works for data fetching. The `UserProfile` component attempts to `read()` data. If the data is not yet available (the promise is pending), it throws the promise, which `Suspense` catches. The `Suspense` boundary then renders its `fallback` UI (`Loading user data...`). Once the promise resolves, `UserProfile` re-renders with the fetched data. This declarative approach significantly simplifies handling loading states compared to manual `isLoading` flags.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Concurrent Mode",
            "Suspense",
            "Performance",
            "User Experience",
            "Asynchronous Operations"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "Promises",
            "Asynchronous JavaScript"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "requiredFor": [
            "Optimizing Large-Scale React Apps",
            "Building Responsive UIs",
            "Modern React Data Fetching"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_state_management_mcq_1",
          "topic": "React Context and Reducer Pattern",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following React hooks is primarily used to manage complex state logic, where the next state depends on the previous state and involves multiple sub-values?",
          "answer": "`useReducer`",
          "options": [
            "`useState`",
            "`useEffect`",
            "`useReducer`",
            "`useContext`"
          ],
          "analysisPoints": [
            "`useState` is for simple state variables.",
            "`useEffect` is for side effects.",
            "`useContext` is for consuming context.",
            "`useReducer` is specifically designed for complex state transitions, similar to a Redux reducer."
          ],
          "keyConcepts": [
            "useReducer",
            "useState",
            "State Management"
          ],
          "evaluationCriteria": [
            "Understanding of `useReducer`'s purpose",
            "Distinction between different React hooks"
          ],
          "example": "```typescript\nconst [state, dispatch] = useReducer(reducer, initialState);\n```",
          "tags": [
            "React",
            "Hooks",
            "useReducer",
            "State Management",
            "MCQ"
          ],
          "prerequisites": [
            "React Hooks Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_state_management_mcq_2",
          "topic": "React Context and Reducer Pattern",
          "level": "medium",
          "type": "mcq",
          "question": "In the provided `TodoApp` example, what is the primary role of the `TodoProvider` component?",
          "answer": "To make the `todos` state and `dispatch` function available to all child components via Context.",
          "options": [
            "To define the initial list of todos.",
            "To render the `AddTodo` and `TodoList` components.",
            "To make the `todos` state and `dispatch` function available to all child components via Context.",
            "To handle the submission of new todo items."
          ],
          "analysisPoints": [
            "The `TodoProvider` component wraps the `AddTodo` and `TodoList` components.",
            "It uses `useReducer` to manage the `todos` state and `dispatch` function.",
            "It then passes these via `TodoContext.Provider`'s `value` prop.",
            "Its purpose is to provide global access to the state management logic."
          ],
          "keyConcepts": [
            "Context API",
            "Provider Pattern",
            "State Management",
            "useContext",
            "useReducer"
          ],
          "evaluationCriteria": [
            "Understanding of Context Provider's role",
            "Ability to analyze component relationships in a React application"
          ],
          "example": "```typescript\nfunction TodoApp() {\n  return (\n    <TodoProvider>\n      <h1>Todo App</h1>\n      <AddTodo />\n      <TodoList />\n    </TodoProvider>\n  );\n}\n```",
          "tags": [
            "React",
            "Context API",
            "Provider",
            "State Management",
            "MCQ"
          ],
          "prerequisites": [
            "React Components",
            "Context API"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_management_open_1",
          "topic": "React Context and Reducer Pattern",
          "level": "medium",
          "type": "open",
          "question": "Explain three advantages of using the `useReducer` and `useContext` pattern for state management in React, as demonstrated by the `TodoApp`.",
          "answer": "1.  **Centralized State Logic:** All state transitions and the logic for updating state (the reducer function) are defined in a single, dedicated place. This makes the state management more organized, easier to understand, and simplifies maintenance compared to spreading state logic across multiple `useState` calls and components.\n2.  **Predictable State Updates:** State can only be updated by dispatching well-defined action objects. This makes the data flow unidirectional and transparent, reducing the likelihood of unexpected side effects or bugs. It's easy to track how and why state changes.\n3.  **Easy to Test:** Reducer functions are pure functions (given the same state and action, they always return the same new state). This purity makes them highly testable in isolation, without needing to render components or set up complex testing environments, which significantly improves code reliability.",
          "analysisPoints": [
            "The response should clearly articulate at least three distinct advantages.",
            "The explanation for each advantage should be concise and accurate.",
            "Examples from the TodoApp (e.g., dispatching actions for add/toggle/delete) can reinforce the points."
          ],
          "keyConcepts": [
            "useReducer",
            "useContext",
            "State Management Patterns",
            "Centralized State",
            "Pure Functions",
            "Testability"
          ],
          "evaluationCriteria": [
            "Completeness of advantages listed",
            "Clarity and accuracy of explanations",
            "Relevance to the provided code example"
          ],
          "example": "",
          "tags": [
            "React",
            "State Management",
            "useReducer",
            "useContext",
            "Architecture",
            "Open-Ended"
          ],
          "prerequisites": [
            "React State Management",
            "Reducer Pattern"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_management_code_1",
          "topic": "React Context and Reducer Pattern",
          "level": "hard",
          "type": "code",
          "question": "Consider a scenario where a user can perform 'undo' and 'redo' operations on the todo list. Modify the `todoReducer` to support these actions. The `state` for the reducer should now keep track of past, current, and future states to enable undo/redo functionality.",
          "answer": "```typescript\nimport React, { createContext, useReducer, useContext, useState } from 'react';\n\n// Initial state structure for undo/redo\nconst initialUndoableState = {\n  past: [],\n  current: [], // The actual todo list state\n  future: [],\n};\n\nconst undoableTodoReducer = (state, action) => {\n  const { past, current, future } = state;\n\n  switch (action.type) {\n    case 'ADD_TODO':\n    case 'TOGGLE_TODO':\n    case 'DELETE_TODO':\n      // Apply the actual todo modification logic\n      let newTodos;\n      switch (action.type) {\n        case 'ADD_TODO':\n          newTodos = [...current, { id: Date.now(), text: action.payload, completed: false }];\n          break;\n        case 'TOGGLE_TODO':\n          newTodos = current.map(todo =>\n            todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo\n          );\n          break;\n        case 'DELETE_TODO':\n          newTodos = current.filter(todo => todo.id !== action.payload);\n          break;\n        default: // Should not happen with the outer switch\n          newTodos = current;\n      }\n      return {\n        past: [...past, current], // Save current state to past\n        current: newTodos,       // New current state\n        future: [],              // Clear future for new actions\n      };\n    case 'UNDO':\n      if (past.length === 0) return state;\n      const previous = past[past.length - 1];\n      const newPast = past.slice(0, past.length - 1);\n      return {\n        past: newPast,\n        current: previous,\n        future: [current, ...future],\n      };\n    case 'REDO':\n      if (future.length === 0) return state;\n      const next = future[0];\n      const newFuture = future.slice(1);\n      return {\n        past: [...past, current],\n        current: next,\n        future: newFuture,\n      };\n    default:\n      return state;\n  }\n};\n\n// Update TodoProvider to use undoableTodoReducer\nconst TodoContext = createContext(null);\n\nexport const TodoProvider = ({ children }) => {\n  const [state, dispatch] = useReducer(undoableTodoReducer, initialUndoableState);\n\n  return (\n    <TodoContext.Provider value={{ todos: state.current, dispatch, canUndo: state.past.length > 0, canRedo: state.future.length > 0 }}>\n      {children}\n    </TodoContext.Provider>\n  );\n};\n\nexport const useTodo = () => {\n  const context = useContext(TodoContext);\n  if (!context) {\n    throw new Error('useTodo must be used within a TodoProvider');\n  }\n  return context;\n};\n\n// Components will need to use canUndo and canRedo for button disabling\nfunction AddTodo() {\n  const [text, setText] = useState('');\n  const { dispatch } = useTodo();\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (text.trim()) {\n      dispatch({ type: 'ADD_TODO', payload: text });\n      setText('');\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input \n        value={text} \n        onChange={(e) => setText(e.target.value)} \n        placeholder=\"Add a todo\"\n      />\n      <button type=\"submit\">Add</button>\n    </form>\n  );\n}\n\nfunction TodoList() {\n  const { todos, dispatch, canUndo, canRedo } = useTodo();\n  \n  return (\n    <div>\n      <div>\n        <button onClick={() => dispatch({ type: 'UNDO' })} disabled={!canUndo}>Undo</button>\n        <button onClick={() => dispatch({ type: 'REDO' })} disabled={!canRedo} style={{ marginLeft: '10px' }}>Redo</button>\n      </div>\n      <ul>\n        {todos.map(todo => (\n          <li \n            key={todo.id} \n            style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}\n          >\n            <span \n              onClick={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })} \n              style={{ cursor: 'pointer' }}\n            >\n              {todo.text}\n            </span>\n            <button \n              onClick={() => dispatch({ type: 'DELETE_TODO', payload: todo.id })} \n              style={{ marginLeft: '10px' }}\n            >\n              Delete\n            </button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nfunction TodoApp() {\n  return (\n    <TodoProvider>\n      <h1>Todo App with Undo/Redo</h1>\n      <AddTodo />\n      <TodoList />\n    </TodoProvider>\n  );\n}\n\nexport default TodoApp;\n```",
          "analysisPoints": [
            "The reducer's state structure must be modified to include `past`, `current`, and `future` arrays.",
            "Regular actions (`ADD_TODO`, `TOGGLE_TODO`, `DELETE_TODO`) must push the `current` state to `past` and clear `future`.",
            "The `UNDO` action should pop from `past` to `current` and push the old `current` to `future`.",
            "The `REDO` action should pop from `future` to `current` and push the old `current` to `past`.",
            "Edge cases for `UNDO` (empty `past`) and `REDO` (empty `future`) must be handled.",
            "The `TodoProvider` and `useTodo` hook need to expose `canUndo` and `canRedo` flags for UI control."
          ],
          "keyConcepts": [
            "State Machine",
            "useReducer",
            "Immutable Updates",
            "Undo/Redo Functionality",
            "Complex State Management"
          ],
          "evaluationCriteria": [
            "Correct implementation of undo/redo logic within the reducer.",
            "Proper handling of `past`, `current`, and `future` states.",
            "Immutability of state updates.",
            "Correct integration with Context API.",
            "Handling of edge cases (no more undo/redo)."
          ],
          "example": "",
          "tags": [
            "React",
            "State Management",
            "useReducer",
            "Context API",
            "Undo/Redo",
            "Hard",
            "Code Challenge"
          ],
          "prerequisites": [
            "Advanced useReducer",
            "Immutable Data Structures"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_state_management_flashcard_1",
          "topic": "React Context and Reducer Pattern",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of making a Reducer a pure function?",
          "answer": "Predictability and Testability. A pure reducer guarantees that for the same inputs (state and action), it will always produce the same output (new state), making it easy to reason about and test in isolation.",
          "analysisPoints": [],
          "keyConcepts": [
            "Pure Function",
            "Reducer",
            "Testability",
            "Predictability"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "React",
            "useReducer",
            "Pure Functions",
            "Flashcard"
          ],
          "prerequisites": [
            "Functional Programming Concepts"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_virtual_dom_mcq_1",
          "topic": "Virtual DOM in React",
          "level": "medium",
          "type": "mcq",
          "question": "What is the process React uses to compare the new Virtual DOM tree with the previous one to identify changes, and then apply only those necessary changes to the actual DOM?",
          "answer": "Reconciliation",
          "options": [
            "Hydration",
            "Reconciliation",
            "Diffing",
            "Virtualization"
          ],
          "analysisPoints": [
            "Hydration is for Server-Side Rendering (SSR).",
            "Diffing is the algorithm used *within* reconciliation.",
            "Virtualization refers to techniques like windowing for large lists.",
            "Reconciliation is the overarching process of comparing VDOMs and updating the real DOM."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Reconciliation",
            "Diffing Algorithm",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Understanding of React's rendering process",
            "Correct terminology"
          ],
          "example": "```\n// Simplified conceptual flow:\n// 1. Component state changes -> New Virtual DOM\n// 2. React performs Reconciliation (compares New VDOM with Old VDOM)\n// 3. Diffing algorithm finds minimal changes\n// 4. React updates actual DOM with only those minimal changes\n```",
          "tags": [
            "React",
            "Virtual DOM",
            "Reconciliation",
            "Performance",
            "MCQ"
          ],
          "prerequisites": [
            "Basic React Concepts"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_open_1",
          "topic": "Virtual DOM in React",
          "level": "medium",
          "type": "open",
          "question": "Beyond performance optimization, what are two other significant benefits of React's Virtual DOM, and how does it enable them?",
          "answer": "1.  **Cross-platform Compatibility:** The Virtual DOM acts as an abstraction layer between React components and the actual rendering environment. Since React works with its JavaScript representation (VDOM) instead of directly with the browser's DOM, it can be adapted to other platforms. For example, React Native uses a similar principle to render to native mobile UI components, and React 360 renders to VR environments, all because the VDOM decouples the UI description from the platform-specific rendering.\n2.  **Declarative Programming Model:** The Virtual DOM significantly contributes to React's declarative nature. Developers describe *what* the UI should look like for a given state, rather than *how* to change it. React, through its Virtual DOM and reconciliation process, handles all the imperative steps of manipulating the real DOM to match the desired declarative state. This simplifies development, as you don't manually track or manage DOM updates.",
          "analysisPoints": [
            "The answer should identify at least two benefits other than performance.",
            "Each benefit should be clearly explained with how the Virtual DOM enables it.",
            "Mention of React Native or other platforms for cross-platform compatibility is a good sign.",
            "Clear distinction between declarative vs. imperative programming."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Cross-Platform",
            "Declarative Programming",
            "Abstraction Layer"
          ],
          "evaluationCriteria": [
            "Identification of correct benefits",
            "Quality of explanation linking benefits to VDOM mechanism",
            "Clarity and conciseness"
          ],
          "example": "",
          "tags": [
            "React",
            "Virtual DOM",
            "Benefits",
            "Declarative UI",
            "Cross-Platform",
            "Open-Ended"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_flashcard_1",
          "topic": "Virtual DOM in React",
          "level": "easy",
          "type": "flashcard",
          "question": "True or False: React directly updates the actual DOM every time a component's state or props change.",
          "answer": "False. React updates a lightweight copy of the DOM (Virtual DOM) first, then compares it with the previous Virtual DOM, and finally applies only the minimal necessary changes to the actual DOM. This process is called reconciliation.",
          "analysisPoints": [],
          "keyConcepts": [
            "Virtual DOM",
            "Reconciliation",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "React",
            "Virtual DOM",
            "Flashcard"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_concurrent_mode_mcq_1",
          "topic": "React Concurrent Mode",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following Concurrent Mode features allows React to pause a rendering update to handle a more urgent user interaction, then resume the paused work later?",
          "answer": "Interruptible Rendering",
          "options": [
            "Time Slicing",
            "Suspense for Data Fetching",
            "Priority-Based Rendering",
            "Interruptible Rendering"
          ],
          "analysisPoints": [
            "Time Slicing is a mechanism that enables Interruptible Rendering.",
            "Suspense is for managing loading states during data fetching.",
            "Priority-Based Rendering dictates *which* work gets priority, but Interruptible Rendering describes the *ability to pause and resume*.",
            "Interruptible Rendering directly describes the pausing and resuming behavior for responsiveness."
          ],
          "keyConcepts": [
            "Concurrent Mode",
            "Interruptible Rendering",
            "Responsiveness"
          ],
          "evaluationCriteria": [
            "Understanding of Concurrent Mode features",
            "Distinction between related concepts"
          ],
          "example": "```\n// Imagine a complex filter operation running.\n// User types in an input field (high priority).\n// Concurrent Mode: pauses filter rendering, handles input, then resumes filter.\n```",
          "tags": [
            "React",
            "Concurrent Mode",
            "Performance",
            "UX",
            "MCQ"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_concurrent_mode_open_1",
          "topic": "React Concurrent Mode",
          "level": "hard",
          "type": "open",
          "question": "Describe how Suspense for Data Fetching, a feature of Concurrent Mode, improves user experience and simplifies development compared to traditional data fetching approaches in React.",
          "answer": "Suspense for Data Fetching improves user experience by enabling smoother loading states. Instead of manually tracking `isLoading` flags, showing conditional rendering logic (e.g., `if (isLoading) return <Spinner />`), and potentially encountering 'waterfall' issues with nested data fetches, Suspense allows you to declaratively specify a `fallback` UI. When a component (or any descendant) is fetching data, it 'suspends' rendering, and React automatically displays the nearest `Suspense` boundary's fallback. This prevents rendering incomplete UIs and provides a consistent loading experience without complex manual orchestration.\n\nFrom a development perspective, Suspense simplifies asynchronous logic significantly. Developers can write components as if data is immediately available, and the framework handles the waiting state automatically. This leads to cleaner, more readable code, as loading logic is decoupled from the component's core rendering logic. It also helps avoid 'render-as-you-fetch' patterns, allowing you to kick off data fetching earlier.",
          "analysisPoints": [
            "Explain how Suspense works (declarative fallback, throwing promises).",
            "Compare it to traditional `isLoading` state management.",
            "Detail the UX benefits (no blank screens, consistent loading).",
            "Detail the DX benefits (cleaner code, simplified async logic, decoupling).",
            "Mention the concept of 'render-as-you-fetch' implicitly or explicitly."
          ],
          "keyConcepts": [
            "Concurrent Mode",
            "Suspense",
            "Data Fetching",
            "User Experience",
            "Developer Experience",
            "Declarative Programming"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of Suspense's mechanism.",
            "Clear articulation of both UX and DX improvements.",
            "Ability to contrast with traditional methods.",
            "Depth of understanding of Concurrent Mode's impact."
          ],
          "example": "",
          "tags": [
            "React",
            "Concurrent Mode",
            "Suspense",
            "Data Fetching",
            "UX",
            "DX",
            "Open-Ended"
          ],
          "prerequisites": [
            "Asynchronous JavaScript",
            "React State"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_concurrent_mode_flashcard_1",
          "topic": "React Concurrent Mode",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary goal of React's Concurrent Mode?",
          "answer": "To help applications stay responsive and gracefully adjust to user device capabilities and network speed by allowing React to work on multiple tasks concurrently and prioritize urgent updates.",
          "analysisPoints": [],
          "keyConcepts": [
            "Concurrent Mode",
            "Responsiveness",
            "Prioritization"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "React",
            "Concurrent Mode",
            "Flashcard"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_todo_with_reducer_context",
          "title": "Build a Simple Shopping List with `useReducer` and `useContext`",
          "description": "\nImplement a small shopping list application using the `useReducer` and `useContext` pattern for state management. \n\n**Requirements:**\n1.  **Add Item:** Users should be able to add new items to the list via an input field and a button.\n2.  **Remove Item:** Each item in the list should have a 'Remove' button to delete it.\n3.  **Toggle Purchased:** Each item should have a way to toggle its 'purchased' status (e.g., strike-through text).\n4.  **Centralized State Logic:** All state transitions (add, remove, toggle) must be handled by a single `reducer` function.\n5.  **Context for Global State:** The list state and the `dispatch` function should be provided to components via React Context.\n6.  **Custom Hook:** Create a custom hook (e.g., `useShoppingList`) to simplify consuming the context in components.\n7.  **Display:** Render the list of items, showing their status.\n\nYour solution should demonstrate a clear separation of concerns, with the reducer handling state logic and components interacting via `dispatch`.\n",
          "difficulty": "medium",
          "startingCode": "import React, { createContext, useReducer, useContext, useState } from 'react';\n\n// TODO: 1. Define your reducer function for shopping list actions\nconst shoppingListReducer = (state, action) => {\n  switch (action.type) {\n    // Implement ADD_ITEM, REMOVE_ITEM, TOGGLE_PURCHASED\n    default:\n      return state;\n  }\n};\n\n// TODO: 2. Create Context for the shopping list\nconst ShoppingListContext = createContext(null);\n\n// TODO: 3. Create the ShoppingListProvider component\nexport const ShoppingListProvider = ({ children }) => {\n  const [items, dispatch] = useReducer(shoppingListReducer, []); // Initial state is an empty array\n\n  return (\n    <ShoppingListContext.Provider value={{ items, dispatch }}>\n      {children}\n    </ShoppingListContext.Provider>\n  );\n};\n\n// TODO: 4. Create a custom hook to use the shopping list context\nexport const useShoppingList = () => {\n  const context = useContext(ShoppingListContext);\n  if (!context) {\n    throw new Error('useShoppingList must be used within a ShoppingListProvider');\n  }\n  return context;\n};\n\n// TODO: 5. Implement AddItemForm component\nfunction AddItemForm() {\n  const [itemName, setItemName] = useState('');\n  const { dispatch } = useShoppingList();\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (itemName.trim()) {\n      // TODO: Dispatch ADD_ITEM action\n      setItemName('');\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        value={itemName}\n        onChange={(e) => setItemName(e.target.value)}\n        placeholder=\"Add new item\"\n      />\n      <button type=\"submit\">Add Item</button>\n    </form>\n  );\n}\n\n// TODO: 6. Implement ShoppingListItem component\nfunction ShoppingListItem({ item }) {\n  const { dispatch } = useShoppingList();\n\n  return (\n    <li style={{ textDecoration: item.purchased ? 'line-through' : 'none' }}>\n      <span onClick={() => { /* TODO: Dispatch TOGGLE_PURCHASED action */ }} style={{ cursor: 'pointer' }}>\n        {item.name}\n      </span>\n      <button onClick={() => { /* TODO: Dispatch REMOVE_ITEM action */ }} style={{ marginLeft: '10px' }}>\n        Remove\n      </button>\n    </li>\n  );\n}\n\n// TODO: 7. Implement ShoppingListDisplay component\nfunction ShoppingListDisplay() {\n  const { items } = useShoppingList();\n\n  return (\n    <ul>\n      {items.map(item => (\n        <ShoppingListItem key={item.id} item={item} />\n      ))}\n    </ul>\n  );\n}\n\n// Main App component\nexport default function ShoppingApp() {\n  return (\n    <ShoppingListProvider>\n      <h1>My Shopping List</h1>\n      <AddItemForm />\n      <ShoppingListDisplay />\n    </ShoppingListProvider>\n  );\n}\n",
          "solutionCode": "import React, { createContext, useReducer, useContext, useState } from 'react';\n\n// 1. Define your reducer function for shopping list actions\nconst shoppingListReducer = (state, action) => {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      return [...state, { id: Date.now(), name: action.payload, purchased: false }];\n    case 'REMOVE_ITEM':\n      return state.filter(item => item.id !== action.payload);\n    case 'TOGGLE_PURCHASED':\n      return state.map(item =>\n        item.id === action.payload ? { ...item, purchased: !item.purchased } : item\n      );\n    default:\n      return state;\n  }\n};\n\n// 2. Create Context for the shopping list\nconst ShoppingListContext = createContext(null);\n\n// 3. Create the ShoppingListProvider component\nexport const ShoppingListProvider = ({ children }) => {\n  const [items, dispatch] = useReducer(shoppingListReducer, []); // Initial state is an empty array\n\n  return (\n    <ShoppingListContext.Provider value={{ items, dispatch }}>\n      {children}\n    </ShoppingListContext.Provider>\n  );\n};\n\n// 4. Create a custom hook to use the shopping list context\nexport const useShoppingList = () => {\n  const context = useContext(ShoppingListContext);\n  if (!context) {\n    throw new Error('useShoppingList must be used within a ShoppingListProvider');\n  }\n  return context;\n};\n\n// 5. Implement AddItemForm component\nfunction AddItemForm() {\n  const [itemName, setItemName] = useState('');\n  const { dispatch } = useShoppingList();\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (itemName.trim()) {\n      dispatch({ type: 'ADD_ITEM', payload: itemName });\n      setItemName('');\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        value={itemName}\n        onChange={(e) => setItemName(e.target.value)}\n        placeholder=\"Add new item\"\n      />\n      <button type=\"submit\">Add Item</button>\n    </form>\n  );\n}\n\n// 6. Implement ShoppingListItem component\nfunction ShoppingListItem({ item }) {\n  const { dispatch } = useShoppingList();\n\n  return (\n    <li style={{ textDecoration: item.purchased ? 'line-through' : 'none' }}>\n      <span onClick={() => dispatch({ type: 'TOGGLE_PURCHASED', payload: item.id })} style={{ cursor: 'pointer' }}>\n        {item.name}\n      </span>\n      <button onClick={() => dispatch({ type: 'REMOVE_ITEM', payload: item.id })} style={{ marginLeft: '10px' }}>\n        Remove\n      </button>\n    </li>\n  );\n}\n\n// 7. Implement ShoppingListDisplay component\nfunction ShoppingListDisplay() {\n  const { items } = useShoppingList();\n\n  return (\n    <ul>\n      {items.map(item => (\n        <ShoppingListItem key={item.id} item={item} />\n      ))}\n    </ul>\n  );\n}\n\n// Main App component\nexport default function ShoppingApp() {\n  return (\n    <ShoppingListProvider>\n      <h1>My Shopping List</h1>\n      <AddItemForm />\n      <ShoppingListDisplay />\n    </ShoppingListProvider>\n  );\n}\n",
          "testCases": [
            "**Test Case 1: Add Item**\n1.  Open the application.\n2.  Type 'Apples' into the input field.\n3.  Click 'Add Item'.\nExpected: 'Apples' should appear in the list.",
            "**Test Case 2: Remove Item**\n1.  Add 'Bananas' to the list.\n2.  Click the 'Remove' button next to 'Bananas'.\nExpected: 'Bananas' should be removed from the list.",
            "**Test Case 3: Toggle Purchased Status**\n1.  Add 'Milk' to the list.\n2.  Click on the 'Milk' text.\nExpected: 'Milk' should be struck through. Click again, and the strike-through should be removed.",
            "**Test Case 4: Empty Input Handling**\n1.  Attempt to add an empty item (just click 'Add Item' without typing).\nExpected: No new item should be added to the list."
          ],
          "hints": [
            "Remember that reducer actions usually have a `type` and a `payload`.",
            "When removing or toggling an item, the `payload` should typically be the item's unique `id`.",
            "Ensure your reducer returns a new state object/array for every update to maintain immutability."
          ],
          "tags": [
            "React",
            "State Management",
            "useReducer",
            "useContext",
            "Context API",
            "Frontend Interview",
            "Shopping List"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Hooks",
            "JavaScript Arrays (map, filter, spread syntax)"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Centralized State",
            "Pure Functions",
            "Immutability"
          ]
        },
        {
          "id": "task_optimize_list_re_renders_virtual_dom",
          "title": "Optimize a Large List Rendering to Showcase Virtual DOM Principles",
          "description": "\nWhile you can't directly 'implement' the Virtual DOM, you can demonstrate understanding of its principles by optimizing a React component that renders a large list to prevent unnecessary re-renders. This task focuses on leveraging `React.memo` and `useCallback` to improve performance, mimicking how React's efficient reconciliation works by minimizing actual DOM updates.\n\n**Requirements:**\n1.  **Initial Setup:** Create a `Parent` component that manages a counter (`useState`) and renders a `ChildList` component. The `ChildList` component receives an array of `items` and a `handleClick` function as props, and renders many `ListItem` components.\n2.  **Performance Issue:** Initially, ensure that incrementing the counter in `Parent` causes *all* `ListItem` components to re-render, even though only the counter state changed (this simulates a common performance pitfall).\n3.  **Optimization with `React.memo`:** Wrap the `ChildList` and `ListItem` components with `React.memo`.\n4.  **Optimization with `useCallback`:** Memoize the `handleClick` function passed from `Parent` to `ChildList` using `useCallback`.\n5.  **Verification:** Add `console.log` statements to `ChildList` and `ListItem` to track when they re-render. Demonstrate that after optimization, only `Parent` re-renders when the counter changes, and the list items do not.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// Generate a large list of items\nconst generateItems = (count) => {\n  return Array.from({ length: count }, (_, i) => ({ id: i, text: `Item ${i}` }));\n};\n\n// Child component representing a single item in the list\nfunction ListItem({ item, onClick }) {\n  console.log(`Rendering ListItem ${item.id}`); // For debugging re-renders\n  return (\n    <li onClick={() => onClick(item.id)}>\n      {item.text}\n    </li>\n  );\n}\n\n// Child component that renders the list of items\nfunction ChildList({ items, onItemClick }) {\n  console.log('Rendering ChildList'); // For debugging re-renders\n  return (\n    <ul>\n      {items.map(item => (\n        <ListItem key={item.id} item={item} onClick={onItemClick} />\n      ))}\n    </ul>\n  );\n}\n\n// Parent component managing state and passing props\nexport default function Parent() {\n  const [count, setCount] = useState(0);\n  const items = generateItems(1000); // A large list\n\n  const handleItemClick = (id) => {\n    console.log(`Clicked item: ${id}`);\n  };\n\n  console.log('Rendering Parent'); // For debugging re-renders\n\n  return (\n    <div>\n      <h1>Parent Component</h1>\n      <p>Counter: {count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>Increment Counter</button>\n      <hr />\n      <ChildList items={items} onItemClick={handleItemClick} />\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState, useEffect, memo, useCallback } from 'react';\n\n// Generate a large list of items\nconst generateItems = (count) => {\n  return Array.from({ length: count }, (_, i) => ({ id: i, text: `Item ${i}` }));\n};\n\n// Child component representing a single item in the list - NOW MEMOIZED\nconst ListItem = memo(function ListItem({ item, onClick }) {\n  console.log(`Rendering ListItem ${item.id}`); // For debugging re-renders\n  return (\n    <li onClick={() => onClick(item.id)}>\n      {item.text}\n    </li>\n  );\n});\n\n// Child component that renders the list of items - NOW MEMOIZED\nconst ChildList = memo(function ChildList({ items, onItemClick }) {\n  console.log('Rendering ChildList'); // For debugging re-renders\n  return (\n    <ul>\n      {items.map(item => (\n        <ListItem key={item.id} item={item} onClick={onItemClick} />\n      ))}\n    </ul>\n  );\n});\n\n// Parent component managing state and passing props\nexport default function Parent() {\n  const [count, setCount] = useState(0);\n  const items = generateItems(1000); // A large list\n\n  // Memoize the function passed to ChildList using useCallback\n  const handleItemClick = useCallback((id) => {\n    console.log(`Clicked item: ${id}`);\n  }, []); // Empty dependency array means this function reference is stable\n\n  console.log('Rendering Parent'); // For debugging re-renders\n\n  return (\n    <div>\n      <h1>Parent Component</h1>\n      <p>Counter: {count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>Increment Counter</button>\n      <hr />\n      <ChildList items={items} onItemClick={handleItemClick} />\n    </div>\n  );\n}\n",
          "testCases": [
            "**Test Case 1: Initial Render**\n1.  Run the application.\nExpected: Console logs should show 'Rendering Parent', 'Rendering ChildList', and 'Rendering ListItem' for all 1000 items once.",
            "**Test Case 2: Counter Increment (Before Optimization)**\n1.  Start with the `startingCode`.\n2.  Click 'Increment Counter'.\nExpected: Console logs should show 'Rendering Parent', 'Rendering ChildList', and 'Rendering ListItem' for all 1000 items again, even though the list data didn't change.",
            "**Test Case 3: Counter Increment (After Optimization)**\n1.  Implement the solution using `React.memo` and `useCallback`.\n2.  Click 'Increment Counter'.\nExpected: Console logs should only show 'Rendering Parent'. 'Rendering ChildList' and 'Rendering ListItem' logs should *not* appear, demonstrating that the list components are memoized and not re-rendering unnecessarily."
          ],
          "hints": [
            "`React.memo` is a higher-order component that memoizes functional components. It prevents re-renders if props haven't changed.",
            "`useCallback` is a hook that memoizes functions. It returns a memoized version of the callback that only changes if one of the `dependencies` has changed.",
            "Pay close attention to the dependency array of `useCallback` to ensure the function reference remains stable."
          ],
          "tags": [
            "React",
            "Performance Optimization",
            "Virtual DOM",
            "React.memo",
            "useCallback",
            "Frontend Interview",
            "Rendering"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Hooks",
            "Component Lifecycle",
            "Basic Performance Concepts"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Reconciliation",
            "Pure Components",
            "Shallow Comparison"
          ]
        },
        {
          "id": "task_implement_suspense_loading_profile",
          "title": "Implement User Profile Loading with React Suspense",
          "description": "\nCreate a React application that fetches user profile data asynchronously and utilizes React Suspense to manage the loading state. This task will demonstrate your understanding of `Suspense` for data fetching, a key concept in React's Concurrent Mode.\n\n**Requirements:**\n1.  **Simulated API:** Create a function `fetchUserProfile(userId)` that returns a Promise which resolves with user data after a delay (e.g., 2 seconds). This simulates an API call.\n2.  **`UserProfile` Component:** Create a `UserProfile` component that takes `userId` as a prop. Inside this component, call the `fetchUserProfile` function. To make it Suspense-ready, you'll need a simple wrapper that throws the promise if the data isn't ready (as shown in the `createUserResource` example in the theory).\n3.  **`Suspense` Boundary:** Wrap the `UserProfile` component with a `<Suspense>` boundary and provide a `fallback` UI (e.g., `<div>Loading profile...</div>`).\n4.  **Error Boundary (Optional but good practice):** For a more robust solution, consider wrapping `Suspense` in an `ErrorBoundary` to gracefully handle fetch errors.\n5.  **User Interaction:** Add a button in the parent component to toggle between two different `userId`s, triggering new data fetches and demonstrating the Suspense loading state.\n",
          "difficulty": "hard",
          "startingCode": "import React, { Suspense, useState, useEffect } from 'react';\n\n// 1. Simulate an asynchronous data fetch function\nconst fetchUserProfile = (userId) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({ id: userId, name: `User ${userId}`, email: `user${userId}@example.com` });\n    }, 2000); // Simulate network delay\n  });\n};\n\n// TODO: Implement a simple resource cache/wrapper for Suspense\n// This is crucial for making the component Suspense-ready.\n// A basic implementation would involve a map to store promises/results\n// and a `read()` method that throws the promise if not resolved.\nlet userResourceCache = {}; // Example cache\nconst createSuspenseResource = (asyncFn, key) => {\n  // Implement resource creation logic here\n  // Check if key exists in cache, if not, create promise, update status, and store\n  // The read() method should throw the promise if status is 'pending'\n  // return { read() { /* ... */ } };\n};\n\n// TODO: 2. Implement UserProfile component\nfunction UserProfile({ userId }) {\n  // Use the Suspense-ready resource here\n  // const user = resource.read();\n  return (\n    <div>\n      <h3>User Details for {userId}</h3>\n      {/* Display user data */}\n      <p>Loading...</p> {/* This should be replaced by actual data once resource.read() returns */}\n    </div>\n  );\n}\n\n// Main App component\nexport default function App() {\n  const [currentUserId, setCurrentUserId] = useState(1);\n\n  return (\n    <div>\n      <h1>User Profile Viewer</h1>\n      <button onClick={() => setCurrentUserId(currentUserId === 1 ? 2 : 1)}>\n        Load {currentUserId === 1 ? 'User 2' : 'User 1'}\n      </button>\n      <hr/>\n      {/* TODO: 3. Wrap UserProfile with Suspense and provide a fallback */}\n      {/* TODO: 4. (Optional) Wrap Suspense with an ErrorBoundary */}\n      <UserProfile userId={currentUserId} />\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { Suspense, useState, useEffect } from 'react';\n\n// 1. Simulate an asynchronous data fetch function\nconst fetchUserProfile = (userId) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({ id: userId, name: `User ${userId}`, email: `user${userId}@example.com` });\n    }, 2000); // Simulate network delay\n  });\n};\n\n// 1a. Simple resource cache/wrapper for Suspense\n// In a real application, you'd typically use a library like React Query or SWR\n// that provides Suspense-ready hooks, or a more robust custom implementation.\nconst resourceCache = new Map();\n\nconst createSuspenseResource = (promiseCreator, key) => {\n  if (!resourceCache.has(key)) {\n    let status = 'pending';\n    let result;\n    const suspender = promiseCreator(key).then(\n      r => { status = 'success'; result = r; },\n      e => { status = 'error'; result = e; }\n    );\n    resourceCache.set(key, {\n      read() {\n        if (status === 'pending') {\n          throw suspender; // Suspense catches this promise\n        } else if (status === 'error') {\n          throw result;    // Propagate error\n        } else {\n          return result;   // Return data\n        }\n      },\n    });\n  }\n  return resourceCache.get(key);\n};\n\n// 2. Implement UserProfile component\nfunction UserProfile({ userId }) {\n  // Use the Suspense-ready resource here\n  const userResource = createSuspenseResource(fetchUserProfile, userId);\n  const user = userResource.read(); // This will throw a promise if data is not ready\n\n  return (\n    <div>\n      <h3>User Details for {user.name}</h3>\n      <p>ID: {user.id}</p>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n}\n\n// 4. (Optional) Implement a basic ErrorBoundary for better error handling\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error: error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.error(\"Caught error:\", error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h2>Something went wrong loading the profile: {this.state.error?.message || 'Unknown error'}</h2>;\n    }\n    return this.props.children;\n  }\n}\n\n// Main App component\nexport default function App() {\n  const [currentUserId, setCurrentUserId] = useState(1);\n\n  return (\n    <div>\n      <h1>User Profile Viewer</h1>\n      <button onClick={() => setCurrentUserId(currentUserId === 1 ? 2 : 1)}>\n        Load {currentUserId === 1 ? 'User 2' : 'User 1'}\n      </button>\n      <hr/>\n      <ErrorBoundary>\n        {/* 3. Wrap UserProfile with Suspense and provide a fallback */}\n        <Suspense fallback={<div>Loading profile for user {currentUserId}...</div>}>\n          <UserProfile userId={currentUserId} />\n        </Suspense>\n      </ErrorBoundary>\n    </div>\n  );\n}\n",
          "testCases": [
            "**Test Case 1: Initial Load**\n1.  Open the application.\nExpected: 'Loading profile for user 1...' should appear for approx. 2 seconds, then User 1's details.",
            "**Test Case 2: Toggle User**\n1.  Click the 'Load User 2' button.\nExpected: 'Loading profile for user 2...' should appear for approx. 2 seconds, then User 2's details.",
            "**Test Case 3: Rapid Toggling**\n1.  Rapidly click the toggle button multiple times.\nExpected: The loading fallback should appear and disappear smoothly. The UI should not 'flash' or become unresponsive. The correct user's profile should eventually display, even if requests are overlapped.",
            "**Test Case 4: Error Handling (Manual Simulation)**\n1.  Modify `fetchUserProfile` to sometimes reject the promise (e.g., `if (userId === 99) reject(new Error('User not found'));`).\n2.  Try to load user 99.\nExpected: The `ErrorBoundary`'s fallback should render, displaying an error message instead of the Suspense fallback."
          ],
          "hints": [
            "The core idea for Suspense-ready components is that they 'throw' a promise when data is not ready. React's Suspense boundary catches this promise.",
            "A common pattern for a simple Suspense-ready data source involves a cache (e.g., a Map) to store the state of your data promises (pending, resolved, rejected).",
            "The `read()` method of your resource wrapper is where the promise should be thrown if the data isn't ready. If it's ready, `read()` returns the data; if it errored, `read()` throws the error.",
            "Remember that `ErrorBoundary` is a class component as functional components don't yet support `getDerivedStateFromError` or `componentDidCatch`."
          ],
          "tags": [
            "React",
            "Concurrent Mode",
            "Suspense",
            "Data Fetching",
            "Asynchronous JavaScript",
            "Frontend Interview",
            "Error Handling"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React Hooks",
            "Promises",
            "Error Handling in React"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Error Boundaries",
            "Loading States",
            "User Experience Optimization"
          ]
        }
      ]
    }
  },
  {
    "id": "504016ce-30d4-4af1-bb18-d2bf41698cfc",
    "startLine": 7700,
    "endLine": 7799,
    "processedDate": "2025-06-17T10:30:00.266Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_concurrent_mode_suspense",
          "title": "Concurrent Mode, Suspense, and SuspenseList",
          "content": "Concurrent Mode is an experimental set of features in React designed to improve user experience by enabling applications to remain responsive even during heavy computational tasks or network requests. It allows React to work on multiple tasks concurrently, prioritizing updates and ensuring smoother user interfaces. While Concurrent Mode itself is still experimental and not fully recommended for production in all applications, individual stable features derived from it are being gradually released.\n\n## Key Concepts\n\n### `unstable_createRoot`\nTo opt into Concurrent Mode features, `unstable_createRoot` (or the stable `createRoot` introduced in React 18) is used instead of `ReactDOM.render`. This new root API enables features like automatic batching, transitions, and Suspense for data fetching.\n\n### Suspense\n`Suspense` is a React component that lets you \"wait\" for some code to load dynamically and declaratively specify a loading state (a fallback UI) while it's loading. It's primarily used for code splitting with `React.lazy` and for data fetching with Suspense-enabled data libraries. When a component wrapped in `Suspense` (or any of its children) 'suspends' (e.g., waits for data to load), the `fallback` UI is displayed.\n\n### SuspenseList\n`SuspenseList` is a component used to coordinate the order in which `Suspense` and `React.lazy` components reveal their content. It's useful when you have multiple Suspense boundaries and want to prevent them from showing all their fallbacks at once or reveal them in a specific sequence. It accepts `revealOrder` and `tail` props:\n- `revealOrder`: Can be `forwards`, `backwards`, or `together`.\n  - `forwards`: Children are revealed in the order they appear in the component tree.\n  - `backwards`: Children are revealed in reverse order.\n  - `together`: All children are revealed at once, only after all of them have resolved.\n- `tail`: Can be `collapsed` or `hidden`.\n  - `collapsed`: Only shows one fallback at a time, hiding subsequent ones until the preceding ones resolve.\n  - `hidden`: Hides all fallbacks after the first one resolves, showing only the first until its content is ready.\n\n## Benefits of Concurrent Mode\n\n1.  **Improved User Experience**: Applications feel more responsive and fluid, even during data fetching or heavy computations, especially on slower devices.\n2.  **Smoother Transitions**: Loading states can be coordinated, prioritized, and non-blocking, leading to fewer abrupt changes in the UI.\n3.  **Fewer Loading Indicators**: With `Suspense` and `SuspenseList`, content can be displayed incrementally, reducing the need for all-or-nothing loading screens and providing a more progressive user experience.\n4.  **Better Error Handling**: Errors can be caught and handled more gracefully at the component level using `Error Boundaries`, which complement Suspense by allowing you to define fallback UIs for errors during rendering or data fetching.\n\n## Status\nConcurrent Mode is an umbrella term for a set of experimental features. While `createRoot` is stable in React 18, the full Concurrent Mode features like automatic batching and transitions are built upon it. Suspense for data fetching requires a Suspense-enabled data fetching solution (like Relay, Apollo, or a custom one built with `use` hook) and is still evolving. It's generally not recommended for production use without careful consideration and understanding of its implications.",
          "examples": [
            {
              "id": "example_concurrent_mode_1",
              "title": "Basic Suspense and SuspenseList Usage",
              "code": "import React, { Suspense, SuspenseList, unstable_createRoot as createRoot } from 'react';\n\n// Mock data fetching utility\nconst createResource = (fetcher) => {\n  let status = 'pending';\n  let result;\n  let suspender = fetcher().then(\n    (r) => {\n      status = 'success';\n      result = r;\n    },\n    (e) => {\n      status = 'error';\n      result = e;\n    }\n  );\n  return {\n    read() {\n      if (status === 'pending') {\n        throw suspender;\n      } else if (status === 'error') {\n        throw result;\n      } else if (status === 'success') {\n        return result;\n      }\n    },\n  };\n};\n\n// Simulate an async data fetch\nconst fetchUserData = (userId) => {\n  return createResource(\n    () => new Promise((resolve) =>\n      setTimeout(() => {\n        resolve({ id: userId, name: `User ${userId}`, bio: `Bio for User ${userId}` });\n      }, 1000 + Math.random() * 1000)\n    )\n  );\n};\n\nconst fetchPostsData = (userId) => {\n  return createResource(\n    () => new Promise((resolve) =>\n      setTimeout(() => {\n        resolve([\n          { id: 1, title: `Post 1 by User ${userId}` },\n          { id: 2, title: `Post 2 by User ${userId}` }\n        ]);\n      }, 1500 + Math.random() * 1000)\n    )\n  );\n};\n\n// Components that simulate data fetching and can suspend\nfunction ProfileHeader() {\n  const userResource = fetchUserData(1);\n  const user = userResource.read(); // This will suspend if data is not ready\n  return <h2>{user.name}'s Profile</h2>;\n}\n\nfunction ProfileDetails() {\n  const userResource = fetchUserData(1);\n  const user = userResource.read(); // This will suspend if data is not ready\n  return <div>{user.bio}</div>;\n}\n\nfunction ProfilePosts() {\n  const postsResource = fetchPostsData(1);\n  const posts = postsResource.read(); // This will suspend if data is not ready\n  return (\n    <div>\n      <h3>Posts</h3>\n      <ul>\n        {posts.map(post => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>Concurrent Mode Demo</h1>\n      <SuspenseList revealOrder=\"forwards\" tail=\"collapsed\">\n        <Suspense fallback={<div>Loading header...</div>}>\n          <ProfileHeader />\n        </Suspense>\n        <Suspense fallback={<div>Loading details...</div>}>\n          <ProfileDetails />\n        </Suspense>\n        <Suspense fallback={<div>Loading posts...</div>}>\n          <ProfilePosts />\n        </Suspense>\n      </SuspenseList>\n    </div>\n  );\n}\n\nconst rootEl = document.getElementById('root');\n// In React 18, replace unstable_createRoot with createRoot\nconst root = createRoot(rootEl);\nroot.render(<App />);\n\n// Basic HTML for #root:\n// <div id=\"root\"></div>",
              "explanation": "This example demonstrates how `Suspense` and `SuspenseList` work together. Each `Profile` component internally uses a `createResource` utility to simulate asynchronous data fetching. When `resource.read()` is called and the data isn't ready, it 'throws' a Promise, causing the nearest `Suspense` boundary to activate and display its `fallback` UI. `SuspenseList` then coordinates the display of these fallbacks and the subsequent revelation of content. With `revealOrder=\"forwards\"` and `tail=\"collapsed\"`, the fallbacks appear one by one, and content is revealed in the order it's defined, improving the perceived loading experience.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_unstable_create_root_1",
            "question_suspenselist_purpose_1",
            "question_concurrent_mode_benefits_1",
            "question_suspense_data_fetching_1",
            "question_suspenselist_revealorder_1",
            "question_concurrent_mode_status_1"
          ],
          "relatedTasks": [
            "task_suspense_list_coordination"
          ],
          "tags": [
            "React",
            "Concurrent Mode",
            "Suspense",
            "SuspenseList",
            "Performance",
            "User Experience",
            "React 18"
          ],
          "technology": "React",
          "prerequisites": [
            "React Components",
            "State Management",
            "Asynchronous JavaScript",
            "Error Boundaries"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "Modern React Development",
            "Large Scale React Applications",
            "Performance Optimization"
          ]
        },
        {
          "id": "theory_react_server_components",
          "title": "React Server Components (RSC)",
          "content": "React Server Components (RSC) represent a significant architectural shift in React, enabling developers to build applications that seamlessly span both server and client environments. This paradigm aims to combine the best aspects of traditional server rendering (performance, SEO, access to server resources) with the rich interactivity of client-side React applications, without compromising on bundle size or user experience.\n\n## Key Concepts\n\n### Server Components vs. Client Components\n\n-   **Server Components (`.server.jsx`, `use server`)**:\n    -   **Execution Environment**: Rendered exclusively on the server. They never execute or bundle their JavaScript code on the client.\n    -   **Bundle Size**: Contribute zero bytes to the client-side JavaScript bundle size. This is a major advantage for initial page load performance.\n    -   **Resource Access**: Can directly access server-side resources like databases, file systems, or private APIs without needing to expose API endpoints or use client-side data fetching.\n    -   **State/Interactivity**: By default, they are stateless and non-interactive. To add interactivity, they must render Client Components.\n    -   **Usage**: Ideal for fetching data, accessing backend services, or rendering static/semi-static content that doesn't require client-side interactivity.\n    -   **Serialization**: Their rendered output (React elements, not HTML directly) is serialized and sent to the client, where React hydrates it.\n\n-   **Client Components (`.client.jsx`, `use client`)**:\n    -   **Execution Environment**: Rendered on the client (browser), similar to traditional React components. They can also be pre-rendered on the server for initial HTML output (SSR/SSG), but their JavaScript is always sent to the client for hydration and interactivity.\n    -   **Bundle Size**: Their JavaScript code is part of the client-side bundle.\n    -   **Resource Access**: Cannot directly access server-side resources. They fetch data via API calls (e.g., `fetch` from the browser) or use client-side state management.\n    -   **State/Interactivity**: Fully interactive, can use state (`useState`), effects (`useEffect`), and event listeners.\n    -   **Usage**: Necessary for any client-side interactivity, state management, or browser-specific APIs (e.g., `localStorage`, `navigator`).\n\n### Coexistence and Composition\nServer Components and Client Components can coexist within the same component tree. Importantly:\n-   Server Components can render Client Components. This is how interactivity is brought into an RSC-based application.\n-   Client Components **cannot** directly render Server Components. If a Client Component needs to display content from a Server Component, the Server Component must pass that content as a prop (e.g., `children`).\n\n### Zero Bundle Size for Server Components\nThis is a core tenet of RSCs. Since Server Components only execute on the server and their JavaScript is never sent to the client, they do not contribute to the client-side JavaScript bundle. This significantly reduces the amount of code the browser needs to download and parse, leading to faster initial page loads and better Lighthouse scores.\n\n### Automatic Code Splitting\nReact Server Components work hand-in-hand with automatic code splitting. Client Components are automatically code-split, meaning their JavaScript bundles are only loaded when they are needed by the browser. This further optimizes initial load times by only sending the essential JavaScript for the visible parts of the application.\n\n### Directives: `'use server'` and `'use client'`\nThese are module-level directives placed at the very top of a file:\n-   `'use server'`: Marks a module as a Server Component or a server action/function. All exports from this module are considered server-only.\n-   `'use client'`: Marks a module as a Client Component. This indicates that the component contains client-side interactivity and must be bundled for the browser.",
          "examples": [
            {
              "id": "example_rsc_server_component",
              "title": "Server Component Example (`.server.jsx`)",
              "code": "// ServerComponent.server.jsx - runs only on the server\n'use server';\n\n// In a real application, 'db' would be a database connection utility.\n// For this example, we'll simulate a database call.\nconst db = {\n  query: async (sql) => {\n    console.log(`Executing server query: ${sql}`);\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve([\n          { id: 1, name: 'Alice' },\n          { id: 2, name: 'Bob' },\n          { id: 3, name: 'Charlie' }\n        ]);\n      }, 500);\n    });\n  }\n};\n\n// Import a Client Component to be rendered within the Server Component\nimport ClientCounter from './ClientCounter.client.jsx';\n\n// This component fetches data on the server\n// and its JavaScript is never sent to the client\nexport default async function ServerComponent() {\n  const data = await db.query('SELECT * FROM users');\n  \n  return (\n    <div>\n      <h1>Users from Server</h1>\n      <ul>\n        {data.map(user => (\n          <li key={user.id}>{user.name}</li>\n        ))}\n      </ul>\n      <p>This content is rendered on the server.</p>\n      {/* Can use Client Components inside Server Components */}\n      <ClientCounter initialCount={data.length} />\n    </div>\n  );\n}",
              "explanation": "This `ServerComponent` is marked with `'use server'`, ensuring it runs only on the server. It directly accesses a simulated `db` (representing a database connection) to fetch user data. The JavaScript for `db` and `ServerComponent` itself never reaches the browser, resulting in zero bundle size for this part of the application. It then renders a `ClientCounter` component, passing data from the server to it. This demonstrates how interactivity (handled by `ClientCounter`) can be integrated into a server-rendered page.",
              "language": "typescript"
            },
            {
              "id": "example_rsc_client_component",
              "title": "Client Component Example (`.client.jsx`)",
              "code": "// ClientCounter.client.jsx - runs in the browser\n'use client';\n\nimport React, { useState } from 'react';\n\nexport default function ClientCounter({ initialCount }) {\n  const [count, setCount] = useState(initialCount || 0);\n\n  return (\n    <div style={{ border: '1px solid blue', padding: '10px', margin: '10px 0' }}>\n      <h3>Client-Side Counter</h3>\n      <p>Current count: {count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>Increment</button>\n      <button onClick={() => setCount(prev => prev - 1)}>Decrement</button>\n      <p>This component is interactive and runs on the client.</p>\n    </div>\n  );\n}",
              "explanation": "This `ClientCounter` component is marked with `'use client'`, indicating that its JavaScript must be bundled and sent to the browser for execution. It uses `useState` for internal state management and provides interactive buttons. This component would be hydrated on the client, allowing users to interact with it, while the surrounding `ServerComponent` (if any) remains static and server-rendered.",
              "language": "typescript"
            },
            {
              "id": "example_rsc_app_composition",
              "title": "Composing Server and Client Components",
              "code": "// App.server.jsx (entry point, typically a Server Component)\n'use server';\n\nimport ServerComponent from './ServerComponent.server';\n\nexport default function App() {\n  return (\n    <div>\n      <h1>Welcome to My App</h1>\n      <ServerComponent />\n      {/* A Client Component could also be directly imported here if needed */}\n      {/* <ClientCounter initialCount={10} /> */}\n    </div>\n  );\n}",
              "explanation": "This `App` component acts as an entry point. Since it's a Server Component (`'use server'`), it can import and render `ServerComponent`. `ServerComponent` in turn imports and renders `ClientCounter`. This demonstrates the typical structure where a root Server Component renders other Server Components, which then render Client Components for interactivity. The client only downloads the JavaScript for `ClientCounter` (and any other client-side logic), not `ServerComponent` or `App.server.jsx`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_rsc_server_vs_client_1",
            "question_rsc_bundle_size_1",
            "question_rsc_use_client_1",
            "question_rsc_composition_1",
            "question_rsc_auto_codesplitting_1",
            "question_rsc_use_server_1"
          ],
          "relatedTasks": [
            "task_rsc_simple_app"
          ],
          "tags": [
            "React",
            "React Server Components",
            "RSC",
            "Performance",
            "Server-Side Rendering",
            "Client-Side Rendering",
            "Bundle Size",
            "Next.js"
          ],
          "technology": "React",
          "prerequisites": [
            "React Components",
            "Server-Side Concepts",
            "JavaScript Modules",
            "Asynchronous JavaScript"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "Modern React Development",
            "Full-Stack JavaScript",
            "Next.js App Router"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_unstable_create_root_1",
          "topic": "Concurrent Mode Setup",
          "level": "easy",
          "type": "mcq",
          "question": "Which `ReactDOM` method is used to enable Concurrent Mode features in React, as shown in the provided example?",
          "answer": "`unstable_createRoot` (or `createRoot` in React 18+)",
          "options": [
            "`ReactDOM.render`",
            "`ReactDOM.hydrate`",
            "`unstable_createRoot` (or `createRoot` in React 18+)",
            "`ReactDOM.createPortal`"
          ],
          "analysisPoints": [
            "Identifies the correct entry point for Concurrent Mode.",
            "Distinguishes between legacy `render` and modern `createRoot`.",
            "Highlights the 'unstable' prefix for experimental features prior to React 18 stable `createRoot`."
          ],
          "keyConcepts": [
            "Concurrent Mode",
            "ReactDOM API",
            "Root API"
          ],
          "evaluationCriteria": [
            "Understanding of React's rendering APIs.",
            "Knowledge of Concurrent Mode activation."
          ],
          "example": "```typescript\nimport { unstable_createRoot as createRoot } from 'react';\nconst rootEl = document.getElementById('root');\nconst root = createRoot(rootEl);\nroot.render(<App />);\n```",
          "tags": [
            "React",
            "Concurrent Mode",
            "ReactDOM",
            "createRoot"
          ],
          "prerequisites": [
            "React Basics",
            "DOM Manipulation"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_suspenselist_purpose_1",
          "topic": "SuspenseList",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary purpose of `SuspenseList` in React's Concurrent Mode?",
          "answer": "To coordinate the loading sequence and reveal order of multiple Suspense components.",
          "options": [
            "To define an alternative UI when an error occurs in a child component.",
            "To enable lazy loading of components.",
            "To coordinate the loading sequence and reveal order of multiple Suspense components.",
            "To manage global state across an application."
          ],
          "analysisPoints": [
            "Correctly identifies `SuspenseList`'s role in orchestrating loading states.",
            "Distinguishes `SuspenseList` from `Suspense` (lazy loading/fallback) and `Error Boundaries` (error handling).",
            "Reinforces the concept of smoother transitions in Concurrent Mode."
          ],
          "keyConcepts": [
            "SuspenseList",
            "Concurrent Mode",
            "User Experience",
            "Loading States"
          ],
          "evaluationCriteria": [
            "Understanding of advanced Suspense features.",
            "Ability to differentiate between related React APIs."
          ],
          "example": "```typescript\n<SuspenseList revealOrder=\"forwards\">\n  <Suspense fallback={<div>Loading header...</div>}>\n    <ProfileHeader />\n  </Suspense>\n  <Suspense fallback={<div>Loading details...</div>}>\n    <ProfileDetails />\n  </Suspense>\n</SuspenseList>\n```",
          "tags": [
            "React",
            "SuspenseList",
            "Concurrent Mode",
            "Performance"
          ],
          "prerequisites": [
            "Suspense",
            "React Components"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_concurrent_mode_benefits_1",
          "topic": "Concurrent Mode Benefits",
          "level": "medium",
          "type": "open",
          "question": "Explain at least three key benefits of React's Concurrent Mode (and its features like Suspense) for user experience and application performance.",
          "answer": "React's Concurrent Mode offers several benefits:\n\n1.  **Improved User Experience**: Apps feel more responsive. React can interrupt rendering an ongoing update to start a more urgent one (e.g., user input), then resume the interrupted work later. This prevents the UI from freezing or becoming unresponsive during heavy computations or network requests.\n2.  **Smoother Transitions**: Concurrent Mode allows for coordinated loading states. Instead of immediately showing a loading spinner, React can wait a short period or prioritize rendering existing content while new data loads, leading to less jarring UI changes. `SuspenseList` further enhances this by controlling the reveal order of content.\n3.  **Fewer Loading Indicators / Incremental Loading**: With Suspense, parts of the UI that are ready can be displayed while other parts are still loading. This allows for incremental content revelation, preventing the 'all-or-nothing' loading screens and making the application feel faster to the user.\n4.  **Better Error Handling**: While not exclusive to Concurrent Mode, the architecture encourages and integrates well with Error Boundaries, allowing errors to be caught and handled at the component level, preventing crashes and displaying fallback UIs for specific problematic sections.",
          "analysisPoints": [
            "Assesses understanding of the core value proposition of Concurrent Mode.",
            "Requires articulating how technical features translate into user benefits.",
            "Tests knowledge of `Suspense` and `SuspenseList` in the context of UX."
          ],
          "keyConcepts": [
            "Concurrent Mode",
            "User Experience",
            "Performance Optimization",
            "Suspense",
            "SuspenseList"
          ],
          "evaluationCriteria": [
            "Clarity and completeness of explanation.",
            "Ability to link technical features to practical benefits.",
            "Depth of understanding of Concurrent Mode's goals."
          ],
          "tags": [
            "React",
            "Concurrent Mode",
            "Performance",
            "UX",
            "Interview Question"
          ],
          "prerequisites": [
            "React Fundamentals",
            "Asynchronous Operations"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_concurrent_mode_status_1",
          "topic": "Concurrent Mode Status",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the current general recommendation regarding the use of the full Concurrent Mode features (beyond `createRoot` for stable features like automatic batching) in production applications?",
          "answer": "It is still experimental and generally not recommended for production use in all applications.",
          "analysisPoints": [
            "Tests recall of the developmental status of Concurrent Mode.",
            "Emphasizes the distinction between `createRoot` (stable) and the broader experimental features."
          ],
          "keyConcepts": [
            "Concurrent Mode Status",
            "Experimental Features",
            "Production Readiness"
          ],
          "evaluationCriteria": [
            "Accuracy of factual recall.",
            "Awareness of best practices and stability concerns."
          ],
          "tags": [
            "React",
            "Concurrent Mode",
            "Status",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_suspense_data_fetching_1",
          "topic": "Suspense for Data Fetching",
          "level": "medium",
          "type": "code",
          "question": "Imagine you have a component `UserProfile` that fetches user data asynchronously. How would you wrap this component with `Suspense` to show a 'Loading user data...' message while the data is being fetched? Provide a simple code snippet.",
          "answer": "```typescript\nimport React, { Suspense } from 'react';\n\n// Assume fetchUserData is a Suspense-enabled data fetcher\n// (e.g., using a Suspense-aware library or a custom resource utility)\n// For demonstration, let's use a placeholder:\nconst UserProfileData = React.lazy(() => \n  new Promise(resolve => setTimeout(() => resolve({ default: () => <div>User data loaded!</div> }), 1500))\n);\n\nfunction UserProfile() {\n  return (\n    <Suspense fallback={<div>Loading user data...</div>}>\n      <UserProfileData />\n    </Suspense>\n  );\n}\n\n// To make the example runnable with a mock suspending component:\n// const createResource = (fetcher) => { /* ... (as in theory example) ... */ };\n// const fetchUserData = (userId) => { /* ... (as in theory example) ... */ };\n// function UserProfileContent({ userId }) {\n//   const user = fetchUserData(userId).read();\n//   return <div>{user.name}'s profile</div>;\n// }\n// function UserProfile({ userId }) {\n//   return (\n//     <Suspense fallback={<div>Loading user data...</div>}>\n//       <UserProfileContent userId={userId} />\n//     </Suspense>\n//   );\n// }\n```",
          "analysisPoints": [
            "Demonstrates correct usage of the `Suspense` component.",
            "Shows understanding of the `fallback` prop.",
            "Implies awareness that `Suspense` relies on a child component 'suspending' (e.g., via `React.lazy` or a Suspense-enabled data fetching library)."
          ],
          "keyConcepts": [
            "Suspense",
            "Data Fetching",
            "Loading States",
            "React.lazy"
          ],
          "evaluationCriteria": [
            "Correct syntax for `Suspense`.",
            "Appropriate use of `fallback`.",
            "Conceptual understanding of how Suspense is triggered."
          ],
          "tags": [
            "React",
            "Suspense",
            "Code Example",
            "Loading"
          ],
          "prerequisites": [
            "React Components",
            "Asynchronous JavaScript"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_suspenselist_revealorder_1",
          "topic": "SuspenseList Properties",
          "level": "hard",
          "type": "mcq",
          "question": "Consider the following `SuspenseList` usage:\n\n```typescript\n<SuspenseList revealOrder=\"backwards\" tail=\"collapsed\">\n  <Suspense fallback={<div>Loading A...</div>}> <ComponentA /> </Suspense>\n  <Suspense fallback={<div>Loading B...</div>}> <ComponentB /> </Suspense>\n  <Suspense fallback={<div>Loading C...</div>}> <ComponentC /> </Suspense>\n</SuspenseList>\n```\n\nIf `ComponentC` resolves first, followed by `ComponentA`, and then `ComponentB`, which loading indicator(s) will be visible at the point when `ComponentA` has just resolved, but `ComponentB` is still loading?",
          "answer": "Only \"Loading B...\" will be visible.",
          "options": [
            "All three loading indicators will be visible.",
            "Only \"Loading A...\" and \"Loading B...\" will be visible.",
            "Only \"Loading B...\" will be visible.",
            "No loading indicators will be visible, as `ComponentC` has already resolved."
          ],
          "analysisPoints": [
            "Tests deep understanding of `revealOrder` and `tail` props.",
            "Requires tracking the state of multiple `Suspense` boundaries.",
            "Understands that `revealOrder=\"backwards\"` implies `ComponentC` (last in list) is prioritized, and `tail=\"collapsed\"` means only the immediately preceding unresolved fallback in the reveal order is shown."
          ],
          "keyConcepts": [
            "SuspenseList",
            "revealOrder",
            "tail",
            "Loading States",
            "Complex UI Flow"
          ],
          "evaluationCriteria": [
            "Ability to analyze complex `SuspenseList` scenarios.",
            "Precise understanding of prop interactions.",
            "Logical reasoning about UI state changes."
          ],
          "example": "With `revealOrder=\"backwards\"`, `ComponentC` is meant to be revealed first. Since `ComponentC` resolves first, it will reveal its content. `tail=\"collapsed\"` means only one fallback will be shown at a time. The `backwards` order means `C` then `B` then `A`. When `ComponentC` resolves, its content is shown. When `ComponentA` resolves, `ComponentB` is still loading. Since `ComponentB` is the next to resolve *in the backwards order* after `C`, and it's still loading, its fallback (\"Loading B...\") will be visible while other resolved components (`A` and `C`) display their content.",
          "tags": [
            "React",
            "SuspenseList",
            "Advanced",
            "Tricky"
          ],
          "prerequisites": [
            "Suspense",
            "SuspenseList",
            "Asynchronous Logic"
          ],
          "complexity": 9,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_rsc_server_vs_client_1",
          "topic": "React Server Components Fundamentals",
          "level": "medium",
          "type": "open",
          "question": "Describe the fundamental differences between React Server Components and Client Components in terms of where they execute, their impact on client-side bundle size, and their ability to access server-side resources.",
          "answer": "The fundamental differences are:\n\n1.  **Execution Environment**: Server Components execute exclusively on the server during the build process or request time. Their JavaScript code is never sent to or executed in the client's browser. Client Components, conversely, execute in the client's browser after being downloaded and hydrated, although they can also be pre-rendered on the server (SSR).\n2.  **Impact on Client-Side Bundle Size**: Server Components contribute zero bytes to the client-side JavaScript bundle. Their code remains entirely on the server. Only their serialized output (React elements) is sent to the client. Client Components, however, are part of the client-side JavaScript bundle, and their code is downloaded and parsed by the browser.\n3.  **Access to Server-Side Resources**: Server Components have direct access to server-side resources like databases, file systems, or private APIs. This means you can directly query your database or read files from the server within a Server Component. Client Components *cannot* directly access server-side resources; they must rely on API endpoints exposed by the server to fetch data.",
          "analysisPoints": [
            "Tests core understanding of RSC architecture.",
            "Requires clear articulation of execution context, performance implications, and data access patterns.",
            "Highlights the 'zero bundle size' benefit."
          ],
          "keyConcepts": [
            "React Server Components",
            "Client Components",
            "Bundle Size",
            "Execution Environment",
            "Server-Side Access"
          ],
          "evaluationCriteria": [
            "Accuracy and completeness of definitions.",
            "Clarity in differentiating concepts.",
            "Ability to explain the 'why' behind these differences."
          ],
          "tags": [
            "React",
            "RSC",
            "Architecture",
            "Performance",
            "Interview Question"
          ],
          "prerequisites": [
            "React Components",
            "Client-Side vs Server-Side"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rsc_bundle_size_1",
          "topic": "React Server Components Benefits",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is a key benefit of React Server Components regarding client-side bundle size?",
          "answer": "They contribute zero bytes to the client-side JavaScript bundle.",
          "options": [
            "They automatically minify all client-side JavaScript.",
            "They encrypt sensitive data before sending it to the client.",
            "They contribute zero bytes to the client-side JavaScript bundle.",
            "They enable universal rendering across server and client with a single bundle."
          ],
          "analysisPoints": [
            "Identifies the primary performance advantage of Server Components.",
            "Distinguishes core RSC benefits from unrelated concepts (minification, encryption, universal rendering without bundle size implications)."
          ],
          "keyConcepts": [
            "React Server Components",
            "Bundle Size",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Understanding of RSC's core value proposition.",
            "Ability to recall specific technical advantages."
          ],
          "tags": [
            "React",
            "RSC",
            "Performance",
            "Bundle Size"
          ],
          "prerequisites": [
            "Web Performance"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_rsc_use_client_1",
          "topic": "React Server Components Directives",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of the `'use client'` directive at the top of a React component file?",
          "answer": "It marks the module as a Client Component, indicating that its JavaScript code must be bundled and sent to the browser for client-side execution and interactivity.",
          "analysisPoints": [
            "Tests recall of the `use client` directive's function.",
            "Connects the directive to the client-side execution environment and interactivity."
          ],
          "keyConcepts": [
            "React Server Components",
            "use client",
            "Client Components",
            "Directives"
          ],
          "evaluationCriteria": [
            "Accuracy of factual recall.",
            "Understanding of component classification."
          ],
          "tags": [
            "React",
            "RSC",
            "use client",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_rsc_composition_1",
          "topic": "React Server Components Composition",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements about composing React Server Components and Client Components is TRUE?",
          "answer": "Server Components can render Client Components.",
          "options": [
            "Client Components can directly render Server Components.",
            "Server Components can render Client Components.",
            "Server Components and Client Components must be in separate applications.",
            "Only one type of component (Server or Client) can exist in a single React application."
          ],
          "analysisPoints": [
            "Tests understanding of the composition rules between RSCs and Client Components.",
            "Highlights the one-way street: Server -> Client.",
            "Dispels common misconceptions about their coexistence."
          ],
          "keyConcepts": [
            "React Server Components",
            "Client Components",
            "Composition",
            "Component Tree"
          ],
          "evaluationCriteria": [
            "Correct understanding of interaction patterns.",
            "Ability to identify valid architectural setups."
          ],
          "example": "```typescript\n// ServerComponent.server.jsx\n'use server';\nimport ClientInteractiveComponent from './ClientInteractive.client';\nexport default function ServerComp() {\n  return (\n    <div>\n      <p>This is server rendered.</p>\n      <ClientInteractiveComponent /> {/* Valid */}\n    </div>\n  );\n}\n\n// ClientInteractive.client.jsx\n'use client';\n// This would be INVALID if ClientInteractiveComponent tried to directly import and render a Server Component.\n```",
          "tags": [
            "React",
            "RSC",
            "Architecture",
            "Composition"
          ],
          "prerequisites": [
            "React Components"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rsc_auto_codesplitting_1",
          "topic": "React Server Components & Code Splitting",
          "level": "medium",
          "type": "open",
          "question": "How do React Server Components facilitate automatic code splitting, and what is its main benefit?",
          "answer": "React Server Components facilitate automatic code splitting primarily for **Client Components**. Since Server Components' JavaScript never leaves the server, they inherently don't contribute to the client-side bundle. However, when Server Components render Client Components, these Client Components are automatically code-split by the build system. This means that the JavaScript for a Client Component is only downloaded by the browser when that component is actually needed or rendered.\n\n**Main Benefit**: The main benefit is significantly improved initial page load performance. By only loading the necessary JavaScript for interactive parts of the page, the browser has less code to download, parse, and execute, leading to faster Time To Interactive (TTI) and overall better user experience, especially on slower networks or devices.",
          "analysisPoints": [
            "Connects RSCs to the concept of code splitting.",
            "Specifies that code splitting primarily applies to Client Components in this context.",
            "Explains the performance benefit clearly.",
            "Requires understanding of `use client` implication."
          ],
          "keyConcepts": [
            "React Server Components",
            "Code Splitting",
            "Client Components",
            "Performance Optimization",
            "Bundle Size"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation regarding which components are split.",
            "Clarity of the performance impact.",
            "Demonstrates understanding of the end-to-end flow."
          ],
          "tags": [
            "React",
            "RSC",
            "Code Splitting",
            "Performance",
            "Interview Question"
          ],
          "prerequisites": [
            "Webpack/Bundling",
            "Web Performance"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rsc_use_server_1",
          "topic": "React Server Components Directives",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary function of the `'use server'` directive when placed at the top of a file?",
          "answer": "It marks the module as a Server Component or a server action/function, meaning its code will only execute on the server and will not be bundled for the client.",
          "analysisPoints": [
            "Tests recall of the `use server` directive's function.",
            "Highlights the server-only execution and zero client bundle aspect."
          ],
          "keyConcepts": [
            "React Server Components",
            "use server",
            "Server Components",
            "Directives",
            "Execution Environment"
          ],
          "evaluationCriteria": [
            "Accuracy of factual recall.",
            "Understanding of server-side component behavior."
          ],
          "tags": [
            "React",
            "RSC",
            "use server",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_suspense_list_coordination",
          "title": "Implement a Coordinated Loading Sequence with SuspenseList",
          "description": "\nImplement a React application that fetches data for three distinct sections (e.g., User Profile, User Posts, User Comments) using `Suspense` for each section. Wrap these `Suspense` components in a `SuspenseList` to coordinate their loading and reveal order.\n\n**Requirements:**\n1.  Create three functional components (e.g., `UserProfile`, `UserPosts`, `UserComments`), each simulating an asynchronous data fetch (e.g., using a `setTimeout` wrapped in a `Promise` that throws for Suspense).\n2.  Each of these components should be wrapped in its own `Suspense` boundary with a distinct `fallback` message.\n3.  Use `SuspenseList` to wrap all three `Suspense` components.\n4.  Configure `SuspenseList` with `revealOrder=\"forwards\"` and `tail=\"collapsed\"` to ensure a smooth, sequential loading experience.\n5.  Ensure your mock data fetching utility properly 'suspends' (throws a promise) until the data is resolved.\n6.  Render the main `App` component using `createRoot` (or `unstable_createRoot`) to enable Concurrent Mode features.\n",
          "difficulty": "medium",
          "startingCode": "import React, { Suspense, SuspenseList, unstable_createRoot as createRoot } from 'react';\n\n// TODO: Implement a simple Suspense-enabled data fetching utility\n// This utility should return an object with a 'read' method that throws a Promise\n// if data is not ready, or returns the data if ready.\nconst createResource = (fetcher) => {\n  let status = 'pending';\n  let result;\n  let suspender = fetcher().then(\n    (r) => { status = 'success'; result = r; },\n    (e) => { status = 'error'; result = e; }\n  );\n  return {\n    read() {\n      if (status === 'pending') throw suspender;\n      if (status === 'error') throw result;\n      return result;\n    },\n  };\n};\n\n// TODO: Implement UserProfile, UserPosts, UserComments components\n// Each component should use the createResource utility to fetch data\n// and render the data when available.\n\nfunction UserProfile() {\n  // Simulate data fetch for profile\n  const profileData = createResource(() => new Promise(resolve => setTimeout(() => resolve({ name: 'Jane Doe' }), 1000 + Math.random() * 500)));\n  const data = profileData.read();\n  return <div><h2>{data.name}'s Profile</h2><p>This is profile content.</p></div>;\n}\n\nfunction UserPosts() {\n  // Simulate data fetch for posts\n  const postsData = createResource(() => new Promise(resolve => setTimeout(() => resolve([{ id: 1, title: 'My First Post' }, { id: 2, title: 'Another Post' }]), 1500 + Math.random() * 500)));\n  const data = postsData.read();\n  return (\n    <div>\n      <h3>Posts</h3>\n      <ul>\n        {data.map(post => <li key={post.id}>{post.title}</li>)}\n      </ul>\n    </div>\n  );\n}\n\nfunction UserComments() {\n  // Simulate data fetch for comments\n  const commentsData = createResource(() => new Promise(resolve => setTimeout(() => resolve([{ id: 101, text: 'Great profile!' }, { id: 102, text: 'Nice posts!' }]), 2000 + Math.random() * 500)));\n  const data = commentsData.read();\n  return (\n    <div>\n      <h3>Comments</h3>\n      <ul>\n        {data.map(comment => <li key={comment.id}>{comment.text}</li>)}\n      </ul>\n    </div>\n  );\n);\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>Application with Coordinated Loading</h1>\n      {/* TODO: Wrap components in SuspenseList with appropriate props */}\n      {/* TODO: Wrap each component in Suspense with a distinct fallback */}\n      \n    </div>\n  );\n}\n\n// DOM rendering setup\nconst rootEl = document.getElementById('root');\nif (rootEl) {\n  const root = createRoot(rootEl);\n  root.render(<App />);\n}\n",
          "solutionCode": "import React, { Suspense, SuspenseList, unstable_createRoot as createRoot } from 'react';\n\nconst createResource = (fetcher) => {\n  let status = 'pending';\n  let result;\n  let suspender = fetcher().then(\n    (r) => { status = 'success'; result = r; },\n    (e) => { status = 'error'; result = e; }\n  );\n  return {\n    read() {\n      if (status === 'pending') throw suspender;\n      if (status === 'error') throw result;\n      return result;\n    },\n  };\n};\n\nfunction UserProfile() {\n  const profileData = createResource(() => new Promise(resolve => setTimeout(() => resolve({ name: 'Jane Doe' }), 1000 + Math.random() * 500)));\n  const data = profileData.read();\n  return <div><h2>{data.name}'s Profile</h2><p>This is profile content.</p></div>;\n}\n\nfunction UserPosts() {\n  const postsData = createResource(() => new Promise(resolve => setTimeout(() => resolve([{ id: 1, title: 'My First Post' }, { id: 2, title: 'Another Post' }]), 1500 + Math.random() * 500)));\n  const data = postsData.read();\n  return (\n    <div>\n      <h3>Posts</h3>\n      <ul>\n        {data.map(post => <li key={post.id}>{post.title}</li>)}\n      </ul>\n    </div>\n  );\n}\n\nfunction UserComments() {\n  const commentsData = createResource(() => new Promise(resolve => setTimeout(() => resolve([{ id: 101, text: 'Great profile!' }, { id: 102, text: 'Nice posts!' }]), 2000 + Math.random() * 500)));\n  const data = commentsData.read();\n  return (\n    <div>\n      <h3>Comments</h3>\n      <ul>\n        {data.map(comment => <li key={comment.id}>{comment.text}</li>)}\n      </ul>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>Application with Coordinated Loading</h1>\n      <SuspenseList revealOrder=\"forwards\" tail=\"collapsed\">\n        <Suspense fallback={<div>Loading User Profile...</div>}>\n          <UserProfile />\n        </Suspense>\n        <Suspense fallback={<div>Loading User Posts...</div>}>\n          <UserPosts />\n        </Suspense>\n        <Suspense fallback={<div>Loading User Comments...</div>}>\n          <UserComments />\n        </Suspense>\n      </SuspenseList>\n    </div>\n  );\n}\n\nconst rootEl = document.getElementById('root');\nif (rootEl) {\n  const root = createRoot(rootEl);\n  root.render(<App />);\n}\n\n// You would also need a basic index.html with <div id=\"root\"></div>",
          "testCases": [
            "Verify that initially, 'Loading User Profile...' is shown, and other fallbacks are hidden due to `tail=\"collapsed\"`.",
            "Verify that after 'User Profile' loads, 'Loading User Posts...' appears.",
            "Verify that content is revealed sequentially from `UserProfile` -> `UserPosts` -> `UserComments` due to `revealOrder=\"forwards\"`.",
            "Verify that all content eventually renders successfully.",
            "Observe the smooth transition of loading indicators, preventing multiple spinners from appearing at once."
          ],
          "hints": [
            "Remember that `Suspense` works by catching a thrown Promise from a child component that isn't ready.",
            "The `createResource` pattern is a common way to simulate Suspense-enabled data fetching.",
            "Pay close attention to the `revealOrder` and `tail` props of `SuspenseList` to achieve the desired coordination."
          ],
          "tags": [
            "React",
            "Suspense",
            "SuspenseList",
            "Concurrent Mode",
            "Asynchronous",
            "UI/UX",
            "Performance"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Components",
            "Promises",
            "Basic JavaScript Asynchronicity"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Error Boundaries",
            "React.lazy",
            "Data Fetching with Suspense"
          ]
        },
        {
          "id": "task_rsc_simple_app",
          "title": "Build a Hybrid App with React Server and Client Components",
          "description": "\nCreate a small React application that demonstrates the interaction between a Server Component and a Client Component. The Server Component should fetch some mock data (simulating a database call) and pass part of that data to a Client Component for interactive display.\n\n**Requirements:**\n1.  Create a file named `UserList.server.jsx` that acts as a Server Component. It should:\n    *   Contain the `'use server'` directive at the top.\n    *   Simulate fetching a list of users (e.g., an array of objects with `id` and `name`) using a `setTimeout` to mimic async database access.\n    *   Render the list of users.\n    *   Import and render a `UserCountDisplay.client.jsx` component, passing the total number of users as a prop.\n2.  Create a file named `UserCountDisplay.client.jsx` that acts as a Client Component. It should:\n    *   Contain the `'use client'` directive at the top.\n    *   Receive an `initialCount` prop from the Server Component.\n    *   Display the count.\n    *   Include a button that increments the count using client-side state (`useState`), demonstrating interactivity.\n3.  Set up an entry point (e.g., `App.server.jsx` or a root server component) that renders `UserList.server.jsx`.\n4.  Explain how this setup leverages the benefits of both Server and Client Components (e.g., zero bundle size for data fetching, client-side interactivity).\n\n**Note**: For a real-world setup, you'd typically use a framework like Next.js App Router or Remix to handle the server environment. For this task, focus on the component structure and directives, assuming a compatible environment.\n",
          "difficulty": "medium",
          "startingCode": "// UserList.server.jsx\n// TODO: Add 'use server' directive\n// TODO: Implement mock database query\n// TODO: Import Client Component\n// TODO: Implement Server Component to fetch data and render list + Client Component\n\n// UserCountDisplay.client.jsx\n// TODO: Add 'use client' directive\n// TODO: Import useState\n// TODO: Implement Client Component to display count and add increment button\n\n// App.server.jsx (or your main entry point)\n// TODO: Add 'use server' directive if it's a server component\n// TODO: Import UserList.server.jsx\n// TODO: Render UserList.server.jsx\n",
          "solutionCode": "// UserList.server.jsx\n'use server';\n\nimport UserCountDisplay from './UserCountDisplay.client';\n\n// Simulate a database query on the server\nasync function fetchUsersFromDB() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve([\n        { id: 1, name: 'Alice' },\n        { id: 2, name: 'Bob' },\n        { id: 3, name: 'Charlie' },\n        { id: 4, name: 'David' }\n      ]);\n    }, 800);\n  });\n}\n\nexport default async function UserList() {\n  const users = await fetchUsersFromDB();\n\n  return (\n    <div style={{ border: '1px dashed green', padding: '15px', margin: '10px' }}>\n      <h2>Server-Rendered User List</h2>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>{user.name}</li>\n        ))}\n      </ul>\n      <p>This list was fetched and rendered entirely on the server. Its JS bundle size is zero on the client.</p>\n      <UserCountDisplay initialCount={users.length} />\n    </div>\n  );\n}\n\n// UserCountDisplay.client.jsx\n'use client';\n\nimport React, { useState } from 'react';\n\nexport default function UserCountDisplay({ initialCount }) {\n  const [count, setCount] = useState(initialCount);\n\n  return (\n    <div style={{ border: '1px solid blue', padding: '10px', margin: '10px 0' }}>\n      <h3>Client-Side User Count Display</h3>\n      <p>Current user count (interactive): {count}</p>\n      <button onClick={() => setCount(prev => prev + 1)}>Increment Count</button>\n      <p>This part is hydrated and interactive on the client.</p>\n    </div>\n  );\n}\n\n// App.server.jsx (Main entry point for the application)\n'use server';\n\nimport UserList from './UserList.server';\n\nexport default function App() {\n  return (\n    <html lang=\"en\">\n      <body>\n        <h1>My Hybrid React App</h1>\n        <UserList />\n      </body>\n    </html>\n  );\n}\n\n// For demonstration, you would usually render App.server.jsx via a framework like Next.js.\n// If running in a simplified environment, ensure your build setup correctly handles '.server.jsx' and '.client.jsx' extensions.",
          "testCases": [
            "Verify that the initial page load displays the user list fetched by the Server Component.",
            "Verify that the 'Increment Count' button in `UserCountDisplay` works correctly on the client side, updating the count.",
            "Conceptually explain which parts of the code are sent to the client's browser (only `UserCountDisplay.client.jsx`'s JS and the rendered HTML from `UserList.server.jsx`).",
            "Explain how the `initialCount` prop is passed from the server-side `UserList` component to the client-side `UserCountDisplay` component."
          ],
          "hints": [
            "Remember to place the `'use server'` and `'use client'` directives at the very top of their respective files.",
            "Server Components can import and render Client Components directly. Client Components cannot directly import Server Components.",
            "Simulate data fetching in the Server Component using `async/await` with `setTimeout` to represent an I/O operation."
          ],
          "tags": [
            "React",
            "React Server Components",
            "RSC",
            "Client-Server Architecture",
            "Performance",
            "Full-Stack"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "React Components",
            "Asynchronous JavaScript",
            "Module Systems"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Server-Side Rendering",
            "Hydration",
            "Zero-Bundle Size",
            "Next.js App Router"
          ]
        }
      ]
    }
  }
]