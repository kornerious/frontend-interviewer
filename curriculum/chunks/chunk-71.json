[
  {
    "id": "6b5c7815-567c-47b5-812c-60fe268133e2",
    "startLine": 14400,
    "endLine": 14499,
    "processedDate": "2025-06-17T13:57:21.199Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_redux_form_reinitialize",
          "title": "Redux-Form: Dynamic Initialization and Reinitialization",
          "content": "Redux-Form is a popular higher-order component (HOC) based library for managing form state in a Redux store. It handles form state, validation, submission, and more, integrating deeply with Redux.\n\n## `enableReinitialize: true`\n\nOne crucial configuration option for `redux-form` is `enableReinitialize`. When set to `true`, this flag tells `redux-form` to automatically update the form's `initialValues` whenever the `initialValues` prop provided to the `reduxForm` HOC changes. This ensures that your form fields reflect the latest data, even if it changes asynchronously after the form component has mounted.\n\n### How it Works:\n\n1.  **`initialValues` Prop:** The `initialValues` prop is typically supplied to the `reduxForm` HOC via `mapStateToProps`. It's an object where keys correspond to your form field names and values are the initial data for those fields.\n2.  **`enableReinitialize: true`:** When this option is active, `redux-form` observes changes to the `initialValues` prop. If the incoming `initialValues` are different from the current ones, the form's internal state is updated to reflect these new values.\n3.  **Use Cases:**\n    *   **Editing Existing Records:** When you load an existing user or product for editing, the `initialValues` would come from an API call. If the user navigates between different records, `enableReinitialize: true` ensures the form updates with the new record's data.\n    *   **Asynchronous Data Loading:** If form data is fetched asynchronously (e.g., after component mount), `enableReinitialize` will ensure the form fields are populated once the data arrives.\n    *   **Dynamic Form Generation:** Forms whose initial data changes based on user selection or other dynamic factors.\n\n### Key Redux-Form Props:\n\n*   **`handleSubmit`**: A function provided by `redux-form` that wraps your `onSubmit` handler. It prevents default browser submission, runs validation, and then calls your provided `onSubmit` function with the form data if validation passes.\n*   **`pristine`**: A boolean indicating if the form values are currently identical to their `initialValues`. `true` means no changes have been made.\n*   **`reset`**: A function to reset the form's values back to their `initialValues`.\n*   **`submitting`**: A boolean indicating if the form is currently in the process of submitting (e.g., after `handleSubmit` is called and before the `onSubmit` promise resolves).\n*   **`Field`**: A component provided by `redux-form` that connects an input to the Redux store. It manages the input's value, `onChange`, `onBlur`, and error states. You specify which component to render using the `component` prop (e.g., 'input', 'select', or a custom React component).",
          "examples": [
            {
              "id": "example_redux_form_reinitialize_1",
              "title": "Basic Redux-Form with enableReinitialize",
              "code": "import React from 'react';\nimport { connect } from 'react-redux';\nimport { reduxForm, Field } from 'redux-form';\n\n// A simple presentational form component\nclass UserEditFormComponent extends React.Component {\n  render() {\n    const { handleSubmit, pristine, reset, submitting } = this.props;\n    return (\n      <form onSubmit={handleSubmit}>\n        <div>\n          <label>First Name</label>\n          <div>\n            <Field name=\"firstName\" component=\"input\" type=\"text\" placeholder=\"First Name\" />\n          </div>\n        </div>\n        <div>\n          <label>Last Name</label>\n          <div>\n            <Field name=\"lastName\" component=\"input\" type=\"text\" placeholder=\"Last Name\" />\n          </div>\n        </div>\n        <div>\n          <button type=\"submit\" disabled={pristine || submitting}>Submit</button>\n          <button type=\"button\" disabled={pristine || submitting} onClick={reset}>Clear Values</button>\n        </div>\n      </form>\n    );\n  }\n}\n\n// mapStateToProps provides initialValues from Redux state\nconst mapStateToProps = (state) => ({\n  initialValues: state.user.data // Pre-populate form with this data\n});\n\n// Apply reduxForm HOC with enableReinitialize set to true\nconst UserEditFormConnected = reduxForm({\n  form: 'userEdit',\n  enableReinitialize: true // This is the key setting\n})(UserEditFormComponent);\n\n// Connect to Redux store to get user data for initialValues\nexport default connect(mapStateToProps)(UserEditFormConnected);",
              "explanation": "This example demonstrates how to set up `redux-form` with `enableReinitialize: true`. The `initialValues` prop is sourced from the Redux store via `mapStateToProps`. If `state.user.data` changes (e.g., a new user record is loaded), the form fields will automatically update to reflect the new `initialValues`. The `handleSubmit`, `pristine`, `reset`, and `submitting` props are destructured and used to manage form submission and button states.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_redux_form_reinitialize_1",
            "question_redux_form_reinitialize_2",
            "question_redux_form_reinitialize_3",
            "question_redux_form_reinitialize_4",
            "question_redux_form_reinitialize_5",
            "question_redux_form_reinitialize_6"
          ],
          "relatedTasks": [
            "task_redux_form_dynamic_reinitialize"
          ],
          "tags": [
            "Redux-Form",
            "Forms",
            "State Management",
            "React",
            "Reinitialization"
          ],
          "technology": "React, Redux, Redux-Form",
          "prerequisites": [
            "Redux Basics",
            "React Components",
            "Higher-Order Components"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Complex Forms",
            "Dynamic Forms",
            "Data Editing Interfaces"
          ]
        },
        {
          "id": "theory_react_hook_form",
          "title": "React Hook Form: Performance-Oriented Form Management",
          "content": "React Hook Form is a lightweight and performant form library for React. It focuses on reducing re-renders and providing a simple API using React Hooks. Unlike `redux-form` which uses a Redux store for form state, `React Hook Form` uses uncontrolled components and refs to manage input states, minimizing re-renders and improving performance.\n\n## Key Concepts:\n\n*   **Uncontrolled Components:** By default, `React Hook Form` leverages uncontrolled components, which means it doesn't control the value of the input elements directly through React state. Instead, it registers refs to input elements.\n*   **Reduced Re-renders:** Because it relies on refs rather than controlled components, `React Hook Form` generally causes fewer re-renders of your component compared to libraries that manage all input state in React state or Redux.\n*   **Validation:** It has built-in support for native HTML form validation, but it also integrates seamlessly with schema validation libraries like `Yup`, `Zod`, and `Joi` via resolvers.\n\n## Core Hooks and Functions:\n\n*   **`useForm()`:** The primary hook that initializes the form and provides methods and state for form management.\n    *   **`register` function:** A function returned by `useForm` that you spread onto your input elements (`{...register('fieldName')}`). It registers the input with `React Hook Form`, allowing it to track its value, validation rules, and other properties.\n    *   **`handleSubmit` function:** A function that takes your `onSubmit` callback as an argument (`onSubmit={handleSubmit(yourSubmitHandler)}`). It handles form submission, triggers validation, and then calls your provided callback with the form data if validation passes.\n    *   **`formState` object:** Contains various states of the form, including:\n        *   **`errors`**: An object containing validation errors, where keys are field names and values are error objects (e.g., `{ message: 'Error message' }`).\n        *   **`isSubmitting`**: A boolean indicating if the form is currently being submitted.\n        *   **`isValid`**: A boolean indicating if the form is currently valid.\n        *   **`dirtyFields`**: An object indicating which fields have been touched by the user.\n\n*   **Resolvers (e.g., `yupResolver`):** These are adapters that allow `React Hook Form` to work with external schema validation libraries. You pass your validation schema to the resolver, and the resolver then translates the validation results into a format `React Hook Form` understands.\n\n## Validation with Yup:\n\n`Yup` is a schema builder for value parsing and validation. You define a schema that specifies the validation rules for each field. `yupResolver` then connects this schema to `useForm`.",
          "examples": [
            {
              "id": "example_react_hook_form_1",
              "title": "Basic React Hook Form with Yup Validation",
              "code": "import { useForm } from 'react-hook-form';\nimport { yupResolver } from '@hookform/resolvers/yup';\nimport * as yup from 'yup';\n\n// Define the validation schema using Yup\nconst schema = yup.object({\n  name: yup.string().required('Name is required'),\n  email: yup.string().email('Invalid email').required('Email is required'),\n  message: yup.string().required('Message is required')\n}).required(); // .required() at the end ensures the whole schema is required (often for object schemas)\n\nfunction HookFormBasic() {\n  // Initialize useForm, passing the resolver for Yup validation\n  const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm({\n    resolver: yupResolver(schema)\n  });\n\n  // Define the onSubmit handler\n  const onSubmit = (data) => {\n    console.log('Form submitted:', data);\n    // In a real app, you would send 'data' to a server\n    // Simulate API call\n    return new Promise(resolve => setTimeout(() => {\n      alert(JSON.stringify(data, null, 2));\n      resolve();\n    }, 1000));\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <div>\n        <label htmlFor=\"name\">Name:</label>\n        <input id=\"name\" {...register('name')} />\n        {errors.name && <p className=\"error\" style={{color: 'red'}}>{errors.name.message}</p>}\n      </div>\n\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input id=\"email\" type=\"email\" {...register('email')} />\n        {errors.email && <p className=\"error\" style={{color: 'red'}}>{errors.email.message}</p>}\n      </div>\n\n      <div>\n        <label htmlFor=\"message\">Message:</label>\n        <textarea id=\"message\" {...register('message')} />\n        {errors.message && <p className=\"error\" style={{color: 'red'}}>{errors.message.message}</p>}\n      </div>\n\n      <button type=\"submit\" disabled={isSubmitting}>\n        {isSubmitting ? 'Submitting...' : 'Submit'}\n      </button>\n    </form>\n  );\n}\n\nexport default HookFormBasic;",
              "explanation": "This example demonstrates a basic form using `React Hook Form` integrated with `Yup` for schema validation. The `useForm` hook is initialized with `yupResolver(schema)`, which connects our validation rules. Input fields are registered using the `register` function. The `handleSubmit` function is used to wrap our `onSubmit` callback, ensuring validation runs before the data is processed. Validation errors are accessed via `formState.errors` and displayed next to their respective fields. The `isSubmitting` flag is used to disable the submit button during form submission.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_hook_form_1",
            "question_react_hook_form_2",
            "question_react_hook_form_3",
            "question_react_hook_form_4",
            "question_react_hook_form_5",
            "question_react_hook_form_6",
            "question_react_hook_form_7",
            "question_react_hook_form_8",
            "question_react_hook_form_9"
          ],
          "relatedTasks": [
            "task_react_hook_form_advanced_validation",
            "task_custom_input_react_hook_form"
          ],
          "tags": [
            "React Hook Form",
            "Forms",
            "Hooks",
            "Performance",
            "Validation",
            "Yup"
          ],
          "technology": "React, React Hooks, Yup",
          "prerequisites": [
            "React Hooks",
            "Basic JavaScript Forms"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Modern React Forms",
            "High-Performance Forms",
            "Client-Side Validation"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_redux_form_reinitialize_1",
          "topic": "Redux-Form: enableReinitialize",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of setting `enableReinitialize: true` in `redux-form`?",
          "answer": "To allow the form to update its `initialValues` whenever the `initialValues` prop changes.",
          "analysisPoints": [
            "Tests basic understanding of `enableReinitialize`."
          ],
          "keyConcepts": [
            "Redux-Form",
            "enableReinitialize",
            "initialValues"
          ],
          "evaluationCriteria": [
            "Direct recall of feature purpose."
          ],
          "example": "Setting `enableReinitialize: true` ensures that if you fetch user data asynchronously and then update the `initialValues` prop with this data, the form fields will reflect the fetched data.",
          "tags": [
            "Redux-Form",
            "Reinitialization",
            "Forms"
          ],
          "prerequisites": [
            "Redux-Form Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_redux_form_reinitialize_2",
          "topic": "Redux-Form: enableReinitialize Scenario",
          "level": "medium",
          "type": "open",
          "question": "Describe a practical scenario where `enableReinitialize: true` in `redux-form` would be crucial for a good user experience. Explain why it's crucial in that scenario.",
          "answer": "A crucial scenario is an 'Edit Profile' form where a user can edit details of different profiles (e.g., in an admin panel). When the user navigates from editing 'User A' to 'User B' without leaving the form component, the `initialValues` prop will change to reflect 'User B's data. If `enableReinitialize` is `false`, the form would still display 'User A's data. With `enableReinitialize: true`, the form automatically repopulates with 'User B's data, providing a seamless and correct editing experience.",
          "analysisPoints": [
            "Ability to apply concept to real-world use cases.",
            "Understanding of the problem `enableReinitialize` solves."
          ],
          "keyConcepts": [
            "Redux-Form",
            "enableReinitialize",
            "initialValues",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Clarity of scenario description.",
            "Logical reasoning for its importance.",
            "Demonstrates practical application."
          ],
          "example": "```jsx\n// Imagine this component receives a 'userId' prop that changes\nconst mapStateToProps = (state, props) => ({\n  initialValues: state.users.data[props.userId] // This data changes based on props.userId\n});\n\nconst UserEditFormConnected = reduxForm({\n  form: 'userEdit',\n  enableReinitialize: true // Essential for updating when userId changes\n})(UserEditForm);\n```",
          "tags": [
            "Redux-Form",
            "Reinitialization",
            "Forms",
            "UX"
          ],
          "prerequisites": [
            "Redux-Form Basics",
            "React Component Lifecycle"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_form_reinitialize_3",
          "topic": "Redux-Form: Field Component",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the role of the `Field` component in `redux-form`?",
          "answer": "The `Field` component connects an input element (or a custom component) to the Redux store, managing its value, `onChange`, `onBlur`, and validation state.",
          "analysisPoints": [
            "Tests knowledge of `redux-form` core components."
          ],
          "keyConcepts": [
            "Redux-Form",
            "Field",
            "Input Management"
          ],
          "evaluationCriteria": [
            "Direct recall of component functionality."
          ],
          "example": "```jsx\n<Field name=\"firstName\" component=\"input\" type=\"text\" placeholder=\"First Name\" />\n```",
          "tags": [
            "Redux-Form",
            "Field Component"
          ],
          "prerequisites": [
            "Redux-Form Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_redux_form_reinitialize_4",
          "topic": "Redux-Form: Props",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following `redux-form` props is used to reset the form's values back to their `initialValues`?",
          "answer": "`reset`",
          "options": [
            "`pristine`",
            "`submitting`",
            "`reset`",
            "`clear`"
          ],
          "analysisPoints": [
            "Tests knowledge of `redux-form` provided props.",
            "Distinguishes between similar-sounding props."
          ],
          "keyConcepts": [
            "Redux-Form",
            "Form Props",
            "reset"
          ],
          "evaluationCriteria": [
            "Correct identification of function.",
            "Exclusion of distractors."
          ],
          "example": "```jsx\n// In your form component's render method\nconst { reset } = this.props;\n<button type=\"button\" onClick={reset}>Clear Form</button>\n```\nThe `reset` prop is a function provided by `redux-form` that when called, reverts all form fields to their `initialValues`. `pristine` is a boolean flag indicating if the form has been modified from its initial state, and `submitting` is a boolean indicating if the form is currently being submitted.",
          "tags": [
            "Redux-Form",
            "Form Props"
          ],
          "prerequisites": [
            "Redux-Form Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_form_reinitialize_5",
          "topic": "Redux-Form vs. React Hook Form (Re-renders)",
          "level": "medium",
          "type": "open",
          "question": "From a performance perspective, how does `redux-form` typically handle re-renders compared to `React Hook Form`, especially concerning input changes? Consider their underlying mechanisms.",
          "answer": "`Redux-form` often causes more re-renders than `React Hook Form` because it stores the entire form state in the Redux store. Every time an input value changes, a Redux action is dispatched, updating the store, which then triggers a re-render of the connected `redux-form` component (and potentially its children). In contrast, `React Hook Form` uses uncontrolled components by default, relying on refs to directly access DOM input values. This approach minimizes re-renders of the React component tree as input changes do not necessarily trigger state updates that flow down the component hierarchy.",
          "analysisPoints": [
            "Compares fundamental architectural differences.",
            "Explains the impact on performance (re-renders).",
            "Connects to concepts of controlled vs. uncontrolled components/refs."
          ],
          "keyConcepts": [
            "Redux-Form",
            "React Hook Form",
            "Re-renders",
            "Performance",
            "Controlled Components",
            "Uncontrolled Components",
            "Refs",
            "Redux State"
          ],
          "evaluationCriteria": [
            "Accurate comparison of re-rendering mechanisms.",
            "Understanding of the underlying principles of each library.",
            "Clarity in explaining performance implications."
          ],
          "example": "While `redux-form` provides robust state management with Redux, its tight coupling with the Redux store for every input change can lead to more frequent component updates. `React Hook Form`'s philosophy of 'uncontrolled inputs' avoids this by primarily interacting directly with the DOM for value retrieval, thereby reducing the need for React component updates on every keystroke.",
          "tags": [
            "Redux-Form",
            "React Hook Form",
            "Performance",
            "Re-renders",
            "Architecture"
          ],
          "prerequisites": [
            "React Controlled/Uncontrolled Components",
            "Redux Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_redux_form_reinitialize_6",
          "topic": "Redux-Form: initialValues Priority",
          "level": "hard",
          "type": "mcq",
          "question": "Consider a `redux-form` setup where `enableReinitialize: true`. If the `initialValues` prop changes, and concurrently, a user has typed some data into a field, which value takes precedence for that field upon reinitialization?",
          "answer": "The new `initialValues` will overwrite the user-typed data.",
          "options": [
            "The user-typed data will always persist.",
            "The new `initialValues` will overwrite the user-typed data.",
            "It depends on whether the field is `pristine` or `dirty`.",
            "The form will throw an error due to a conflict."
          ],
          "analysisPoints": [
            "Tests understanding of reinitialization behavior with user interaction.",
            "Highlights a potential data loss scenario if not handled carefully.",
            "Distinguishes from `keepDirtyOnReinitialize` (which is not mentioned but a common related concept)."
          ],
          "keyConcepts": [
            "Redux-Form",
            "enableReinitialize",
            "initialValues",
            "User Input",
            "Data Precedence"
          ],
          "evaluationCriteria": [
            "Correct understanding of `enableReinitialize`'s default overwrite behavior.",
            "Identification of potential side effects."
          ],
          "example": "When `enableReinitialize: true` is set, `redux-form` prioritizes the `initialValues` prop. If the `initialValues` prop changes, the form will reset to these new values, overwriting any unsaved user input. If you need to preserve user changes while still allowing reinitialization for other fields, you might consider the `keepDirtyOnReinitialize` option (though not discussed in the provided text, it's a relevant advanced topic).",
          "tags": [
            "Redux-Form",
            "Reinitialization",
            "Edge Cases",
            "Data Handling"
          ],
          "prerequisites": [
            "Redux-Form Advanced Configuration"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_hook_form_1",
          "topic": "React Hook Form: Core Benefit",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a primary performance benefit of `React Hook Form` compared to other form libraries?",
          "answer": "It reduces re-renders by utilizing uncontrolled components and refs, directly interacting with the DOM.",
          "analysisPoints": [
            "Tests understanding of the library's core philosophy."
          ],
          "keyConcepts": [
            "React Hook Form",
            "Performance",
            "Re-renders",
            "Uncontrolled Components"
          ],
          "evaluationCriteria": [
            "Direct recall of key advantage."
          ],
          "example": "```javascript\n// React Hook Form minimizes re-renders on input change because it doesn't\n// manage the input's value via React state directly on every keystroke.\nconst { register } = useForm();\n<input {...register('name')} />\n```",
          "tags": [
            "React Hook Form",
            "Performance"
          ],
          "prerequisites": [
            "React Hooks Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_hook_form_2",
          "topic": "React Hook Form: Input Registration",
          "level": "easy",
          "type": "mcq",
          "question": "Which function from `useForm` is used to connect an HTML input element to `React Hook Form`'s internal state?",
          "answer": "`register`",
          "options": [
            "`connect`",
            "`bind`",
            "`register`",
            "`link`"
          ],
          "analysisPoints": [
            "Tests knowledge of `React Hook Form`'s API.",
            "Identifies the correct function for input management."
          ],
          "keyConcepts": [
            "React Hook Form",
            "register",
            "Input Management"
          ],
          "evaluationCriteria": [
            "Correct identification of the API method.",
            "Familiarity with hook-based form libraries."
          ],
          "example": "```jsx\nconst { register } = useForm();\n<input type=\"text\" {...register('username')} />\n```\nThe `register` function is spread onto input elements, allowing `React Hook Form` to track their values and apply validation rules. This is central to how the library manages form fields.",
          "tags": [
            "React Hook Form",
            "register",
            "API"
          ],
          "prerequisites": [
            "React Hooks"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_hook_form_3",
          "topic": "React Hook Form: Validation Errors",
          "level": "medium",
          "type": "flashcard",
          "question": "How do you access validation errors for a specific field (e.g., 'email') when using `React Hook Form`?",
          "answer": "Errors are accessed through the `errors` object within `formState`, like `formState.errors.email.message`.",
          "analysisPoints": [
            "Tests knowledge of error access pattern.",
            "Familiarity with `formState` object."
          ],
          "keyConcepts": [
            "React Hook Form",
            "formState",
            "errors",
            "Validation"
          ],
          "evaluationCriteria": [
            "Correct path to error messages."
          ],
          "example": "```jsx\nconst { formState: { errors } } = useForm();\n{errors.email && <p>{errors.email.message}</p>}\n```",
          "tags": [
            "React Hook Form",
            "Validation",
            "Errors"
          ],
          "prerequisites": [
            "React Hook Form Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_hook_form_4",
          "topic": "React Hook Form: `handleSubmit`",
          "level": "medium",
          "type": "open",
          "question": "Explain the role of the `handleSubmit` function in `React Hook Form` and how it's used in practice.",
          "answer": "The `handleSubmit` function is returned by the `useForm` hook. Its primary role is to wrap your custom `onSubmit` callback function. When the form is submitted (e.g., by clicking a submit button), `handleSubmit` first triggers the form's internal validation process. If validation passes, it then calls your `onSubmit` callback, passing the validated form data as an argument. If validation fails, it prevents the `onSubmit` callback from being executed and populates the `formState.errors` object. In practice, you typically attach it to the form's `onSubmit` attribute: `<form onSubmit={handleSubmit(yourSubmitFunction)}>`.",
          "analysisPoints": [
            "Understanding of submission flow.",
            "Role in validation triggering.",
            "Practical application syntax."
          ],
          "keyConcepts": [
            "React Hook Form",
            "handleSubmit",
            "Form Submission",
            "Validation"
          ],
          "evaluationCriteria": [
            "Clear explanation of `handleSubmit`'s purpose.",
            "Correct usage example.",
            "Understanding of its role in the form lifecycle."
          ],
          "example": "```jsx\nconst { handleSubmit } = useForm();\nconst mySubmitFunction = (data) => {\n  console.log('Form data:', data);\n};\n\n<form onSubmit={handleSubmit(mySubmitFunction)}>\n  {/* ... inputs ... */}\n  <button type=\"submit\">Submit</button>\n</form>\n```",
          "tags": [
            "React Hook Form",
            "Form Submission",
            "API"
          ],
          "prerequisites": [
            "React Hooks"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_hook_form_5",
          "topic": "React Hook Form: `yupResolver`",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the purpose of `yupResolver` when using `React Hook Form`?",
          "answer": "`yupResolver` is an adapter that integrates `Yup` validation schemas with `React Hook Form`, allowing the form to use `Yup`'s schema validation for its fields.",
          "analysisPoints": [
            "Tests knowledge of validation integration."
          ],
          "keyConcepts": [
            "React Hook Form",
            "Yup",
            "yupResolver",
            "Validation Schema"
          ],
          "evaluationCriteria": [
            "Correct definition of resolver's role."
          ],
          "example": "```typescript\nimport { yupResolver } from '@hookform/resolvers/yup';\nimport * as yup from 'yup';\n\nconst schema = yup.object({\n  name: yup.string().required()\n});\n\nconst { register } = useForm({\n  resolver: yupResolver(schema)\n});\n```",
          "tags": [
            "React Hook Form",
            "Yup",
            "Validation"
          ],
          "prerequisites": [
            "React Hook Form Basics",
            "Yup Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_hook_form_6",
          "topic": "React Hook Form: `isSubmitting`",
          "level": "easy",
          "type": "mcq",
          "question": "You want to disable the submit button while the form data is being sent to the server using `React Hook Form`. Which `formState` property should you use?",
          "answer": "`isSubmitting`",
          "options": [
            "`isValid`",
            "`isDirty`",
            "`isSubmitted`",
            "`isSubmitting`"
          ],
          "analysisPoints": [
            "Tests practical application of `formState` properties.",
            "Distinguishes between submission states."
          ],
          "keyConcepts": [
            "React Hook Form",
            "formState",
            "isSubmitting",
            "UI/UX"
          ],
          "evaluationCriteria": [
            "Correct identification of the relevant property.",
            "Understanding of loading state management."
          ],
          "example": "```jsx\nconst { formState: { isSubmitting } } = useForm();\n<button type=\"submit\" disabled={isSubmitting}>\n  {isSubmitting ? 'Sending...' : 'Submit'}\n</button>\n```\nThe `isSubmitting` property becomes `true` when `handleSubmit` is called and its `onSubmit` callback is executing (especially if it returns a Promise), and `false` once the process completes. This is ideal for managing UI states during asynchronous operations.",
          "tags": [
            "React Hook Form",
            "Form State",
            "UI",
            "Loading State"
          ],
          "prerequisites": [
            "React Hook Form Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_hook_form_7",
          "topic": "React Hook Form: `mode` option",
          "level": "hard",
          "type": "open",
          "question": "While not explicitly mentioned, `React Hook Form` has a `mode` option for `useForm`. Explain its purpose and how different `mode` values (e.g., 'onBlur', 'onChange', 'onSubmit') affect validation triggering.",
          "answer": "The `mode` option in `useForm` dictates *when* validation is triggered. This can significantly impact user experience:\n\n*   **`'onSubmit'` (Default):** Validation is triggered only when the form is submitted (i.e., when `handleSubmit` is invoked). Errors are shown only after an attempted submission.\n*   **`'onBlur'`:** Validation is triggered on `blur` events for each input field. This means as soon as a user moves out of a field, its validation rules are checked. This provides earlier feedback than `'onSubmit'` but avoids validating on every keystroke.\n*   **`'onChange'`:** Validation is triggered on every `change` event (i.e., every keystroke) for each input field. This provides the most immediate feedback but can be performance-intensive for complex forms or validation rules, and potentially annoying for users if errors appear too quickly.\n*   **`'onTouched'`:** Validation is triggered when a field is touched (i.e., receives a `blur` event after being focused). Only fields that have been 'touched' will show errors.\n\nThe `mode` allows developers to fine-tune the user experience by deciding how aggressively validation feedback is provided.",
          "analysisPoints": [
            "Tests knowledge beyond the provided text, implying deeper library understanding.",
            "Explains impact on UX and performance.",
            "Covers multiple `mode` values and their behavior."
          ],
          "keyConcepts": [
            "React Hook Form",
            "Validation Modes",
            "UX",
            "Performance",
            "onBlur",
            "onChange",
            "onSubmit",
            "onTouched"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of `mode`.",
            "Accurate description of each mode's behavior.",
            "Understanding of trade-offs (UX vs. performance)."
          ],
          "example": "```typescript\nconst { register, handleSubmit, formState: { errors } } = useForm({\n  mode: 'onBlur', // Validate on blur\n  resolver: yupResolver(schema)\n});\n```\nUsing `mode: 'onBlur'` can strike a good balance, providing feedback without being overly aggressive like `'onChange'`, which might show 'required' errors even before the user starts typing.",
          "tags": [
            "React Hook Form",
            "Validation",
            "Configuration",
            "Advanced",
            "UX"
          ],
          "prerequisites": [
            "React Hook Form Basics"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_hook_form_8",
          "topic": "React Hook Form: `watch` vs. `getValues`",
          "level": "hard",
          "type": "open",
          "question": "In `React Hook Form`, explain the difference between `watch` and `getValues` when attempting to retrieve form field values. When would you prefer one over the other?",
          "answer": "`watch` and `getValues` both retrieve form values, but they differ in how they interact with React's rendering cycle:\n\n*   **`watch()`:** This function is a hook (`useWatch` or directly `watch` from `useForm`). It subscribes your component to changes in the specified fields. When a watched field's value changes, the component that called `watch` will re-render. You would use `watch` when you need to dynamically display a value (e.g., a character counter for a textarea) or conditionally render parts of your form based on a field's value, as it ensures your UI stays synchronized with the latest input.\n*   **`getValues()`:** This function directly returns the current form values without subscribing the component to updates. It does *not* cause a re-render when the form values change. You would use `getValues` when you need to retrieve the current form state at a specific point in time (e.g., inside an `onClick` handler for a button that isn't the submit button, or within `useEffect` hooks that don't need to re-run on every field change) and don't need the component to re-render. It's useful for accessing values without incurring performance overhead of re-renders.\n\n**Preference:**\n*   Use `watch` for reactive updates that affect the UI, requiring re-renders.\n*   Use `getValues` for imperatively accessing values without causing re-renders, typically in event handlers or effects where you only need the snapshot of the current state.",
          "analysisPoints": [
            "Tests nuanced understanding of `React Hook Form` API.",
            "Explains the re-rendering implications of each method.",
            "Provides clear use-case distinctions."
          ],
          "keyConcepts": [
            "React Hook Form",
            "watch",
            "getValues",
            "Re-renders",
            "Form State",
            "Performance"
          ],
          "evaluationCriteria": [
            "Accurate distinction between reactive vs. imperative value retrieval.",
            "Clear explanation of re-rendering behavior.",
            "Sound advice on when to use each method."
          ],
          "example": "```typescript\n// Example using watch for conditional rendering\nfunction MyForm() {\n  const { register, watch } = useForm();\n  const showExtraField = watch('optionSelected');\n  return (\n    <form>\n      <input type=\"checkbox\" {...register('optionSelected')} />\n      {showExtraField && <input type=\"text\" {...register('extraData')} />}\n    </form>\n  );\n}\n\n// Example using getValues for an external button click\nfunction MyOtherForm() {\n  const { register, getValues } = useForm();\n  const handleLogData = () => {\n    console.log(getValues()); // Gets current form data without re-rendering\n  };\n  return (\n    <form>\n      <input {...register('field1')} />\n      <button type=\"button\" onClick={handleLogData}>Log Data</button>\n    </form>\n  );\n}\n```",
          "tags": [
            "React Hook Form",
            "API",
            "Advanced",
            "Performance"
          ],
          "prerequisites": [
            "React Hook Form Basics",
            "React Component Lifecycle"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_hook_form_9",
          "topic": "React Hook Form: Default Values",
          "level": "medium",
          "type": "mcq",
          "question": "How do you provide default values to inputs in `React Hook Form` when initializing `useForm`?",
          "answer": "By passing an object to the `defaultValues` option of `useForm`.",
          "options": [
            "By setting the `value` prop directly on each input.",
            "By passing an object to the `initialValues` option of `useForm`.",
            "By passing an object to the `defaultValues` option of `useForm`.",
            "By using the `setValue` method for each field in a `useEffect` hook."
          ],
          "analysisPoints": [
            "Tests knowledge of how to set initial/default values.",
            "Differentiates from `redux-form`'s `initialValues`.",
            "Identifies the most straightforward and idiomatic approach."
          ],
          "keyConcepts": [
            "React Hook Form",
            "defaultValues",
            "useForm",
            "Initialization"
          ],
          "evaluationCriteria": [
            "Correct identification of the `useForm` option.",
            "Understanding of the recommended way to set defaults."
          ],
          "example": "```typescript\nimport { useForm } from 'react-hook-form';\n\nfunction MyFormWithDefaults() {\n  const { register, handleSubmit } = useForm({\n    defaultValues: {\n      name: 'John Doe',\n      email: 'john.doe@example.com'\n    }\n  });\n\n  const onSubmit = (data) => console.log(data);\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <input {...register('name')} />\n      <input type=\"email\" {...register('email')} />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n```\nThe `defaultValues` option is the canonical way to set initial values for your form fields in `React Hook Form`. This ensures that fields are populated correctly upon component mount without needing to manually manage their `value` props.",
          "tags": [
            "React Hook Form",
            "Default Values",
            "Form Initialization"
          ],
          "prerequisites": [
            "React Hook Form Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_redux_form_dynamic_reinitialize",
          "title": "Build a User Profile Editor with Dynamic Reinitialization (Redux-Form)",
          "description": "\nImplement a user profile editing form using `redux-form`. The form should be capable of loading different user profiles from a simulated API and reinitializing its fields whenever the `initialValues` (representing the currently selected user's data) change.\n\n**Requirements:**\n\n1.  Set up a basic `redux-form` for `firstName` and `lastName`.\n2.  Simulate fetching user data asynchronously (e.g., using `setTimeout` or a mock API call).\n3.  Use `mapStateToProps` to provide `initialValues` to `reduxForm`.\n4.  Crucially, configure `redux-form` to reinitialize when the `initialValues` prop changes.\n5.  Include a button to 'Load User A' and 'Load User B' to demonstrate reinitialization.\n6.  Display `pristine`, `submitting` status, and enable/disable submit/reset buttons accordingly.\n7.  Implement a simple `onSubmit` handler to log form data.\n\n**Considerations:**\n*   How will you manage the `userId` that dictates which user's data is fetched and passed as `initialValues`?\n*   How to handle the initial load of user data?\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\nimport { createStore, combineReducers } from 'redux';\nimport { Provider } from 'react-redux';\nimport { reduxForm, Field, reducer as formReducer } from 'redux-form';\nimport { connect } from 'react-redux';\n\n// Mock Redux store setup\nconst initialUserState = {\n  data: { firstName: '', lastName: '' }\n};\n\nfunction userReducer(state = initialUserState, action) {\n  switch (action.type) {\n    case 'SET_USER_DATA':\n      return { ...state, data: action.payload };\n    default:\n      return state;\n  }\n}\n\nconst rootReducer = combineReducers({\n  form: formReducer,\n  user: userReducer,\n});\n\nconst store = createStore(rootReducer);\n\n// --- Your Redux-Form Component will go here ---\n\n// Define a presentational component for the form\nclass UserProfileForm extends React.Component {\n  render() {\n    const { handleSubmit, pristine, reset, submitting } = this.props;\n    return (\n      <form onSubmit={handleSubmit}>\n        <div>\n          <label>First Name</label>\n          <div>\n            <Field name=\"firstName\" component=\"input\" type=\"text\" />\n          </div>\n        </div>\n        <div>\n          <label>Last Name</label>\n          <div>\n            <Field name=\"lastName\" component=\"input\" type=\"text\" />\n          </div>\n        </div>\n        <div>\n          <button type=\"submit\" disabled={pristine || submitting}>Submit</button>\n          <button type=\"button\" disabled={pristine || submitting} onClick={reset}>Reset</button>\n        </div>\n      </form>\n    );\n  }\n}\n\n// TODO: Implement mapStateToProps to get initialValues\nconst mapStateToProps = (state) => ({});\n\n// TODO: Apply reduxForm HOC with enableReinitialize\nconst UserProfileFormConnected = reduxForm({\n  form: 'userProfileEdit',\n  // TODO: Add enableReinitialize here\n})(UserProfileForm);\n\n// TODO: Connect the form to Redux\nconst FinalUserProfileForm = connect(mapStateToProps)(UserProfileFormConnected);\n\n// Main App Component to demonstrate loading users\nfunction App() {\n  const [currentUserId, setCurrentUserId] = useState(null);\n\n  useEffect(() => {\n    // Simulate initial data load for a default user\n    fetchUserData('user1'); // Load a default user on mount\n  }, []);\n\n  const fetchUserData = (userId) => {\n    // Simulate API call\n    const userData = {\n      'user1': { firstName: 'Alice', lastName: 'Smith' },\n      'user2': { firstName: 'Bob', lastName: 'Johnson' }\n    };\n    setTimeout(() => {\n      store.dispatch({ type: 'SET_USER_DATA', payload: userData[userId] });\n      setCurrentUserId(userId);\n    }, 500);\n  };\n\n  const onSubmit = (values) => {\n    console.log('Form submitted:', values);\n    alert(JSON.stringify(values, null, 2));\n    // Simulate API submission\n    return new Promise(resolve => setTimeout(resolve, 1000));\n  };\n\n  return (\n    <Provider store={store}>\n      <h1>Redux-Form Dynamic Reinitialization</h1>\n      <button onClick={() => fetchUserData('user1')}>Load User A</button>\n      <button onClick={() => fetchUserData('user2')} style={{marginLeft: '10px'}}>Load User B</button>\n      <hr />\n      {currentUserId && <FinalUserProfileForm onSubmit={onSubmit} />}\n      {!currentUserId && <p>Loading user data...</p>}\n    </Provider>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\nimport { createStore, combineReducers } from 'redux';\nimport { Provider } from 'react-redux';\nimport { reduxForm, Field, reducer as formReducer } from 'redux-form';\nimport { connect } from 'react-redux';\n\n// Mock Redux store setup\nconst initialUserState = {\n  data: { firstName: '', lastName: '' }\n};\n\nfunction userReducer(state = initialUserState, action) {\n  switch (action.type) {\n    case 'SET_USER_DATA':\n      return { ...state, data: action.payload };\n    default:\n      return state;\n  }\n}\n\nconst rootReducer = combineReducers({\n  form: formReducer,\n  user: userReducer,\n});\n\nconst store = createStore(rootReducer);\n\n// --- Your Redux-Form Component will go here ---\n\n// Define a presentational component for the form\nclass UserProfileForm extends React.Component {\n  render() {\n    const { handleSubmit, pristine, reset, submitting } = this.props;\n    return (\n      <form onSubmit={handleSubmit}>\n        <div>\n          <label>First Name</label>\n          <div>\n            <Field name=\"firstName\" component=\"input\" type=\"text\" />\n          </div>\n        </div>\n        <div>\n          <label>Last Name</label>\n          <div>\n            <Field name=\"lastName\" component=\"input\" type=\"text\" />\n          </div>\n        </div>\n        <div>\n          <button type=\"submit\" disabled={pristine || submitting}>Submit</button>\n          <button type=\"button\" disabled={pristine || submitting} onClick={reset}>Reset</button>\n        </div>\n        <p>Pristine: {pristine ? 'Yes' : 'No'}</p>\n        <p>Submitting: {submitting ? 'Yes' : 'No'}</p>\n      </form>\n    );\n  }\n}\n\n// Implement mapStateToProps to get initialValues from Redux state\nconst mapStateToProps = (state) => ({\n  initialValues: state.user.data // This prop will trigger reinitialization if it changes\n});\n\n// Apply reduxForm HOC with enableReinitialize\nconst UserProfileFormConnected = reduxForm({\n  form: 'userProfileEdit',\n  enableReinitialize: true, // Crucial for dynamic initialValues\n  keepDirtyOnReinitialize: false // Default behavior, but good to be aware of\n})(UserProfileForm);\n\n// Connect the form to Redux to get access to initialValues\nconst FinalUserProfileForm = connect(mapStateToProps)(UserProfileFormConnected);\n\n// Main App Component to demonstrate loading users\nfunction App() {\n  const [currentUserId, setCurrentUserId] = useState(null);\n\n  useEffect(() => {\n    // Simulate initial data load for a default user\n    fetchUserData('user1'); // Load a default user on mount\n  }, []);\n\n  const fetchUserData = (userId) => {\n    // Simulate API call\n    const userData = {\n      'user1': { firstName: 'Alice', lastName: 'Smith' },\n      'user2': { firstName: 'Bob', lastName: 'Johnson' },\n      'user3': { firstName: 'Charlie', lastName: 'Brown' }\n    };\n    setTimeout(() => {\n      store.dispatch({ type: 'SET_USER_DATA', payload: userData[userId] });\n      setCurrentUserId(userId);\n    }, 500);\n  };\n\n  const onSubmit = async (values) => {\n    console.log('Form submitted:', values);\n    alert(JSON.stringify(values, null, 2));\n    // Simulate API submission\n    return new Promise(resolve => setTimeout(resolve, 1000));\n  };\n\n  return (\n    <Provider store={store}>\n      <h1>Redux-Form Dynamic Reinitialization</h1>\n      <button onClick={() => fetchUserData('user1')}>Load User A (Alice)</button>\n      <button onClick={() => fetchUserData('user2')} style={{marginLeft: '10px'}}>Load User B (Bob)</button>\n      <button onClick={() => fetchUserData('user3')} style={{marginLeft: '10px'}}>Load User C (Charlie)</button>\n      <hr />\n      {currentUserId ? <FinalUserProfileForm onSubmit={onSubmit} /> : <p>Loading user data...</p>}\n    </Provider>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "**Initial Load:** Form should display 'Alice Smith' after initial load.",
            "**Load User B:** Click 'Load User B'. Form fields should update to 'Bob Johnson'.",
            "**Type and Reload:** Type something into 'First Name' (e.g., 'EditedAlice'), then click 'Load User B'. The form should correctly reinitialize to 'Bob Johnson', overwriting the typed 'EditedAlice'.",
            "**Submit and Reset:** Fill out the form, submit, then reset. Verify it returns to the currently loaded user's `initialValues`.",
            "**Pristine State:** After loading a user, edit a field. `Pristine` status should change from 'Yes' to 'No'. Resetting should make it 'Yes' again."
          ],
          "hints": [
            "Remember that `enableReinitialize: true` must be part of the configuration object passed to `reduxForm`.",
            "The `initialValues` prop is typically provided by `mapStateToProps` in a `redux-form` setup.",
            "Ensure your Redux state properly updates the `user.data` slice to trigger the `initialValues` change."
          ],
          "tags": [
            "Redux-Form",
            "Reinitialization",
            "Dynamic Forms",
            "Redux",
            "Forms"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Redux-Form",
            "Redux Basics",
            "React Class Components"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "mapStateToProps",
            "Higher-Order Components",
            "Form State Management"
          ]
        },
        {
          "id": "task_react_hook_form_advanced_validation",
          "title": "Build a Robust User Registration Form (React Hook Form + Yup)",
          "description": "\nCreate a user registration form using `React Hook Form` and `Yup` for comprehensive client-side validation. The form should include standard fields and demonstrate advanced validation concepts.\n\n**Requirements:**\n\n1.  **Basic Fields:** `username` (string), `email` (email format), `password` (string), `confirmPassword` (string).\n2.  **Required Fields:** All fields must be required.\n3.  **Email Validation:** `email` must be a valid email format.\n4.  **Password Strength:** `password` must be at least 8 characters long, contain at least one uppercase letter, one lowercase letter, one number, and one special character.\n5.  **Confirm Password:** `confirmPassword` must match `password`.\n6.  **Conditional Field:** Add a checkbox 'Are you a student?' (`isStudent`). If checked, a new input field `studentId` should appear, which is required only when `isStudent` is true.\n7.  **Error Display:** Display validation error messages clearly below each input.\n8.  **Loading State:** Disable the submit button and show 'Submitting...' when the form is being submitted.\n9.  Implement a simple `onSubmit` handler to log the validated data (simulate API call with `setTimeout`).\n\n**Considerations:**\n*   How to define complex regex-based validation in Yup?\n*   How to handle conditional validation based on other field values?\n*   How to conditionally render fields in React Hook Form?\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\nimport { useForm } from 'react-hook-form';\nimport { yupResolver } from '@hookform/resolvers/yup';\nimport * as yup from 'yup';\n\n// TODO: Define the Yup validation schema here\nconst schema = yup.object({\n  username: yup.string().required('Username is required'),\n  email: yup.string().email('Invalid email format').required('Email is required'),\n  password: yup.string().required('Password is required'),\n  confirmPassword: yup.string().required('Confirm Password is required'),\n  // TODO: Add conditional field and its validation\n}).required();\n\nfunction RegistrationForm() {\n  const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm({\n    resolver: yupResolver(schema)\n  });\n\n  const onSubmit = async (data) => {\n    console.log('Form data:', data);\n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 1500));\n    alert('Registration successful! Check console for data.');\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <h2>Register Account</h2>\n\n      <div>\n        <label htmlFor=\"username\">Username:</label>\n        <input id=\"username\" {...register('username')} />\n        {errors.username && <p style={{color: 'red'}}>{errors.username.message}</p>}\n      </div>\n\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input id=\"email\" type=\"email\" {...register('email')} />\n        {errors.email && <p style={{color: 'red'}}>{errors.email.message}</p>}\n      </div>\n\n      <div>\n        <label htmlFor=\"password\">Password:</label>\n        <input id=\"password\" type=\"password\" {...register('password')} />\n        {errors.password && <p style={{color: 'red'}}>{errors.password.message}</p>}\n      </div>\n\n      <div>\n        <label htmlFor=\"confirmPassword\">Confirm Password:</label>\n        <input id=\"confirmPassword\" type=\"password\" {...register('confirmPassword')} />\n        {errors.confirmPassword && <p style={{color: 'red'}}>{errors.confirmPassword.message}</p>}\n      </div>\n\n      {/* TODO: Add conditional student field here */}\n\n      <button type=\"submit\" disabled={isSubmitting}>\n        {isSubmitting ? 'Registering...' : 'Register'}\n      </button>\n    </form>\n  );\n}\n\nexport default RegistrationForm;\n",
          "solutionCode": "import React from 'react';\nimport { useForm } from 'react-hook-form';\nimport { yupResolver } from '@hookform/resolvers/yup';\nimport * as yup from 'yup';\n\n// Define the Yup validation schema\nconst schema = yup.object({\n  username: yup.string()\n    .required('Username is required')\n    .min(3, 'Username must be at least 3 characters')\n    .max(20, 'Username cannot exceed 20 characters'),\n  email: yup.string()\n    .email('Invalid email format')\n    .required('Email is required'),\n  password: yup.string()\n    .required('Password is required')\n    .min(8, 'Password must be at least 8 characters long')\n    .matches(/[A-Z]/, 'Password must contain at least one uppercase letter')\n    .matches(/[a-z]/, 'Password must contain at least one lowercase letter')\n    .matches(/\\d/, 'Password must contain at least one number')\n    .matches(/[^A-Za-z0-9]/, 'Password must contain at least one special character'),\n  confirmPassword: yup.string()\n    .required('Confirm Password is required')\n    .oneOf([yup.ref('password'), null], 'Passwords must match'), // Matches 'password' field\n  isStudent: yup.boolean(),\n  studentId: yup.string().when('isStudent', {\n    is: true,\n    then: (schema) => schema.required('Student ID is required for students'),\n    otherwise: (schema) => schema.notRequired(), // Not required if isStudent is false/undefined\n  }),\n}).required();\n\nfunction RegistrationForm() {\n  const { register, handleSubmit, watch, formState: { errors, isSubmitting } } = useForm({\n    resolver: yupResolver(schema),\n    mode: 'onBlur' // Validate on blur for better UX\n  });\n\n  // Watch the 'isStudent' field to conditionally render 'studentId'\n  const isStudent = watch('isStudent', false);\n\n  const onSubmit = async (data) => {\n    console.log('Form data:', data);\n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 1500));\n    alert('Registration successful! Check console for data.');\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)} style={{ maxWidth: '400px', margin: '20px auto', padding: '20px', border: '1px solid #ccc', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' }}>\n      <h2>Register Account</h2>\n\n      <div style={{ marginBottom: '15px' }}>\n        <label htmlFor=\"username\" style={{ display: 'block', marginBottom: '5px' }}>Username:</label>\n        <input id=\"username\" {...register('username')} style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}/>\n        {errors.username && <p style={{color: 'red', fontSize: '0.8em', marginTop: '5px'}}>{errors.username.message}</p>}\n      </div>\n\n      <div style={{ marginBottom: '15px' }}>\n        <label htmlFor=\"email\" style={{ display: 'block', marginBottom: '5px' }}>Email:</label>\n        <input id=\"email\" type=\"email\" {...register('email')} style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}/>\n        {errors.email && <p style={{color: 'red', fontSize: '0.8em', marginTop: '5px'}}>{errors.email.message}</p>}\n      </div>\n\n      <div style={{ marginBottom: '15px' }}>\n        <label htmlFor=\"password\" style={{ display: 'block', marginBottom: '5px' }}>Password:</label>\n        <input id=\"password\" type=\"password\" {...register('password')} style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}/>\n        {errors.password && <p style={{color: 'red', fontSize: '0.8em', marginTop: '5px'}}>{errors.password.message}</p>}\n      </div>\n\n      <div style={{ marginBottom: '15px' }}>\n        <label htmlFor=\"confirmPassword\" style={{ display: 'block', marginBottom: '5px' }}>Confirm Password:</label>\n        <input id=\"confirmPassword\" type=\"password\" {...register('confirmPassword')} style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}/>\n        {errors.confirmPassword && <p style={{color: 'red', fontSize: '0.8em', marginTop: '5px'}}>{errors.confirmPassword.message}</p>}\n      </div>\n\n      <div style={{ marginBottom: '15px' }}>\n        <label style={{ display: 'flex', alignItems: 'center' }}>\n          <input type=\"checkbox\" {...register('isStudent')} style={{ marginRight: '5px' }}/>\n          Are you a student?\n        </label>\n      </div>\n\n      {isStudent && (\n        <div style={{ marginBottom: '15px' }}>\n          <label htmlFor=\"studentId\" style={{ display: 'block', marginBottom: '5px' }}>Student ID:</label>\n          <input id=\"studentId\" {...register('studentId')} style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}/>\n          {errors.studentId && <p style={{color: 'red', fontSize: '0.8em', marginTop: '5px'}}>{errors.studentId.message}</p>}\n        </div>\n      )}\n\n      <button type=\"submit\" disabled={isSubmitting} style={{ padding: '10px 20px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}>\n        {isSubmitting ? 'Registering...' : 'Register'}\n      </button>\n    </form>\n  );\n}\n\nexport default RegistrationForm;\n",
          "testCases": [
            "**Empty Submission:** Submit the form with all fields empty. Verify all 'required' error messages appear.",
            "**Invalid Email:** Enter 'test' in email. Verify 'Invalid email format' error.",
            "**Short Password:** Enter 'pass123' in password. Verify 'at least 8 characters' error.",
            "**Weak Password:** Enter 'password123' in password. Verify errors for missing uppercase, special characters.",
            "**Mismatched Passwords:** Enter 'Pass123!A' in password and 'Pass123!B' in confirm password. Verify 'Passwords must match' error.",
            "**Student Field Not Visible/Required:** Ensure `studentId` is not visible or required when 'Are you a student?' is unchecked.",
            "**Student Field Visible/Required:** Check 'Are you a student?', then leave `studentId` empty. Verify `studentId` field appears and shows 'Student ID is required' error.",
            "**Successful Submission:** Fill all fields correctly (including `studentId` if `isStudent` is checked). Verify console log and alert of successful submission, and submit button disables/enables correctly."
          ],
          "hints": [
            "For password complexity, Yup's `.matches()` method with regular expressions is very powerful.",
            "To make one field's validation dependent on another (like `confirmPassword` matching `password` or `studentId` being required conditionally), use `yup.ref()` or `yup.string().when()`.",
            "To conditionally render `studentId` based on `isStudent`'s value, use `watch('isStudent')` to get its live value.",
            "Consider setting `mode: 'onBlur'` or `mode: 'onChange'` in `useForm` for immediate validation feedback.",
            "Remember to `import * as yup from 'yup';` and use `yup.object().required()` for the root schema."
          ],
          "tags": [
            "React Hook Form",
            "Yup",
            "Validation",
            "Conditional Logic",
            "Forms",
            "UI/UX"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React Hooks",
            "Yup Library",
            "Basic HTML Forms"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Schema Validation",
            "Conditional Rendering",
            "RegEx",
            "Form Submission"
          ]
        }
      ]
    }
  },
  {
    "id": "11b51687-0a07-43c6-a331-9ab5f08e5839",
    "startLine": 14500,
    "endLine": 14599,
    "processedDate": "2025-06-17T13:59:40.410Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_form_best_practices",
          "title": "Form Submission Best Practices in React",
          "content": "Form handling is a crucial part of web development, and implementing forms correctly ensures a good user experience, data integrity, and security. In React, several best practices emerge for managing form state, validation, and accessibility.\n\n## Key Concepts\n\n### 1. Client-side and Server-side Validation\n\n**Client-side validation** provides immediate feedback to the user, improving user experience by preventing unnecessary server requests and guiding the user to correct errors quickly. It checks input formats, required fields, and basic constraints.\n\n**Server-side validation** is absolutely essential for security and data integrity. Client-side validation can be bypassed, so all data submitted to the server *must* be re-validated on the server. This prevents malicious data injection, ensures business logic is adhered to, and guards against corrupted data.\n\n### 2. Controlled Components\n\nIn React, a 'controlled component' is a form element (like `<input>`, `<textarea>`, or `<select>`) whose value is controlled by React state. The state is the single source of truth. When the user types into a controlled input, an `onChange` event handler updates the component's state, and the input's `value` prop is then re-rendered with the new state. This provides a clear, reactive way to manage form data.\n\n### 3. Form Libraries for Complex Forms\n\nFor forms with many fields, complex validation rules, or multi-step flows, managing state and logic manually can become cumbersome. Libraries like Formik, React Hook Form, or Redux Form abstract away much of the boilerplate, providing:\n-   Simplified state management for form values, errors, and touched fields.\n-   Declarative validation schemas (e.g., using Yup or Zod).\n-   Performance optimizations (e.g., preventing unnecessary re-renders).\n-   Helpers for submission, resetting, and field-level interactions.\n\n### 4. Proper Error Handling\n\nClear and timely error messages are vital for user experience. Errors should be displayed inline, close to the problematic input field, and clearly explain what went wrong and how to fix it. This includes:\n-   **Validation errors**: Informing the user about incorrect input format or missing fields.\n-   **Submission errors**: Handling network issues, server-side validation failures, or other backend problems.\n\n### 5. ARIA Attributes for Accessibility\n\nARIA (Accessible Rich Internet Applications) attributes provide semantic meaning to elements, making web content and applications more accessible to people with disabilities, especially those using screen readers. For forms, common ARIA attributes include:\n-   `aria-labelledby` / `aria-describedby`: Linking labels/descriptions to form controls.\n-   `aria-required`: Indicating a required field.\n-   `aria-invalid`: Indicating an invalid input field.\n-   `aria-live`: For dynamic content updates, such as submission messages or real-time validation feedback.\n\n### 6. Visual Feedback During Submission\n\nWhen a user submits a form, especially if it involves an asynchronous operation (like an API call), it's important to provide visual feedback. This prevents the user from submitting the form multiple times, assures them that the action is being processed, and improves perceived performance. Examples include:\n-   Disabling the submit button.\n-   Displaying a loading spinner or progress bar.\n-   Changing the button text (e.g., \"Submitting...\").\n\n### 7. User Experience (UX) for Multi-step Forms\n\nMulti-step forms break down complex data collection into smaller, manageable sections. Good UX for these forms includes:\n-   **Progress indicators**: Clearly showing the user which step they are on and how many steps remain.\n-   **Clear navigation**: Obvious \"Next\" and \"Back\" buttons.\n-   **Data persistence**: Allowing users to navigate back and forth without losing previously entered data.\n-   **Error summaries**: Consolidating errors across steps before final submission.\n",
          "examples": [
            {
              "id": "example_form_best_practices_1",
              "title": "Basic Controlled Component with Client-Side Validation",
              "code": "import React, { useState } from 'react';\n\nfunction LoginForm() {\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const [emailError, setEmailError] = useState('');\n  const [passwordError, setPasswordError] = useState('');\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  const validateForm = () => {\n    let isValid = true;\n    setEmailError('');\n    setPasswordError('');\n\n    if (!email) {\n      setEmailError('Email is required.');\n      isValid = false;\n    } else if (!/^[\\w-]+(\\.[\\w-]+)*@([a-z0-9-]+(\\.[a-z0-9-]+)*?\\.[a-z]{2,6}|(\\d{1,3}\\.){3}\\d{1,3})(:\\d{4})?$/.test(email)) {\n      setEmailError('Invalid email format.');\n      isValid = false;\n    }\n\n    if (!password) {\n      setPasswordError('Password is required.');\n      isValid = false;\n    } else if (password.length < 6) {\n      setPasswordError('Password must be at least 6 characters.');\n      isValid = false;\n    }\n\n    return isValid;\n  };\n\n  const handleSubmit = async (event) => {\n    event.preventDefault();\n    if (validateForm()) {\n      setIsSubmitting(true);\n      // Simulate API call\n      try {\n        await new Promise(resolve => setTimeout(resolve, 1500));\n        console.log('Form submitted successfully:', { email, password });\n        alert('Login successful!');\n        // Clear form or redirect\n      } catch (error) {\n        console.error('Submission error:', error);\n        alert('Login failed. Please try again.');\n      } finally {\n        setIsSubmitting(false);\n      }\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px', maxWidth: '300px', margin: '20px auto', padding: '20px', border: '1px solid #ccc', borderRadius: '5px' }}>\n      <h2>Login</h2>\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input\n          type=\"email\"\n          id=\"email\"\n          value={email}\n          onChange={(e) => setEmail(e.target.value)}\n          aria-required=\"true\"\n          aria-invalid={!!emailError}\n          aria-describedby=\"email-error\"\n          disabled={isSubmitting}\n        />\n        {emailError && <div id=\"email-error\" style={{ color: 'red', fontSize: '0.8em' }}>{emailError}</div>}\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password:</label>\n        <input\n          type=\"password\"\n          id=\"password\"\n          value={password}\n          onChange={(e) => setPassword(e.target.value)}\n          aria-required=\"true\"\n          aria-invalid={!!passwordError}\n          aria-describedby=\"password-error\"\n          disabled={isSubmitting}\n        />\n        {passwordError && <div id=\"password-error\" style={{ color: 'red', fontSize: '0.8em' }}>{passwordError}</div>}\n      </div>\n      <button type=\"submit\" disabled={isSubmitting} style={{ padding: '10px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: isSubmitting ? 'not-allowed' : 'pointer' }}>\n        {isSubmitting ? 'Logging in...' : 'Login'}\n      </button>\n    </form>\n  );\n}\n\nexport default LoginForm;\n",
              "explanation": "This example demonstrates a basic login form using React's `useState` hook to manage form input values, validation errors, and submission state. It showcases:\n-   **Controlled Components**: `email` and `password` inputs are bound to state variables.\n-   **Client-side Validation**: The `validateForm` function checks for required fields and basic format, providing immediate feedback.\n-   **Error Handling**: Error messages are displayed below the relevant input field.\n-   **Visual Feedback**: The submit button is disabled and its text changes during submission (`isSubmitting` state).\n-   **ARIA Attributes**: `aria-required`, `aria-invalid`, and `aria-describedby` are used to improve accessibility.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_form_best_practices_1",
            "question_form_best_practices_2",
            "question_form_best_practices_3",
            "question_form_best_practices_4",
            "question_form_best_practices_5",
            "question_form_best_practices_6",
            "question_form_best_practices_7",
            "question_form_best_practices_8",
            "question_form_best_practices_9"
          ],
          "relatedTasks": [
            "task_complex_registration_form"
          ],
          "tags": [
            "Forms",
            "React",
            "Validation",
            "Accessibility",
            "UX",
            "Controlled Components"
          ],
          "technology": "React",
          "prerequisites": [
            "React State Management",
            "Event Handling in React",
            "HTML Forms"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Complex Form Development",
            "User Input Handling",
            "Accessibility Best Practices"
          ]
        },
        {
          "id": "theory_focus_input_on_load",
          "title": "Focusing Input Elements on Page Load in React",
          "content": "A common UX requirement is to automatically focus an input field when a component mounts, such as a search bar on a search results page or the first field in a login form. In React, directly manipulating the DOM (like calling `.focus()`) should be done carefully, typically within lifecycle methods for class components or `useEffect` hooks for functional components.\n\n## Key Concepts\n\n### 1. Using Refs in React\n\nRefs provide a way to access DOM nodes or React elements created in the `render` method. They are primarily used for:\n-   Managing focus, text selection, or media playback.\n-   Triggering imperative animations.\n-   Integrating with third-party DOM libraries.\n\n### 2. Focusing in Class Components\n\nIn class components, you can use a ref callback or `React.createRef()` to get a reference to the DOM element. The `.focus()` method should then be called within `componentDidMount()`. This lifecycle method runs after the component has been rendered to the DOM, ensuring that the input element exists and can be focused.\n\n**Ref Callback**: A function passed to the `ref` prop. React calls this function with the DOM element when the component mounts, and `null` when it unmounts. This allows you to store a reference to the DOM node directly.\n\n### 3. Focusing in Functional Components with Hooks\n\nFunctional components utilize the `useRef` hook to create mutable ref objects and the `useEffect` hook to perform side effects after rendering. `useRef` returns a ref object whose `.current` property can be set to the DOM element. `useEffect` with an empty dependency array (`[]`) ensures that the effect runs only once after the initial render, mimicking `componentDidMount`.\n\n**`useRef`**: Returns a mutable ref object. The `current` property is initialized to the passed argument (`null` by default). This object will persist for the full lifetime of the component.\n\n**`useEffect`**: The function passed to `useEffect` runs after every render. With an empty dependency array `[]`, it runs only once after the initial render. This is the perfect place to perform DOM manipulations like focusing an input, as the DOM is guaranteed to be available.\n",
          "examples": [
            {
              "id": "example_focus_input_1",
              "title": "Focusing Input in a Class Component",
              "code": "import React from 'react';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.nameInput = null; // Initialize ref\n  }\n\n  componentDidMount() {\n    // Ensure the ref is set before calling focus\n    if (this.nameInput) {\n      this.nameInput.focus();\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Input below should automatically focus on page load.</p>\n        <input\n          ref={(input) => { this.nameInput = input; }} // Assign DOM node to ref property\n          defaultValue=\"Will focus\"\n          aria-label=\"Name input\"\n        />\n        <br/>\n        <input\n          defaultValue=\"Won't focus\"\n          aria-label=\"Another input\"\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n",
              "explanation": "This example shows how to use a ref callback in a class component. The `ref` prop of the `<input>` element is set to a function that assigns the DOM node to `this.nameInput`. In `componentDidMount`, which runs after the component is mounted to the DOM, `this.nameInput.focus()` is called to set the focus on the input field. A check `if (this.nameInput)` is added for robustness, although in `componentDidMount`, the ref should already be set.",
              "language": "typescript"
            },
            {
              "id": "example_focus_input_2",
              "title": "Focusing Input in a Functional Component with Hooks",
              "code": "import React, { useRef, useEffect } from 'react';\n\nfunction App() {\n  const inputRef = useRef(null); // Create a ref object\n\n  useEffect(() => {\n    // Access the DOM node via .current property\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Empty dependency array ensures this runs only once on mount\n\n  return (\n    <div>\n      <p>Input below should automatically focus on page load.</p>\n      <input ref={inputRef} aria-label=\"Auto-focused input\" />\n    </div>\n  );\n}\n\nexport default App;\n",
              "explanation": "This example uses React Hooks to achieve the same functionality in a functional component. `useRef(null)` creates a mutable ref object `inputRef`. This `inputRef` object is then passed to the `ref` prop of the `<input>` element, causing React to assign the DOM element to `inputRef.current` when the component mounts. The `useEffect` hook, with an empty dependency array `[]`, ensures that the effect (calling `inputRef.current.focus()`) runs only once after the initial render, when the DOM node is guaranteed to be available.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_focus_input_1",
            "question_focus_input_2",
            "question_focus_input_3",
            "question_focus_input_4",
            "question_focus_input_5",
            "question_focus_input_6"
          ],
          "relatedTasks": [
            "task_autofocus_search_component"
          ],
          "tags": [
            "React",
            "Refs",
            "Hooks",
            "useEffect",
            "useRef",
            "DOM Manipulation",
            "UX"
          ],
          "technology": "React",
          "prerequisites": [
            "React Components",
            "React Lifecycle Methods",
            "React Hooks Basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Custom Hooks",
            "Imperative DOM Operations",
            "Accessibility Features"
          ]
        },
        {
          "id": "theory_rerender_on_resize",
          "title": "Re-rendering React Components on Browser Resize",
          "content": "React components often need to adapt their layout or display based on the browser window's dimensions. To achieve this, you can listen to the global `resize` event and update the component's state, triggering a re-render with the new dimensions. Proper event listener management is crucial to prevent memory leaks and optimize performance.\n\n## Key Concepts\n\n### 1. The `resize` Event\n\nThe `window.resize` event fires when the document view (window) has been resized. It's a standard DOM event that can be listened to directly.\n\n### 2. Managing Event Listeners in Class Components\n\n-   **Adding Listener (`componentDidMount`)**: Event listeners should be added in `componentDidMount()`. This ensures the component has mounted and the `window` object is available. It runs only once after the initial render.\n-   **Removing Listener (`componentWillUnmount`)**: It's critical to remove event listeners in `componentWillUnmount()`. This lifecycle method runs just before the component is unmounted and destroyed. Failing to remove listeners can lead to memory leaks (the listener function holds a reference to the unmounted component, preventing garbage collection) and unexpected behavior (listeners trying to update state on non-existent components).\n\n### 3. Managing Event Listeners in Functional Components with Hooks\n\n-   **`useEffect` for Subscriptions**: The `useEffect` hook is used for side effects, including setting up subscriptions like event listeners. The function passed to `useEffect` can return a cleanup function. This cleanup function runs when the component unmounts or before the effect re-runs (if dependencies change).\n-   **Cleanup Function**: By returning a function from `useEffect`, you tell React to run this cleanup when the component unmounts. For event listeners, this is where you call `window.removeEventListener()`.\n-   **Dependency Array**: An empty dependency array (`[]`) for `useEffect` means the effect runs once after the initial render and its cleanup runs only when the component unmounts. This behavior perfectly mimics `componentDidMount` and `componentWillUnmount` for this use case.\n\n### 4. Performance Optimization: Debouncing and Throttling\n\nThe `resize` event can fire very rapidly, potentially leading to a large number of state updates and re-renders, which can degrade performance. To mitigate this, **debouncing** or **throttling** the event handler is highly recommended.\n-   **Debouncing**: Delays the execution of the function until a certain amount of time has passed without any further events. Only the *last* call in a series of rapid calls executes.\n-   **Throttling**: Limits the rate at which a function can be called. The function will execute at most once per a given time period.\n\nFor `resize` events, debouncing is often preferred as you typically only care about the final window dimensions after the user has finished resizing.\n",
          "examples": [
            {
              "id": "example_rerender_on_resize_1",
              "title": "Re-rendering on Resize in a Class Component",
              "code": "import React from 'react';\n\nclass WindowDimensions extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { width: 0, height: 0 };\n    this.updateDimensions = this.updateDimensions.bind(this); // Bind 'this' to the handler\n  }\n\n  componentDidMount() {\n    this.updateDimensions(); // Set initial dimensions\n    window.addEventListener('resize', this.updateDimensions);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.updateDimensions);\n  }\n\n  updateDimensions() {\n    this.setState({ \n      width: window.innerWidth,\n      height: window.innerHeight \n    });\n  }\n\n  render() {\n    return (\n      <div style={{ padding: '20px', border: '1px solid #ccc', margin: '20px', display: 'inline-block' }}>\n        <h2>Window Dimensions (Class Component)</h2>\n        <p>Width: {this.state.width}px</p>\n        <p>Height: {this.state.height}px</p>\n      </div>\n    );\n  }\n}\n\nexport default WindowDimensions;\n",
              "explanation": "This class component example demonstrates how to track window dimensions. `componentDidMount` adds the `resize` event listener and calls `updateDimensions` once to set the initial state. The `updateDimensions` method updates the component's state with `window.innerWidth` and `window.innerHeight`, triggering a re-render. Crucially, `componentWillUnmount` removes the event listener to prevent memory leaks when the component is no longer in the DOM. The `updateDimensions` method is also bound to `this` in the constructor to ensure `this` refers to the component instance inside the event handler.",
              "language": "typescript"
            },
            {
              "id": "example_rerender_on_resize_2",
              "title": "Re-rendering on Resize in a Functional Component with Hooks (and Debounce)",
              "code": "import React, { useState, useEffect, useCallback } from 'react';\n\n// Helper for debouncing a function\nconst debounce = (func, delay) => {\n  let timeoutId;\n  return (...args) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n};\n\nfunction WindowDimensionsHooks() {\n  const [dimensions, setDimensions] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight,\n  });\n\n  // Using useCallback to memoize the debounced function, preventing re-creation on every render\n  const handleResize = useCallback(\n    debounce(() => {\n      setDimensions({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    }, 200), // Debounce by 200ms\n    [] // Dependency array for useCallback ensures the debounced function is created only once\n  );\n\n  useEffect(() => {\n    window.addEventListener('resize', handleResize);\n\n    // Cleanup function: runs when component unmounts or before effect re-runs\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [handleResize]); // Dependency array: re-run effect if handleResize changes (which it won't due to useCallback([]))\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', margin: '20px', display: 'inline-block' }}>\n      <h2>Window Dimensions (Functional Component)</h2>\n      <p>Width: {dimensions.width}px</p>\n      <p>Height: {dimensions.height}px</p>\n    </div>\n  );\n}\n\nexport default WindowDimensionsHooks;\n",
              "explanation": "This example uses React Hooks (`useState`, `useEffect`, `useCallback`) and demonstrates a more robust approach with debouncing.\n-   `useState` manages the `dimensions` state.\n-   `debounce` is a helper function that returns a debounced version of `setDimensions` logic.\n-   `useCallback` is used to memoize `handleResize`. This is important because without it, `debounce` would be called on every render, creating a new `handleResize` function each time. This new function would cause `useEffect` to re-run unnecessarily, potentially re-attaching the listener.\n-   `useEffect` adds the event listener. Its cleanup function (returned by the effect) removes the listener. The empty dependency array ensures the effect runs only once on mount and cleans up on unmount. The `[handleResize]` dependency array for `useEffect` ensures the listener is correctly managed if `handleResize` itself were to change (which it won't here due to `useCallback([])`).\n-   The `debounce` function ensures that `setDimensions` is only called after the user has stopped resizing the window for 200 milliseconds, preventing excessive re-renders and improving performance.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_rerender_on_resize_1",
            "question_rerender_on_resize_2",
            "question_rerender_on_resize_3",
            "question_rerender_on_resize_4",
            "question_rerender_on_resize_5",
            "question_rerender_on_resize_6",
            "question_rerender_on_resize_7"
          ],
          "relatedTasks": [
            "task_responsive_header"
          ],
          "tags": [
            "React",
            "Lifecycle Methods",
            "Hooks",
            "useEffect",
            "Event Listeners",
            "Performance",
            "Debounce",
            "Throttling"
          ],
          "technology": "React",
          "prerequisites": [
            "React State Management",
            "React Lifecycle Methods",
            "React Hooks Basics",
            "JavaScript Event Handling"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Responsive Design",
            "Performance Optimization",
            "Custom Hooks Development"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_form_best_practices_1",
          "topic": "Form Submission Validation",
          "level": "easy",
          "type": "mcq",
          "question": "Why is it considered a best practice to validate form data on both the client-side and the server-side?",
          "answer": "Client-side validation enhances user experience and performance, while server-side validation is crucial for security and data integrity.",
          "options": [
            "Client-side validation ensures security, and server-side validation ensures performance.",
            "Server-side validation is for UX, and client-side validation is for data integrity.",
            "Client-side validation enhances user experience and performance, while server-side validation is crucial for security and data integrity.",
            "Both client and server-side validation are only for performance optimization."
          ],
          "analysisPoints": [
            "Client-side validation provides immediate feedback, improving UX and reducing server load by catching simple errors early.",
            "Server-side validation is paramount for security because client-side checks can be easily bypassed by malicious users or faulty clients.",
            "Server-side validation ensures that data conforms to business rules and maintains database integrity, regardless of the client's behavior.",
            "Neglecting server-side validation can lead to security vulnerabilities, corrupted data, and application malfunctions."
          ],
          "keyConcepts": [
            "Client-side validation",
            "Server-side validation",
            "User Experience (UX)",
            "Security",
            "Data Integrity",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental purpose of each validation type.",
            "Ability to differentiate between UX/performance benefits and security/integrity benefits.",
            "Recognition of the critical role of server-side validation."
          ],
          "example": "Client-side validation offers instant feedback (e.g., 'Email format is invalid'), saving a round trip to the server. Server-side validation catches sophisticated attacks (e.g., SQL injection attempts) or ensures data consistency (e.g., uniqueness checks for usernames) even if the client-side script is tampered with.",
          "tags": [
            "Forms",
            "Validation",
            "Security",
            "UX",
            "Performance"
          ],
          "prerequisites": [
            "HTML Forms",
            "Basic Web Security"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_form_best_practices_2",
          "topic": "Controlled Components in React",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following best describes a 'controlled component' in React?",
          "answer": "A form element whose value is managed by React state and updated via an `onChange` handler.",
          "options": [
            "A form element that manages its own internal state.",
            "A form element whose value is set once and never changes.",
            "A form element whose value is managed by React state and updated via an `onChange` handler.",
            "Any HTML form element used within a React component."
          ],
          "analysisPoints": [
            "Controlled components mean that React component state is the 'single source of truth' for the input's value.",
            "The `value` prop is explicitly set by the component's state, making the component responsible for rendering the input's value.",
            "An `onChange` event handler is necessary to update the component's state whenever the input value changes, thereby triggering a re-render and updating the input's displayed value.",
            "This pattern allows for easy implementation of validation, formatting, and conditional enabling/disabling of inputs."
          ],
          "keyConcepts": [
            "Controlled Components",
            "React State",
            "`onChange` Event",
            "Single Source of Truth",
            "Form Management"
          ],
          "evaluationCriteria": [
            "Accurate definition of a controlled component.",
            "Understanding the role of React state and event handlers.",
            "Distinguishing from uncontrolled components."
          ],
          "example": "```jsx\nimport React, { useState } from 'react';\n\nfunction MyControlledInput() {\n  const [inputValue, setInputValue] = useState('');\n\n  const handleChange = (event) => {\n    setInputValue(event.target.value);\n  };\n\n  return (\n    <input type=\"text\" value={inputValue} onChange={handleChange} />\n  );\n}\n```\nIn this example, `inputValue` from `useState` controls the `value` prop of the input. Any change to the input triggers `handleChange`, which updates `inputValue`, and React then re-renders the input with the new value. The state `inputValue` is the single source of truth.",
          "tags": [
            "React",
            "Forms",
            "State Management",
            "Controlled Components"
          ],
          "prerequisites": [
            "React State",
            "Event Handling in React"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_form_best_practices_3",
          "topic": "Form Libraries",
          "level": "easy",
          "type": "flashcard",
          "question": "Name two popular React form libraries that simplify complex form management.",
          "answer": "Formik and React Hook Form.",
          "analysisPoints": [
            "These libraries provide abstractions for common form challenges.",
            "They typically handle state management, validation, submission, and accessibility concerns.",
            "Other notable libraries include Redux Form."
          ],
          "keyConcepts": [
            "Form Libraries",
            "Formik",
            "React Hook Form",
            "Form Management"
          ],
          "evaluationCriteria": [
            "Recall of prominent React form libraries."
          ],
          "example": "Formik simplifies form setup with `handleChange`, `handleBlur`, `handleSubmit` props, and integrated validation. React Hook Form focuses on performance by using uncontrolled components and native browser validation.",
          "tags": [
            "Forms",
            "Libraries",
            "React"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_form_best_practices_4",
          "topic": "Accessibility in Forms",
          "level": "medium",
          "type": "open",
          "question": "Explain the importance of ARIA attributes in form development and provide examples of how they are used.",
          "answer": "ARIA (Accessible Rich Internet Applications) attributes are crucial for making web forms accessible to users with disabilities, particularly those who rely on assistive technologies like screen readers. HTML alone often lacks the semantic information needed for complex UI components or dynamic updates. ARIA attributes bridge this gap by providing additional semantic meaning and conveying component states and properties to assistive technologies.\n\n**Importance:**\n1.  **Semantic Clarity**: They clarify the purpose and state of interactive elements for screen readers (e.g., is a field required, is it invalid, what is its description?).\n2.  **Navigation**: They can improve navigation for keyboard users and screen reader users by providing labels and descriptions where native HTML falls short.\n3.  **Dynamic Updates**: For real-time validation feedback or submission messages, ARIA live regions (`aria-live`) ensure that dynamic content changes are announced to the user without requiring them to manually refresh or navigate.\n\n**Examples:**\n*   `aria-required=\"true\"`: Indicates that a form field is mandatory. Screen readers will announce this to the user.\n    ```html\n    <label for=\"username\">Username</label>\n    <input type=\"text\" id=\"username\" aria-required=\"true\">\n    ```\n*   `aria-invalid=\"true\"` and `aria-describedby`: When a field has a validation error, `aria-invalid=\"true\"` informs assistive technologies that the input's value is not valid. `aria-describedby` links the input to an element that provides a description or error message.\n    ```html\n    <label for=\"email\">Email</label>\n    <input\n      type=\"email\"\n      id=\"email\"\n      aria-required=\"true\"\n      aria-invalid=\"true\" \n      aria-describedby=\"email-error-message\"\n    />\n    <div id=\"email-error-message\" style=\"color: red;\">Please enter a valid email address.</div>\n    ```\n*   `role=\"alert\"` with `aria-live=\"assertive\"`: For critical, time-sensitive error messages or success notifications that appear dynamically, `aria-live` ensures they are immediately announced.\n    ```html\n    <div role=\"alert\" aria-live=\"assertive\" style=\"color: green;\">\n      Form submitted successfully!\n    </div>\n    ```\nUsing these attributes ensures that all users, regardless of their abilities, can understand, interact with, and successfully complete forms.",
          "analysisPoints": [
            "Defining ARIA attributes and their purpose.",
            "Explaining the benefits for accessibility (screen readers, keyboard navigation).",
            "Providing concrete, correct examples of common ARIA attributes in form context.",
            "Understanding how ARIA contributes to semantic meaning and dynamic content announcements."
          ],
          "keyConcepts": [
            "ARIA Attributes",
            "Accessibility",
            "Screen Readers",
            "Semantic HTML",
            "User Experience (UX)",
            "Inclusive Design"
          ],
          "evaluationCriteria": [
            "Thorough understanding of ARIA's role.",
            "Ability to cite specific ARIA attributes and their application.",
            "Clear explanation of why they are important."
          ],
          "example": null,
          "tags": [
            "Accessibility",
            "ARIA",
            "Forms",
            "UX",
            "HTML"
          ],
          "prerequisites": [
            "HTML Forms",
            "Web Accessibility Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_form_best_practices_5",
          "topic": "Visual Feedback on Form Submission",
          "level": "medium",
          "type": "flashcard",
          "question": "What kind of visual feedback should be provided to users during form submission, and why?",
          "answer": "During form submission, provide visual feedback like disabling the submit button, showing a loading spinner/progress bar, or changing button text (e.g., 'Submitting...'). This prevents multiple submissions, assures the user the action is processing, and improves perceived performance.",
          "analysisPoints": [
            "Identifying common visual feedback elements.",
            "Explaining the user experience benefits (preventing double clicks, reassuring user, perceived performance).",
            "Relating feedback to asynchronous operations."
          ],
          "keyConcepts": [
            "Visual Feedback",
            "Form Submission",
            "User Experience (UX)",
            "Asynchronous Operations",
            "Loading States"
          ],
          "evaluationCriteria": [
            "Knowledge of UX best practices for forms.",
            "Understanding the 'why' behind the feedback."
          ],
          "example": "```jsx\n// Example of disabling button and changing text\n<button type=\"submit\" disabled={isSubmitting}>\n  {isSubmitting ? 'Sending...' : 'Submit'}\n</button>\n\n// Example of showing a spinner\n{isSubmitting && <div className=\"spinner\"></div>}\n```",
          "tags": [
            "Forms",
            "UX",
            "Visual Feedback",
            "Loading State"
          ],
          "prerequisites": [
            "React State",
            "Conditional Rendering"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_form_best_practices_6",
          "topic": "Multi-Step Forms UX",
          "level": "easy",
          "type": "flashcard",
          "question": "What are two key UX considerations for designing multi-step forms?",
          "answer": "Progress indicators to show current step and total steps, and clear navigation (e.g., 'Next' and 'Back' buttons) that preserves previously entered data.",
          "analysisPoints": [
            "Focus on guiding the user through the process.",
            "Ensuring data is not lost.",
            "Indicating progress and allowing flexible navigation."
          ],
          "keyConcepts": [
            "Multi-step Forms",
            "User Experience (UX)",
            "Progress Indicators",
            "Form Navigation",
            "Data Persistence"
          ],
          "evaluationCriteria": [
            "Understanding of common multi-step form challenges.",
            "Ability to suggest relevant UX solutions."
          ],
          "example": null,
          "tags": [
            "Forms",
            "UX",
            "Multi-step"
          ],
          "prerequisites": [
            "UI/UX Principles"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_form_best_practices_7",
          "topic": "Uncontrolled Components",
          "level": "medium",
          "type": "open",
          "question": "What is an 'uncontrolled component' in React, and when might you use one?",
          "answer": "An 'uncontrolled component' in React is a form element where the form data is handled by the DOM itself, rather than by React state. In an uncontrolled component, you access the form's data directly from the DOM using a ref, typically after a submission event, instead of managing its value with state and `onChange` handlers.\n\n**When to use an uncontrolled component:**\n1.  **Simple Forms**: For very basic forms where you only need to get the value once (e.g., on submission) and don't require instant validation or complex state synchronization.\n2.  **Performance Optimization**: For forms with a large number of inputs where updating React state on every keystroke (`onChange`) might introduce performance overhead. However, this is less of an issue with modern React and optimized controlled component patterns (e.g., React Hook Form's approach which leverages uncontrolled inputs for performance).\n3.  **Integrating with Non-React Code**: When working with traditional HTML form elements or a third-party DOM library that expects to manage its own internal state.\n4.  **File Inputs**: The `input type=\"file\"` is always an uncontrolled component because its value is read-only and can only be set by a user interaction, not programmatically.",
          "analysisPoints": [
            "Clear definition of an uncontrolled component (DOM-managed state).",
            "Correct mechanism for accessing values (refs).",
            "Appropriate use cases (simplicity, performance, integration, file inputs).",
            "Contrast with controlled components without explicitly mentioning the term 'controlled' if the question doesn't ask for it directly."
          ],
          "keyConcepts": [
            "Uncontrolled Components",
            "React Refs",
            "DOM Manipulation",
            "Form Data Access",
            "Performance",
            "File Input"
          ],
          "evaluationCriteria": [
            "Accurate definition and understanding of how data is managed.",
            "Ability to identify valid use cases.",
            "Awareness of when it might be preferred or necessary."
          ],
          "example": "```jsx\nimport React, { useRef } from 'react';\n\nfunction MyUncontrolledInput() {\n  const inputRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    alert(`Submitted value: ${inputRef.current.value}`);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Name:\n        <input type=\"text\" ref={inputRef} defaultValue=\"Initial Value\" />\n      </label>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n```\nIn this example, the input's value is not controlled by React state. Instead, `useRef` is used to get a direct reference to the DOM input element, and its value is accessed from `inputRef.current.value` only when the form is submitted.",
          "tags": [
            "React",
            "Forms",
            "Refs",
            "Uncontrolled Components"
          ],
          "prerequisites": [
            "React State",
            "React Refs"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_form_best_practices_8",
          "topic": "Form Best Practices - Code Implementation",
          "level": "medium",
          "type": "code",
          "question": "Refactor the following component to use a controlled input, display a client-side validation error if the email is empty or invalid, and disable the submit button during a simulated submission.",
          "answer": "```jsx\nimport React, { useState } from 'react';\n\nfunction UserRegistrationForm() {\n  const [email, setEmail] = useState('');\n  const [emailError, setEmailError] = useState('');\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  const validateEmail = (inputEmail) => {\n    if (!inputEmail.trim()) {\n      return 'Email cannot be empty.';\n    }\n    if (!/^[\\w-]+(\\.[\\w-]+)*@([a-z0-9-]+(\\.[a-z0-9-]+)*?\\.[a-z]{2,6}|(\\d{1,3}\\.){3}\\d{1,3})(:\\d{4})?$/.test(inputEmail)) {\n      return 'Please enter a valid email address.';\n    }\n    return ''; // No error\n  };\n\n  const handleChange = (e) => {\n    const newEmail = e.target.value;\n    setEmail(newEmail);\n    setEmailError(validateEmail(newEmail)); // Validate on change\n  };\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    const validationMessage = validateEmail(email);\n    if (validationMessage) {\n      setEmailError(validationMessage);\n      return;\n    }\n\n    setIsSubmitting(true);\n    console.log('Submitting email:', email);\n\n    // Simulate API call\n    try {\n      await new Promise(resolve => setTimeout(resolve, 1500));\n      alert('Registration successful for: ' + email);\n      setEmail(''); // Clear form on success\n      setEmailError('');\n    } catch (error) {\n      console.error('Submission failed:', error);\n      setEmailError('Submission failed. Please try again.');\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px', maxWidth: '300px', margin: '20px auto', padding: '20px', border: '1px solid #ccc', borderRadius: '5px' }}>\n      <h2>Register</h2>\n      <div>\n        <label htmlFor=\"emailInput\">Email:</label>\n        <input\n          type=\"email\"\n          id=\"emailInput\"\n          value={email}\n          onChange={handleChange}\n          aria-required=\"true\"\n          aria-invalid={!!emailError}\n          aria-describedby=\"email-error-message\"\n          disabled={isSubmitting}\n        />\n        {emailError && <div id=\"email-error-message\" style={{ color: 'red', fontSize: '0.8em' }}>{emailError}</div>}\n      </div>\n      <button type=\"submit\" disabled={isSubmitting}>\n        {isSubmitting ? 'Registering...' : 'Register'}\n      </button>\n    </form>\n  );\n}\n\nexport default UserRegistrationForm;\n```",
          "options": [],
          "analysisPoints": [
            "Correct usage of `useState` for `email`, `emailError`, and `isSubmitting` states.",
            "Input's `value` prop is controlled by the `email` state.",
            "`onChange` handler updates the `email` state and triggers validation.",
            "A separate `validateEmail` function encapsulates validation logic.",
            "Error message is conditionally rendered next to the input.",
            "Submit button's `disabled` prop is tied to `isSubmitting` state.",
            "Simulated asynchronous submission demonstrates `isSubmitting` state transition.",
            "Form submission `preventDefault()` is used.",
            "Proper ARIA attributes (`aria-required`, `aria-invalid`, `aria-describedby`) are applied."
          ],
          "keyConcepts": [
            "Controlled Components",
            "Client-side Validation",
            "State Management",
            "Event Handling",
            "Conditional Rendering",
            "Asynchronous Operations",
            "Form Submission",
            "Accessibility (ARIA)"
          ],
          "evaluationCriteria": [
            "Ability to implement controlled components correctly.",
            "Proficiency in client-side validation logic.",
            "Correct handling of loading states for UI feedback.",
            "Application of basic accessibility features.",
            "Clean code structure and separation of concerns."
          ],
          "example": null,
          "tags": [
            "React",
            "Forms",
            "Validation",
            "Controlled Components",
            "State Management",
            "Code Challenge"
          ],
          "prerequisites": [
            "React State",
            "Event Handling",
            "JavaScript Async/Await"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_form_best_practices_9",
          "topic": "Form Performance",
          "level": "hard",
          "type": "open",
          "question": "Discuss potential performance considerations when dealing with large or frequently updating forms in React, and how form libraries like React Hook Form address some of these issues.",
          "answer": "When dealing with large forms (many fields) or forms that update frequently (e.g., real-time validation on every keystroke), performance can become a concern due to excessive re-renders. Every state update in a controlled component causes the component (and potentially its children) to re-render. With many inputs, this can lead to noticeable lag.\n\n**Potential Performance Considerations:**\n1.  **Excessive Re-renders**: Each `onChange` event in a controlled component triggers a state update, which leads to a re-render. In a form with 50 inputs, 50 re-renders can occur with very little user interaction.\n2.  **Re-running Validation Logic**: If validation logic is complex or runs on every keystroke, it can be computationally expensive and contribute to performance bottlenecks.\n3.  **Context Re-renders**: If form state is managed via React Context, updates can trigger re-renders for all consumers of that context, leading to widespread unnecessary re-renders across the component tree.\n\n**How React Hook Form Addresses These Issues:**\nReact Hook Form (RHF) is designed with performance in mind, primarily by:\n1.  **Leveraging Uncontrolled Components (by default)**: RHF uses refs to access input values directly from the DOM, rather than binding them to React state. This means `onChange` handlers typically don't trigger re-renders of the component until submission or when specific events (like `onBlur` or explicit validation triggers) occur. This significantly reduces the number of re-renders during user input.\n2.  **Optimized Re-renders**: RHF's `useForm` hook only re-renders the component when form state that *you subscribe to* (e.g., `errors`, `isSubmitting`, `isValid`) changes, not on every input value change. It uses internal mechanisms to track input values efficiently without triggering a React re-render of the entire form component for every keystroke.\n3.  **Separation of Concerns**: It separates form state from component state. The input values are held by the native DOM inputs, and RHF only interacts with them when needed (e.g., to get values for submission or run validation).\n4.  **Batching Updates**: RHF often batches internal state updates, reducing the overall number of re-renders.\n5.  **Schema-based Validation**: It integrates seamlessly with schema validation libraries like Zod or Yup, allowing for efficient, optimized validation that can be triggered precisely when needed (e.g., `onBlur`, `onSubmit`).\n\nBy minimizing re-renders and optimizing how form state changes trigger React updates, RHF helps maintain a smooth user experience even with very complex forms.",
          "analysisPoints": [
            "Identify the core performance problem (excessive re-renders due to controlled component pattern).",
            "Mention specific areas of concern (state updates, validation re-runs, context re-renders).",
            "Explain RHF's fundamental approach (uncontrolled inputs with refs).",
            "Describe how RHF minimizes re-renders (only re-render on subscribed state changes, not input value changes).",
            "Highlight other RHF benefits (validation integration, batching).",
            "Compare implicitely with traditional controlled components."
          ],
          "keyConcepts": [
            "Form Performance",
            "Controlled vs. Uncontrolled Components",
            "React Hook Form",
            "Re-renders",
            "Optimization",
            "Validation",
            "React Context"
          ],
          "evaluationCriteria": [
            "Deep understanding of React rendering mechanisms in forms.",
            "Knowledge of performance bottlenecks specific to forms.",
            "Ability to explain how a modern library like RHF addresses these issues at a technical level.",
            "Clear and structured explanation."
          ],
          "example": null,
          "tags": [
            "React",
            "Forms",
            "Performance",
            "Optimization",
            "React Hook Form",
            "Advanced"
          ],
          "prerequisites": [
            "React Rendering",
            "Controlled/Uncontrolled Components",
            "React Hooks"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_focus_input_1",
          "topic": "Focusing Input - Class Components",
          "level": "easy",
          "type": "flashcard",
          "question": "Which React class component lifecycle method is best suited for focusing an input element on initial page load?",
          "answer": "`componentDidMount()`",
          "analysisPoints": [
            "`componentDidMount` runs after the component has been rendered to the DOM.",
            "This ensures the DOM element (the input) is available for direct manipulation like calling `.focus()`."
          ],
          "keyConcepts": [
            "React Lifecycle Methods",
            "`componentDidMount`",
            "DOM Manipulation",
            "Refs"
          ],
          "evaluationCriteria": [
            "Recall of appropriate lifecycle method for DOM interaction."
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "Refs"
          ],
          "prerequisites": [
            "React Lifecycle"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_focus_input_2",
          "topic": "Focusing Input - Functional Components",
          "level": "easy",
          "type": "flashcard",
          "question": "Which React Hooks are used to focus an input element on initial page load in a functional component?",
          "answer": "`useRef` to get a reference to the DOM element and `useEffect` with an empty dependency array (`[]`) to perform the focus operation after mount.",
          "analysisPoints": [
            "`useRef` creates a mutable object that persists across renders and holds a reference to the DOM node in its `.current` property.",
            "`useEffect` with `[]` mimics `componentDidMount`, executing its callback once after the initial render when the DOM is ready."
          ],
          "keyConcepts": [
            "React Hooks",
            "`useRef`",
            "`useEffect`",
            "DOM Manipulation",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Recall of appropriate hooks for DOM interaction.",
            "Understanding of `useEffect` dependency array."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "useEffect"
          ],
          "prerequisites": [
            "React Hooks Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_focus_input_3",
          "topic": "React Refs",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React class component. What will be the outcome regarding input focus on initial render?",
          "answer": "Only the input with `ref={(input) => { this.myInput = input; }}` will receive focus.",
          "options": [
            "Both inputs will receive focus.",
            "Neither input will receive focus.",
            "Only the input with `defaultValue=\"Won't focus\"` will receive focus.",
            "Only the input with `ref={(input) => { this.myInput = input; }}` will receive focus."
          ],
          "analysisPoints": [
            "The `ref` attribute is used to gain direct access to the DOM element.",
            "Only the input explicitly assigned to `this.myInput` via the `ref` callback can be targeted by `this.myInput.focus()`.",
            "`defaultValue` only sets the initial value of an uncontrolled input and has no bearing on focus behavior.",
            "`componentDidMount` is the correct place to perform DOM manipulations after the component is rendered."
          ],
          "keyConcepts": [
            "React Refs",
            "Class Components",
            "DOM Manipulation",
            "Lifecycle Methods",
            "`componentDidMount`"
          ],
          "evaluationCriteria": [
            "Understanding of how `ref` callbacks work.",
            "Knowledge of `componentDidMount`'s execution timing.",
            "Ability to interpret code related to DOM interaction."
          ],
          "example": "```jsx\nclass MyComponent extends React.Component {\n  componentDidMount() {\n    if (this.myInput) {\n      this.myInput.focus();\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <input defaultValue=\"Won't focus\" />\n        <input\n          ref={(input) => { this.myInput = input; }}\n          defaultValue=\"Will focus\"\n        />\n      </div>\n    );\n  }\n}\n```",
          "tags": [
            "React",
            "Refs",
            "Class Components",
            "Focus",
            "DOM"
          ],
          "prerequisites": [
            "React Refs",
            "React Lifecycle"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_focus_input_4",
          "topic": "React Refs vs. State for Input Values",
          "level": "medium",
          "type": "open",
          "question": "When would you choose to use `useRef` to interact with an input element, as opposed to managing its value with `useState` and making it a controlled component? Provide examples.",
          "answer": "You would typically choose `useRef` to interact with an input element for imperative DOM manipulations that do not directly involve the input's value or where managing the value through React state is unnecessary or cumbersome. This is in contrast to `useState`, which creates a 'controlled component' where React state is the single source of truth for the input's value.\n\n**Reasons to use `useRef` (for imperative actions):**\n1.  **Managing Focus, Selection, or Media Playback**: Directly calling `.focus()`, `.select()`, or interacting with `<video>`/`<audio>` elements. This is the most common use case for `useRef` with inputs.\n    *   **Example**: Auto-focusing an input on component mount or providing a button to re-focus a specific input.\n        ```jsx\n        function SearchBar() {\n          const inputRef = useRef(null);\n          useEffect(() => {\n            inputRef.current.focus(); // Auto-focus on mount\n          }, []);\n          return <input ref={inputRef} placeholder=\"Search...\" />;\n        }\n        ```\n2.  **Integrating with Third-Party DOM Libraries**: When a library expects to manage its own DOM elements or needs direct access to them (e.g., a charting library, a complex date picker).\n    *   **Example**: Initializing a non-React charting library on a `<div>` or `<canvas>` element.\n        ```jsx\n        function ChartComponent() {\n          const canvasRef = useRef(null);\n          useEffect(() => {\n            const chart = new ThirdPartyChart(canvasRef.current);\n            // ... setup chart\n          }, []);\n          return <canvas ref={canvasRef} />;\n        }\n        ```\n3.  **Uncontrolled Components**: When you want to retrieve the value of an input only at the time of form submission, and you don't need to control its value or react to every keystroke via state.\n    *   **Example**: A simple form where you get the value only on submit, without needing real-time validation or intermediate state updates.\n        ```jsx\n        function LoginForm() {\n          const usernameRef = useRef(null);\n          const handleSubmit = (event) => {\n            event.preventDefault();\n            alert('Username: ' + usernameRef.current.value);\n          };\n          return (\n            <form onSubmit={handleSubmit}>\n              <input type=\"text\" ref={usernameRef} defaultValue=\"guest\" />\n              <button type=\"submit\">Login</button>\n            </form>\n          );\n        }\n        ```\n\n**When to use `useState` (for controlled components):**\n-   When you need to react to every change in the input (e.g., real-time validation, formatting, conditional UI updates based on input value).\n-   When the input's value needs to be part of the component's state or passed down to other components.\n-   This is the more common and recommended approach for most form inputs in React, as it provides a predictable and reactive data flow.",
          "analysisPoints": [
            "Clearly differentiate between `useRef`'s imperative nature and `useState`'s declarative state management for inputs.",
            "Provide specific, common use cases for `useRef` (focus, media, third-party libraries, uncontrolled components).",
            "Give clear code examples for each `useRef` scenario.",
            "Briefly explain when `useState` is preferred for context and comparison.",
            "Demonstrate understanding of React's philosophy regarding DOM manipulation."
          ],
          "keyConcepts": [
            "React Refs",
            "useRef Hook",
            "useState Hook",
            "Controlled Components",
            "Uncontrolled Components",
            "DOM Manipulation",
            "Imperative vs. Declarative"
          ],
          "evaluationCriteria": [
            "Deep understanding of `useRef` and `useState` functionalities.",
            "Ability to identify appropriate use cases for each.",
            "Clear and concise explanations with relevant examples.",
            "Demonstration of knowledge about React's philosophy on direct DOM access."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "useState",
            "Controlled Components",
            "Uncontrolled Components",
            "DOM"
          ],
          "prerequisites": [
            "React Hooks",
            "Controlled/Uncontrolled Components"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_focus_input_5",
          "topic": "useEffect Dependency Array for Focus",
          "level": "medium",
          "type": "mcq",
          "question": "In a functional component, what is the purpose of passing an empty array `[]` as the second argument to `useEffect` when auto-focusing an input?",
          "answer": "It ensures the effect runs only once after the initial render, similar to `componentDidMount` in class components.",
          "options": [
            "It tells React to re-run the effect on every render.",
            "It prevents the effect from ever running.",
            "It ensures the effect runs only once after the initial render, similar to `componentDidMount` in class components.",
            "It makes the effect run whenever the input's value changes."
          ],
          "analysisPoints": [
            "The `useEffect` hook's second argument (dependency array) controls when the effect re-runs.",
            "An empty array `[]` means the effect has no dependencies that will change during the component's lifecycle after the first render.",
            "This behavior precisely matches `componentDidMount` (runs once after mount) and `componentWillUnmount` (cleanup runs once before unmount).",
            "This is crucial for side effects that should only happen once, like initial DOM manipulations or setting up subscriptions."
          ],
          "keyConcepts": [
            "React Hooks",
            "`useEffect`",
            "Dependency Array",
            "Lifecycle Methods",
            "`componentDidMount`",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Correct understanding of `useEffect` dependency array's function.",
            "Ability to relate `useEffect` with `[]` to class component lifecycle.",
            "Understanding its importance for one-time effects."
          ],
          "example": "```jsx\nfunction MyAutoFocusComponent() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // This will run only once after the first render\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Empty array ensures this effect runs only on mount\n\n  return <input ref={inputRef} />;\n}\n```",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Dependency Array",
            "Focus"
          ],
          "prerequisites": [
            "React Hooks Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_focus_input_6",
          "topic": "Re-focusing Input",
          "level": "medium",
          "type": "code",
          "question": "Implement a functional React component that contains an input field. The input should automatically focus when the component mounts. Additionally, add a button that, when clicked, re-focuses the input field.",
          "answer": "```jsx\nimport React, { useRef, useEffect } from 'react';\n\nfunction AutoFocusAndRefocusInput() {\n  const inputRef = useRef(null);\n\n  // Effect to auto-focus on mount\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Empty dependency array ensures this runs only once on mount\n\n  // Handler for the re-focus button\n  const handleRefocusClick = () => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  };\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', margin: '20px auto', maxWidth: '400px', display: 'flex', flexDirection: 'column', gap: '15px' }}>\n      <h2>Auto-Focus & Re-Focus Input</h2>\n      <p>This input will focus automatically on load. Click the button to re-focus it.</p>\n      <input\n        ref={inputRef}\n        type=\"text\"\n        placeholder=\"Type something...\"\n        style={{ padding: '8px', fontSize: '1em' }}\n        aria-label=\"Focused input\"\n      />\n      <button onClick={handleRefocusClick} style={{ padding: '10px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>\n        Re-Focus Input\n      </button>\n    </div>\n  );\n}\n\nexport default AutoFocusAndRefocusInput;\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `useRef` to create a mutable ref object for the input element.",
            "Correct use of `useEffect` with an empty dependency array (`[]`) for initial auto-focus on mount.",
            "Correct implementation of an `onClick` handler on the button to imperatively call `inputRef.current.focus()`.",
            "Ensuring `inputRef.current` is checked for null before calling `.focus()` for robustness.",
            "Clear and functional component structure."
          ],
          "keyConcepts": [
            "React Hooks",
            "`useRef`",
            "`useEffect`",
            "DOM Manipulation",
            "Event Handling",
            "Imperative Programming"
          ],
          "evaluationCriteria": [
            "Ability to combine `useRef` and `useEffect` for DOM interaction.",
            "Competence in handling user events to trigger imperative actions.",
            "Code correctness and clarity."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "useEffect",
            "DOM Manipulation",
            "Code Challenge"
          ],
          "prerequisites": [
            "React Hooks Basics",
            "Event Handling"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rerender_on_resize_1",
          "topic": "Browser Resize Event - Class Components",
          "level": "easy",
          "type": "flashcard",
          "question": "In a React class component, where should you add and remove a `window.resize` event listener to avoid memory leaks?",
          "answer": "Add the listener in `componentDidMount()` and remove it in `componentWillUnmount()`.",
          "analysisPoints": [
            "`componentDidMount` ensures the component is in the DOM and the `window` object is available.",
            "`componentWillUnmount` ensures cleanup happens before the component is destroyed, preventing the listener from holding a reference to a non-existent component."
          ],
          "keyConcepts": [
            "React Lifecycle Methods",
            "`componentDidMount`",
            "`componentWillUnmount`",
            "Event Listeners",
            "Memory Leaks",
            "Cleanup"
          ],
          "evaluationCriteria": [
            "Recall of correct lifecycle methods for subscription management.",
            "Understanding the importance of cleanup."
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Event Listeners",
            "Memory Leaks"
          ],
          "prerequisites": [
            "React Lifecycle"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_rerender_on_resize_2",
          "topic": "Browser Resize Event - Functional Components",
          "level": "medium",
          "type": "mcq",
          "question": "Which `useEffect` setup is correct for listening to the `window.resize` event in a functional React component, ensuring proper cleanup?",
          "answer": "```jsx\nuseEffect(() => {\n  const handleResize = () => { /* ... */ };\n  window.addEventListener('resize', handleResize);\n  return () => window.removeEventListener('resize', handleResize);\n}, []);\n```",
          "options": [
            "```jsx\nuseEffect(() => {\n  window.addEventListener('resize', () => { /* ... */ });\n});\n```",
            "```jsx\nuseEffect(() => {\n  window.addEventListener('resize', () => { /* ... */ });\n});\nreturn () => window.removeEventListener('resize', () => { /* ... */ });\n```",
            "```jsx\nuseEffect(() => {\n  const handleResize = () => { /* ... */ };\n  window.addEventListener('resize', handleResize);\n  return () => window.removeEventListener('resize', handleResize);\n}, []);\n```",
            "```jsx\nuseEffect(() => {\n  window.addEventListener('resize', () => { /* ... */ });\n}, [window.innerWidth]);\n```"
          ],
          "analysisPoints": [
            "The effect function should return a cleanup function.",
            "The cleanup function must remove the *exact same* listener function that was added.",
            "An empty dependency array `[]` ensures the listener is added once on mount and removed once on unmount.",
            "Option A has no cleanup and will re-add listener on every render.",
            "Option B tries to return cleanup outside `useEffect`'s return.",
            "Option D creates a new anonymous function every time `window.innerWidth` changes, and attempts to re-add/remove it, which is inefficient and potentially problematic if `window.innerWidth` changes frequently without proper cleanup of the *previous* listener."
          ],
          "keyConcepts": [
            "React Hooks",
            "`useEffect`",
            "Dependency Array",
            "Cleanup Function",
            "Event Listeners",
            "Memory Leaks"
          ],
          "evaluationCriteria": [
            "Understanding of `useEffect`'s cleanup mechanism.",
            "Ability to correctly manage event listeners with hooks.",
            "Recognition of common pitfalls (no cleanup, incorrect dependency array)."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Event Listeners",
            "Cleanup",
            "Memory Leaks"
          ],
          "prerequisites": [
            "React Hooks Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rerender_on_resize_3",
          "topic": "Debouncing vs. Throttling for Resize Events",
          "level": "hard",
          "type": "open",
          "question": "Why is it important to debounce or throttle the `window.resize` event listener when updating component state in React? Explain the difference between debouncing and throttling and which is generally preferred for resize events.",
          "answer": "It is crucial to debounce or throttle the `window.resize` event listener because the `resize` event can fire **very rapidly and continuously** while a user is resizing the browser window. If an event handler updates component state on every single `resize` event, it can lead to:\n1.  **Excessive Re-renders**: Triggering numerous re-renders of the React component, which can be computationally expensive, especially if the component's render logic is complex or involves many DOM manipulations.\n2.  **Performance Degradation**: Janky animations, slow UI responses, or even browser crashes due to the high frequency of updates and layout recalculations.\n\n**Debouncing:**\n*   **Definition**: Debouncing ensures that a function is executed only *after* a specified period of inactivity (no further calls) has passed. If the function is called again within that period, the timer is reset, and the function is not executed until the new timer expires.\n*   **Analogy**: Waiting for an elevator. It only closes and leaves after no one has pressed the button for a few seconds.\n*   **Preferred for `resize`**: Debouncing is generally preferred for `window.resize` events because you typically only care about the *final* dimensions of the window once the user has finished resizing, not the intermediate dimensions during the resizing process. It reduces the number of state updates to just one after the user has settled on a window size.\n\n**Throttling:**\n*   **Definition**: Throttling limits the rate at which a function can be called. It ensures that a function executes at most once within a specified time window.\n*   **Analogy**: A security guard checking IDs every 5 minutes. No matter how many people try to pass, only one check happens every 5 minutes.\n*   **When to use**: Throttling is useful for events that need to be handled periodically but not excessively, like `scroll` events or rapid button clicks where you want a continuous, but rate-limited, response.",
          "analysisPoints": [
            "Clearly explain the problem: rapid firing of `resize` event leading to performance issues (excessive re-renders).",
            "Define debouncing: execution after inactivity, timer reset on new call.",
            "Define throttling: execution at most once per time window.",
            "Explain *why* debouncing is generally preferred for `resize` (only final state matters).",
            "Provide clear analogies or use cases for each to demonstrate understanding."
          ],
          "keyConcepts": [
            "Debouncing",
            "Throttling",
            "Window Resize Event",
            "Performance Optimization",
            "Event Handling",
            "React Re-renders",
            "User Experience (UX)"
          ],
          "evaluationCriteria": [
            "Deep understanding of performance issues with high-frequency events.",
            "Accurate definitions and distinctions between debouncing and throttling.",
            "Correct reasoning for preferred technique for `resize` events.",
            "Ability to explain the benefits to application performance and UX."
          ],
          "example": "```javascript\n// Debounce example\nconst debouncedResizeHandler = debounce(() => {\n  console.log('Window resized (debounced)');\n}, 300); // Wait 300ms after last resize event\n\nwindow.addEventListener('resize', debouncedResizeHandler);\n\n// Throttle example\nconst throttledScrollHandler = throttle(() => {\n  console.log('Scrolled (throttled)');\n}, 100); // At most once every 100ms\n\nwindow.addEventListener('scroll', throttledScrollHandler);\n```",
          "tags": [
            "JavaScript",
            "Performance",
            "Optimization",
            "Debounce",
            "Throttling",
            "Events"
          ],
          "prerequisites": [
            "JavaScript Event Loop",
            "Performance Concepts"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_rerender_on_resize_4",
          "topic": "Memory Leaks with Event Listeners",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary reason for removing event listeners (like `resize`) when a React component unmounts?",
          "answer": "To prevent memory leaks by ensuring the listener does not hold a reference to the unmounted component.",
          "options": [
            "To improve initial rendering performance.",
            "To allow the browser to automatically re-attach them on next mount.",
            "To prevent memory leaks by ensuring the listener does not hold a reference to the unmounted component.",
            "To avoid conflicts with other components listening to the same event."
          ],
          "analysisPoints": [
            "When a component unmounts, its associated DOM elements and event handlers should no longer be active.",
            "If an event listener is not removed, it might still try to execute its callback function when the event fires.",
            "If the callback references the unmounted component's state or props, it can lead to errors (e.g., 'Can't perform a React state update on an unmounted component').",
            "More importantly, the listener function (and the closure it creates) might prevent the garbage collector from reclaiming the memory used by the unmounted component, leading to a memory leak.",
            "While avoiding conflicts and performance are tangential benefits, the primary reason is memory management."
          ],
          "keyConcepts": [
            "Memory Leaks",
            "Event Listeners",
            "Component Unmount",
            "Garbage Collection",
            "Cleanup",
            "Lifecycle Methods"
          ],
          "evaluationCriteria": [
            "Understanding of memory management in JavaScript/React.",
            "Correct identification of memory leaks as the primary issue.",
            "Knowledge of component lifecycle and its implications for external subscriptions."
          ],
          "example": null,
          "tags": [
            "React",
            "Memory Leaks",
            "Event Listeners",
            "Cleanup",
            "Performance"
          ],
          "prerequisites": [
            "JavaScript Memory Management",
            "React Lifecycle"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rerender_on_resize_5",
          "topic": "Custom Hooks for Window Dimensions",
          "level": "medium",
          "type": "code",
          "question": "Create a custom React Hook `useWindowDimensions` that provides the current `width` and `height` of the browser window. The hook should update these dimensions on window resize and include proper cleanup. Incorporate debouncing into the resize handling.",
          "answer": "```jsx\nimport { useState, useEffect, useCallback } from 'react';\n\n// Helper for debouncing a function\nconst debounce = (func, delay) => {\n  let timeoutId;\n  return (...args) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n};\n\nfunction useWindowDimensions(debounceDelay = 200) {\n  const [dimensions, setDimensions] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight,\n  });\n\n  // Using useCallback to memoize the debounced function, ensuring it's stable across renders\n  const handleResize = useCallback(\n    debounce(() => {\n      setDimensions({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    }, debounceDelay), // Use the passed debounceDelay\n    [debounceDelay] // Recalculate handleResize if debounceDelay changes\n  );\n\n  useEffect(() => {\n    // Add event listener\n    window.addEventListener('resize', handleResize);\n\n    // Initial dimensions in case they changed before first resize event\n    // (though useState already initializes with current innerWidth/Height)\n    // handleResize(); // Can optionally call here to ensure initial value reflects debounced logic\n\n    // Cleanup function: remove event listener when component unmounts\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [handleResize]); // Dependency array: Re-run effect if handleResize function changes (only if debounceDelay changes)\n\n  return dimensions;\n}\n\nexport default useWindowDimensions;\n\n/* Example Usage:\nimport React from 'react';\nimport useWindowDimensions from './useWindowDimensions'; // Assuming the hook is in this file\n\nfunction MyResponsiveComponent() {\n  const { width, height } = useWindowDimensions(300);\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid blue', margin: '20px' }}>\n      <h3>Responsive Box</h3>\n      <p>Window Width: {width}px</p>\n      <p>Window Height: {height}px</p>\n      {width < 768 ? <p>Small Screen Layout</p> : <p>Large Screen Layout</p>}\n    </div>\n  );\n}\n\nexport default MyResponsiveComponent;\n*/\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `useState` to manage `width` and `height`.",
            "Correct use of `useEffect` to add and remove the `resize` event listener.",
            "Proper cleanup function returned by `useEffect` to prevent memory leaks.",
            "Implementation of a `debounce` utility function.",
            "Integration of `debounce` with `useCallback` to ensure the `handleResize` function is stable and doesn't cause `useEffect` to re-run unnecessarily.",
            "The hook accepts a `debounceDelay` parameter for flexibility.",
            "Initial state is set to current window dimensions."
          ],
          "keyConcepts": [
            "React Custom Hooks",
            "`useState`",
            "`useEffect`",
            "`useCallback`",
            "Debouncing",
            "Event Listeners",
            "Performance Optimization",
            "Cleanup"
          ],
          "evaluationCriteria": [
            "Ability to create a functional custom hook.",
            "Proficiency in `useEffect` with cleanup and dependency arrays.",
            "Correct implementation of debouncing logic.",
            "Understanding of `useCallback` for memoizing event handlers.",
            "Code quality, readability, and reusability."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "Performance",
            "Debounce",
            "Code Challenge"
          ],
          "prerequisites": [
            "React Hooks Advanced",
            "JavaScript Closures"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_rerender_on_resize_6",
          "topic": "Window Dimensions Initialization",
          "level": "easy",
          "type": "flashcard",
          "question": "When initializing state for window dimensions in a component that listens to `resize`, what values should you use for the initial `width` and `height`?",
          "answer": "`window.innerWidth` and `window.innerHeight`.",
          "analysisPoints": [
            "These properties provide the current dimensions of the browser window's viewport.",
            "Initializing with them ensures the component displays correct dimensions immediately on mount, before the first `resize` event occurs."
          ],
          "keyConcepts": [
            "Window Object",
            "`innerWidth`",
            "`innerHeight`",
            "React State Initialization",
            "Client-side Dimensions"
          ],
          "evaluationCriteria": [
            "Knowledge of how to get current window dimensions.",
            "Understanding of initial state setup."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "Browser API",
            "React State"
          ],
          "prerequisites": [
            "JavaScript DOM Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_rerender_on_resize_7",
          "topic": "React.Fragment and Re-renders",
          "level": "medium",
          "type": "mcq",
          "question": "You have a component that displays window dimensions. It contains two `<span>` elements wrapped in a `<div>`. If the component re-renders due to a window resize, what parts of the DOM will React update?",
          "answer": "Only the text content of the `<span>` elements will be updated, as their `children` prop (the dimensions) has changed.",
          "options": [
            "The entire `<div>` and its `<span>` children will be re-created in the DOM.",
            "Only the `<div>` element will be updated, but not its children.",
            "Only the text content of the `<span>` elements will be updated, as their `children` prop (the dimensions) has changed.",
            "React will re-mount the entire component, including the `<div>` and `<span>` elements."
          ],
          "analysisPoints": [
            "React's reconciliation algorithm (Diffing) efficiently updates the DOM.",
            "It compares the new virtual DOM tree with the old one.",
            "If only text content changes within an element, React will update only that text node in the actual DOM, not re-create the entire element or its parents.",
            "The `div` element itself is not affected by the change in the children's text content, so it won't be re-created unless its own props or type change.",
            "Re-mounting the entire component happens only if the component's key changes or its type changes."
          ],
          "keyConcepts": [
            "React Reconciliation",
            "Virtual DOM",
            "DOM Updates",
            "Re-rendering",
            "Diffing Algorithm",
            "Performance"
          ],
          "evaluationCriteria": [
            "Understanding of React's reconciliation process.",
            "Knowledge of how React optimizes DOM updates.",
            "Ability to predict specific DOM changes based on component updates."
          ],
          "example": "```jsx\nfunction WindowDimensions({ width, height }) {\n  return (\n    <div>\n      <span>Width: {width}</span>\n      <span>Height: {height}</span>\n    </div>\n  );\n}\n// If width changes from 800 to 801, React will only update the text node '800' to '801'.\n```",
          "tags": [
            "React",
            "Performance",
            "Reconciliation",
            "Virtual DOM",
            "Rendering"
          ],
          "prerequisites": [
            "React Rendering",
            "Virtual DOM"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_complex_registration_form",
          "title": "Build a Multi-Step User Registration Form with Validation and Accessibility",
          "description": "\nImplement a two-step user registration form in React. Each step should have its own set of fields and validation. The form must incorporate best practices discussed in the theory.\n\n**Requirements:**\n\n1.  **Step 1: Personal Information**\n    *   Fields: `Name` (text, required), `Email` (email, required, valid format).\n    *   Client-side validation for both fields.\n    *   A 'Next' button to proceed to Step 2.\n2.  **Step 2: Account Details**\n    *   Fields: `Password` (password, required, min 8 chars), `Confirm Password` (password, required, must match password).\n    *   Client-side validation for both fields.\n    *   'Back' button to return to Step 1 (should preserve Step 1 data).\n    *   'Register' button to submit the form.\n3.  **Controlled Components**: All form inputs must be controlled components.\n4.  **Error Handling**: Display clear, inline validation error messages for each field.\n5.  **Visual Feedback**: Disable navigation buttons and show a 'Submitting...' message on the 'Register' button during a simulated API call (e.g., `setTimeout`).\n6.  **Accessibility (ARIA)**: Use appropriate ARIA attributes for required fields, invalid fields, and error messages.\n7.  **Progress Indicator**: Display a simple progress indicator (e.g., 'Step 1 of 2' / 'Step 2 of 2').\n8.  **Form Reset**: After successful submission, the form should reset to its initial state.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\n\nfunction RegistrationForm() {\n  const [step, setStep] = useState(1); // Current step\n  const [formData, setFormData] = useState({\n    name: '',\n    email: '',\n    password: '',\n    confirmPassword: '',\n  });\n  const [errors, setErrors] = useState({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  const validateStep1 = () => {\n    const newErrors = {};\n    if (!formData.name.trim()) newErrors.name = 'Name is required.';\n    if (!formData.email.trim()) newErrors.email = 'Email is required.';\n    else if (!/^[\\w-]+(\\.[\\w-]+)*@([a-z0-9-]+(\\.[a-z0-9-]+)*?\\.[a-z]{2,6}|(\\d{1,3}\\.){3}\\d{1,3})(:\\d{4})?$/.test(formData.email)) {\n      newErrors.email = 'Invalid email format.';\n    }\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  const validateStep2 = () => {\n    const newErrors = {};\n    if (!formData.password) newErrors.password = 'Password is required.';\n    else if (formData.password.length < 8) newErrors.password = 'Password must be at least 8 characters.';\n    if (formData.password !== formData.confirmPassword) {\n      newErrors.confirmPassword = 'Passwords do not match.';\n    }\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({ ...prev, [name]: value }));\n    // Optional: live validation here\n  };\n\n  const handleNext = () => {\n    if (validateStep1()) {\n      setStep(2);\n      setErrors({}); // Clear errors when moving to next step\n    }\n  };\n\n  const handleBack = () => {\n    setStep(1);\n    setErrors({}); // Clear errors when going back\n  };\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    if (validateStep2()) {\n      setIsSubmitting(true);\n      // Simulate API call\n      try {\n        await new Promise(resolve => setTimeout(resolve, 2000));\n        console.log('Registration Data:', formData);\n        alert('User registered successfully!');\n        // Reset form after successful submission\n        setFormData({ name: '', email: '', password: '', confirmPassword: '' });\n        setErrors({});\n        setStep(1);\n      } catch (error) {\n        console.error('Registration failed:', error);\n        // Set a general error or specific field error\n        setErrors(prev => ({ ...prev, general: 'Registration failed. Please try again.' }));\n      } finally {\n        setIsSubmitting(false);\n      }\n    }\n  };\n\n  return (\n    <div style={{ maxWidth: '500px', margin: '40px auto', padding: '30px', border: '1px solid #ddd', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' }}>\n      <h2>User Registration - Step {step} of 2</h2>\n\n      {step === 1 && (\n        <div>\n          <h3>Personal Information</h3>\n          <div style={{ marginBottom: '15px' }}>\n            <label htmlFor=\"name\">Name:</label>\n            <input\n              type=\"text\"\n              id=\"name\"\n              name=\"name\"\n              value={formData.name}\n              onChange={handleChange}\n              aria-required=\"true\"\n              aria-invalid={!!errors.name}\n              aria-describedby={errors.name ? 'name-error' : undefined}\n              disabled={isSubmitting}\n            />\n            {errors.name && <div id=\"name-error\" style={{ color: 'red', fontSize: '0.8em' }}>{errors.name}</div>}\n          </div>\n          <div style={{ marginBottom: '15px' }}>\n            <label htmlFor=\"email\">Email:</label>\n            <input\n              type=\"email\"\n              id=\"email\"\n              name=\"email\"\n              value={formData.email}\n              onChange={handleChange}\n              aria-required=\"true\"\n              aria-invalid={!!errors.email}\n              aria-describedby={errors.email ? 'email-error' : undefined}\n              disabled={isSubmitting}\n            />\n            {errors.email && <div id=\"email-error\" style={{ color: 'red', fontSize: '0.8em' }}>{errors.email}</div>}\n          </div>\n          <button onClick={handleNext} disabled={isSubmitting} style={{ padding: '10px 20px', backgroundColor: '#28a745', color: 'white', border: 'none', borderRadius: '4px', cursor: isSubmitting ? 'not-allowed' : 'pointer' }}>\n            Next\n          </button>\n        </div>\n      )}\n\n      {step === 2 && (\n        <div>\n          <h3>Account Details</h3>\n          <div style={{ marginBottom: '15px' }}>\n            <label htmlFor=\"password\">Password:</label>\n            <input\n              type=\"password\"\n              id=\"password\"\n              name=\"password\"\n              value={formData.password}\n              onChange={handleChange}\n              aria-required=\"true\"\n              aria-invalid={!!errors.password}\n              aria-describedby={errors.password ? 'password-error' : undefined}\n              disabled={isSubmitting}\n            />\n            {errors.password && <div id=\"password-error\" style={{ color: 'red', fontSize: '0.8em' }}>{errors.password}</div>}\n          </div>\n          <div style={{ marginBottom: '15px' }}>\n            <label htmlFor=\"confirmPassword\">Confirm Password:</label>\n            <input\n              type=\"password\"\n              id=\"confirmPassword\"\n              name=\"confirmPassword\"\n              value={formData.confirmPassword}\n              onChange={handleChange}\n              aria-required=\"true\"\n              aria-invalid={!!errors.confirmPassword}\n              aria-describedby={errors.confirmPassword ? 'confirm-password-error' : undefined}\n              disabled={isSubmitting}\n            />\n            {errors.confirmPassword && <div id=\"confirm-password-error\" style={{ color: 'red', fontSize: '0.8em' }}>{errors.confirmPassword}</div>}\n          </div>\n          <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n            <button onClick={handleBack} disabled={isSubmitting} style={{ padding: '10px 20px', backgroundColor: '#6c757d', color: 'white', border: 'none', borderRadius: '4px', cursor: isSubmitting ? 'not-allowed' : 'pointer' }}>\n              Back\n            </button>\n            <button type=\"submit\" onClick={handleSubmit} disabled={isSubmitting} style={{ padding: '10px 20px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: isSubmitting ? 'not-allowed' : 'pointer' }}>\n              {isSubmitting ? 'Registering...' : 'Register'}\n            </button>\n          </div>\n        </div>\n      )}\n      {errors.general && <div style={{ color: 'red', marginTop: '15px' }}>{errors.general}</div>}\n    </div>\n  );\n}\n\nexport default RegistrationForm;\n",
          "solutionCode": "import React, { useState } from 'react';\n\nfunction RegistrationForm() {\n  const [step, setStep] = useState(1); // Current step\n  const [formData, setFormData] = useState({\n    name: '',\n    email: '',\n    password: '',\n    confirmPassword: '',\n  });\n  const [errors, setErrors] = useState({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  // Validation function for Step 1 fields\n  const validateStep1 = () => {\n    let newErrors = {};\n    if (!formData.name.trim()) {\n      newErrors.name = 'Name is required.';\n    }\n    if (!formData.email.trim()) {\n      newErrors.email = 'Email is required.';\n    } else if (!/^[\\w-]+(\\.[\\w-]+)*@([a-z0-9-]+(\\.[a-z0-9-]+)*?\\.[a-z]{2,6}|(\\d{1,3}\\.){3}\\d{1,3})(:\\d{4})?$/.test(formData.email)) {\n      newErrors.email = 'Invalid email format.';\n    }\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  // Validation function for Step 2 fields\n  const validateStep2 = () => {\n    let newErrors = {};\n    if (!formData.password) {\n      newErrors.password = 'Password is required.';\n    } else if (formData.password.length < 8) {\n      newErrors.password = 'Password must be at least 8 characters long.';\n    }\n    if (formData.password !== formData.confirmPassword) {\n      newErrors.confirmPassword = 'Passwords do not match.';\n    }\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  // Generic change handler for all inputs\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({ ...prev, [name]: value }));\n\n    // Optional: Real-time validation as user types\n    let currentErrors = { ...errors };\n    if (name === 'name') {\n        currentErrors.name = value.trim() ? '' : 'Name is required.';\n    } else if (name === 'email') {\n        currentErrors.email = value.trim() ? (/^[\\w-]+(\\.[\\w-]+)*@([a-z0-9-]+(\\.[a-z0-9-]+)*?\\.[a-z]{2,6}|(\\d{1,3}\\.){3}\\d{1,3})(:\\d{4})?$/.test(value) ? '' : 'Invalid email format.') : 'Email is required.';\n    } else if (name === 'password') {\n        currentErrors.password = value ? (value.length < 8 ? 'Password must be at least 8 characters long.' : '') : 'Password is required.';\n    } else if (name === 'confirmPassword') {\n        currentErrors.confirmPassword = value ? (value !== formData.password ? 'Passwords do not match.' : '') : 'Confirm password is required.';\n    }\n    setErrors(currentErrors);\n  };\n\n  // Handle 'Next' button click\n  const handleNext = () => {\n    if (validateStep1()) {\n      setStep(2);\n      // Clear step-specific errors after successful step transition\n      setErrors(prevErrors => { \n        const { name, email, ...rest } = prevErrors; \n        return rest; \n      });\n    }\n  };\n\n  // Handle 'Back' button click\n  const handleBack = () => {\n    setStep(1);\n    // Clear step-specific errors when going back\n    setErrors(prevErrors => {\n        const { password, confirmPassword, ...rest } = prevErrors;\n        return rest;\n    });\n  };\n\n  // Handle final form submission\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    if (validateStep2()) {\n      setIsSubmitting(true);\n      console.log('Submitting registration data:', formData);\n      // Simulate API call\n      try {\n        await new Promise(resolve => setTimeout(resolve, 2000));\n        alert('User registered successfully!');\n        // Reset form after successful submission\n        setFormData({ name: '', email: '', password: '', confirmPassword: '' });\n        setErrors({});\n        setStep(1);\n      } catch (error) {\n        console.error('Registration failed:', error);\n        setErrors(prev => ({ ...prev, general: 'Registration failed. Please try again.' }));\n      } finally {\n        setIsSubmitting(false);\n      }\n    }\n  };\n\n  return (\n    <div style={{ maxWidth: '500px', margin: '40px auto', padding: '30px', border: '1px solid #ddd', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' }}>\n      <h2>User Registration</h2>\n      <p style={{ textAlign: 'center', marginBottom: '20px', fontWeight: 'bold' }}>Step {step} of 2</p>\n\n      <form onSubmit={e => e.preventDefault()}> {/* Prevent default form submission on parent form */}\n        {step === 1 && (\n          <div>\n            <h3>Personal Information</h3>\n            <div style={{ marginBottom: '15px' }}>\n              <label htmlFor=\"name\">Name:</label>\n              <input\n                type=\"text\"\n                id=\"name\"\n                name=\"name\"\n                value={formData.name}\n                onChange={handleChange}\n                aria-required=\"true\"\n                aria-invalid={!!errors.name}\n                aria-describedby={errors.name ? 'name-error' : undefined}\n                disabled={isSubmitting}\n                style={{ width: '100%', padding: '8px', boxSizing: 'border-box', marginTop: '5px' }}\n              />\n              {errors.name && <div id=\"name-error\" role=\"alert\" style={{ color: 'red', fontSize: '0.8em' }}>{errors.name}</div>}\n            </div>\n            <div style={{ marginBottom: '15px' }}>\n              <label htmlFor=\"email\">Email:</label>\n              <input\n                type=\"email\"\n                id=\"email\"\n                name=\"email\"\n                value={formData.email}\n                onChange={handleChange}\n                aria-required=\"true\"\n                aria-invalid={!!errors.email}\n                aria-describedby={errors.email ? 'email-error' : undefined}\n                disabled={isSubmitting}\n                style={{ width: '100%', padding: '8px', boxSizing: 'border-box', marginTop: '5px' }}\n              />\n              {errors.email && <div id=\"email-error\" role=\"alert\" style={{ color: 'red', fontSize: '0.8em' }}>{errors.email}</div>}\n            </div>\n            <button onClick={handleNext} disabled={isSubmitting} style={{ padding: '10px 20px', backgroundColor: '#28a745', color: 'white', border: 'none', borderRadius: '4px', cursor: isSubmitting ? 'not-allowed' : 'pointer' }}>\n              Next\n            </button>\n          </div>\n        )}\n\n        {step === 2 && (\n          <div>\n            <h3>Account Details</h3>\n            <div style={{ marginBottom: '15px' }}>\n              <label htmlFor=\"password\">Password:</label>\n              <input\n                type=\"password\"\n                id=\"password\"\n                name=\"password\"\n                value={formData.password}\n                onChange={handleChange}\n                aria-required=\"true\"\n                aria-invalid={!!errors.password}\n                aria-describedby={errors.password ? 'password-error' : undefined}\n                disabled={isSubmitting}\n                style={{ width: '100%', padding: '8px', boxSizing: 'border-box', marginTop: '5px' }}\n              />\n              {errors.password && <div id=\"password-error\" role=\"alert\" style={{ color: 'red', fontSize: '0.8em' }}>{errors.password}</div>}\n            </div>\n            <div style={{ marginBottom: '15px' }}>\n              <label htmlFor=\"confirmPassword\">Confirm Password:</label>\n              <input\n                type=\"password\"\n                id=\"confirmPassword\"\n                name=\"confirmPassword\"\n                value={formData.confirmPassword}\n                onChange={handleChange}\n                aria-required=\"true\"\n                aria-invalid={!!errors.confirmPassword}\n                aria-describedby={errors.confirmPassword ? 'confirm-password-error' : undefined}\n                disabled={isSubmitting}\n                style={{ width: '100%', padding: '8px', boxSizing: 'border-box', marginTop: '5px' }}\n              />\n              {errors.confirmPassword && <div id=\"confirm-password-error\" role=\"alert\" style={{ color: 'red', fontSize: '0.8em' }}>{errors.confirmPassword}</div>}\n            </div>\n            <div style={{ display: 'flex', justifyContent: 'space-between', marginTop: '20px' }}>\n              <button onClick={handleBack} disabled={isSubmitting} style={{ padding: '10px 20px', backgroundColor: '#6c757d', color: 'white', border: 'none', borderRadius: '4px', cursor: isSubmitting ? 'not-allowed' : 'pointer' }}>\n                Back\n              </button>\n              <button type=\"button\" onClick={handleSubmit} disabled={isSubmitting} style={{ padding: '10px 20px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: isSubmitting ? 'not-allowed' : 'pointer' }}>\n                {isSubmitting ? 'Registering...' : 'Register'}\n              </button>\n            </div>\n          </div>\n        )}\n      </form>\n      {errors.general && <div role=\"alert\" aria-live=\"assertive\" style={{ color: 'red', marginTop: '15px' }}>{errors.general}</div>}\n    </div>\n  );\n}\n\nexport default RegistrationForm;\n",
          "testCases": [
            "**Initial Load**: Form should display Step 1 with empty fields.",
            "**Step 1 Validation**: Clicking 'Next' with empty 'Name' or invalid 'Email' should show inline errors. 'Next' button should be disabled.",
            "**Successful Step 1**: Entering valid data for Step 1 and clicking 'Next' should transition to Step 2, clearing Step 1 errors.",
            "**Step 2 Validation**: Clicking 'Register' with empty 'Password' or 'Confirm Password' or mismatching passwords should show inline errors. 'Register' button should be disabled.",
            "**Back Button**: Clicking 'Back' from Step 2 should return to Step 1, preserving entered data in Step 1 fields and clearing Step 2 errors.",
            "**Submission Process**: Clicking 'Register' with valid Step 2 data should disable both 'Back' and 'Register' buttons, show 'Registering...' on the button, simulate a 2-second delay, and then show a success alert.",
            "**Form Reset**: After successful submission, the form should reset to Step 1, all fields cleared.",
            "**Accessibility**: Verify ARIA attributes are correctly applied to inputs and error messages (check dev tools accessibility tree).",
            "**Edge Case - Invalid Email on Change**: Typing an invalid email should show an error dynamically.",
            "**Edge Case - Password Mismatch on Change**: Typing a password and a mismatching confirm password should show an error dynamically (if real-time validation is implemented).",
            "**Visual Feedback**: Ensure buttons are disabled during submission and button text changes correctly."
          ],
          "hints": [
            "Manage form data and errors using a single `useState` object for `formData` and another for `errors`.",
            "Use conditional rendering (`{step === 1 && ...}`) to display different steps.",
            "Ensure `event.preventDefault()` is called for form submission and navigation handlers to prevent page reload.",
            "For ARIA, remember to link error messages to their respective inputs using `aria-describedby` and give the error `role='alert'` and `aria-live='assertive'` if they appear dynamically.",
            "Consider placing validation logic in separate helper functions for reusability and clarity."
          ],
          "tags": [
            "Forms",
            "React",
            "Validation",
            "Multi-step",
            "Controlled Components",
            "Accessibility",
            "UX"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React State Management",
            "Event Handling",
            "Conditional Rendering",
            "JavaScript Async/Await"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Client-side validation",
            "Server-side validation (simulated)",
            "Controlled components",
            "ARIA attributes",
            "Visual feedback",
            "Multi-step forms UX"
          ]
        },
        {
          "id": "task_autofocus_search_component",
          "title": "Build an Auto-Focusing Search Input Component with Refocus Button",
          "description": "\nCreate a functional React component that implements an auto-focusing search input field and a button to manually re-focus it. This task demonstrates proper use of `useRef` and `useEffect` for imperative DOM interactions.\n\n**Requirements:**\n\n1.  **Auto-Focus on Mount**: The search input field should automatically receive focus when the `SearchInputComponent` mounts for the first time.\n2.  **Manual Re-Focus**: Add a button labeled 'Re-focus Search' that, when clicked, sets the focus back to the search input field.\n3.  **Controlled Input (Optional but Recommended)**: The search input should be a controlled component, managing its value via React state.\n4.  **Accessibility**: Ensure the input has an appropriate `aria-label` or is associated with a `<label>` element.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useRef, useEffect, useState } from 'react';\n\nfunction SearchInputComponent() {\n  const inputRef = useRef(null);\n  const [searchText, setSearchText] = useState('');\n\n  // TODO: Implement auto-focus on mount\n\n  // TODO: Implement refocus handler for button\n\n  const handleChange = (e) => {\n    setSearchText(e.target.value);\n  };\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', margin: '20px auto', maxWidth: '400px', display: 'flex', flexDirection: 'column', gap: '15px' }}>\n      <h2>Search Bar</h2>\n      <label htmlFor=\"search-input\" style={{ fontWeight: 'bold' }}>Search Query:</label>\n      <input\n        id=\"search-input\"\n        type=\"text\"\n        value={searchText}\n        onChange={handleChange}\n        placeholder=\"Enter your search term...\"\n        style={{ padding: '8px', fontSize: '1em' }}\n        aria-label=\"Search input field\"\n      />\n      <p>Current Search: {searchText}</p>\n      <button /* TODO: Add onClick for refocus */ style={{ padding: '10px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>\n        Re-focus Search\n      </button>\n    </div>\n  );\n}\n\nexport default SearchInputComponent;\n",
          "solutionCode": "import React, { useRef, useEffect, useState } from 'react';\n\nfunction SearchInputComponent() {\n  const inputRef = useRef(null);\n  const [searchText, setSearchText] = useState('');\n\n  // 1. Auto-focus on mount using useEffect with an empty dependency array\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // The empty array ensures this effect runs only once after the initial render\n\n  // 2. Handler for the refocus button\n  const handleRefocusClick = () => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  };\n\n  const handleChange = (e) => {\n    setSearchText(e.target.value);\n  };\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', margin: '20px auto', maxWidth: '400px', display: 'flex', flexDirection: 'column', gap: '15px' }}>\n      <h2>Search Bar</h2>\n      <label htmlFor=\"search-input\" style={{ fontWeight: 'bold' }}>Search Query:</label>\n      <input\n        id=\"search-input\"\n        ref={inputRef} // Attach the ref to the input element\n        type=\"text\"\n        value={searchText}\n        onChange={handleChange}\n        placeholder=\"Enter your search term...\"\n        style={{ padding: '8px', fontSize: '1em' }}\n        aria-label=\"Search input field\"\n      />\n      <p>Current Search: {searchText}</p>\n      <button onClick={handleRefocusClick} style={{ padding: '10px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>\n        Re-focus Search\n      </button>\n    </div>\n  );\n}\n\nexport default SearchInputComponent;\n",
          "testCases": [
            "**Initial Render**: The search input field should automatically receive keyboard focus as soon as the component is rendered.",
            "**Typing Input**: Verify that typing in the input updates the `Current Search` display (if controlled component is implemented).",
            "**Re-focus Button**: Click the 'Re-focus Search' button. If focus is currently on another element or lost, it should return to the search input.",
            "**Multiple Renders**: Ensure auto-focus only happens on the *initial* mount, not on subsequent re-renders (e.g., when `searchText` changes).",
            "**Accessibility**: Verify the `aria-label` or `<label>` correctly associates with the input (check browser's accessibility tree)."
          ],
          "hints": [
            "Use `useRef` to create a reference to the DOM input element.",
            "Place the `focus()` call inside `useEffect`.",
            "Remember to pass an empty dependency array (`[]`) to `useEffect` to ensure the auto-focus only happens once on mount.",
            "Attach the `ref` object returned by `useRef` to the `ref` prop of your `<input>` element.",
            "Ensure `inputRef.current` is not null before attempting to call `.focus()` on it."
          ],
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "useEffect",
            "DOM Manipulation",
            "UX",
            "Accessibility"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Hooks Basics",
            "JavaScript DOM Basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Refs in React",
            "Imperative programming",
            "Functional components",
            "Lifecycle of functional components"
          ]
        },
        {
          "id": "task_responsive_header",
          "title": "Implement a Responsive Header with Dynamic Layout based on Window Size",
          "description": "\nCreate a React functional component for a header that changes its layout based on the window's width. Specifically, it should display a full navigation menu on large screens and collapse into a hamburger menu icon on small screens. You must implement a custom hook `useWindowSize` (or similar) to track window dimensions.\n\n**Requirements:**\n\n1.  **Custom Hook**: Create a `useWindowSize` custom hook that returns the current `width` and `height` of the browser window. This hook must:\n    *   Listen to the `window.resize` event.\n    *   Initialize with current window dimensions.\n    *   Include proper cleanup to remove the event listener when the component (or hook consumer) unmounts.\n    *   **Implement debouncing** for the resize event handler to optimize performance (e.g., 200ms debounce delay).\n2.  **Header Component (`ResponsiveHeader`)**:\n    *   Use the `useWindowSize` hook to get current dimensions.\n    *   **Conditional Rendering**: If the `width` is greater than or equal to a breakpoint (e.g., 768px), display a `LargeScreenNav` component. Otherwise, display a `HamburgerMenu` component.\n    *   The `HamburgerMenu` should toggle its visibility on click.\n\n**Component Structure:**\n\n```\n├── App.js (renders ResponsiveHeader)\n├── hooks\n│   └── useWindowSize.js\n└── components\n    ├── ResponsiveHeader.js\n    ├── LargeScreenNav.js\n    └── HamburgerMenu.js\n```\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useEffect, useCallback } from 'react';\n\n// --- hooks/useWindowSize.js --- START\nconst debounce = (func, delay) => {\n  let timeoutId;\n  return (...args) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n};\n\nfunction useWindowSize(debounceDelay = 200) {\n  const [dimensions, setDimensions] = useState({\n    width: typeof window !== 'undefined' ? window.innerWidth : 0,\n    height: typeof window !== 'undefined' ? window.innerHeight : 0,\n  });\n\n  const handleResize = useCallback(\n    debounce(() => {\n      setDimensions({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    }, debounceDelay),\n    [debounceDelay]\n  );\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return; // Handle SSR\n    window.addEventListener('resize', handleResize);\n    // Call once initially if not already set by useState initial value\n    // handleResize(); // Uncomment if you want debounced initial call, but useState is fine for current value\n\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [handleResize]);\n\n  return dimensions;\n}\n// --- hooks/useWindowSize.js --- END\n\n// --- components/LargeScreenNav.js --- START\nfunction LargeScreenNav() {\n  return (\n    <nav style={{ display: 'flex', gap: '20px' }}>\n      <a href=\"#home\">Home</a>\n      <a href=\"#about\">About</a>\n      <a href=\"#services\">Services</a>\n      <a href=\"#contact\">Contact</a>\n    </nav>\n  );\n}\n// --- components/LargeScreenNav.js --- END\n\n// --- components/HamburgerMenu.js --- START\nfunction HamburgerMenu() {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const toggleMenu = () => {\n    setIsOpen(!isOpen);\n  };\n\n  return (\n    <div style={{ position: 'relative' }}>\n      <button onClick={toggleMenu} style={{ background: 'none', border: 'none', fontSize: '24px', cursor: 'pointer' }}>\n        ☰\n      </button>\n      {isOpen && (\n        <nav style={{\n          position: 'absolute', right: '0', top: '40px', background: '#f0f0f0', border: '1px solid #ccc', padding: '10px',\n          display: 'flex', flexDirection: 'column', gap: '10px', minWidth: '150px', zIndex: 100\n        }}>\n          <a href=\"#home\">Home</a>\n          <a href=\"#about\">About</a>\n          <a href=\"#services\">Services</a>\n          <a href=\"#contact\">Contact</a>\n        </nav>\n      )}\n    </div>\n  );\n}\n// --- components/HamburgerMenu.js --- END\n\n// --- components/ResponsiveHeader.js --- START\nfunction ResponsiveHeader() {\n  const { width } = useWindowSize();\n  const breakpoint = 768; // Define your breakpoint\n\n  return (\n    <header style={{\n      display: 'flex', justifyContent: 'space-between', alignItems: 'center',\n      padding: '15px 20px', background: '#333', color: 'white'\n    }}>\n      <h1>MyBrand</h1>\n      {/* TODO: Conditional rendering based on width */}\n      {/* Example: width >= breakpoint ? <LargeScreenNav /> : <HamburgerMenu /> */}\n    </header>\n  );\n}\n// --- components/ResponsiveHeader.js --- END\n\n// --- App.js --- START\nexport default function App() {\n  return (\n    <div>\n      <ResponsiveHeader />\n      <main style={{ padding: '20px' }}>\n        <p>Resize your browser window to see the header adapt!</p>\n      </main>\n    </div>\n  );\n}\n// --- App.js --- END\n",
          "solutionCode": "import React, { useState, useEffect, useCallback } from 'react';\n\n// --- hooks/useWindowSize.js --- START\nconst debounce = (func, delay) => {\n  let timeoutId;\n  return (...args) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n};\n\nfunction useWindowSize(debounceDelay = 200) {\n  const [dimensions, setDimensions] = useState({\n    width: typeof window !== 'undefined' ? window.innerWidth : 0,\n    height: typeof window !== 'undefined' ? window.innerHeight : 0,\n  });\n\n  const handleResize = useCallback(\n    debounce(() => {\n      setDimensions({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    }, debounceDelay),\n    [debounceDelay] // `handleResize` function itself will only change if `debounceDelay` changes\n  );\n\n  useEffect(() => {\n    // Guard against SSR environments where `window` might not be defined\n    if (typeof window === 'undefined') return;\n\n    // Add event listener\n    window.addEventListener('resize', handleResize);\n\n    // Cleanup function: remove event listener when component unmounts\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [handleResize]); // Effect re-runs only if `handleResize` changes (i.e., `debounceDelay` changes)\n\n  return dimensions;\n}\n// --- hooks/useWindowSize.js --- END\n\n// --- components/LargeScreenNav.js --- START\nfunction LargeScreenNav() {\n  return (\n    <nav style={{ display: 'flex', gap: '20px' }}>\n      <a href=\"#home\" style={{ color: 'white', textDecoration: 'none' }}>Home</a>\n      <a href=\"#about\" style={{ color: 'white', textDecoration: 'none' }}>About</a>\n      <a href=\"#services\" style={{ color: 'white', textDecoration: 'none' }}>Services</a>\n      <a href=\"#contact\" style={{ color: 'white', textDecoration: 'none' }}>Contact</a>\n    </nav>\n  );\n}\n// --- components/LargeScreenNav.js --- END\n\n// --- components/HamburgerMenu.js --- START\nfunction HamburgerMenu() {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const toggleMenu = () => {\n    setIsOpen(!isOpen);\n  };\n\n  return (\n    <div style={{ position: 'relative' }}>\n      <button onClick={toggleMenu} style={{ background: 'none', border: 'none', fontSize: '24px', cursor: 'pointer', color: 'white' }} aria-expanded={isOpen} aria-controls=\"mobile-menu\" aria-label=\"Toggle navigation\">\n        ☰\n      </button>\n      {isOpen && (\n        <nav id=\"mobile-menu\" style={{\n          position: 'absolute', right: '0', top: '40px', background: '#444', border: '1px solid #555', padding: '10px',\n          display: 'flex', flexDirection: 'column', gap: '10px', minWidth: '150px', zIndex: 100, borderRadius: '4px'\n        }}>\n          <a href=\"#home\" style={{ color: 'white', textDecoration: 'none' }} onClick={() => setIsOpen(false)}>Home</a>\n          <a href=\"#about\" style={{ color: 'white', textDecoration: 'none' }} onClick={() => setIsOpen(false)}>About</a>\n          <a href=\"#services\" style={{ color: 'white', textDecoration: 'none' }} onClick={() => setIsOpen(false)}>Services</a>\n          <a href=\"#contact\" style={{ color: 'white', textDecoration: 'none' }} onClick={() => setIsOpen(false)}>Contact</a>\n        </nav>\n      )}\n    </div>\n  );\n}\n// --- components/HamburgerMenu.js --- END\n\n// --- components/ResponsiveHeader.js --- START\nfunction ResponsiveHeader() {\n  const { width } = useWindowSize();\n  const breakpoint = 768; // Example breakpoint in pixels\n\n  return (\n    <header style={{\n      display: 'flex', justifyContent: 'space-between', alignItems: 'center',\n      padding: '15px 20px', background: '#333', color: 'white'\n    }}>\n      <h1 style={{ margin: 0, fontSize: '1.5em' }}>MyBrand</h1>\n      {width >= breakpoint ? <LargeScreenNav /> : <HamburgerMenu />}\n    </header>\n  );\n}\n// --- components/ResponsiveHeader.js --- END\n\n// --- App.js --- START\nexport default function App() {\n  return (\n    <div style={{ fontFamily: 'Arial, sans-serif' }}>\n      <ResponsiveHeader />\n      <main style={{ padding: '20px' }}>\n        <h2>Welcome!</h2>\n        <p>Resize your browser window to see the header navigation change.</p>\n        <p>Below {768}px, the full navigation will be replaced by a hamburger menu icon.</p>\n        <p>Current window width (from hook): {useWindowSize().width}px</p>\n        <div style={{ height: '1000px', background: '#f5f5f5', marginTop: '20px', padding: '20px' }}>\n          Scrollable content to fill space\n        </div>\n      </main>\n    </div>\n  );\n}\n// --- App.js --- END\n",
          "testCases": [
            "**Initial Render**: The header should display the `LargeScreenNav` if the initial window width is >= 768px, or `HamburgerMenu` if < 768px.",
            "**Resize Larger**: Drag the browser window to be larger than 768px. The header should smoothly transition to show the `LargeScreenNav`.",
            "**Resize Smaller**: Drag the browser window to be smaller than 768px. The header should smoothly transition to show the `HamburgerMenu` icon.",
            "**Hamburger Menu Toggle**: When the `HamburgerMenu` is visible, clicking the '☰' icon should toggle the menu's visibility (open/close). Ensure menu items close the menu when clicked.",
            "**Debounce Functionality**: Rapidly resize the window. Observe that the `useWindowSize` hook's returned dimensions only update *after* a brief pause in resizing, not on every pixel change (indicating debouncing is working).",
            "**Component Unmount (Mental Check)**: If `ResponsiveHeader` were to be unmounted (e.g., navigating to another page in an SPA), the `useWindowSize` hook should correctly remove its event listener, preventing memory leaks.",
            "**Accessibility**: Ensure the hamburger menu button has appropriate ARIA attributes (`aria-expanded`, `aria-controls`, `aria-label`)."
          ],
          "hints": [
            "The `debounce` utility function from the theory block is very useful here. Make sure it's stable and memoized for `useCallback`'s dependency.",
            "The `useWindowSize` hook will combine `useState` for dimensions and `useEffect` with cleanup for the event listener.",
            "For the `useEffect` in `useWindowSize`, remember that the `handleResize` function itself should be stable (memoized with `useCallback`) to avoid unnecessarily re-attaching the event listener.",
            "Use conditional rendering `width >= breakpoint ? <ComponentA /> : <ComponentB />` in the `ResponsiveHeader`.",
            "For the `HamburgerMenu`, you'll need local state (`useState`) to manage its open/closed state."
          ],
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "Responsive Design",
            "Performance",
            "Debounce",
            "Conditional Rendering",
            "UI/UX"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React Hooks Advanced",
            "JavaScript Event Handling",
            "Debounce/Throttling Concepts"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Custom hooks",
            "Window resize event",
            "Performance optimization",
            "Conditional rendering",
            "Component lifecycle (hooks equivalent)",
            "Mobile-first design"
          ]
        }
      ]
    }
  }
]