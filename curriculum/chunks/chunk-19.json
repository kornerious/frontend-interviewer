[
  {
    "id": "e51c3a6f-4f35-470b-b485-1fd99e46d080",
    "startLine": 3700,
    "endLine": 3799,
    "processedDate": "2025-06-17T08:52:09.094Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_event_handling_basics",
          "title": "React Event Handling Fundamentals",
          "content": "React implements a synthetic event system that wraps browser's native events, providing a consistent cross-browser interface. While similar to traditional HTML DOM event handling, React introduces several key differences:\n\n### 1. Event Naming Convention (camelCase)\nUnlike HTML, where event names are typically lowercase (e.g., `onclick`), React uses camelCase for event names (e.g., `onClick`). This convention applies to all event types.\n\n### 2. Passing Functions as Event Handlers\nIn HTML, event handlers are often defined as strings containing JavaScript code that gets executed. In React, you pass a direct reference to a JavaScript function as the event handler. This allows for cleaner separation of concerns and easier maintenance.\n\n### 3. Explicit `preventDefault()`\nTo prevent the default browser behavior (like form submission or navigating away from a link), you must explicitly call `event.preventDefault()` within your event handler function. In traditional HTML, returning `false` from an event handler could sometimes prevent default behavior, but this is not the case in React's synthetic event system.\n\nReact's synthetic events are pooled. This means the synthetic event object will be reused, and its properties will be nullified after the event callback has been invoked. If you need to access the event object asynchronously, you should call `event.persist()` on the event, or read the properties you need before the event callback returns.",
          "examples": [
            {
              "id": "example_react_event_handling_basics_1",
              "title": "HTML vs. React Event Naming and Handler Passing",
              "code": "```html\n<!-- In HTML -->\n<button onclick=\"activateAccount()\">\n  Activate Account\n</button>\n<a href=\"#\" onclick=\"console.log('Clicked'); return false;\">\n  Click me\n</a>\n```\n\n```jsx\n// In React\nfunction activateAccount() {\n  console.log('Account activated!');\n}\n\nfunction preventNavigation(e) {\n  e.preventDefault(); // Explicitly prevent default\n  console.log('Navigation prevented, but clicked!');\n}\n\nfunction MyComponent() {\n  return (\n    <>\n      <button onClick={activateAccount}>\n        Activate Account\n      </button>\n      <a href=\"#\" onClick={preventNavigation}>\n        Click me (Prevent Default)\n      </a>\n    </>\n  );\n}\n```",
              "explanation": "This example clearly illustrates the differences. In HTML, `onclick` is lowercase and accepts a string. In React, `onClick` is camelCase and accepts a function reference. Additionally, the `preventDefault()` method is explicitly called on the synthetic event object `e` to stop the default browser behavior of navigating to '#'.",
              "language": "jsx"
            },
            {
              "id": "example_react_event_handling_basics_2",
              "title": "Complete Event Handling Example in React",
              "code": "```jsx\nfunction ButtonComponent() {\n  const handleClick = (e) => {\n    // console.log('Event target:', e.target);\n    // console.log('Event type:', e.type);\n    e.preventDefault(); // Prevents default behavior (e.g., form submission if this was a submit button)\n    console.log('Button was clicked and default prevented');\n  };\n\n  return (\n    <button onClick={handleClick}>\n      Click me\n    </button>\n  );\n}\n\n// Usage example:\n// ReactDOM.render(<ButtonComponent />, document.getElementById('root'));\n```",
              "explanation": "This example shows a functional React component demonstrating a basic click handler. The `handleClick` function receives the synthetic event object `e`. Inside this handler, `e.preventDefault()` is called to explicitly prevent any default browser action associated with the button (though for a simple button, it's less critical unless it's a submit button within a form). `console.log` is used to confirm the event has fired.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_react_events_syntax_mcq",
            "question_prevent_default_code",
            "question_html_react_event_diff_flashcard",
            "question_event_pooling_open"
          ],
          "relatedTasks": [
            "task_button_link_events"
          ],
          "tags": [
            "React",
            "Events",
            "Event Handling",
            "Synthetic Events",
            "DOM"
          ],
          "technology": "React",
          "prerequisites": [
            "html_basics",
            "javascript_functions",
            "dom_events"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_forms",
            "react_interactions"
          ]
        },
        {
          "id": "theory_pointer_events",
          "title": "React Pointer Events",
          "content": "React supports Pointer Events, which offer a unified and abstract way to handle various input types, including mouse, touch, and pen interactions, through a single set of event handlers. This API simplifies developing applications that need to support diverse input methods without writing separate logic for each. Pointer Events provide a `pointerId` property to track individual pointers, and properties like `clientX`, `clientY` for coordinates, similar to mouse events.\n\nKey Pointer Event types include:\n- `onPointerDown`: Triggered when a pointer comes into contact with the surface.\n- `onPointerMove`: Triggered when a pointer changes coordinates.\n- `onPointerUp`: Triggered when a pointer is lifted from the surface.\n- `onPointerCancel`: Triggered when a pointer event is canceled by the browser (e.g., due to a browser gesture).\n- `onGotPointerCapture`: Triggered when an element receives pointer capture.\n- `onLostPointerCapture`: Triggered when an element loses pointer capture.\n- `onPointerEnter`: Triggered when a pointer enters an element's hit test boundaries.\n- `onPointerLeave`: Triggered when a pointer leaves an element's hit test boundaries.\n- `onPointerOver`: Triggered when a pointer is moved into the hit test boundaries of an element or one of its descendants.\n- `onPointerOut`: Triggered when a pointer is moved out of the hit test boundaries of an element or one of its descendants.\n\nPointer Events are particularly useful for creating interactive elements like draggable components, drawing applications, or any UI element requiring precise input tracking across different devices.",
          "examples": [
            {
              "id": "example_pointer_events_1",
              "title": "Basic Pointer Event Handlers",
              "code": "```jsx\nfunction PointerEventsDemo() {\n  return (\n    <div\n      style={{\n        width: '300px',\n        height: '200px',\n        border: '2px solid blue',\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        cursor: 'pointer'\n      }}\n      onPointerDown={(e) => console.log('Pointer down, ID:', e.pointerId)}\n      onPointerMove={(e) => console.log('Pointer move, X:', e.clientX, 'Y:', e.clientY)}\n      onPointerUp={(e) => console.log('Pointer up')}\n      onPointerCancel={(e) => console.log('Pointer cancel')}\n      onGotPointerCapture={(e) => console.log('Got pointer capture, ID:', e.pointerId)}\n      onLostPointerCapture={(e) => console.log('Lost pointer capture, ID:', e.pointerId)}\n      onPointerEnter={(e) => console.log('Pointer enter')}\n      onPointerLeave={(e) => console.log('Pointer leave')}\n      onPointerOver={(e) => console.log('Pointer over')}\n      onPointerOut={(e) => console.log('Pointer out')}\n    >\n      Pointer Events Demo Area\n    </div>\n  );\n}\n\n// Usage example:\n// ReactDOM.render(<PointerEventsDemo />, document.getElementById('root'));\n```",
              "explanation": "This example demonstrates how to attach various Pointer Event handlers to a `div` element. When interacting with this area using a mouse, touch, or pen, the respective console logs will show the event type and relevant properties like `pointerId` and coordinates (`clientX`, `clientY`). This allows for a unified approach to input handling.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_pointer_events_purpose_mcq",
            "question_pointer_events_use_cases_open",
            "question_pointer_events_types_flashcard",
            "question_mouse_vs_pointer_open"
          ],
          "relatedTasks": [
            "task_draggable_element_pointer_events"
          ],
          "tags": [
            "React",
            "Events",
            "Pointer Events",
            "Input Handling",
            "Cross-Browser"
          ],
          "technology": "React",
          "prerequisites": [
            "react_event_handling_basics",
            "dom_events"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "interactive_uis",
            "touch_interfaces"
          ]
        },
        {
          "id": "theory_react_state_management_class_components",
          "title": "React State Management in Class Components",
          "content": "In React class components, `state` is a plain JavaScript object that holds data relevant to a component that can change over time. When the `state` object changes, the component re-renders. `state` is managed within the component itself and is typically initialized in the constructor or as a class property (using the class fields syntax).\n\n### Initializing State\nState can be initialized as a class property directly, as shown in the example, or within the `constructor` method of the class component:\n\n```jsx\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 }; // Initialize state in constructor\n  }\n  // ...\n}\n// OR using class fields syntax (requires Babel preset-env with class properties):\nclass MyComponent extends React.Component {\n  state = { count: 0 }; // Initialize state as a class property\n  // ...\n}\n```\n\n### Updating State (`this.setState()`)\nTo update the state, you must use the `this.setState()` method. This method merges the new state into the current state and triggers a re-render of the component and its children. `setState` is asynchronous; React may batch multiple `setState` calls for performance. For updates that depend on the previous state, it's recommended to pass a function to `setState` to ensure you're working with the most up-to-date state value.\n\n```jsx\n// Updating state with an object (for independent values)\nthis.setState({ visible: true });\n\n// Updating state with a function (when new state depends on previous state)\nthis.setState((prevState) => ({\n  count: prevState.count + 1\n}));\n```\n\nIt's important to remember that `state` should not be modified directly (e.g., `this.state.visible = true;`). Always use `this.setState()` to ensure React's re-rendering mechanism works correctly.",
          "examples": [
            {
              "id": "example_react_state_class_component_1",
              "title": "Basic State Management in a Class Component",
              "code": "```jsx\nimport React from 'react';\n\nclass Article extends React.Component {\n  // Initialize state using class fields syntax\n  state = {\n    visible: false,\n    readCount: 0\n  };\n\n  // Event handler to update state\n  handleReadMoreClick = (e) => {\n    e.preventDefault(); // Prevent default link behavior\n    // Using setState to merge the new state with the existing state\n    this.setState({\n      visible: true,\n      readCount: this.state.readCount + 1 // Directly using this.state for simple updates\n    });\n    console.log('Article visibility updated to:', true);\n  };\n\n  render() {\n    const { visible, readCount } = this.state;\n    return (\n      <div>\n        <h2>My Awesome Article</h2>\n        <p>This is a short introduction...</p>\n        {!visible && (\n          <a href=\"#\" onClick={this.handleReadMoreClick}>\n            Read More\n          </a>\n        )}\n        {visible && (\n          <p>This is the full article content that becomes visible after clicking 'Read More'.</p>\n        )}\n        <p>Times read: {readCount}</p>\n      </div>\n    );\n  }\n}\n\n// Usage example:\n// ReactDOM.render(<Article />, document.getElementById('root'));\n```",
              "explanation": "This example demonstrates a `Article` class component managing its `visible` and `readCount` state. The `state` is initialized directly as a class property. The `handleReadMoreClick` method updates `visible` to `true` and increments `readCount` using `this.setState()`. When `visible` changes, the component re-renders to show the full article content. The `e.preventDefault()` ensures the link doesn't navigate.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_setstate_purpose_mcq",
            "question_direct_state_mutation_flashcard",
            "question_setstate_async_open",
            "question_class_state_toggle_code"
          ],
          "relatedTasks": [
            "task_toggle_visibility_component"
          ],
          "tags": [
            "React",
            "State",
            "Class Components",
            "setState",
            "Component Lifecycle"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_classes",
            "react_components"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_flow",
            "component_interaction"
          ]
        },
        {
          "id": "theory_lifting_state_up",
          "title": "Lifting State Up",
          "content": "In React, when multiple sibling components need to share or communicate data, or when a child component needs to communicate with a parent's sibling, the recommended approach is to 'lift the state up' to their closest common ancestor. This pattern ensures that the 'single source of truth' for that shared state resides in one place, making data flow predictable and debugging easier.\n\n### How it Works:\n1.  **Identify Shared State:** Determine which piece of state is needed by multiple components.\n2.  **Move State to Common Ancestor:** Move this shared state from a child component to its closest common parent component.\n3.  **Pass Data Down via Props:** The parent component then passes the state down to its children (or grandchildren) as props.\n4.  **Pass Callbacks Down via Props:** If a child needs to update this shared state, the parent passes down a callback function (also via props) that the child can call to request state changes. The parent's state update function then modifies the state, causing a re-render and updated props for all relevant children.\n\nThis pattern aligns with React's philosophy of 'one-way data flow' (or 'unidirectional data flow'), where data moves down the component tree through props. Lifting state up is a fundamental concept for building robust and maintainable React applications with interactive data dependencies.",
          "examples": [
            {
              "id": "example_lifting_state_up_1",
              "title": "Counter Example with Lifting State Up",
              "code": "```jsx\nimport React, { useState } from 'react';\n\n// Child Component 1: Displays the count\nfunction DisplayCount({ count }) {\n  return <h2>Current Count: {count}</h2>;\n}\n\n// Child Component 2: Button to increment the count\nfunction CounterButton({ onIncrement }) {\n  return (\n    <button onClick={onIncrement}>\n      Increment Count\n    </button>\n  );\n}\n\n// Parent Component: Manages the shared count state\nfunction CounterApp() {\n  const [count, setCount] = useState(0);\n\n  const handleIncrement = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <h1>Lifting State Up Example</h1>\n      {/* State passed down as prop */}\n      <DisplayCount count={count} />\n      {/* Callback function passed down as prop */}\n      <CounterButton onIncrement={handleIncrement} />\n    </div>\n  );\n}\n\n// Usage example:\n// ReactDOM.render(<CounterApp />, document.getElementById('root'));\n```",
              "explanation": "In this example, `CounterApp` is the common ancestor managing the `count` state. It passes `count` as a prop to `DisplayCount` for display. It also passes `handleIncrement`, a callback function, to `CounterButton`. When `CounterButton` is clicked, it calls `onIncrement`, which in turn executes `handleIncrement` in `CounterApp`, updating the `count` state. This update triggers a re-render, and `DisplayCount` receives the new `count` value, demonstrating the flow of lifted state.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_lifting_state_up_purpose_open",
            "question_lifting_state_up_flow_flashcard",
            "question_lifting_state_up_mcq",
            "question_lifting_state_up_code"
          ],
          "relatedTasks": [
            "task_parent_child_communication_lifting_state"
          ],
          "tags": [
            "React",
            "State Management",
            "Data Flow",
            "Component Communication",
            "Props",
            "Patterns"
          ],
          "technology": "React",
          "prerequisites": [
            "react_state_management_class_components",
            "react_hooks_useState",
            "react_props"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "complex_applications",
            "state_management_patterns"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_react_events_syntax_mcq",
          "topic": "React Event Handling Fundamentals",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is the correct way to handle a click event on a button in React?",
          "answer": "<button onClick={handleClick}>Click Me</button>",
          "options": [
            "<button onclick=\"handleClick()\">Click Me</button>",
            "<button onClick=\"handleClick\">Click Me</button>",
            "<button onClick={handleClick()}>Click Me</button>",
            "<button onClick={handleClick}>Click Me</button>"
          ],
          "analysisPoints": [
            "React event names are camelCase (e.g., `onClick` instead of `onclick`).",
            "Event handlers in React receive a direct function reference, not a string.",
            "Calling `handleClick()` directly in JSX would execute the function immediately during render, not when the button is clicked. It should be `handleClick`."
          ],
          "keyConcepts": [
            "React event naming conventions",
            "Passing function references as event handlers",
            "Distinction between function call and function reference"
          ],
          "evaluationCriteria": [
            "Understanding of React's JSX event syntax.",
            "Knowledge of camelCase convention for events.",
            "Ability to differentiate between calling a function and passing a reference."
          ],
          "example": "The correct option `<button onClick={handleClick}>Click Me</button>` demonstrates React's camelCase syntax for event names and passing a direct reference to the `handleClick` function, ensuring it's called only when the button is clicked. Other options show common pitfalls like using HTML-like string syntax or immediately invoking the function.",
          "tags": [
            "React",
            "Events",
            "JSX",
            "Syntax"
          ],
          "prerequisites": [
            "react_basics",
            "javascript_functions"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_prevent_default_code",
          "topic": "React Event Handling Fundamentals",
          "level": "medium",
          "type": "code",
          "question": "You have an anchor (`<a>`) tag in React that, when clicked, should log a message to the console but **should not** navigate the page. Complete the `handleLinkClick` function and the JSX for the `<a>` tag to achieve this.",
          "answer": "```jsx\nimport React from 'react';\n\nfunction MyLinkComponent() {\n  const handleLinkClick = (e) => {\n    e.preventDefault(); // Prevents the default navigation behavior\n    console.log('Link was clicked, but navigation prevented.');\n  };\n\n  return (\n    <a href=\"/some-page\" onClick={handleLinkClick}>\n      Click me, but stay here\n    </a>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "The primary method to prevent default browser actions in React synthetic events is `e.preventDefault()`.",
            "Returning `false` from a handler does not prevent default behavior in React.",
            "The `onClick` attribute should receive a function reference."
          ],
          "keyConcepts": [
            "SyntheticEvent object",
            "`preventDefault()` method",
            "React event handling syntax"
          ],
          "evaluationCriteria": [
            "Correct use of `e.preventDefault()`.",
            "Correct React event syntax (`onClick={handler}`).",
            "Understanding of the difference from traditional HTML event handling."
          ],
          "example": "The solution correctly uses `e.preventDefault()` within the `handleLinkClick` function. This is the standard and only reliable way to prevent default browser actions like navigation for an `<a>` tag or form submission for a `<form>` in React's synthetic event system. The `onClick` attribute is correctly assigned the function reference.",
          "tags": [
            "React",
            "Events",
            "preventDefault",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_event_handling_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_html_react_event_diff_flashcard",
          "topic": "React Event Handling Fundamentals",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the two main differences between event handling in plain HTML (inline) and React JSX?",
          "answer": "1. **Naming Convention:** HTML uses lowercase (e.g., `onclick`), React uses camelCase (e.g., `onClick`).\n2. **Handler Type:** HTML often uses strings (e.g., `onclick=\"doSomething()\"`), React uses direct function references (e.g., `onClick={doSomething}`).",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Events",
            "HTML Events",
            "JSX",
            "CamelCase"
          ],
          "evaluationCriteria": [
            "Recall of fundamental differences."
          ],
          "example": null,
          "tags": [
            "React",
            "Events",
            "Flashcard",
            "Basics"
          ],
          "prerequisites": [
            "react_event_handling_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_pooling_open",
          "topic": "React Event Handling Fundamentals",
          "level": "medium",
          "type": "open",
          "question": "React's synthetic events are 'pooled'. What does this mean, and what is a potential pitfall and its solution when dealing with asynchronous code?",
          "answer": "React's synthetic events are 'pooled' for performance. This means that the synthetic event object is reused and its properties are nullified (set to `null`) shortly after the event handler function has completed. This optimization reduces the garbage collection overhead.\n\n**Potential Pitfall:** If you try to access properties of the `e` (event) object asynchronously (e.g., inside a `setTimeout`, a `Promise.then()` callback, or an `async/await` function after the `await`), the properties will likely be nullified, leading to unexpected behavior or errors.\n\n**Solution:** To safely access event properties asynchronously, you have two main options:\n1.  **Call `e.persist()`:** This method removes the synthetic event from the pool, allowing you to retain references to it and its properties. However, `e.persist()` is deprecated in React 17+ and not needed with modern event handling (e.g., React DOM event handlers no longer use pooling from React 17 onwards, though it's still a good concept to know for interviews).\n2.  **Extract properties:** The more robust and recommended solution is to extract the properties you need from the event object *before* the event handler completes, and then use these extracted values in your asynchronous code.",
          "options": [],
          "analysisPoints": [
            "Definition of event pooling and its purpose (performance).",
            "Identification of the pitfall: accessing nullified properties asynchronously.",
            "Explanation of solutions: `e.persist()` (and its deprecation context) or extracting properties."
          ],
          "keyConcepts": [
            "Synthetic Events",
            "Event Pooling",
            "Asynchronous JavaScript",
            "`e.persist()`"
          ],
          "evaluationCriteria": [
            "Demonstrates understanding of React's internal event optimization.",
            "Identifies and explains common asynchronous pitfalls.",
            "Proposes correct and modern solutions."
          ],
          "example": null,
          "tags": [
            "React",
            "Events",
            "Performance",
            "Asynchronous",
            "Advanced"
          ],
          "prerequisites": [
            "react_event_handling_basics",
            "javascript_async"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_pointer_events_purpose_mcq",
          "topic": "React Pointer Events",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary advantage of using React's Pointer Events over traditional mouse and touch events?",
          "answer": "They provide a unified way to handle various input types (mouse, touch, pen) with a single set of event handlers.",
          "options": [
            "They offer better performance than traditional events.",
            "They are specifically designed for virtual reality applications.",
            "They provide a unified way to handle various input types (mouse, touch, pen) with a single set of event handlers.",
            "They automatically prevent default browser behavior for all interactions."
          ],
          "analysisPoints": [
            "Pointer Events abstract different input types into a single model.",
            "Their main benefit is code simplification for multi-input applications.",
            "They do not automatically prevent default behavior; `preventDefault()` is still required."
          ],
          "keyConcepts": [
            "Pointer Events",
            "Unified Input",
            "Cross-device compatibility"
          ],
          "evaluationCriteria": [
            "Understanding of the core purpose of Pointer Events.",
            "Ability to distinguish its unique selling proposition."
          ],
          "example": "The key benefit of Pointer Events is their ability to unify input handling across different devices (mouse, touch, pen). This simplifies development for applications that need to respond to various forms of user interaction without writing separate code branches for each.",
          "tags": [
            "React",
            "Events",
            "Pointer Events",
            "Input"
          ],
          "prerequisites": [
            "react_event_handling_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "intermediate"
        },
        {
          "id": "question_pointer_events_use_cases_open",
          "topic": "React Pointer Events",
          "level": "medium",
          "type": "open",
          "question": "Describe two real-world scenarios where using React's Pointer Events would be particularly beneficial. Justify your choices.",
          "answer": "1.  **Draggable/Resizable UI Elements:** When building a UI where elements can be dragged or resized, Pointer Events provide a single API to handle interactions regardless of whether the user is using a mouse, touch, or a pen. For instance, an `onPointerDown` can initiate a drag, `onPointerMove` can update the position, and `onPointerUp` can end the drag. This avoids having to manage separate `onMouseDown`/`onMouseMove`/`onMouseUp` and `onTouchStart`/`onTouchMove`/`onTouchEnd` logic.\n\n2.  **Interactive Canvas/Drawing Applications:** In applications like a whiteboard or a graphic design tool where users draw or manipulate objects, Pointer Events are invaluable. They can distinguish between different pointer types (e.g., finger vs. pen) and provide pressure information (`e.pressure`). This allows for richer interactions, such as varying line thickness based on pen pressure, or differentiating between a 'select' action (mouse click) and a 'draw' action (pen stroke) with a unified event listener.",
          "options": [],
          "analysisPoints": [
            "Identifies scenarios requiring multi-input support.",
            "Explains how Pointer Events simplify development in these scenarios.",
            "Mentions specific Pointer Event properties or capabilities (`pointerId`, `pressure`)."
          ],
          "keyConcepts": [
            "Pointer Events",
            "Cross-device UI",
            "Unified input",
            "User experience"
          ],
          "evaluationCriteria": [
            "Ability to apply theoretical knowledge to practical scenarios.",
            "Justification of choices with technical details.",
            "Demonstrates understanding of the unique value proposition of Pointer Events."
          ],
          "example": null,
          "tags": [
            "React",
            "Pointer Events",
            "Use Cases",
            "Design",
            "Interactive UI"
          ],
          "prerequisites": [
            "react_pointer_events"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_pointer_events_types_flashcard",
          "topic": "React Pointer Events",
          "level": "easy",
          "type": "flashcard",
          "question": "Name three common React Pointer Events and what they generally signify.",
          "answer": "1.  `onPointerDown`: A pointer (mouse, touch, pen) has made contact with the surface.\n2.  `onPointerMove`: A pointer is moving across the surface.\n3.  `onPointerUp`: A pointer has been lifted from the surface.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Pointer Events",
            "Event Types",
            "Input"
          ],
          "evaluationCriteria": [
            "Recall of common Pointer Event types and their meaning."
          ],
          "example": null,
          "tags": [
            "React",
            "Pointer Events",
            "Flashcard"
          ],
          "prerequisites": [
            "react_pointer_events"
          ],
          "complexity": 3,
          "interviewFrequency": 4,
          "learningPath": "intermediate"
        },
        {
          "id": "question_setstate_purpose_mcq",
          "topic": "React State Management in Class Components",
          "level": "easy",
          "type": "mcq",
          "question": "In a React class component, what is the correct method to update the component's `state` and trigger a re-render?",
          "answer": "this.setState()",
          "options": [
            "this.state.propertyName = newValue;",
            "updateState()",
            "this.setState()",
            "this.forceUpdate()"
          ],
          "analysisPoints": [
            "Direct mutation of `this.state` (e.g., `this.state.propertyName = newValue;`) will not trigger a re-render and is a common anti-pattern.",
            "`this.setState()` is the standard asynchronous method for updating state.",
            "`this.forceUpdate()` forces a re-render but should generally be avoided unless absolutely necessary, as it bypasses `shouldComponentUpdate`."
          ],
          "keyConcepts": [
            "React State",
            "`setState` method",
            "Component re-rendering",
            "Immutability of state"
          ],
          "evaluationCriteria": [
            "Correct identification of the state update method.",
            "Understanding of why direct state mutation is wrong.",
            "Familiarity with React component lifecycle and rendering."
          ],
          "example": "The `this.setState()` method is the sole way to update a class component's state and inform React that the component needs to be re-rendered. Directly modifying `this.state.propertyName = newValue;` will change the state object but bypass React's update mechanism, leading to UI that doesn't reflect the data.",
          "tags": [
            "React",
            "State",
            "Class Components",
            "setState"
          ],
          "prerequisites": [
            "react_state_management_class_components"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_direct_state_mutation_flashcard",
          "topic": "React State Management in Class Components",
          "level": "easy",
          "type": "flashcard",
          "question": "Why should you never directly modify `this.state` in a React class component (e.g., `this.state.count = 5;`)?",
          "answer": "Directly modifying `this.state` will not trigger a re-render of the component. React's change detection and reconciliation process relies on `this.setState()` to know when state has changed and a re-render is needed. Bypassing `setState()` leads to UI that does not reflect the underlying data.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React State",
            "Immutability",
            "setState",
            "Re-render"
          ],
          "evaluationCriteria": [
            "Understanding of state immutability in React."
          ],
          "example": null,
          "tags": [
            "React",
            "State",
            "Class Components",
            "Flashcard"
          ],
          "prerequisites": [
            "react_state_management_class_components"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_setstate_async_open",
          "topic": "React State Management in Class Components",
          "level": "medium",
          "type": "open",
          "question": "Explain why `this.setState()` is asynchronous and what implications this has for state updates that depend on the previous state. Provide an example of how to correctly update state based on previous state.",
          "answer": "`this.setState()` is asynchronous because React may batch multiple `setState()` calls for performance reasons to avoid unnecessary re-renders. When `setState()` is called, React doesn't necessarily update the state immediately; it schedules an update. This means `this.state` might not be the most up-to-date value right after calling `setState()`.\n\n**Implication:** If you try to update state based on the current `this.state` value immediately after calling `setState()`, you might be using a stale value. For example, if you call `this.setState({ count: this.state.count + 1 });` twice in a row within the same event loop tick, the second call might use the `count` value from *before* the first `setState()` call was processed.\n\n**Correct Way (Functional `setState`):** To correctly update state that depends on the previous state, you should pass a function to `this.setState()`. This function receives the `prevState` as its first argument and `props` as its second, guaranteeing you're working with the most current state value.\n\n**Example:**\n```jsx\nclass Counter extends React.Component {\n  state = { count: 0 };\n\n  handleIncrement = () => {\n    // Incorrect way if multiple updates are batched or depend on previous state\n    // this.setState({ count: this.state.count + 1 }); \n\n    // Correct way: using a function to ensure latest state is used\n    this.setState((prevState) => ({\n      count: prevState.count + 1\n    }));\n\n    this.setState((prevState) => ({\n      count: prevState.count + 1 // This will correctly increment from the result of the first update\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleIncrement}>Increment</button>\n      </div>\n    );\n  }\n}\n```",
          "options": [],
          "analysisPoints": [
            "Explains the asynchronous nature and its purpose (batching, performance).",
            "Identifies the pitfall of relying on `this.state` immediately after `setState`.",
            "Demonstrates the functional form of `setState` with `prevState` parameter.",
            "Provides a clear code example for correct usage."
          ],
          "keyConcepts": [
            "setState Asynchronous",
            "State Batching",
            "Functional setState",
            "Previous State"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of `setState`'s async behavior.",
            "Correctly identifies and demonstrates the solution for dependent state updates.",
            "Provides a clear and accurate code example."
          ],
          "example": null,
          "tags": [
            "React",
            "State",
            "Class Components",
            "setState",
            "Asynchronous"
          ],
          "prerequisites": [
            "react_state_management_class_components"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_lifting_state_up_purpose_open",
          "topic": "Lifting State Up",
          "level": "medium",
          "type": "open",
          "question": "What is the 'Lifting State Up' pattern in React, and why is it considered a best practice for managing shared state between components?",
          "answer": "The 'Lifting State Up' pattern in React is a strategy where if multiple child components need to share the same state, or if a child component needs to communicate with a sibling component, the state is moved (or 'lifted') from the child component(s) to their closest common ancestor component. This common ancestor then becomes the 'single source of truth' for that particular piece of state.\n\n**Why it's a best practice:**\n1.  **Single Source of Truth:** It ensures that shared data is managed in one place, making it easier to reason about the state and predict how changes will affect the UI.\n2.  **Unidirectional Data Flow:** It adheres to React's principle of one-way data flow. The parent component passes state down to children via props, and children communicate updates back to the parent via callback functions passed down as props.\n3.  **Simpler Debugging:** With state centralized, it's easier to trace data changes and pinpoint bugs related to shared data.\n4.  **Improved Component Reusability:** Child components become 'dumb' or 'presentational' components that simply receive data and callbacks via props, making them more reusable and less coupled to specific state management logic.",
          "options": [],
          "analysisPoints": [
            "Clear definition of 'Lifting State Up'.",
            "Explanation of the 'single source of truth' concept.",
            "Connection to unidirectional data flow.",
            "Benefits like simpler debugging and improved reusability."
          ],
          "keyConcepts": [
            "Lifting State Up",
            "Shared State",
            "Common Ancestor",
            "Unidirectional Data Flow",
            "Props",
            "Callbacks"
          ],
          "evaluationCriteria": [
            "Ability to define and explain the pattern.",
            "Understanding of the underlying principles (single source of truth, one-way data flow).",
            "Articulation of benefits and best practices."
          ],
          "example": null,
          "tags": [
            "React",
            "State Management",
            "Patterns",
            "Architecture",
            "Best Practices"
          ],
          "prerequisites": [
            "react_state_management_class_components",
            "react_props"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_lifting_state_up_flow_flashcard",
          "topic": "Lifting State Up",
          "level": "easy",
          "type": "flashcard",
          "question": "How does data flow when state is 'lifted up' in React (i.e., from parent to child, and child to parent for updates)?",
          "answer": "Data (state) flows down from the common ancestor (parent) to child components via `props`. When a child component needs to update this shared state, it calls a callback function, which was passed down from the parent via `props`. This callback function then updates the state in the parent.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Lifting State Up",
            "Data Flow",
            "Props",
            "Callbacks"
          ],
          "evaluationCriteria": [
            "Recall of data flow in lifted state scenarios."
          ],
          "example": null,
          "tags": [
            "React",
            "State Management",
            "Flashcard",
            "Data Flow"
          ],
          "prerequisites": [
            "react_lifting_state_up"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifting_state_up_mcq",
          "topic": "Lifting State Up",
          "level": "medium",
          "type": "mcq",
          "question": "Consider a `ParentComponent` that renders two sibling components: `InputComponent` and `DisplayComponent`. `InputComponent` has a text input, and `DisplayComponent` should show the current value typed into `InputComponent`. How would you typically implement this using the 'Lifting State Up' pattern?",
          "answer": "The ParentComponent manages the input's value in its state and passes the value to DisplayComponent as a prop, and a callback function to InputComponent to update the value.",
          "options": [
            "InputComponent directly updates DisplayComponent's state using a ref.",
            "Each component maintains its own state, and a global event bus communicates changes.",
            "The ParentComponent manages the input's value in its state and passes the value to DisplayComponent as a prop, and a callback function to InputComponent to update the value.",
            "DisplayComponent fetches the input's value directly from InputComponent's DOM element."
          ],
          "analysisPoints": [
            "Refs are generally not used for state management between components.",
            "Global event buses are an alternative but not the standard 'Lifting State Up' pattern for direct parent-child/sibling communication in React.",
            "Directly accessing another component's DOM is an anti-pattern for data flow.",
            "The correct answer describes the core mechanism of lifting state: state in common ancestor, data down via props, callbacks up via props."
          ],
          "keyConcepts": [
            "Lifting State Up",
            "Unidirectional Data Flow",
            "Props",
            "Callbacks",
            "Shared State"
          ],
          "evaluationCriteria": [
            "Understanding of the core mechanism of 'Lifting State Up'.",
            "Ability to identify correct data flow patterns in React.",
            "Recognition of anti-patterns."
          ],
          "example": "This scenario is a classic example for 'Lifting State Up'. The `ParentComponent` would hold the `inputValue` state. It passes `inputValue` as a prop to `DisplayComponent` to render it. It also passes a function, let's say `handleInputChange`, as a prop to `InputComponent`. When the input's value changes, `InputComponent` calls `handleInputChange` with the new value, which then updates the state in `ParentComponent`, triggering re-renders for both children.",
          "tags": [
            "React",
            "State Management",
            "Lifting State Up",
            "Component Communication",
            "Pattern"
          ],
          "prerequisites": [
            "react_lifting_state_up"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_state_toggle_code",
          "topic": "React State Management in Class Components",
          "level": "medium",
          "type": "code",
          "question": "Create a React class component named `ToggleButton` that displays a message. When a button inside the component is clicked, the message should toggle between 'Message Visible!' and 'Message Hidden!'. Initial state should be 'Message Hidden!'.",
          "answer": "```jsx\nimport React from 'react';\n\nclass ToggleButton extends React.Component {\n  state = {\n    isVisible: false\n  };\n\n  handleToggle = () => {\n    this.setState(prevState => ({\n      isVisible: !prevState.isVisible\n    }));\n  };\n\n  render() {\n    const { isVisible } = this.state;\n    return (\n      <div>\n        <p>{isVisible ? 'Message Visible!' : 'Message Hidden!'}</p>\n        <button onClick={this.handleToggle}>\n          Toggle Message\n        </button>\n      </div>\n    );\n  }\n}\n\n// Usage example:\n// ReactDOM.render(<ToggleButton />, document.getElementById('root'));\n```",
          "options": [],
          "analysisPoints": [
            "Correct initialization of state in a class component.",
            "Correct usage of `this.setState()` to update state.",
            "Using the functional form of `setState` (`prevState`) is best practice when the new state depends on the old state.",
            "Conditional rendering based on state.",
            "Binding `this` context to `handleToggle` (implicitly handled by arrow function as class property)."
          ],
          "keyConcepts": [
            "Class Component State",
            "`setState`",
            "Conditional Rendering",
            "Event Handling"
          ],
          "evaluationCriteria": [
            "Ability to manage state in class components.",
            "Correct application of `setState` for toggling boolean state.",
            "Proper use of conditional rendering.",
            "Adherence to React coding conventions."
          ],
          "example": "This solution correctly initializes `isVisible` to `false`. The `handleToggle` method uses the functional `setState` to safely toggle the `isVisible` boolean, ensuring accurate state updates even if React batches calls. The `render` method then conditionally displays the message based on `isVisible`.",
          "tags": [
            "React",
            "State",
            "Class Components",
            "Code Challenge",
            "Conditional Rendering"
          ],
          "prerequisites": [
            "react_state_management_class_components"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_button_link_events",
          "title": "Implement Interactive Button and Link in React",
          "description": "\nCreate a React functional component named `InteractionDemo` that includes:\n\n1.  A `<button>` element that, when clicked, logs 'Button was clicked!' to the console.\n2.  A `<a>` tag with `href=\"#\"` that, when clicked, logs 'Link clicked, navigation prevented!' to the console, and importantly, **prevents the default browser behavior** (i.e., doesn't navigate or scroll to the top of the page).\n\nEnsure that you adhere to React's event handling conventions (camelCase, passing functions).",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\n\nfunction InteractionDemo() {\n  // Implement button click handler here\n  const handleButtonClick = () => {\n    // TODO: Log a message\n  };\n\n  // Implement link click handler here\n  const handleLinkClick = (e) => {\n    // TODO: Prevent default behavior and log a message\n  };\n\n  return (\n    <div>\n      {/* TODO: Add a button here */}\n      {/* TODO: Add a link here */}\n    </div>\n  );\n}\n\nexport default InteractionDemo;\n",
          "solutionCode": "import React from 'react';\n\nfunction InteractionDemo() {\n  const handleButtonClick = () => {\n    console.log('Button was clicked!');\n  };\n\n  const handleLinkClick = (e) => {\n    e.preventDefault(); // Critical: prevents default navigation for <a> tags\n    console.log('Link clicked, navigation prevented!');\n  };\n\n  return (\n    <div>\n      <button onClick={handleButtonClick}>\n        Click Me\n      </button>\n      <br /><br />\n      <a href=\"#\" onClick={handleLinkClick}>\n        Click me, but stay here\n      </a>\n    </div>\n  );\n}\n\nexport default InteractionDemo;\n",
          "testCases": [
            "Clicking the button should log 'Button was clicked!' to the console.",
            "Clicking the link should log 'Link clicked, navigation prevented!' to the console.",
            "Clicking the link should NOT cause the page to scroll to the top or change the URL hash.",
            "Ensure event handlers are passed as function references, not strings."
          ],
          "hints": [
            "Remember React's `onClick` syntax (camelCase).",
            "To prevent default actions for the link, you'll need access to the synthetic event object."
          ],
          "tags": [
            "React",
            "Events",
            "Event Handling",
            "preventDefault",
            "Basics"
          ],
          "timeEstimate": 20,
          "prerequisites": [
            "react_basics",
            "react_event_handling_basics"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "synthetic_events",
            "jsx"
          ]
        },
        {
          "id": "task_draggable_element_pointer_events",
          "title": "Create a Draggable Element with React Pointer Events",
          "description": "\nImplement a React functional component named `DraggableBox` that allows a user to drag a `div` element around the screen using mouse, touch, or pen.\n\nRequirements:\n1.  The `div` should have a fixed size (e.g., 100px by 100px) and a distinct background color.\n2.  Use **Pointer Events** (`onPointerDown`, `onPointerMove`, `onPointerUp`) to manage the drag functionality.\n3.  The box's position should update as the pointer moves while it's 'down'.\n4.  The box should stop moving when the pointer is 'up'.\n5.  Consider how to correctly calculate the position relative to the element's initial click point to avoid 'jumping'.\n6.  The element should be absolutely positioned.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useRef } from 'react';\n\nfunction DraggableBox() {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  const [isDragging, setIsDragging] = useState(false);\n  const offset = useRef({ x: 0, y: 0 }); // To store the offset from mouse to element top-left\n\n  const handlePointerDown = (e) => {\n    // TODO: Implement logic for when pointer goes down\n    // 1. Set isDragging to true\n    // 2. Calculate the offset from pointer position to element's top-left corner\n    //    e.g., offset.current.x = e.clientX - position.x\n  };\n\n  const handlePointerMove = (e) => {\n    // TODO: Implement logic for when pointer moves\n    // 1. If dragging, update the position based on pointer movement and stored offset\n    //    e.g., setPosition({ x: e.clientX - offset.current.x, y: e.clientY - offset.current.y });\n  };\n\n  const handlePointerUp = () => {\n    // TODO: Implement logic for when pointer goes up\n    // 1. Set isDragging to false\n  };\n\n  return (\n    <div\n      style={{\n        position: 'absolute',\n        width: '100px',\n        height: '100px',\n        backgroundColor: 'rebeccapurple',\n        cursor: 'grab',\n        left: position.x,\n        top: position.y,\n        userSelect: 'none'\n      }}\n      onPointerDown={handlePointerDown}\n      onPointerMove={handlePointerMove}\n      onPointerUp={handlePointerUp}\n    >\n      Drag Me\n    </div>\n  );\n}\n\nexport default DraggableBox;\n",
          "solutionCode": "import React, { useState, useRef } from 'react';\n\nfunction DraggableBox() {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  const [isDragging, setIsDragging] = useState(false);\n  const offset = useRef({ x: 0, y: 0 }); // To store the offset from mouse to element top-left\n  const boxRef = useRef(null);\n\n  const handlePointerDown = (e) => {\n    setIsDragging(true);\n    // Calculate the offset from the pointer's current position to the box's top-left corner\n    // This prevents the box from 'jumping' its top-left to the pointer's position on click.\n    const rect = boxRef.current.getBoundingClientRect();\n    offset.current = {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top,\n    };\n    // Important for dragging: capture the pointer to receive events even if pointer leaves the element\n    boxRef.current.setPointerCapture(e.pointerId);\n  };\n\n  const handlePointerMove = (e) => {\n    if (isDragging) {\n      // Update the position based on pointer movement and stored offset\n      setPosition({\n        x: e.clientX - offset.current.x,\n        y: e.clientY - offset.current.y,\n      });\n    }\n  };\n\n  const handlePointerUp = (e) => {\n    setIsDragging(false);\n    // Release pointer capture\n    boxRef.current.releasePointerCapture(e.pointerId);\n  };\n\n  return (\n    <div\n      ref={boxRef}\n      style={{\n        position: 'absolute',\n        width: '100px',\n        height: '100px',\n        backgroundColor: 'rebeccapurple',\n        color: 'white',\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        cursor: isDragging ? 'grabbing' : 'grab',\n        left: position.x + 'px',\n        top: position.y + 'px',\n        userSelect: 'none',\n        touchAction: 'none' // Prevents browser default touch actions like scrolling\n      }}\n      onPointerDown={handlePointerDown}\n      onPointerMove={handlePointerMove}\n      onPointerUp={handlePointerUp}\n      // onPointerLeave={isDragging ? handlePointerUp : undefined} // Optional: useful if drag ends by leaving window\n      // onPointerCancel={handlePointerUp} // Also good to handle cancel events\n    >\n      Drag Me\n    </div>\n  );\n}\n\nexport default DraggableBox;\n",
          "testCases": [
            "The box should appear on the screen.",
            "Clicking and dragging the box should move it across the screen.",
            "Releasing the click (mouse up) should stop the box from moving.",
            "The box should not 'jump' when the drag starts.",
            "Dragging outside the box's boundaries while `onPointerDown` is active should still move the box (due to `setPointerCapture`).",
            "On touch devices, the box should be draggable with a finger.",
            "Browser default touch actions (like scrolling) should be prevented on the box itself (using `touchAction: 'none'`)."
          ],
          "hints": [
            "You'll need `useState` for the box's position and drag state.",
            "A `useRef` can be useful to store the offset between the pointer's position and the element's top-left corner at the moment `onPointerDown` fires.",
            "Consider using `element.setPointerCapture()` and `element.releasePointerCapture()` to ensure consistent dragging behavior even if the pointer moves off the element.",
            "Don't forget to add `px` to your `left` and `top` style properties if they are numbers.",
            "For touch devices, consider the `touch-action: none` CSS property to prevent default browser gestures."
          ],
          "tags": [
            "React",
            "Pointer Events",
            "State",
            "Hooks",
            "Interactive UI",
            "Drag and Drop"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_hooks_useState",
            "react_hooks_useRef",
            "react_pointer_events"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "dom_manipulation",
            "event_listeners"
          ]
        },
        {
          "id": "task_toggle_visibility_component",
          "title": "Implement a Message Toggle Component (Class Component)",
          "description": "\nCreate a React **class component** called `MessageToggler` that displays a hidden message that can be toggled visible/hidden by clicking a button.\n\nRequirements:\n1.  The component should manage its visibility state internally using `this.state`.\n2.  Initially, the message should be hidden.\n3.  A button should exist that, when clicked, toggles the visibility of the message.\n4.  The button's text should change based on the message's visibility (e.g., 'Show Message' when hidden, 'Hide Message' when visible).\n5.  The message itself should be a simple paragraph element.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass MessageToggler extends React.Component {\n  // TODO: Initialize state here (e.g., isMessageVisible: false)\n\n  // TODO: Create a method to handle the button click and toggle state\n  handleToggleClick = () => {\n    // Use setState to update visibility\n  };\n\n  render() {\n    // TODO: Destructure state\n    const { /* state variable here */ } = this.state;\n\n    return (\n      <div>\n        {/* TODO: Conditionally render the message */}\n        {/* TODO: Render the button with changing text and onClick handler */}\n      </div>\n    );\n  }\n}\n\nexport default MessageToggler;\n",
          "solutionCode": "import React from 'react';\n\nclass MessageToggler extends React.Component {\n  // Initialize state using class fields syntax\n  state = {\n    isMessageVisible: false\n  };\n\n  // Method to handle the button click and toggle state\n  handleToggleClick = () => {\n    // Use the functional form of setState for toggling boolean values\n    this.setState(prevState => ({\n      isMessageVisible: !prevState.isMessageVisible\n    }));\n  };\n\n  render() {\n    const { isMessageVisible } = this.state;\n\n    return (\n      <div>\n        <button onClick={this.handleToggleClick}>\n          {isMessageVisible ? 'Hide Message' : 'Show Message'}\n        </button>\n        {isMessageVisible && (\n          <p>This is the secret message! You found it!</p>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default MessageToggler;\n",
          "testCases": [
            "Initially, the message paragraph should not be visible.",
            "The button's initial text should be 'Show Message'.",
            "Clicking the button once should make the message visible and change the button text to 'Hide Message'.",
            "Clicking the button a second time should hide the message and change the button text back to 'Show Message'.",
            "Ensure state is managed correctly within the class component using `this.state` and `this.setState()`."
          ],
          "hints": [
            "Remember to use `this.setState()` to update the component's state.",
            "For toggling a boolean state, it's often best practice to use the functional update form of `setState` to ensure you're working with the most recent state value.",
            "Conditional rendering in React can be achieved using logical `&&` or ternary operators (`? :`)."
          ],
          "tags": [
            "React",
            "Class Components",
            "State Management",
            "setState",
            "Conditional Rendering"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_state_management_class_components"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "component_lifecycle",
            "event_handling"
          ]
        },
        {
          "id": "task_parent_child_communication_lifting_state",
          "title": "Implement Parent-Child Communication via Lifting State Up",
          "description": "\nCreate a React application consisting of three components: `ParentCounter`, `IncrementButton`, and `DisplayValue`. Demonstrate the 'Lifting State Up' pattern.\n\nRequirements:\n1.  `ParentCounter` should be the main component that manages a `count` state (initialized to 0).\n2.  `IncrementButton` should be a child component of `ParentCounter` that, when clicked, requests an increment of the `count`.\n3.  `DisplayValue` should be another child component of `ParentCounter` that simply displays the current `count`.\n4.  `IncrementButton` and `DisplayValue` should be 'dumb' or 'presentational' components; they should not manage their own state. All shared state logic should reside in `ParentCounter`.\n5.  Ensure proper data flow: `ParentCounter` passes `count` to `DisplayValue` and a callback to `IncrementButton`.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// Child Component: Displays the count\nfunction DisplayValue({ /* TODO: props for count */ }) {\n  return <h2>Current Value: { /* TODO: display count */ }</h2>;\n}\n\n// Child Component: Button to increment the count\nfunction IncrementButton({ /* TODO: props for callback */ }) {\n  return (\n    <button onClick={ /* TODO: call increment callback */ }>\n      Increment\n    </button>\n  );\n}\n\n// Parent Component: Manages the shared count state\nfunction ParentCounter() {\n  const [count, setCount] = useState(0);\n\n  const handleIncrement = () => {\n    // TODO: Update count state\n  };\n\n  return (\n    <div>\n      <h1>Lifting State Up Demo</h1>\n      {/* TODO: Pass count to DisplayValue */}\n      {/* TODO: Pass handleIncrement to IncrementButton */}\n    </div>\n  );\n}\n\nexport default ParentCounter;\n",
          "solutionCode": "import React, { useState } from 'react';\n\n// Child Component: Displays the count\nfunction DisplayValue({ count }) {\n  return <h2>Current Value: {count}</h2>;\n}\n\n// Child Component: Button to increment the count\nfunction IncrementButton({ onIncrement }) {\n  return (\n    <button onClick={onIncrement}>\n      Increment\n    </button>\n  );\n}\n\n// Parent Component: Manages the shared count state\nfunction ParentCounter() {\n  const [count, setCount] = useState(0);\n\n  const handleIncrement = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <h1>Lifting State Up Demo</h1>\n      <DisplayValue count={count} />\n      <IncrementButton onIncrement={handleIncrement} />\n    </div>\n  );\n}\n\nexport default ParentCounter;\n",
          "testCases": [
            "Initially, the displayed value should be 0.",
            "Clicking the 'Increment' button should increase the displayed value by 1.",
            "Verify that `DisplayValue` and `IncrementButton` do not contain `useState` or `this.state`.",
            "Ensure `ParentCounter` is the sole source of truth for the `count` state.",
            "Check that data flows down via props and updates flow up via callbacks."
          ],
          "hints": [
            "Use the `useState` hook in the `ParentCounter` for the `count` state.",
            "Pass the `count` state to `DisplayValue` as a prop.",
            "Pass the `handleIncrement` function (defined in `ParentCounter`) to `IncrementButton` as a prop. `IncrementButton` will call this prop when its button is clicked.",
            "Remember to use the functional update form of `setCount` when incrementing (`setCount(prevCount => prevCount + 1)`) to avoid stale closure issues."
          ],
          "tags": [
            "React",
            "State Management",
            "Lifting State Up",
            "Component Communication",
            "Hooks"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_hooks_useState",
            "react_props",
            "react_lifting_state_up"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "unidirectional_data_flow",
            "functional_components"
          ]
        }
      ]
    }
  },
  {
    "id": "dac5694d-d623-4dc4-8968-de83d980e021",
    "startLine": 3800,
    "endLine": 3899,
    "processedDate": "2025-06-17T08:57:45.652Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_lifting_state_up",
          "title": "Lifting State Up for Shared Data",
          "content": "When multiple components in a React application need to share and react to the same piece of state, it is a recommended practice to \"lift\" that shared state up to their closest common ancestor component. This pattern is fundamental for maintaining data consistency and simplifying state management in complex component trees.\n\n## Core Concept\n\n**Single Source of Truth:** By lifting state, you establish a single, authoritative source for that data. Instead of each child component managing its own copy of potentially conflicting state, the parent component becomes the owner of the shared state. This ensures that all components that depend on this state are always in sync.\n\n**Data Flow:** The data flows downwards from the parent (owner) component to its children via props. If a child component needs to update this shared state, it doesn't modify the state directly. Instead, the parent passes down a callback function (also via props) that the child can invoke to request a state update. The parent then executes its state update logic, which in turn causes a re-render of itself and its children, passing down the new state.\n\n## Benefits of Lifting State Up\n\n-   **Maintains a single source of truth:** Eliminates duplication and ensures data consistency.\n-   **Easier synchronization:** All related components automatically receive updates from the central state, making it simpler to keep them in sync.\n-   **Reduces bugs:** By centralizing state logic, you minimize the chances of inconsistent data and related bugs.\n-   **Simpler debugging:** State changes are centralized in one component, making it easier to trace data flow and identify the source of issues.\n-   **Improved maintainability:** The explicit data flow (props down, events up) makes the application's behavior more predictable and easier to understand.\n\n## Implementation Steps\n\n1.  **Identify Shared State:** Determine which piece of state is needed by multiple sibling components.\n2.  **Find Common Ancestor:** Locate the closest parent component that renders all components needing access to this state.\n3.  **Move State to Ancestor:** Declare the `useState` hook for the shared state in the common ancestor component.\n4.  **Pass State Down:** Pass the state value from the ancestor to its children as props.\n5.  **Pass Update Callbacks Down:** Pass a function from the ancestor (which updates the shared state) down to children as props. Children will call this function when they need to request a state change.\n6.  **Handle Updates in Parent:** The parent component's update function will receive the new data, update its state, and trigger re-renders.\n\nThis pattern encourages a unidirectional data flow, which is a core principle in React, leading to more predictable and manageable applications.",
          "examples": [
            {
              "id": "example_lifting_state_up_1",
              "title": "Temperature Converter Example",
              "code": "import React, { useState } from 'react';\n\n// Parent component holds the shared state\nfunction TemperatureCalculator() {\n  const [temperature, setTemperature] = useState('');\n  const [scale, setScale] = useState('c');\n  \n  // Conversion functions\n  const toCelsius = (fahrenheit) => {\n    if (isNaN(parseFloat(fahrenheit))) return '';\n    return ((parseFloat(fahrenheit) - 32) * 5 / 9).toFixed(2);\n  };\n  const toFahrenheit = (celsius) => {\n    if (isNaN(parseFloat(celsius))) return '';\n    return ((parseFloat(celsius) * 9 / 5) + 32).toFixed(2);\n  };\n  \n  // Handle temperature change from Celsius input\n  const handleCelsiusChange = (value) => {\n    setTemperature(value);\n    setScale('c');\n  };\n  \n  // Handle temperature change from Fahrenheit input\n  const handleFahrenheitChange = (value) => {\n    setTemperature(value);\n    setScale('f');\n  };\n  \n  // Calculate both temperatures based on current scale\n  const celsius = scale === 'f' ? toCelsius(temperature) : temperature;\n  const fahrenheit = scale === 'c' ? toFahrenheit(temperature) : temperature;\n  \n  return (\n    <div>\n      <h2>Temperature Converter</h2>\n      <TemperatureInput \n        scale=\"c\" \n        temperature={celsius}\n        onTemperatureChange={handleCelsiusChange} \n      />\n      <TemperatureInput \n        scale=\"f\" \n        temperature={fahrenheit}\n        onTemperatureChange={handleFahrenheitChange} \n      />\n      <BoilingVerdict celsius={parseFloat(celsius)} />\n    </div>\n  );\n}\n\n// Child component receives props from parent\nfunction TemperatureInput({ scale, temperature, onTemperatureChange }) {\n  const scaleNames = {\n    c: 'Celsius',\n    f: 'Fahrenheit'\n  };\n  \n  const handleChange = (e) => {\n    onTemperatureChange(e.target.value);\n  };\n  \n  return (\n    <fieldset>\n      <legend>Enter temperature in {scaleNames[scale]}:</legend>\n      <input \n        value={temperature}\n        onChange={handleChange} \n      />\n    </fieldset>\n  );\n}\n\n// Another component that uses the same state\nfunction BoilingVerdict({ celsius }) {\n  if (isNaN(celsius)) {\n    return <p>Enter a number to see boiling verdict.</p>;\n  }\n  return celsius >= 100 ?\n    <p style={{ color: 'green' }}>The water would boil.</p> :\n    <p style={{ color: 'blue' }}>The water would not boil.</p>;\n}\n\n// To render:\n// ReactDOM.render(<TemperatureCalculator />, document.getElementById('root'));",
              "explanation": "This example demonstrates how state (`temperature` and `scale`) is lifted up to the `TemperatureCalculator` component. Both `TemperatureInput` components receive the current `temperature` and `onTemperatureChange` callback from `TemperatureCalculator`. When a user types in either input, the `handleChange` function in `TemperatureInput` calls `onTemperatureChange` (which is `handleCelsiusChange` or `handleFahrenheitChange` from the parent). The parent then updates its state, re-calculates both Celsius and Fahrenheit values, and re-renders, ensuring both inputs and the `BoilingVerdict` component are always synchronized based on the single source of truth in `TemperatureCalculator`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_lifting_state_up_1",
            "question_lifting_state_up_2",
            "question_lifting_state_up_3",
            "question_lifting_state_up_4",
            "question_lifting_state_up_5",
            "question_lifting_state_up_6"
          ],
          "relatedTasks": [
            "task_lifting_state_up_1",
            "task_lifting_state_up_2"
          ],
          "tags": [
            "React",
            "State Management",
            "Component Communication",
            "Unidirectional Data Flow",
            "Best Practices"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_state_hook",
            "react_props"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "complex_forms",
            "data_synchronization",
            "global_state_management_patterns"
          ]
        },
        {
          "id": "theory_refs",
          "title": "Refs in React: Accessing DOM Elements and React Components Imperatively",
          "content": "Refs (short for references) provide a way to access DOM nodes or React components created in the render method. In the typical React data flow, props are the primary way components interact with each other, flowing data from parent to child. However, there are scenarios where you need to imperatively modify a child, which cannot be achieved with props alone. Refs are designed for these cases.\n\n## When to Use Refs\n\nRefs are not intended for general-purpose state management or for making declarative changes to your UI. Instead, they are specifically for imperative interactions. Common use cases include:\n\n1.  **Managing Focus, Text Selection, or Media Playback:** Directly focusing an input field, selecting text, or controlling `play()`/`pause()` on video/audio elements.\n2.  **Triggering Imperative Animations:** Interacting with browser APIs or third-party animation libraries that directly manipulate the DOM.\n3.  **Integrating with Third-Party DOM Libraries:** When you need to integrate React with a non-React library that expects a DOM element to operate on (e.g., a charting library).\n\n## When NOT to Use Refs\n\n-   **Do not overuse refs:** Avoid using refs for anything that can be achieved declaratively through props and state. For example, don't use a ref to show/hide a component; use conditional rendering based on state.\n-   **Refs are not for component communication:** Don't use refs to pass data between components or trigger updates. This should be handled by props and state.\n\n## Creating Refs\n\nReact provides different ways to create and use refs depending on whether you are using class components or functional components.\n\n### In Class Components\n\nRefs are typically created using `React.createRef()` in the constructor and attached to React elements via the `ref` attribute. The ref's `current` property will hold the underlying DOM element or the instance of the React component after it has mounted.\n\n### In Functional Components (with Hooks)\n\nFor functional components, the `useRef` Hook is used. `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument (`initialValue`). The returned object will persist for the full lifetime of the component. It's similar to `createRef`, but `useRef` is specifically designed for functional components.\n\n### Forwarding Refs\n\nBy default, you cannot attach a `ref` directly to a custom functional component and expect to get a reference to its internal DOM node. This is because functional components are typically stateless and don't expose their internal DOM structure directly. To allow a parent component to get a ref to a DOM node *inside* a child functional component, you use `React.forwardRef`. This Higher-Order Component allows you to pass the `ref` prop down to an underlying DOM element or another component.\n\n",
          "examples": [
            {
              "id": "example_refs_1",
              "title": "Using `createRef` in Class Components",
              "code": "import React from 'react';\n\nclass MyForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.textInput = React.createRef(); // Create a ref\n  }\n\n  focusTextInput = () => {\n    // Use the DOM API to focus the input\n    this.textInput.current.focus();\n  };\n\n  render() {\n    return (\n      <div>\n        <input\n          type=\"text\"\n          ref={this.textInput} // Attach the ref to the input element\n        />\n        <button onClick={this.focusTextInput}>\n          Focus the text input\n        </button>\n      </div>\n    );\n  }\n}\n// To render:\n// ReactDOM.render(<MyForm />, document.getElementById('root'));",
              "explanation": "In this class component, `this.textInput` is created using `React.createRef()` in the constructor. It's then attached to the `<input>` element via the `ref` prop. When the component mounts, `this.textInput.current` will point to the actual DOM input element, allowing us to call DOM methods like `focus()` on it.",
              "language": "typescript"
            },
            {
              "id": "example_refs_2",
              "title": "Using `useRef` in Functional Components",
              "code": "import React, { useRef } from 'react';\n\nfunction MyFunctionalForm() {\n  const textInput = useRef(null); // Create a ref using useRef hook\n\n  const focusTextInput = () => {\n    // Use the DOM API to focus the input\n    textInput.current.focus();\n  };\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        ref={textInput} // Attach the ref to the input element\n      />\n      <button onClick={focusTextInput}>\n        Focus the text input\n      </button>\n    </div>\n  );\n}\n// To render:\n// ReactDOM.render(<MyFunctionalForm />, document.getElementById('root'));",
              "explanation": "This example shows the equivalent functionality using a functional component and the `useRef` hook. `useRef(null)` initializes the ref. The `textInput.current` property will hold the DOM input element after rendering. The `focusTextInput` function then accesses `textInput.current` to call the `focus()` method. `useRef` is preferred in functional components.",
              "language": "typescript"
            },
            {
              "id": "example_refs_3",
              "title": "Using `forwardRef` to Pass Refs",
              "code": "import React, { useRef, forwardRef } from 'react';\n\n// Child functional component that forwards the ref to its input\nconst CustomInput = forwardRef((props, ref) => (\n  <div>\n    <label>{props.label}: </label>\n    <input type=\"text\" ref={ref} {...props} />\n  </div>\n));\n\n// Parent component that uses CustomInput and wants to focus its internal input\nfunction ParentComponent() {\n  const inputRef = useRef(null);\n\n  const handleClick = () => {\n    inputRef.current.focus();\n  };\n\n  return (\n    <div>\n      <CustomInput label=\"Your Name\" ref={inputRef} />\n      <button onClick={handleClick}>Focus Name Input</button>\n    </div>\n  );\n}\n// To render:\n// ReactDOM.render(<ParentComponent />, document.getElementById('root'));",
              "explanation": "Here, `CustomInput` is a functional component wrapped with `forwardRef`. This allows `ParentComponent` to pass `inputRef` directly to `CustomInput`, and `CustomInput` explicitly attaches it to its internal `<input>` element. When the button is clicked, `inputRef.current.focus()` successfully focuses the input inside `CustomInput`, demonstrating how refs can be passed through components.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_refs_1",
            "question_refs_2",
            "question_refs_3",
            "question_refs_4",
            "question_refs_5",
            "question_refs_6"
          ],
          "relatedTasks": [
            "task_refs_1",
            "task_refs_2",
            "task_refs_3"
          ],
          "tags": [
            "React",
            "Refs",
            "DOM Manipulation",
            "Imperative Programming",
            "Hooks",
            "forwardRef",
            "useRef"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_class_components",
            "react_hooks_overview",
            "react_props"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "integrating_third_party_libs",
            "advanced_dom_manipulation",
            "media_controls"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_lifting_state_up_1",
          "topic": "Lifting State Up - Core Concept",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary motivation for 'lifting state up' in React applications?",
          "answer": "To establish a single source of truth for shared data.",
          "options": [
            "To reduce the total amount of state in an application.",
            "To make components completely independent of each other.",
            "To establish a single source of truth for shared data.",
            "To allow child components to directly modify parent state."
          ],
          "analysisPoints": [
            "Lifting state centralizes shared data, making it consistent.",
            "It doesn't necessarily reduce the total state, but rather organizes it.",
            "Components become interdependent through shared state, not independent.",
            "Children do not directly modify parent state; they call callbacks provided by the parent."
          ],
          "keyConcepts": [
            "Lifting State Up",
            "Single Source of Truth",
            "Data Flow"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles of state management in React."
          ],
          "example": "The core idea behind lifting state up is to ensure that when multiple components need to react to changes in the same data, there's only one place where that data lives. This prevents inconsistencies and simplifies debugging.",
          "tags": [
            "React State",
            "Component Communication",
            "Fundamentals"
          ],
          "prerequisites": [
            "react_state_hook",
            "react_props"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifting_state_up_2",
          "topic": "Lifting State Up - Implementation",
          "level": "medium",
          "type": "code",
          "question": "Consider a `CounterDisplay` component that simply shows a number and `IncrementButton` that increases a counter. Refactor the following code to lift the `count` state to a common parent component `App`, ensuring both components reflect the same count value.",
          "answer": "```typescript\nimport React, { useState } from 'react';\n\nfunction CounterDisplay({ count }) {\n  return <h2>Current Count: {count}</h2>;\n}\n\nfunction IncrementButton({ onIncrement }) {\n  return (\n    <button onClick={onIncrement}>Increment</button>\n  );\n}\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const handleIncrement = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <h1>Shared Counter</h1>\n      <CounterDisplay count={count} />\n      <IncrementButton onIncrement={handleIncrement} />\n    </div>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "The `count` state is moved from `CounterDisplay` (or `IncrementButton` if it were there) to `App`.",
            "The `count` value is passed down to `CounterDisplay` as a prop.",
            "A function `handleIncrement` (which updates `count` in `App`) is passed down to `IncrementButton` as a prop (`onIncrement`).",
            "The `IncrementButton` calls the `onIncrement` callback, triggering the state update in `App`."
          ],
          "keyConcepts": [
            "Lifting State Up",
            "Props",
            "Callbacks",
            "Unidirectional Data Flow"
          ],
          "evaluationCriteria": [
            "Correctly identifies the common ancestor.",
            "Moves state to the ancestor.",
            "Passes state and update functions as props.",
            "Ensures correct data flow (props down, events up)."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\n// Initial (incorrect) setup:\n// function CounterDisplay() {\n//   const [count, setCount] = useState(0);\n//   return <h2>Current Count: {count}</h2>;\n// }\n// function IncrementButton() {\n//   // How to update count in CounterDisplay from here?\n//   return <button>Increment</button>;\n// }\n// function App() {\n//   return (\n//     <div>\n//       <CounterDisplay />\n//       <IncrementButton />\n//     </div>\n//   );\n// }\n\n// Corrected (lifted state) solution:\nfunction CounterDisplay({ count }) {\n  return <h2>Current Count: {count}</h2>;\n}\n\nfunction IncrementButton({ onIncrement }) {\n  return (\n    <button onClick={onIncrement}>Increment</button>\n  );\n}\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const handleIncrement = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <h1>Shared Counter</h1>\n      <CounterDisplay count={count} />\n      <IncrementButton onIncrement={handleIncrement} />\n    </div>\n  );\n}\n```",
          "tags": [
            "React Code",
            "State Management",
            "Refactoring",
            "Hooks"
          ],
          "prerequisites": [
            "react_state_hook",
            "react_props"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifting_state_up_3",
          "topic": "Lifting State Up - Benefits",
          "level": "medium",
          "type": "open",
          "question": "Besides 'maintaining a single source of truth', describe two other significant benefits of lifting state up in a React application. Provide a brief explanation for each.",
          "answer": "1.  **Easier Synchronization:** When state is lifted, all child components that depend on that state receive updates directly from the parent component. This makes it inherently easier to keep the UI consistent across multiple components, as they are all rendering based on the same, updated data. Without lifted state, each component might manage its own version, leading to potential discrepancies.\n2.  **Reduced Bugs & Simpler Debugging:** By centralizing state management logic in one place (the common ancestor), you minimize the chances of inconsistencies and related bugs. If an issue arises with the shared data, you know exactly where to look – the parent component that owns the state. This makes debugging significantly more straightforward than trying to trace state across multiple, independently managed components.",
          "options": [],
          "analysisPoints": [
            "Ability to articulate benefits beyond the primary one.",
            "Clarity and conciseness of explanations.",
            "Understanding of practical implications (e.g., consistency, debugging)."
          ],
          "keyConcepts": [
            "Lifting State Up",
            "Synchronization",
            "Debugging",
            "Bug Reduction"
          ],
          "evaluationCriteria": [
            "Comprehension of the pattern's advantages.",
            "Ability to explain concepts clearly.",
            "Demonstrates practical understanding."
          ],
          "example": "An example demonstrating 'Easier Synchronization' is the temperature calculator: without lifting state, if Celsius input updated its own state and Fahrenheit input updated its own, they would quickly fall out of sync. By lifting the state, typing in one input immediately updates the other, maintaining synchronization. 'Simpler Debugging' is evident because if the temperature calculation or display is wrong, the developer knows to check the `TemperatureCalculator` component where the state and logic reside, rather than searching through multiple independent components.",
          "tags": [
            "React State",
            "Best Practices",
            "Debugging"
          ],
          "prerequisites": [
            "react_state_management"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifting_state_up_4",
          "topic": "Lifting State Up - Flashcard",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the term for a common pattern where shared state is moved to a common ancestor component in React?",
          "answer": "Lifting State Up",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Lifting State Up"
          ],
          "evaluationCriteria": [
            "Recall of fundamental React terminology."
          ],
          "example": "",
          "tags": [
            "React Terminology",
            "State Management"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifting_state_up_5",
          "topic": "Lifting State Up - Trade-offs",
          "level": "hard",
          "type": "open",
          "question": "While beneficial, lifting state up can sometimes lead to 'prop drilling'. Explain what prop drilling is and suggest one alternative pattern or technology in React that aims to mitigate it.",
          "answer": "**Prop Drilling (or Threading)**: Prop drilling refers to the situation where a piece of data (state) needs to be passed down through several layers of intermediary components that don't actually need the data themselves, just to get it to a deeply nested child component that does. This can make the code harder to read, maintain, and refactor because changes to the data structure or requirements necessitate modifying many intermediary components.\n\n**Alternative Mitigation (Context API):** React's Context API is a common solution to prop drilling. It provides a way to pass data through the component tree without having to pass props down manually at every level. You define a Context Provider higher up in the tree which holds the data, and any component nested deeper in the tree can consume this context using `useContext` (for functional components) or `Context.Consumer` (for class components), without needing props from intermediate components. This is ideal for 'global' data like theme, user authentication, or preferences that many components might need.",
          "options": [],
          "analysisPoints": [
            "Accurate definition of prop drilling.",
            "Identification of a valid alternative (e.g., Context API, Redux, Zustand).",
            "Clear explanation of how the alternative mitigates prop drilling.",
            "Understanding of the trade-offs of lifting state up in large applications."
          ],
          "keyConcepts": [
            "Prop Drilling",
            "React Context API",
            "State Management",
            "Scalability"
          ],
          "evaluationCriteria": [
            "In-depth understanding of React state patterns and their limitations.",
            "Knowledge of advanced React features or common state management libraries.",
            "Ability to analyze and propose solutions for architectural challenges."
          ],
          "example": "Imagine a user's `theme` (dark/light) stored in `App` component. If a component `Button` is nested several layers deep (`App -> Layout -> Header -> Navigation -> Button`), and `Button` needs the theme, `theme` would have to be passed as a prop through `Layout`, `Header`, and `Navigation` (which don't use `theme` themselves). This is prop drilling. Using `Context API`, `App` provides the theme context, and `Button` can directly consume it without `Layout`, `Header`, or `Navigation` needing to know about it.",
          "tags": [
            "React State",
            "Advanced React",
            "Context API",
            "Architecture"
          ],
          "prerequisites": [
            "react_context_api"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_lifting_state_up_6",
          "topic": "Lifting State Up - Unidirectional Data Flow",
          "level": "medium",
          "type": "mcq",
          "question": "Which principle does 'lifting state up' reinforce in React's data flow?",
          "answer": "Unidirectional data flow",
          "options": [
            "Bidirectional data binding",
            "Component reusability",
            "Unidirectional data flow",
            "Direct DOM manipulation"
          ],
          "analysisPoints": [
            "Lifting state ensures data flows from parent to child (downwards) via props, and updates are requested upwards via callbacks, which is the definition of unidirectional data flow.",
            "React primarily advocates for unidirectional flow, unlike some other frameworks that support bidirectional binding.",
            "While it can enable reusability, it's not the core principle reinforced.",
            "It's about managing state, not directly manipulating the DOM (unless it's an escape hatch like refs)."
          ],
          "keyConcepts": [
            "Lifting State Up",
            "Unidirectional Data Flow",
            "React Principles"
          ],
          "evaluationCriteria": [
            "Understanding of core React architectural principles."
          ],
          "example": "In the temperature converter example, the `temperature` flows down from `TemperatureCalculator` to `TemperatureInput` and `BoilingVerdict`. When `TemperatureInput` wants to change the temperature, it doesn't directly modify the state; it calls a function (`onTemperatureChange`) that was passed down from the parent, allowing the parent to control the update. This explicit, one-way flow makes the application more predictable.",
          "tags": [
            "React Architecture",
            "Data Flow",
            "Principles"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_refs_1",
          "topic": "Refs - Purpose",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of `Refs` in React?",
          "answer": "To provide a way to access DOM nodes or React components created in the render method.",
          "options": [
            "To manage component state declaratively.",
            "To provide a way to access DOM nodes or React components created in the render method.",
            "To facilitate component-to-component communication for shared data.",
            "To replace the need for props in data passing."
          ],
          "analysisPoints": [
            "Refs are an escape hatch for imperative interactions, not for declarative state.",
            "Refs allow direct access to underlying DOM or component instances.",
            "Component communication is primarily via props and state, not refs.",
            "Refs complement props; they don't replace them."
          ],
          "keyConcepts": [
            "Refs",
            "DOM Access",
            "Imperative Programming"
          ],
          "evaluationCriteria": [
            "Understanding the core function of refs."
          ],
          "example": "```typescript\nimport React, { useRef, useEffect } from 'react';\n\nfunction MyInput() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // Directly access the DOM node to focus it after mount\n    inputRef.current.focus();\n  }, []);\n\n  return <input type=\"text\" ref={inputRef} />;\n}\n```\nThis example shows `inputRef.current.focus()` directly manipulating the DOM node to set focus, which is a classic use case for refs.",
          "tags": [
            "React Refs",
            "Fundamentals"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_refs_2",
          "topic": "Refs - Use Cases",
          "level": "medium",
          "type": "open",
          "question": "List at least three specific use cases where using `Refs` is appropriate in React, as opposed to relying solely on state and props.",
          "answer": "1.  **Managing Focus, Text Selection, or Media Playback:** For example, programmatically setting focus on an input field when a component mounts, selecting all text in a textbox, or controlling a `<video>` or `<audio>` element (play, pause, volume).\n2.  **Triggering Imperative Animations:** When integrating with animation libraries that directly manipulate the DOM (e.g., GreenSock (GSAP)) or performing low-level DOM animations that are not easily managed through React's declarative state.\n3.  **Integrating with Third-Party DOM Libraries:** When you need to interact with external JavaScript libraries (like charting libraries, map libraries, or advanced UI widgets) that expect a direct DOM element reference to initialize or operate upon.",
          "options": [],
          "analysisPoints": [
            "Ability to recall specific, appropriate use cases for refs.",
            "Distinction between imperative ref usage and declarative state/prop management.",
            "Clarity and conciseness of examples."
          ],
          "keyConcepts": [
            "Refs Use Cases",
            "Imperative Programming",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Knowledge of practical scenarios for ref usage.",
            "Understanding of React's architectural philosophy."
          ],
          "example": "",
          "tags": [
            "React Refs",
            "Best Practices",
            "DOM"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_refs_3",
          "topic": "Refs - `useRef` vs `createRef`",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements correctly describes the difference between `React.createRef()` and `useRef()` in React?",
          "answer": "`React.createRef()` is used in class components, while `useRef()` is a Hook used in functional components.",
          "options": [
            "`React.createRef()` is for DOM elements, while `useRef()` is for React components.",
            "`React.createRef()` is used for mutable values, while `useRef()` is for immutable values.",
            "`React.createRef()` causes a re-render when its value changes, while `useRef()` does not.",
            "`React.createRef()` is used in class components, while `useRef()` is a Hook used in functional components."
          ],
          "analysisPoints": [
            "The primary distinction is their usage context: `createRef` for classes, `useRef` for hooks/functional components.",
            "Both can refer to DOM elements or component instances.",
            "Both `current` properties are mutable.",
            "Neither `createRef` nor `useRef` directly cause re-renders when their `current` property changes. Re-renders are triggered by state or prop changes."
          ],
          "keyConcepts": [
            "Refs",
            "Hooks",
            "Class Components",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Understanding of ref creation mechanisms in different component types.",
            "Knowledge of React Hooks principles."
          ],
          "example": "```typescript\n// Class component using createRef\nclass MyClassComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.myRef = React.createRef();\n  }\n  render() {\n    return <div ref={this.myRef} />; // this.myRef.current will be the div\n  }\n}\n\n// Functional component using useRef\nfunction MyFunctionalComponent() {\n  const myRef = useRef(null);\n  return <div ref={myRef} />; // myRef.current will be the div\n}\n```",
          "tags": [
            "React Hooks",
            "Class Components",
            "Functional Components",
            "Refs"
          ],
          "prerequisites": [
            "react_class_components",
            "react_functional_components",
            "react_hooks_overview"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_refs_4",
          "topic": "Refs - `forwardRef`",
          "level": "hard",
          "type": "code",
          "question": "You have a `CustomButton` functional component that renders a native `<button>` element. How would you modify `CustomButton` so that a parent component can obtain a ref to the *native button DOM element* inside `CustomButton`?",
          "answer": "```typescript\nimport React, { forwardRef } from 'react';\n\n// CustomButton now accepts a ref prop and forwards it to the native button.\nconst CustomButton = forwardRef(({ children, ...props }, ref) => (\n  <button ref={ref} {...props}>\n    {children}\n  </button>\n));\n\n// Parent component using CustomButton\nfunction ParentComponent() {\n  const buttonRef = React.useRef(null);\n\n  const handleClick = () => {\n    if (buttonRef.current) {\n      buttonRef.current.focus(); // Example: Focusing the button\n      console.log('Button clicked:', buttonRef.current.textContent);\n    }\n  };\n\n  return (\n    <div>\n      <CustomButton ref={buttonRef} onClick={handleClick}>\n        Click Me to Focus\n      </CustomButton>\n    </div>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "The solution correctly uses `React.forwardRef`.",
            "The `forwardRef` HOC passes `props` and `ref` as arguments to the functional component.",
            "The `ref` argument is then attached to the internal native DOM element (`<button>`).",
            "The parent component correctly uses `useRef` and passes the ref to the `CustomButton`."
          ],
          "keyConcepts": [
            "Refs",
            "forwardRef",
            "Functional Components",
            "DOM Access",
            "Higher-Order Components"
          ],
          "evaluationCriteria": [
            "Correct application of `forwardRef`.",
            "Understanding of ref propagation in functional components.",
            "Ability to solve common ref-related challenges."
          ],
          "example": "```typescript\n// Original CustomButton (does not forward ref)\n// function CustomButton({ children, onClick }) {\n//   return <button onClick={onClick}>{children}</button>;\n// }\n\n// Parent attempting to use ref (would fail):\n// function ParentComponent() {\n//   const btnRef = useRef(null);\n//   useEffect(() => {\n//     console.log(btnRef.current); // This would be null because ref isn't forwarded\n//   }, []);\n//   return <CustomButton ref={btnRef}>Test</CustomButton>;\n// }\n\n// Corrected with forwardRef:\nimport React, { useRef, forwardRef } from 'react';\n\nconst CustomButton = forwardRef(({ children, ...props }, ref) => (\n  <button ref={ref} {...props}>\n    {children}\n  </button>\n));\n\nfunction ParentComponent() {\n  const buttonRef = useRef(null);\n\n  const handleClick = () => {\n    if (buttonRef.current) {\n      buttonRef.current.focus(); // Works now!\n      alert('Button Focused!');\n    }\n  };\n\n  return (\n    <div>\n      <CustomButton ref={buttonRef} onClick={handleClick}>\n        Focus Button\n      </CustomButton>\n    </div>\n  );\n}\n```",
          "tags": [
            "React Code",
            "Refs",
            "forwardRef",
            "Hooks"
          ],
          "prerequisites": [
            "react_hooks_overview",
            "react_functional_components"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_refs_5",
          "topic": "Refs - When NOT to Use",
          "level": "medium",
          "type": "flashcard",
          "question": "True or False: It is generally a good practice to use refs to manage whether a component is visible or hidden.",
          "answer": "False",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Refs Best Practices",
            "Declarative UI",
            "State Management"
          ],
          "evaluationCriteria": [
            "Understanding of when refs are inappropriate."
          ],
          "example": "Managing visibility should be done using state and conditional rendering (e.g., `isVisible ? <Component /> : null`) or CSS classes based on state, not by directly manipulating DOM visibility via refs.",
          "tags": [
            "React Refs",
            "Best Practices"
          ],
          "prerequisites": [
            "react_conditional_rendering"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_refs_6",
          "topic": "Refs - `current` Property",
          "level": "easy",
          "type": "mcq",
          "question": "After attaching a ref object (`myRef = useRef(null)`) to an element `<input ref={myRef} />`, what does `myRef.current` refer to after the component mounts?",
          "answer": "The actual DOM node of the input element.",
          "options": [
            "The React component instance of the input.",
            "The props object passed to the input.",
            "The actual DOM node of the input element.",
            "The initial value passed to `useRef`."
          ],
          "analysisPoints": [
            "When a ref is attached to a native HTML element (like `input`, `div`, `button`), `myRef.current` will be the corresponding DOM element.",
            "If attached to a class component, `myRef.current` would be the instance of that component.",
            "It never refers to the props or the initial value of `useRef` (though the initial value is what `current` holds *before* being attached)."
          ],
          "keyConcepts": [
            "Refs",
            "useRef",
            "DOM Access",
            "current property"
          ],
          "evaluationCriteria": [
            "Understanding how refs provide access to elements."
          ],
          "example": "```typescript\nimport React, { useRef, useEffect } from 'react';\n\nfunction DOMAccessExample() {\n  const myInputRef = useRef(null);\n\n  useEffect(() => {\n    if (myInputRef.current) {\n      console.log(myInputRef.current); // Logs the <input> DOM element\n      myInputRef.current.value = 'Hello Ref!';\n    }\n  }, []);\n\n  return <input type=\"text\" ref={myInputRef} />;\n}\n```",
          "tags": [
            "React Refs",
            "DOM",
            "Hooks"
          ],
          "prerequisites": [
            "react_hooks_overview"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_lifting_state_up_1",
          "title": "Build a Color Picker with Shared Display",
          "description": "\nImplement a React application where multiple `ColorInput` components allow users to select a color, and a `ColorDisplay` component shows the currently selected color.\n\n**Requirements:**\n1.  Create a parent component (e.g., `App` or `ColorPickerContainer`) to manage the shared `selectedColor` state.\n2.  Create a `ColorInput` functional component that takes a `colorName` (e.g., 'Red', 'Green', 'Blue') and an `onColorSelect` callback as props. When clicked, it should call `onColorSelect` with its `colorName`.\n3.  Create a `ColorDisplay` functional component that takes `color` as a prop and renders a `div` with its background color set to the `color` prop and displays the color name.\n4.  The `ColorPickerContainer` should render at least three `ColorInput` components (e.g., for Red, Green, Blue) and one `ColorDisplay` component.\n5.  Clicking any `ColorInput` should update the `ColorDisplay` to show the chosen color.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// Parent component to manage shared state\nfunction ColorPickerContainer() {\n  // TODO: Implement shared state for selectedColor\n  // TODO: Implement handler to update selectedColor\n\n  return (\n    <div>\n      <h1>Color Picker</h1>\n      <div style={{ display: 'flex', gap: '10px', marginBottom: '20px' }}>\n        {/* TODO: Render ColorInput components */}\n        {/* Example: <ColorInput colorName=\"Red\" onColorSelect={handleColorSelect} /> */}\n      </div>\n      {/* TODO: Render ColorDisplay component */}\n    </div>\n  );\n}\n\n// Child component: ColorInput\nfunction ColorInput({ colorName, onColorSelect }) {\n  return (\n    <button \n      style={{\n        padding: '10px 20px',\n        backgroundColor: colorName,\n        color: 'white',\n        border: 'none',\n        borderRadius: '5px',\n        cursor: 'pointer'\n      }}\n      onClick={() => onColorSelect(colorName)}\n    >\n      {colorName}\n    </button>\n  );\n}\n\n// Child component: ColorDisplay\nfunction ColorDisplay({ color }) {\n  return (\n    <div \n      style={{\n        width: '200px',\n        height: '100px',\n        backgroundColor: color || 'lightgray',\n        border: '1px solid black',\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        color: color ? (['red', 'green', 'blue'].includes(color.toLowerCase()) ? 'white' : 'black') : 'black',\n        fontWeight: 'bold'\n      }}\n    >\n      {color ? `Selected: ${color}` : 'No Color Selected'}\n    </div>\n  );\n}\n\n// To render the application:\n// ReactDOM.render(<ColorPickerContainer />, document.getElementById('root'));",
          "solutionCode": "import React, { useState } from 'react';\n\n// Parent component to manage shared state\nfunction ColorPickerContainer() {\n  const [selectedColor, setSelectedColor] = useState('');\n\n  const handleColorSelect = (color) => {\n    setSelectedColor(color);\n  };\n\n  return (\n    <div>\n      <h1>Color Picker</h1>\n      <div style={{ display: 'flex', gap: '10px', marginBottom: '20px' }}>\n        <ColorInput colorName=\"Red\" onColorSelect={handleColorSelect} />\n        <ColorInput colorName=\"Green\" onColorSelect={handleColorSelect} />\n        <ColorInput colorName=\"Blue\" onColorSelect={handleColorSelect} />\n        <ColorInput colorName=\"Yellow\" onColorSelect={handleColorSelect} />\n      </div>\n      <ColorDisplay color={selectedColor} />\n    </div>\n  );\n}\n\n// Child component: ColorInput\nfunction ColorInput({ colorName, onColorSelect }) {\n  return (\n    <button \n      style={{\n        padding: '10px 20px',\n        backgroundColor: colorName,\n        color: colorName.toLowerCase() === 'yellow' ? 'black' : 'white',\n        border: 'none',\n        borderRadius: '5px',\n        cursor: 'pointer'\n      }}\n      onClick={() => onColorSelect(colorName)}\n    >\n      {colorName}\n    </button>\n  );\n}\n\n// Child component: ColorDisplay\nfunction ColorDisplay({ color }) {\n  return (\n    <div \n      style={{\n        width: '200px',\n        height: '100px',\n        backgroundColor: color || 'lightgray',\n        border: '1px solid black',\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        color: color ? (['red', 'green', 'blue'].includes(color.toLowerCase()) ? 'white' : 'black') : 'black',\n        fontWeight: 'bold'\n      }}\n    >\n      {color ? `Selected: ${color}` : 'No Color Selected'}\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: ColorDisplay should show 'No Color Selected' and have a lightgray background.",
            "Click 'Red' button: ColorDisplay should show 'Selected: Red' and have a red background.",
            "Click 'Green' button: ColorDisplay should show 'Selected: Green' and have a green background.",
            "Click 'Blue' button: ColorDisplay should show 'Selected: Blue' and have a blue background.",
            "Verify all `ColorInput` components are rendered and interactive."
          ],
          "hints": [
            "Remember to use `useState` in the parent for the `selectedColor`.",
            "The parent will need a function to update `selectedColor` that it passes down to `ColorInput` components.",
            "The `ColorDisplay` component simply receives the `selectedColor` as a prop."
          ],
          "tags": [
            "React",
            "State Management",
            "Lifting State Up",
            "Component Communication",
            "Hooks"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_state_hook",
            "react_props"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "unidirectional_data_flow",
            "single_source_of_truth"
          ]
        },
        {
          "id": "task_lifting_state_up_2",
          "title": "Implement a Shopping Cart Item Quantity Adjuster",
          "description": "\nCreate a simplified shopping cart item quantity adjuster where multiple displays for the same product need to show the same quantity.\n\n**Requirements:**\n1.  Create a `ProductItem` component that represents a single product in the cart. This component should display the product name and its quantity. It should also have 'Add' and 'Remove' buttons.\n2.  The `quantity` state should *not* be held within `ProductItem` directly. Instead, lift it up to a common parent component (e.g., `ShoppingCart`).\n3.  `ShoppingCart` should manage a map/object of product quantities (e.g., `{ 'Product A': 2, 'Product B': 1 }`).\n4.  `ProductItem` will receive `productName`, `quantity`, and `onQuantityChange` callback as props.\n5.  When 'Add' or 'Remove' is clicked in any `ProductItem`, the `ShoppingCart`'s state should be updated, and all relevant `ProductItem` components should reflect the new quantity.\n6.  Ensure the quantity cannot go below 0.\n7.  Add a `TotalItems` component that displays the sum of all quantities of all products.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\n\n// Parent component: ShoppingCart\nfunction ShoppingCart() {\n  // TODO: Manage product quantities here using useState\n  // Example: { 'Laptop': 1, 'Mouse': 2 }\n\n  const handleQuantityChange = (productName, change) => {\n    // TODO: Update the quantity for the given product\n  };\n\n  // TODO: Calculate total items\n  const totalItems = 0; \n\n  return (\n    <div>\n      <h1>Your Shopping Cart</h1>\n      {/* TODO: Render ProductItem components for different products */}\n      {/* Example: <ProductItem productName=\"Laptop\" quantity={quantities['Laptop']} onQuantityChange={handleQuantityChange} /> */}\n      <TotalItems total={totalItems} />\n    </div>\n  );\n}\n\n// Child component: ProductItem\nfunction ProductItem({ productName, quantity, onQuantityChange }) {\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n      <span>{productName}</span>\n      <div>\n        <button onClick={() => onQuantityChange(productName, -1)} disabled={quantity <= 0}>-</button>\n        <span style={{ margin: '0 10px' }}>{quantity}</span>\n        <button onClick={() => onQuantityChange(productName, 1)}>+</button>\n      </div>\n    </div>\n  );\n}\n\n// Another child component: TotalItems\nfunction TotalItems({ total }) {\n  return (\n    <h3 style={{ marginTop: '20px', borderTop: '1px solid #eee', paddingTop: '10px' }}>Total Items in Cart: {total}</h3>\n  );\n}\n\n// To render:\n// ReactDOM.render(<ShoppingCart />, document.getElementById('root'));",
          "solutionCode": "import React, { useState } from 'react';\n\n// Parent component: ShoppingCart\nfunction ShoppingCart() {\n  const [quantities, setQuantities] = useState({\n    'Laptop': 1,\n    'Mouse': 2,\n    'Keyboard': 0\n  });\n\n  const handleQuantityChange = (productName, change) => {\n    setQuantities(prevQuantities => {\n      const newQuantity = Math.max(0, prevQuantities[productName] + change);\n      return {\n        ...prevQuantities,\n        [productName]: newQuantity\n      };\n    });\n  };\n\n  const totalItems = Object.values(quantities).reduce((sum, qty) => sum + qty, 0);\n\n  return (\n    <div>\n      <h1>Your Shopping Cart</h1>\n      <ProductItem \n        productName=\"Laptop\" \n        quantity={quantities['Laptop']} \n        onQuantityChange={handleQuantityChange} \n      />\n      <ProductItem \n        productName=\"Mouse\" \n        quantity={quantities['Mouse']} \n        onQuantityChange={handleQuantityChange} \n      />\n      <ProductItem \n        productName=\"Keyboard\" \n        quantity={quantities['Keyboard']} \n        onQuantityChange={handleQuantityChange} \n      />\n      <TotalItems total={totalItems} />\n    </div>\n  );\n}\n\n// Child component: ProductItem\nfunction ProductItem({ productName, quantity, onQuantityChange }) {\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n      <span>{productName}</span>\n      <div>\n        <button onClick={() => onQuantityChange(productName, -1)} disabled={quantity <= 0}>-</button>\n        <span style={{ margin: '0 10px' }}>{quantity}</span>\n        <button onClick={() => onQuantityChange(productName, 1)}>+</button>\n      </div>\n    </div>\n  );\n}\n\n// Another child component: TotalItems\nfunction TotalItems({ total }) {\n  return (\n    <h3 style={{ marginTop: '20px', borderTop: '1px solid #eee', paddingTop: '10px' }}>Total Items in Cart: {total}</h3>\n  );\n}\n",
          "testCases": [
            "Initial render: 'Laptop' quantity 1, 'Mouse' quantity 2, 'Keyboard' quantity 0. Total Items: 3.",
            "Click '+' for 'Laptop': 'Laptop' quantity should become 2. Total Items should become 4.",
            "Click '-' for 'Mouse': 'Mouse' quantity should become 1. Total Items should become 3.",
            "Click '-' for 'Keyboard' (initially 0): 'Keyboard' quantity should remain 0, and the '-' button should be disabled.",
            "Repeatedly click '-' for 'Laptop' until quantity is 0: Quantity should not go below 0, and '-' button should disable."
          ],
          "hints": [
            "The `useState` in `ShoppingCart` should hold an object where keys are product names and values are quantities.",
            "When updating the `quantities` state, remember to create a new object using the spread operator (`...prevQuantities`) to ensure immutability.",
            "The `reduce` method is useful for calculating the `totalItems` from the `quantities` object values."
          ],
          "tags": [
            "React",
            "State Management",
            "Lifting State Up",
            "Complex State",
            "Functional Programming"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_state_hook",
            "react_props",
            "javascript_object_methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "unidirectional_data_flow",
            "immutable_updates"
          ]
        },
        {
          "id": "task_refs_1",
          "title": "Implement an Auto-Focusing Input Field",
          "description": "\nCreate a React component that renders an input field and automatically focuses on it when the component mounts.\n\n**Requirements:**\n1.  Use a functional component.\n2.  Utilize the `useRef` hook to get a reference to the input DOM element.\n3.  Use the `useEffect` hook to trigger the focus action after the component has rendered for the first time.\n4.  Ensure that the input is truly focused (e.g., you can immediately start typing).\n",
          "difficulty": "easy",
          "startingCode": "import React, { useRef, useEffect } from 'react';\n\nfunction AutoFocusInput() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // TODO: Use inputRef to focus the input element\n  }, []); // Empty dependency array means it runs once after initial render\n\n  return (\n    <div>\n      <label>Your Name:</label>\n      <input type=\"text\" ref={inputRef} />\n    </div>\n  );\n}\n\n// To render:\n// ReactDOM.render(<AutoFocusInput />, document.getElementById('root'));",
          "solutionCode": "import React, { useRef, useEffect } from 'react';\n\nfunction AutoFocusInput() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []);\n\n  return (\n    <div>\n      <h2>Auto-Focus Input</h2>\n      <label>Your Name:</label>\n      <input type=\"text\" ref={inputRef} placeholder=\"Type here...\"/>\n    </div>\n  );\n}\n",
          "testCases": [
            "Component mounts: The input field should immediately gain focus.",
            "Verify you can type into the input without manually clicking on it after the page loads."
          ],
          "hints": [
            "The `useRef` hook returns an object with a `current` property that holds the DOM element.",
            "The `focus()` method is a standard DOM API method available on input elements.",
            "An empty dependency array `[]` in `useEffect` ensures the effect runs only once after the initial render, similar to `componentDidMount`."
          ],
          "tags": [
            "React",
            "Refs",
            "Hooks",
            "useEffect",
            "DOM Manipulation"
          ],
          "timeEstimate": 15,
          "prerequisites": [
            "react_hooks_overview",
            "react_functional_components"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "imperative_programming"
          ]
        },
        {
          "id": "task_refs_2",
          "title": "Implement a Basic Video Player Controls",
          "description": "\nCreate a simple video player component with play and pause buttons using React refs to control the `<video>` element.\n\n**Requirements:**\n1.  Create a functional component `VideoPlayer`.\n2.  Inside `VideoPlayer`, render a `<video>` element (you can use a placeholder video URL or a local one). Give it `controls={false}` so you manage playback programmatically.\n3.  Use `useRef` to get a reference to the `<video>` DOM element.\n4.  Implement two buttons: 'Play' and 'Pause'.\n5.  When the 'Play' button is clicked, call the `play()` method on the video element via its ref.\n6.  When the 'Pause' button is clicked, call the `pause()` method on the video element via its ref.\n7.  Add a `src` attribute to the video tag, you can use `http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4` for testing.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useRef } from 'react';\n\nfunction VideoPlayer() {\n  const videoRef = useRef(null);\n\n  const handlePlay = () => {\n    // TODO: Implement play logic using videoRef\n  };\n\n  const handlePause = () => {\n    // TODO: Implement pause logic using videoRef\n  };\n\n  return (\n    <div>\n      <h2>My Custom Video Player</h2>\n      <video \n        ref={videoRef}\n        width=\"640\" \n        height=\"360\" \n        controls={false}\n        src=\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"\n      >\n        Your browser does not support the video tag.\n      </video>\n      <div style={{ marginTop: '10px' }}>\n        <button onClick={handlePlay} style={{ marginRight: '10px' }}>Play</button>\n        <button onClick={handlePause}>Pause</button>\n      </div>\n    </div>\n  );\n}\n\n// To render:\n// ReactDOM.render(<VideoPlayer />, document.getElementById('root'));",
          "solutionCode": "import React, { useRef } from 'react';\n\nfunction VideoPlayer() {\n  const videoRef = useRef(null);\n\n  const handlePlay = () => {\n    if (videoRef.current) {\n      videoRef.current.play();\n    }\n  };\n\n  const handlePause = () => {\n    if (videoRef.current) {\n      videoRef.current.pause();\n    }\n  };\n\n  return (\n    <div>\n      <h2>My Custom Video Player</h2>\n      <video \n        ref={videoRef}\n        width=\"640\" \n        height=\"360\" \n        controls={false}\n        src=\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"\n      >\n        Your browser does not support the video tag.\n      </video>\n      <div style={{ marginTop: '10px' }}>\n        <button onClick={handlePlay} style={{ marginRight: '10px' }}>Play</button>\n        <button onClick={handlePause}>Pause</button>\n      </div>\n    </div>\n  );\n}\n",
          "testCases": [
            "Component renders: Video should be present but not playing (due to `controls={false}`).",
            "Click 'Play' button: Video should start playing.",
            "Click 'Pause' button while playing: Video should pause.",
            "Click 'Play' button again after pausing: Video should resume playing."
          ],
          "hints": [
            "The `videoRef.current` will be the HTMLVideoElement, which has `play()` and `pause()` methods.",
            "Always check `if (videoRef.current)` before trying to access its methods, as `current` might be null if the element hasn't mounted yet or the ref isn't properly assigned."
          ],
          "tags": [
            "React",
            "Refs",
            "Hooks",
            "Media Playback",
            "DOM Manipulation"
          ],
          "timeEstimate": 25,
          "prerequisites": [
            "react_hooks_overview",
            "react_functional_components"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "imperative_animations",
            "third_party_dom_libraries"
          ]
        },
        {
          "id": "task_refs_3",
          "title": "Create a Scroll-to-Top Button for a Long Content Page",
          "description": "\nImplement a 'Scroll to Top' button that appears when the user scrolls down a long page and, when clicked, smoothly scrolls the page back to the top.\n\n**Requirements:**\n1.  Create a `LongContentPage` component that contains enough content to require scrolling (e.g., several paragraphs or `div`s with `height`).\n2.  Implement a `ScrollToTopButton` component. This component should:\n    a.  Be a functional component.\n    b.  Use `useState` to control its visibility (e.g., `showButton`).\n    c.  Use `useEffect` and `window.addEventListener('scroll', ...)` to update `showButton` based on scroll position (e.g., show if `window.scrollY > 200px`). Remember to clean up the event listener.\n    d.  When clicked, it should smoothly scroll the window to the top using `window.scrollTo()` with `behavior: 'smooth'`.\n3.  Render `ScrollToTopButton` within `LongContentPage`.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// Parent component with long content\nfunction LongContentPage() {\n  return (\n    <div style={{ height: '2000px', background: 'linear-gradient(to bottom, #f0f0f0, #ccc)' }}>\n      <h1>Long Page Content</h1>\n      {Array.from({ length: 50 }).map((_, i) => (\n        <p key={i}>This is paragraph {i + 1}. Scroll down to see the button appear!</p>\n      ))}\n      {/* TODO: Render ScrollToTopButton here */}\n    </div>\n  );\n}\n\n// ScrollToTopButton component\nfunction ScrollToTopButton() {\n  const [showButton, setShowButton] = useState(false);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      // TODO: Update showButton based on window.scrollY\n    };\n\n    // TODO: Add scroll event listener\n    // TODO: Return cleanup function for event listener\n  }, []);\n\n  const scrollToTop = () => {\n    // TODO: Implement smooth scroll to top\n  };\n\n  return (\n    <div\n      style={{\n        position: 'fixed',\n        bottom: '20px',\n        right: '20px',\n        padding: '10px 15px',\n        backgroundColor: '#007bff',\n        color: 'white',\n        borderRadius: '5px',\n        cursor: 'pointer',\n        display: showButton ? 'block' : 'none',\n        zIndex: 1000\n      }}\n      onClick={scrollToTop}\n    >\n      Scroll to Top\n    </div>\n  );\n}\n\n// To render:\n// ReactDOM.render(<LongContentPage />, document.getElementById('root'));",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// Parent component with long content\nfunction LongContentPage() {\n  return (\n    <div style={{ height: '2000px', background: 'linear-gradient(to bottom, #f0f0f0, #ccc)' }}>\n      <h1>Long Page Content</h1>\n      {Array.from({ length: 50 }).map((_, i) => (\n        <p key={i}>This is paragraph {i + 1}. Scroll down to see the button appear!</p>\n      ))}\n      <ScrollToTopButton />\n    </div>\n  );\n}\n\n// ScrollToTopButton component\nfunction ScrollToTopButton() {\n  const [showButton, setShowButton] = useState(false);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      // Show button if scrolled more than 200px\n      if (window.scrollY > 200) {\n        setShowButton(true);\n      } else {\n        setShowButton(false);\n      }\n    };\n\n    window.addEventListener('scroll', handleScroll);\n\n    // Cleanup the event listener when the component unmounts\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, []); // Empty dependency array ensures listener is added/removed once\n\n  const scrollToTop = () => {\n    window.scrollTo({\n      top: 0,\n      behavior: 'smooth'\n    });\n  };\n\n  return (\n    <div\n      style={{\n        position: 'fixed',\n        bottom: '20px',\n        right: '20px',\n        padding: '10px 15px',\n        backgroundColor: '#007bff',\n        color: 'white',\n        borderRadius: '5px',\n        cursor: 'pointer',\n        display: showButton ? 'block' : 'none',\n        zIndex: 1000,\n        boxShadow: '0 2px 5px rgba(0,0,0,0.2)'\n      }}\n      onClick={scrollToTop}\n    >\n      Scroll to Top\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: The 'Scroll to Top' button should NOT be visible.",
            "Scroll down past 200px: The button should become visible.",
            "Scroll back up above 200px: The button should disappear.",
            "Click the visible button: The page should smoothly scroll back to the top.",
            "Verify smooth scrolling functionality."
          ],
          "hints": [
            "You'll need `window.scrollY` to check the current scroll position.",
            "The `useEffect` hook with an empty dependency array `[]` is crucial for setting up and tearing down the `scroll` event listener correctly.",
            "`window.scrollTo({ top: 0, behavior: 'smooth' })` is the modern way to achieve smooth scrolling."
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Event Listeners",
            "DOM Manipulation",
            "Scroll"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_hooks_overview",
            "react_functional_components",
            "javascript_dom_events"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "refs_use_cases",
            "side_effects_in_react"
          ]
        }
      ]
    }
  },
  {
    "id": "59fc381d-1589-4a63-8766-4f40e6aba3fa",
    "startLine": 3900,
    "endLine": 3999,
    "processedDate": "2025-06-17T08:59:13.588Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_refs_overview",
          "title": "React Refs: Accessing DOM Nodes and React Elements",
          "content": "Refs provide a way to access DOM nodes or React elements created in the render method. In a typical React data flow, props are the only way parent components interact with their children. However, there are a few cases where you need to imperatively modify a child outside of the typical data flow. Refs are the solution for this.\n\n## When to Use Refs\nRefs are useful in scenarios where direct manipulation or access to a DOM element or component instance is necessary. Common use cases include:\n\n*   Managing focus, text selection, or media playback.\n*   Triggering imperative animations.\n*   Integrating with third-party DOM libraries.\n*   Working with uncontrolled components.\n\n## When NOT to Use Refs\nAvoid using refs for anything that can be done declaratively. For example, rather than using a ref to imperatively change a component's style, you should pass a prop to it. Props are the primary way to pass data down the component tree.",
          "examples": [],
          "relatedQuestions": [
            "question_react_refs_overview_1",
            "question_react_refs_overview_2",
            "question_react_refs_overview_3",
            "question_react_refs_overview_4"
          ],
          "relatedTasks": [],
          "tags": [
            "React",
            "Refs",
            "DOM",
            "Imperative Programming",
            "Component Interaction"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_props",
            "dom_basics"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "controlled_vs_uncontrolled_components",
            "integrating_third_party_libraries"
          ]
        },
        {
          "id": "theory_refs_class_components",
          "title": "Refs in Class Components: createRef and Callback Refs",
          "content": "In class components, refs can be created using `React.createRef()` or by using a 'callback ref'.\n\n### Using `React.createRef()`\n`React.createRef()` is the modern way to create refs in class components. It returns a ref object, and the ref is assigned to an instance property. This ref object's `.current` property will hold the actual DOM element or React component instance after the component mounts.\n\n**Initialization:**\n`this.myRef = React.createRef()` should be called in the constructor so that the ref is created once when the component instance is created.\n\n**Attaching to an Element:**\nThe ref object is then attached to a React element by passing it as the `ref` prop: `<div ref={this.myRef} />`.\n\n### Using Callback Refs\nCallback refs provide more fine-grained control over when refs are set and unset. Instead of passing a ref object, you pass a function to the `ref` attribute. This function receives the underlying DOM element or class component instance as its argument. React will call the ref callback with the DOM element when the component mounts, and call it with `null` when it unmounts. This ensures you can clean up any resources if necessary.\n\n**Syntax:**\n`<input ref={(element) => { this.textInput = element; }} />`\n\nWhile callback refs offer more control, `createRef()` is often simpler for common use cases.",
          "examples": [
            {
              "id": "example_class_component_createRef",
              "title": "Basic createRef in Class Component",
              "code": "import React from 'react';\n\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.myDivRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // Accessing the DOM node after mount\n    if (this.myDivRef.current) {\n      console.log('Div element:', this.myDivRef.current);\n      this.myDivRef.current.style.backgroundColor = 'lightblue';\n    }\n  }\n\n  render() {\n    return <div ref={this.myDivRef}>Hello, I'm a div!</div>;\n  }\n}",
              "explanation": "This example demonstrates how to create a ref using `React.createRef()` in a class component's constructor, attach it to a DOM element in the `render` method, and then access the underlying DOM node via `this.myDivRef.current` in `componentDidMount` to modify its style.",
              "language": "javascript"
            },
            {
              "id": "example_class_component_callbackRef",
              "title": "Callback Ref in Class Component",
              "code": "import React from 'react';\n\nclass AutoFocusInputCallbackRef extends React.Component {\n  constructor(props) {\n    super(props);\n    this.nameInput = null; // Initialize the ref holder\n  }\n\n  componentDidMount() {\n    // Focus the input using the callback ref\n    if (this.nameInput) {\n      this.nameInput.focus();\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <input\n          ref={(inputElement) => { this.nameInput = inputElement; }}\n          defaultValue={'Focused with Callback Ref'}\n        />\n      </div>\n    );\n  }\n}",
              "explanation": "This example uses a callback ref. The `ref` prop is a function that receives the DOM `inputElement` when the component mounts, which is then stored in `this.nameInput`. This allows the `componentDidMount` lifecycle method to imperatively call `focus()` on the input.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_class_refs_1",
            "question_class_refs_2",
            "question_class_refs_3",
            "question_class_refs_4",
            "question_class_refs_5"
          ],
          "relatedTasks": [
            "task_class_component_ref_focus"
          ],
          "tags": [
            "React",
            "Refs",
            "Class Components",
            "createRef",
            "Callback Refs",
            "DOM Manipulation"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "react_lifecycle_methods"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "legacy_react_codebase",
            "uncontrolled_forms"
          ]
        },
        {
          "id": "theory_use_ref_hook",
          "title": "Refs in Functional Components: The `useRef` Hook",
          "content": "For functional components, React provides the `useRef` hook to work with refs. `useRef` is a powerful hook that serves multiple purposes beyond just accessing DOM elements.\n\n### How `useRef` Works\n`useRef` returns a mutable ref object. This object has a `.current` property which is initialized to the argument passed to `useRef` (e.g., `useRef(null)`). The returned ref object will persist for the full lifetime of the component, meaning it won't be re-created on every render.\n\n**Key Characteristics of `useRef`:**\n\n*   **Mutable:** Unlike state, `useRef` allows you to directly mutate its `.current` property. `ref.current = newValue` is a valid operation.\n*   **No Re-renders:** Changing a ref's `.current` property *does not* trigger a re-render of the component. This is a crucial distinction from `useState`.\n*   **Lifetime:** The ref object persists across renders, maintaining its `.current` value.\n*   **Versatility:** While often used for DOM access, `useRef` is perfect for storing any mutable value that doesn't affect the visual output of your component and doesn't need to trigger re-renders. This can include timers (e.g., `setInterval` IDs), mutable objects, or previous values of props/state.",
          "examples": [
            {
              "id": "example_useRef_focus_input",
              "title": "Focusing Input with `useRef` Hook",
              "code": "import React, { useRef } from 'react';\n\nfunction TextInputWithFocusButton() {\n  const inputRef = useRef(null);\n  \n  const focusTextInput = () => {\n    // Explicitly focus the text input using the raw DOM API\n    // Note: we're accessing \"current\" to get the DOM node\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  };\n  \n  return (\n    <>\n      <input type=\"text\" ref={inputRef} />\n      <button onClick={focusTextInput}>Focus the input</button>\n    </>\n  );\n}",
              "explanation": "This example demonstrates the primary use case of `useRef` for DOM manipulation. An `inputRef` is created, attached to the `<input>` element, and then its `.current` property is used within the `focusTextInput` handler to call the native DOM `focus()` method.",
              "language": "javascript"
            },
            {
              "id": "example_useRef_store_value",
              "title": "Storing Mutable Value with `useRef`",
              "code": "import React, { useRef, useState } from 'react';\n\nfunction CounterWithNoRerenderRef() {\n  const counterRef = useRef(0); // Initialize with 0\n  const [renderCount, setRenderCount] = useState(0);\n\n  const incrementRefCounter = () => {\n    counterRef.current++;\n    console.log('Ref Counter:', counterRef.current);\n  };\n\n  return (\n    <div>\n      <p>Ref Counter (does not re-render): {counterRef.current}</p>\n      <button onClick={incrementRefCounter}>Increment Ref Counter</button>\n      <button onClick={() => setRenderCount(prev => prev + 1)}>Force Re-render ({renderCount})</button>\n      <p>Click 'Force Re-render' to see updated Ref Counter display.</p>\n    </div>\n  );\n}",
              "explanation": "This advanced example shows `useRef` used for storing a mutable value (`counterRef.current`) that does not trigger a re-render. The `Ref Counter` displayed on screen only updates when a `useState`-driven re-render is explicitly triggered (e.g., by clicking 'Force Re-render'), highlighting the difference between `useRef` and `useState`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_use_ref_1",
            "question_use_ref_2",
            "question_use_ref_3",
            "question_use_ref_4",
            "question_use_ref_5",
            "question_use_ref_6"
          ],
          "relatedTasks": [
            "task_autofocus_functional_component",
            "task_timer_with_ref"
          ],
          "tags": [
            "React Hooks",
            "useRef",
            "Functional Components",
            "Mutable Values",
            "DOM Manipulation",
            "No Re-render"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "complex_form_management",
            "performance_optimization_in_hooks",
            "integrating_non_react_libraries"
          ]
        },
        {
          "id": "theory_autofocus_with_refs",
          "title": "Focusing an Input Element with Refs (Auto-Focus)",
          "content": "A very common and practical application of refs is to programmatically focus an input element, often when a component mounts or after a certain user action. This is particularly useful for user experience in forms, such as login fields or search bars, where you want to place the cursor immediately for user convenience.\n\n### Class Component Approach\nIn class components, you typically use `componentDidMount` to perform side effects like focusing. After the component has mounted and the ref has been assigned the DOM node, you can call the `focus()` method on it.\n\n### Functional Component Approach with `useRef` and `useEffect`\nIn functional components, the `useEffect` hook is the equivalent of lifecycle methods like `componentDidMount` and `componentDidUpdate`. To focus an input on mount, you'd use `useEffect` with an empty dependency array (`[]`), ensuring the effect runs only once after the initial render. The `useRef` hook creates the ref object, and `useEffect` accesses its `.current` property to call `focus()`.\n\nIt's important to always check if `ref.current` is not `null` before attempting to interact with it, as refs are `null` initially and only populated after the component renders and the DOM node is available.",
          "examples": [
            {
              "id": "example_autofocus_class_component",
              "title": "Auto-Focus in Class Component",
              "code": "import React from 'react';\n\nclass AutoFocusInputClass extends React.Component {\n  componentDidMount() {\n    // Using a callback ref for simplicity here, as seen in original content\n    if (this.nameInput) {\n      this.nameInput.focus();\n    }\n  }\n  \n  render() {\n    return (\n      <div>\n        <input\n          ref={(input) => this.nameInput = input} // Callback ref\n          defaultValue={'Will be focused on mount (Class)'}\n        />\n      </div>\n    );\n  }\n}",
              "explanation": "This example demonstrates auto-focusing an input in a class component using a callback ref. The `componentDidMount` lifecycle method is used to ensure the DOM element is available before attempting to call `focus()`.",
              "language": "javascript"
            },
            {
              "id": "example_autofocus_functional_component",
              "title": "Auto-Focus in Functional Component with `useRef` and `useEffect`",
              "code": "import React, { useRef, useEffect } from 'react';\n\nconst AutoFocusInputFunc = () => {\n  // Create a ref\n  const inputRef = useRef(null);\n  \n  // Focus the input element after component mounts\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Empty dependency array ensures this runs once after mount\n  \n  return (\n    <div>\n      <input\n        ref={inputRef}\n        defaultValue={'Will be focused on mount (Functional)'}\n      />\n    </div>\n  );\n};",
              "explanation": "This example shows how to achieve auto-focus in a functional component. `useRef` creates the mutable ref object, and `useEffect` with an empty dependency array executes the `focus()` call once the component has rendered and the ref's `.current` property has been assigned the DOM `input` element.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_autofocus_1",
            "question_autofocus_2",
            "question_autofocus_3"
          ],
          "relatedTasks": [
            "task_autofocus_functional_component"
          ],
          "tags": [
            "React",
            "Refs",
            "useRef",
            "useEffect",
            "DOM Manipulation",
            "Focus",
            "User Experience"
          ],
          "technology": "React",
          "prerequisites": [
            "react_hooks_basics",
            "react_lifecycle_methods"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "form_development",
            "accessibility"
          ]
        },
        {
          "id": "theory_uncontrolled_components",
          "title": "Uncontrolled Components with Refs",
          "content": "In React, form components are typically 'controlled components,' meaning their values are handled by React state, and every state update triggers a re-render. While this is the recommended approach for most form inputs, sometimes you might want to integrate with non-React code or if you need to access a form value once, without managing its state throughout its lifecycle. This is where 'uncontrolled components' come in.\n\n### What are Uncontrolled Components?\nUncontrolled components are form components where the form data is handled by the DOM itself, not by React. Instead of writing an event handler for every state update, you use a ref to get the form value directly from the DOM when you need it (e.g., when the form is submitted). This can sometimes make integration with non-React libraries or legacy code easier.\n\n### How Refs are Used\nFor uncontrolled components, you attach a ref to the form input element. When the form is submitted or a specific action occurs, you access `ref.current.value` (for `<input>`, `<textarea>`) or `ref.current.files` (for `<input type='file'>`) to retrieve the current value directly from the DOM element.\n\n**Contrast with Controlled Components:**\n*   **Controlled:** React state is the single source of truth. Updates happen via `onChange` and `setState`. Re-renders occur on every input change.\n*   **Uncontrolled:** DOM is the single source of truth. Values are retrieved via refs when needed. No re-renders on input change, only when values are explicitly accessed.",
          "examples": [
            {
              "id": "example_uncontrolled_form",
              "title": "Basic Uncontrolled Form with Class Component",
              "code": "import React from 'react';\n\nclass UncontrolledForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.nameInput = React.createRef();\n    this.fileInput = React.createRef();\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleSubmit(event) {\n    event.preventDefault();\n    // Access values directly from the DOM using refs\n    const name = this.nameInput.current.value;\n    const file = this.fileInput.current.files[0];\n\n    alert(`Name: ${name}\\nSelected file: ${file ? file.name : 'No file'}`);\n    console.log('Name:', name);\n    console.log('File:', file);\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" ref={this.nameInput} defaultValue=\"John Doe\" />\n        </label>\n        <br />\n        <label>\n          Upload File:\n          <input type=\"file\" ref={this.fileInput} />\n        </label>\n        <br />\n        <button type=\"submit\">Submit</button>\n      </form>\n    );\n  }\n}",
              "explanation": "This example demonstrates an uncontrolled form in a class component. `React.createRef()` is used to create refs for an input and a file input. When the form is submitted, the `handleSubmit` method directly accesses the current values from the DOM elements via `this.nameInput.current.value` and `this.fileInput.current.files`, without needing to manage their state in React.",
              "language": "javascript"
            },
            {
              "id": "example_uncontrolled_form_functional",
              "title": "Basic Uncontrolled Form with Functional Component",
              "code": "import React, { useRef } from 'react';\n\nconst UncontrolledFormFunc = () => {\n  const nameInputRef = useRef(null);\n  const fileInputRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    const name = nameInputRef.current.value;\n    const file = fileInputRef.current.files[0];\n\n    alert(`Name: ${name}\\nSelected file: ${file ? file.name : 'No file'}`);\n    console.log('Name:', name);\n    console.log('File:', file);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Name:\n        <input type=\"text\" ref={nameInputRef} defaultValue=\"Jane Doe\" />\n      </label>\n      <br />\n      <label>\n        Upload File:\n        <input type=\"file\" ref={fileInputRef} />\n      </label>\n      <br />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};",
              "explanation": "This functional component example mirrors the uncontrolled form behavior using `useRef`. The refs `nameInputRef` and `fileInputRef` are attached to the respective inputs, and their `.current` property is accessed directly within the `handleSubmit` function to retrieve the form values.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_uncontrolled_1",
            "question_uncontrolled_2",
            "question_uncontrolled_3",
            "question_uncontrolled_4"
          ],
          "relatedTasks": [
            "task_uncontrolled_login_form"
          ],
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "Refs",
            "useRef",
            "Controlled vs Uncontrolled"
          ],
          "technology": "React",
          "prerequisites": [
            "react_forms",
            "react_state"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "form_optimization",
            "integration_with_dom_libraries"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_react_refs_overview_1",
          "topic": "Introduction to React Refs",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of React Refs?",
          "answer": "Refs provide a way to access DOM nodes or React elements created in the render method, allowing imperative modifications outside of the typical React data flow.",
          "options": [],
          "analysisPoints": [
            "Understanding of when direct DOM interaction is needed.",
            "Recognition that refs are an escape hatch from declarative React.",
            "Differentiating between typical data flow (props) and refs."
          ],
          "keyConcepts": [
            "Refs",
            "DOM Access",
            "Imperative Programming",
            "React Data Flow"
          ],
          "evaluationCriteria": [
            "Correctly identifies the core function of refs."
          ],
          "example": "",
          "tags": [
            "React",
            "Refs",
            "Basics"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_refs_overview_2",
          "topic": "Use Cases for Refs",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following scenarios is a valid and common use case for React Refs?\n\nA. Managing the state of a complex form input that updates on every keystroke.\nB. Passing data from a parent component to a child component.\nC. Programmatically focusing an input field when a component mounts.\nD. Styling a component's background color based on a prop.",
          "answer": "C. Programmatically focusing an input field when a component mounts.",
          "options": [
            "A. Managing the state of a complex form input that updates on every keystroke.",
            "B. Passing data from a parent component to a child component.",
            "C. Programmatically focusing an input field when a component mounts.",
            "D. Styling a component's background color based on a prop."
          ],
          "analysisPoints": [
            "Distinguishes between declarative (props, state) and imperative (refs) operations.",
            "Identifies common imperative DOM manipulations appropriate for refs.",
            "Avoids using refs for tasks better handled by state or props."
          ],
          "keyConcepts": [
            "Refs",
            "Controlled Components",
            "Props",
            "DOM Manipulation",
            "Best Practices"
          ],
          "evaluationCriteria": [
            "Correctly identifies appropriate use of refs.",
            "Demonstrates understanding of React's declarative nature."
          ],
          "example": "Option A describes a controlled component, best handled by React state. Option B is the primary use case for props. Option D is a declarative styling choice, also handled by props or state. Option C, focusing an input, is a classic imperative DOM operation that refs are designed for.",
          "tags": [
            "React",
            "Refs",
            "Use Cases",
            "Best Practices"
          ],
          "prerequisites": [
            "react_state",
            "react_props"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_refs_overview_3",
          "topic": "Ref vs. State",
          "level": "medium",
          "type": "open",
          "question": "Explain the key differences between `useState` and `useRef` in React functional components, specifically focusing on how they handle value updates and component re-renders.",
          "answer": "While both `useState` and `useRef` can store values, their primary differences lie in mutability and effect on re-renders.\n\n1.  **Re-rendering:**\n    *   `useState`: When the setter function (`setSomething`) is called to update state, it queues a re-render of the component and its children. This is ideal for values that affect the component's visual output.\n    *   `useRef`: Changing the `.current` property of a ref object (`ref.current = newValue`) *does not* trigger a re-render of the component. This makes it suitable for storing values that need to persist across renders but do not directly influence the UI, such as timer IDs, DOM elements, or mutable objects.\n\n2.  **Mutability:**\n    *   `useState`: State values are generally treated as immutable. You update state by replacing the old value with a new one using the setter function. Direct mutation of state (e.g., `state.property = value`) is a common anti-pattern that can lead to bugs.\n    *   `useRef`: The `.current` property of a ref object is mutable. You can directly assign a new value to it (`ref.current = newValue`). The ref object itself (`myRef`) remains the same across renders, but its `current` property can change.\n\n3.  **Persistence:**\n    *   Both persist across renders. State values are managed by React and persist. Ref objects are also guaranteed to persist for the entire lifetime of the component.",
          "options": [],
          "analysisPoints": [
            "Distinguishes between re-render behavior of state and refs.",
            "Explains the mutability characteristics of each.",
            "Provides clear use cases for each based on their behavior."
          ],
          "keyConcepts": [
            "useState",
            "useRef",
            "State Management",
            "Component Lifecycle",
            "Re-renders",
            "Mutability"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of explanation.",
            "Ability to articulate the core behavioral differences.",
            "Demonstrates understanding of React's rendering mechanism."
          ],
          "example": "",
          "tags": [
            "React Hooks",
            "useState",
            "useRef",
            "Comparison",
            "Core Concepts"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_state"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_refs_overview_4",
          "topic": "When to avoid Refs",
          "level": "easy",
          "type": "flashcard",
          "question": "When should you generally AVOID using React Refs?",
          "answer": "You should avoid using refs for anything that can be done declaratively with props and state. For example, changing a component's style or content based on dynamic data should be handled by props/state, not refs.",
          "options": [],
          "analysisPoints": [
            "Reinforces understanding of React's declarative paradigm.",
            "Highlights the 'escape hatch' nature of refs.",
            "Encourages best practices in React development."
          ],
          "keyConcepts": [
            "Refs",
            "Declarative Programming",
            "Props",
            "State",
            "Best Practices"
          ],
          "evaluationCriteria": [
            "Identifies the core principle of when to avoid refs."
          ],
          "example": "",
          "tags": [
            "React",
            "Refs",
            "Best Practices"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_class_refs_1",
          "topic": "Refs in Class Components: createRef",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you create a ref in a React class component using the modern API?",
          "answer": "You create a ref using `React.createRef()` and assign it to an instance property in the component's constructor, e.g., `this.myRef = React.createRef();`",
          "options": [],
          "analysisPoints": [
            "Recalls the specific method for creating refs in classes.",
            "Identifies the correct place for initialization (constructor)."
          ],
          "keyConcepts": [
            "Refs",
            "Class Components",
            "createRef"
          ],
          "evaluationCriteria": [
            "Correctly names the method and its usage."
          ],
          "example": "",
          "tags": [
            "React",
            "Class Components",
            "Refs"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_class_refs_2",
          "topic": "Refs in Class Components: Accessing `current`",
          "level": "easy",
          "type": "mcq",
          "question": "Given the following class component snippet, how would you access the underlying DOM `div` element to change its background color after it mounts?\n\n```javascript\nimport React from 'react';\n\nclass MyDivComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.divRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // CODE TO ACCESS DIV ELEMENT HERE\n  }\n\n  render() {\n    return <div ref={this.divRef}>Hello</div>;\n  }\n}\n```\n\nA. `this.divRef.style.backgroundColor = 'blue';`\nB. `this.divRef.domNode.style.backgroundColor = 'blue';`\nC. `this.divRef.current.style.backgroundColor = 'blue';`\nD. `document.getElementById('my-div').style.backgroundColor = 'blue';`",
          "answer": "C. `this.divRef.current.style.backgroundColor = 'blue';`",
          "options": [
            "A. `this.divRef.style.backgroundColor = 'blue';`",
            "B. `this.divRef.domNode.style.backgroundColor = 'blue';`",
            "C. `this.divRef.current.style.backgroundColor = 'blue';`",
            "D. `document.getElementById('my-div').style.backgroundColor = 'blue';`"
          ],
          "analysisPoints": [
            "Understands the `.current` property of a ref object.",
            "Recognizes how to interact with the underlying DOM element.",
            "Distinguishes between direct DOM manipulation and React's ref mechanism."
          ],
          "keyConcepts": [
            "Refs",
            "Class Components",
            "createRef",
            "DOM Access",
            "current property"
          ],
          "evaluationCriteria": [
            "Correctly uses the `.current` property.",
            "Demonstrates knowledge of ref object structure."
          ],
          "example": "The `divRef` object itself is not the DOM node; it's a plain JavaScript object with a `current` property that holds the DOM node after the component mounts. Option D is incorrect because it bypasses React entirely and relies on an ID that isn't present in the JSX.",
          "tags": [
            "React",
            "Class Components",
            "Refs",
            "DOM"
          ],
          "prerequisites": [
            "react_class_components",
            "react_createRef"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_refs_3",
          "topic": "Callback Refs",
          "level": "medium",
          "type": "open",
          "question": "Describe what a 'callback ref' is in React class components and explain a scenario where it might be preferred over `React.createRef()`.",
          "answer": "A callback ref is a function passed as the `ref` prop to a React element. This function receives the underlying DOM element or component instance as its argument. React calls this function with the element when it mounts and with `null` when it unmounts, allowing for setup and cleanup logic.\n\n**Scenario for Preference:**\nCallback refs are often preferred when you need more granular control over when the ref is set and unset, or when you need to integrate with external DOM libraries that require specific initialization/cleanup. For example, if you need to attach or detach event listeners or perform other imperative actions that require cleanup when the component unmounts, the callback ref naturally provides both the mounting (element provided) and unmounting (`null` provided) hooks for this.",
          "options": [],
          "analysisPoints": [
            "Defines callback ref correctly.",
            "Explains its mechanism (receives element, `null` on unmount).",
            "Identifies specific use cases for callback refs that leverage their unique behavior (cleanup, fine-grained control)."
          ],
          "keyConcepts": [
            "Refs",
            "Callback Refs",
            "Class Components",
            "DOM Manipulation",
            "Lifecycle"
          ],
          "evaluationCriteria": [
            "Accurate definition and functionality explanation.",
            "Provides a relevant and justified use case."
          ],
          "example": "",
          "tags": [
            "React",
            "Class Components",
            "Refs",
            "Callback Refs"
          ],
          "prerequisites": [
            "react_class_components",
            "react_createRef"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_refs_4",
          "topic": "Ref Assignment in Class Components",
          "level": "medium",
          "type": "code",
          "question": "Correct the following class component to properly create and use a ref to access the `input` element and log its value to the console when a button is clicked.\n\n```javascript\nimport React from 'react';\n\nclass MyForm extends React.Component {\n  // Missing constructor and ref creation\n\n  handleClick = () => {\n    // Incorrect ref access\n    console.log(this.myInputRef.value);\n  };\n\n  render() {\n    return (\n      <div>\n        <input type=\"text\" ref=\"myInputRef\" />\n        <button onClick={this.handleClick}>Log Input</button>\n      </div>\n    );\n  }\n}\n```",
          "answer": "```javascript\nimport React from 'react';\n\nclass MyForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.myInputRef = React.createRef(); // Correct: Create ref in constructor\n  }\n\n  handleClick = () => {\n    // Correct: Access DOM element via .current property\n    if (this.myInputRef.current) {\n      console.log(this.myInputRef.current.value);\n    }\n  };\n\n  render() {\n    return (\n      <div>\n        {/* Correct: Pass the ref object to the ref prop */}\n        <input type=\"text\" ref={this.myInputRef} />\n        <button onClick={this.handleClick}>Log Input</button>\n      </div>\n    );\n  }\n}\n```",
          "options": [],
          "analysisPoints": [
            "Identifies missing ref creation in the constructor.",
            "Correctly uses `React.createRef()`.",
            "Understands that the `ref` prop expects a ref *object*, not a string.",
            "Accesses the DOM element through the `.current` property of the ref.",
            "Includes a null check for `ref.current` (best practice)."
          ],
          "keyConcepts": [
            "Refs",
            "Class Components",
            "createRef",
            "DOM Access",
            "Error Handling"
          ],
          "evaluationCriteria": [
            "Produces runnable, correct code.",
            "Demonstrates understanding of ref lifecycle and access patterns.",
            "Applies best practices (null checks)."
          ],
          "example": "The original code had several issues: `this.myInputRef` was not initialized, passing a string to `ref` is a legacy pattern (string refs) and discouraged, and it attempted to access `value` directly on the ref object instead of its `.current` property.",
          "tags": [
            "React",
            "Class Components",
            "Refs",
            "Coding Challenge",
            "Debugging"
          ],
          "prerequisites": [
            "react_class_components",
            "react_createRef"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_refs_5",
          "topic": "String Refs (Legacy)",
          "level": "hard",
          "type": "mcq",
          "question": "Which of the following is true about string refs (`ref=\"myRefString\"`) in React?\n\nA. They are the recommended way to use refs in modern React applications.\nB. They are automatically cleared to `null` by React after unmounting, similar to callback refs.\nC. They have some caveats, such as not allowing component composition and being generally discouraged in favor of `React.createRef()` or `useRef()`.\nD. They can directly access a component's state and props.",
          "answer": "C. They have some caveats, such as not allowing component composition and being generally discouraged in favor of `React.createRef()` or `useRef()`.",
          "options": [
            "A. They are the recommended way to use refs in modern React applications.",
            "B. They are automatically cleared to `null` by React after unmounting, similar to callback refs.",
            "C. They have some caveats, such as not allowing component composition and being generally discouraged in favor of `React.createRef()` or `useRef()`.",
            "D. They can directly access a component's state and props."
          ],
          "analysisPoints": [
            "Understands the legacy nature of string refs.",
            "Knows why string refs are discouraged (performance, composability issues).",
            "Distinguishes string refs from modern ref APIs.",
            "Correctly identifies that refs access DOM nodes/component instances, not internal state/props directly."
          ],
          "keyConcepts": [
            "Refs",
            "String Refs",
            "Legacy API",
            "Best Practices",
            "createRef",
            "useRef"
          ],
          "evaluationCriteria": [
            "Demonstrates knowledge of historical React ref patterns.",
            "Understands reasons for deprecation.",
            "Avoids common misconceptions about ref capabilities."
          ],
          "example": "String refs are a legacy API in React. They have minor performance implications and are problematic with hot reloading and component composition. React recommends using `React.createRef()` or `useRef()` instead. Refs provide access to the DOM node or component instance, not direct access to its internal state or props, which should be managed through standard React data flow.",
          "tags": [
            "React",
            "Refs",
            "Legacy",
            "Best Practices"
          ],
          "prerequisites": [
            "react_class_components",
            "react_hooks_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 5,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_ref_1",
          "topic": "useRef Hook Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What does the `useRef` hook return?",
          "answer": "`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument. This object persists for the full lifetime of the component.",
          "options": [],
          "analysisPoints": [
            "Identifies the return value as a mutable ref object.",
            "Recalls the `.current` property.",
            "Knows about its persistence across renders."
          ],
          "keyConcepts": [
            "useRef",
            "React Hooks",
            "Ref Object",
            "Current Property"
          ],
          "evaluationCriteria": [
            "Correctly identifies the structure and behavior of the returned object."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "Basics"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_ref_2",
          "topic": "useRef and Re-renders",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React functional component:\n\n```javascript\nimport React, { useRef, useState } from 'react';\n\nfunction MyComponent() {\n  const countRef = useRef(0);\n  const [renderCounter, setRenderCounter] = useState(0);\n\n  const incrementCount = () => {\n    countRef.current++;\n    console.log('Ref Count:', countRef.current);\n  };\n\n  return (\n    <div>\n      <p>Ref Count: {countRef.current}</p>\n      <button onClick={incrementCount}>Increment Ref Count</button>\n      <button onClick={() => setRenderCounter(prev => prev + 1)}>Force Re-render</button>\n    </div>\n  );\n}\n```\n\nWhat happens to the displayed 'Ref Count' value when the 'Increment Ref Count' button is clicked multiple times *without* clicking 'Force Re-render'?",
          "answer": "B. The `console.log` will show the updated value, but the displayed 'Ref Count' on the screen will not change until 'Force Re-render' is clicked.",
          "options": [
            "A. The displayed 'Ref Count' will immediately update on screen with each click, matching the `console.log` output.",
            "B. The `console.log` will show the updated value, but the displayed 'Ref Count' on the screen will not change until 'Force Re-render' is clicked.",
            "C. The `countRef.current` value will not increment at all because `useRef` cannot store mutable numbers.",
            "D. The component will re-render automatically, but the `countRef.current` value will reset to 0 on each re-render."
          ],
          "analysisPoints": [
            "Understands that changing `useRef().current` does not trigger a re-render.",
            "Differentiates `useRef` behavior from `useState`.",
            "Predicts the visual outcome based on React's rendering mechanism."
          ],
          "keyConcepts": [
            "useRef",
            "Re-renders",
            "useState",
            "Mutable Values",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Correctly identifies the re-render characteristic of `useRef`.",
            "Explains the discrepancy between internal state and displayed UI."
          ],
          "example": "This question directly tests the core characteristic of `useRef`: its `.current` property is mutable, but mutating it does not cause the component to re-render. Therefore, while `countRef.current` updates internally and in the console, the UI only reflects this update when a re-render is triggered by something else, like a `useState` update.",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "Re-renders",
            "State Management"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_state"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_ref_3",
          "topic": "useRef Use Cases Beyond DOM",
          "level": "medium",
          "type": "open",
          "question": "Besides accessing DOM elements, what are other common use cases for the `useRef` hook in React functional components? Provide an example for one such use case.",
          "answer": "Beyond DOM element access, `useRef` is commonly used for:\n\n1.  **Storing any mutable value that doesn't trigger a re-render:** This is useful for values that need to persist across renders but aren't part of the component's render output. Examples include timer IDs (from `setInterval` or `setTimeout`), previous values of props/state, or mutable objects that are part of an external library.\n2.  **Referencing a previous value of state or props:** You can store the current value of a prop or state in a ref, and in the next render, compare it to the current prop/state value to understand changes over time.\n\n**Example: Storing a Timer ID**\n```javascript\nimport React, { useRef, useEffect, useState } from 'react';\n\nfunction Timer() {\n  const intervalRef = useRef(null); // Stores the interval ID\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    intervalRef.current = setInterval(() => {\n      setCount(prevCount => prevCount + 1);\n    }, 1000);\n\n    return () => {\n      // Cleanup: Clear the interval when component unmounts\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, []); // Run only on mount and unmount\n\n  const stopTimer = () => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null; // Clear the ref\n    }\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={stopTimer}>Stop Timer</button>\n    </div>\n  );\n}\n```\nIn this example, `intervalRef` is used to hold the ID returned by `setInterval`. This ID is mutable and needs to persist across renders (so `useEffect`'s cleanup function can access it), but changing it doesn't need to cause a re-render of the component itself.",
          "options": [],
          "analysisPoints": [
            "Identifies multiple non-DOM use cases.",
            "Provides a clear and correct code example.",
            "Explains *why* `useRef` is suitable for the chosen example (persistence, no re-render)."
          ],
          "keyConcepts": [
            "useRef",
            "React Hooks",
            "Side Effects",
            "Persistence",
            "Timers",
            "useEffect"
          ],
          "evaluationCriteria": [
            "Comprehensive answer covering diverse use cases.",
            "Code example is relevant and functional.",
            "Demonstrates a deep understanding of `useRef`'s capabilities."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "Advanced Use Cases",
            "Side Effects"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_useEffect"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_ref_4",
          "topic": "Initializing useRef",
          "level": "easy",
          "type": "flashcard",
          "question": "When `useRef` is called, what value is its `.current` property initialized to?",
          "answer": "The `.current` property of the ref object returned by `useRef` is initialized to the argument passed to `useRef` (e.g., `useRef(null)` initializes `current` to `null`).",
          "options": [],
          "analysisPoints": [
            "Recalls the initialization behavior of `useRef`.",
            "Understands the direct correlation between argument and `.current` value."
          ],
          "keyConcepts": [
            "useRef",
            "Initialization",
            "current property"
          ],
          "evaluationCriteria": [
            "Correctly states the initialization value."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "Basics"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_ref_5",
          "topic": "Code Prediction with useRef",
          "level": "medium",
          "type": "code",
          "question": "What will be logged to the console when `ComponentA` is rendered and then its button is clicked? Assume this is the first time the component is mounted.",
          "answer": "```text\nInitial render: 0\nButton click: 1\n```",
          "options": [],
          "analysisPoints": [
            "Understands that `useRef` maintains its value across renders.",
            "Understands that changing `ref.current` does not trigger a re-render, so the `console.log` inside the component body runs only on the initial render, but the value inside the `handleClick` function will always be the latest.",
            "Differentiates between the value *during* render and the value *after* an event handler mutates it."
          ],
          "keyConcepts": [
            "useRef",
            "Re-renders",
            "Functional Components",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Correctly predicts console output.",
            "Demonstrates understanding of `useRef` persistence and re-render behavior."
          ],
          "example": "```javascript\nimport React, { useRef } from 'react';\n\nfunction ComponentA() {\n  const valueRef = useRef(0);\n\n  console.log('Initial render:', valueRef.current);\n\n  const handleClick = () => {\n    valueRef.current++;\n    console.log('Button click:', valueRef.current);\n  };\n\n  return (\n    <button onClick={handleClick}>Click Me</button>\n  );\n}\n\n// When <ComponentA /> is rendered:\n// 1. First render: valueRef.current is 0. 'Initial render: 0' is logged.\n// 2. Button click: valueRef.current becomes 1. 'Button click: 1' is logged. The component does NOT re-render due to ref change.\n// If the button is clicked again: valueRef.current becomes 2. 'Button click: 2' is logged. Still no re-render.\n```",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "Code Prediction",
            "Re-renders"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_ref_6",
          "topic": "When to choose useRef",
          "level": "hard",
          "type": "open",
          "question": "You need to implement a feature where a component should keep track of how many times it has rendered, but this count should not trigger any additional re-renders itself. Which React hook would you use and why?",
          "answer": "I would use the `useRef` hook. The `useRef` hook returns a mutable ref object whose `.current` property can be updated without causing a re-render of the component. This is perfect for storing a value like a render count, which needs to persist across renders but should not visually update the component simply by changing its value. If `useState` were used, every time the render count increased, it would trigger a re-render, leading to an infinite loop (as the render count would increment during the re-render process, triggering another re-render, and so on). `useRef` avoids this re-render cycle while still providing persistent storage.",
          "options": [],
          "analysisPoints": [
            "Identifies `useRef` as the correct hook.",
            "Clearly explains *why* `useRef` is suitable (no re-render on mutation).",
            "Contrasts with `useState` and explains the infinite loop issue if `useState` were mistakenly used.",
            "Demonstrates a nuanced understanding of React's rendering lifecycle."
          ],
          "keyConcepts": [
            "useRef",
            "useState",
            "Re-renders",
            "Component Lifecycle",
            "Performance Optimization",
            "Infinite Loops"
          ],
          "evaluationCriteria": [
            "Selects the optimal hook with a robust justification.",
            "Demonstrates understanding of potential pitfalls with `useState` in this scenario.",
            "Articulates the core difference between `useRef` and `useState` effectively."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "useState",
            "Architecture",
            "Optimization"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_state",
            "react_rendering_principles"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_autofocus_1",
          "topic": "Auto-Focus Implementation",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is the correct and idiomatic way to auto-focus an input element in a React functional component when it mounts?\n\nA.\n```javascript\nimport React, { useRef } from 'react';\nfunction MyInput() {\n  const inputRef = useRef();\n  inputRef.current.focus(); // Problematic: Runs on every render, might be null\n  return <input ref={inputRef} />;\n}\n```\n\nB.\n```javascript\nimport React, { useRef, useEffect } from 'react';\nfunction MyInput() {\n  const inputRef = useRef(null);\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }); // Problematic: No dependency array, runs on every render\n  return <input ref={inputRef} />;\n}\n```\n\nC.\n```javascript\nimport React, { useRef, useEffect } from 'react';\nfunction MyInput() {\n  const inputRef = useRef(null);\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Correct: Runs once after mount\n  return <input ref={inputRef} />;\n}\n```\n\nD.\n```javascript\nimport React, { useRef, useEffect } from 'react';\nfunction MyInput() {\n  const inputRef = useRef(null);\n  // No effect hook, relying on direct DOM access after render\n  inputRef.current.focus(); // Still problematic\n  return <input ref={inputRef} />;\n}\n```",
          "answer": "C. \n```javascript\nimport React, { useRef, useEffect } from 'react';\nfunction MyInput() {\n  const inputRef = useRef(null);\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Correct: Runs once after mount\n  return <input ref={inputRef} />;\n}\n```",
          "options": [
            "A.\n```javascript\nimport React, { useRef } from 'react';\nfunction MyInput() {\n  const inputRef = useRef();\n  inputRef.current.focus(); // Problematic: Runs on every render, might be null\n  return <input ref={inputRef} />;\n}\n```",
            "B.\n```javascript\nimport React, { useRef, useEffect } from 'react';\nfunction MyInput() {\n  const inputRef = useRef(null);\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }); // Problematic: No dependency array, runs on every render\n  return <input ref={inputRef} />;\n}\n```",
            "C.\n```javascript\nimport React, { useRef, useEffect } from 'react';\nfunction MyInput() {\n  const inputRef = useRef(null);\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Correct: Runs once after mount\n  return <input ref={inputRef} />;\n}\n```",
            "D.\n```javascript\nimport React, { useRef, useEffect } from 'react';\nfunction MyInput() {\n  const inputRef = useRef(null);\n  // No effect hook, relying on direct DOM access after render\n  inputRef.current.focus(); // Still problematic\n  return <input ref={inputRef} />;\n}\n```"
          ],
          "analysisPoints": [
            "Understands the correct use of `useRef` to acquire a DOM reference.",
            "Recognizes the necessity of `useEffect` for side effects like focusing.",
            "Knows that an empty dependency array (`[]`) in `useEffect` ensures the effect runs only once after the initial mount.",
            "Appreciates the importance of checking `ref.current` for nullability."
          ],
          "keyConcepts": [
            "useRef",
            "useEffect",
            "DOM Manipulation",
            "Component Lifecycle",
            "Side Effects",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Selects the most robust and idiomatic React solution.",
            "Identifies errors in incorrect implementations (e.g., running `focus` in render, missing dependency array).",
            "Demonstrates knowledge of Hook best practices."
          ],
          "example": "Option A and D attempt to call `focus()` directly during the render phase, which is incorrect and can lead to errors as `inputRef.current` might not yet be populated. Option B uses `useEffect` but lacks a dependency array, meaning it would run on *every* render, which is inefficient and potentially problematic for focusing. Option C correctly uses `useEffect` with an empty dependency array to ensure the focus operation happens once after the component has mounted and the `inputRef.current` value is available, adhering to React's lifecycle principles for side effects.",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "useEffect",
            "DOM Manipulation",
            "Best Practices"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_useEffect"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_autofocus_2",
          "topic": "Class Component Auto-Focus Lifecycle",
          "level": "medium",
          "type": "flashcard",
          "question": "Which lifecycle method in a React class component is typically used to auto-focus an input element with refs, and why?",
          "answer": "The `componentDidMount` lifecycle method is typically used. This is because `componentDidMount` runs only once after the component has been rendered to the DOM, ensuring that the DOM element referenced by the ref (`this.myRef.current`) is available and ready for interaction (like calling `focus()`).",
          "options": [],
          "analysisPoints": [
            "Correctly identifies `componentDidMount`.",
            "Explains the reason based on the component lifecycle (DOM availability).",
            "Connects lifecycle to ref usage."
          ],
          "keyConcepts": [
            "Class Components",
            "Lifecycle Methods",
            "componentDidMount",
            "Refs",
            "DOM Interaction"
          ],
          "evaluationCriteria": [
            "Accurately names the lifecycle method and provides a correct rationale."
          ],
          "example": "",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Refs"
          ],
          "prerequisites": [
            "react_class_components",
            "react_lifecycle_methods"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_autofocus_3",
          "topic": "Why `if (inputRef.current)` is important",
          "level": "easy",
          "type": "flashcard",
          "question": "Why is it important to include a check like `if (inputRef.current)` before attempting to call methods on a ref's `current` property (e.g., `inputRef.current.focus()`)?",
          "answer": "It's important because `inputRef.current` will be `null` on the initial render before the DOM element is mounted and assigned to the ref. Attempting to call a method on `null` would result in a runtime error.",
          "options": [],
          "analysisPoints": [
            "Understands the initial state of `ref.current`.",
            "Recognizes the potential for runtime errors if not checked.",
            "Applies defensive programming principles."
          ],
          "keyConcepts": [
            "Refs",
            "Null Checks",
            "Error Handling",
            "DOM Access",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Provides a clear and correct reason for the null check."
          ],
          "example": "",
          "tags": [
            "React",
            "Refs",
            "Best Practices",
            "Error Handling"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_uncontrolled_1",
          "topic": "Uncontrolled Components Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What is an 'uncontrolled component' in React?",
          "answer": "An uncontrolled component is a form component where the form data is handled by the DOM itself, rather than by React state. Refs are used to get the form value directly from the DOM when needed.",
          "options": [],
          "analysisPoints": [
            "Correctly defines uncontrolled components.",
            "Highlights the role of the DOM as the source of truth.",
            "Mentions refs as the mechanism for access."
          ],
          "keyConcepts": [
            "Uncontrolled Components",
            "Forms",
            "Refs",
            "DOM"
          ],
          "evaluationCriteria": [
            "Provides an accurate and concise definition."
          ],
          "example": "",
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components"
          ],
          "prerequisites": [
            "react_forms"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_uncontrolled_2",
          "topic": "Controlled vs Uncontrolled Components",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast 'controlled components' and 'uncontrolled components' in React forms. When would you typically choose one over the other?",
          "answer": "**Controlled Components:**\n*   **Source of Truth:** React state is the single source of truth for form input values.\n*   **Data Flow:** Input values are controlled by React state. Changes are handled via `onChange` event handlers, which update state, causing re-renders.\n*   **Benefits:** Easier to implement validation, conditional input disabling, formatting, and immediate feedback. Predictable data flow.\n*   **When to Use:** Most common and recommended approach for form inputs in React, especially when you need to respond to every keystroke, perform real-time validation, or manipulate the input value.\n\n**Uncontrolled Components:**\n*   **Source of Truth:** The DOM itself is the source of truth for form input values.\n*   **Data Flow:** Input values are retrieved directly from the DOM using refs, typically when a form is submitted or a specific action occurs. React does not actively manage the input's value during typing.\n*   **Benefits:** Can be simpler for very basic forms where you only need the final value, or when integrating with non-React DOM libraries. Potentially fewer re-renders for simple inputs compared to constantly updating state.\n*   **When to Use:** Less common. Suitable for simple forms where you don't need real-time validation or intricate state management. Often used when integrating with third-party DOM libraries or when dealing with file inputs (where file data is naturally handled by the DOM).",
          "options": [],
          "analysisPoints": [
            "Defines both types of components accurately.",
            "Highlights the 'source of truth' difference.",
            "Explains the data flow for each.",
            "Lists clear advantages/disadvantages and appropriate use cases for both.",
            "Demonstrates understanding of form management paradigms in React."
          ],
          "keyConcepts": [
            "Controlled Components",
            "Uncontrolled Components",
            "Forms",
            "React State",
            "Refs",
            "Data Flow",
            "Best Practices"
          ],
          "evaluationCriteria": [
            "Comprehensive and accurate comparison.",
            "Provides clear and justified recommendations for usage.",
            "Demonstrates strong knowledge of React form handling."
          ],
          "example": "",
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "Uncontrolled Components",
            "Comparison"
          ],
          "prerequisites": [
            "react_forms",
            "react_state",
            "react_refs"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_uncontrolled_3",
          "topic": "Accessing Uncontrolled Form Data",
          "level": "medium",
          "type": "mcq",
          "question": "You have an uncontrolled `<input type=\"text\" ref={myInputRef} />` in a functional component. How would you access the current value of this input when a submit button is clicked?",
          "answer": "B. `myInputRef.current.value`",
          "options": [
            "A. `myInputRef.value`",
            "B. `myInputRef.current.value`",
            "C. `myInputRef.current()`",
            "D. `myInputRef.getValue()`"
          ],
          "analysisPoints": [
            "Knows that `useRef` returns an object with a `current` property.",
            "Understands that form input values are accessed via the `value` property on the DOM element.",
            "Differentiates between the ref object and the actual DOM element."
          ],
          "keyConcepts": [
            "Uncontrolled Components",
            "Refs",
            "useRef",
            "DOM Access",
            "Form Inputs"
          ],
          "evaluationCriteria": [
            "Correctly identifies the property used to access the input value.",
            "Demonstrates practical knowledge of `useRef`."
          ],
          "example": "The `myInputRef` is the ref object itself. The actual DOM `<input>` element is assigned to its `.current` property. Once you have the DOM element via `myInputRef.current`, you can access its properties like `value` (for text inputs) or `files` (for file inputs), or call its methods like `focus()`.",
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "useRef",
            "DOM"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_forms"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_uncontrolled_4",
          "topic": "Uncontrolled File Inputs",
          "level": "medium",
          "type": "flashcard",
          "question": "Why are `<input type=\"file\">` elements commonly handled as uncontrolled components in React?",
          "answer": "File inputs are typically uncontrolled components because their value is read-only for security reasons (you cannot programmatically set the value of a file input). React recommends `defaultValue` for pre-filling but otherwise allows the user to interact directly with it. You retrieve the file data using a ref to `ref.current.files` when the form is submitted, rather than trying to control it with React state.",
          "options": [],
          "analysisPoints": [
            "Identifies the read-only nature of file inputs.",
            "Connects security restrictions to the uncontrolled paradigm.",
            "Explains how file data is accessed via `ref.current.files`."
          ],
          "keyConcepts": [
            "Uncontrolled Components",
            "File Input",
            "Refs",
            "Security",
            "Forms"
          ],
          "evaluationCriteria": [
            "Provides a clear and accurate explanation for the specific case of file inputs."
          ],
          "example": "",
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "File Input"
          ],
          "prerequisites": [
            "react_forms",
            "react_refs"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_autofocus_functional_component",
          "title": "Implement Auto-Focus on a Search Input",
          "description": "\nCreate a React functional component `SearchBar` that automatically focuses its text input field when the component first mounts. The input should also have a placeholder text 'Search...'.\n\n1.  Use the `useRef` hook to create a ref for the input element.\n2.  Use the `useEffect` hook to apply focus to the input after the component mounts.\n3.  Ensure the focus logic runs only once.\n4.  Add a button that, when clicked, clears the input field and re-focuses it.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useRef, useEffect } from 'react';\n\nfunction SearchBar() {\n  // TODO: Create ref for the input\n  // TODO: Implement useEffect for auto-focus on mount\n\n  const handleClearAndFocus = () => {\n    // TODO: Clear input value and re-focus\n  };\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Search...\"\n        // TODO: Attach ref\n      />\n      <button onClick={handleClearAndFocus}>Clear & Focus</button>\n    </div>\n  );\n}\n\nexport default SearchBar;",
          "solutionCode": "import React, { useRef, useEffect } from 'react';\n\nfunction SearchBar() {\n  const inputRef = useRef(null); // Create ref for the input\n\n  useEffect(() => {\n    // Auto-focus on mount\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Empty dependency array ensures this runs once after mount\n\n  const handleClearAndFocus = () => {\n    if (inputRef.current) {\n      inputRef.current.value = ''; // Clear input value\n      inputRef.current.focus();   // Re-focus\n    }\n  };\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Search...\"\n        ref={inputRef} // Attach ref\n      />\n      <button onClick={handleClearAndFocus}>Clear & Focus</button>\n    </div>\n  );\n}\n\nexport default SearchBar;",
          "testCases": [
            "Component renders and the input field is automatically focused.",
            "Clicking 'Clear & Focus' button clears the input value and re-focuses the input."
          ],
          "hints": [
            "Remember that `useEffect` with an empty dependency array (`[]`) behaves like `componentDidMount`.",
            "To clear an input field imperatively, you can set its `value` property to an empty string.",
            "Always check `ref.current` before trying to use it."
          ],
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "useEffect",
            "DOM Manipulation",
            "Forms",
            "UX"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_hooks_basics",
            "react_functional_components"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "autofocus_with_refs",
            "theory_use_ref_hook"
          ]
        },
        {
          "id": "task_class_component_ref_focus",
          "title": "Class Component: Dynamic Ref Focus Button",
          "description": "\nCreate a React class component named `TextFocusControl` that renders two input fields: 'First Name' and 'Last Name'.\n\nImplement two buttons:\n1.  'Focus First Name': When clicked, it should focus the 'First Name' input.\n2.  'Focus Last Name': When clicked, it should focus the 'Last Name' input.\n\nUse `React.createRef()` for each input.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass TextFocusControl extends React.Component {\n  constructor(props) {\n    super(props);\n    // TODO: Create refs for first and last name inputs\n  }\n\n  focusFirstName = () => {\n    // TODO: Implement focus logic for first name\n  };\n\n  focusLastName = () => {\n    // TODO: Implement focus logic for last name\n  };\n\n  render() {\n    return (\n      <div>\n        <label>\n          First Name:\n          <input type=\"text\" /> {/* TODO: Attach ref */}\n        </label>\n        <br />\n        <label>\n          Last Name:\n          <input type=\"text\" /> {/* TODO: Attach ref */}\n        </label>\n        <br />\n        <button onClick={this.focusFirstName}>Focus First Name</button>\n        <button onClick={this.focusLastName}>Focus Last Name</button>\n      </div>\n    );\n  }\n}\n\nexport default TextFocusControl;",
          "solutionCode": "import React from 'react';\n\nclass TextFocusControl extends React.Component {\n  constructor(props) {\n    super(props);\n    this.firstNameRef = React.createRef();\n    this.lastNameRef = React.createRef();\n  }\n\n  focusFirstName = () => {\n    if (this.firstNameRef.current) {\n      this.firstNameRef.current.focus();\n    }\n  };\n\n  focusLastName = () => {\n    if (this.lastNameRef.current) {\n      this.lastNameRef.current.focus();\n    }\n  };\n\n  render() {\n    return (\n      <div>\n        <label>\n          First Name:\n          <input type=\"text\" ref={this.firstNameRef} />\n        </label>\n        <br />\n        <label>\n          Last Name:\n          <input type=\"text\" ref={this.lastNameRef} />\n        </label>\n        <br />\n        <button onClick={this.focusFirstName}>Focus First Name</button>\n        <button onClick={this.focusLastName}>Focus Last Name</button>\n      </div>\n    );\n  }\n}\n\nexport default TextFocusControl;",
          "testCases": [
            "Component renders with two input fields and two buttons.",
            "Clicking 'Focus First Name' button puts focus on the 'First Name' input.",
            "Clicking 'Focus Last Name' button puts focus on the 'Last Name' input."
          ],
          "hints": [
            "Remember to create a separate `React.createRef()` instance for each element you want to reference.",
            "Refs should be initialized in the constructor for class components.",
            "Always use the `.current` property to access the actual DOM element."
          ],
          "tags": [
            "React",
            "Class Components",
            "Refs",
            "createRef",
            "DOM Manipulation",
            "Forms"
          ],
          "timeEstimate": 35,
          "prerequisites": [
            "react_class_components",
            "react_createRef"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_refs_class_components",
            "autofocus_with_refs"
          ]
        },
        {
          "id": "task_timer_with_ref",
          "title": "Build a Stopwatch with Ref for Interval ID",
          "description": "\nCreate a React functional component `Stopwatch` that displays a continuously incrementing timer.\n\nRequirements:\n1.  The timer should start automatically when the component mounts.\n2.  Use `useRef` to store the `setInterval` ID to enable cleanup.\n3.  Use `useState` to manage and display the elapsed time (in seconds).\n4.  Implement a 'Stop' button that clears the interval and stops the timer.\n5.  Implement a 'Reset' button that stops the timer and resets the count to 0.\n6.  Ensure the timer correctly cleans up when the component unmounts.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useRef, useEffect, useState } from 'react';\n\nfunction Stopwatch() {\n  const intervalRef = useRef(null); // Used to store interval ID\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    // TODO: Start interval and store its ID in intervalRef.current\n\n    return () => {\n      // TODO: Cleanup interval when component unmounts\n    };\n  }, []); // Empty dependency array for componentDidMount-like behavior\n\n  const stopTimer = () => {\n    // TODO: Clear interval\n  };\n\n  const resetTimer = () => {\n    // TODO: Clear interval and reset seconds to 0\n  };\n\n  return (\n    <div>\n      <h1>Stopwatch: {seconds}s</h1>\n      <button onClick={stopTimer}>Stop</button>\n      <button onClick={resetTimer}>Reset</button>\n    </div>\n  );\n}\n\nexport default Stopwatch;",
          "solutionCode": "import React, { useRef, useEffect, useState } from 'react';\n\nfunction Stopwatch() {\n  const intervalRef = useRef(null); // Used to store interval ID\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    // Start interval and store its ID in intervalRef.current\n    intervalRef.current = setInterval(() => {\n      setSeconds(prevSeconds => prevSeconds + 1);\n    }, 1000);\n\n    return () => {\n      // Cleanup: Clear interval when component unmounts\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, []); // Empty dependency array for componentDidMount-like behavior\n\n  const stopTimer = () => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null; // Important to nullify after clearing\n    }\n  };\n\n  const resetTimer = () => {\n    stopTimer(); // Reuse stop logic\n    setSeconds(0);\n  };\n\n  return (\n    <div>\n      <h1>Stopwatch: {seconds}s</h1>\n      <button onClick={stopTimer}>Stop</button>\n      <button onClick={resetTimer}>Reset</button>\n    </div>\n  );\n}\n\nexport default Stopwatch;",
          "testCases": [
            "Component mounts and timer starts incrementing every second.",
            "Clicking 'Stop' button pauses the timer at its current value.",
            "Clicking 'Reset' button stops the timer and resets the displayed seconds to 0.",
            "Verify in browser dev tools that the `setInterval` is cleared upon component unmount (e.g., navigating away or conditionally rendering the component)."
          ],
          "hints": [
            "The `setInterval` function returns an ID that you need to pass to `clearInterval`.",
            "`useRef` is perfect for storing the interval ID because it persists across renders and doesn't trigger re-renders when updated.",
            "The `useEffect` cleanup function (`return () => {...}`) is crucial for preventing memory leaks."
          ],
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "useEffect",
            "useState",
            "Timers",
            "Side Effects",
            "Cleanup"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_hooks_basics",
            "javascript_timers"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_use_ref_hook",
            "theory_autofocus_with_refs"
          ]
        },
        {
          "id": "task_uncontrolled_login_form",
          "title": "Implement an Uncontrolled Login Form",
          "description": "\nCreate a React functional component `LoginForm` that uses refs to handle form data for a username and password, without using React state to manage input values.\n\nRequirements:\n1.  Render two input fields: one for 'Username' and one for 'Password'.\n2.  Use `useRef` to create a separate ref for each input.\n3.  Implement a 'Submit' button.\n4.  On form submission, prevent the default browser behavior.\n5.  Access the current values of the username and password inputs directly via their refs.\n6.  Log the username and password to the console when the form is submitted.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useRef } from 'react';\n\nfunction LoginForm() {\n  // TODO: Create refs for username and password inputs\n\n  const handleSubmit = (event) => {\n    // TODO: Prevent default form submission\n    // TODO: Access input values via refs and log them\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Username:\n        <input type=\"text\" /> {/* TODO: Attach ref */}\n      </label>\n      <br />\n      <label>\n        Password:\n        <input type=\"password\" /> {/* TODO: Attach ref */}\n      </label>\n      <br />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n\nexport default LoginForm;",
          "solutionCode": "import React, { useRef } from 'react';\n\nfunction LoginForm() {\n  const usernameRef = useRef(null);\n  const passwordRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault(); // Prevent default form submission\n\n    const username = usernameRef.current ? usernameRef.current.value : '';\n    const password = passwordRef.current ? passwordRef.current.value : '';\n\n    console.log('Username:', username);\n    console.log('Password:', password);\n\n    // In a real app, you'd send this to an API or perform authentication\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Username:\n        <input type=\"text\" ref={usernameRef} />\n      </label>\n      <br />\n      <label>\n        Password:\n        <input type=\"password\" ref={passwordRef} />\n      </label>\n      <br />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n\nexport default LoginForm;",
          "testCases": [
            "Component renders with username and password input fields and a submit button.",
            "Enter values in both fields and click 'Login'. Verify that the console logs the correct username and password.",
            "Test with empty inputs to ensure `value` access doesn't throw errors (e.g., `ref.current` might be null or value is empty string)."
          ],
          "hints": [
            "Remember to call `event.preventDefault()` in the submit handler to stop the browser's default form submission behavior.",
            "Access the input value using the `.current` property of the ref, followed by the `.value` property of the DOM element.",
            "It's good practice to check if `ref.current` exists before trying to access its properties."
          ],
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "useRef",
            "Event Handling",
            "DOM"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "react_forms",
            "react_hooks_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_uncontrolled_components",
            "theory_use_ref_hook"
          ]
        }
      ]
    }
  }
]