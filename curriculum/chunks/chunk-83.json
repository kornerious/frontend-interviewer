[
  {
    "id": "83f753cd-3157-413f-95d7-78fdd3f0a630",
    "startLine": 16900,
    "endLine": 16999,
    "processedDate": "2025-06-17T15:37:55.995Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_sop_cors",
          "title": "Same-Origin Policy (SOP) and Cross-Origin Resource Sharing (CORS)",
          "content": "The **Same-Origin Policy (SOP)** is a fundamental security mechanism in web browsers that restricts how documents or scripts loaded from one origin can interact with resources from another origin. An 'origin' is defined by the combination of protocol, host, and port. For example, `http://example.com:80/page` has the origin `http://example.com:80`.\n\n## Key Restrictions Imposed by SOP\n- **Cross-origin reads**: Scripts from one origin cannot directly read data from responses originating from another origin via `XMLHttpRequest` or `Fetch` API calls, unless explicitly allowed by CORS headers.\n- **Cross-origin writes**: While typically allowed (e.g., form submissions, redirects, `<img>` tags, `<script>` tags), the browser still enforces the same-origin policy on the data returned from such requests.\n- **Cross-origin embedding**: Embedding resources (like images, CSS, scripts) is generally allowed, but a script from `http://example.com` cannot directly read data from `http://api.another.com`.\n- **Specific APIs**: Access to certain browser APIs and data stores is also restricted:\n    - **Cookies**: Typically scoped to an origin, meaning cookies set by `example.com` cannot be accessed by `another.com`.\n    - **LocalStorage and IndexedDB**: Data stored in `LocalStorage` and `IndexedDB` is strictly confined to its origin.\n    - **CSS `getComputedStyle` and certain Canvas operations**: Information leakage can occur if these operations are performed on cross-origin content without proper security measures.\n\n## Cross-Origin Resource Sharing (CORS)\n**CORS** is a browser mechanism that allows web servers to explicitly permit cross-origin requests. It provides a flexible way for servers to specify which origins are permitted to access their resources. This is achieved using HTTP headers:\n- **`Access-Control-Allow-Origin`**: Specifies one or more origins that are allowed to access the resource. A value of `*` allows access from any origin (less secure).\n- **Preflight Requests**: For certain types of cross-origin requests (e.g., requests with custom headers, non-GET/POST methods like PUT/DELETE, or specific MIME types), browsers send an `OPTIONS` HTTP request (a \"preflight\" request) to the server before the actual request. This preflight checks if the server is willing to accept the actual request method and headers. The server must respond to the `OPTIONS` request with appropriate CORS headers (`Access-Control-Allow-Methods`, `Access-Control-Allow-Headers`, `Access-Control-Max-Age`).\n\nBy leveraging CORS, developers can build secure web applications that interact with APIs hosted on different domains, while still maintaining the fundamental security benefits of the Same-Origin Policy.",
          "examples": [
            {
              "id": "example_sop_cors_1",
              "title": "CORS Restricted Fetch Example",
              "code": "// Client-side JavaScript (e.g., from http://example.com)\nfetch('http://api.another.com/data')\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error('Fetch error:', error));\n\n// Server-side response from http://api.another.com (without CORS headers)\n// HTTP/1.1 200 OK\n// Content-Type: application/json\n// {\"message\": \"Some data\"}\n\n// Expected browser console error on http://example.com:\n// Access to fetch at 'http://api.another.com/data' from origin 'http://example.com' \n// has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present \n// on the requested resource.",
              "explanation": "This example demonstrates a common CORS error. A `fetch` request from `http://example.com` to `http://api.another.com` will be blocked by the Same-Origin Policy if the `api.another.com` server does not include the `Access-Control-Allow-Origin` header in its response. The browser prevents the script from reading the cross-origin response.",
              "language": "typescript"
            },
            {
              "id": "example_sop_cors_2",
              "title": "CORS Enabled Server Response Example",
              "code": "// Server-side response from http://api.another.com (with CORS headers)\n// HTTP/1.1 200 OK\n// Access-Control-Allow-Origin: http://example.com\n// Access-Control-Allow-Methods: GET, POST\n// Access-Control-Allow-Headers: Content-Type, Authorization\n// Content-Type: application/json\n// {\"message\": \"Data allowed by CORS\"}",
              "explanation": "To allow the `fetch` request from `http://example.com` to succeed, the server at `http://api.another.com` must include the `Access-Control-Allow-Origin` header in its response, specifying `http://example.com` as an allowed origin. This header signals to the browser that the cross-origin request is permissible.",
              "language": "http"
            }
          ],
          "relatedQuestions": [
            "question_sop_cors_1",
            "question_sop_cors_2",
            "question_sop_cors_3",
            "question_sop_cors_4"
          ],
          "relatedTasks": [
            "task_cors_simulation"
          ],
          "tags": [
            "security",
            "networking",
            "browser-apis",
            "http",
            "frontend-basics"
          ],
          "technology": "Web",
          "prerequisites": [
            "http_basics",
            "javascript_fetch_api"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "api_integration",
            "web_security"
          ]
        },
        {
          "id": "theory_browser_storage",
          "title": "Browser Data Storage Mechanisms",
          "content": "Web browsers provide several mechanisms for storing data on the client-side. Each has distinct characteristics regarding storage capacity, persistence, accessibility, and primary use cases.\n\n## Available Storage Options\n1.  **Cookies**:\n    *   **Description**: Small text data stored by the browser, sent with every HTTP request to the domain.\n    *   **Capacity**: Very limited, typically max ~4KB per domain (including name, value, attributes).\n    *   **Persistence**: Can be session-based (deleted when browser closes) or persistent (with an expiry date/max-age).\n    *   **Accessibility**: Accessible by both client-side JavaScript (`document.cookie`) and server-side HTTP headers.\n    *   **Use Cases**: Session management (e.g., login status), user tracking, small preferences.\n    *   **Security**: Vulnerable to Cross-Site Scripting (XSS) and Cross-Site Request Forgery (CSRF) if not handled securely (e.g., `HttpOnly`, `SameSite` attributes).\n\n2.  **LocalStorage**:\n    *   **Description**: Stores key-value pairs (always strings).\n    *   **Capacity**: Larger than cookies, typically 5-10MB per origin.\n    *   **Persistence**: Persistent; data remains even after the browser is closed, until explicitly cleared by the user or code.\n    *   **Accessibility**: Synchronous API, accessible only by client-side JavaScript (`window.localStorage`). Not sent with HTTP requests.\n    *   **Use Cases**: User preferences (e.g., theme settings), application state that needs to persist across sessions, offline data caching.\n\n3.  **SessionStorage**:\n    *   **Description**: Similar to LocalStorage, stores key-value pairs (strings).\n    *   **Capacity**: Similar to LocalStorage, typically 5-10MB per origin.\n    *   **Persistence**: Data lasts only for the duration of the page session (until the tab or browser window is closed). Each new tab/window gets its own `SessionStorage` instance.\n    *   **Accessibility**: Synchronous API, accessible only by client-side JavaScript (`window.sessionStorage`). Not sent with HTTP requests.\n    *   **Use Cases**: Storing temporary data relevant only for the current session (e.g., form input data before submission, wizard steps).\n\n4.  **IndexedDB**:\n    *   **Description**: A transactional NoSQL database for storing significant amounts of structured data (JSON objects, files like `Blob`, `ArrayBuffer`). Provides an object store model.\n    *   **Capacity**: Much larger than LocalStorage, typically user-agent dependent, often 50MB to unlimited (with user permission).\n    *   **Persistence**: Persistent; data remains until explicitly cleared.\n    *   **Accessibility**: Asynchronous API, accessed via events and callbacks/Promises (`indexedDB` global object).\n    *   **Use Cases**: Offline applications, caching large volumes of data, storing complex structured data, client-side data synchronization.\n\n5.  **Web SQL (Deprecated)**:\n    *   **Description**: SQL database interface (SQLite based).\n    *   **Status**: Deprecated and not recommended for new projects. While some browsers still support it, it's not a W3C standard.\n    *   **Use Cases**: Historically used for structured data, but superseded by IndexedDB.\n\n6.  **Cache API (Service Workers)**:\n    *   **Description**: Part of the Service Worker specification, designed for storing network request/response pairs.\n    *   **Capacity**: Large, similar to IndexedDB, but focused on caching network resources.\n    *   **Persistence**: Persistent, controlled by Service Worker lifecycle.\n    *   **Accessibility**: Asynchronous API, typically used within Service Workers but can be accessed from the main thread.\n    *   **Use Cases**: Enabling offline capabilities, improving performance by serving cached assets.\n\n## Comparison Summary\n| Feature           | Cookies               | LocalStorage          | SessionStorage        | IndexedDB             | Cache API            |\n|-------------------|-----------------------|-----------------------|-----------------------|-----------------------|----------------------|\n| **Capacity**      | ~4KB                  | 5-10MB                | 5-10MB                | 50MB+ (user-agent dependent) | Large (user-agent dependent) |\n| **Persistence**   | Configurable (session/persistent) | Persistent            | Session-only          | Persistent            | Persistent           |\n| **API**           | Synchronous (`document.cookie`), HTTP headers | Synchronous (`localStorage`) | Synchronous (`sessionStorage`) | Asynchronous (`indexedDB`) | Asynchronous (`caches`) |\n| **Data Type**     | String                | Strings               | Strings               | Any structured data (JSON, Blob, ArrayBuffer) | Request/Response objects |\n| **Sent with HTTP**| Yes                   | No                    | No                    | No                    | No                   |\n| **Use Case**      | Session, tracking     | User preferences, app state | Temporary session data | Offline apps, large structured data | Offline apps, network caching |\n| **Security**      | HttpOnly, SameSite req'd | XSS vulnerable        | XSS vulnerable        | XSS vulnerable        | Managed by SW        |",
          "examples": [
            {
              "id": "example_browser_storage_1",
              "title": "LocalStorage and Cookies Basic Usage",
              "code": "// LocalStorage Example\nlocalStorage.setItem('theme', 'dark');\nconst currentTheme = localStorage.getItem('theme');\nconsole.log('Current theme (LocalStorage):', currentTheme); // Output: dark\n\n// Cookies Example\n// Setting a cookie (client-side) with an expiry\ndocument.cookie = 'user=john_doe; expires=' + new Date(Date.now() + 86400 * 1000).toUTCString() + '; path=/';\n\n// Reading cookies (client-side) - this returns all cookies as one string\nconsole.log('All cookies:', document.cookie); // Output: user=john_doe; theme=dark (if theme cookie existed)",
              "explanation": "This example demonstrates setting and retrieving data using `localStorage` and `document.cookie`. `localStorage.setItem` is straightforward for key-value string storage. `document.cookie` is more complex, requiring careful string manipulation for setting attributes like expiry or path. Reading `document.cookie` returns a single string containing all cookies, which then needs to be parsed.",
              "language": "typescript"
            },
            {
              "id": "example_browser_storage_2",
              "title": "SessionStorage Basic Usage",
              "code": "// SessionStorage Example\nsessionStorage.setItem('tempData', JSON.stringify({ items: [1, 2, 3], timestamp: Date.now() }));\nconst retrievedTempData = JSON.parse(sessionStorage.getItem('tempData'));\nconsole.log('Temporary session data:', retrievedTempData);\n\n// Data will be cleared when the tab/browser is closed.",
              "explanation": "This demonstrates `sessionStorage`, which behaves identically to `localStorage` but has a session-limited lifespan. It's suitable for temporary data that doesn't need to persist beyond the current browsing session.",
              "language": "typescript"
            },
            {
              "id": "example_browser_storage_3",
              "title": "IndexedDB Basic Setup (Conceptual)",
              "code": "// IndexedDB Conceptual Example (Simplified)\nconst request = indexedDB.open('myDatabase', 1);\n\nrequest.onupgradeneeded = event => {\n  const db = event.target.result;\n  if (!db.objectStoreNames.contains('books')) {\n    db.createObjectStore('books', { keyPath: 'isbn' });\n  }\n};\n\nrequest.onsuccess = event => {\n  const db = event.target.result;\n  const transaction = db.transaction(['books'], 'readwrite');\n  const objectStore = transaction.objectStore('books');\n  \n  objectStore.add({ isbn: '978-1234567890', title: 'My Awesome Book' });\n  \n  transaction.oncomplete = () => console.log('Book added to IndexedDB.');\n  transaction.onerror = error => console.error('Error adding book:', error);\n};\n\nrequest.onerror = error => console.error('IndexedDB error:', error);",
              "explanation": "This conceptual example outlines the basic steps for interacting with IndexedDB: opening a database, handling `onupgradeneeded` for schema changes (like creating object stores), and performing a transaction to add data. IndexedDB's asynchronous nature requires event handlers or Promises (often wrapped for easier use).",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_browser_storage_1",
            "question_browser_storage_2",
            "question_browser_storage_3",
            "question_browser_storage_4"
          ],
          "relatedTasks": [
            "task_user_preference_manager"
          ],
          "tags": [
            "browser-apis",
            "data-storage",
            "web-development",
            "offline-first"
          ],
          "technology": "Web",
          "prerequisites": [
            "javascript_basics",
            "dom_manipulation"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "offline_applications",
            "web_performance"
          ]
        },
        {
          "id": "theory_web_workers",
          "title": "Web Workers: Running Scripts in Background Threads",
          "content": "Web Workers enable JavaScript to run scripts in background threads, separate from the main UI thread of the browser. This is crucial for performing long, CPU-intensive computations without blocking the main thread, thus preventing the UI from becoming unresponsive (freezing).\n\n## Types of Web Workers\n1.  **Dedicated Workers**:\n    *   **Scope**: Communicate with a single main thread context (e.g., one tab or iframe).\n    *   **Communication**: Use `postMessage()` to send data from the main thread to the worker and vice-versa. The worker listens for messages using an `onmessage` event handler.\n    *   **Data Transfer**: By default, data passed via `postMessage` is **copied** using the structured cloning algorithm. This means a duplicate of the data is created, which can be slow and memory-intensive for large objects.\n\n2.  **Shared Workers**:\n    *   **Scope**: Can be accessed by multiple browser contexts (tabs, iframes, even other workers) from the same origin.\n    *   **Communication**: Each context connects to the Shared Worker via a `Port` object. Communication happens using `port.postMessage()` and `port.onmessage` on both sides.\n    *   **Life Cycle**: A Shared Worker instance is shared among all connected contexts from the same origin. It stays alive as long as at least one connection is open.\n\n## Key Characteristics\n-   **No DOM Access**: Web Workers do not have direct access to the DOM, `window` object, or `document` object. They operate in a separate global scope (`self` or `WorkerGlobalScope`).\n-   **Limited APIs**: They have access to a subset of global JavaScript features, including `XMLHttpRequest`, `fetch`, `IndexedDB`, `setTimeout`/`setInterval`, and the `self` global object, among others.\n-   **Error Handling**: Errors within a worker can be handled by listening for the `error` event on the worker object in the main thread.\n\n## Performance Benefit\nBy offloading heavy tasks (like complex calculations, data processing, or large network operations) to a Web Worker, the main thread remains free to handle UI updates, user interactions, and rendering, leading to a smoother and more responsive user experience.",
          "examples": [
            {
              "id": "example_web_workers_1",
              "title": "Dedicated Worker Basic Communication",
              "code": "// main.js (Main Thread)\nconst myWorker = new Worker('worker.js');\n\nmyWorker.postMessage({ command: 'start', data: 1000000 }); // Send data to worker\n\nmyWorker.onmessage = event => {\n  console.log('Message from worker:', event.data);\n  // Output: Message from worker: { result: 500000500000, processedBy: 'Worker' }\n};\n\nmyWorker.onerror = error => {\n  console.error('Worker error:', error.message);\n};\n\nconsole.log('Main thread continues to run...');\n\n// worker.js (Dedicated Worker)\nself.onmessage = event => {\n  const { command, data } = event.data;\n  if (command === 'start') {\n    let sum = 0;\n    for (let i = 0; i <= data; i++) {\n      sum += i;\n    }\n    self.postMessage({ result: sum, processedBy: 'Worker' }); // Send result back\n  }\n};",
              "explanation": "This example shows a dedicated worker (`worker.js`) performing a sum calculation. The main thread creates the worker, sends a message with input data using `postMessage`, and receives the result via the `onmessage` event. The main thread remains responsive while the worker performs the computation.",
              "language": "typescript"
            },
            {
              "id": "example_web_workers_2",
              "title": "Shared Worker Basic Setup (Conceptual)",
              "code": "// main.js or otherTab.js (Main Thread / Other Tab)\nconst sharedWorker = new SharedWorker('shared-worker.js');\n\n// Establish a connection to the shared worker\nsharedWorker.port.start(); // Necessary to begin listening for messages\n\nsharedWorker.port.postMessage('Hello from a context!');\n\nsharedWorker.port.onmessage = event => {\n  console.log('Message from shared worker:', event.data);\n};\n\n// shared-worker.js (Shared Worker)\nself.onconnect = event => {\n  const port = event.ports[0]; // Get the port for the connection\n  \n  port.onmessage = e => {\n    const message = e.data;\n    console.log('Shared Worker received:', message);\n    port.postMessage(`Echo: ${message} (from shared worker)`);\n  };\n\n  // Handle disconnects if needed\n  port.onmessageerror = error => console.error('Shared Worker message error:', error);\n};\n",
              "explanation": "This conceptual example illustrates a shared worker. Multiple browser contexts can connect to the same shared worker instance via `SharedWorker('path').port`. Each context gets a `MessagePort` object to communicate with the worker using `port.postMessage` and `port.onmessage`. The `onconnect` event is crucial in the shared worker to establish communication with newly connected ports.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_web_workers_1",
            "question_web_workers_2",
            "question_web_workers_3",
            "question_web_workers_4"
          ],
          "relatedTasks": [
            "task_heavy_computation_offloader"
          ],
          "tags": [
            "web-workers",
            "performance",
            "concurrency",
            "browser-apis"
          ],
          "technology": "Web",
          "prerequisites": [
            "javascript_async",
            "event_loop"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "complex_web_applications",
            "web_performance_optimization"
          ]
        },
        {
          "id": "theory_transferable_objects",
          "title": "Transferable Objects: Efficient Data Transfer in Web Workers",
          "content": "When data is passed between the main thread and a Web Worker (or between different Workers) using `postMessage()`, it is typically copied using the structured cloning algorithm. This process can be slow and memory-intensive, especially for large datasets, as it involves creating a complete duplicate of the data.\n\n**Transferable Objects** provide a solution to this performance bottleneck. They are a special type of object whose ownership can be transferred from one execution context to another with near-zero cost.\n\n## How Transferable Objects Work\n-   **Transfer of Ownership**: Instead of copying, the underlying memory buffer of the object is transferred. This means the original object in the sending context becomes **unusable (neutered)** after the transfer. It's like moving a file from one folder to another instead of copying it.\n-   **Performance Benefit**: For large data structures, transferring ownership is significantly faster than structured cloning because it avoids the overhead of memory allocation and data serialization/deserialization.\n\n## Examples of Transferable Objects\nCommon examples of objects that can be transferred include:\n-   **`ArrayBuffer`**: A raw binary data buffer. This is the most common use case for transferring large numerical arrays.\n-   **`MessagePort`**: Used for direct communication channels between contexts.\n-   **`ImageBitmap`**: An opaque object representing a bitmap image, suitable for drawing to a canvas without decoding on the main thread.\n-   **`OffscreenCanvas`**: A canvas that can be rendered in a Web Worker, allowing complex graphics operations to be offloaded.\n\n## Syntax for Transfer\nTo transfer an object, you pass it as the second argument (an array of transferable objects) to `postMessage()`:\n```typescript\nworker.postMessage(data, [transferableObject1, transferableObject2]);\n```\nAfter this call, `transferableObject1` and `transferableObject2` (and any other objects in the transferable array) will be \"neutered\" in the sending context.",
          "examples": [
            {
              "id": "example_transferable_objects_1",
              "title": "Transferring an ArrayBuffer",
              "code": "// main.js (Main Thread)\nconst myData = new Uint32Array(1000000); // 4MB array\nfor (let i = 0; i < myData.length; i++) {\n  myData[i] = i;\n}\n\nconsole.log('Main thread before transfer: myData[0] =', myData[0]); // Output: 0\n\nconst worker = new Worker('worker.js');\n\n// Transfer myData.buffer (the underlying ArrayBuffer)\nworker.postMessage({ arrayBuffer: myData.buffer }, [myData.buffer]);\n\n// After transfer, myData's underlying ArrayBuffer is neutered.\n// Any attempts to access myData will result in an error or unexpected behavior.\ntry {\n  console.log('Main thread after transfer: myData[0] =', myData[0]);\n} catch (e) {\n  console.error('Error accessing neutered ArrayBuffer:', e.message);\n  // Output: Error accessing neutered ArrayBuffer: ArrayBuffer has been detached\n}\n\n// worker.js\nself.onmessage = event => {\n  const receivedArrayBuffer = event.data.arrayBuffer;\n  const receivedData = new Uint32Array(receivedArrayBuffer);\n  \n  console.log('Worker received data: receivedData[0] =', receivedData[0]); // Output: 0\n  \n  // Perform operations on receivedData...\n  receivedData[0] = 999;\n  \n  // Transfer it back if needed\n  self.postMessage({ modifiedArrayBuffer: receivedData.buffer }, [receivedData.buffer]);\n};\n",
              "explanation": "This example demonstrates transferring a large `Uint32Array`'s underlying `ArrayBuffer` to a worker. Immediately after `postMessage`, the original `myData.buffer` (and thus `myData`) in the main thread becomes neutered. The worker receives the ownership and can then create its own `Uint32Array` view to work with the data. This avoids copying the 4MB data, providing significant performance gains.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_transferable_objects_1",
            "question_transferable_objects_2",
            "question_transferable_objects_3",
            "question_transferable_objects_4"
          ],
          "relatedTasks": [
            "task_large_array_processing_transferable"
          ],
          "tags": [
            "web-workers",
            "performance",
            "memory-management",
            "binary-data"
          ],
          "technology": "Web",
          "prerequisites": [
            "web_workers",
            "javascript_typed_arrays"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "requiredFor": [
            "high_performance_computing",
            "realtime_applications"
          ]
        },
        {
          "id": "theory_js_performance_optimization",
          "title": "Optimizing JavaScript Execution for Rendering Performance",
          "content": "Efficient JavaScript execution is critical for maintaining a smooth and responsive user interface. Long-running JavaScript tasks can block the main thread, leading to janky animations, unresponsive inputs, and a poor user experience. Here are several techniques to optimize resource-intensive JavaScript operations:\n\n1.  **Web Workers**: Offload heavy, CPU-bound computations (e.g., complex algorithms, large data processing) to a background thread using Web Workers. This ensures the main UI thread remains free to handle rendering and user interactions.\n\n2.  **Debouncing and Throttling**: These techniques limit the frequency at which a function is called, especially for events that fire rapidly (e.g., `resize`, `scroll`, `mousemove`, `input`).\n    *   **Debouncing**: Delays the execution of a function until a certain amount of time has passed since the last time it was invoked. Useful for search suggestions (only call API after user stops typing).\n    *   **Throttling**: Limits how often a function can be called to at most once in a given period. Useful for scroll events (update UI only every 100ms).\n\n3.  **`requestAnimationFrame` (rAF)**: This API is specifically designed for performing animations and visual updates. It schedules a function to run just before the browser's next repaint cycle, typically at 60 frames per second. This synchronizes updates with the browser's rendering engine, leading to smoother animations and avoiding layout thrashing.\n\n4.  **Task Chunking / Yielding to Main Thread**: Break down long-running synchronous tasks into smaller, manageable chunks. After each chunk, yield control back to the main thread, allowing the browser to render updates or process user input.\n    *   **`setTimeout(..., 0)`**: Placing a task in a `setTimeout` with a delay of 0 effectively puts it at the end of the current event loop queue, giving the browser a chance to render.\n    *   **`requestIdleCallback`**: Schedules a function to be run when the browser is idle. This is less urgent than `setTimeout(0)` and is ideal for non-essential, background work.\n\n5.  **Virtual DOM / Incremental DOM**: Libraries like React and Vue use a Virtual DOM (or similar concepts like Incremental DOM) to minimize direct DOM manipulations. Instead of updating the real DOM immediately, they build an in-memory representation, compare it with the previous state (diffing), and then batch the minimal necessary changes to the actual DOM. This reduces expensive reflows and repaints.\n\n6.  **Code Splitting / Lazy Loading**: Load JavaScript code only when it is needed, rather than loading everything upfront. This reduces the initial bundle size, speeding up page load times. Commonly used with routing (load component JS when route is activated) or for features accessed less frequently.\n\n7.  **Memoization**: Cache the results of expensive function calls. If the same inputs occur again, return the cached result instead of re-executing the function. This is particularly useful for pure functions with computationally intensive logic.\n\nBy strategically applying these techniques, developers can significantly improve the perceived performance and responsiveness of their web applications.",
          "examples": [
            {
              "id": "example_js_performance_1",
              "title": "Debouncing an Input Field",
              "code": "// Debounce function\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\n// Example usage with a search input\nconst searchInput = document.getElementById('search-input');\n\nfunction performSearch(query) {\n  console.log(`Searching for: ${query}`);\n  // In a real app, this would be an API call\n}\n\nconst debouncedSearch = debounce(performSearch, 500);\n\nsearchInput.addEventListener('input', (event) => {\n  debouncedSearch(event.target.value);\n});",
              "explanation": "This example shows how to debounce an input event. The `performSearch` function (which might be an expensive API call) is only executed after the user has paused typing for 500 milliseconds. This prevents excessive function calls for every keystroke, optimizing performance.",
              "language": "typescript"
            },
            {
              "id": "example_js_performance_2",
              "title": "Using requestAnimationFrame for Animation",
              "code": "// Get the animated element\nconst box = document.getElementById('animated-box');\nlet position = 0;\n\nfunction animateBox() {\n  position += 2; // Move 2 pixels per frame\n  box.style.transform = `translateX(${position}px)`;\n\n  if (position < 200) { // Stop animation after 200px\n    requestAnimationFrame(animateBox);\n  }\n}\n\n// Start the animation\nrequestAnimationFrame(animateBox);",
              "explanation": "This demonstrates `requestAnimationFrame` for a smooth animation. Instead of using `setTimeout` or `setInterval` which can lead to janky animations, `requestAnimationFrame` ensures that the `animateBox` function runs precisely when the browser is ready to paint, synchronizing with the browser's refresh rate for optimal smoothness.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_js_perf_opt_1",
            "question_js_perf_opt_2",
            "question_js_perf_opt_3",
            "question_js_perf_opt_4"
          ],
          "relatedTasks": [
            "task_optimized_search_input",
            "task_heavy_computation_offloader"
          ],
          "tags": [
            "performance",
            "javascript",
            "browser-rendering",
            "optimization",
            "user-experience"
          ],
          "technology": "Web",
          "prerequisites": [
            "javascript_async",
            "event_loop"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "requiredFor": [
            "high_performance_applications",
            "web_vitals"
          ]
        },
        {
          "id": "theory_resize_observer",
          "title": "ResizeObserver API: Reacting to Element Size Changes",
          "content": "The **`ResizeObserver` API** provides a performant way to react to changes in the dimensions of a DOM element's content or border box. Unlike the `window.onresize` event, which only fires when the browser window changes size, `ResizeObserver` can monitor any specific DOM element and trigger a callback when its size changes, regardless of the cause (e.g., CSS changes, content changes, window resize).\n\n## Key Features and Timing\n-   **Observing Elements**: You create a `ResizeObserver` instance and then use its `observe()` method to register one or more target elements.\n-   **Callback Function**: The `ResizeObserver` constructor takes a callback function that will be executed whenever the size of an observed element changes. The callback receives an array of `ResizeObserverEntry` objects, each containing information about the changed dimensions of an observed element.\n-   **Timing of Notifications**: `ResizeObserver` delivers notifications **after** layout but **before** paint.\n    -   **After Layout**: The browser has already calculated the new dimensions and position of elements.\n    -   **Before Paint**: The browser has not yet painted these changes to the screen.\n\n## Why this Timing is Crucial\nThis specific timing is a significant performance advantage. By receiving notifications after layout but before paint, the observer can make further changes to the observed elements (or other parts of the DOM) *within the same rendering frame*. If these changes affect layout, the browser can recalculate the layout *once more* before painting. This avoids:\n-   **Layout Thrashing (or reflows)**: Repeated, synchronous forced recalculations of layout, which are expensive.\n-   **Visual Jank**: Unnecessary multiple redraws or flickering that might occur if changes were made after the browser had already painted.\n\nThis behavior allows for highly responsive components that can adjust their internal layout, font sizes, or other styles based on their new dimensions efficiently, without causing additional layout passes or visible performance hiccups.",
          "examples": [
            {
              "id": "example_resize_observer_1",
              "title": "Basic ResizeObserver Usage",
              "code": "// HTML:\n// <div id=\"my-resizable-box\" style=\"width: 200px; height: 100px; border: 1px solid black;\"></div>\n\nconst myBox = document.getElementById('my-resizable-box');\n\nconst resizeObserver = new ResizeObserver(entries => {\n  for (let entry of entries) {\n    // contentRect provides the size of the element's content box\n    const { width, height } = entry.contentRect;\n    console.log(`Box size changed to: ${width}px x ${height}px`);\n    \n    // Example: Adjust font size based on width\n    if (width < 250) {\n      entry.target.style.fontSize = '12px';\n    } else {\n      entry.target.style.fontSize = '20px';\n    }\n  }\n});\n\n// Start observing the element\nresizeObserver.observe(myBox);\n\n// You can change the size programmatically to test:\n// myBox.style.width = '300px';\n// myBox.style.height = '150px';\n\n// Or resize the browser window if the element has fluid width/height",
              "explanation": "This example sets up a `ResizeObserver` to monitor a `div` element. Whenever the `div`'s size changes (e.g., if its `width` CSS property is altered or if the browser window is resized causing its fluid width to change), the callback function executes, logging the new dimensions and dynamically adjusting the font size of the element based on its width. This demonstrates how responsive components can be built efficiently.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_resize_observer_1",
            "question_resize_observer_2",
            "question_resize_observer_3"
          ],
          "relatedTasks": [
            "task_responsive_card_component"
          ],
          "tags": [
            "browser-apis",
            "responsive-design",
            "performance",
            "dom"
          ],
          "technology": "Web",
          "prerequisites": [
            "javascript_events",
            "dom_manipulation"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "ui_components",
            "responsive_web_design"
          ]
        },
        {
          "id": "theory_drag_drop_file_reading",
          "title": "Drag and Drop File Reading with FileReader API",
          "content": "Implementing drag-and-drop file functionality allows users to easily interact with files directly from their desktop or file system. This typically involves handling a sequence of DOM events and utilizing the `FileReader` API to access file contents.\n\n## Algorithm for Reading a Dropped Text File\n1.  **Identify Drop Target**: Designate a specific DOM element (e.g., a `div`, `section`) to act as the drop zone.\n\n2.  **Prevent Default Browser Behavior**: Browsers have default behaviors for drag-and-drop (e.g., opening a dragged file in a new tab). These must be prevented to enable custom handling:\n    *   Attach an `event listener` for the `dragover` event to the drop target. Inside the handler, call `event.preventDefault()`. This indicates that the drop target is valid and allows a drop.\n    *   Attach an `event listener` for the `drop` event to the drop target. Inside the handler, call `event.preventDefault()` again to prevent the browser from processing the dropped file.\n\n3.  **Handle `dragover` (Optional Visual Feedback)**:\n    *   While not strictly necessary for functionality, it's good practice to provide visual feedback (e.g., changing border style, adding a class) when a draggable item is over the valid drop zone. Use `dragenter` and `dragleave` events for this.\n\n4.  **Handle `drop` Event and Access Files**:\n    *   In the `drop` event handler, the dropped files are accessible via `event.dataTransfer.files`. This property returns a `FileList` object, which is an array-like list of `File` objects.\n    *   Each `File` object contains properties like `name`, `size`, and `type` (MIME type).\n\n5.  **Validate File Type**: Before attempting to read, check if the dropped file is of the expected type (e.g., `text/plain` for `.txt` files). You can check `file.type` or `file.name`.\n\n6.  **Read File Content with `FileReader` API**:\n    *   If the file type is valid, create a new instance of `FileReader`.\n    *   Use one of `FileReader`'s methods to read the file:\n        *   `readAsText(file, [encoding])`: Reads the contents of the specified `Blob` or `File` as a text string. The `encoding` parameter is optional.\n        *   `readAsDataURL(file)`: Reads the contents as a data URL (Base64 encoded string).\n        *   `readAsArrayBuffer(file)`: Reads the contents as an `ArrayBuffer`.\n        *   `readAsBinaryString(file)`: Reads the contents as a raw binary string (deprecated).\n    *   Listen for the `onload` event on the `FileReader` instance. When the file has been successfully read, `event.target.result` will contain the file's content.\n\n7.  **Process/Display Content**: Once the content is available in `fileReader.onload`, you can display it in a `textarea`, `div`, or process it as needed by your application.\n\nThis robust approach ensures a user-friendly and functional drag-and-drop file interaction.",
          "examples": [
            {
              "id": "example_drag_drop_file_reading_1",
              "title": "Drag and Drop Text File Reader",
              "code": "// HTML structure (index.html):\n// <div id=\"drop-zone\" style=\"border: 2px dashed #ccc; padding: 20px; text-align: center; font-family: sans-serif; height: 100px; line-height: 100px;\">\n//   Drag & Drop .txt files here\n// </div>\n// <pre id=\"file-content\" style=\"margin-top: 20px; border: 1px solid #eee; padding: 10px; background-color: #f9f9f9; white-space: pre-wrap; word-wrap: break-word;\"></pre>\n\n// JavaScript (script.js):\nconst dropZone = document.getElementById('drop-zone');\nconst fileContentDisplay = document.getElementById('file-content');\n\ndropZone.addEventListener('dragover', (e) => {\n  e.preventDefault(); // Prevent default to allow drop\n  dropZone.style.borderColor = 'green'; // Visual feedback\n});\n\ndropZone.addEventListener('dragleave', () => {\n  dropZone.style.borderColor = '#ccc'; // Reset visual feedback\n});\n\ndropZone.addEventListener('drop', (e) => {\n  e.preventDefault(); // Prevent browser from opening file\n  dropZone.style.borderColor = '#ccc'; // Reset visual feedback\n\n  const files = e.dataTransfer.files; // Get the FileList\n\n  if (files.length > 0) {\n    const file = files[0]; // Get the first dropped file\n\n    if (file.type === 'text/plain' || file.name.endsWith('.txt')) {\n      const reader = new FileReader();\n\n      reader.onload = (event) => {\n        // Display the file content\n        fileContentDisplay.textContent = event.target.result;\n      };\n\n      reader.onerror = (error) => {\n        console.error('Error reading file:', error);\n        fileContentDisplay.textContent = 'Error reading file.';\n      };\n\n      reader.readAsText(file); // Read the file as text\n    } else {\n      fileContentDisplay.textContent = 'Please drop a .txt file.';\n    }\n  }\n});",
              "explanation": "This example implements the described algorithm. It sets up a `div` as a drop zone. On `dragover`, it prevents default behavior and provides visual feedback. On `drop`, it retrieves the file, validates it as a `.txt` file, uses `FileReader.readAsText()` to get its content, and then displays it in a `pre` tag. Error handling for the `FileReader` is also included.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_drag_drop_file_1",
            "question_drag_drop_file_2",
            "question_drag_drop_file_3",
            "question_drag_drop_file_4"
          ],
          "relatedTasks": [
            "task_text_file_viewer"
          ],
          "tags": [
            "dom-events",
            "file-api",
            "drag-and-drop",
            "browser-apis",
            "user-experience"
          ],
          "technology": "Web",
          "prerequisites": [
            "javascript_events",
            "dom_manipulation"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "file_upload_interfaces",
            "rich_text_editors"
          ]
        },
        {
          "id": "theory_shadow_dom",
          "title": "Shadow DOM: Encapsulated DOM and Styles",
          "content": "The **Shadow DOM** is a web standard that allows for the encapsulation of DOM structure and CSS styles within a web component. When you inspect an HTML page in browser developer tools and see `#shadow-root (open)` or `#shadow-root (closed)`, it indicates the presence of a Shadow DOM.\n\n## Key Concepts\n-   **Shadow Host**: A regular DOM element to which a shadow tree is attached. This element acts as the container for the encapsulated content.\n-   **Shadow Tree**: The isolated DOM tree that is rendered by the browser instead of the shadow host's regular light DOM children. Its content is not part of the main document's DOM tree.\n-   **Shadow Root**: The root node of the shadow tree. It's the entry point to the encapsulated DOM. It can be `open` or `closed`.\n    -   **`open` Shadow Root**: The shadow root can be accessed via JavaScript from the main document (e.g., `element.shadowRoot`). This is common for custom elements that expose internal parts for styling or scripting.\n    -   **`closed` Shadow Root**: The shadow root cannot be accessed from outside JavaScript. This provides stronger encapsulation, typically used by built-in browser elements (like `<video>` controls) for security reasons.\n\n## Benefits of Shadow DOM\n1.  **Encapsulation of DOM**: The internal DOM structure of a component is hidden from the main document's DOM. Queries like `document.querySelector()` will not pierce into the shadow tree.\n2.  **Style Encapsulation**: CSS styles defined within the shadow tree are scoped only to that tree and do not leak out to the main document. Conversely, styles from the main document generally do not leak into the shadow tree (with some exceptions like inherited properties).\n3.  **Modularity and Reusability**: Promotes the creation of truly self-contained and reusable UI components. Developers can be confident that a component's internal structure or styles won't conflict with other parts of the page or break when integrated into different projects.\n4.  **Simplified Development**: Reduces the mental overhead of managing CSS specificity and avoiding naming collisions in large applications.\n\n## Use Cases\n-   **Web Components**: Shadow DOM is a cornerstone of the Web Components specification, particularly for defining custom elements that have their own encapsulated UI.\n-   **Built-in Elements**: Many standard HTML elements like `<video>`, `<audio>`, `<input type=\"range\">`, and others use Shadow DOM internally to render their complex controls, ensuring their styling and functionality are consistent across websites.",
          "examples": [
            {
              "id": "example_shadow_dom_1",
              "title": "Native Element with Shadow DOM",
              "code": "// Inspect a native <video> element in your browser's developer tools.\n// You will typically see a structure similar to this:\n\n// <video controls src=\"your-video.mp4\">\n//   #shadow-root (open)\n//     <div id=\"container\">\n//       <div id=\"controls\">\n//         <button id=\"play-button\"></button>\n//         <input type=\"range\" id=\"timeline\">\n//         <!-- ... other video controls ... -->\n//       </div>\n//     </div>\n// </video>\n\n// Explanation: The complex UI for video controls (play button, timeline, volume etc.) \n// is rendered inside an open shadow root attached to the <video> element. \n// This allows the browser to style and manage these controls internally \n// without them interfering with your page's CSS or JavaScript.",
              "explanation": "This conceptual example shows how standard HTML elements like `<video>` use Shadow DOM. The browser hides the complex internal structure of the video player controls within a shadow root, ensuring their functionality and styling are isolated from the main document.",
              "language": "html"
            },
            {
              "id": "example_shadow_dom_2",
              "title": "Creating a Simple Custom Element with Shadow DOM",
              "code": "// HTML:\n// <my-shadow-component></my-shadow-component>\n\n// JavaScript:\nclass MyShadowComponent extends HTMLElement {\n  constructor() {\n    super();\n    const shadowRoot = this.attachShadow({ mode: 'open' }); // Create an open shadow root\n\n    // Add content to the shadow DOM\n    shadowRoot.innerHTML = `\n      <style>\n        /* Styles here are scoped ONLY to this component */\n        :host {\n          display: block;\n          border: 1px solid blue;\n          padding: 10px;\n          background-color: lightblue;\n        }\n        p {\n          color: darkblue;\n          font-family: sans-serif;\n        }\n      </style>\n      <p>This content is inside the Shadow DOM.</p>\n      <button>Click Me</button>\n    `;\n\n    // You can also add event listeners to elements inside the shadow DOM\n    shadowRoot.querySelector('button').addEventListener('click', () => {\n      alert('Button clicked inside Shadow DOM!');\n    });\n  }\n}\n\ncustomElements.define('my-shadow-component', MyShadowComponent);",
              "explanation": "This example demonstrates how to create a custom element that uses Shadow DOM. By calling `this.attachShadow({ mode: 'open' })`, an isolated DOM tree is created. Styles defined within the `<style>` tag inside the shadow root are confined to this component, preventing them from affecting the main document and vice-versa, showcasing the powerful encapsulation.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_shadow_dom_1",
            "question_shadow_dom_2",
            "question_shadow_dom_3",
            "question_shadow_dom_4"
          ],
          "relatedTasks": [
            "task_reusable_alert_component"
          ],
          "tags": [
            "web-components",
            "dom",
            "css",
            "encapsulation",
            "front-end-architecture"
          ],
          "technology": "Web",
          "prerequisites": [
            "html_basics",
            "css_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "web_components_development",
            "framework_agnostic_components"
          ]
        },
        {
          "id": "theory_custom_elements",
          "title": "Custom Elements: Defining Your Own HTML Tags",
          "content": "Custom Elements are a fundamental part of the Web Components specification, allowing developers to define their own fully-featured HTML tags with custom templates, encapsulated styles (often using Shadow DOM), and JavaScript-driven behavior. They extend the capabilities of HTML itself.\n\n## How Custom Elements Work\nCustom Elements are built upon the `HTMLElement` interface and registered with the browser's `CustomElementRegistry` (`customElements` global object).\n\n1.  **Defining the Class**: You create a JavaScript class that extends `HTMLElement`.\n2.  **Attaching Behavior**: Inside this class, you can define:\n    *   **Constructor**: Used for initial setup. Best practice is to set up Shadow DOM and attach event listeners here.\n    *   **Lifecycle Callbacks**: Special methods that are automatically called by the browser at different stages of the element's life:\n        *   `connectedCallback()`: Invoked when the custom element is first connected to the document's DOM.\n        *   `disconnectedCallback()`: Invoked when the custom element is disconnected from the document's DOM.\n        *   `attributeChangedCallback(name, oldValue, newValue)`: Invoked when one of the custom element's observed attributes is added, removed, or changed. You must define `static get observedAttributes()` to specify which attributes to observe.\n        *   `adoptedCallback()`: Invoked when the custom element is moved to a new document (e.g., in an `<iframe>`).\n3.  **Registering the Element**: You register your custom element with the browser using `customElements.define(tagName, elementClass, [options])`. The `tagName` must contain a hyphen (`-`) to avoid conflicts with future HTML elements (e.g., `my-button`, `date-picker`).\n\n## Types of Custom Elements\n-   **Autonomous Custom Elements**: Standalone elements that do not inherit from standard HTML elements. They are entirely new elements (e.g., `<my-modal>`).\n-   **Customized Built-in Elements**: Elements that extend existing HTML elements (e.g., `<button is=\"my-fancy-button\">`). These are less commonly used due to complexity and browser support.\n\n## Benefits and Use Cases\n1.  **Reusability**: Create encapsulated UI components (like a custom date picker, a modal dialog, or a notification banner) that can be easily reused across different projects or shared within an organization.\n2.  **Encapsulation**: When combined with Shadow DOM, Custom Elements provide strong encapsulation of their internal DOM structure and styles, preventing conflicts with the rest of the page. This leads to more robust and predictable components.\n3.  **Interoperability**: As a native web platform standard, Custom Elements can be used with any JavaScript framework (React, Vue, Angular) or even with no framework at all. They are future-proof and highly interoperable.\n4.  **Semantic HTML**: Define elements that have clear, domain-specific meaning, improving the readability and maintainability of your HTML markup.\n5.  **Maintainability**: Break down complex user interfaces into smaller, self-contained, and easier-to-manage components.\n6.  **Progressive Enhancement**: Custom elements can degrade gracefully if JavaScript is disabled or fails to load, allowing basic content to still be rendered.",
          "examples": [
            {
              "id": "example_custom_elements_1",
              "title": "Basic Custom Element Definition and Usage",
              "code": "// HTML:\n// <hello-world name=\"Alice\"></hello-world>\n// <hello-world name=\"Bob\"></hello-world>\n\n// JavaScript:\nclass HelloWorld extends HTMLElement {\n  // Define observed attributes for attributeChangedCallback\n  static get observedAttributes() {\n    return ['name'];\n  }\n\n  constructor() {\n    super(); // Always call super() first in the constructor\n    this.attachShadow({ mode: 'open' }); // Attach a shadow DOM for encapsulation\n    this._render(); // Initial render\n  }\n\n  connectedCallback() {\n    console.log('hello-world element added to DOM.');\n    // Add event listeners or fetch data here\n  }\n\n  disconnectedCallback() {\n    console.log('hello-world element removed from DOM.');\n    // Clean up event listeners or resources\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === 'name' && oldValue !== newValue) {\n      console.log(`Name attribute changed from ${oldValue} to ${newValue}`);\n      this._render(); // Re-render when name changes\n    }\n  }\n\n  _render() {\n    const name = this.getAttribute('name') || 'World';\n    this.shadowRoot.innerHTML = `\n      <style>\n        p { color: #333; font-family: sans-serif; }\n        span { font-weight: bold; color: blue; }\n      </style>\n      <p>Hello, <span>${name}</span>!</p>\n    `;\n  }\n}\n\n// Define the custom element\ncustomElements.define('hello-world', HelloWorld);\n\n// Example of changing attribute programmatically\n// const el = document.querySelector('hello-world');\n// el.setAttribute('name', 'Charlie');",
              "explanation": "This example defines a simple `<hello-world>` custom element. It extends `HTMLElement`, uses a `constructor` to set up Shadow DOM, and implements `connectedCallback` and `attributeChangedCallback` to react to DOM attachment and attribute changes. The `_render` method updates the Shadow DOM content. The `customElements.define` call registers the element with the browser, making `<hello-world>` available as a valid HTML tag.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_custom_elements_1",
            "question_custom_elements_2",
            "question_custom_elements_3",
            "question_custom_elements_4"
          ],
          "relatedTasks": [
            "task_reusable_alert_component"
          ],
          "tags": [
            "web-components",
            "html",
            "javascript",
            "modularity",
            "front-end-architecture"
          ],
          "technology": "Web",
          "prerequisites": [
            "html_basics",
            "javascript_classes",
            "dom_manipulation",
            "shadow_dom"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "web_components_development",
            "framework_agnostic_components",
            "design_systems"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_sop_cors_1",
          "topic": "Same-Origin Policy",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary security principle behind the Same-Origin Policy?",
          "answer": "The Same-Origin Policy prevents a document or script loaded from one origin from interacting with a resource from another origin.",
          "options": [],
          "analysisPoints": [
            "Defines 'origin' as protocol, host, and port.",
            "Crucial for preventing malicious scripts from accessing sensitive data from other sites.",
            "Acts as a foundational browser security model."
          ],
          "keyConcepts": [
            "Same-Origin Policy",
            "Origin",
            "Browser Security"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles",
            "Ability to define key terms"
          ],
          "example": "",
          "tags": [
            "security",
            "networking",
            "browser"
          ],
          "prerequisites": [
            "http_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_sop_cors_2",
          "topic": "CORS and SOP Restrictions",
          "level": "medium",
          "type": "open",
          "question": "The Same-Origin Policy restricts `XMLHttpRequest` and `Fetch` calls by default. Name two other browser features or data storage mechanisms that are typically scoped to an origin due to SOP, and briefly explain why.",
          "answer": "Two other browser features/data storage mechanisms scoped to an origin due to SOP are:\n\n1.  **Cookies**: Cookies are typically scoped to a domain (and path/protocol) to prevent one website from reading cookies set by another. If `siteA.com` could read `siteB.com`'s cookies, it could potentially steal session tokens or other sensitive user data, leading to session hijacking or privacy breaches.\n2.  **LocalStorage and IndexedDB**: Data stored in `LocalStorage` and `IndexedDB` is strictly confined to its origin. This means that data stored by `app.example.com` cannot be accessed by `another.com`. This prevents malicious scripts from reading or modifying data that belongs to other applications or websites, ensuring data isolation and preventing cross-site data leakage.",
          "options": [],
          "analysisPoints": [
            "Identifies Cookies, LocalStorage, or IndexedDB.",
            "Explains the security rationale for each restriction.",
            "Demonstrates understanding of data isolation."
          ],
          "keyConcepts": [
            "Same-Origin Policy",
            "Cookies",
            "LocalStorage",
            "IndexedDB",
            "Data Isolation",
            "Security"
          ],
          "evaluationCriteria": [
            "Identification of restricted features",
            "Ability to explain the 'why' behind security restrictions",
            "Understanding of common web vulnerabilities"
          ],
          "example": "",
          "tags": [
            "security",
            "browser-apis",
            "data-storage"
          ],
          "prerequisites": [
            "same_origin_policy",
            "browser_storage"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_sop_cors_3",
          "topic": "CORS Headers",
          "level": "medium",
          "type": "mcq",
          "question": "A frontend application hosted at `https://app.example.com` needs to make `POST` requests to an API server at `https://api.thirdparty.net`. If the requests are being blocked by the Same-Origin Policy, which HTTP response header must `https://api.thirdparty.net` include to allow `app.example.com` to make these requests?",
          "answer": "`Access-Control-Allow-Origin: https://app.example.com`",
          "options": [
            "`Content-Type: application/json`",
            "`Access-Control-Allow-Methods: POST`",
            "`Access-Control-Allow-Origin: https://app.example.com`",
            "`X-Requested-With: XMLHttpRequest`"
          ],
          "analysisPoints": [
            "Correctly identifies `Access-Control-Allow-Origin` as the primary header for allowing cross-origin requests.",
            "Understands that the value of `Access-Control-Allow-Origin` must match the requesting origin (or be `*`).",
            "Distinguishes `Access-Control-Allow-Origin` from other CORS-related headers like `Access-Control-Allow-Methods` (which is also needed for `POST` in preflight but doesn't grant fundamental origin permission).",
            "Recognizes that `Content-Type` and `X-Requested-With` are standard request/response headers, not CORS enforcement headers."
          ],
          "keyConcepts": [
            "CORS",
            "Access-Control-Allow-Origin",
            "HTTP Headers",
            "Same-Origin Policy"
          ],
          "evaluationCriteria": [
            "Knowledge of CORS specific headers",
            "Ability to apply CORS concepts to a practical scenario"
          ],
          "example": "The `Access-Control-Allow-Origin` header is fundamental for allowing cross-origin requests. If a server at `api.thirdparty.net` includes `Access-Control-Allow-Origin: https://app.example.com` in its response headers, the browser will permit the JavaScript code from `app.example.com` to read the response from `api.thirdparty.net`. While `Access-Control-Allow-Methods: POST` would also be necessary for the preflight `OPTIONS` request for a `POST` method, it's `Access-Control-Allow-Origin` that determines if the origin itself is permitted to access the resource.",
          "tags": [
            "cors",
            "http",
            "security",
            "networking"
          ],
          "prerequisites": [
            "same_origin_policy"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_sop_cors_4",
          "topic": "CORS Preflight Requests",
          "level": "hard",
          "type": "open",
          "question": "Explain what a CORS 'preflight' request is, when it occurs, and why it's necessary. What HTTP method is typically used for a preflight request, and what headers does the server need to respond with?",
          "answer": "A CORS 'preflight' request is an `OPTIONS` HTTP request that the browser automatically sends to a server before the actual cross-origin request. It's necessary for \"non-simple\" requests to determine if the server is willing to accept the actual request with its specified method, headers, and origin.\n\n**When it occurs:**\nPreflight requests occur for cross-origin requests that are not considered \"simple\" by the CORS specification. A request is simple if all of the following conditions are met:\n1.  Method is `GET`, `HEAD`, or `POST`.\n2.  Headers only include CORS-safelisted request-headers (e.g., `Accept`, `Accept-Language`, `Content-Language`, `Content-Type` with values `application/x-www-form-urlencoded`, `multipart/form-data`, or `text/plain`).\n3.  No `ReadableStream` object is used in the request.\n\nExamples of non-simple requests include `PUT`, `DELETE`, requests with custom headers (like `Authorization`), or `POST` requests with `Content-Type: application/json`.\n\n**Why it's necessary:**\nIt's a security mechanism. For non-simple requests, the browser needs to ensure the server understands and explicitly grants permission for the more complex or potentially destructive operations before sending the actual data. Without a preflight, a malicious script could trick a browser into sending a `PUT` or `DELETE` request to another origin, which might have side effects, even if the script can't read the response.\n\n**HTTP Method and Server Response:**\n-   The HTTP method used for a preflight request is always **`OPTIONS`**.\n-   The server must respond with the following CORS headers to indicate it's safe to proceed with the actual request:\n    -   `Access-Control-Allow-Origin`: Specifies the origin(s) allowed.\n    -   `Access-Control-Allow-Methods`: Specifies the HTTP methods allowed for the actual request (e.g., `GET, POST, PUT, DELETE`).\n    -   `Access-Control-Allow-Headers`: Specifies the non-safelisted headers allowed for the actual request (e.g., `Content-Type, Authorization`).\n    -   `Access-Control-Max-Age` (optional): Indicates how long the results of a preflight request can be cached, reducing subsequent preflight requests.",
          "options": [],
          "analysisPoints": [
            "Defines preflight request and its purpose.",
            "Lists conditions for when a preflight request is triggered.",
            "Explains the security rationale (preventing side effects without explicit permission).",
            "Identifies `OPTIONS` as the method.",
            "Lists necessary `Access-Control` response headers."
          ],
          "keyConcepts": [
            "CORS Preflight",
            "OPTIONS Method",
            "Access-Control-Allow-Origin",
            "Access-Control-Allow-Methods",
            "Access-Control-Allow-Headers",
            "HTTP Security"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of complex CORS mechanism",
            "Ability to articulate security implications",
            "Detailed knowledge of HTTP headers"
          ],
          "example": "",
          "tags": [
            "cors",
            "http",
            "security",
            "networking",
            "advanced"
          ],
          "prerequisites": [
            "same_origin_policy",
            "http_headers"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_browser_storage_1",
          "topic": "Browser Data Storage Comparison",
          "level": "medium",
          "type": "open",
          "question": "You need to store user preferences (e.g., dark theme preference) and also temporarily save form data as a user fills out a multi-step form before final submission. Which two browser storage mechanisms would you choose for each scenario, and why? Explain their key differences relevant to these use cases.",
          "answer": "For user preferences (e.g., dark theme preference), I would choose **LocalStorage**.\n\n*   **Why LocalStorage for preferences**: LocalStorage provides persistent storage, meaning the data remains even after the user closes and reopens the browser. User preferences are typically expected to last across sessions, making LocalStorage ideal. It also has a relatively large capacity (5-10MB) and a simple, synchronous API for key-value string storage.\n\nFor temporarily saving form data during a multi-step form, I would choose **SessionStorage**.\n\n*   **Why SessionStorage for temporary form data**: SessionStorage is designed for session-specific data. The data persists as long as the browser tab or window is open, but is automatically cleared when the session ends (tab closed). This is perfect for multi-step forms where the data is only relevant for the current user interaction and does not need to persist once the form is submitted or the user navigates away and closes the tab. It also shares the same synchronous key-value API as LocalStorage, making it easy to use.",
          "options": [],
          "analysisPoints": [
            "Correctly identifies LocalStorage for preferences due to persistence.",
            "Correctly identifies SessionStorage for temporary form data due to session-only persistence.",
            "Articulates the key difference in persistence between LocalStorage and SessionStorage.",
            "Mentions other relevant characteristics like API type (synchronous) or capacity."
          ],
          "keyConcepts": [
            "LocalStorage",
            "SessionStorage",
            "Persistence",
            "Browser Storage",
            "Use Cases"
          ],
          "evaluationCriteria": [
            "Ability to choose appropriate storage based on requirements",
            "Clear comparison of storage mechanisms",
            "Understanding of practical application of browser APIs"
          ],
          "example": "",
          "tags": [
            "data-storage",
            "frontend-architecture",
            "user-experience"
          ],
          "prerequisites": [
            "browser_storage"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_browser_storage_2",
          "topic": "Browser Data Storage Features",
          "level": "easy",
          "type": "flashcard",
          "question": "Which browser storage mechanism is typically limited to ~4KB and is sent with every HTTP request to its domain?",
          "answer": "Cookies",
          "options": [],
          "analysisPoints": [
            "Recalls the capacity limitation of Cookies.",
            "Recalls the HTTP header transmission characteristic of Cookies."
          ],
          "keyConcepts": [
            "Cookies",
            "Capacity",
            "HTTP Request"
          ],
          "evaluationCriteria": [
            "Quick recall of facts",
            "Identification of key characteristics"
          ],
          "example": "",
          "tags": [
            "cookies",
            "data-storage",
            "http"
          ],
          "prerequisites": [
            "browser_storage"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_browser_storage_3",
          "topic": "IndexedDB Use Cases",
          "level": "medium",
          "type": "mcq",
          "question": "Your web application needs to store a large amount of structured data (e.g., hundreds of JSON objects representing product catalog data) locally on the client-side for offline access. Which browser storage API is best suited for this requirement?",
          "answer": "IndexedDB",
          "options": [
            "Cookies",
            "LocalStorage",
            "SessionStorage",
            "IndexedDB"
          ],
          "analysisPoints": [
            "Identifies the need for large capacity and structured data.",
            "Recognizes IndexedDB as a transactional NoSQL database suitable for such requirements.",
            "Understands limitations of other options (small capacity for Cookies, string-only and smaller capacity for Local/SessionStorage)."
          ],
          "keyConcepts": [
            "IndexedDB",
            "Offline Applications",
            "Structured Data",
            "Browser Storage Capacity"
          ],
          "evaluationCriteria": [
            "Ability to select appropriate technology based on specific needs",
            "Understanding of API capabilities and limitations"
          ],
          "example": "IndexedDB is the most suitable choice here. Unlike Cookies (very small, sent with every request), LocalStorage, and SessionStorage (both limited to strings and typically 5-10MB), IndexedDB is a full-fledged transactional NoSQL database designed for storing large amounts of structured data, including JSON objects, Blobs, and ArrayBuffers. Its asynchronous API is built to handle significant data operations without blocking the main thread, making it ideal for offline-first applications and complex client-side data management.",
          "tags": [
            "indexeddb",
            "data-storage",
            "offline-first",
            "browser-apis"
          ],
          "prerequisites": [
            "browser_storage"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_browser_storage_4",
          "topic": "Cache API and Service Workers",
          "level": "hard",
          "type": "open",
          "question": "Beyond storing user preferences or structured data, what is the primary purpose of the Cache API in conjunction with Service Workers, and how does it contribute to web application performance and user experience?",
          "answer": "The primary purpose of the **Cache API** in conjunction with **Service Workers** is to enable robust **offline capabilities** and significantly **improve performance** by intercepting and serving network requests from a cache.\n\n**How it works and contributes:**\n1.  **Network Request Interception**: Service Workers act as a programmable proxy between the browser and the network. They can intercept all outgoing network requests made by the page.\n2.  **Caching Responses**: The Cache API allows Service Workers to store network request-response pairs. When a request is made, the Service Worker can check its cache first. If a matching response is found, it can serve it immediately from the cache, without going to the network.\n3.  **Offline Access**: By caching essential assets (HTML, CSS, JavaScript, images) and even dynamic API responses, the application can load and function even when the user is offline or has an unreliable network connection.\n4.  **Performance Improvement**: Serving assets from the local cache is much faster than fetching them from the network. This drastically reduces page load times, especially on repeat visits, providing an instant-loading experience and improving Core Web Vitals.",
          "options": [],
          "analysisPoints": [
            "Identifies Cache API's role with Service Workers.",
            "Explains its primary purpose as offline capability and performance enhancement.",
            "Details how it achieves this (network interception, caching request/response pairs).",
            "Connects it to user experience (faster loading, offline access)."
          ],
          "keyConcepts": [
            "Cache API",
            "Service Workers",
            "Offline First",
            "Web Performance",
            "Network Interception"
          ],
          "evaluationCriteria": [
            "Understanding of advanced browser APIs and their synergy",
            "Ability to explain architectural patterns for web performance",
            "Insight into user experience benefits"
          ],
          "example": "",
          "tags": [
            "service-workers",
            "cache-api",
            "offline",
            "performance"
          ],
          "prerequisites": [
            "browser_storage",
            "web_workers"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_web_workers_1",
          "topic": "Web Workers Purpose",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using Web Workers in a web application?",
          "answer": "Web Workers allow JavaScript to run in a background thread, preventing the main UI thread from being blocked by heavy computations, thus keeping the UI responsive.",
          "options": [],
          "analysisPoints": [
            "Focuses on non-blocking UI.",
            "Mentions background thread execution."
          ],
          "keyConcepts": [
            "Web Workers",
            "UI Responsiveness",
            "Background Threads",
            "Main Thread"
          ],
          "evaluationCriteria": [
            "Understanding core benefit",
            "Concise explanation"
          ],
          "example": "",
          "tags": [
            "web-workers",
            "performance",
            "concurrency"
          ],
          "prerequisites": [
            "javascript_async"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_web_workers_2",
          "topic": "Web Workers Communication",
          "level": "medium",
          "type": "open",
          "question": "Describe how data is transferred between a dedicated Web Worker and the main thread. What is the default mechanism, and what is its potential drawback for large data?",
          "answer": "Data is transferred between a dedicated Web Worker and the main thread using the `postMessage()` method to send data and an `onmessage` event handler to receive it.\n\nBy default, the mechanism for data transfer is **structured cloning**. This means that when data is sent via `postMessage()`, a complete copy of the data is created in the receiving context. The original object in the sending context remains unchanged.\n\nThe potential drawback for large data is **performance overhead**. Copying large amounts of data can be slow and memory-intensive, as it involves serialization in the sending thread and deserialization in the receiving thread, potentially blocking the main thread for a noticeable duration if the data is substantial.",
          "options": [],
          "analysisPoints": [
            "Explains `postMessage` and `onmessage`.",
            "Identifies 'structured cloning' as the default mechanism.",
            "Highlights performance and memory overhead as drawbacks for large data due to copying."
          ],
          "keyConcepts": [
            "Web Workers",
            "postMessage",
            "onmessage",
            "Structured Cloning",
            "Performance",
            "Data Transfer"
          ],
          "evaluationCriteria": [
            "Understanding of worker communication API",
            "Knowledge of underlying data transfer mechanisms",
            "Ability to identify performance bottlenecks"
          ],
          "example": "",
          "tags": [
            "web-workers",
            "performance",
            "data-transfer",
            "javascript"
          ],
          "prerequisites": [
            "web_workers"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_web_workers_3",
          "topic": "Dedicated vs. Shared Workers",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements accurately describes a key difference between a Dedicated Worker and a Shared Worker?",
          "answer": "A Shared Worker can be accessed by multiple browsing contexts (e.g., different tabs or iframes) from the same origin, while a Dedicated Worker communicates with only one.",
          "options": [
            "Dedicated Workers have access to the DOM, while Shared Workers do not.",
            "Shared Workers use `postMessage()` for communication, while Dedicated Workers use `port.postMessage()`.",
            "A Shared Worker can be accessed by multiple browsing contexts (e.g., different tabs or iframes) from the same origin, while a Dedicated Worker communicates with only one.",
            "Dedicated Workers are suitable for long-running tasks, but Shared Workers are not."
          ],
          "analysisPoints": [
            "Correctly identifies the multi-context access of Shared Workers versus single-context of Dedicated Workers.",
            "Debunks the false claim about DOM access (neither has direct DOM access).",
            "Clarifies that both use `postMessage`-like mechanisms, but Shared Workers use it via a `Port` object.",
            "Correctly implies both are suitable for long-running tasks."
          ],
          "keyConcepts": [
            "Dedicated Workers",
            "Shared Workers",
            "Web Workers Comparison",
            "Browsing Contexts",
            "Communication"
          ],
          "evaluationCriteria": [
            "Distinguishing characteristics of different worker types",
            "Understanding of worker scope and access",
            "Accuracy of technical details"
          ],
          "example": "The key distinction between Dedicated and Shared Workers lies in their scope. A Dedicated Worker is bound to the script that created it, communicating exclusively with that single browsing context (e.g., one tab). A Shared Worker, conversely, can establish connections with multiple browsing contexts (such as different tabs, windows, or iframes) that share the same origin. This makes Shared Workers ideal for coordinating tasks or sharing state across multiple parts of a web application.",
          "tags": [
            "web-workers",
            "architecture",
            "concurrency"
          ],
          "prerequisites": [
            "web_workers"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_web_workers_4",
          "topic": "Web Workers API Access",
          "level": "hard",
          "type": "open",
          "question": "While Web Workers are powerful for offloading computations, they have limitations regarding browser API access. List three significant browser APIs or global objects that Web Workers *do not* have direct access to, and explain why this restriction exists.",
          "answer": "Web Workers operate in a separate global scope and do not have direct access to:\n\n1.  **The DOM (Document Object Model)**: This means they cannot directly manipulate HTML elements (`document`, `window.document`, `getElementById`, `querySelector`, etc.). This restriction exists because DOM manipulation is inherently a main-thread activity, and allowing workers to directly modify the DOM would introduce complex synchronization issues and potential race conditions between the worker and the main thread, leading to a janky or broken UI.\n2.  **The `window` object (and its properties like `alert`, `confirm`, `location`, `history`)**: Workers do not have access to the main `window` object or its direct properties/methods. This is because the `window` object represents the browser's main thread environment and its visual aspects. Allowing workers to control `window` properties would break the isolation model and could lead to unpredictable behavior and security vulnerabilities.\n3.  **Direct access to `localStorage` and `sessionStorage`**: While workers can access `IndexedDB` (which is asynchronous), they cannot directly access `localStorage` or `sessionStorage` (which are synchronous APIs tied to the main thread's `window` object). This restriction ensures that these synchronous storage APIs do not block the main thread, and prevents workers from directly causing UI freezes by performing blocking storage operations.",
          "options": [],
          "analysisPoints": [
            "Identifies DOM, `window`, `localStorage`/`sessionStorage` as restricted APIs.",
            "Explains the rationale for each restriction (e.g., preventing UI blocking, synchronization issues, security, isolation model).",
            "Demonstrates a deeper understanding of the worker's execution environment."
          ],
          "keyConcepts": [
            "Web Workers Limitations",
            "DOM Access",
            "Window Object",
            "LocalStorage",
            "SessionStorage",
            "Thread Isolation"
          ],
          "evaluationCriteria": [
            "Knowledge of worker API restrictions",
            "Ability to explain the underlying reasons for these restrictions",
            "Understanding of browser architecture"
          ],
          "example": "",
          "tags": [
            "web-workers",
            "browser-apis",
            "limitations",
            "architecture"
          ],
          "prerequisites": [
            "web_workers"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_transferable_objects_1",
          "topic": "Transferable Objects Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using Transferable Objects when communicating with Web Workers?",
          "answer": "Transferable Objects allow data to be passed between execution contexts (like main thread and worker) with near-zero copying cost, improving performance for large datasets.",
          "options": [],
          "analysisPoints": [
            "Highlights performance gain.",
            "Mentions 'near-zero copying cost' or 'transfer of ownership'."
          ],
          "keyConcepts": [
            "Transferable Objects",
            "Performance",
            "Web Workers",
            "Data Transfer"
          ],
          "evaluationCriteria": [
            "Quick recall of core benefit",
            "Concise explanation"
          ],
          "example": "",
          "tags": [
            "performance",
            "web-workers",
            "memory"
          ],
          "prerequisites": [
            "web_workers"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_transferable_objects_2",
          "topic": "Transferable Object State",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code snippet:\n\n```typescript\nconst myBuffer = new ArrayBuffer(1024);\nconst worker = new Worker('my-worker.js');\n\nworker.postMessage({ buffer: myBuffer }, [myBuffer]);\n\n// What is the state of `myBuffer` immediately after the postMessage call in the main thread?\nconsole.log(myBuffer.byteLength);\n```\n\nWhat will be the output of `console.log(myBuffer.byteLength)` in the main thread after the `postMessage` call?",
          "answer": "0",
          "options": [
            "1024",
            "0",
            "An error will be thrown",
            "undefined"
          ],
          "analysisPoints": [
            "Correctly understands that `ArrayBuffer` is a Transferable Object.",
            "Knows that a transferred `ArrayBuffer` becomes 'neutered' in the sending context.",
            "Connects 'neutered' to its `byteLength` becoming 0."
          ],
          "keyConcepts": [
            "Transferable Objects",
            "ArrayBuffer",
            "Neutered",
            "Ownership Transfer",
            "postMessage"
          ],
          "evaluationCriteria": [
            "Detailed understanding of Transferable Objects' behavior",
            "Ability to predict side effects of API calls"
          ],
          "example": "When an `ArrayBuffer` is transferred via `postMessage` using the second argument (the `transferList`), its ownership is moved to the receiving context (the worker). In the sending context (the main thread), the `ArrayBuffer` becomes 'neutered', meaning its internal data pointer is detached, and its `byteLength` property becomes 0. Any attempt to access or modify the `ArrayBuffer` or any `TypedArray` views on it in the original context will typically result in an error or undefined behavior.",
          "tags": [
            "web-workers",
            "performance",
            "memory",
            "arraybuffer"
          ],
          "prerequisites": [
            "transferable_objects",
            "typed_arrays"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_transferable_objects_3",
          "topic": "Transferable Object Types",
          "level": "medium",
          "type": "open",
          "question": "Besides `ArrayBuffer`, name two other types of objects that are commonly supported as Transferable Objects. For each, briefly describe a use case where transferring it would be beneficial.",
          "answer": "Two other types of objects commonly supported as Transferable Objects are:\n\n1.  **`MessagePort`**: A `MessagePort` represents one end of a communication channel. You can create a `MessageChannel` and then transfer one of its ports to a worker (or another window/iframe). This is beneficial when you need to establish a direct, dedicated communication line between two contexts without necessarily going through the main `Worker` instance's `postMessage` (e.g., setting up a direct communication between two workers, or between a worker and a nested iframe).\n2.  **`ImageBitmap`**: An `ImageBitmap` is an opaque object representing a bitmap image, which can be created from various sources like `<img>` elements, `Blob`s, or `CanvasImageSource`. Transferring `ImageBitmap`s is beneficial when you want to perform image processing or rendering on an `OffscreenCanvas` within a Web Worker. Instead of serializing raw pixel data (which would be slow), the `ImageBitmap` can be transferred efficiently, allowing the worker to directly use it for drawing without blocking the main thread.",
          "options": [],
          "analysisPoints": [
            "Identifies `MessagePort` and `ImageBitmap` (or `OffscreenCanvas`).",
            "Provides a valid use case for each, demonstrating understanding of their purpose.",
            "Highlights the performance benefit of transferring each type."
          ],
          "keyConcepts": [
            "Transferable Objects",
            "MessagePort",
            "ImageBitmap",
            "OffscreenCanvas",
            "Use Cases",
            "Performance"
          ],
          "evaluationCriteria": [
            "Knowledge of various Transferable Object types",
            "Ability to articulate practical use cases and benefits"
          ],
          "example": "",
          "tags": [
            "web-workers",
            "performance",
            "image-processing",
            "communication"
          ],
          "prerequisites": [
            "web_workers",
            "transferable_objects"
          ],
          "complexity": 8,
          "interviewFrequency": 5,
          "learningPath": "advanced"
        },
        {
          "id": "question_transferable_objects_4",
          "topic": "Transferable Objects vs. Structured Cloning",
          "level": "hard",
          "type": "open",
          "question": "Compare the performance implications of transferring a large `ArrayBuffer` using `postMessage(data, [data.buffer])` versus simply sending a regular JavaScript array of numbers `postMessage(data)` that implicitly uses structured cloning. Why is the former significantly more performant for large datasets?",
          "answer": "When sending data via `postMessage`:\n\n1.  **Structured Cloning (`postMessage(data)`)**:\n    *   **Mechanism**: The browser creates a deep copy of the JavaScript array. For large arrays, this involves iterating over every element, allocating new memory, and copying the value to the new location.\n    *   **Performance Implications**: This process can be computationally expensive and time-consuming for large datasets. It consumes significant CPU cycles and memory on both the sending (serialization) and receiving (deserialization) threads. If done on the main thread, it can lead to UI freezes and jank.\n\n2.  **Transferable Objects (`postMessage({ buffer: data.buffer }, [data.buffer])`)**:\n    *   **Mechanism**: The ownership of the underlying raw binary data buffer (`ArrayBuffer`) is *transferred* from the sending context to the receiving context. The actual memory is not copied. Instead, internal pointers are updated.\n    *   **Performance Implications**: This is a near-zero-cost operation. It's extremely fast regardless of the size of the `ArrayBuffer` because no serialization or deserialization of the large data occurs. The primary overhead is just updating references and metadata. The original `ArrayBuffer` in the sending context becomes \"neutered\" (unusable).\n\n**Why the former is significantly more performant for large datasets:**\nThe key difference is the avoidance of data copying. Structured cloning is akin to making a duplicate of a large file, which takes time proportional to the file size. Transferring an `ArrayBuffer` is like simply changing the owner of that file without duplicating it; the file itself doesn't move, and the operation's time is constant, regardless of the file's size. For multi-megabyte or gigabyte datasets, this difference translates into orders of magnitude faster transfer times and avoids blocking the main thread.",
          "options": [],
          "analysisPoints": [
            "Clearly describes structured cloning as a deep copy mechanism.",
            "Clearly describes Transferable Objects as an ownership transfer mechanism.",
            "Highlights the 'no copying' aspect as the core performance differentiator.",
            "Explains the impact on CPU, memory, and main thread blocking for both."
          ],
          "keyConcepts": [
            "Transferable Objects",
            "Structured Cloning",
            "ArrayBuffer",
            "Performance Optimization",
            "Memory Management",
            "Web Workers"
          ],
          "evaluationCriteria": [
            "Deep technical understanding of data transfer mechanisms",
            "Ability to articulate performance trade-offs",
            "Comparison and contrast skills"
          ],
          "example": "",
          "tags": [
            "web-workers",
            "performance",
            "memory",
            "arraybuffer",
            "optimization"
          ],
          "prerequisites": [
            "transferable_objects",
            "web_workers"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_js_perf_opt_1",
          "topic": "JavaScript Performance Optimization Techniques",
          "level": "easy",
          "type": "flashcard",
          "question": "Which JavaScript API is specifically designed to synchronize animations and visual updates with the browser's repaint cycle?",
          "answer": "`requestAnimationFrame`",
          "options": [],
          "analysisPoints": [
            "Identifies the specific API for animations.",
            "Mentions its role in synchronization with repaint."
          ],
          "keyConcepts": [
            "requestAnimationFrame",
            "Animation",
            "Browser Rendering"
          ],
          "evaluationCriteria": [
            "Quick recall",
            "Understanding of API purpose"
          ],
          "example": "",
          "tags": [
            "performance",
            "animation",
            "browser"
          ],
          "prerequisites": [
            "javascript_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_js_perf_opt_2",
          "topic": "Debouncing vs. Throttling",
          "level": "medium",
          "type": "open",
          "question": "Explain the difference between debouncing and throttling. Provide a practical web development scenario where each technique would be more appropriate.",
          "answer": "Both debouncing and throttling are techniques used to control the frequency of function execution, primarily for events that fire rapidly (e.g., `scroll`, `resize`, `input`).\n\n1.  **Debouncing**:\n    *   **Mechanism**: Delays the execution of a function until a certain amount of time has passed *since the last time it was invoked*. If the function is called again within the delay period, the timer is reset.\n    *   **Goal**: Ensure a function is only called *after* a period of inactivity.\n    *   **Scenario**: A search input field with live suggestions. You want to make an API call to fetch suggestions, but only after the user has stopped typing for a short duration (e.g., 300ms). Debouncing prevents an API call on every single keystroke, saving resources and improving responsiveness.\n\n2.  **Throttling**:\n    *   **Mechanism**: Limits how often a function can be called to at most once within a specified time window. If the function is called multiple times within that window, subsequent calls are ignored until the window expires.\n    *   **Goal**: Ensure a function is called *at most* once per interval.\n    *   **Scenario**: Handling a `scroll` event to update an element's position (e.g., parallax scrolling) or load more content. You want to update the UI regularly but not excessively. Throttling to, say, 100ms means the UI updates will occur smoothly without overwhelming the browser or causing jank, even if the user scrolls very fast.",
          "options": [],
          "analysisPoints": [
            "Clearly distinguishes the mechanisms of debouncing (after inactivity) and throttling (at most once per interval).",
            "Provides relevant and distinct practical scenarios for each.",
            "Highlights the specific goals of each technique."
          ],
          "keyConcepts": [
            "Debouncing",
            "Throttling",
            "Event Handling",
            "Performance Optimization",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Precise definitions of both concepts",
            "Ability to apply concepts to real-world problems",
            "Understanding of performance implications"
          ],
          "example": "",
          "tags": [
            "performance",
            "event-handling",
            "javascript",
            "optimization"
          ],
          "prerequisites": [
            "javascript_functions",
            "event_listeners"
          ],
          "complexity": 7,
          "interviewFrequency": 10,
          "learningPath": "intermediate"
        },
        {
          "id": "question_js_perf_opt_3",
          "topic": "Offloading Heavy Tasks",
          "level": "medium",
          "type": "mcq",
          "question": "A web application performs a complex mathematical calculation that takes several seconds to complete, causing the UI to become unresponsive. Which optimization technique is *most effective* for preventing the UI from freezing while this calculation runs?",
          "answer": "Offloading the calculation to a Web Worker",
          "options": [
            "Debouncing the calculation function",
            "Throttling the calculation function",
            "Using `requestAnimationFrame` for the calculation",
            "Offloading the calculation to a Web Worker"
          ],
          "analysisPoints": [
            "Identifies the core problem: UI freezing due to long synchronous task.",
            "Recognizes that only Web Workers execute code in a separate thread, truly preventing main thread blocking.",
            "Understands that debouncing/throttling reduce frequency, not solve blocking; `requestAnimationFrame` is for visual updates, not heavy computation."
          ],
          "keyConcepts": [
            "Web Workers",
            "Performance Optimization",
            "UI Responsiveness",
            "Main Thread Blocking"
          ],
          "evaluationCriteria": [
            "Ability to diagnose performance problems",
            "Selection of the most appropriate solution for a given problem",
            "Understanding of the core mechanism of each technique"
          ],
          "example": "When a complex mathematical calculation takes several seconds, it's a CPU-bound task that will block the main thread. To prevent the UI from freezing, the most effective solution is to move this computation off the main thread entirely by running it in a **Web Worker**. Debouncing and throttling only control *when* a function runs, not *where* it runs, and `requestAnimationFrame` is for visual synchronization, not general computation.",
          "tags": [
            "web-workers",
            "performance",
            "optimization",
            "concurrency"
          ],
          "prerequisites": [
            "web_workers",
            "js_performance_optimization"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_js_perf_opt_4",
          "topic": "Task Chunking",
          "level": "hard",
          "type": "open",
          "question": "You have a long, synchronous JavaScript function that processes a large array of data. While it's not feasible to move this task to a Web Worker, you need to prevent it from blocking the UI entirely. Describe how you can use 'task chunking' with `setTimeout(..., 0)` to make the UI more responsive, and explain the underlying principle.",
          "answer": "To prevent a long, synchronous JavaScript function from blocking the UI, you can employ 'task chunking' by breaking the large task into smaller, manageable pieces and processing each piece in a separate turn of the event loop using `setTimeout(..., 0)`.\n\n**Algorithm:**\n1.  **Divide the Task**: Split the large array (or computation) into smaller chunks.\n2.  **Process Chunks Iteratively**: Create a recursive or iterative function that processes one chunk at a time.\n3.  **Yield Control**: After processing each chunk, instead of immediately processing the next one, schedule the processing of the next chunk using `setTimeout(myFunctionForNextChunk, 0)`.\n\n**Underlying Principle (Event Loop):**\nJavaScript runs on a single thread with an **event loop**. When `setTimeout(..., 0)` is called, it doesn't execute the callback immediately. Instead, it places the callback function at the end of the current task queue (or macrotask queue). This allows the browser to:\n-   Complete the current task (the processing of the *current* chunk).\n-   Check the event queue for other pending tasks, including rendering updates, user input events, and network responses.\n-   Execute any microtasks (like Promise callbacks) that were scheduled.\n-   Then, pick up the `setTimeout` callback from the task queue.\n\nBy yielding control back to the event loop with `setTimeout(0)`, you effectively give the browser opportunities to process other events, paint updates, and respond to user interactions between each chunk of your long-running task. This creates an illusion of responsiveness, even though the overall task might take the same amount of time or slightly longer due to the overhead of `setTimeout` scheduling.",
          "options": [],
          "analysisPoints": [
            "Defines task chunking as breaking down and processing in parts.",
            "Explains the role of `setTimeout(0)` in yielding control.",
            "Details how `setTimeout(0)` interacts with the event loop.",
            "Articulates how this prevents UI blocking (allows browser to render/handle input)."
          ],
          "keyConcepts": [
            "Task Chunking",
            "Event Loop",
            "setTimeout(0)",
            "UI Responsiveness",
            "JavaScript Performance",
            "Macrotasks"
          ],
          "evaluationCriteria": [
            "In-depth understanding of JavaScript event loop",
            "Ability to describe complex optimization patterns",
            "Clarity in explaining the 'why' and 'how'"
          ],
          "example": "```typescript\nfunction processLargeArrayInChunks(dataArray, chunkSize = 100) {\n  let index = 0;\n\n  function processNextChunk() {\n    const end = Math.min(index + chunkSize, dataArray.length);\n    for (let i = index; i < end; i++) {\n      // Simulate heavy computation\n      console.log(`Processing item ${i}: ${dataArray[i]}`);\n      // For example, dataArray[i] = dataArray[i] * 2;\n    }\n    index = end;\n\n    if (index < dataArray.length) {\n      // Schedule next chunk processing in the next event loop tick\n      setTimeout(processNextChunk, 0);\n    } else {\n      console.log('Finished processing all chunks.');\n    }\n  }\n\n  // Start processing the first chunk\n  processNextChunk();\n}\n\nconst largeData = Array.from({ length: 5000 }, (_, i) => i + 1);\nconsole.log('Starting long operation...');\nprocessLargeArrayInChunks(largeData);\nconsole.log('UI remains responsive while processing... (e.g., you can still click buttons)');\n```",
          "tags": [
            "performance",
            "javascript",
            "event-loop",
            "optimization"
          ],
          "prerequisites": [
            "js_performance_optimization",
            "javascript_async"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_resize_observer_1",
          "topic": "ResizeObserver Timing",
          "level": "medium",
          "type": "flashcard",
          "question": "Regarding the browser's rendering pipeline, when does `ResizeObserver` typically deliver its notifications?",
          "answer": "`ResizeObserver` delivers notifications after layout but before paint.",
          "options": [],
          "analysisPoints": [
            "Accurate recall of the specific timing relative to rendering phases.",
            "Indicates understanding of the rendering pipeline."
          ],
          "keyConcepts": [
            "ResizeObserver",
            "Rendering Pipeline",
            "Layout",
            "Paint"
          ],
          "evaluationCriteria": [
            "Precise factual recall",
            "Knowledge of browser internals"
          ],
          "example": "",
          "tags": [
            "browser-apis",
            "performance",
            "rendering"
          ],
          "prerequisites": [
            "resize_observer"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_resize_observer_2",
          "topic": "ResizeObserver Benefits of Timing",
          "level": "hard",
          "type": "open",
          "question": "Why is the specific timing of `ResizeObserver` notifications (after layout but before paint) beneficial for performance and preventing visual jank?",
          "answer": "The timing of `ResizeObserver` notifications (after layout but before paint) is crucial for performance and preventing visual jank for the following reasons:\n\n1.  **Prevents Layout Thrashing/Multiple Reflows**: When a `ResizeObserver`'s callback is triggered after layout, the browser has already calculated all the dimensions and positions of elements. If the callback then makes changes to the DOM or styles that affect layout, the browser can perform *another* layout pass immediately. Since both the initial layout change and any subsequent layout changes from the observer's callback occur within the same animation frame, the browser only needs to perform one repaint at the end of the frame. This prevents costly 'layout thrashing' (repeated, synchronous forced layout calculations) which occurs when JavaScript reads layout information then immediately writes new layout information, forcing recalculations mid-frame.\n2.  **Synchronized Visual Updates**: By allowing changes *before* paint, the observer can adjust the element's appearance (e.g., font size, aspect ratio, internal component arrangement) or other related elements' layouts based on the new dimensions. These adjustments will then be incorporated into the *single* upcoming paint operation for that frame. If the changes were made *after* paint, it would necessitate a separate, additional repaint cycle, leading to visible flickering or 'jank'.\n3.  **Efficiency for Responsive Components**: This timing makes `ResizeObserver` highly efficient for building responsive UI components that self-adjust. They can react to their own size changes, or the size changes of parent elements, and perform necessary layout adjustments in a single, optimized browser cycle, ensuring smooth and seamless user experience.",
          "options": [],
          "analysisPoints": [
            "Explains how it prevents layout thrashing/multiple reflows.",
            "Details how changes made in the callback are incorporated into a single paint.",
            "Contrasts with what would happen if timing were different (jank, extra repaints).",
            "Connects to efficient responsive component design."
          ],
          "keyConcepts": [
            "ResizeObserver",
            "Rendering Pipeline",
            "Layout Thrashing",
            "Reflow",
            "Repaint",
            "Performance Optimization",
            "Visual Jank"
          ],
          "evaluationCriteria": [
            "Deep understanding of browser rendering mechanisms",
            "Ability to explain the performance implications of API design choices",
            "Detailed articulation of benefits"
          ],
          "example": "",
          "tags": [
            "performance",
            "browser-apis",
            "rendering",
            "responsive-design"
          ],
          "prerequisites": [
            "resize_observer",
            "js_performance_optimization"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_resize_observer_3",
          "topic": "ResizeObserver vs. Window Resize",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following scenarios is `ResizeObserver` primarily designed to handle more efficiently than traditional `window.onresize` event listeners?",
          "answer": "Dynamically adjusting a custom component's internal layout when its parent container changes size.",
          "options": [
            "Detecting when the browser tab is closed.",
            "Responding to changes in the overall browser window dimensions.",
            "Monitoring network connection status changes.",
            "Dynamically adjusting a custom component's internal layout when its parent container changes size."
          ],
          "analysisPoints": [
            "Identifies `ResizeObserver`'s unique capability to observe specific element sizes, not just the window.",
            "Recognizes that `window.onresize` is for global window size changes, not individual element changes.",
            "Excludes irrelevant options like tab closing or network status."
          ],
          "keyConcepts": [
            "ResizeObserver",
            "Window.onresize",
            "Responsive Components",
            "Element Sizing"
          ],
          "evaluationCriteria": [
            "Understanding of API's specific use case",
            "Comparison of related APIs",
            "Ability to identify appropriate tools for a task"
          ],
          "example": "`window.onresize` only triggers when the entire browser window is resized. However, a component's size might change for many other reasons, such as its parent container shrinking, content within it changing, or CSS layout properties being altered. `ResizeObserver` is specifically designed to efficiently observe and react to these *element-level* size changes, making it far superior for building truly responsive and adaptable UI components, such as a component that adjusts its font size or image layout based on its own dynamically computed width or height.",
          "tags": [
            "browser-apis",
            "responsive-design",
            "ui-components"
          ],
          "prerequisites": [
            "resize_observer"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_drag_drop_file_1",
          "topic": "Drag and Drop Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What two core DOM events must you `preventDefault()` for when implementing custom drag-and-drop file functionality?",
          "answer": "`dragover` and `drop`",
          "options": [],
          "analysisPoints": [
            "Recalls the specific events required for custom drag-and-drop handling.",
            "Emphasizes the necessity of `preventDefault()` for these events."
          ],
          "keyConcepts": [
            "Drag and Drop",
            "DOM Events",
            "preventDefault"
          ],
          "evaluationCriteria": [
            "Factual recall",
            "Understanding of event handling basics"
          ],
          "example": "",
          "tags": [
            "dom-events",
            "drag-and-drop",
            "javascript"
          ],
          "prerequisites": [
            "dom_manipulation"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_drag_drop_file_2",
          "topic": "FileReader API",
          "level": "medium",
          "type": "mcq",
          "question": "After a user drags and drops a text file onto your web page, you access the `File` object. Which `FileReader` method would you use to read the file's content as a plain text string?",
          "answer": "`readAsText(file)`",
          "options": [
            "`readFile(file)`",
            "`readAsDataURL(file)`",
            "`readAsText(file)`",
            "`readAsBlob(file)`"
          ],
          "analysisPoints": [
            "Correctly identifies `readAsText` as the method for plain text.",
            "Differentiates it from other `FileReader` methods like `readAsDataURL`.",
            "Knows the correct method signature (takes `file` object)."
          ],
          "keyConcepts": [
            "FileReader API",
            "File Object",
            "readAsText",
            "Drag and Drop"
          ],
          "evaluationCriteria": [
            "Knowledge of FileReader API methods",
            "Ability to select appropriate method for specific data type"
          ],
          "example": "The `FileReader.readAsText()` method is specifically designed to read the contents of a `File` or `Blob` object as a text string. `readAsDataURL()` would return a Base64 encoded string, `readAsArrayBuffer()` would return an `ArrayBuffer`, and `readFile()` is not a standard `FileReader` method. Therefore, `readAsText(file)` is the correct choice for obtaining plain text content.",
          "tags": [
            "file-api",
            "javascript",
            "browser-apis"
          ],
          "prerequisites": [
            "drag_drop_file_reading"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_drag_drop_file_3",
          "topic": "Drag and Drop File Access",
          "level": "medium",
          "type": "open",
          "question": "When handling the `drop` event for a drag-and-drop file upload, how do you access the dropped files in JavaScript? What type of object is returned, and what properties might you check on it?",
          "answer": "When handling the `drop` event, you can access the dropped files via `event.dataTransfer.files`.\n\nThis property returns a **`FileList`** object. A `FileList` is an array-like object (but not a true array) containing `File` objects.\n\nEach `File` object in the `FileList` represents a dropped file and has several useful properties that you might check:\n-   **`name`**: The name of the file (e.g., `document.txt`). Useful for displaying the filename or checking the file extension.\n-   **`type`**: The MIME type of the file (e.g., `text/plain`, `image/png`, `application/pdf`). Crucial for validating the type of file dropped.\n-   **`size`**: The size of the file in bytes. Useful for displaying file size or enforcing size limits.\n-   **`lastModified`**: The last modified date of the file as a Unix timestamp.\n-   **`lastModifiedDate`**: The last modified date of the file as a `Date` object (deprecated).",
          "options": [],
          "analysisPoints": [
            "Correctly identifies `event.dataTransfer.files`.",
            "States that a `FileList` object is returned.",
            "Lists and explains relevant properties of the `File` object (`name`, `type`, `size`)."
          ],
          "keyConcepts": [
            "Drag and Drop",
            "Drop Event",
            "FileList",
            "File Object",
            "dataTransfer"
          ],
          "evaluationCriteria": [
            "Knowledge of event object properties",
            "Understanding of File API objects",
            "Ability to describe practical usage"
          ],
          "example": "",
          "tags": [
            "dom-events",
            "file-api",
            "javascript"
          ],
          "prerequisites": [
            "drag_drop_file_reading"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_drag_drop_file_4",
          "topic": "Drag and Drop Error Handling",
          "level": "hard",
          "type": "coding",
          "question": "You are implementing a drag-and-drop functionality for image files only. Provide the JavaScript code snippet for the `drop` event handler that:\n1.  Prevents the browser's default behavior.\n2.  Retrieves the first dropped file.\n3.  Checks if the file's MIME type starts with 'image/' (e.g., 'image/png', 'image/jpeg').\n4.  If it's an image, logs 'Image file dropped: [filename]'.\n5.  If it's not an image, logs 'Error: Please drop an image file.'.",
          "answer": "```typescript\ndropZone.addEventListener('drop', (e) => {\n  e.preventDefault(); // 1. Prevent default browser behavior\n\n  const files = e.dataTransfer.files;\n\n  if (files.length > 0) {\n    const file = files[0]; // 2. Retrieve the first dropped file\n\n    // 3. Check if the file's MIME type starts with 'image/'\n    if (file.type.startsWith('image/')) {\n      // 4. If it's an image, log filename\n      console.log(`Image file dropped: ${file.name}`);\n      // In a real app, you would then read and display the image\n    } else {\n      // 5. If it's not an image, log an error\n      console.log('Error: Please drop an image file.');\n    }\n  } else {\n    console.log('No files were dropped.');\n  }\n});\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `e.preventDefault()`.",
            "Accesses `e.dataTransfer.files` correctly.",
            "Properly selects the first file.",
            "Uses `file.type.startsWith('image/')` for robust MIME type validation.",
            "Provides distinct console outputs for success and error cases."
          ],
          "keyConcepts": [
            "Drag and Drop",
            "Drop Event",
            "File API",
            "MIME Type Validation",
            "Error Handling"
          ],
          "evaluationCriteria": [
            "Correct API usage for drag and drop",
            "Robust input validation",
            "Clear conditional logic",
            "Adherence to problem requirements"
          ],
          "example": "",
          "tags": [
            "coding-challenge",
            "dom-events",
            "file-api",
            "validation"
          ],
          "prerequisites": [
            "drag_drop_file_reading"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_shadow_dom_1",
          "topic": "Shadow DOM Identification",
          "level": "easy",
          "type": "flashcard",
          "question": "What does `#shadow-root` in the browser's developer tools inspector indicate?",
          "answer": "It indicates the root of a Shadow DOM, which is an isolated DOM tree attached to an element, encapsulating its structure and styles.",
          "options": [],
          "analysisPoints": [
            "Identifies `shadow-root` with Shadow DOM.",
            "Mentions encapsulation and isolated tree."
          ],
          "keyConcepts": [
            "Shadow DOM",
            "Developer Tools",
            "Encapsulation"
          ],
          "evaluationCriteria": [
            "Quick recall",
            "Understanding of visual cue"
          ],
          "example": "",
          "tags": [
            "shadow-dom",
            "web-components",
            "dev-tools"
          ],
          "prerequisites": [
            "shadow_dom"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_shadow_dom_2",
          "topic": "Shadow DOM Encapsulation",
          "level": "medium",
          "type": "open",
          "question": "Explain how Shadow DOM provides encapsulation for both DOM structure and CSS styles within a web component. Why is this beneficial for component development?",
          "answer": "Shadow DOM provides encapsulation in two primary ways:\n\n1.  **DOM Structure Encapsulation**: The internal DOM structure of a component placed within a Shadow DOM is isolated from the main document's DOM. This means that selectors used in the main document's JavaScript (e.g., `document.querySelector`, `getElementById`) or CSS (e.g., `div p`) cannot pierce into the shadow tree to accidentally select or modify elements within the component. Conversely, elements inside the shadow tree cannot accidentally select or modify elements in the light DOM outside of the component.\n\n2.  **CSS Style Encapsulation**: Styles defined within the Shadow DOM are scoped only to that shadow tree. They do not leak out to affect elements in the main document. Similarly, with few exceptions (like inherited CSS properties such as `font-family` or `color`), styles from the main document generally do not leak into the shadow tree. This is achieved because the browser re-scopes CSS selectors to only apply within the shadow boundary.\n\n**Benefits for component development:**\n-   **Modularity and Reusability**: Developers can create self-contained components without worrying about naming conflicts (e.g., duplicate `id`s or class names) or style collisions with other components or the host page. This makes components truly plug-and-play and highly reusable across different projects.\n-   **Predictability**: The component's internal behavior and appearance remain consistent regardless of where it's used, as its environment is strictly controlled.\n-   **Maintainability**: Reduces the complexity of CSS specificity management and makes debugging easier, as styles are localized to where they are defined.",
          "options": [],
          "analysisPoints": [
            "Details DOM isolation (selectors don't pierce).",
            "Details CSS isolation (styles don't leak in or out, mostly).",
            "Explains benefits like modularity, reusability, predictability, and maintainability.",
            "Demonstrates understanding of core Shadow DOM purpose."
          ],
          "keyConcepts": [
            "Shadow DOM",
            "Encapsulation",
            "DOM Isolation",
            "CSS Scoping",
            "Web Components",
            "Modularity"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of encapsulation mechanisms",
            "Articulation of benefits for component architecture",
            "Understanding of technical implementation (e.g., selector scoping)"
          ],
          "example": "",
          "tags": [
            "shadow-dom",
            "web-components",
            "css",
            "dom",
            "architecture"
          ],
          "prerequisites": [
            "shadow_dom"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_shadow_dom_3",
          "topic": "Shadow DOM Modes",
          "level": "medium",
          "type": "mcq",
          "question": "You're attaching a Shadow DOM to a custom element with `this.attachShadow({ mode: 'closed' })`. Which of the following statements is true regarding this configuration?",
          "answer": "The shadow root and its contents cannot be accessed directly from JavaScript in the main document.",
          "options": [
            "Styles from the main document will fully override styles within the shadow root.",
            "The shadow root and its contents cannot be accessed directly from JavaScript in the main document.",
            "The custom element can only be styled using external stylesheets linked from the main document.",
            "Events dispatched from within the shadow DOM will not bubble out to the light DOM."
          ],
          "analysisPoints": [
            "Correctly identifies the effect of `mode: 'closed'` (inaccessibility from main document JS).",
            "Understands that Shadow DOM style encapsulation generally prevents main document styles from overriding unless explicitly inherited.",
            "Knows that events generally *do* retarget and bubble out (unless specifically stopped), even from closed shadow roots.",
            "Differentiates from other aspects of Shadow DOM."
          ],
          "keyConcepts": [
            "Shadow DOM",
            "Closed Mode",
            "Open Mode",
            "Encapsulation",
            "JavaScript Access",
            "Event Bubbling"
          ],
          "evaluationCriteria": [
            "Knowledge of Shadow DOM modes and their implications",
            "Understanding of encapsulation boundaries",
            "Accuracy regarding event behavior"
          ],
          "example": "When a Shadow DOM is attached with `mode: 'closed'`, it means that the shadow root (and thus its internal DOM structure and styles) cannot be directly accessed or manipulated by JavaScript from the main document using `element.shadowRoot` or similar methods. This provides a stronger level of encapsulation, commonly used by built-in browser elements. Styles from the main document do not easily override shadow DOM styles, and events generally *do* retarget and bubble out (e.g., a click on a button inside a shadow DOM will still be detectable on a parent element in the light DOM, though the `event.target` will be the shadow host).",
          "tags": [
            "shadow-dom",
            "web-components",
            "javascript",
            "security"
          ],
          "prerequisites": [
            "shadow_dom"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_shadow_dom_4",
          "topic": "Shadow DOM Use Cases",
          "level": "hard",
          "type": "open",
          "question": "Provide two distinct examples of when using Shadow DOM would be highly beneficial, one involving a native HTML element and one involving a custom component you might build. Explain why it's beneficial in each case.",
          "answer": "1.  **Native HTML Element Example: `<video>` element**\n    *   **Description**: When you embed a `<video>` tag with the `controls` attribute, the browser renders a complex set of UI controls (play/pause button, timeline, volume slider, fullscreen button, etc.) for it. If you inspect a `<video>` element in dev tools, you'll see a `#shadow-root` containing all these internal elements.\n    *   **Benefit**: Shadow DOM isolates the internal structure and default styling of these video controls from the rest of your webpage. This means your global CSS rules won't accidentally break the video player's appearance, and the browser ensures consistent functionality across all websites without developers needing to re-implement or re-style complex native controls. It also prevents the numerous internal elements (buttons, sliders, divs) from polluting the main document's DOM and potentially clashing with global JavaScript queries.\n\n2.  **Custom Component Example: A `<custom-date-picker>` component**\n    *   **Description**: Imagine building a `<custom-date-picker>` element for a design system. This component would likely contain multiple internal elements (input fields, buttons for navigation, a grid for days, etc.) and specific styling to make it visually consistent across an application.\n    *   **Benefit**: By attaching a Shadow DOM to `<custom-date-picker>`, all its internal HTML and CSS are encapsulated. This prevents:\n        *   **Style Conflicts**: Your application's global CSS (e.g., `input { border: none; }`) from unintentionally styling the date picker's internal inputs.\n        *   **DOM Pollution**: The internal structure (e.g., `<div>`s, `<span>`s, `<button>`s) from appearing in the main document's DOM, which could lead to accidental selection by global JavaScript queries or rendering performance issues in extremely large applications. It guarantees that the component renders and behaves consistently regardless of the page it's embedded in.",
          "options": [],
          "analysisPoints": [
            "Provides a native HTML element example (`<video>`, `<input type='range'>`).",
            "Provides a plausible custom component example (`date-picker`, `modal`, `alert`).",
            "Articulates specific benefits (e.g., style isolation, DOM pollution prevention, consistency, reusability) for each example.",
            "Demonstrates real-world understanding of Shadow DOM's application."
          ],
          "keyConcepts": [
            "Shadow DOM",
            "Native Elements",
            "Custom Components",
            "Encapsulation",
            "Modularity",
            "Reusability"
          ],
          "evaluationCriteria": [
            "Practical application knowledge of Shadow DOM",
            "Ability to articulate specific advantages in real-world scenarios",
            "Clarity and conciseness of explanations"
          ],
          "example": "",
          "tags": [
            "shadow-dom",
            "web-components",
            "design-systems",
            "architecture",
            "use-cases"
          ],
          "prerequisites": [
            "shadow_dom"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_custom_elements_1",
          "topic": "Custom Elements Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the name of the base class that a Custom Element's JavaScript class must extend?",
          "answer": "`HTMLElement`",
          "options": [],
          "analysisPoints": [
            "Recalls the correct base class.",
            "Connects it to the Custom Elements API."
          ],
          "keyConcepts": [
            "Custom Elements",
            "HTMLElement",
            "Web Components"
          ],
          "evaluationCriteria": [
            "Factual recall",
            "Knowledge of basic API structure"
          ],
          "example": "",
          "tags": [
            "web-components",
            "javascript",
            "html"
          ],
          "prerequisites": [
            "custom_elements"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_custom_elements_2",
          "topic": "Custom Elements Benefits",
          "level": "medium",
          "type": "open",
          "question": "Beyond simply defining new HTML tags, what are two significant benefits of using Custom Elements in modern web development?",
          "answer": "Two significant benefits of using Custom Elements are:\n\n1.  **Reusability and Modularity**: Custom Elements allow developers to create truly self-contained, reusable UI components. Once defined, a custom element can be used anywhere in your HTML (`<my-button>`, `<user-avatar>`) just like native HTML tags. This promotes a modular architecture, making code easier to manage, share, and maintain across different parts of an application or even across multiple projects.\n2.  **Interoperability and Future-Proofing**: As a native web platform standard, Custom Elements are framework-agnostic. This means they can be used seamlessly with any JavaScript framework (React, Vue, Angular, Svelte) or even in projects with no framework at all. This provides a high degree of interoperability and makes your components more resilient to changes in the JavaScript framework ecosystem, ensuring they have a longer lifespan.",
          "options": [],
          "analysisPoints": [
            "Identifies reusability/modularity.",
            "Identifies interoperability/framework-agnostic nature.",
            "Explains how each benefit contributes to development (e.g., easier maintenance, longer lifespan)."
          ],
          "keyConcepts": [
            "Custom Elements",
            "Reusability",
            "Modularity",
            "Interoperability",
            "Framework-Agnostic",
            "Web Components"
          ],
          "evaluationCriteria": [
            "Understanding of architectural benefits",
            "Ability to articulate advantages beyond basic definition",
            "Insight into long-term development considerations"
          ],
          "example": "",
          "tags": [
            "web-components",
            "architecture",
            "modularity",
            "frontend-basics"
          ],
          "prerequisites": [
            "custom_elements"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_custom_elements_3",
          "topic": "Custom Elements Registration",
          "level": "medium",
          "type": "mcq",
          "question": "Which global object and method are used to register a new Custom Element with the browser?",
          "answer": "`customElements.define()`",
          "options": [
            "`document.registerElement()`",
            "`window.createCustomElement()`",
            "`customElements.define()`",
            "`HTMLElement.register()`"
          ],
          "analysisPoints": [
            "Correctly identifies `customElements` as the global registry.",
            "Identifies `define()` as the method for registration.",
            "Distinguishes from deprecated or non-existent methods."
          ],
          "keyConcepts": [
            "Custom Elements",
            "customElements",
            "define",
            "Web Components API"
          ],
          "evaluationCriteria": [
            "Knowledge of specific API calls for Custom Elements",
            "Accuracy of method names and objects"
          ],
          "example": "To register a new Custom Element, you use the static method `define()` on the `customElements` global object (which is an instance of `CustomElementRegistry`). The `define()` method takes two required arguments: the tag name for your custom element (which must contain a hyphen) and the JavaScript class that defines its behavior. For example: `customElements.define('my-component', MyComponentClass);`.",
          "tags": [
            "web-components",
            "javascript",
            "api-usage"
          ],
          "prerequisites": [
            "custom_elements"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_custom_elements_4",
          "topic": "Custom Elements Lifecycle",
          "level": "hard",
          "type": "open",
          "question": "Describe the purpose of the `connectedCallback()` and `attributeChangedCallback()` lifecycle methods in a Custom Element. What additional static method is required for `attributeChangedCallback()` to function correctly, and why?",
          "answer": "1.  **`connectedCallback()`**:\n    *   **Purpose**: This method is invoked by the browser each time the custom element is added to the document's DOM (or connected to it, which includes initial parsing, appending to a parent, or moving from one parent to another). It's a good place to perform initial setup that relies on the element being in the document, such as:\n        *   Attaching event listeners.\n        *   Fetching data.\n        *   Performing initial rendering if it depends on light DOM children.\n\n2.  **`attributeChangedCallback(name, oldValue, newValue)`**:\n    *   **Purpose**: This method is invoked when one of the custom element's observed attributes is added, removed, or changed. It receives the attribute's `name`, its `oldValue`, and its `newValue`.\n    *   **Use Case**: It allows the custom element to react dynamically to changes in its attributes, updating its internal state or re-rendering its UI accordingly (e.g., changing a `src` attribute on an `<img>` within the component).\n\n**Additional static method for `attributeChangedCallback()`:**\nFor `attributeChangedCallback()` to function, you *must* define a `static get observedAttributes()` method in your custom element class.\n\n**Why it's required:**\nThis static getter must return an array of strings, where each string is the name of an attribute that the custom element should observe for changes. The browser will *only* call `attributeChangedCallback()` for attributes listed in this array. This mechanism improves performance by allowing the browser to avoid unnecessary observation and callback invocations for attributes that your component doesn't care about, making the attribute change detection explicit and efficient.",
          "options": [],
          "analysisPoints": [
            "Clearly explains `connectedCallback`'s purpose and typical uses.",
            "Clearly explains `attributeChangedCallback`'s purpose and parameters.",
            "Identifies `static get observedAttributes()` as the required method.",
            "Explains *why* `observedAttributes` is needed (performance, explicit observation)."
          ],
          "keyConcepts": [
            "Custom Elements",
            "Lifecycle Callbacks",
            "connectedCallback",
            "attributeChangedCallback",
            "observedAttributes",
            "DOM Events",
            "Performance"
          ],
          "evaluationCriteria": [
            "In-depth knowledge of Custom Elements lifecycle",
            "Understanding of method parameters and return values",
            "Ability to explain the rationale behind API design"
          ],
          "example": "```typescript\nclass MyComponentWithLifecycle extends HTMLElement {\n  static get observedAttributes() {\n    return ['color', 'size']; // Only 'color' and 'size' changes will trigger attributeChangedCallback\n  }\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.innerHTML = `<p style=\"font-size: 16px; color: black;\">Hello</p>`;\n  }\n\n  connectedCallback() {\n    console.log('MyComponentWithLifecycle added to the DOM.');\n    // Initial setup, e.g., applying initial attribute values\n    this._updateStyle();\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    console.log(`Attribute ${name} changed from ${oldValue} to ${newValue}.`);\n    if (oldValue !== newValue) {\n      this._updateStyle();\n    }\n  }\n\n  _updateStyle() {\n    const p = this.shadowRoot.querySelector('p');\n    p.style.color = this.getAttribute('color') || 'black';\n    p.style.fontSize = (this.getAttribute('size') || '16') + 'px';\n  }\n}\ncustomElements.define('my-component-with-lifecycle', MyComponentWithLifecycle);\n\n// Example Usage:\n// <my-component-with-lifecycle color=\"red\"></my-component-with-lifecycle>\n// const el = document.querySelector('my-component-with-lifecycle');\n// el.setAttribute('size', '24'); // This will trigger attributeChangedCallback\n// el.setAttribute('data-test', 'abc'); // This will NOT trigger attributeChangedCallback\n```",
          "tags": [
            "web-components",
            "javascript",
            "lifecycle",
            "api-design",
            "performance"
          ],
          "prerequisites": [
            "custom_elements"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_cors_simulation",
          "title": "Client-Side CORS Error Handling Simulation",
          "description": "\nImplement a client-side JavaScript application that simulates a cross-origin `fetch` request and handles a potential CORS error gracefully. Since you cannot set up a server for this task, simulate the CORS error condition by checking the `response.ok` property and the `response.status` code, and provide a user-friendly message when a CORS-like error occurs.\n\n**Requirements:**\n1.  Create an HTML page with a button and a `div` to display messages.\n2.  When the button is clicked, initiate a `fetch` request to a mock API endpoint (e.g., `https://jsonplaceholder.typicode.com/posts/1`).\n3.  In the `fetch` `.then()` block, check the `response.ok` property and `response.status`. While `jsonplaceholder` doesn't *typically* cause CORS issues for `GET` requests, for the purpose of this simulation, if `response.ok` is `false` or `response.status` is, for example, `403` (Forbidden) which might imply a CORS-like access issue, display a 'CORS error' message.\n4.  If the fetch is successful (e.g., `response.ok` is true and status is 200), parse the JSON and display some data.\n5.  Use a `catch` block to handle actual network errors (e.g., no internet connection).\n6.  Display all messages in the designated `div` element.\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>CORS Simulation</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; }\n        #message-display { border: 1px solid #ccc; padding: 10px; min-height: 50px; margin-top: 10px; background-color: #f9f9f9; }\n        .error { color: red; font-weight: bold; }\n        .success { color: green; }\n    </style>\n</head>\n<body>\n    <h1>Fetch CORS Simulation</h1>\n    <button id=\"fetch-button\">Fetch Data</button>\n    <div id=\"message-display\"></div>\n\n    <script>\n        const fetchButton = document.getElementById('fetch-button');\n        const messageDisplay = document.getElementById('message-display');\n\n        fetchButton.addEventListener('click', async () => {\n            messageDisplay.textContent = 'Fetching data...';\n            messageDisplay.className = '';\n            const apiUrl = 'https://jsonplaceholder.typicode.com/posts/1'; // A typical API endpoint\n            // For simulating a CORS error, you might imagine fetching from 'http://example.invalid-cors.com/data'\n            // but since that's not possible in a static task, we'll use status checks.\n\n            try {\n                const response = await fetch(apiUrl);\n                \n                if (!response.ok) {\n                    // Simulate a CORS-like error for demonstration purposes if status is not 2xx\n                    if (response.status === 403 || response.status === 0) { // status 0 for network/CORS issues\n                        messageDisplay.textContent = `Error: Access to resource blocked (CORS-like issue, Status: ${response.status}). Check server configuration.`;\n                        messageDisplay.className = 'error';\n                    } else {\n                        messageDisplay.textContent = `HTTP Error: ${response.status} ${response.statusText}`;\n                        messageDisplay.className = 'error';\n                    }\n                } else {\n                    const data = await response.json();\n                    messageDisplay.textContent = `Success! Data fetched: ${JSON.stringify(data.title)}`;\n                    messageDisplay.className = 'success';\n                }\n            } catch (error) {\n                // This catch block handles network errors (e.g., offline, DNS issues)\n                messageDisplay.textContent = `Network Error: ${error.message}. Please check your internet connection.`;\n                messageDisplay.className = 'error';\n            }\n        });\n    </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>CORS Simulation</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; }\n        #message-display { border: 1px solid #ccc; padding: 10px; min-height: 50px; margin-top: 10px; background-color: #f9f9f9; }\n        .error { color: red; font-weight: bold; }\n        .success { color: green; }\n    </style>\n</head>\n<body>\n    <h1>Fetch CORS Simulation</h1>\n    <button id=\"fetch-button\">Fetch Data</button>\n    <div id=\"message-display\"></div>\n\n    <script>\n        const fetchButton = document.getElementById('fetch-button');\n        const messageDisplay = document.getElementById('message-display');\n\n        fetchButton.addEventListener('click', async () => {\n            messageDisplay.textContent = 'Fetching data...';\n            messageDisplay.className = '';\n            \n            // For a real CORS error, you'd try to fetch from a different origin \n            // that doesn't send Access-Control-Allow-Origin headers.\n            // For this task, we'll simulate based on status codes.\n            const mockApiUrl = 'https://jsonplaceholder.typicode.com/posts/1'; // This typically works (200 OK)\n            // To simulate a 'CORS-like' error, you could try fetching from a non-existent domain or a domain \n            // that you know will return specific HTTP errors, or modify the URL to a bad endpoint.\n            // For a robust test, we'll try to trigger a 404/500 and classify it.\n            const errorApiUrl = 'https://jsonplaceholder.typicode.com/nonexistent-path'; // This will return 404\n\n            try {\n                // Choose which URL to test by commenting/uncommenting\n                const response = await fetch(mockApiUrl); // Test success case\n                // const response = await fetch(errorApiUrl); // Test error case\n                \n                if (!response.ok) {\n                    // A browser blocking a CORS request due to missing headers will often\n                    // result in a network error (caught by .catch) or a status of 0.\n                    // Since we're using a public API that usually has CORS, we simulate\n                    // general access issues with common HTTP error codes.\n                    if (response.status >= 400 && response.status < 500) {\n                        messageDisplay.textContent = `Client Error: ${response.status} ${response.statusText}. Check request parameters or access permissions.`;\n                        messageDisplay.className = 'error';\n                    } else if (response.status >= 500) {\n                        messageDisplay.textContent = `Server Error: ${response.status} ${response.statusText}. Please try again later.`;\n                        messageDisplay.className = 'error';\n                    } else {\n                         // Catch-all for other non-ok responses, including actual CORS errors\n                         // which often appear as network errors (status 0) caught by the catch block\n                         messageDisplay.textContent = `Fetch failed with status: ${response.status} ${response.statusText}. Potential cross-origin access issue.`;\n                         messageDisplay.className = 'error';\n                    }\n                } else {\n                    const data = await response.json();\n                    messageDisplay.textContent = `Success! Data fetched: ${JSON.stringify(data.title)}`;\n                    messageDisplay.className = 'success';\n                }\n            } catch (error) {\n                // This catch block handles actual network errors (e.g., DNS, no internet, CORS preflight failures)\n                // For actual CORS issues where the browser blocks the request entirely,\n                // the fetch promise will reject with a TypeError (status 0).\n                if (error instanceof TypeError && error.message.includes('Failed to fetch')) {\n                    messageDisplay.textContent = `Network or CORS Error: Could not reach the server or access was denied. ${error.message}`;\n                } else {\n                    messageDisplay.textContent = `An unexpected error occurred: ${error.message}`;\n                }\n                messageDisplay.className = 'error';\n            }\n        });\n    </script>\n</body>\n</html>\n",
          "testCases": [
            "Click the button: Should display 'Fetching data...' then 'Success!' with fetched data.",
            "Modify `mockApiUrl` to 'https://jsonplaceholder.typicode.com/nonexistent-path' and click: Should display a client error (e.g., 404).",
            "Disable network connection and click: Should display a 'Network or CORS Error' message (TypeError: Failed to fetch).",
            "Ensure CSS classes are applied correctly for success and error messages."
          ],
          "hints": [
            "Remember that a `fetch` request's promise only rejects for network errors, not for HTTP error statuses (like 404 or 500). You need to check `response.ok` and `response.status` inside the first `.then()` block.",
            "A true CORS blocking error often manifests as a `TypeError: Failed to fetch` or similar network error in the `catch` block, sometimes with `response.status` being 0 (though this can also indicate other network issues).",
            "Consider using `async/await` with `try/catch` for cleaner asynchronous error handling."
          ],
          "tags": [
            "cors",
            "fetch-api",
            "error-handling",
            "networking",
            "frontend-basics"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_sop_cors",
            "javascript_fetch_api",
            "javascript_async"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "same_origin_policy",
            "cors_headers",
            "http_status_codes"
          ]
        },
        {
          "id": "task_user_preference_manager",
          "title": "User Preference Manager with LocalStorage",
          "description": "\nCreate a simple web application that allows a user to select a preferred theme (e.g., 'light', 'dark', 'system') and a preferred language (e.g., 'en', 'es', 'fr'). These preferences should persist across browser sessions.\n\n**Requirements:**\n1.  Create an HTML page with:\n    *   A heading displaying the current active theme and language.\n    *   Three radio buttons or a select dropdown for theme selection.\n    *   Three radio buttons or a select dropdown for language selection.\n    *   A button to 'Clear All Preferences'.\n2.  Implement JavaScript to:\n    *   **Load Preferences**: On page load, check `localStorage` for saved theme and language preferences. If found, apply them to the UI and display them.\n    *   **Save Preferences**: When a user selects a new theme or language, save the new preference to `localStorage`.\n    *   **Apply Theme/Language**: Dynamically update the page's appearance (e.g., change `body` background/text color for theme) and the displayed language text based on the selections.\n    *   **Clear Preferences**: When the 'Clear All Preferences' button is clicked, remove both theme and language preferences from `localStorage` and reset the UI to default settings.\n3.  Ensure that changes persist even if the browser tab is closed and reopened.\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>User Preferences</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; transition: background-color 0.3s, color 0.3s; }\n        .container { max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #eee; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        .option-group { margin-bottom: 15px; }\n        label { display: block; margin-bottom: 5px; font-weight: bold; }\n        input[type=\"radio\"] { margin-right: 5px; }\n        button { padding: 10px 15px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; }\n        button:hover { background-color: #0056b3; }\n\n        /* Theme styles */\n        body.light-theme { background-color: #f0f0f0; color: #333; }\n        body.dark-theme { background-color: #333; color: #f0f0f0; }\n        body.system-theme { background-color: white; color: black; } /* Default */\n    </style>\n</head>\n<body class=\"system-theme\">\n    <div class=\"container\">\n        <h1>User Preference Manager</h1>\n        <p>Current Theme: <span id=\"current-theme\">System</span></p>\n        <p>Current Language: <span id=\"current-language\">English</span></p>\n\n        <div class=\"option-group\">\n            <label>Select Theme:</label>\n            <input type=\"radio\" name=\"theme\" value=\"light\" id=\"theme-light\"> <label for=\"theme-light\">Light</label>\n            <input type=\"radio\" name=\"theme\" value=\"dark\" id=\"theme-dark\"> <label for=\"theme-dark\">Dark</label>\n            <input type=\"radio\" name=\"theme\" value=\"system\" id=\"theme-system\"> <label for=\"theme-system\">System Default</label>\n        </div>\n\n        <div class=\"option-group\">\n            <label>Select Language:</label>\n            <input type=\"radio\" name=\"language\" value=\"en\" id=\"lang-en\"> <label for=\"lang-en\">English</label>\n            <input type=\"radio\" name=\"language\" value=\"es\" id=\"lang-es\"> <label for=\"lang-es\">Spanish</label>\n            <input type=\"radio\" name=\"language\" value=\"fr\" id=\"lang-fr\"> <label for=\"lang-fr\">French</label>\n        </div>\n\n        <button id=\"clear-preferences\">Clear All Preferences</button>\n    </div>\n\n    <script>\n        const currentThemeSpan = document.getElementById('current-theme');\n        const currentLanguageSpan = document.getElementById('current-language');\n        const themeRadios = document.querySelectorAll('input[name=\"theme\"]');\n        const languageRadios = document.querySelectorAll('input[name=\"language\"]');\n        const clearButton = document.getElementById('clear-preferences');\n\n        // Default values\n        const defaultTheme = 'system';\n        const defaultLanguage = 'en';\n\n        const langMap = { // Mapping for display purposes\n            'en': 'English',\n            'es': 'Spanish',\n            'fr': 'French'\n        };\n\n        function applyTheme(theme) {\n            document.body.className = ''; // Clear existing themes\n            document.body.classList.add(`${theme}-theme`);\n            currentThemeSpan.textContent = theme.charAt(0).toUpperCase() + theme.slice(1); // Capitalize first letter\n            // Set radio button\n            document.getElementById(`theme-${theme}`).checked = true;\n        }\n\n        function applyLanguage(lang) {\n            currentLanguageSpan.textContent = langMap[lang] || 'Unknown';\n            // Set radio button\n            document.getElementById(`lang-${lang}`).checked = true;\n            // In a real app, this would change text content on the page\n        }\n\n        function loadPreferences() {\n            const savedTheme = localStorage.getItem('userTheme');\n            const savedLanguage = localStorage.getItem('userLanguage');\n\n            applyTheme(savedTheme || defaultTheme);\n            applyLanguage(savedLanguage || defaultLanguage);\n        }\n\n        function saveTheme(theme) {\n            localStorage.setItem('userTheme', theme);\n            applyTheme(theme);\n        }\n\n        function saveLanguage(lang) {\n            localStorage.setItem('userLanguage', lang);\n            applyLanguage(lang);\n        }\n\n        function clearPreferences() {\n            localStorage.removeItem('userTheme');\n            localStorage.removeItem('userLanguage');\n            loadPreferences(); // Reset to defaults\n        }\n\n        // Event Listeners\n        themeRadios.forEach(radio => {\n            radio.addEventListener('change', (event) => {\n                saveTheme(event.target.value);\n            });\n        });\n\n        languageRadios.forEach(radio => {\n            radio.addEventListener('change', (event) => {\n                saveLanguage(event.target.value);\n            });\n        });\n\n        clearButton.addEventListener('click', clearPreferences);\n\n        // Initial load\n        document.addEventListener('DOMContentLoaded', loadPreferences);\n    </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>User Preferences</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; transition: background-color 0.3s, color 0.3s; }\n        .container { max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #eee; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        .option-group { margin-bottom: 15px; }\n        label { display: block; margin-bottom: 5px; font-weight: bold; }\n        input[type=\"radio\"] { margin-right: 5px; }\n        button { padding: 10px 15px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; }\n        button:hover { background-color: #0056b3; }\n\n        /* Theme styles */\n        body.light-theme { background-color: #f0f0f0; color: #333; }\n        body.dark-theme { background-color: #333; color: #f0f0f0; }\n        body.system-theme { background-color: white; color: black; } /* Default */\n    </style>\n</head>\n<body class=\"system-theme\">\n    <div class=\"container\">\n        <h1>User Preference Manager</h1>\n        <p>Current Theme: <span id=\"current-theme\">System</span></p>\n        <p>Current Language: <span id=\"current-language\">English</span></p>\n\n        <div class=\"option-group\">\n            <label>Select Theme:</label>\n            <input type=\"radio\" name=\"theme\" value=\"light\" id=\"theme-light\"> <label for=\"theme-light\">Light</label>\n            <input type=\"radio\" name=\"theme\" value=\"dark\" id=\"theme-dark\"> <label for=\"theme-dark\">Dark</label>\n            <input type=\"radio\" name=\"theme\" value=\"system\" id=\"theme-system\"> <label for=\"theme-system\">System Default</label>\n        </div>\n\n        <div class=\"option-group\">\n            <label>Select Language:</label>\n            <input type=\"radio\" name=\"language\" value=\"en\" id=\"lang-en\"> <label for=\"lang-en\">English</label>\n            <input type=\"radio\" name=\"language\" value=\"es\" id=\"lang-es\"> <label for=\"lang-es\">Spanish</label>\n            <input type=\"radio\" name=\"language\" value=\"fr\" id=\"lang-fr\"> <label for=\"lang-fr\">French</label>\n        </div>\n\n        <button id=\"clear-preferences\">Clear All Preferences</button>\n    </div>\n\n    <script>\n        const currentThemeSpan = document.getElementById('current-theme');\n        const currentLanguageSpan = document.getElementById('current-language');\n        const themeRadios = document.querySelectorAll('input[name=\"theme\"]');\n        const languageRadios = document.querySelectorAll('input[name=\"language\"]');\n        const clearButton = document.getElementById('clear-preferences');\n\n        const defaultTheme = 'system';\n        const defaultLanguage = 'en';\n\n        const langMap = {\n            'en': 'English',\n            'es': 'Spanish',\n            'fr': 'French'\n        };\n\n        function applyTheme(theme) {\n            document.body.className = ''; // Remove existing classes\n            document.body.classList.add(`${theme}-theme`);\n            currentThemeSpan.textContent = theme.charAt(0).toUpperCase() + theme.slice(1); // Capitalize for display\n            const themeRadio = document.getElementById(`theme-${theme}`);\n            if (themeRadio) {\n                themeRadio.checked = true;\n            }\n        }\n\n        function applyLanguage(lang) {\n            currentLanguageSpan.textContent = langMap[lang] || 'Unknown';\n            const langRadio = document.getElementById(`lang-${lang}`);\n            if (langRadio) {\n                langRadio.checked = true;\n            }\n        }\n\n        function loadPreferences() {\n            const savedTheme = localStorage.getItem('userTheme');\n            const savedLanguage = localStorage.getItem('userLanguage');\n\n            applyTheme(savedTheme || defaultTheme);\n            applyLanguage(savedLanguage || defaultLanguage);\n        }\n\n        function savePreference(key, value, applyFn) {\n            try {\n                localStorage.setItem(key, value);\n                applyFn(value);\n            } catch (e) {\n                console.error(`Error saving preference '${key}':`, e);\n                alert('Storage limit exceeded or access denied. Cannot save preference.');\n            }\n        }\n\n        function clearPreferences() {\n            try {\n                localStorage.removeItem('userTheme');\n                localStorage.removeItem('userLanguage');\n                loadPreferences(); // Reset to defaults\n                alert('All preferences cleared!');\n            } catch (e) {\n                console.error('Error clearing preferences:', e);\n                alert('Error clearing preferences.');\n            }\n        }\n\n        // Event Listeners\n        themeRadios.forEach(radio => {\n            radio.addEventListener('change', (event) => {\n                savePreference('userTheme', event.target.value, applyTheme);\n            });\n        });\n\n        languageRadios.forEach(radio => {\n            radio.addEventListener('change', (event) => {\n                savePreference('userLanguage', event.target.value, applyLanguage);\n            });\n        });\n\n        clearButton.addEventListener('click', clearPreferences);\n\n        // Initial load when the DOM is fully loaded\n        document.addEventListener('DOMContentLoaded', loadPreferences);\n    </script>\n</body>\n</html>\n",
          "testCases": [
            "Load the page: Should display default theme and language, and corresponding radio buttons checked.",
            "Select 'Dark' theme: Page background/text should change, 'Current Theme' text should update, and 'Dark' radio should be checked.",
            "Select 'Spanish' language: 'Current Language' text should update, and 'Spanish' radio should be checked.",
            "Refresh the page: Previously selected theme and language should persist and be applied.",
            "Close and reopen the browser tab: Previously selected theme and language should still persist.",
            "Click 'Clear All Preferences': Page should revert to default theme/language, and `localStorage` should be empty (verify in Dev Tools Application tab).",
            "Test with invalid localStorage access (e.g., in incognito mode with 'Block third-party cookies' enabled for some browsers): `savePreference` should catch the error."
          ],
          "hints": [
            "Use `localStorage.setItem(key, value)` to save and `localStorage.getItem(key)` to retrieve.",
            "Remember that `localStorage` only stores strings. For more complex data, you might need `JSON.stringify()` and `JSON.parse()`.",
            "Consider using a `DOMContentLoaded` event listener to ensure your JavaScript runs after the HTML is fully parsed.",
            "For styling, you can toggle CSS classes on the `body` element based on the selected theme.",
            "Wrap `localStorage` calls in `try...catch` blocks to handle potential `QuotaExceededError` or `SecurityError` (e.g., if storage is full or disabled)."
          ],
          "tags": [
            "local-storage",
            "frontend-basics",
            "data-persistence",
            "dom-manipulation",
            "user-interface"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_browser_storage",
            "javascript_dom",
            "html_forms"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "session_storage",
            "browser_api_security",
            "web_usability"
          ]
        },
        {
          "id": "task_heavy_computation_offloader",
          "title": "Heavy Computation Offloader with Web Worker",
          "description": "\nCreate a web page that demonstrates how to offload a CPU-intensive task to a Web Worker to keep the main UI thread responsive. The task will be calculating the Nth Fibonacci number, which can be computationally expensive for large N.\n\n**Requirements:**\n1.  **HTML Structure**:\n    *   An input field for the user to enter a number `N`.\n    *   A button to 'Calculate Fibonacci'.\n    *   A `div` to display the result.\n    *   A simple animation (e.g., a spinning loader icon or a changing background color) that continuously runs on the main thread.\n2.  **JavaScript (Main Thread)**:\n    *   When the 'Calculate Fibonacci' button is clicked, disable the button, show the loading animation, and send the input `N` to a Web Worker using `postMessage()`.\n    *   Listen for messages from the Web Worker. When a result is received, display it in the result `div`, hide the loading animation, and re-enable the button.\n    *   Handle potential errors from the worker (e.g., for very large N leading to computation overflow).\n3.  **JavaScript (Worker Thread - `fibonacciWorker.js`)**:\n    *   Define a function to calculate the Nth Fibonacci number (e.g., a recursive or iterative implementation).\n    *   Listen for `message` events from the main thread.\n    *   Upon receiving `N`, calculate the Fibonacci number.\n    *   Send the result back to the main thread using `postMessage()`.\n    *   Implement error handling for cases where N is too large or invalid.\n4.  **Demonstrate Responsiveness**: Ensure that the loading animation continues to run smoothly while the worker is busy calculating, proving that the main thread is not blocked.\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Web Worker Fibonacci</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; }\n        .container { max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #eee; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        input[type=\"number\"] { padding: 8px; margin-right: 10px; border: 1px solid #ccc; border-radius: 4px; }\n        button { padding: 10px 15px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; }\n        button:disabled { background-color: #a0c9ff; cursor: not-allowed; }\n        #result { margin-top: 20px; padding: 10px; border: 1px dashed #ddd; min-height: 30px; }\n        #loading-animation { \n            width: 30px; height: 30px; border: 4px solid #f3f3f3; border-top: 4px solid #3498db; \n            border-radius: 50%; animation: spin 1s linear infinite; display: none; margin: 10px auto;\n        }\n        @keyframes spin {\n            0% { transform: rotate(0deg); }\n            100% { transform: rotate(360deg); }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Fibonacci Calculator (Web Worker)</h1>\n        <p>Enter a number N to calculate the Nth Fibonacci number:</p>\n        <input type=\"number\" id=\"fib-input\" value=\"40\" min=\"0\">\n        <button id=\"calculate-button\">Calculate Fibonacci</button>\n        <div id=\"loading-animation\"></div>\n        <div id=\"result\"></div>\n    </div>\n\n    <script>\n        const fibInput = document.getElementById('fib-input');\n        const calculateButton = document.getElementById('calculate-button');\n        const loadingAnimation = document.getElementById('loading-animation');\n        const resultDiv = document.getElementById('result');\n\n        let fibWorker;\n\n        function initWorker() {\n            if (fibWorker) {\n                fibWorker.terminate(); // Terminate existing worker if any\n            }\n            fibWorker = new Worker('fibonacciWorker.js');\n\n            fibWorker.onmessage = (event) => {\n                const { result, error } = event.data;\n                loadingAnimation.style.display = 'none';\n                calculateButton.disabled = false;\n\n                if (error) {\n                    resultDiv.textContent = `Error: ${error}`;\n                    resultDiv.style.color = 'red';\n                } else {\n                    resultDiv.textContent = `Fibonacci(${fibInput.value}) = ${result}`;\n                    resultDiv.style.color = 'green';\n                }\n            };\n\n            fibWorker.onerror = (error) => {\n                loadingAnimation.style.display = 'none';\n                calculateButton.disabled = false;\n                resultDiv.textContent = `Worker Error: ${error.message}`;\n                resultDiv.style.color = 'red';\n                console.error('Worker error:', error);\n            };\n        }\n\n        calculateButton.addEventListener('click', () => {\n            const n = parseInt(fibInput.value);\n            if (isNaN(n) || n < 0) {\n                resultDiv.textContent = 'Please enter a valid non-negative number.';\n                resultDiv.style.color = 'orange';\n                return;\n            }\n\n            calculateButton.disabled = true;\n            loadingAnimation.style.display = 'block';\n            resultDiv.textContent = '';\n            resultDiv.style.color = 'black';\n\n            if (!fibWorker) {\n                initWorker();\n            }\n            fibWorker.postMessage(n);\n        });\n\n        // Initialize worker on page load\n        document.addEventListener('DOMContentLoaded', initWorker);\n\n        // Visual responsiveness check: main thread 'animation'\n        // This function will continuously update the body background color\n        // If the UI freezes during calculation, this animation will stop.\n        let hue = 0;\n        function animateBackground() {\n            document.body.style.backgroundColor = `hsl(${hue}, 70%, 90%)`;\n            hue = (hue + 1) % 360;\n            requestAnimationFrame(animateBackground);\n        }\n        requestAnimationFrame(animateBackground);\n    </script>\n</body>\n</html>\n\n<!-- fibonacciWorker.js -->\n// This file will be created by the solution\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Web Worker Fibonacci</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; transition: background-color 0.1s; }\n        .container { max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #eee; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        input[type=\"number\"] { padding: 8px; margin-right: 10px; border: 1px solid #ccc; border-radius: 4px; }\n        button { padding: 10px 15px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; }\n        button:disabled { background-color: #a0c9ff; cursor: not-allowed; }\n        #result { margin-top: 20px; padding: 10px; border: 1px dashed #ddd; min-height: 30px; }\n        #loading-animation { \n            width: 30px; height: 30px; border: 4px solid #f3f3f3; border-top: 4px solid #3498db; \n            border-radius: 50%; animation: spin 1s linear infinite; display: none; margin: 10px auto;\n        }\n        @keyframes spin {\n            0% { transform: rotate(0deg); }\n            100% { transform: rotate(360deg); }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Fibonacci Calculator (Web Worker)</h1>\n        <p>Enter a number N to calculate the Nth Fibonacci number:</p>\n        <input type=\"number\" id=\"fib-input\" value=\"40\" min=\"0\">\n        <button id=\"calculate-button\">Calculate Fibonacci</button>\n        <div id=\"loading-animation\"></div>\n        <div id=\"result\"></div>\n    </div>\n\n    <script>\n        const fibInput = document.getElementById('fib-input');\n        const calculateButton = document.getElementById('calculate-button');\n        const loadingAnimation = document.getElementById('loading-animation');\n        const resultDiv = document.getElementById('result');\n\n        let fibWorkerInstance;\n\n        // Function to create/re-initialize the worker\n        function getFibWorker() {\n            if (fibWorkerInstance) {\n                fibWorkerInstance.terminate(); // Ensure previous worker is terminated\n            }\n            fibWorkerInstance = new Worker('fibonacciWorker.js');\n\n            fibWorkerInstance.onmessage = (event) => {\n                const { result, error } = event.data;\n                loadingAnimation.style.display = 'none';\n                calculateButton.disabled = false;\n\n                if (error) {\n                    resultDiv.textContent = `Error: ${error}`;\n                    resultDiv.style.color = 'red';\n                } else {\n                    // Use BigInt for potentially very large Fibonacci numbers\n                    resultDiv.textContent = `Fibonacci(${fibInput.value}) = ${result.toString()}`;\n                    resultDiv.style.color = 'green';\n                }\n            };\n\n            fibWorkerInstance.onerror = (error) => {\n                loadingAnimation.style.display = 'none';\n                calculateButton.disabled = false;\n                resultDiv.textContent = `Worker Error: ${error.message || 'An unknown worker error occurred.'}`;\n                resultDiv.style.color = 'red';\n                console.error('Worker error:', error);\n            };\n            return fibWorkerInstance;\n        }\n\n        calculateButton.addEventListener('click', () => {\n            const n = parseInt(fibInput.value);\n            if (isNaN(n) || n < 0) {\n                resultDiv.textContent = 'Please enter a valid non-negative number.';\n                resultDiv.style.color = 'orange';\n                return;\n            }\n            if (n > 100) { // Practical limit for BigInt Fibonacci without excessive wait\n                resultDiv.textContent = 'Input number is too large for practical calculation. Try <= 100.';\n                resultDiv.style.color = 'orange';\n                return;\n            }\n\n            calculateButton.disabled = true;\n            loadingAnimation.style.display = 'block';\n            resultDiv.textContent = 'Calculating...';\n            resultDiv.style.color = 'black';\n\n            const worker = getFibWorker();\n            worker.postMessage(n);\n        });\n\n        // --- Main thread animation to prove responsiveness ---\n        let hue = 0;\n        function animateBackground() {\n            document.body.style.backgroundColor = `hsl(${hue}, 70%, 90%)`;\n            hue = (hue + 2) % 360;\n            requestAnimationFrame(animateBackground);\n        }\n        \n        // Start the background animation on page load\n        requestAnimationFrame(animateBackground);\n    </script>\n</body>\n</html>\n\n<!-- fibonacciWorker.js -->\nself.onmessage = (event) => {\n    const n = event.data;\n\n    function fibonacci(num) {\n        // Handle edge cases for negative or non-integer input in worker as well\n        if (num < 0 || !Number.isInteger(num)) {\n            return 'Invalid input: Please provide a non-negative integer.';\n        }\n        if (num === 0) return 0n; // Use BigInt for potentially large numbers\n        if (num === 1) return 1n;\n\n        let a = 0n, b = 1n;\n        for (let i = 2; i <= num; i++) {\n            let temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n\n    try {\n        const result = fibonacci(n);\n        self.postMessage({ result: result.toString() }); // Send BigInt as string\n    } catch (e) {\n        self.postMessage({ error: e.message || 'An error occurred during calculation.' });\n    }\n};\n",
          "testCases": [
            "Enter `N=10` and click Calculate: Should quickly show result. Animation should run smoothly.",
            "Enter `N=40` and click Calculate: Calculation will take a noticeable time, but the background animation (or other UI elements) should continue to run smoothly, demonstrating no UI freeze.",
            "Enter `N=0` or `N=1`: Should return correct base cases (0 and 1).",
            "Enter `N=-5` or a non-integer like `3.5`: Should display an error message for invalid input.",
            "Enter `N=90` (or higher if your machine is fast): Should take significant time but UI remains responsive. The result will be a very large number, handled by BigInt.",
            "After calculation, change `N` and click again: Should perform new calculation, demonstrating worker reusability or termination/re-initialization."
          ],
          "hints": [
            "The Fibonacci sequence calculation (especially naive recursive ones) is a good candidate for demonstrating CPU-bound tasks.",
            "Remember to use `new Worker('path/to/worker.js')` in the main thread and `self.onmessage` / `self.postMessage` in the worker.",
            "For very large Fibonacci numbers, regular JavaScript numbers (doubles) lose precision. Consider using `BigInt` for accurate results for N > ~78.",
            "Ensure your loading animation runs on the main thread (e.g., using `requestAnimationFrame`) to visually prove responsiveness."
          ],
          "tags": [
            "web-workers",
            "performance",
            "asynchronous-javascript",
            "concurrency",
            "algorithms"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_web_workers",
            "javascript_async",
            "dom_manipulation"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "event_loop",
            "main_thread_blocking",
            "bigint"
          ]
        },
        {
          "id": "task_large_array_processing_transferable",
          "title": "Large Array Processing with Transferable Objects",
          "description": "\nDemonstrate the performance benefit of `Transferable Objects` (specifically `ArrayBuffer`) when processing a large dataset in a Web Worker compared to standard data copying. You will implement two modes of operation: one using structured cloning (implicit copying) and one using explicit transfer of an `ArrayBuffer`.\n\n**Requirements:**\n1.  **HTML Structure**:\n    *   An input field to specify the size of the array (e.g., `10,000,000`).\n    *   Two buttons: 'Process (Copy)' and 'Process (Transfer)'.\n    *   A `div` to display processing time and results.\n    *   A simple animation (e.g., a pulsing square) to show main thread responsiveness.\n2.  **JavaScript (Main Thread)**:\n    *   Create a `Web Worker` (`dataProcessor.js`).\n    *   **'Process (Copy)' Mode**: Generate a large `Array` of numbers. Send it to the worker using `worker.postMessage(dataArray)`. Measure and display the round-trip time.\n    *   **'Process (Transfer)' Mode**: Generate a large `ArrayBuffer` (e.g., using `Uint32Array`). Send its underlying buffer to the worker using `worker.postMessage({ buffer: myBuffer }, [myBuffer])`. Measure and display the round-trip time. Observe that the original `myBuffer` becomes neutered.\n    *   Display a visual indicator (e.g., a loading spinner/animation) that continues running during worker processing to confirm main thread responsiveness.\n3.  **JavaScript (Worker Thread - `dataProcessor.js`)**:\n    *   Listen for messages from the main thread.\n    *   Upon receiving data, perform a simple operation on it (e.g., double each number, sum all numbers) to simulate processing.\n    *   Send the processed data (or result) back to the main thread.\n    *   Ensure the worker can correctly handle both a copied array and a transferred `ArrayBuffer`.\n4.  **Comparison**: The goal is to visually demonstrate (and measure) that 'Process (Transfer)' is significantly faster for large datasets than 'Process (Copy)'.\n",
          "difficulty": "hard",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Transferable Objects Demo</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; }\n        .container { max-width: 800px; margin: 0 auto; padding: 20px; border: 1px solid #eee; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        input[type=\"number\"] { padding: 8px; margin-right: 10px; border: 1px solid #ccc; border-radius: 4px; }\n        button { padding: 10px 15px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px; }\n        button:disabled { background-color: #a0c9ff; cursor: not-allowed; }\n        #results { margin-top: 20px; padding: 10px; border: 1px dashed #ddd; min-height: 80px; }\n        #animation-box { width: 50px; height: 50px; background-color: #f00; margin: 20px auto; animation: pulse 1s infinite alternate; }\n        @keyframes pulse {\n            from { transform: scale(0.8); opacity: 0.5; }\n            to { transform: scale(1.2); opacity: 1; }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Large Array Processing: Copy vs. Transfer</h1>\n        <p>Enter array size: <input type=\"number\" id=\"array-size\" value=\"5000000\" min=\"1000\"></p>\n        <button id=\"process-copy\">Process (Copy)</button>\n        <button id=\"process-transfer\">Process (Transfer)</button>\n        <div id=\"results\"></div>\n        <div id=\"animation-box\"></div>\n    </div>\n\n    <script>\n        const arraySizeInput = document.getElementById('array-size');\n        const processCopyBtn = document.getElementById('process-copy');\n        const processTransferBtn = document.getElementById('process-transfer');\n        const resultsDiv = document.getElementById('results');\n        const animationBox = document.getElementById('animation-box');\n\n        let dataWorker = new Worker('dataProcessor.js');\n        let startTime;\n\n        dataWorker.onmessage = (event) => {\n            const { processedData, type } = event.data;\n            const endTime = performance.now();\n            const duration = (endTime - startTime).toFixed(2);\n\n            let originalBufferState = '';\n            if (type === 'transfer') {\n                // This part is challenging to demonstrate neutering directly here\n                // as the original reference `myBuffer` is not easily captured\n                // in a simple variable outside the function scope after transfer.\n                // We rely on the concept that it *is* neutered.\n            }\n            resultsDiv.innerHTML = `\n                <h3>${type.toUpperCase()} Mode</h3>\n                <p>Processed ${processedData.length || 'array'} items in: <strong>${duration} ms</strong></p>\n                <p>First item (after processing): ${processedData[0] || 'N/A'}</p>\n                <p>Original buffer state: ${originalBufferState}</p>\n            `;\n            enableButtons();\n        };\n\n        dataWorker.onerror = (error) => {\n            console.error('Worker error:', error);\n            resultsDiv.textContent = `Error: ${error.message}`; \n            enableButtons();\n        };\n\n        function disableButtons() {\n            processCopyBtn.disabled = true;\n            processTransferBtn.disabled = true;\n        }\n\n        function enableButtons() {\n            processCopyBtn.disabled = false;\n            processTransferBtn.disabled = false;\n        }\n\n        processCopyBtn.addEventListener('click', () => {\n            const size = parseInt(arraySizeInput.value);\n            if (isNaN(size) || size <= 0) { alert('Please enter a valid array size.'); return; }\n            \n            disableButtons();\n            resultsDiv.textContent = 'Processing (Copy)...';\n            \n            // Create a regular JavaScript array\n            const data = Array.from({ length: size }, (_, i) => i);\n            \n            startTime = performance.now();\n            dataWorker.postMessage({ type: 'copy', data: data });\n        });\n\n        processTransferBtn.addEventListener('click', () => {\n            const size = parseInt(arraySizeInput.value);\n            if (isNaN(size) || size <= 0) { alert('Please enter a valid array size.'); return; }\n\n            disableButtons();\n            resultsDiv.textContent = 'Processing (Transfer)...';\n\n            // Create a TypedArray and get its underlying ArrayBuffer\n            const typedArray = new Uint32Array(size);\n            for (let i = 0; i < size; i++) {\n                typedArray[i] = i;\n            }\n            const bufferToTransfer = typedArray.buffer;\n            \n            startTime = performance.now();\n            // Send the ArrayBuffer and mark it for transfer\n            dataWorker.postMessage({ type: 'transfer', data: bufferToTransfer }, [bufferToTransfer]);\n\n            // IMPORTANT: After transfer, bufferToTransfer is neutered in main thread.\n            // Attempting to access typedArray will cause an error.\n            try {\n                console.log('Original typedArray[0] after transfer:', typedArray[0]);\n            } catch (e) {\n                console.error('Expected error accessing neutered ArrayBuffer:', e.message);\n                // You might update resultsDiv with this message if desired\n            }\n        });\n\n        // Main thread animation to demonstrate responsiveness\n        function animatePulse() {\n            // The CSS animation will handle this directly, no JS needed here\n            requestAnimationFrame(animatePulse); // Keep the loop running for other potential updates\n        }\n        requestAnimationFrame(animatePulse);\n\n    </script>\n</body>\n</html>\n\n<!-- dataProcessor.js -->\n// This file will be created by the solution\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Transferable Objects Demo</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; }\n        .container { max-width: 800px; margin: 0 auto; padding: 20px; border: 1px solid #eee; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        input[type=\"number\"] { padding: 8px; margin-right: 10px; border: 1px solid #ccc; border-radius: 4px; }\n        button { padding: 10px 15px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px; }\n        button:disabled { background-color: #a0c9ff; cursor: not-allowed; }\n        #results { margin-top: 20px; padding: 10px; border: 1px dashed #ddd; min-height: 80px; }\n        #animation-box { width: 50px; height: 50px; background-color: #f00; margin: 20px auto; animation: pulse 1s infinite alternate; }\n        @keyframes pulse {\n            from { transform: scale(0.8); opacity: 0.5; }\n            to { transform: scale(1.2); opacity: 1; }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Large Array Processing: Copy vs. Transfer</h1>\n        <p>Enter array size (e.g., 5,000,000 for noticeable difference): <input type=\"number\" id=\"array-size\" value=\"5000000\" min=\"1000\"></p>\n        <button id=\"process-copy\">Process (Copy)</button>\n        <button id=\"process-transfer\">Process (Transfer)</button>\n        <div id=\"results\"></div>\n        <div id=\"animation-box\"></div>\n    </div>\n\n    <script>\n        const arraySizeInput = document.getElementById('array-size');\n        const processCopyBtn = document.getElementById('process-copy');\n        const processTransferBtn = document.getElementById('process-transfer');\n        const resultsDiv = document.getElementById('results');\n        const animationBox = document.getElementById('animation-box');\n\n        let dataWorker;\n        let startTime;\n        let originalTypedArrayRef; // To check neutered state after transfer\n\n        function initializeWorker() {\n            if (dataWorker) {\n                dataWorker.terminate();\n            }\n            dataWorker = new Worker('dataProcessor.js');\n\n            dataWorker.onmessage = (event) => {\n                const { processedData, type } = event.data;\n                const endTime = performance.now();\n                const duration = (endTime - startTime).toFixed(2);\n\n                let originalBufferState = '';\n                if (type === 'transfer' && originalTypedArrayRef) {\n                    // Check if the original ArrayBuffer is neutered (byteLength will be 0)\n                    originalBufferState = `Original ArrayBuffer.byteLength after transfer: ${originalTypedArrayRef.buffer.byteLength}`;\n                }\n                \n                resultsDiv.innerHTML = `\n                    <h3>${type.toUpperCase()} Mode</h3>\n                    <p>Processed ${processedData ? processedData.length : 'N/A'} items in: <strong>${duration} ms</strong></p>\n                    <p>First item (after processing): ${processedData ? processedData[0] : 'N/A'}</p>\n                    <p>${originalBufferState}</p>\n                `;\n                enableButtons();\n            };\n\n            dataWorker.onerror = (error) => {\n                console.error('Worker error:', error);\n                resultsDiv.textContent = `Error: ${error.message}`; \n                enableButtons();\n            };\n        }\n\n        function disableButtons() {\n            processCopyBtn.disabled = true;\n            processTransferBtn.disabled = true;\n        }\n\n        function enableButtons() {\n            processCopyBtn.disabled = false;\n            processTransferBtn.disabled = false;\n        }\n\n        // Initialize worker on page load\n        document.addEventListener('DOMContentLoaded', initializeWorker);\n\n        processCopyBtn.addEventListener('click', () => {\n            const size = parseInt(arraySizeInput.value);\n            if (isNaN(size) || size <= 0) { alert('Please enter a valid array size.'); return; }\n            \n            disableButtons();\n            resultsDiv.textContent = 'Processing (Copying data)...';\n            \n            // Create a regular JavaScript array for copying\n            const data = Array.from({ length: size }, (_, i) => i);\n            \n            startTime = performance.now();\n            dataWorker.postMessage({ type: 'copy', data: data });\n        });\n\n        processTransferBtn.addEventListener('click', () => {\n            const size = parseInt(arraySizeInput.value);\n            if (isNaN(size) || size <= 0) { alert('Please enter a valid array size.'); return; }\n\n            disableButtons();\n            resultsDiv.textContent = 'Processing (Transferring data)...';\n\n            // Create a TypedArray and get its underlying ArrayBuffer\n            const typedArray = new Uint32Array(size);\n            for (let i = 0; i < size; i++) {\n                typedArray[i] = i;\n            }\n            const bufferToTransfer = typedArray.buffer;\n            originalTypedArrayRef = typedArray; // Keep reference to check neutered state\n            \n            startTime = performance.now();\n            // Send the ArrayBuffer and mark it for transfer\n            dataWorker.postMessage({ type: 'transfer', data: bufferToTransfer }, [bufferToTransfer]);\n\n            // IMPORTANT: After transfer, bufferToTransfer is neutered in main thread.\n            // Attempting to access typedArray will cause an error or yield 0s.\n            // This console.error will confirm the neutering.\n            setTimeout(() => {\n                try {\n                    console.log('Original typedArray[0] after transfer:', typedArray[0]);\n                } catch (e) {\n                    console.error('Expected error accessing neutered ArrayBuffer:', e.message);\n                }\n                 console.log('Original ArrayBuffer.byteLength after transfer:', typedArray.buffer.byteLength);\n            }, 0);\n           \n        });\n\n        // Main thread animation to demonstrate responsiveness\n        function animatePulse() {\n            // The CSS animation ensures this is running independently\n            requestAnimationFrame(animatePulse);\n        }\n        requestAnimationFrame(animatePulse);\n    </script>\n</body>\n</html>\n\n<!-- dataProcessor.js -->\nself.onmessage = (event) => {\n    const { type, data } = event.data;\n\n    let processedData;\n\n    if (type === 'copy') {\n        // Received a copied array\n        processedData = data.map(item => item * 2); // Example processing\n    } else if (type === 'transfer') {\n        // Received an ArrayBuffer. Create a TypedArray view to work with it.\n        const typedArray = new Uint32Array(data);\n        processedData = typedArray.map(item => item * 2); // Example processing\n\n        // If you wanted to transfer it back, you'd do:\n        // self.postMessage({ processedData: processedData.buffer, type: 'transfer' }, [processedData.buffer]);\n    }\n    \n    self.postMessage({ processedData, type });\n};\n",
          "testCases": [
            "Enter `100000` (smaller size) for array: 'Process (Copy)' and 'Process (Transfer)' should both be relatively fast. Animation should run smoothly.",
            "Enter `5000000` (medium size): 'Process (Copy)' should be noticeably slower than 'Process (Transfer)'. Observe the animation during both. The `byteLength` of the original `ArrayBuffer` in the console after transfer should be 0.",
            "Enter `20000000` (large size): The difference between 'Copy' and 'Transfer' should become very significant, with 'Copy' potentially causing brief UI jank and taking much longer. The animation should remain smooth for 'Transfer'.",
            "Test with invalid array size (e.g., 0, negative, non-number): Should show an alert message and not proceed.",
            "Ensure `original ArrayBuffer.byteLength after transfer: 0` is logged in the console after the 'Process (Transfer)' button is clicked."
          ],
          "hints": [
            "For the 'Copy' mode, a regular `Array` (or even a `TypedArray` without specifying a transfer list) will be copied via structured cloning.",
            "For the 'Transfer' mode, you need to explicitly create an `ArrayBuffer` (e.g., using `new Uint32Array(size).buffer`) and pass it as the second argument to `postMessage`.",
            "To measure time, use `performance.now()` before sending the message and after receiving the result.",
            "Remember that `ArrayBuffer` itself is just raw binary data; you need `TypedArray` views (like `Uint32Array`) to easily manipulate the numbers within it.",
            "Confirm the neutering effect by trying to access the `TypedArray` after `postMessage` in the main thread (it should become detached or its `byteLength` should be 0)."
          ],
          "tags": [
            "web-workers",
            "transferable-objects",
            "performance",
            "memory-management",
            "javascript-optimization",
            "typed-arrays"
          ],
          "timeEstimate": 120,
          "prerequisites": [
            "theory_transferable_objects",
            "theory_web_workers",
            "javascript_typed_arrays"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "relatedConcepts": [
            "structured_cloning",
            "main_thread_blocking",
            "event_loop"
          ]
        },
        {
          "id": "task_optimized_search_input",
          "title": "Optimized Search Input with Debouncing",
          "description": "\nImplement a search input field that simulates making an API call for suggestions as the user types. To optimize performance and reduce unnecessary network requests, you must implement debouncing on the input event.\n\n**Requirements:**\n1.  **HTML Structure**:\n    *   An `input` field (`type=\"text\"`) for search queries.\n    *   A `div` or `ul` to display search results/suggestions.\n    *   A small indicator (e.g., text like 'Typing...' or 'Searching...') to show when the debounced function is active/waiting.\n2.  **JavaScript (Main Thread)**:\n    *   Implement a `debounce` utility function that takes a function and a delay as arguments and returns a debounced version of the function.\n    *   Create a `simulateApiCall(query)` function. This function should: `console.log` the query and a timestamp, and return a Promise that resolves after a short delay (e.g., 300ms) to mimic network latency. For this task, it doesn't need to return actual data, just confirm the call happened.\n    *   Attach an `input` event listener to the search field.\n    *   Inside the event listener, call the `debouncedSimulateApiCall` function with the current input value.\n    *   Manage the 'Typing...'/'Searching...' indicator: show it when typing starts, hide it when the debounced function actually executes.\n3.  **Behavior**:\n    *   Rapid typing should trigger the debounced function only once, after the user pauses.\n    *   If the user types, pauses, and then types again quickly, the timer should reset, and the function should execute only after the *last* pause.\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Debounced Search</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; }\n        .container { max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #eee; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        input[type=\"text\"] { width: calc(100% - 20px); padding: 10px; margin-bottom: 15px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px; }\n        #status-indicator { font-style: italic; color: #666; margin-bottom: 10px; }\n        #results-display { border: 1px dashed #ddd; padding: 10px; min-height: 50px; background-color: #f9f9f9; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Debounced Search Input</h1>\n        <p>Type into the search box to see debouncing in action. The \"API call\" will only trigger after a short pause.</p>\n        <input type=\"text\" id=\"search-input\" placeholder=\"Start typing...\">\n        <div id=\"status-indicator\"></div>\n        <div id=\"results-display\"></div>\n    </div>\n\n    <script>\n        const searchInput = document.getElementById('search-input');\n        const statusIndicator = document.getElementById('status-indicator');\n        const resultsDisplay = document.getElementById('results-display');\n\n        // Your debounce utility function here\n        function debounce(func, delay) {\n            let timeoutId;\n            return function(...args) {\n                clearTimeout(timeoutId);\n                statusIndicator.textContent = 'Typing...';\n                timeoutId = setTimeout(() => {\n                    statusIndicator.textContent = 'Searching...';\n                    func.apply(this, args);\n                }, delay);\n            };\n        }\n\n        // Simulate an API call\n        function simulateApiCall(query) {\n            return new Promise(resolve => {\n                setTimeout(() => {\n                    console.log(`API call for: \"${query}\" at ${new Date().toLocaleTimeString()}`);\n                    resultsDisplay.textContent = `Results for: \"${query}\" (simulated API call)`;\n                    statusIndicator.textContent = ''; // Clear indicator after call\n                    resolve();\n                }, 300); // Simulate network latency\n            });\n        }\n\n        // Debounced version of the API call\n        const debouncedSearch = debounce(simulateApiCall, 500); // 500ms debounce delay\n\n        searchInput.addEventListener('input', (event) => {\n            debouncedSearch(event.target.value);\n        });\n    </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Debounced Search</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; }\n        .container { max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #eee; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        input[type=\"text\"] { width: calc(100% - 20px); padding: 10px; margin-bottom: 15px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px; }\n        #status-indicator { font-style: italic; color: #666; margin-bottom: 10px; }\n        #results-display { border: 1px dashed #ddd; padding: 10px; min-height: 50px; background-color: #f9f9f9; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Debounced Search Input</h1>\n        <p>Type into the search box to see debouncing in action. The \"API call\" will only trigger after a short pause.</p>\n        <input type=\"text\" id=\"search-input\" placeholder=\"Start typing...\">\n        <div id=\"status-indicator\"></div>\n        <div id=\"results-display\"></div>\n    </div>\n\n    <script>\n        const searchInput = document.getElementById('search-input');\n        const statusIndicator = document.getElementById('status-indicator');\n        const resultsDisplay = document.getElementById('results-display');\n\n        /**\n         * Debounce utility function\n         * @param {function} func The function to debounce.\n         * @param {number} delay The delay in milliseconds before the function is invoked.\n         * @returns {function} A debounced version of the function.\n         */\n        function debounce(func, delay) {\n            let timeoutId; // Stores the timer ID\n            let isWaiting = false; // Flag to track if we're in a waiting state\n\n            return function(...args) {\n                // Clear any existing timer to reset the debounce countdown\n                clearTimeout(timeoutId);\n                \n                // Show typing indicator immediately if not already showing\n                if (!isWaiting) {\n                    statusIndicator.textContent = 'Typing...';\n                    isWaiting = true;\n                }\n\n                timeoutId = setTimeout(() => {\n                    // When the delay passes, execute the original function\n                    func.apply(this, args);\n                    isWaiting = false;\n                    statusIndicator.textContent = ''; // Clear indicator after execution\n                }, delay);\n            };\n        }\n\n        /**\n         * Simulates an API call to fetch search suggestions.\n         * @param {string} query The search query.\n         * @returns {Promise<void>}\n         */\n        function simulateApiCall(query) {\n            statusIndicator.textContent = 'Searching...'; // Change status when actual call is made\n            return new Promise(resolve => {\n                setTimeout(() => {\n                    console.log(`API call for: \"${query}\" at ${new Date().toLocaleTimeString()}`);\n                    resultsDisplay.textContent = `Results for: \"${query}\" (simulated API call)`;\n                    resolve();\n                }, 300); // Simulate network latency\n            });\n        }\n\n        // Create a debounced version of the API call function with a 500ms delay\n        const debouncedSearch = debounce(simulateApiCall, 500); \n\n        // Attach the debounced function to the input event\n        searchInput.addEventListener('input', (event) => {\n            debouncedSearch(event.target.value);\n        });\n    </script>\n</body>\n</html>\n",
          "testCases": [
            "Type 'hello' slowly (pause between letters): Each letter should update 'Typing...' then eventually trigger 'Searching...' and the result.",
            "Type 'world' very quickly without pausing: 'Typing...' should appear, but 'Searching...' and the result should only appear once after you stop typing, demonstrating the debounce effect.",
            "Type 'apple', pause, then type 'banana' quickly: The first 'apple' search should trigger, and then the 'banana' search should trigger after its own pause, resetting the timer correctly.",
            "Clear the input field: The indicator should clear or return to default state after the debounce delay.",
            "Ensure the console logs match the debounced behavior (fewer API calls than key presses)."
          ],
          "hints": [
            "The `debounce` function needs to maintain a `timeoutId` using a closure.",
            "Each time the debounced function is called, `clearTimeout` should be used to cancel any pending executions.",
            "The actual function call should only occur inside the `setTimeout` callback.",
            "The `statusIndicator` should change between 'Typing...' (immediately on input) and 'Searching...' (when the debounced function actually fires)."
          ],
          "tags": [
            "debouncing",
            "performance-optimization",
            "event-handling",
            "javascript",
            "user-experience"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_js_performance_optimization",
            "javascript_closures",
            "javascript_timers"
          ],
          "complexity": 7,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "throttling",
            "event_listeners",
            "api_calls"
          ]
        },
        {
          "id": "task_responsive_card_component",
          "title": "Responsive Card Component with ResizeObserver",
          "description": "\nCreate a responsive card component that dynamically adjusts its internal layout and font sizes based on its own width, using the `ResizeObserver` API. This demonstrates how elements can self-adapt without relying on global window resize events.\n\n**Requirements:**\n1.  **HTML Structure**:\n    *   A main `div` with the ID `resizable-card`. This card should have a fluid width (e.g., `width: 80%; max-width: 600px; min-width: 250px; margin: 20px auto;`) so its size changes when the browser window is resized.\n    *   Inside the card, include a `h2` for the title and a `p` for the content.\n    *   (Optional but recommended) Add a `div` that visually shows the card's current `contentRect` dimensions.\n2.  **CSS**: Provide basic styling for the card and its internal elements. Define different font sizes or flex directions that will be applied by JavaScript based on width.\n3.  **JavaScript**:\n    *   Create a `ResizeObserver` instance.\n    *   Observe the `resizable-card` element.\n    *   In the `ResizeObserver` callback:\n        *   Read the `contentRect.width` of the observed entry.\n        *   Implement logic to change the `font-size` of the `h2` and `p` elements based on the card's width (e.g., smaller font for `width < 350px`, larger for `width >= 350px`).\n        *   (Optional) Implement logic to change the `flex-direction` of an internal container from `column` to `row` or vice-versa based on width.\n        *   Update the `div` displaying current dimensions.\n4.  **Demonstration**: Resize the browser window to observe the card's width changing and its internal content dynamically adapting without a page refresh.\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Responsive Card with ResizeObserver</title>\n    <style>\n        body { font-family: sans-serif; margin: 0; background-color: #f4f4f4; }\n        .resizable-card {\n            width: 80%;\n            max-width: 600px;\n            min-width: 250px;\n            margin: 20px auto;\n            padding: 20px;\n            border: 1px solid #ccc;\n            border-radius: 8px;\n            box-shadow: 0 4px 8px rgba(0,0,0,0.1);\n            background-color: white;\n            display: flex; /* For optional flex-direction change */\n            flex-direction: column; /* Default flex direction */\n            transition: font-size 0.2s, flex-direction 0.2s; /* Smooth transitions */\n        }\n        .card-content {\n            flex-grow: 1;\n        }\n        h2 { margin-top: 0; font-size: 24px; }\n        p { font-size: 16px; line-height: 1.5; }\n        .dimensions-display { margin-top: 15px; padding-top: 10px; border-top: 1px dashed #eee; font-size: 14px; color: #555; }\n    </style>\n</head>\n<body>\n    <div id=\"resizable-card\" class=\"resizable-card\">\n        <div class=\"card-content\">\n            <h2 id=\"card-title\">Dynamic Card Title</h2>\n            <p id=\"card-text\">This content will adjust its font size and potentially layout based on the card's width. Resize your browser window to see the effect.</p>\n        </div>\n        <div class=\"dimensions-display\">\n            Current Width: <span id=\"current-width\"></span>px<br>\n            Current Height: <span id=\"current-height\"></span>px\n        </div>\n    </div>\n\n    <script>\n        const card = document.getElementById('resizable-card');\n        const cardTitle = document.getElementById('card-title');\n        const cardText = document.getElementById('card-text');\n        const currentWidthSpan = document.getElementById('current-width');\n        const currentHeightSpan = document.getElementById('current-height');\n\n        const resizeObserver = new ResizeObserver(entries => {\n            for (let entry of entries) {\n                if (entry.target === card) {\n                    const { width, height } = entry.contentRect;\n\n                    currentWidthSpan.textContent = Math.round(width);\n                    currentHeightSpan.textContent = Math.round(height);\n\n                    // Adjust font sizes based on width\n                    if (width < 350) {\n                        cardTitle.style.fontSize = '18px';\n                        cardText.style.fontSize = '13px';\n                        card.style.flexDirection = 'column'; // Example: stack content\n                    } else if (width >= 350 && width < 500) {\n                        cardTitle.style.fontSize = '22px';\n                        cardText.style.fontSize = '15px';\n                        card.style.flexDirection = 'column';\n                    } else {\n                        cardTitle.style.fontSize = '26px';\n                        cardText.style.fontSize = '17px';\n                        card.style.flexDirection = 'row'; // Example: side-by-side content\n                    }\n                }\n            }\n        });\n\n        // Start observing the card element\n        resizeObserver.observe(card);\n\n        // Optional: Trigger initial observation manually if needed for immediate display\n        // const initialEntry = [{ target: card, contentRect: card.getBoundingClientRect() }];\n        // resizeObserver.callback(initialEntry, resizeObserver); // This is not how you call it directly.\n        // It is called automatically on first observe, and then when resize occurs.\n\n    </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Responsive Card with ResizeObserver</title>\n    <style>\n        body { font-family: sans-serif; margin: 0; background-color: #f4f4f4; }\n        .resizable-card {\n            width: 80%;\n            max-width: 600px;\n            min-width: 250px;\n            margin: 20px auto;\n            padding: 20px;\n            border: 1px solid #ccc;\n            border-radius: 8px;\n            box-shadow: 0 4px 8px rgba(0,0,0,0.1);\n            background-color: white;\n            display: flex; \n            flex-direction: column; /* Default flex direction */\n            transition: font-size 0.2s, flex-direction 0.2s; /* Smooth transitions */\n        }\n        .card-content {\n            flex-grow: 1;\n        }\n        h2 { margin-top: 0; font-size: 24px; transition: font-size 0.2s; }\n        p { font-size: 16px; line-height: 1.5; transition: font-size 0.2s; }\n        .dimensions-display { margin-top: 15px; padding-top: 10px; border-top: 1px dashed #eee; font-size: 14px; color: #555; }\n        \n        /* Additional class for row layout for demonstration */\n        .resizable-card.row-layout {\n            flex-direction: row;\n            align-items: center;\n        }\n        .resizable-card.row-layout .card-content {\n            margin-right: 15px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"resizable-card\" class=\"resizable-card\">\n        <div class=\"card-content\">\n            <h2 id=\"card-title\">Dynamic Card Title</h2>\n            <p id=\"card-text\">This content will adjust its font size and potentially layout based on the card's width. Resize your browser window to see the effect.</p>\n        </div>\n        <div class=\"dimensions-display\">\n            Current Width: <span id=\"current-width\"></span>px<br>\n            Current Height: <span id=\"current-height\"></span>px\n        </div>\n    </div>\n\n    <script>\n        const card = document.getElementById('resizable-card');\n        const cardTitle = document.getElementById('card-title');\n        const cardText = document.getElementById('card-text');\n        const currentWidthSpan = document.getElementById('current-width');\n        const currentHeightSpan = document.getElementById('current-height');\n\n        const resizeObserver = new ResizeObserver(entries => {\n            for (let entry of entries) {\n                if (entry.target === card) {\n                    // contentRect provides the size of the element's content box\n                    const { width, height } = entry.contentRect;\n\n                    currentWidthSpan.textContent = Math.round(width);\n                    currentHeightSpan.textContent = Math.round(height);\n\n                    // Adjust font sizes based on width\n                    if (width < 350) {\n                        cardTitle.style.fontSize = '18px';\n                        cardText.style.fontSize = '13px';\n                        card.classList.remove('row-layout');\n                    } else if (width >= 350 && width < 500) {\n                        cardTitle.style.fontSize = '22px';\n                        cardText.style.fontSize = '15px';\n                        card.classList.remove('row-layout');\n                    } else { // width >= 500\n                        cardTitle.style.fontSize = '26px';\n                        cardText.style.fontSize = '17px';\n                        card.classList.add('row-layout'); // Apply row layout for larger width\n                    }\n                }\n            }\n        });\n\n        // Start observing the card element\n        resizeObserver.observe(card);\n\n        // Initial update might be needed if the card is already at a certain size on load\n        // The `observe` call itself triggers the first callback entry, so explicit call is often not necessary.\n        // However, if styles or content load async, you might want to call `resizeObserver.disconnect()` then `observe()` again.\n        // Or, for immediate visual, manually trigger update on load if needed:\n        // window.addEventListener('load', () => {\n        //     const initialRect = card.getBoundingClientRect();\n        //     resizeObserver.disconnect(); // Disconnect to ensure re-observe triggers new callback\n        //     resizeObserver.observe(card); \n        // });\n\n    </script>\n</body>\n</html>\n",
          "testCases": [
            "Load the page: The card should display its initial dimensions and font sizes.",
            "Resize the browser window from very wide to very narrow: Observe that the card's width and height reported dynamically update.",
            "Observe font size changes: As the card crosses the `350px` and `500px` width thresholds, the title and paragraph font sizes should change accordingly.",
            "Observe layout changes (if implemented): The `flex-direction` should change as the card crosses the `500px` threshold (e.g., from `column` to `row`).",
            "Test with different initial window sizes: The component should render correctly with appropriate styling based on its initial width.",
            "Ensure transitions are smooth and no visual jank occurs during resizing."
          ],
          "hints": [
            "The `ResizeObserver` callback receives an array of `ResizeObserverEntry` objects. Each entry has a `target` (the observed element) and `contentRect` (a `DOMRectReadOnly` object with `width`, `height`, etc.).",
            "You can modify element styles directly (e.g., `element.style.fontSize = '...'`) or toggle CSS classes based on width thresholds.",
            "Ensure your `resizable-card` has a responsive width (e.g., percentage width) so it actually changes size when the window is resized.",
            "CSS transitions can make the size/layout changes appear smoother."
          ],
          "tags": [
            "resize-observer",
            "responsive-design",
            "dom-manipulation",
            "css",
            "user-interface"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "theory_resize_observer",
            "css_flexbox",
            "dom_events"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "web_performance",
            "layout_thrashing",
            "css_media_queries"
          ]
        },
        {
          "id": "task_text_file_viewer",
          "title": "Text File Viewer via Drag and Drop",
          "description": "\nDevelop a web page that allows users to drag and drop a `.txt` file into a designated area. Upon dropping, the content of the `.txt` file should be read and displayed in a `textarea` or `pre` element on the page.\n\n**Requirements:**\n1.  **HTML Structure**:\n    *   A `div` element with a clear visual border and text indicating it's a 'Drop Zone'.\n    *   A `textarea` or `pre` element to display the file content.\n    *   A `div` to display error messages (e.g., if a non-text file is dropped).\n2.  **CSS**: Style the drop zone to make it visually distinct and provide feedback (e.g., change border color on `dragover`).\n3.  **JavaScript**:\n    *   **Prevent Default**: Add event listeners for `dragover` and `drop` on the drop zone, and call `event.preventDefault()` inside both handlers.\n    *   **Handle `dragenter`/`dragleave` (Optional)**: Change drop zone styling on `dragenter` and reset on `dragleave`.\n    *   **Handle `drop`**: Access dropped files using `event.dataTransfer.files`.\n    *   **File Validation**: Check if the first dropped file is a plain text file (`file.type === 'text/plain'` or `file.name.endsWith('.txt')`).\n    *   **Read File**: If valid, use `FileReader.readAsText(file)`.\n    *   **Display Content**: On `FileReader.onload`, display `event.target.result` in the content display area.\n    *   **Error Handling**: If a non-text file is dropped, display an appropriate error message in the error display area.\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Drag & Drop Text File Viewer</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; }\n        .container { max-width: 800px; margin: 0 auto; padding: 20px; border: 1px solid #eee; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); background-color: white; }\n        #drop-zone {\n            border: 2px dashed #ccc;\n            padding: 40px;\n            text-align: center;\n            font-size: 1.2em;\n            color: #666;\n            cursor: pointer;\n            transition: border-color 0.2s, background-color 0.2s;\n            margin-bottom: 20px;\n        }\n        #drop-zone.dragover { border-color: #007bff; background-color: #e6f7ff; }\n        #file-content {\n            width: calc(100% - 22px); /* Account for padding/border */\n            min-height: 200px;\n            border: 1px solid #ddd;\n            padding: 10px;\n            font-family: 'Courier New', Courier, monospace;\n            font-size: 14px;\n            resize: vertical;\n            background-color: #fafafa;\n        }\n        #error-message { color: red; margin-top: 10px; font-weight: bold; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Drag & Drop Text File Viewer</h1>\n        <div id=\"drop-zone\">Drag & Drop your .txt file here</div>\n        <textarea id=\"file-content\" placeholder=\"File content will appear here...\"></textarea>\n        <div id=\"error-message\"></div>\n    </div>\n\n    <script>\n        const dropZone = document.getElementById('drop-zone');\n        const fileContentDisplay = document.getElementById('file-content');\n        const errorMessageDisplay = document.getElementById('error-message');\n\n        // Prevent default drag behaviors\n        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {\n            dropZone.addEventListener(eventName, preventDefaults, false);\n        });\n\n        function preventDefaults(e) {\n            e.preventDefault();\n            e.stopPropagation();\n        }\n\n        // Add/remove dragover class for visual feedback\n        ['dragenter', 'dragover'].forEach(eventName => {\n            dropZone.addEventListener(eventName, () => dropZone.classList.add('dragover'), false);\n        });\n\n        ['dragleave', 'drop'].forEach(eventName => {\n            dropZone.addEventListener(eventName, () => dropZone.classList.remove('dragover'), false);\n        });\n\n        dropZone.addEventListener('drop', handleDrop, false);\n\n        function handleDrop(e) {\n            const dt = e.dataTransfer;\n            const files = dt.files;\n\n            fileContentDisplay.value = ''; // Clear previous content\n            errorMessageDisplay.textContent = ''; // Clear previous errors\n\n            if (files.length === 0) {\n                errorMessageDisplay.textContent = 'No files dropped.';\n                return;\n            }\n\n            const file = files[0]; // Get the first file\n\n            // Validate file type\n            if (file.type === 'text/plain' || file.name.endsWith('.txt')) {\n                const reader = new FileReader();\n\n                reader.onload = (event) => {\n                    fileContentDisplay.value = event.target.result; // Display content\n                };\n\n                reader.onerror = () => {\n                    errorMessageDisplay.textContent = 'Error reading the file.';\n                    console.error('FileReader error:', reader.error);\n                };\n\n                reader.readAsText(file); // Read as text\n            } else {\n                errorMessageDisplay.textContent = 'Please drop a .txt file. Other file types are not supported.';\n            }\n        }\n\n    </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Drag & Drop Text File Viewer</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; }\n        .container { max-width: 800px; margin: 0 auto; padding: 20px; border: 1px solid #eee; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); background-color: white; }\n        #drop-zone {\n            border: 2px dashed #ccc;\n            padding: 40px;\n            text-align: center;\n            font-size: 1.2em;\n            color: #666;\n            cursor: pointer;\n            transition: border-color 0.2s, background-color 0.2s;\n            margin-bottom: 20px;\n        }\n        #drop-zone.dragover { border-color: #007bff; background-color: #e6f7ff; }\n        #file-content {\n            width: calc(100% - 22px); /* Account for padding/border */\n            min-height: 200px;\n            border: 1px solid #ddd;\n            padding: 10px;\n            font-family: 'Courier New', Courier, monospace;\n            font-size: 14px;\n            resize: vertical;\n            background-color: #fafafa;\n        }\n        #error-message { color: red; margin-top: 10px; font-weight: bold; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Drag & Drop Text File Viewer</h1>\n        <div id=\"drop-zone\">Drag & Drop your .txt file here</div>\n        <textarea id=\"file-content\" placeholder=\"File content will appear here...\"></textarea>\n        <div id=\"error-message\"></div>\n    </div>\n\n    <script>\n        const dropZone = document.getElementById('drop-zone');\n        const fileContentDisplay = document.getElementById('file-content');\n        const errorMessageDisplay = document.getElementById('error-message');\n\n        // Step 1: Prevent default drag behaviors for all necessary events\n        // This is crucial to allow custom drop handling and prevent browser's default file opening\n        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {\n            dropZone.addEventListener(eventName, preventDefaults, false);\n        });\n\n        function preventDefaults(e) {\n            e.preventDefault();\n            e.stopPropagation(); // Stop propagation to prevent parent elements from handling\n        }\n\n        // Step 2: Add/remove 'dragover' class for visual feedback\n        ['dragenter', 'dragover'].forEach(eventName => {\n            dropZone.addEventListener(eventName, () => dropZone.classList.add('dragover'), false);\n        });\n\n        ['dragleave', 'drop'].forEach(eventName => {\n            dropZone.addEventListener(eventName, () => dropZone.classList.remove('dragover'), false);\n        });\n\n        // Step 3: Handle the 'drop' event\n        dropZone.addEventListener('drop', handleDrop, false);\n\n        function handleDrop(e) {\n            // Clear previous content and errors\n            fileContentDisplay.value = ''; \n            errorMessageDisplay.textContent = ''; \n\n            const files = e.dataTransfer.files; // Get the FileList object\n\n            if (files.length === 0) {\n                errorMessageDisplay.textContent = 'No files dropped.';\n                return;\n            }\n\n            const file = files[0]; // Get the first dropped file\n\n            // Step 4: Validate file type (text/plain or .txt extension)\n            if (file.type === 'text/plain' || file.name.toLowerCase().endsWith('.txt')) {\n                const reader = new FileReader();\n\n                // Step 5: Read file content using FileReader\n                reader.onload = (event) => {\n                    // Step 6: Display the file content\n                    fileContentDisplay.value = event.target.result; \n                };\n\n                reader.onerror = () => {\n                    errorMessageDisplay.textContent = 'Error reading the file. Please try again.';\n                    console.error('FileReader error:', reader.error);\n                };\n\n                reader.readAsText(file); // Read the file as text\n            } else {\n                errorMessageDisplay.textContent = 'Invalid file type. Please drop a .txt file.';\n            }\n        }\n\n    </script>\n</body>\n</html>\n",
          "testCases": [
            "Drag and drop a valid `.txt` file: The file's content should appear in the `textarea`.",
            "Drag and drop a file that is NOT a `.txt` file (e.g., an image, a PDF, a `.docx`): An error message should appear in the `error-message` div, stating it's an invalid file type.",
            "Drag and drop multiple files: Only the first file's content should be processed and displayed (as per requirement, though the prompt implies only one). Ensure no errors from handling multiple.",
            "Test `dragover` visual feedback: The drop zone border/background should change when a file is dragged over it and reset when dragged away or dropped.",
            "Attempt to drop no files (e.g., just drag and release without a file): Should gracefully handle and perhaps display 'No files dropped.'",
            "Test an empty `.txt` file: Should display an empty `textarea`."
          ],
          "hints": [
            "Remember to call `e.preventDefault()` in both `dragover` and `drop` events to enable custom handling.",
            "`event.dataTransfer.files` gives you a `FileList` object.",
            "Use `FileReader.readAsText(file)` to get the content as a string, and attach an `onload` event listener to the `FileReader` instance.",
            "The `file.type` property is useful for MIME type validation (e.g., `'text/plain'`). You can also check `file.name.endsWith('.txt')` for robustness.",
            "Clear previous messages/content before processing a new drop."
          ],
          "tags": [
            "drag-and-drop",
            "file-api",
            "dom-events",
            "javascript",
            "user-interface"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_drag_drop_file_reading",
            "dom_manipulation",
            "javascript_events"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "input_file_element",
            "blob_api",
            "event_bubbling"
          ]
        },
        {
          "id": "task_reusable_alert_component",
          "title": "Reusable Alert Component with Custom Elements and Shadow DOM",
          "description": "\nCreate a reusable web component `<my-alert>` using Custom Elements and Shadow DOM. This component should display a message and an optional type (e.g., 'info', 'warning', 'error') which affects its styling. It should also have a close button.\n\n**Requirements:**\n1.  **Custom Element Definition**:\n    *   Define a JavaScript class `MyAlert` that extends `HTMLElement`.\n    *   Register the element as `<my-alert>` using `customElements.define()`.\n2.  **Shadow DOM Encapsulation**:\n    *   Attach a Shadow DOM (`mode: 'open'`) in the component's constructor.\n    *   Place all internal HTML structure and CSS styles within the Shadow DOM.\n3.  **Attributes and Content**:\n    *   The alert should accept a `type` attribute (defaulting to 'info') and display its content from a `slot` element (allowing light DOM content).\n    *   Implement `static get observedAttributes()` to observe changes to the `type` attribute.\n    *   Implement `attributeChangedCallback()` to react to `type` changes and update styling.\n4.  **Styling**:\n    *   Provide default styles for the alert.\n    *   Change background color, border color, or icon based on the `type` attribute (e.g., blue for 'info', yellow for 'warning', red for 'error'). Use `:host` and `:host-context()` (or simpler class-based styling).\n5.  **Close Button**:\n    *   Include a close button (`` icon or text) inside the Shadow DOM.\n    *   When clicked, the button should remove the `<my-alert>` element from the DOM (e.g., `this.remove()`).\n6.  **Example Usage**:\n    *   Demonstrate usage of `<my-alert>` with different `type` attributes and content in the main HTML.\n",
          "difficulty": "hard",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Custom Alert Component</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; background-color: #f0f0f0; }\n        .container { max-width: 600px; margin: 0 auto; padding: 20px; background-color: white; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }\n        my-alert { margin-bottom: 15px; display: block; } /* Essential for custom elements */\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Custom Alert Component Demo</h1>\n\n        <my-alert type=\"info\">\n            This is an **info** alert! It provides general information.\n        </my-alert>\n\n        <my-alert type=\"warning\">\n            <strong>Warning!</strong> Something might be wrong, please check.\n        </my-alert>\n\n        <my-alert type=\"error\">\n            Oh no! An <span>error</span> occurred. Please try again.\n        </my-alert>\n\n        <my-alert>\n            This is a default alert (info type assumed).\n        </my-alert>\n\n    </div>\n\n    <script>\n        // Define the Custom Element class\n        class MyAlert extends HTMLElement {\n            static get observedAttributes() {\n                return ['type']; // Observe 'type' attribute changes\n            }\n\n            constructor() {\n                super();\n                // Attach Shadow DOM\n                const shadowRoot = this.attachShadow({ mode: 'open' });\n\n                // Internal HTML for the component\n                shadowRoot.innerHTML = `\n                    <style>\n                        /* Component-specific styles */\n                        :host {\n                            display: flex;\n                            align-items: center;\n                            padding: 10px 15px;\n                            border-radius: 5px;\n                            font-family: sans-serif;\n                            box-shadow: 0 1px 3px rgba(0,0,0,0.1);\n                        }\n                        .alert-content {\n                            flex-grow: 1;\n                            margin-right: 10px;\n                        }\n                        .close-btn {\n                            background: none;\n                            border: none;\n                            font-size: 1.2em;\n                            cursor: pointer;\n                            line-height: 1;\n                            padding: 0;\n                            color: inherit; /* Inherit color from host for consistency */\n                        }\n\n                        /* Type-specific styles */\n                        :host([type=\"info\"]) {\n                            background-color: #e7f3fe;\n                            border-left: 5px solid #2196F3;\n                            color: #2196F3;\n                        }\n                        :host([type=\"warning\"]) {\n                            background-color: #fff3e0;\n                            border-left: 5px solid #ff9800;\n                            color: #ff9800;\n                        }\n                        :host([type=\"error\"]) {\n                            background-color: #ffe0e0;\n                            border-left: 5px solid #f44336;\n                            color: #f44336;\n                        }\n                        \n                        /* Slot styling */\n                        ::slotted(span) { /* Example of styling slotted content */\n                            font-weight: bold;\n                        }\n                    </style>\n                    <div class=\"alert-content\">\n                        <slot></slot>\n                    </div>\n                    <button class=\"close-btn\"></button>\n                `;\n\n                // Add event listener for the close button\n                this.shadowRoot.querySelector('.close-btn').addEventListener('click', () => {\n                    this.remove(); // Remove the component from the DOM\n                });\n\n                // Initial attribute application\n                this._updateType(this.getAttribute('type') || 'info');\n            }\n\n            attributeChangedCallback(name, oldValue, newValue) {\n                if (name === 'type' && oldValue !== newValue) {\n                    this._updateType(newValue || 'info');\n                }\n            }\n\n            _updateType(newType) {\n                // This function simply ensures the :host styles are applied correctly\n                // by re-setting the attribute if it was null, or just letting CSS handle it.\n                // The :host selector in CSS handles the actual styling based on attribute presence.\n                if (!this.hasAttribute('type') && newType === 'info') {\n                    // If no type is specified, and default is 'info', do nothing specific\n                    // as the CSS :host rule for info will apply via default type.\n                } else {\n                    this.setAttribute('type', newType);\n                }\n            }\n\n            // Optional: connectedCallback for when the element is added to DOM\n            connectedCallback() {\n                 console.log('MyAlert connected to DOM:', this.getAttribute('type'));\n                 // Ensure default type is set if none provided\n                 if (!this.hasAttribute('type')) {\n                    this.setAttribute('type', 'info');\n                 }\n            }\n\n             // Optional: disconnectedCallback for when the element is removed from DOM\n            disconnectedCallback() {\n                console.log('MyAlert disconnected from DOM.');\n            }\n        }\n\n        // Register the custom element\n        customElements.define('my-alert', MyAlert);\n    </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Custom Alert Component</title>\n    <style>\n        body { font-family: sans-serif; margin: 20px; background-color: #f0f0f0; }\n        .container { max-width: 600px; margin: 0 auto; padding: 20px; background-color: white; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }\n        my-alert { margin-bottom: 15px; display: block; } /* Essential for custom elements to render correctly */\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Custom Alert Component Demo</h1>\n\n        <my-alert type=\"info\">\n            This is an **info** alert! It provides general information.\n        </my-alert>\n\n        <my-alert type=\"warning\">\n            <strong>Warning!</strong> Something might be wrong, please check.\n        </my-alert>\n\n        <my-alert type=\"error\">\n            Oh no! An <span>error</span> occurred. Please try again.\n        </my-alert>\n\n        <my-alert>\n            This is a default alert (info type assumed).\n        </my-alert>\n\n        <button id=\"add-alert-button\">Add New Info Alert</button>\n\n    </div>\n\n    <script>\n        // Define the Custom Element class\n        class MyAlert extends HTMLElement {\n            // 1. Observe 'type' attribute for changes\n            static get observedAttributes() {\n                return ['type']; \n            }\n\n            constructor() {\n                super(); // Always call super() first in the constructor\n                // 2. Attach Shadow DOM in 'open' mode for encapsulation\n                const shadowRoot = this.attachShadow({ mode: 'open' });\n\n                // Internal HTML and CSS for the component\n                shadowRoot.innerHTML = `\n                    <style>\n                        /* Component-specific styles */\n                        :host {\n                            display: flex; /* Ensures flex layout for content and close button */\n                            align-items: center;\n                            padding: 10px 15px;\n                            border-radius: 5px;\n                            font-family: sans-serif;\n                            box-shadow: 0 1px 3px rgba(0,0,0,0.1);\n                            transition: background-color 0.3s, border-left-color 0.3s, color 0.3s;\n                        }\n                        .alert-content {\n                            flex-grow: 1; /* Content takes up available space */\n                            margin-right: 10px;\n                            line-height: 1.4;\n                        }\n                        .close-btn {\n                            background: none;\n                            border: none;\n                            font-size: 1.5em; /* Larger 'x' */\n                            cursor: pointer;\n                            line-height: 1;\n                            padding: 0;\n                            color: inherit; /* Inherit text color for consistency */\n                            margin-left: auto; /* Push to right */\n                            opacity: 0.7;\n                            transition: opacity 0.2s;\n                        }\n                        .close-btn:hover {\n                            opacity: 1;\n                        }\n\n                        /* Type-specific styles using :host-context() or :host() based on attribute */\n                        :host([type=\"info\"]) {\n                            background-color: #e7f3fe;\n                            border-left: 5px solid #2196F3;\n                            color: #2196F3;\n                        }\n                        :host([type=\"warning\"]) {\n                            background-color: #fff3e0;\n                            border-left: 5px solid #ff9800;\n                            color: #ff9800;\n                        }\n                        :host([type=\"error\"]) {\n                            background-color: #ffe0e0;\n                            border-left: 5px solid #f44336;\n                            color: #f44336;\n                        }\n                        \n                        /* Styling for slotted content, demonstrating ::slotted() */\n                        ::slotted(strong) {\n                            font-weight: bold;\n                            color: inherit; /* Ensure strong text color matches alert color */\n                        }\n                        ::slotted(span) {\n                            font-style: italic;\n                        }\n                    </style>\n                    <div class=\"alert-content\">\n                        <slot></slot> <!-- Slot for light DOM content -->\n                    </div>\n                    <button class=\"close-btn\"></button>\n                `;\n\n                // Add event listener for the close button\n                this.shadowRoot.querySelector('.close-btn').addEventListener('click', () => {\n                    this.remove(); // Remove the component from the DOM\n                    console.log('Alert removed.');\n                });\n            }\n\n            // Invoked when the custom element is added to the document's DOM\n            connectedCallback() {\n                 console.log('MyAlert connected to DOM:', this.getAttribute('type') || 'default');\n                 // Set default 'type' if not provided\n                 if (!this.hasAttribute('type')) {\n                    this.setAttribute('type', 'info');\n                 }\n                 // Apply initial styling based on attributes, if needed (CSS :host handles this typically)\n                 this._updateStylesBasedOnType();\n            }\n\n            // Invoked when the custom element is disconnected from the document's DOM\n            disconnectedCallback() {\n                console.log('MyAlert disconnected from DOM.');\n            }\n\n            // Invoked when one of the observed attributes is added, removed, or changed\n            attributeChangedCallback(name, oldValue, newValue) {\n                if (name === 'type' && oldValue !== newValue) {\n                    console.log(`Attribute 'type' changed from ${oldValue} to ${newValue}.`);\n                    this._updateStylesBasedOnType(); // Re-apply styles if type changes\n                }\n            }\n\n            // Helper to ensure styles are updated (CSS :host takes care of most of it,\n            // but this method can be extended for more complex JS-driven style logic if needed)\n            _updateStylesBasedOnType() {\n                // In this setup, the CSS `:host([type=\"...\"])` rules handle the styling automatically\n                // when the 'type' attribute is set or changed. No explicit JS style manipulation needed here.\n                // This function serves as a placeholder for more complex attribute-based logic.\n                const currentType = this.getAttribute('type');\n                // For instance, if you had different icons per type:\n                // const iconElement = this.shadowRoot.querySelector('.icon');\n                // if (iconElement) { iconElement.textContent = getIconForType(currentType); }\n            }\n        }\n\n        // Register the custom element with the browser\n        customElements.define('my-alert', MyAlert);\n\n        // Example of dynamically adding an alert\n        document.getElementById('add-alert-button').addEventListener('click', () => {\n            const newAlert = document.createElement('my-alert');\n            newAlert.setAttribute('type', 'info');\n            newAlert.textContent = `Dynamically added alert! (${new Date().toLocaleTimeString()})`;\n            document.querySelector('.container').appendChild(newAlert);\n        });\n    </script>\n</body>\n</html>\n",
          "testCases": [
            "Load the page: All four alerts should render with correct default (info) or specified `type` styling.",
            "Click the close button on each alert: The alert should disappear from the page.",
            "Inspect elements in Dev Tools: Verify that `<my-alert>` has a `#shadow-root` and its internal structure/styles are encapsulated.",
            "Change the `type` attribute of a rendered alert using Dev Tools (e.g., `document.querySelector('my-alert[type=\"info\"]').setAttribute('type', 'error')`): The alert's styling should dynamically update based on the new type.",
            "Add a new alert using the 'Add New Info Alert' button: The new alert should appear with default info styling and be closable.",
            "Verify `::slotted` content is styled correctly (e.g., 'strong' text in warning alert)."
          ],
          "hints": [
            "Start by creating the `MyAlert` class extending `HTMLElement` and calling `super()` in the constructor.",
            "Use `this.attachShadow({ mode: 'open' })` to create the Shadow DOM.",
            "The `<slot></slot>` element inside the Shadow DOM is crucial for rendering the 'light DOM' content placed inside your custom element (e.g., `This is an alert.`).",
            "Use `:host` CSS pseudo-class in your Shadow DOM stylesheet to style the custom element itself.",
            "Use `:host([type=\"info\"])` to apply type-specific styles based on the `type` attribute.",
            "Remember to define `static get observedAttributes()` to make `attributeChangedCallback` work.",
            "The close button's click handler should call `this.remove()` to remove the component."
          ],
          "tags": [
            "web-components",
            "custom-elements",
            "shadow-dom",
            "encapsulation",
            "reusability",
            "frontend-architecture"
          ],
          "timeEstimate": 120,
          "prerequisites": [
            "theory_custom_elements",
            "theory_shadow_dom",
            "javascript_classes",
            "css_selectors"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "component_design",
            "design_systems",
            "html_slots"
          ]
        }
      ]
    }
  }
]