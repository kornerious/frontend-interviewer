[
  {
    "id": "9b1a3405-fa73-4124-bedd-7912f9063ff8",
    "startLine": 2800,
    "endLine": 2899,
    "processedDate": "2025-06-17T08:30:48.444Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_virtual_dom",
          "title": "Virtual DOM vs. Real DOM and Performance Benefits",
          "content": "## Understanding the DOM (Document Object Model)\n\nThe **Real DOM** is a programming interface for HTML and XML documents. It represents the page structure as a tree of nodes, where each node is an element, attribute, or text. When an element on a webpage changes, the browser must re-render that specific element and its children, which can be computationally expensive, especially for complex UIs with frequent updates.\n\n### Real DOM Characteristics:\n- **Updates Slowly**: Direct manipulation of the Real DOM is slow because it involves recalculating CSS, layout, and painting for the entire subtree affected by the change.\n- **Direct Manipulation**: Allows direct manipulation of HTML elements.\n- **Full DOM Reconstruction**: When an element updates, the entire DOM might need to be re-evaluated or re-created, leading to performance bottlenecks.\n- **Expensive Manipulation**: Each DOM manipulation operation is costly.\n- **Higher Memory Consumption**: Requires more memory as it represents the live, rendered UI.\n\n## Introducing the Virtual DOM\n\nThe **Virtual DOM** is a concept implemented by libraries like React to optimize UI updates. It's a lightweight, in-memory representation of the Real DOM. When the state of a component changes, React first updates its Virtual DOM. It then compares the new Virtual DOM with the previous one (a process called 'diffing') to identify exactly what has changed.\n\n### Virtual DOM Characteristics:\n- **Updates Faster**: Changes are applied to the in-memory Virtual DOM, which is much quicker than directly manipulating the Real DOM.\n- **Indirect Manipulation**: Cannot directly manipulate HTML; it's an abstraction layer.\n- **Efficient Updates**: Updates only the JSX (React's syntax extension) representation, which then intelligently applies minimal changes to the Real DOM.\n- **Easy Manipulation**: DOM manipulation becomes abstracted and very efficient.\n- **Less Memory Consumption**: Generally uses less memory as it's a lightweight representation.\n\n### The Reconciliation Process:\n\nReact's reconciliation algorithm is the core mechanism behind the Virtual DOM's performance benefits. When a component's `render()` method returns a different React element tree, React will diff the new tree with the previous one. It then calculates the most efficient way to update the Real DOM to match the new tree. This process involves:\n1.  **Re-rendering the Component**: When a component's state or props change, React re-renders its `render()` method.\n2.  **Virtual DOM Creation**: A new Virtual DOM tree is created based on the updated component state.\n3.  **Diffing Algorithm**: React compares the new Virtual DOM tree with the previous one. This algorithm identifies the minimal set of changes needed.\n4.  **Batching Updates**: React batches multiple updates into a single re-render operation to minimize direct DOM manipulations.\n5.  **Real DOM Update**: Only the identified differences are then applied to the Real DOM.\n\n## Performance Benefits of Virtual DOM:\n\n1.  **Reduced DOM Operations**: By diffing the Virtual DOM, React minimizes the number of expensive direct DOM manipulations, only updating parts of the Real DOM that have actually changed.\n2.  **Batch Processing**: React groups multiple state updates together and applies them in a single batch to the Real DOM, avoiding redundant re-renders and improving efficiency.\n3.  **Cross-Platform**: The same reconciliation model and Virtual DOM concept can be applied across different rendering environments (e.g., web, mobile with React Native, desktop with Electron), providing a consistent development experience.\n4.  **Declarative API**: Developers describe the desired UI state, and React handles the complex imperative steps of updating the Real DOM to match that state. This simplifies development by abstracting away direct DOM manipulation concerns.\n\n**Image illustrating the Virtual DOM process:**\n\n![Virtual DOM Process](https://example.com/virtual-dom-flow.png) <!-- Placeholder, as no image was provided in the original content -->\n\nThis image visually explains how changes flow from component state to Virtual DOM diffing, and finally to the optimized Real DOM update."
        },
        {
          "id": "theory_component_types",
          "title": "React Component Types: Class vs. Functional Components",
          "content": "React applications are built using components, which are independent, reusable pieces of UI. Historically, React primarily used Class Components, but with the introduction of Hooks, Functional Components have become the preferred way to write new components.\n\n## Class Components\n\n**Class Components** are JavaScript ES6 classes that extend `React.Component`. They can hold and manage their own state (`this.state`) and have lifecycle methods (like `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`) that allow you to hook into different stages of a component's life cycle. They use a `render()` method to return JSX.\n\n### Characteristics of Class Components:\n-   **State Management**: Can have internal state (`this.state`) and update it using `this.setState()`. This makes them 'stateful' or 'container' components.\n-   **Lifecycle Methods**: Provide specific methods to run code at specific points in a component's lifecycle (e.g., when it mounts, updates, or unmounts).\n-   **`this` Context**: Require careful handling of `this` context, especially when passing methods as props.\n-   **More Boilerplate**: Generally require more code for setup and state management.\n\n## Functional Components\n\n**Functional Components** are plain JavaScript functions that accept props as an argument and return React elements (JSX). Before Hooks, they were primarily used for 'stateless' or 'presentational' components because they couldn't manage their own state or side effects.\n\nWith the introduction of **Hooks** (like `useState`, `useEffect`, `useContext`, etc.), Functional Components gained the ability to manage state, perform side effects, and access other React features, making them equally powerful as Class Components.\n\n### Characteristics of Functional Components:\n-   **Simpler Syntax**: More concise and easier to read.\n-   **No `this` Binding Issues**: Don't have `this` context issues common in class components.\n-   **Hooks for State & Lifecycle**: Use Hooks (`useState`, `useEffect`) to manage state and side effects, effectively replacing `this.state` and lifecycle methods.\n-   **Easier to Test**: Often easier to test due to their pure function nature (before Hooks) or clearer separation of concerns (with Hooks).\n-   **Better Performance (Potentially)**: While React optimizes both, functional components can sometimes lead to smaller bundle sizes and slightly better performance due to less overhead (no class instances, less inheritance chain).\n\n### Comparison Overview:\n\n| Feature           | Class Components                      | Functional Components (with Hooks)              |\n|-------------------|---------------------------------------|-------------------------------------------------|\n| Syntax            | ES6 Class extending `React.Component` | Plain JavaScript function                       |\n| State             | `this.state`, `this.setState()`       | `useState` Hook                                 |\n| Lifecycle         | Lifecycle methods (e.g., `componentDidMount`) | `useEffect` Hook                              |\n| `this` Context    | Present, requires binding             | Not present                                     |\n| Boilerplate       | More                                  | Less                                            |\n| Reusability       | Higher-Order Components (HOCs), Render Props | Hooks, Custom Hooks                             |\n\nBoth types of components can accomplish similar tasks, but functional components with Hooks are the modern standard in React development due to their simplicity, reusability, and improved readability.\n",
          "examples": [
            {
              "id": "example_class_component_1",
              "title": "Class Component Example (News Feed)",
              "code": "import React from 'react';\n\nclass News extends React.Component {\n  render() {\n    const newsTemplate = this.props.data.map(function(item) {\n      return (\n        <div key={item.id}>\n          <p className=\"news__author\">{item.author}:</p>\n          <p className=\"news__text\">{item.text}</p>\n        </div>\n      )\n    })\n    return (\n      <div className=\"news\">\n        {newsTemplate}\n      </div>\n    )\n  }\n}",
              "explanation": "This example shows a basic class component named `News`. It extends `React.Component` and contains a `render()` method which returns JSX. The component accesses its data via `this.props.data` and maps over it to display individual news items. Note the use of `function(item)` for mapping, which establishes its own `this` context (though not relevant here as `this` is not used inside the map callback for component properties).",
              "language": "javascript"
            },
            {
              "id": "example_functional_component_1",
              "title": "Functional Component Example (News Feed - Traditional)",
              "code": "import React from 'react';\n\nfunction News(props) {\n  const newsTemplate = props.data.map(item => (\n    <div key={item.id}>\n      <p className=\"news__author\">{item.author}:</p>\n      <p className=\"news__text\">{item.text}</p>\n    </div>\n  ));\n  \n  return (\n    <div className=\"news\">\n      {newsTemplate}\n    </div>\n  );\n}",
              "explanation": "This is the functional equivalent of the `News` component. It's a plain JavaScript function that receives `props` as its argument. It directly uses `props.data` to render the news items. This version is more concise and avoids the `this` keyword, making it simpler for presentation-only components.",
              "language": "javascript"
            },
            {
              "id": "example_functional_component_2",
              "title": "Functional Component Example (News Feed - Arrow Function with Destructuring)",
              "code": "import React from 'react';\n\nconst News = (props) => {\n  const { data } = props;\n  \n  return (\n    <div className=\"news\">\n      {data.map(item => (\n        <div key={item.id}>\n          <p className=\"news__author\">{item.author}:</p>\n          <p className=\"news__text\">{item.text}</p>\n        </div>\n      ))}\n    </div>\n  );\n}",
              "explanation": "This variant of the functional component uses an arrow function syntax, which is common in modern React. It also demonstrates destructuring `props` (`const { data } = props;`) for cleaner access to properties. This is syntactically equivalent to the previous functional component example but reflects a more contemporary coding style.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_class_functional_diff_1",
            "question_class_functional_hooks_2",
            "question_functional_state_3",
            "question_class_lifecycle_4",
            "question_functional_advantages_5",
            "question_convert_to_functional_code_1",
            "question_class_functional_flashcard_1"
          ],
          "relatedTasks": [
            "task_component_conversion",
            "task_stateful_vs_stateless_counter"
          ],
          "tags": [
            "React",
            "Components",
            "Class Components",
            "Functional Components",
            "Hooks",
            "JSX",
            "Props"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript ES6",
            "React Basics",
            "JSX"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "React Hooks",
            "State Management",
            "Component Architecture"
          ]
        },
        {
          "id": "theory_stateless_stateful",
          "title": "Stateless vs. Stateful React Components",
          "content": "In React, components can be broadly categorized based on their ability to manage internal state:\n\n## Stateless Components (Presentational Components)\n\n**Stateless Components** are typically pure JavaScript functions (or class components without `this.state`) that accept props and return React elements. Their primary responsibility is to render UI based on the props they receive. They do not have their own internal state, and therefore, their output is predictable given the same props.\n\n### Characteristics of Stateless Components:\n-   **Pure Functions**: Given the same props, they will always render the same output.\n-   **No Internal State**: They do not manage `this.state` or use `useState` hook.\n-   **Focus on UI (How things look)**: Their main purpose is to present data. They are often referred to as 'dumb' or 'presentational' components.\n-   **Easier to Test and Debug**: Due to their predictability and lack of side effects, they are simpler to test in isolation.\n-   **Better Performance (in some cases)**: Without state or lifecycle methods to process, they can sometimes lead to minor performance gains and are easier for React to optimize.\n-   **Ideal for Displaying Data**: Best used for presenting static data or UI elements based on props.\n\n## Stateful Components (Container Components)\n\n**Stateful Components** (also known as 'Container' or 'Smart' components) are responsible for managing data, state, and complex logic. They typically fetch data, perform computations, and then pass down data and callback functions as props to their stateless children for rendering.\n\n### Characteristics of Stateful Components:\n-   **Internal State Management**: They can manage internal state using `this.state` (in class components) or `useState` (in functional components).\n-   **Business Logic**: Contain the application's business logic, data fetching, and state manipulation.\n-   **Focus on Behavior (How things work)**: Their main purpose is to manage state and logic, passing processed data to presentational components.\n-   **Lifecycle Management**: Class components use lifecycle methods; functional components use `useEffect` for side effects like data fetching or subscriptions.\n-   **Less Reusable in Isolation**: Due to their specific logic and state, they are often less reusable than stateless components, but they compose stateless components to build complex UIs.\n-   **Act as Data Sources**: They often serve as data sources for their presentational descendants.\n\n### The Container/Presentational Pattern:\n\nThis pattern encourages a clear separation of concerns:\n-   **Containers (Stateful)**: Handle data, state, and logic. They often render other components (including presentational ones) and pass data to them.\n-   **Presentational (Stateless)**: Responsible solely for rendering UI based on the props they receive. They are unaware of how data is loaded or managed.\n\nThis separation leads to more maintainable, testable, and reusable code.",
          "examples": [
            {
              "id": "example_stateless_component_1",
              "title": "Stateless Functional Component (UserProfile)",
              "code": "import React from 'react';\n\nfunction UserProfile({ name, age, isActive, hobbies }) {\n  return (\n    <div className=\"profile\">\n      <h2>{name}</h2>\n      <p>Age: {age}</p>\n      <p>Status: {isActive ? 'Active' : 'Inactive'}</p>\n      {hobbies && hobbies.length > 0 && (\n        <div>\n          <h3>Hobbies:</h3>\n          <ul>\n            {hobbies.map((hobby, index) => <li key={index}>{hobby}</li>)}\n          </ul>\n        </div>\n      )}\n    </div>\n  );\n}",
              "explanation": "This `UserProfile` component is stateless. It receives all necessary data via props (`name`, `age`, `isActive`, `hobbies`) and simply renders them. It has no internal state and its output is solely determined by its input props, making it predictable and easy to test.",
              "language": "javascript"
            },
            {
              "id": "example_stateful_component_1",
              "title": "Stateful Functional Component (Counter)",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  const decrement = () => {\n    setCount(prevCount => prevCount - 1);\n  };\n\n  return (\n    <div className=\"counter-container\">\n      <h3>Current Count: {count}</h3>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n    </div>\n  );\n}",
              "explanation": "This `Counter` component is stateful because it manages its own internal `count` state using the `useState` hook. It also contains logic (the `increment` and `decrement` functions) to update this state. This makes it a 'smart' component responsible for managing its own behavior.",
              "language": "javascript"
            },
            {
              "id": "example_stateful_stateless_composition_1",
              "title": "Stateful Parent and Stateless Child Composition",
              "code": "import React, { useState } from 'react';\n\n// Stateless Child Component\nfunction DisplayCount({ count }) {\n  return (\n    <p>The current count is: <strong>{count}</strong></p>\n  );\n}\n\n// Stateful Parent Component\nfunction CounterApp() {\n  const [currentCount, setCurrentCount] = useState(0);\n\n  const handleIncrement = () => {\n    setCurrentCount(prevCount => prevCount + 1);\n  };\n\n  const handleDecrement = () => {\n    setCurrentCount(prevCount => prevCount - 1);\n  };\n\n  return (\n    <div>\n      <h1>Counter Application</h1>\n      <DisplayCount count={currentCount} /> {/* Stateless child receives count as prop */}\n      <button onClick={handleIncrement}>Increase</button>\n      <button onClick={handleDecrement}>Decrease</button>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates the container/presentational pattern. `CounterApp` is a stateful component that manages the `currentCount` state and the logic for incrementing/decrementing it. `DisplayCount` is a stateless component that simply receives the `count` as a prop and displays it. This separation makes `DisplayCount` highly reusable and simpler, while `CounterApp` manages the application's core logic.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_stateless_characteristics_1",
            "question_stateful_role_2",
            "question_presentational_container_3",
            "question_stateless_performance_4",
            "question_stateless_debug_5",
            "question_state_props_flashcard_1",
            "question_stateless_code_1"
          ],
          "relatedTasks": [
            "task_stateful_vs_stateless_counter"
          ],
          "tags": [
            "React",
            "Components",
            "State",
            "Props",
            "Stateless Components",
            "Stateful Components",
            "Presentational Components",
            "Container Components"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "Props",
            "State Management in React (useState)"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Component Architecture",
            "State Management Patterns",
            "Performance Optimization"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_virtual_dom_speed_mcq_1",
          "topic": "Virtual DOM",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is a primary reason why Virtual DOM updates faster than Real DOM?",
          "answer": "It minimizes the number of direct DOM manipulations.",
          "options": [
            "It directly manipulates HTML.",
            "It minimizes the number of direct DOM manipulations.",
            "It creates a new DOM whenever an element updates.",
            "It consumes more memory, thus processing faster."
          ],
          "analysisPoints": [
            "The Virtual DOM is an in-memory representation, allowing fast comparisons.",
            "The 'diffing' algorithm identifies minimal changes needed.",
            "Batch processing groups multiple updates into one Real DOM update.",
            "Direct Real DOM manipulation is expensive due to re-layouts and re-paints."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Real DOM",
            "DOM Manipulation",
            "Performance"
          ],
          "evaluationCriteria": [
            "Understanding of Virtual DOM's core performance benefit.",
            "Ability to distinguish between efficient and inefficient DOM operations."
          ],
          "example": "The Virtual DOM first updates its own lightweight representation. Then, it compares this new version with the previous one. Only the identified differences are 'patched' to the actual Real DOM, reducing costly direct manipulations.",
          "tags": [
            "Virtual DOM",
            "Performance",
            "React",
            "DOM"
          ],
          "prerequisites": [
            "Basic DOM knowledge",
            "Understanding of UI rendering"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_real_dom_property_mcq_2",
          "topic": "Real DOM",
          "level": "easy",
          "type": "mcq",
          "question": "According to the provided content, which statement is true regarding the Real DOM?",
          "answer": "It can directly manipulate HTML.",
          "options": [
            "It updates faster than the Virtual DOM.",
            "It cannot directly manipulate HTML.",
            "It creates a new DOM when an element updates.",
            "DOM manipulation is very easy with it."
          ],
          "analysisPoints": [
            "The Real DOM is the actual browser DOM, allowing direct manipulation.",
            "Its updates are slow compared to Virtual DOM due to re-layouts/re-paints.",
            "Virtual DOM updates JSX, not the Real DOM directly.",
            "Real DOM manipulation is expensive and not 'easy' in terms of performance."
          ],
          "keyConcepts": [
            "Real DOM",
            "Virtual DOM",
            "DOM Manipulation",
            "Performance"
          ],
          "evaluationCriteria": [
            "Correct recall of Real DOM characteristics.",
            "Ability to differentiate Real DOM from Virtual DOM properties."
          ],
          "example": "The browser uses the Real DOM to render web pages. Developers can access and modify it directly using standard DOM APIs (e.g., `document.getElementById().innerHTML = 'new content'`). However, such direct modifications trigger expensive browser reflows and repaints.",
          "tags": [
            "Real DOM",
            "DOM",
            "HTML",
            "Browser"
          ],
          "prerequisites": [
            "Basic DOM knowledge"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_reconciliation_open_1",
          "topic": "Virtual DOM Reconciliation",
          "level": "medium",
          "type": "open",
          "question": "Explain the reconciliation process in React, detailing how the Virtual DOM contributes to efficient UI updates.",
          "answer": "The reconciliation process is React's algorithm for efficiently updating the browser's Real DOM. It involves three main steps:\n\n1.  **Re-rendering and Virtual DOM Creation**: When a component's state or props change, React re-executes its `render()` method, creating a new Virtual DOM tree (a React Element tree) that represents the updated UI.\n\n2.  **Diffing Algorithm**: React then compares this new Virtual DOM tree with the previous one. This 'diffing' algorithm works by comparing elements level by level. If two elements are of different types, React will tear down the old tree and build the new one from scratch. If they are of the same type, React looks at the attributes (props) and updates only the changed ones. For lists, it uses `keys` to identify which items have changed, been added, or removed.\n\n3.  **Batching and Real DOM Update**: After identifying the minimal set of changes (the 'diff'), React batches these updates together. Instead of making many small, individual changes to the Real DOM, it applies all changes in a single, optimized operation. This batching, combined with only updating the necessary parts of the Real DOM, significantly reduces expensive browser operations like layout calculation and painting, leading to faster and smoother UI updates.",
          "analysisPoints": [
            "Clarity in explaining the steps (render, diff, update).",
            "Understanding of the Virtual DOM's role as an intermediate step.",
            "Mention of diffing algorithm and its efficiency.",
            "Explanation of batching and its performance benefits."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Reconciliation",
            "Diffing Algorithm",
            "Batching",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Detailed explanation of the process flow.",
            "Accuracy in describing how Virtual DOM improves performance.",
            "Use of correct terminology."
          ],
          "example": "When a user clicks a 'Like' button, only the 'like count' text needs to change, not the entire comment section. React's Virtual DOM diffs the old and new component states, identifies just the text node change, and efficiently updates only that specific text node in the Real DOM, avoiding a full re-render of the parent comment.",
          "tags": [
            "React",
            "Virtual DOM",
            "Performance",
            "Reconciliation",
            "Interview Question"
          ],
          "prerequisites": [
            "Theory of Virtual DOM"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_flashcard_1",
          "topic": "Virtual DOM",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary role of the Virtual DOM in React?",
          "answer": "To provide an in-memory representation of the Real DOM, enabling efficient updates by minimizing direct DOM manipulations through a diffing algorithm.",
          "analysisPoints": [
            "Recall of Virtual DOM definition.",
            "Understanding of its purpose (efficiency)."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Efficiency",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Concise and accurate definition."
          ],
          "example": "N/A",
          "tags": [
            "Virtual DOM",
            "React",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_declarative_api_flashcard_1",
          "topic": "Declarative API",
          "level": "medium",
          "type": "flashcard",
          "question": "How does React's 'Declarative API' benefit developers in terms of DOM updates?",
          "answer": "Developers describe the desired UI state, and React handles the complex imperative steps of updating the Real DOM to match that state, abstracting away direct DOM manipulation concerns.",
          "analysisPoints": [
            "Understanding the concept of declarative programming.",
            "Relating it to React's approach to UI updates.",
            "Contrasting with imperative DOM manipulation."
          ],
          "keyConcepts": [
            "Declarative API",
            "React",
            "DOM Updates",
            "Abstraction"
          ],
          "evaluationCriteria": [
            "Ability to explain the benefit of declarative UI."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Declarative",
            "API",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_functional_diff_1",
          "topic": "Class vs Functional Components",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is a primary distinction between a React Class Component and a Functional Component (when Hooks are used in the latter)?",
          "answer": "Class components use `this.state` for state management, while functional components use the `useState` hook.",
          "options": [
            "Class components can manage state, but functional components cannot.",
            "Class components use `this.state` for state management, while functional components use the `useState` hook.",
            "Class components require `props` to be passed explicitly, while functional components receive them automatically.",
            "Functional components always have access to lifecycle methods, while class components do not."
          ],
          "analysisPoints": [
            "Functional components *can* manage state with `useState`.",
            "The core difference in state management syntax (`this.state` vs. `useState`).",
            "Both component types receive props automatically.",
            "Class components use lifecycle methods; functional components use `useEffect` (a Hook) to replicate similar behavior."
          ],
          "keyConcepts": [
            "Class Components",
            "Functional Components",
            "State Management",
            "Hooks",
            "useState"
          ],
          "evaluationCriteria": [
            "Correct identification of state management differences.",
            "Understanding of how Hooks enable state in functional components."
          ],
          "example": "```javascript\n// Class Component State\nclass MyClassComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n}\n\n// Functional Component State\nfunction MyFunctionComponent() {\n  const [count, setCount] = React.useState(0);\n}\n```",
          "tags": [
            "React",
            "Components",
            "Class Components",
            "Functional Components",
            "Hooks",
            "State"
          ],
          "prerequisites": [
            "React Basics",
            "Introduction to Hooks"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_functional_hooks_2",
          "topic": "Class vs Functional Components",
          "level": "medium",
          "type": "open",
          "question": "Discuss the advantages of using Functional Components with Hooks over Class Components for modern React development.",
          "answer": "Functional Components with Hooks offer several advantages in modern React development:\n\n1.  **Simpler Syntax & Less Boilerplate**: Functional components are plain JavaScript functions, leading to more concise and readable code compared to the class syntax, which requires `extends React.Component`, `constructor`, `super(props)`, and the `render()` method.\n2.  **No `this` Binding Issues**: Functional components don't have their own `this` context, eliminating the common problem of `this` binding in class components' event handlers, which often required `.bind(this)` or arrow functions.\n3.  **Improved Reusability with Custom Hooks**: Hooks allow stateful logic to be extracted and reused across different components without altering the component hierarchy (unlike HOCs or render props patterns used with class components). This promotes cleaner, more modular code.\n4.  **Better Separation of Concerns**: `useEffect` allows grouping related logic (e.g., data fetching and cleanup) into a single hook, rather than scattering it across multiple lifecycle methods (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`) in class components. This improves code organization and readability.\n5.  **Easier to Test**: Being pure functions (initially) or functions that clearly define their dependencies and effects, functional components can sometimes be easier to test in isolation.\n6.  **Potential for Optimizations**: While React optimizes both, functional components can sometimes lead to smaller bundle sizes and potentially better performance due to less overhead (no class instances).\n\nIn summary, Hooks provide a more direct API to React features like state and lifecycle, making functional components powerful, flexible, and the preferred paradigm for new React development.",
          "analysisPoints": [
            "Covers syntax simplification.",
            "Addresses `this` binding problem.",
            "Explains reusability via custom hooks.",
            "Discusses separation of concerns with `useEffect`.",
            "Mentions testability and potential performance benefits."
          ],
          "keyConcepts": [
            "Functional Components",
            "Class Components",
            "React Hooks",
            "useState",
            "useEffect",
            "Code Reusability",
            "Separation of Concerns"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison of advantages.",
            "Clear explanation of how Hooks address class component limitations.",
            "Demonstration of in-depth React knowledge."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Components",
            "Hooks",
            "Best Practices",
            "Interview Question"
          ],
          "prerequisites": [
            "Knowledge of Class Components",
            "Knowledge of React Hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_functional_state_3",
          "topic": "Functional Components",
          "level": "easy",
          "type": "mcq",
          "question": "Consider the following functional component:\n\n```javascript\nimport React, { useState } from 'react';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n```\n\nWhat React Hook is used to manage the internal state `count` in this functional component?",
          "answer": "`useState`",
          "options": [
            "`useEffect`",
            "`useContext`",
            "`useReducer`",
            "`useState`"
          ],
          "analysisPoints": [
            "The question specifically asks about state management.",
            "`useState` is the primary hook for adding state to functional components.",
            "Other hooks (`useEffect`, `useContext`, `useReducer`) serve different purposes related to side effects, context, and complex state logic, respectively."
          ],
          "keyConcepts": [
            "Functional Components",
            "React Hooks",
            "useState",
            "State Management"
          ],
          "evaluationCriteria": [
            "Correct identification of `useState` hook.",
            "Basic understanding of React Hooks functionality."
          ],
          "example": "The `useState` hook returns an array containing the current state value (`count`) and a function to update it (`setCount`). When `setCount` is called, React re-renders the component with the new state value.",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "Functional Components"
          ],
          "prerequisites": [
            "Basic React Hooks"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_class_lifecycle_4",
          "topic": "Class Components",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary method in a Class Component used to render JSX?",
          "answer": "The `render()` method.",
          "analysisPoints": [
            "Recall of Class Component structure.",
            "Understanding the purpose of the `render` method."
          ],
          "keyConcepts": [
            "Class Components",
            "render() method",
            "JSX"
          ],
          "evaluationCriteria": [
            "Accurate recall of Class Component methods."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Class Components",
            "JSX",
            "Flashcard"
          ],
          "prerequisites": [
            "Basic Class Components"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_functional_advantages_5",
          "topic": "Functional Components",
          "level": "hard",
          "type": "code",
          "question": "Refactor the following Class Component into a Functional Component using React Hooks.\n\n```javascript\nimport React from 'react';\n\nclass DataFetcher extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      data: null,\n      loading: true,\n      error: null\n    };\n  }\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  async fetchData() {\n    try {\n      const response = await fetch(this.props.url);\n      const data = await response.json();\n      this.setState({ data, loading: false });\n    } catch (error) {\n      this.setState({ error, loading: false });\n    }\n  }\n\n  render() {\n    const { data, loading, error } = this.state;\n    if (loading) return <p>Loading data...</p>;\n    if (error) return <p>Error: {error.message}</p>;\n    return (\n      <div>\n        <h2>Fetched Data</h2>\n        <pre>{JSON.stringify(data, null, 2)}</pre>\n      </div>\n    );\n  }\n}\n```",
          "answer": "```javascript\nimport React, { useState, useEffect } from 'react';\n\nfunction DataFetcher({ url }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [url]); // Depend on 'url' so data refetches if URL changes\n\n  if (loading) return <p>Loading data...</p>;\n  if (error) return <p>Error: {error.message}</p>;\n\n  return (\n    <div>\n      <h2>Fetched Data</h2>\n      <pre>{JSON.stringify(data, null, 2)}</pre>\n    </div>\n  );\n}\n```",
          "analysisPoints": [
            "Correct use of `useState` for each piece of state (`data`, `loading`, `error`).",
            "Correct use of `useEffect` to replace `componentDidMount` for data fetching.",
            "Proper handling of asynchronous operations (async/await) within `useEffect`.",
            "Correct dependency array (`[url]`) for `useEffect` to manage re-fetching.",
            "Destructuring props directly in the functional component signature.",
            "Removal of `this` keyword and class-specific syntax."
          ],
          "keyConcepts": [
            "Class Components to Functional Components Conversion",
            "useState Hook",
            "useEffect Hook",
            "Asynchronous Operations in React",
            "Data Fetching"
          ],
          "evaluationCriteria": [
            "Accuracy of state conversion.",
            "Correct implementation of `useEffect` for side effects.",
            "Robust error handling and loading state management.",
            "Adherence to functional component best practices."
          ],
          "example": "The `useState` hook is used for `data`, `loading`, and `error` states. The `useEffect` hook simulates `componentDidMount` by running once when the component mounts (or when `url` changes). The `async/await` pattern is used inside `useEffect` to handle the asynchronous nature of `fetch`. Cleanup logic (if any) would be returned from `useEffect`.",
          "tags": [
            "React",
            "Hooks",
            "Code Challenge",
            "Class Components",
            "Functional Components",
            "Data Fetching"
          ],
          "prerequisites": [
            "Advanced React Hooks",
            "JavaScript Async/Await"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_class_functional_flashcard_1",
          "topic": "Class vs Functional Components",
          "level": "easy",
          "type": "flashcard",
          "question": "Do functional components require the `render()` method?",
          "answer": "No, functional components directly return JSX.",
          "analysisPoints": [
            "Recall of syntax differences.",
            "Understanding what functional components return."
          ],
          "keyConcepts": [
            "Functional Components",
            "render() method",
            "JSX"
          ],
          "evaluationCriteria": [
            "Concise and accurate answer about component structure."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Functional Components",
            "JSX",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_stateless_characteristics_1",
          "topic": "Stateless Components",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a characteristic of Stateless (Presentational) Components?",
          "answer": "They manage complex business logic and state.",
          "options": [
            "They accept props and return React elements.",
            "They focus on UI rendering (how things look).",
            "They are generally easier to test and debug.",
            "They manage complex business logic and state."
          ],
          "analysisPoints": [
            "Stateless components are pure functions based on props.",
            "Their main role is presentation, not logic or state management.",
            "Predictability makes them easy to test.",
            "State and complex logic are roles of stateful/container components."
          ],
          "keyConcepts": [
            "Stateless Components",
            "Presentational Components",
            "State Management",
            "Props",
            "Pure Functions"
          ],
          "evaluationCriteria": [
            "Accurate identification of stateless component properties.",
            "Ability to distinguish between stateless and stateful roles."
          ],
          "example": "A stateless `Button` component might receive `onClick` and `label` props and simply render a button. It doesn't know *what* happens when clicked, only *that* it can be clicked.",
          "tags": [
            "React",
            "Components",
            "Stateless Components",
            "Presentational"
          ],
          "prerequisites": [
            "Basic React Components",
            "Props"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_stateful_role_2",
          "topic": "Stateful Components",
          "level": "medium",
          "type": "open",
          "question": "Describe the primary role and characteristics of Stateful (Container) Components in React. How do they typically interact with Stateless (Presentational) Components?",
          "answer": "The primary role of **Stateful (Container) Components** is to manage the application's data, state, and business logic. They are responsible for 'how things work'.\n\n**Characteristics of Stateful Components:**\n-   **Internal State**: They hold and manage their own internal state (e.g., fetched data, form input values, UI flags).\n-   **Business Logic**: They contain the logic for data manipulation, fetching data from APIs, and handling events that change the application state.\n-   **Lifecycle Management**: They often perform side effects like data fetching on component mount or updates.\n-   **Not Always Reusable in Isolation**: Their specific logic and state make them less generic, though they enable reusability of their presentational children.\n\n**Interaction with Stateless Components:**\nStateful components typically act as data providers for stateless components. They fetch or generate data, process it, and then pass this data down to their stateless (presentational) children via `props`. They also pass down callback functions (e.g., event handlers) that stateless children can invoke to trigger state changes or actions in the stateful parent. This separation allows stateless components to remain 'dumb' and focused purely on rendering, while stateful components handle the 'smart' logic, promoting a clear separation of concerns and making both types of components more maintainable and testable within their respective roles.",
          "analysisPoints": [
            "Clear definition of stateful component's role.",
            "Detailed characteristics (state, logic, lifecycle).",
            "Accurate explanation of interaction with stateless components (props for data, callbacks for actions).",
            "Mention of separation of concerns (Container/Presentational pattern)."
          ],
          "keyConcepts": [
            "Stateful Components",
            "Container Components",
            "State Management",
            "Business Logic",
            "Stateless Components",
            "Presentational Components",
            "Props",
            "Separation of Concerns"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of roles and characteristics.",
            "Clear demonstration of the interaction model.",
            "Understanding of the Container/Presentational pattern."
          ],
          "example": "A `UserListContainer` (stateful) might fetch a list of users from an API and manage loading/error states. It then passes the `users` array to a `UserList` (stateless) component, which is only responsible for rendering each user item. If a `UserItem` has a 'delete' button, `UserListContainer` would pass a `onDeleteUser` callback to it.",
          "tags": [
            "React",
            "Components",
            "Stateful Components",
            "Container Components",
            "Presentational Components",
            "Architecture",
            "Interview Question"
          ],
          "prerequisites": [
            "Theory of Stateless Components",
            "Props and State"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_presentational_container_3",
          "topic": "Component Types",
          "level": "hard",
          "type": "code",
          "question": "Implement a simple React application that displays a list of items. Your solution should demonstrate the concept of Stateful (Container) and Stateless (Presentational) components. The container component should manage the list data, and the presentational component should render individual list items.",
          "answer": "```javascript\nimport React, { useState, useEffect } from 'react';\n\n// Stateless/Presentational Component: Renders a single item\nfunction ListItem({ item, onSelect }) {\n  return (\n    <li\n      style={{ cursor: 'pointer', padding: '8px', borderBottom: '1px solid #eee' }}\n      onClick={() => onSelect(item.id)}\n    >\n      {item.name} ({item.category})\n    </li>\n  );\n}\n\n// Stateless/Presentational Component: Renders a list of items\nfunction ItemList({ items, onSelectItem }) {\n  if (!items || items.length === 0) {\n    return <p>No items to display.</p>;\n  }\n\n  return (\n    <ul>\n      {items.map(item => (\n        <ListItem key={item.id} item={item} onSelect={onSelectItem} />\n      ))}\n    </ul>\n  );\n}\n\n// Stateful/Container Component: Manages data fetching and state\nfunction ItemListContainer() {\n  const [items, setItems] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [selectedItemId, setSelectedItemId] = useState(null);\n\n  useEffect(() => {\n    const fetchItems = async () => {\n      try {\n        // Simulate API call\n        const response = await new Promise(resolve =>\n          setTimeout(() =>\n            resolve({\n              ok: true,\n              json: () => Promise.resolve([\n                { id: 1, name: 'Laptop', category: 'Electronics' },\n                { id: 2, name: 'Desk Chair', category: 'Furniture' },\n                { id: 3, name: 'Keyboard', category: 'Electronics' },\n              ]),\n            }),\n          1000\n          )\n        );\n\n        if (!response.ok) {\n          throw new Error('Failed to fetch items');\n        }\n        const data = await response.json();\n        setItems(data);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchItems();\n  }, []);\n\n  const handleSelectItem = (id) => {\n    setSelectedItemId(id);\n    console.log(`Selected Item ID: ${id}`);\n  };\n\n  if (loading) return <p>Loading items...</p>;\n  if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n\n  return (\n    <div>\n      <h1>Available Items</h1>\n      <ItemList items={items} onSelectItem={handleSelectItem} />\n      {selectedItemId && (\n        <p>You selected item with ID: <strong>{selectedItemId}</strong></p>\n      )}\n    </div>\n  );\n}\n\n// App entry point\n// function App() {\n//   return <ItemListContainer />;\n// }\n// export default App;\n```",
          "analysisPoints": [
            "Correctly identifies `ListItem` and `ItemList` as stateless/presentational components that receive data and callbacks via props.",
            "Correctly identifies `ItemListContainer` as a stateful/container component that manages data fetching, loading/error states, and the `selectedItemId`.",
            "Uses `useState` for state management and `useEffect` for data fetching in the container.",
            "Demonstrates passing data (`items`) and callback functions (`onSelectItem`) from container to presentational components.",
            "Clear separation of concerns between data/logic management and UI rendering."
          ],
          "keyConcepts": [
            "Stateful Components",
            "Stateless Components",
            "Container/Presentational Pattern",
            "Props",
            "State",
            "Hooks (useState, useEffect)",
            "Data Fetching"
          ],
          "evaluationCriteria": [
            "Successful implementation of the component pattern.",
            "Correct use of React Hooks for state and side effects.",
            "Clear separation of responsibilities.",
            "Readability and maintainability of code."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Components",
            "Code Challenge",
            "State Management",
            "Architecture"
          ],
          "prerequisites": [
            "React Hooks",
            "Component Props",
            "Basic Data Fetching"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_stateless_performance_4",
          "topic": "Stateless Components",
          "level": "easy",
          "type": "flashcard",
          "question": "Can a Stateless (Presentational) component have internal state?",
          "answer": "No, by definition, stateless components do not manage their own internal state. They rely solely on props for data.",
          "analysisPoints": [
            "Direct recall of stateless component definition.",
            "Understanding of the core principle of statelessness."
          ],
          "keyConcepts": [
            "Stateless Components",
            "State",
            "Props"
          ],
          "evaluationCriteria": [
            "Concise and accurate answer."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Components",
            "Stateless",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_stateless_debug_5",
          "topic": "Stateless Components",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is an advantage of Stateless Components concerning testing and debugging?",
          "answer": "They are easier to test and debug due to predictability and lack of side effects.",
          "options": [
            "They have complex internal logic, making them more robust.",
            "They can manage their own state, simplifying isolated testing.",
            "They are easier to test and debug due to predictability and lack of side effects.",
            "They have extensive lifecycle methods for debugging purposes."
          ],
          "analysisPoints": [
            "Complex logic and state make components harder to test in isolation.",
            "Stateless components by definition lack internal state.",
            "Their output is solely based on props, making them predictable ('pure').",
            "They lack lifecycle methods (or use `useEffect` for *controlled* side effects, not inherent complexity)."
          ],
          "keyConcepts": [
            "Stateless Components",
            "Testing",
            "Debugging",
            "Side Effects",
            "Predictability"
          ],
          "evaluationCriteria": [
            "Understanding of testability implications.",
            "Correctly associating statelessness with simplicity and predictability."
          ],
          "example": "A stateless component that just displays text is easy to test: provide it with a 'text' prop, and assert that it renders that text. There are no external dependencies or internal state changes to worry about.",
          "tags": [
            "React",
            "Components",
            "Stateless Components",
            "Testing",
            "Debugging"
          ],
          "prerequisites": [
            "Theory of Stateless Components"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_props_flashcard_1",
          "topic": "State vs Props",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference between `props` and `state` in React?",
          "answer": "`Props` are immutable and passed from parent to child components, controlling what the component receives from outside. `State` is mutable and managed internally by a component, controlling what the component itself does or changes over time.",
          "analysisPoints": [
            "Distinction between internal (state) and external (props) data.",
            "Mutablility of state vs. immutability of props.",
            "Direction of data flow (props: parent to child; state: component internal)."
          ],
          "keyConcepts": [
            "Props",
            "State",
            "Immutability",
            "Data Flow"
          ],
          "evaluationCriteria": [
            "Clear and concise differentiation.",
            "Accuracy of properties for each concept."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "State",
            "Props",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_stateless_code_1",
          "topic": "Stateless Components",
          "level": "medium",
          "type": "code",
          "question": "Create a stateless functional component named `Greeting` that accepts two props: `name` (string) and `isLoggedIn` (boolean). If `isLoggedIn` is true, it should display 'Welcome back, [name]!'. Otherwise, it should display 'Please log in.'.",
          "answer": "```javascript\nimport React from 'react';\n\nfunction Greeting({ name, isLoggedIn }) {\n  return (\n    <div>\n      {isLoggedIn ? (\n        <h1>Welcome back, {name}!</h1>\n      ) : (\n        <h1>Please log in.</h1>\n      )}\n    </div>\n  );\n}\n\n// Example usage:\n// function App() {\n//   return (\n//     <div>\n//       <Greeting name=\"Alice\" isLoggedIn={true} />\n//       <Greeting name=\"Guest\" isLoggedIn={false} />\n//     </div>\n//   );\n// }\n// export default App;\n```",
          "analysisPoints": [
            "Correctly defines a functional component.",
            "Properly destructures props in the function signature.",
            "Uses conditional rendering based on the `isLoggedIn` prop.",
            "Displays the `name` prop when logged in."
          ],
          "keyConcepts": [
            "Stateless Components",
            "Functional Components",
            "Props",
            "Conditional Rendering",
            "JSX"
          ],
          "evaluationCriteria": [
            "Accurate implementation based on requirements.",
            "Demonstrates understanding of props and stateless nature.",
            "Clean and readable code."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Components",
            "Stateless",
            "Code Challenge",
            "Props"
          ],
          "prerequisites": [
            "Basic React Components",
            "Props"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_optimize_virtual_dom_updates",
          "title": "Simulate and Optimize Virtual DOM Updates",
          "description": "\nImplement a React component that displays a large list of items. The goal is to simulate how Virtual DOM updates work efficiently. Initially, render a list of 10,000 items. Then, implement a mechanism to update only a few specific items in the list and observe how React handles it.\n\n**Requirements:**\n1.  Render a list of 10,000 `ListItem` components, each displaying its index and a random number. Each `ListItem` should have a unique `key`.\n2.  Add a button labeled \"Update Random 10 Items\". When clicked, this button should randomly select 10 items from the list and change their random number.\n3.  Ensure that only the 10 updated `ListItem` components re-render, demonstrating the efficiency of React's Virtual DOM reconciliation.\n\n**Hint**: You can add a `console.log` inside the `ListItem` component's render output or use React Developer Tools to verify which components re-render.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useCallback, memo } from 'react';\n\n// Stateless/Presentational Component for a list item\nconst ListItem = memo(({ index, value }) => {\n  console.log(`Rendering ListItem ${index}`); // For observation\n  return (\n    <div style={{ padding: '2px 0' }}>\n      Item {index}: {value}\n    </div>\n  );\n});\n\nfunction LargeListApp() {\n  const initialItems = Array.from({ length: 10000 }, (_, i) => ({\n    id: i,\n    value: Math.floor(Math.random() * 1000)\n  }));\n\n  const [items, setItems] = useState(initialItems);\n\n  const updateRandomItems = useCallback(() => {\n    // TODO: Implement logic to update 10 random items.\n    // Make sure to create a NEW array for React to detect changes.\n    // Example of updating one item:\n    // const newItems = [...items];\n    // newItems[0] = { ...newItems[0], value: Math.floor(Math.random() * 1000) };\n    // setItems(newItems);\n\n  }, [items]);\n\n  return (\n    <div>\n      <h1>Large List Reconciliation Demo</h1>\n      <button onClick={updateRandomItems}>Update Random 10 Items</button>\n      <div style={{ height: '400px', overflowY: 'scroll', border: '1px solid #ccc' }}>\n        {items.map(item => (\n          <ListItem key={item.id} index={item.id} value={item.value} />\n        ))}\n      </div>\n    </div>\n  );\n}\n\n// export default LargeListApp;\n",
          "solutionCode": "import React, { useState, useCallback, memo } from 'react';\n\nconst ListItem = memo(({ index, value }) => {\n  console.log(`Rendering ListItem ${index}`);\n  return (\n    <div style={{ padding: '2px 0' }}>\n      Item {index}: {value}\n    </div>\n  );\n});\n\nfunction LargeListApp() {\n  const initialItems = Array.from({ length: 10000 }, (_, i) => ({\n    id: i,\n    value: Math.floor(Math.random() * 1000)\n  }));\n\n  const [items, setItems] = useState(initialItems);\n\n  const updateRandomItems = useCallback(() => {\n    const itemsToUpdate = new Set();\n    while (itemsToUpdate.size < 10) {\n      itemsToUpdate.add(Math.floor(Math.random() * items.length));\n    }\n\n    const newItems = items.map((item, index) => {\n      if (itemsToUpdate.has(index)) {\n        return { ...item, value: Math.floor(Math.random() * 1000) };\n      }\n      return item;\n    });\n    setItems(newItems);\n  }, [items]);\n\n  return (\n    <div>\n      <h1>Large List Reconciliation Demo</h1>\n      <button onClick={updateRandomItems}>Update Random 10 Items</button>\n      <div style={{ height: '400px', overflowY: 'scroll', border: '1px solid #ccc' }}>\n        {items.map(item => (\n          <ListItem key={item.id} index={item.id} value={item.value} />\n        ))}\n      </div>\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: Verify 10,000 'Rendering ListItem' logs on first load.",
            "Update: Click 'Update Random 10 Items' button. Observe that only approximately 10 'Rendering ListItem' logs appear in the console, not 10,000.",
            "Data Change: Verify that the numbers for the updated items indeed change on screen."
          ],
          "hints": [
            "Remember to use `memo` for your `ListItem` component to prevent unnecessary re-renders of unchanged items. This helps observe the Virtual DOM's efficiency.",
            "When updating state for an array or object, always create a *new* array/object (e.g., using `map` or spread operator) instead of mutating the existing one. React relies on reference equality to detect changes.",
            "To select random unique indices, consider using a `Set`."
          ],
          "tags": [
            "React",
            "Virtual DOM",
            "Performance",
            "Optimization",
            "useState",
            "useCallback",
            "memo"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React State Management",
            "Functional Components",
            "React Hooks (`useState`, `useCallback`, `memo`)",
            "Basic JavaScript Array Methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Reconciliation",
            "Component Re-rendering",
            "Pure Components"
          ]
        },
        {
          "id": "task_component_conversion",
          "title": "Convert Class Component to Functional Component with Hooks",
          "description": "\nConvert the provided React Class Component into an equivalent Functional Component using React Hooks.\n\n**Class Component to Convert:**\n```javascript\nimport React from 'react';\n\nclass Timer extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  componentDidMount() {\n    this.timerId = setInterval(() => {\n      this.setState(prevState => ({ count: prevState.count + 1 }));\n    }, 1000);\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerId);\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>Class Timer: {this.state.count}</h2>\n        <p>Timer updates every second.</p>\n      </div>\n    );\n  }\n}\n```\n\n**Requirements:**\n1.  The functional component should have the same behavior: a counter that increments every second.\n2.  Use `useState` for managing the counter's state.\n3.  Use `useEffect` for setting up and tearing down the `setInterval`.\n4.  Ensure proper cleanup of the interval when the component unmounts.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// TODO: Convert the Class Timer component below to a Functional Component\n// class Timer extends React.Component {\n//   constructor(props) {\n//     super(props);\n//     this.state = { count: 0 };\n//   }\n//\n//   componentDidMount() {\n//     this.timerId = setInterval(() => {\n//       this.setState(prevState => ({ count: prevState.count + 1 }));\n//     }, 1000);\n//   }\n//\n//   componentWillUnmount() {\n//     clearInterval(this.timerId);\n//   }\n//\n//   render() {\n//     return (\n//       <div>\n//         <h2>Class Timer: {this.state.count}</h2>\n//         <p>Timer updates every second.</p>\n//       </div>\n//     );\n//   }\n// }\n\nfunction FunctionalTimer() {\n  // Implement state and effects here\n  \n  return (\n    <div>\n      <h2>Functional Timer: { /* Your state variable here */ }</h2>\n      <p>Timer updates every second.</p>\n    </div>\n  );\n}\n\n// export default FunctionalTimer;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction FunctionalTimer() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const timerId = setInterval(() => {\n      setCount(prevCount => prevCount + 1);\n    }, 1000);\n\n    // Cleanup function: runs when the component unmounts\n    return () => {\n      clearInterval(timerId);\n    };\n  }, []); // Empty dependency array means this effect runs once on mount and cleans up on unmount\n\n  return (\n    <div>\n      <h2>Functional Timer: {count}</h2>\n      <p>Timer updates every second.</p>\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial Render: The timer should start displaying '0' (or initial value).",
            "Increment: The count should increase by 1 every second.",
            "Unmount (simulated by navigating away/conditional rendering): The console logs should indicate that the interval is cleared, preventing memory leaks (e.g., if you temporarily render the component and then remove it)."
          ],
          "hints": [
            "The `useState` hook returns a state variable and a setter function.",
            "The `useEffect` hook takes a callback function and an optional dependency array.",
            "To mimic `componentDidMount` and `componentWillUnmount`, use `useEffect` with an empty dependency array (`[]`) and return a cleanup function from the `useEffect` callback."
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "useEffect",
            "Class Components",
            "Functional Components",
            "Conversion",
            "Side Effects",
            "Cleanup"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Class Components",
            "React Hooks (`useState`, `useEffect`)",
            "JavaScript `setInterval`"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component Lifecycle",
            "State Management",
            "Side Effects in React"
          ]
        },
        {
          "id": "task_stateful_vs_stateless_counter",
          "title": "Build a Counter App: Stateful Parent, Stateless Child",
          "description": "\nCreate a React counter application that clearly separates concerns between a stateful (container) parent component and a stateless (presentational) child component.\n\n**Requirements:**\n1.  **Container Component (`CounterContainer`):**\n    *   Should manage the `count` state using `useState`.\n    *   Should contain functions to `increment` and `decrement` the count.\n    *   Should render the `CounterDisplay` component, passing the current `count` and the `increment`/`decrement` functions as props.\n2.  **Presentational Component (`CounterDisplay`):**\n    *   Should be a functional component.\n    *   Should receive `count`, `onIncrement`, and `onDecrement` as props.\n    *   Should display the current `count`.\n    *   Should have two buttons: 'Increment' and 'Decrement', which call the respective `onIncrement` and `onDecrement` props when clicked.\n    *   Should NOT manage any internal state.\n\nThis task demonstrates the 'Container/Presentational' pattern.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// TODO: Implement the CounterDisplay (stateless) component\nfunction CounterDisplay() {\n  // Props: count, onIncrement, onDecrement\n  return (\n    <div>\n      {/* Display count and buttons */}\n    </div>\n  );\n}\n\n// TODO: Implement the CounterContainer (stateful) component\nfunction CounterContainer() {\n  // Manage count state and logic here\n  // Render CounterDisplay\n  \n  return (\n    <div>\n      <h1>Counter App</h1>\n      {/* Render CounterDisplay here */}\n    </div>\n  );\n}\n\n// export default CounterContainer;\n",
          "solutionCode": "import React, { useState } from 'react';\n\n// Presentational Component: CounterDisplay\nfunction CounterDisplay({ count, onIncrement, onDecrement }) {\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '15px', borderRadius: '5px' }}>\n      <p style={{ fontSize: '2em', margin: '0 0 10px 0' }}>Count: {count}</p>\n      <button onClick={onIncrement} style={{ margin: '5px', padding: '10px 15px' }}>Increment</button>\n      <button onClick={onDecrement} style={{ margin: '5px', padding: '10px 15px' }}>Decrement</button>\n    </div>\n  );\n}\n\n// Container Component: CounterContainer\nfunction CounterContainer() {\n  const [count, setCount] = useState(0);\n\n  const handleIncrement = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  const handleDecrement = () => {\n    setCount(prevCount => prevCount - 1);\n  };\n\n  return (\n    <div>\n      <h1>Simple Counter Application</h1>\n      <CounterDisplay \n        count={count} \n        onIncrement={handleIncrement} \n        onDecrement={handleDecrement} \n      />\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial State: The counter should start at 0.",
            "Increment Functionality: Clicking 'Increment' should increase the count by 1.",
            "Decrement Functionality: Clicking 'Decrement' should decrease the count by 1.",
            "State Separation: Verify that `CounterDisplay` does not use `useState` and only relies on props."
          ],
          "hints": [
            "Remember that stateless components receive all their data and functions via `props`.",
            "The `useState` hook is crucial for adding state to your functional container component.",
            "When updating state based on the previous state (like incrementing a count), it's best practice to use the functional update form of `setCount` (`setCount(prevCount => prevCount + 1)`)."
          ],
          "tags": [
            "React",
            "Stateful Components",
            "Stateless Components",
            "Container Components",
            "Presentational Components",
            "Props",
            "useState",
            "Component Architecture"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Functional Components",
            "useState Hook",
            "Props"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component Composition",
            "Data Flow",
            "Separation of Concerns"
          ]
        }
      ]
    }
  },
  {
    "id": "fa1da733-f612-4535-bd59-00038b677ddd",
    "startLine": 2900,
    "endLine": 2999,
    "processedDate": "2025-06-17T08:35:17.335Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_presentational_components",
          "title": "Presentational Components (UI Components)",
          "content": "Presentational components, also known as UI components, are primarily concerned with how things look. They are typically pure functional components and are designed to be reusable and independent of the rest of the application's business logic or state management.\n\n## Key Characteristics:\n-   **Focus:** Primarily on presentation and UI rendering.\n-   **Independence:** Have no dependencies on the rest of the application's state or data fetching logic.\n-   **Data Flow:** Receive all data and callback functions exclusively via props.\n-   **State Management:** Do not manage their own state (unless it's purely UI-related state, like a toggle for a dropdown menu, but even then, it's often better managed by a container component or passed via props).\n-   **Composition:** Can contain other presentational components.\n-   **Reusability:** Highly reusable across different parts of an application or even different projects.\n\nThey are essential for building a consistent and modular user interface, making it easier to develop, test, and maintain UI elements.",
          "examples": [
            {
              "id": "example_presentational_button",
              "title": "Basic Presentational Button Component",
              "code": "const Button = ({ onClick, text, isDisabled = false }) => (\n  <button onClick={onClick} disabled={isDisabled}>\n    {text}\n  </button>\n);\n\n// Usage example:\n// <Button onClick={() => alert('Clicked!')} text=\"Click Me\" />\n// <Button onClick={() => console.log('Disabled')} text=\"Disabled Button\" isDisabled={true} />",
              "explanation": "This `Button` component is a classic example of a presentational component. It receives its text, click handler, and disabled state entirely through props. It has no internal state, no data fetching logic, and focuses solely on rendering a button based on the provided properties.",
              "language": "typescript"
            },
            {
              "id": "example_presentational_card",
              "title": "Presentational Hobby Card Component",
              "code": "import React from 'react';\n\ninterface HobbyCardProps {\n  title: string;\n  hobbies: string[];\n}\n\nfunction HobbyCard({ title, hobbies }: HobbyCardProps) {\n  return (\n    <div>\n      <h2>{title}</h2>\n      <ul>\n        {hobbies.map(hobby => <li key={hobby}>{hobby}</li>)}\n      </ul>\n    </div>\n  );\n}",
              "explanation": "This `HobbyCard` component renders a title and a list of hobbies. All the data it needs (`title` and `hobbies` array) is passed down via props. It doesn't fetch hobbies itself or manage any complex state, making it purely presentational and highly reusable for displaying different sets of hobbies.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Components",
            "Presentational",
            "UI",
            "Functional Components",
            "Props"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "javascript_es6_destructuring"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "container_components",
            "component_architecture"
          ]
        },
        {
          "id": "theory_container_components",
          "title": "Container Components (Stateful/Data Components)",
          "content": "Container components, also known as stateful or data components, are concerned with how things work. They manage and maintain their own state, handle data fetching, subscribe to external events, and often contain both presentational and other container components. They act as a bridge between the data layer and the UI layer, providing data and behavior to their child components.\n\n## Key Characteristics:\n-   **Focus:** Primarily on data, logic, and state management.\n-   **Data Management:** Responsible for fetching data, managing application state, and handling user interactions that modify state.\n-   **Data Provision:** Pass data and callback functions down to presentational (and sometimes other container) components via props.\n-   **Composition:** Can wrap multiple presentational components or other container components.\n-   **Implementation:** Can be implemented as class-based components (using `state` and lifecycle methods like `componentDidMount`) or functional components with Hooks (using `useState`, `useEffect`, `useContext`, etc.).\n-   **Separation of Concerns:** By separating concerns, presentational components remain 'dumb' and reusable, while container components handle the 'smart' logic.",
          "examples": [
            {
              "id": "example_container_dashboard_hooks",
              "title": "Stateful Component using Hooks (User Dashboard)",
              "code": "import React, { useState, useEffect } from 'react';\n\n// Assuming UserList is a presentational component\n// const UserList = ({ users }) => (\n//   <ul>\n//     {users.map(user => <li key={user.id}>{user.name}</li>)}\n//   </ul>\n// );\n\nfunction UserDashboard() {\n  const [users, setUsers] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    setIsLoading(true);\n    fetch('/api/users')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then(data => {\n        setUsers(data);\n        setIsLoading(false);\n      })\n      .catch(err => {\n        setError(err.message);\n        setIsLoading(false);\n      });\n  }, []); // Empty dependency array means this effect runs once after the initial render\n  \n  if (isLoading) return <p>Loading users...</p>;\n  if (error) return <p style={{ color: 'red' }}>Error: {error}</p>;\n  \n  return (\n    <div>\n      <h1>User Dashboard</h1>\n      {/* UserList would be a presentational component */}\n      {/* <UserList users={users} /> */}\n      {users.length > 0 ? (\n        <ul>\n          {users.map(user => <li key={user.id}>{user.name}</li>)}\n        </ul>\n      ) : (\n        <p>No users found.</p>\n      )}\n    </div>\n  );\n}",
              "explanation": "This `UserDashboard` component demonstrates a container component using React Hooks. It manages the `users`, `isLoading`, and `error` states. The `useEffect` hook handles the data fetching logic when the component mounts. Based on the state, it renders different UI elements (loading, error, or the user list). It passes the fetched `users` data down to a hypothetical `UserList` (or renders them directly here for simplicity), which would be a presentational component.",
              "language": "typescript"
            },
            {
              "id": "example_container_list_class",
              "title": "Container Component using Class (UserListContainer)",
              "code": "import React from 'react';\n\n// Assuming UserList is a presentational component, e.g.:\n// const UserList = ({ users }) => (\n//   <ul>\n//     {users.map(user => <li key={user.id}>{user.name}</li>)}\n//   </ul>\n// );\n\nclass UserListContainer extends React.Component {\n  state = { users: [] };\n  \n  componentDidMount() {\n    // Simulate API call\n    fetch('/api/users')\n      .then(res => {\n        if (!res.ok) {\n          throw new Error(`HTTP error! status: ${res.status}`);\n        }\n        return res.json();\n      })\n      .then(users => this.setState({ users }))\n      .catch(error => console.error('Error fetching users:', error));\n  }\n  \n  render() {\n    // Here, UserList would be a presentational component\n    return (\n      <div>\n        <h2>Users from Container (Class-based)</h2>\n        {this.state.users.length > 0 ? (\n          <ul>\n            {this.state.users.map(user => <li key={user.id}>{user.name}</li>)}\n          </ul>\n        ) : (\n          <p>Loading users or no users available...</p>\n        )}\n        {/* <UserList users={this.state.users} /> */}\n      </div>\n    );\n  }\n}",
              "explanation": "This `UserListContainer` is a class-based container component. It initializes an empty `users` array in its `state`. The `componentDidMount` lifecycle method is used to fetch user data after the component has been inserted into the DOM. Once the data is fetched, the component's state is updated, which triggers a re-render. It would then typically pass this `users` data to a presentational `UserList` component for rendering.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Components",
            "Container",
            "Stateful",
            "Hooks",
            "Class Components",
            "Data Fetching",
            "State Management"
          ],
          "technology": "React",
          "prerequisites": [
            "react_state",
            "react_lifecycle_methods",
            "react_hooks_usestate",
            "react_hooks_useeffect",
            "javascript_promises_fetch_api"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "component_architecture",
            "redux_integration",
            "context_api"
          ]
        },
        {
          "id": "theory_hoc",
          "title": "Higher-Order Components (HOCs)",
          "content": "Higher-Order Components (HOCs) are an advanced technique in React for reusing component logic. A HOC is a function that takes a component as an argument and returns a new component with enhanced capabilities or modified props. They are a pattern derived from higher-order functions in functional programming.\n\n## Key Characteristics:\n-   **Function as an Enhancer:** A HOC is not a component itself but a function that wraps a component.\n-   **Input/Output:** It takes a 'WrappedComponent' (a React component) as an input and returns a new React component.\n-   **Logic Reusability:** HOCs are used to abstract away common logic, such as data fetching, state management, authentication checks, or prop manipulation, that can be applied to multiple components.\n-   **Props Proxy:** The most common HOC pattern, where the HOC renders the wrapped component and passes props to it. It can add, remove, or modify props.\n-   **Inheritance Inversion:** Less common, where the HOC extends the `WrappedComponent` and gains access to its state and props, allowing for more control over the wrapped component's rendering.\n-   **Alternatives:** While powerful, HOCs can sometimes lead to wrapper hell or unclear prop origins. Hooks are often preferred in modern React for sharing stateful logic.\n\n## When to use HOCs:\n-   Sharing non-visual logic between multiple components.\n-   Authentication/Authorization logic.\n-   Conditional rendering based on external data.\n-   Performance optimizations (e.g., `shouldComponentUpdate`).",
          "examples": [
            {
              "id": "example_hoc_withuser",
              "title": "Basic HOC: withUser",
              "code": "import React from 'react';\n\n// Simulate a data fetching function\nconst fetchUser = () => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({ id: 1, name: 'John Doe', email: 'john.doe@example.com' });\n    }, 1000);\n  });\n};\n\nconst withUser = (WrappedComponent) => {\n  return class WithUser extends React.Component {\n    state = { user: null, isLoading: true, error: null };\n    \n    componentDidMount() {\n      this.setState({ isLoading: true });\n      fetchUser()\n        .then(user => this.setState({ user, isLoading: false }))\n        .catch(error => this.setState({ error: error.message, isLoading: false }));\n    }\n    \n    render() {\n      if (this.state.isLoading) {\n        return <p>Loading user data...</p>;\n      }\n      if (this.state.error) {\n        return <p>Error: {this.state.error}</p>;\n      }\n      // Pass the fetched user data and any other original props to the WrappedComponent\n      return <WrappedComponent user={this.state.user} {...this.props} />;\n    }\n  };\n};\n\n// Example of a component that needs user data\nconst UserProfile = ({ user, greeting }) => (\n  <div>\n    <h3>{greeting || 'Welcome'}, {user ? user.name : 'Guest'}</h3>\n    {user && <p>Email: {user.email}</p>}\n  </div>\n);\n\n// Enhance UserProfile with user data\nconst EnhancedUserProfile = withUser(UserProfile);\n\n// Usage in a parent component:\n// <EnhancedUserProfile greeting=\"Hello\" />",
              "explanation": "The `withUser` HOC fetches user data and passes it as a `user` prop to the `WrappedComponent`. It also handles loading and error states. `UserProfile` is a simple presentational component that expects a `user` prop. By wrapping `UserProfile` with `withUser`, `EnhancedUserProfile` automatically receives the user data without `UserProfile` needing to know about the fetching logic. This demonstrates how HOCs can inject props and manage shared logic.",
              "language": "typescript"
            },
            {
              "id": "example_hoc_withlogging",
              "title": "HOC for Logging Props",
              "code": "import React from 'react';\n\nconst withLogger = (WrappedComponent) => {\n  return class WithLogger extends React.Component {\n    componentDidMount() {\n      console.log(`Component ${WrappedComponent.displayName || WrappedComponent.name} mounted with props:`, this.props);\n    }\n\n    componentDidUpdate(prevProps) {\n      console.log(`Component ${WrappedComponent.displayName || WrappedComponent.name} updated. Old props:`, prevProps, 'New props:', this.props);\n    }\n\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  };\n};\n\n// Example component\nconst MyButton = ({ label, onClick }) => <button onClick={onClick}>{label}</button>;\nMyButton.displayName = 'MyButton'; // Useful for HOCs\n\nconst LoggedButton = withLogger(MyButton);\n\n// Usage:\n// <LoggedButton label=\"Click Me\" onClick={() => console.log('Button clicked!')} />",
              "explanation": "The `withLogger` HOC adds logging capabilities to any wrapped component. It logs the props when the component mounts and when it updates. This is a simple example of how HOCs can inject cross-cutting concerns like logging or analytics without modifying the original component's code. It's an example of the 'Props Proxy' pattern where the HOC just passes all props through to the wrapped component while adding additional behavior.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "HOC",
            "Higher-Order Components",
            "Pattern",
            "Code Reusability",
            "Component Enhancement"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "react_props",
            "react_lifecycle_methods",
            "javascript_functions_as_first_class_citizens"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "custom_hooks",
            "component_design_patterns"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_presentational_vs_container_mcq_1",
          "topic": "Presentational vs. Container Components",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following best describes a Presentational Component?",
          "answer": "Focuses on how things look and receives data exclusively via props.",
          "options": [
            "Manages its own state and fetches data from APIs.",
            "Focuses on how things look and receives data exclusively via props.",
            "A function that takes a component and returns a new component.",
            "Responsible for routing and global state management."
          ],
          "analysisPoints": [
            "Tests understanding of the core definition of presentational components.",
            "Distinguishes between UI-focused (presentational) and logic-focused (container) components.",
            "Emphasizes the prop-based data flow for presentational components."
          ],
          "keyConcepts": [
            "Presentational Components",
            "Props",
            "Separation of Concerns",
            "UI Components"
          ],
          "evaluationCriteria": [
            "Ability to recall fundamental characteristics.",
            "Distinguishing between component types."
          ],
          "example": "The correct option highlights the primary role of presentational components: rendering UI based on props, without managing internal state or data logic.",
          "tags": [
            "Presentational Components",
            "UI",
            "Props",
            "Basic"
          ],
          "prerequisites": [
            "react_functional_components"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_container_vs_presentational_mcq_2",
          "topic": "Presentational vs. Container Components",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React component:\n\n```typescript\nimport React, { useState, useEffect } from 'react';\n\ninterface UserListProps {\n  users: { id: number; name: string; }[];\n}\n\nconst UserList: React.FC<UserListProps> = ({ users }) => {\n  return (\n    <div>\n      <h2>User List</h2>\n      <ul>\n        {users.map(user => <li key={user.id}>{user.name}</li>)}\n      </ul>\n    </div>\n  );\n};\n\nfunction UserDashboard() {\n  const [users, setUsers] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  \n  useEffect(() => {\n    setIsLoading(true);\n    fetch('/api/users')\n      .then(response => response.json())\n      .then(data => {\n        setUsers(data);\n        setIsLoading(false);\n      });\n  }, []);\n  \n  if (isLoading) return <p>Loading users...</p>;\n  \n  return <UserList users={users} />;\n}\n```\n\nWhich statement correctly identifies the types of `UserList` and `UserDashboard` components?",
          "answer": "`UserList` is presentational, and `UserDashboard` is container.",
          "options": [
            "`UserList` is container, and `UserDashboard` is presentational.",
            "Both `UserList` and `UserDashboard` are presentational.",
            "`UserList` is presentational, and `UserDashboard` is container.",
            "Both `UserList` and `UserDashboard` are container."
          ],
          "analysisPoints": [
            "Tests the ability to differentiate component types based on their code implementation.",
            "`UserList` receives data via props and focuses on rendering, indicating it's presentational.",
            "`UserDashboard` manages state (`useState`), performs data fetching (`useEffect`), and passes data, indicating it's a container.",
            "Reinforces the concept of separation of concerns in component design."
          ],
          "keyConcepts": [
            "Presentational Components",
            "Container Components",
            "React Hooks (useState, useEffect)",
            "Props",
            "Data Fetching"
          ],
          "evaluationCriteria": [
            "Code analysis skills.",
            "Accurate classification of component roles."
          ],
          "example": "The `UserList` component only takes `users` as a prop and renders them, fulfilling the criteria of a presentational component. The `UserDashboard` component, on the other hand, manages its own state (`users`, `isLoading`) and handles data fetching, fitting the definition of a container component. It then passes the fetched data to `UserList`.",
          "tags": [
            "Presentational Components",
            "Container Components",
            "React Hooks",
            "Code Analysis"
          ],
          "prerequisites": [
            "react_functional_components",
            "react_hooks_usestate",
            "react_hooks_useeffect"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_definition_flashcard_1",
          "topic": "Higher-Order Components (HOCs)",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a Higher-Order Component (HOC) in React?",
          "answer": "A function that takes a component as an argument and returns a new component with enhanced capabilities.",
          "analysisPoints": [
            "Focuses on the functional nature of HOCs.",
            "Highlights the core purpose: component enhancement."
          ],
          "keyConcepts": [
            "HOC",
            "Function",
            "Component Enhancement"
          ],
          "evaluationCriteria": [
            "Ability to recall core definitions."
          ],
          "example": "HOCs are not components themselves, but functions that operate on components to create new, more powerful components. Think of it like a decorator pattern for React components.",
          "tags": [
            "HOC",
            "Definition",
            "React Patterns"
          ],
          "prerequisites": [
            "react_components",
            "javascript_functions"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_hoc_use_cases_open_1",
          "topic": "Higher-Order Components (HOCs)",
          "level": "medium",
          "type": "open",
          "question": "Describe scenarios where using a Higher-Order Component (HOC) would be an appropriate design choice in a React application. Provide at least two distinct use cases.",
          "answer": "HOCs are suitable for sharing common logic across multiple components without repeating code. Two distinct use cases are:\n\n1.  **Authentication/Authorization:** An `withAuth` HOC could check if a user is logged in or has specific permissions. If not, it could redirect or display a fallback UI, otherwise, it renders the wrapped component, possibly injecting user data as props.\n    Example: `const AuthenticatedDashboard = withAuth(Dashboard);`\n\n2.  **Data Fetching/Injection:** An `withData` HOC could encapsulate logic for fetching data from an API and then pass that data as props to the wrapped component. This allows presentational components to remain unaware of how data is sourced.\n    Example: `const UserProfileWithData = withUser(UserProfile);` (as seen in the theory example)\n\nOther use cases include logging, analytics tracking, performance optimizations (e.g., debouncing inputs), or prop manipulation.",
          "analysisPoints": [
            "Tests understanding of HOC's practical applications beyond just definition.",
            "Evaluates the ability to identify cross-cutting concerns that HOCs can address.",
            "Encourages thinking about code reusability and separation of concerns."
          ],
          "keyConcepts": [
            "HOC",
            "Code Reusability",
            "Authentication",
            "Data Fetching",
            "Cross-cutting Concerns"
          ],
          "evaluationCriteria": [
            "Relevance of use cases.",
            "Clarity and completeness of explanation.",
            "Demonstration of practical application knowledge."
          ],
          "example": null,
          "tags": [
            "HOC",
            "Use Cases",
            "React Architecture",
            "Design Patterns"
          ],
          "prerequisites": [
            "theory_hoc"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_container_component_state_management_flashcard_3",
          "topic": "Container Components",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary responsibility of a Container Component regarding data?",
          "answer": "To manage and maintain its own state, fetch data, and provide data to child components.",
          "analysisPoints": [
            "Reinforces the 'data' aspect of container components.",
            "Emphasizes active management roles like fetching and providing."
          ],
          "keyConcepts": [
            "Container Components",
            "State Management",
            "Data Fetching",
            "Data Provision"
          ],
          "evaluationCriteria": [
            "Quick recall of core responsibility."
          ],
          "example": null,
          "tags": [
            "Container Components",
            "State",
            "Data",
            "Flashcard"
          ],
          "prerequisites": [
            "theory_container_components"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_hoc_disadvantages_open_2",
          "topic": "Higher-Order Components (HOCs)",
          "level": "hard",
          "type": "open",
          "question": "While Higher-Order Components (HOCs) offer a powerful way to reuse logic, they also come with certain disadvantages or complexities. Discuss at least two potential drawbacks of using HOCs and how modern React patterns (like Hooks) often address these.",
          "answer": "Two potential drawbacks of HOCs are:\n\n1.  **Wrapper Hell / Indirection:** When multiple HOCs are applied to a single component, it can lead to deeply nested component trees in React DevTools, making debugging and understanding the component hierarchy more difficult. The original component might be wrapped several times, leading to a 'wrapper hell' where it's hard to trace which HOC is providing which prop or behavior.\n2.  **Prop Name Collisions:** If multiple HOCs inject props with the same name, they can overwrite each other, leading to unexpected behavior. This requires careful naming conventions or prop remapping within HOCs, which adds complexity.\n\n**How Hooks Address These:**\nReact Hooks (e.g., `useState`, `useEffect`, `useContext`, and custom hooks) provide a way to reuse stateful logic without changing your component hierarchy. Instead of wrapping components, you directly use logic inside functional components:\n\n-   **No Wrapper Hell:** Hooks are functions that you call inside your component, they don't introduce new layers of components in the tree, making debugging simpler and the component hierarchy flatter.\n-   **No Prop Collisions (Directly):** When using custom hooks, you explicitly name the variables and functions returned by the hook, preventing automatic prop name collisions. For instance, two custom hooks can both manage a `loading` state, but you would destructure them as `const { loading: userLoading } = useUser();` and `const { loading: postLoading } = usePosts();`, avoiding conflicts.",
          "analysisPoints": [
            "Tests critical thinking about design patterns and their trade-offs.",
            "Requires knowledge of both HOCs and Hooks.",
            "Evaluates understanding of React's evolution and best practices.",
            "Assesses the ability to compare and contrast different architectural approaches."
          ],
          "keyConcepts": [
            "HOC",
            "React Hooks",
            "Wrapper Hell",
            "Prop Collisions",
            "Code Reusability",
            "Component Architecture"
          ],
          "evaluationCriteria": [
            "Depth of understanding of HOC limitations.",
            "Accuracy of comparison with Hooks.",
            "Clarity and structure of the explanation."
          ],
          "example": null,
          "tags": [
            "HOC",
            "Hooks",
            "React Architecture",
            "Advanced",
            "Trade-offs"
          ],
          "prerequisites": [
            "theory_hoc",
            "react_hooks_custom_hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_coding_1",
          "topic": "Higher-Order Components (HOCs)",
          "level": "medium",
          "type": "code",
          "question": "Write a Higher-Order Component (HOC) called `withToggle` that injects a `toggled` boolean state and a `toggle` function into a wrapped component. The `toggled` state should default to `false` and `toggle` should flip its value.\n\nThen, use this HOC to create a `TogglableText` component that displays 'Content is hidden' when `toggled` is `false` and 'Content is visible!' when `toggled` is `true`. The `TogglableText` component should also render a button that calls the `toggle` function.",
          "answer": "```typescript\nimport React from 'react';\n\n// HOC Definition\nconst withToggle = (WrappedComponent) => {\n  return class WithToggle extends React.Component {\n    state = {\n      toggled: false,\n    };\n\n    toggle = () => {\n      this.setState(prevState => ({\n        toggled: !prevState.toggled,\n      }));\n    };\n\n    render() {\n      return (\n        <WrappedComponent \n          toggled={this.state.toggled} \n          toggle={this.toggle} \n          {...this.props} \n        />\n      );\n    }\n  };\n};\n\n// Component to be wrapped\ninterface TogglableTextProps {\n  toggled: boolean;\n  toggle: () => void;\n}\n\nconst TogglableText: React.FC<TogglableTextProps> = ({ toggled, toggle }) => {\n  return (\n    <div>\n      <p>{toggled ? 'Content is visible!' : 'Content is hidden'}</p>\n      <button onClick={toggle}>Toggle Content</button>\n    </div>\n  );\n};\n\n// Applying the HOC\nconst EnhancedTogglableText = withToggle(TogglableText);\n\n// Example Usage (in a parent component):\n// function App() {\n//   return (\n//     <div>\n//       <h1>HOC Example</h1>\n//       <EnhancedTogglableText />\n//     </div>\n//   );\n// }\n// export default App;\n```",
          "analysisPoints": [
            "Tests the ability to implement a functional HOC.",
            "Checks understanding of how HOCs inject state and functions via props.",
            "Evaluates component composition using HOCs.",
            "Demonstrates state management within a HOC context."
          ],
          "keyConcepts": [
            "HOC",
            "State Management",
            "Props Injection",
            "Component Composition",
            "Class Components"
          ],
          "evaluationCriteria": [
            "Correct implementation of HOC pattern.",
            "Proper state management within the HOC.",
            "Successful integration of the HOC with a presentational component.",
            "Code cleanliness and readability."
          ],
          "example": null,
          "tags": [
            "HOC",
            "Coding",
            "State",
            "Intermediate",
            "React Patterns"
          ],
          "prerequisites": [
            "theory_hoc",
            "react_class_components_state"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_when_to_use_container_open_1",
          "topic": "Container Components",
          "level": "medium",
          "type": "open",
          "question": "Explain when it is appropriate to create a Container Component instead of a Presentational Component. Provide a concrete example.",
          "answer": "It is appropriate to create a Container Component when a component needs to handle data logic, manage application state, or interact with external services (like APIs or global state stores), rather than just focusing on UI rendering.\n\n**Example:**\nConsider an application that displays a list of products. A `ProductList` component whose sole responsibility is to render the `products` array passed to it would be a **Presentational Component**. It only cares about *how* the list looks.\n\nHowever, a `ProductListContainer` component would be responsible for:\n1.  Fetching the product data from an API.\n2.  Managing loading and error states during the fetch.\n3.  Potentially filtering or sorting the products.\n4.  Passing the processed `products` data (and perhaps an `isLoading` prop) down to the `ProductList` presentational component. \n\nThis separation allows `ProductList` to remain simple and reusable, while `ProductListContainer` encapsulates the complex data logic.",
          "analysisPoints": [
            "Tests understanding of the 'why' behind container components.",
            "Requires the ability to differentiate responsibilities.",
            "Asks for a practical, illustrative example.",
            "Highlights the separation of concerns principle."
          ],
          "keyConcepts": [
            "Container Components",
            "Presentational Components",
            "Separation of Concerns",
            "Data Fetching",
            "State Management"
          ],
          "evaluationCriteria": [
            "Clarity of explanation.",
            "Relevance and accuracy of the example.",
            "Demonstration of architectural thinking."
          ],
          "example": null,
          "tags": [
            "Container Components",
            "Presentational Components",
            "Architecture",
            "Design"
          ],
          "prerequisites": [
            "theory_container_components",
            "theory_presentational_components"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_vs_hooks_flashcard_4",
          "topic": "HOCs vs. Hooks",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary advantage of Custom Hooks over HOCs for sharing stateful logic in modern React?",
          "answer": "Custom Hooks avoid 'wrapper hell' and allow direct access to React features within functional components without introducing extra layers in the component tree, making code flatter and easier to debug.",
          "analysisPoints": [
            "Compares two key patterns for logic reuse.",
            "Focuses on the structural advantage of Hooks.",
            "Highlights the 'wrapper hell' problem associated with HOCs."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "HOCs",
            "Logic Reusability",
            "Wrapper Hell",
            "Component Tree"
          ],
          "evaluationCriteria": [
            "Accurate comparison of patterns.",
            "Understanding of modern React best practices."
          ],
          "example": null,
          "tags": [
            "HOC",
            "Hooks",
            "Comparison",
            "Advanced"
          ],
          "prerequisites": [
            "theory_hoc",
            "react_hooks_custom_hooks"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_presentational_card",
          "title": "Implement a Reusable Presentational Card Component",
          "description": "\nCreate a versatile `Card` presentational component that displays content based solely on its props. The component should:\n\n1.  Accept `title` (string), `content` (ReactNode), and an optional `footer` (ReactNode) as props.\n2.  Render these elements in a visually distinct 'card' format (e.g., with a border or background).\n3.  Ensure it has no internal state or data fetching logic.\n4.  Be callable with just a title and content, or with all three props.\n\nYour solution should demonstrate proper prop typing for TypeScript.",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\n\ninterface CardProps {\n  title: string;\n  content: React.ReactNode; \n  footer?: React.ReactNode; // Optional footer\n}\n\nconst Card: React.FC<CardProps> = ({ title, content, footer }) => {\n  // TODO: Implement the Card component\n  // Consider styling for a distinct card look.\n  \n  return (\n    <div style={{ /* Add basic card styling here */ }}>\n      <h3>{title}</h3>\n      <div>\n        {content}\n      </div>\n      {footer && (\n        <div>\n          {footer}\n        </div>\n      )}\n    </div>\n  );\n};\n\n// Example Usage (for testing):\n// function App() {\n//   return (\n//     <div>\n//       <Card \n//         title=\"Basic Card\"\n//         content={<p>This is the content of the basic card.</p>}\n//       />\n//       <Card \n//         title=\"Card with Footer\"\n//         content={<ul><li>Item 1</li><li>Item 2</li></ul>}\n//         footer={<button>Learn More</button>}\n//       />\n//     </div>\n//   );\n// }\n// export default App;",
          "solutionCode": "import React from 'react';\n\ninterface CardProps {\n  title: string;\n  content: React.ReactNode; \n  footer?: React.ReactNode; \n}\n\nconst Card: React.FC<CardProps> = ({ title, content, footer }) => {\n  const cardStyle: React.CSSProperties = {\n    border: '1px solid #ccc',\n    borderRadius: '8px',\n    padding: '20px',\n    margin: '10px',\n    boxShadow: '0 2px 4px rgba(0,0,0,0.1)',\n    backgroundColor: '#fff',\n    maxWidth: '400px'\n  };\n\n  const headerStyle: React.CSSProperties = {\n    marginBottom: '15px',\n    color: '#333'\n  };\n\n  const contentStyle: React.CSSProperties = {\n    marginBottom: footer ? '15px' : '0',\n    color: '#555'\n  };\n\n  const footerStyle: React.CSSProperties = {\n    paddingTop: '10px',\n    borderTop: '1px solid #eee',\n    marginTop: '10px'\n  };\n\n  return (\n    <div style={cardStyle}>\n      <h3 style={headerStyle}>{title}</h3>\n      <div style={contentStyle}>\n        {content}\n      </div>\n      {footer && (\n        <div style={footerStyle}>\n          {footer}\n        </div>\n      )}\n    </div>\n  );\n};\n\n// Example Usage (for testing):\n// function App() {\n//   return (\n//     <div style={{ display: 'flex', flexWrap: 'wrap', justifyContent: 'center' }}>\n//       <Card \n//         title=\"Basic Information\"\n//         content={<p>This card presents some essential details without any complex logic. It simply renders what it's given.</p>}\n//       />\n//       <Card \n//         title=\"User Statistics\"\n//         content={\n//           <div>\n//             <p>Active Users: <strong>1,234</strong></p>\n//             <p>New Signups Today: <strong>25</strong></p>\n//           </div>\n//         }\n//         footer={<button onClick={() => alert('View all stats')}>View More Stats</button>}\n//       />\n//       <Card\n//         title=\"Empty Content Card\"\n//         content={null} // Example with null content, still renders title/footer if present\n//         footer={<small>No content available for this section.</small>}\n//       />\n//     </div>\n//   );\n// }\n// export default App;",
          "testCases": [
            "Render `Card` with only `title` and `content`.",
            "Render `Card` with `title`, `content`, and `footer`.",
            "Verify that the `footer` section is not rendered when `footer` prop is `undefined` or `null`.",
            "Ensure `content` can be any valid ReactNode (e.g., string, JSX, array of elements).",
            "Check for basic styling application (border, padding, etc.)."
          ],
          "hints": [
            "Use inline styles or a CSS module for the card's visual appearance.",
            "Remember that `React.ReactNode` type can include strings, numbers, elements, or arrays of these.",
            "Conditional rendering (`{footer && (...) }`) is key for optional props."
          ],
          "tags": [
            "Presentational Components",
            "UI Components",
            "Props",
            "TypeScript",
            "Styling"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_functional_components",
            "typescript_interfaces_types"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "component_composition",
            "props_drilling"
          ]
        },
        {
          "id": "task_implement_container_user_profile",
          "title": "Implement a User Profile Container Component with Loading/Error States",
          "description": "\nCreate a `UserProfileContainer` component that fetches user data from a mock API endpoint and manages its loading and error states. This container should then pass the fetched user data to a provided `UserProfilePresentational` component.\n\n**Requirements:**\n1.  `UserProfileContainer` should fetch user data (simulated with a `Promise`).\n2.  It must manage `isLoading` and `error` states.\n3.  Display a 'Loading user...' message when `isLoading` is true.\n4.  Display an 'Error: [error message]' when an error occurs.\n5.  Pass the `user` object to a `UserProfilePresentational` component once data is successfully fetched.\n6.  Create a simple `UserProfilePresentational` component that takes `user` as a prop and displays `user.name` and `user.email`.\n\nUse React Hooks (`useState`, `useEffect`) for state and side effects.",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// --- Mock API Call --- \nconst mockFetchUser = (userId: number) => {\n  return new Promise<{ id: number; name: string; email: string; } | null>((resolve, reject) => {\n    setTimeout(() => {\n      if (userId === 1) {\n        resolve({ id: 1, name: 'Alice Smith', email: 'alice.smith@example.com' });\n      } else if (userId === 2) {\n        reject(new Error('User with ID 2 not found.'));\n      } else {\n        resolve(null); // No user for other IDs\n      }\n    }, 1500);\n  });\n};\n\n// --- Presentational Component (DO NOT MODIFY) ---\ninterface UserProfileProps {\n  user: { id: number; name: string; email: string; } | null;\n}\n\nconst UserProfilePresentational: React.FC<UserProfileProps> = ({ user }) => {\n  if (!user) {\n    return <p>No user data available.</p>;\n  }\n  return (\n    <div style={{ border: '1px solid #eee', padding: '15px', borderRadius: '5px', margin: '10px' }}>\n      <h2>User Profile</h2>\n      <p><strong>Name:</strong> {user.name}</p>\n      <p><strong>Email:</strong> {user.email}</p>\n    </div>\n  );\n};\n\n// --- Your Container Component (Implement this) ---\ninterface UserProfileContainerProps {\n  userId: number;\n}\n\nconst UserProfileContainer: React.FC<UserProfileContainerProps> = ({ userId }) => {\n  // TODO: Implement state for user, isLoading, error\n  // TODO: Use useEffect to call mockFetchUser based on userId\n  // TODO: Handle loading, error, and data display\n\n  return (\n    <div>\n      {/* Render loading, error, or UserProfilePresentational based on state */}\n      <p>Container logic goes here...</p>\n      <UserProfilePresentational user={null} /> {/* Placeholder */}\n    </div>\n  );\n};\n\n// Example Usage (for testing):\n// function App() {\n//   return (\n//     <div>\n//       <h1>User Profile App</h1>\n//       <UserProfileContainer userId={1} />\n//       <UserProfileContainer userId={2} /> {/* This should show an error */}\n//       <UserProfileContainer userId={3} /> {/* This should show no user data */}\n//     </div>\n//   );\n// }\n// export default App;",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// --- Mock API Call --- \nconst mockFetchUser = (userId: number) => {\n  return new Promise<{ id: number; name: string; email: string; } | null>((resolve, reject) => {\n    setTimeout(() => {\n      if (userId === 1) {\n        resolve({ id: 1, name: 'Alice Smith', email: 'alice.smith@example.com' });\n      } else if (userId === 2) {\n        reject(new Error('User with ID 2 not found.'));\n      } else {\n        resolve(null); // No user for other IDs\n      }\n    }, 1500);\n  });\n};\n\n// --- Presentational Component (DO NOT MODIFY) ---\ninterface UserProfileProps {\n  user: { id: number; name: string; email: string; } | null;\n}\n\nconst UserProfilePresentational: React.FC<UserProfileProps> = ({ user }) => {\n  if (!user) {\n    return <p>No user data available.</p>;\n  }\n  return (\n    <div style={{ border: '1px solid #eee', padding: '15px', borderRadius: '5px', margin: '10px' }}>\n      <h2>User Profile</h2>\n      <p><strong>Name:</strong> {user.name}</p>\n      <p><strong>Email:</strong> {user.email}</p>\n    </div>\n  );\n};\n\n// --- Your Container Component (Implement this) ---\ninterface UserProfileContainerProps {\n  userId: number;\n}\n\nconst UserProfileContainer: React.FC<UserProfileContainerProps> = ({ userId }) => {\n  const [user, setUser] = useState<{ id: number; name: string; email: string; } | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    setIsLoading(true);\n    setError(null); // Clear previous errors\n    setUser(null); // Clear previous user data\n\n    mockFetchUser(userId)\n      .then(data => {\n        setUser(data);\n      })\n      .catch(err => {\n        setError(err.message);\n      })\n      .finally(() => {\n        setIsLoading(false);\n      });\n  }, [userId]); // Re-run effect if userId changes\n\n  if (isLoading) {\n    return <p>Loading user...</p>;\n  }\n\n  if (error) {\n    return <p style={{ color: 'red' }}>Error: {error}</p>;\n  }\n\n  return <UserProfilePresentational user={user} />;\n};\n\n// Example Usage (for testing):\n// function App() {\n//   return (\n//     <div>\n//       <h1>User Profile App</h1>\n//       <UserProfileContainer userId={1} />\n//       <UserProfileContainer userId={2} /> {/* This should show an error */}\n//       <UserProfileContainer userId={3} /> {/* This should show no user data (null user) */}\n//     </div>\n//   );\n// }\n// export default App;",
          "testCases": [
            "Verify 'Loading user...' message is displayed initially.",
            "Test with `userId={1}`: Ensure `UserProfilePresentational` receives and displays 'Alice Smith' and her email.",
            "Test with `userId={2}`: Ensure an error message 'Error: User with ID 2 not found.' is displayed.",
            "Test with `userId={3}`: Ensure 'No user data available.' is displayed (as `mockFetchUser` resolves with `null`).",
            "Change `userId` prop dynamically (e.g., with a button) to ensure the component re-fetches data and updates correctly.",
            "Ensure no memory leaks (e.g., setting state on unmounted component if not handled, though `useEffect` cleanup for `fetch` is often more complex for simple cases like this mock)."
          ],
          "hints": [
            "Initialize `isLoading` to `true` to show the loading state immediately.",
            "Use the `useEffect` hook for side effects like data fetching. Remember its dependency array.",
            "Handle both `then` (success) and `catch` (error) blocks of the `Promise`.",
            "The `finally` block in a Promise is useful for setting `isLoading` to `false` regardless of success or failure.",
            "Conditional rendering (`if (isLoading) return ...`) is crucial for displaying different UI states."
          ],
          "tags": [
            "Container Components",
            "React Hooks",
            "Data Fetching",
            "State Management",
            "Error Handling"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_hooks_usestate",
            "react_hooks_useeffect",
            "javascript_promises_fetch_api"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "component_architecture",
            "separation_of_concerns"
          ]
        },
        {
          "id": "task_implement_hoc_with_loading",
          "title": "Implement a `withLoading` HOC",
          "description": "\nCreate a Higher-Order Component (HOC) called `withLoading` that enhances any component by adding a loading state and displaying a loading indicator while a prop named `data` (or any other specified prop) is `null` or `undefined`.\n\n**Requirements:**\n1.  The `withLoading` HOC should accept `WrappedComponent` and an optional `dataPropName` (defaulting to 'data') as arguments.\n2.  If the specified data prop on the `WrappedComponent` is `null` or `undefined`, the HOC should render a 'Loading...' message.\n3.  Otherwise, it should render the `WrappedComponent` with all its original props.\n4.  Demonstrate its use by creating a `ProductList` component that expects a `products` prop, and then use `withLoading` to make it show a loading message when `products` is not yet available.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\n\n// --- Your HOC (Implement this) ---\nconst withLoading = (WrappedComponent: React.ComponentType<any>, dataPropName: string = 'data') => {\n  // TODO: Return a new component that manages loading logic\n  return (props: any) => {\n    // Check if the relevant data prop is missing\n    const data = props[dataPropName];\n\n    if (data === null || data === undefined) {\n      return <p>Loading...</p>;\n    }\n    \n    // Render the wrapped component with all its props\n    return <WrappedComponent {...props} />;\n  };\n};\n\n// --- Example Component to be Wrapped ---\ninterface ProductListProps {\n  products: { id: number; name: string; }[];\n  title: string;\n}\n\nconst ProductList: React.FC<ProductListProps> = ({ products, title }) => {\n  return (\n    <div>\n      <h3>{title}</h3>\n      {products.length > 0 ? (\n        <ul>\n          {products.map(product => <li key={product.id}>{product.name}</li>)}\n        </ul>\n      ) : (\n        <p>No products available.</p>\n      )}\n    </div>\n  );\n};\n\n// --- Usage Example (for testing) ---\n// const EnhancedProductList = withLoading(ProductList, 'products');\n\n// function App() {\n//   const [products, setProducts] = React.useState<any[] | null>(null);\n\n//   React.useEffect(() => {\n//     setTimeout(() => {\n//       setProducts([\n//         { id: 1, name: 'Laptop' },\n//         { id: 2, name: 'Keyboard' }\n//       ]);\n//     }, 2000);\n//   }, []);\n\n//   return (\n//     <div>\n//       <h1>HOC with Loading</h1>\n//       <EnhancedProductList products={products} title=\"Our Products\" />\n//     </div>\n//   );\n// }\n// export default App;",
          "solutionCode": "import React from 'react';\n\n// --- Your HOC (Implement this) ---\nconst withLoading = (WrappedComponent: React.ComponentType<any>, dataPropName: string = 'data') => {\n  // The HOC returns a new functional component\n  return (props: any) => {\n    // Check if the relevant data prop is missing\n    const data = props[dataPropName];\n\n    if (data === null || data === undefined) {\n      return <p>Loading...</p>;\n    }\n    \n    // Render the wrapped component with all its props\n    return <WrappedComponent {...props} />;\n  };\n};\n\n// --- Example Component to be Wrapped ---\ninterface ProductListProps {\n  products: { id: number; name: string; }[];\n  title: string;\n}\n\nconst ProductList: React.FC<ProductListProps> = ({ products, title }) => {\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '15px', borderRadius: '5px', margin: '10px' }}>\n      <h3>{title}</h3>\n      {products.length > 0 ? (\n        <ul>\n          {products.map(product => <li key={product.id}>{product.name}</li>)}\n        </ul>\n      ) : (\n        <p>No products available.</p>\n      )}\n    </div>\n  );\n};\n\n// --- Usage Example (for testing) ---\nconst EnhancedProductList = withLoading(ProductList, 'products');\nconst EnhancedGenericComponent = withLoading(ProductList); // Using default 'data' prop name (will not work for ProductList)\n\n// This component demonstrates the usage:\n// function App() {\n//   const [products, setProducts] = React.useState<any[] | null>(null);\n//   const [otherData, setOtherData] = React.useState<string | null>(null);\n\n//   React.useEffect(() => {\n//     // Simulate data fetching for products\n//     setTimeout(() => {\n//       setProducts([\n//         { id: 1, name: 'Laptop' },\n//         { id: 2, name: 'Keyboard' }\n//       ]);\n//     }, 2000);\n\n//     // Simulate data fetching for otherData\n//     setTimeout(() => {\n//       setOtherData('Some other loaded data');\n//     }, 1000);\n//   }, []);\n\n//   return (\n//     <div>\n//       <h1>HOC with Loading</h1>\n//       <h2>Products List:</h2>\n//       <EnhancedProductList products={products} title=\"Available Electronics\" />\n\n//       <h2>Another Component (using default 'data' prop name):</h2>\n//       {/* This will show loading and then 'No products available.' because otherData is not named 'data' */}\n//       <EnhancedGenericComponent data={otherData} title=\"Generic Data Demo\" products={[]} />\n\n//       <h2>Component without HOC (always shows data if provided):</h2>\n//       <ProductList products={products || []} title=\"Raw Product List\" />\n//     </div>\n//   );\n// }\n// export default App;",
          "testCases": [
            "Render `EnhancedProductList` with `products={null}` initially: Should display 'Loading...'.",
            "After a delay, `products` is set to an array: Should display the list of products.",
            "Test with `dataPropName` explicitly set (e.g., `withLoading(MyComponent, 'items')`).",
            "Test with `dataPropName` not provided (default 'data'): Ensure it correctly checks for a prop named 'data'.",
            "Ensure all other props passed to the HOC are correctly forwarded to the `WrappedComponent`.",
            "Test with an empty array for data (e.g., `products=[]`): Should render the `WrappedComponent` (and it should show 'No products available.')."
          ],
          "hints": [
            "The HOC function itself returns a new functional component. This returned component is what will receive props.",
            "Use `props[dataPropName]` to dynamically access the prop that determines the loading state.",
            "Remember to pass all incoming props (`{...props}`) to the `WrappedComponent`.",
            "Consider the distinction between `null`/`undefined` (loading) and an empty array (loaded, but empty data)."
          ],
          "tags": [
            "HOC",
            "Higher-Order Components",
            "Loading State",
            "React Patterns",
            "Functional Components"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_hoc",
            "react_functional_components",
            "javascript_object_destructuring"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "component_enhancement",
            "props_proxy_pattern"
          ]
        }
      ]
    }
  },
  {
    "id": "134b0e16-02b4-4f7f-891c-05645559f4f0",
    "startLine": 3000,
    "endLine": 3099,
    "processedDate": "2025-06-17T08:36:30.313Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_hoc",
          "title": "Higher-Order Components (HOCs)",
          "content": "Higher-Order Components (HOCs) are an advanced technique in React for reusing component logic. A HOC is essentially a function that takes a component as an argument and returns a new component with enhanced props or behavior. They are used for cross-cutting concerns, meaning functionalities that are common across many components, such as data fetching, authentication, logging, or state management.\n\n## Key Concepts\n-   **Function Signature**: A HOC is a function with the signature `(WrappedComponent) => EnhancedComponent`.\n-   **Logic Reusability**: They promote the reuse of component logic without duplicating code.\n-   **Props Proxying**: The HOC renders the WrappedComponent, passing down props it received, potentially adding, modifying, or removing some.\n-   **Inheritance Inversion (less common)**: The HOC extends the WrappedComponent, allowing access to its state and props, but this is generally discouraged due to complexity and tight coupling.\n\n## How HOCs Work\nA HOC wraps an existing component and injects new props or behavior. It doesn't modify the component itself, nor does it use inheritance. Instead, a HOC composes the original component by wrapping it in a container component. This container component handles the shared logic (e.g., fetching data, providing context) and then passes the necessary data as props to the original component.\n\n## Advantages\n-   **Logic Reuse**: Centralize common logic, reducing code duplication.\n-   **Separation of Concerns**: Decouple presentational components from data-fetching or other non-UI logic.\n-   **Abstracting State and Props**: Can manage state or manipulate props before passing them down.\n\n## Disadvantages\n-   **Prop Collisions**: HOCs can unintentionally override props passed to the wrapped component if they use the same prop names.\n-   **Ref Forwarding Issues**: Refs don't automatically pass through HOCs to the wrapped component, requiring explicit `React.forwardRef`.\n-   **Wrapper Hell**: Too many HOCs can lead to a deeply nested component tree, making debugging harder and obscuring where props originate from.\n-   **Static Composition**: HOCs compose components statically, meaning the injected logic is fixed at render time, unlike Hooks or Render Props which offer more dynamic composition.\n\n## Usage Example\nIn the provided example, `withUser` would be a Higher-Order Component that injects `user` data into `UserProfile`. If `user` is not available (e.g., still loading), it might provide `null` or `undefined`, allowing `UserProfile` to render a loading state.\n",
          "examples": [
            {
              "id": "example_hoc_1",
              "title": "Basic HOC Implementation: withUser",
              "code": "import React, { useState, useEffect } from 'react';\n\n// A Higher-Order Component (HOC) to inject user data\nconst withUser = (WrappedComponent) => {\n  const WithUserComponent = (props) => {\n    const [user, setUser] = useState(null);\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() => {\n      // Simulate fetching user data\n      setTimeout(() => {\n        const fetchedUser = { name: 'John Doe', id: 1 };\n        setUser(fetchedUser);\n        setLoading(false);\n      }, 1000);\n    }, []);\n\n    if (loading) {\n      return <div>Loading user data...</div>;\n    }\n\n    return <WrappedComponent {...props} user={user} />;\n  };\n  WithUserComponent.displayName = `WithUser(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return WithUserComponent;\n};\n\n// Original Component to be wrapped\nconst UserProfile = ({ user, greeting }) => (\n  user ? <div>{greeting}, {user.name}!</div> : <div>Loading...</div>\n);\n\n// Applying the HOC\nconst UserProfileWithUser = withUser(UserProfile);\n\n// Usage in an App component\nfunction App() {\n  return <UserProfileWithUser greeting=\"Hello\" />;\n}\n",
              "explanation": "This example demonstrates a basic `withUser` HOC. It fetches user data asynchronously and then passes the `user` object as a prop to the `WrappedComponent` (`UserProfile`). It also handles a loading state. The `displayName` is set for easier debugging in React DevTools.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_hoc_1",
            "question_hoc_2",
            "question_hoc_3",
            "question_hoc_4",
            "question_hoc_5"
          ],
          "relatedTasks": [
            "task_hoc_auth_logger"
          ],
          "tags": [
            "React",
            "HOC",
            "Design Patterns",
            "Reusability",
            "Composition"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_props",
            "react_state",
            "javascript_functions"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced_react_patterns",
            "logic_reusability",
            "separation_of_concerns"
          ]
        },
        {
          "id": "theory_component_specialization",
          "title": "Component Specialization Pattern",
          "content": "Component specialization is a pattern where you create a more specialized component from a more generic one. This is achieved by creating a new component that renders the generic component with specific, pre-defined props. The main goal is to create reusable variations of a base component, simplifying its usage and ensuring consistency across an application.\n\n## Key Concepts\n-   **Generic Component**: A base component designed to be highly configurable via props, handling a wide range of use cases.\n-   **Specialized Component**: A wrapper component that renders the generic component, fixing certain props or applying specific styles/behaviors, thereby creating a more specific instance.\n-   **Encapsulation**: The specialized component encapsulates the specific configuration, hiding complexity from its consumers.\n\n## How Component Specialization Works\nThe pattern involves defining a generic component that accepts various props to control its appearance and behavior. Then, for common use cases or specific design requirements, you create new, simpler components that internally render this generic component, passing a fixed subset of props. These specialized components often have more semantic names, reflecting their specific purpose (e.g., `PrimaryButton`, `DangerButton`).\n\n## Advantages\n-   **Improved Readability and Semantics**: Specialized components have clear names that indicate their purpose, making code easier to understand.\n-   **Reduced Prop Boilerplate**: Consumers of specialized components don't need to pass the same set of props repeatedly for common variations.\n-   **Design Consistency**: Ensures that specific variations of a component (e.g., a primary button) always look and behave consistently throughout the application.\n-   **Enhanced Reusability**: While the generic component is reusable, specialized components make it easier to reuse specific configurations.\n\n## Disadvantages\n-   **File Sprawl**: Can lead to many small component files if every slight variation is specialized.\n-   **Over-abstraction**: For very simple cases, it might introduce unnecessary layers of abstraction.\n-   **Maintenance Overhead**: Managing many specialized components alongside the generic one can sometimes be more complex.\n",
          "examples": [
            {
              "id": "example_component_specialization_1",
              "title": "Generic Button and Specialized Variations",
              "code": "// Generic Button component\nfunction Button({ size, color, children, ...rest }) {\n  const sizeClass = size === 'large' ? 'text-lg px-6 py-3' : 'text-sm px-4 py-2';\n  const colorClass = {\n    primary: 'bg-blue-500 hover:bg-blue-600 text-white',\n    secondary: 'bg-gray-500 hover:bg-gray-600 text-white',\n    danger: 'bg-red-500 hover:bg-red-600 text-white',\n  }[color] || 'bg-gray-200 hover:bg-gray-300 text-black';\n  \n  return (\n    <button \n      className={`rounded font-medium ${sizeClass} ${colorClass}`}\n      {...rest}\n    >\n      {children}\n    </button>\n  );\n}\n\n// Specialized button components using component specialization pattern\nfunction PrimaryButton(props) {\n  return <Button color=\"primary\" {...props} />;\n}\n\nfunction DangerButton(props) {\n  return <Button color=\"danger\" {...props} />;\n}\n\nfunction LargeButton(props) {\n  return <Button size=\"large\" {...props} />;\n}\n\n// Usage\nfunction App() {\n  return (\n    <div>\n      <PrimaryButton onClick={() => console.log('Saved')}>Save</PrimaryButton>\n      <DangerButton onClick={() => console.log('Deleted')}>Delete</DangerButton>\n      <LargeButton color=\"secondary\">Secondary Large Button</LargeButton>\n      <Button color=\"primary\" size=\"large\">Big Primary</Button>\n    </div>\n  );\n}\n",
              "explanation": "This example showcases a generic `Button` component that accepts `size` and `color` props. Then, `PrimaryButton`, `DangerButton`, and `LargeButton` are created as specialized versions. They simply render the `Button` component with pre-set `color` or `size` props, while still allowing consumers to pass additional props like `onClick` or `children` via `...props`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_specialization_1",
            "question_specialization_2",
            "question_specialization_3",
            "question_specialization_4"
          ],
          "relatedTasks": [
            "task_input_specialization"
          ],
          "tags": [
            "React",
            "Design Patterns",
            "Component Design",
            "Reusability",
            "DRY"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_props"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "ui_library_design",
            "reusable_components"
          ]
        },
        {
          "id": "theory_render_props",
          "title": "Render Props Pattern",
          "content": "The Render Props pattern is a technique for sharing code and functionality between React components using a prop whose value is a function. The component with the render prop calls this function, passing it data or state, instead of implementing its own render logic directly. This allows for flexible and dynamic composition of UI and behavior.\n\n## Key Concepts\n-   **Function as a Prop**: Instead of rendering JSX directly, a component receives a function as a prop (often named `render` or even `children`).\n-   **Child Controls Rendering**: The component that *receives* the render prop is responsible for calling this function and rendering its return value. It passes its internal state or shared logic data as arguments to this function.\n-   **Decoupling Logic from UI**: The component implementing the render prop focuses solely on the logic/state, while the UI structure is entirely controlled by the consumer of the render prop.\n-   **Cross-Cutting Concerns**: Similar to HOCs, render props are excellent for sharing non-visual logic like mouse tracking, window size, authentication status, etc.\n\n## How Render Props Work\nImagine a component that tracks mouse position. Instead of rendering a specific UI element (like a `<div>` showing coordinates), it takes a `render` prop. When its internal mouse position state updates, it calls `this.props.render(this.state.mousePosition)` and renders whatever that function returns. This means the parent component (consumer of `MouseTracker`) dictates *what* gets rendered with the mouse position data.\n\n## Advantages\n-   **Highly Flexible Composition**: Offers dynamic composition at runtime, allowing consumers to fully control the rendering and incorporate the shared logic into any UI structure.\n-   **Clear Prop Origin**: It's very clear where the data comes from (it's passed as an argument to the render prop function).\n-   **No Prop Collisions**: Avoids the prop name collision issues sometimes encountered with HOCs.\n-   **No Wrapper Hell**: Does not introduce extra layers in the component tree just for logic sharing, making debugging simpler than deeply nested HOCs.\n\n## Disadvantages\n-   **Nesting (Indentation) Hell**: Can lead to deeply nested JSX if multiple render props are used, making code harder to read.\n-   **Performance Considerations**: If the render prop function creates new functions on every render, it can cause unnecessary re-renders for pure components (though `React.memo` or `useCallback` can mitigate this).\n-   **Learning Curve**: Can be less intuitive for beginners than simple prop passing.\n\n## Comparison to HOCs\nRender Props and HOCs are both patterns for code reuse. Render Props are generally preferred when you need more dynamic control over rendering and want to avoid prop collisions or wrapper hell. HOCs are useful for simpler, more static enhancements that don't require fine-grained UI control from the consumer.\n",
          "examples": [
            {
              "id": "example_render_props_1",
              "title": "Mouse Tracker with Render Props",
              "code": "import React from 'react';\n\n// A component that tracks mouse position and uses render props pattern\nclass MouseTracker extends React.Component {\n  state = { x: 0, y: 0 };\n  \n  handleMouseMove = (event) => {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  };\n  \n  render() {\n    return (\n      <div \n        style={{ height: '100vh', border: '1px solid black', display: 'flex', justifyContent: 'center', alignItems: 'center' }}\n        onMouseMove={this.handleMouseMove}\n      >\n        {/* The render prop: a function that returns a React element */}\n        {this.props.render(this.state)}\n      </div>\n    );\n  }\n}\n\n// A simple Circle component to display position\nconst Circle = ({ position }) => (\n    <div style={{\n        position: 'absolute',\n        left: position.x,\n        top: position.y,\n        width: '50px',\n        height: '50px',\n        borderRadius: '50%',\n        background: 'blue',\n        transform: 'translate(-50%, -50%)'\n    }} />\n);\n\n// Using the render prop\nfunction App() {\n  return (\n    <MouseTracker \n      render={({ x, y }) => (\n        <div>\n          <h1>Move the mouse around!</h1>\n          <p>Current mouse position: {x}, {y}</p>\n          <Circle position={{ x, y }} />\n        </div>\n      )}\n    />\n  );\n}\n",
              "explanation": "This example defines `MouseTracker` which manages its own `x` and `y` state. Instead of directly rendering any UI, it calls `this.props.render` and passes its current state. The `App` component provides the `render` prop as a function, which receives `x` and `y` and uses them to display text and position a `Circle` component.",
              "language": "typescript"
            },
            {
              "id": "example_render_props_2",
              "title": "Children as a Render Prop",
              "code": "import React, { useState, useEffect } from 'react';\n\n// Component using 'children' as a render prop\nfunction DataLoader({ url, children }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      try {\n        // Simulate API call\n        const response = await new Promise(resolve => setTimeout(() => {\n          if (url === '/api/users') resolve({ name: 'Jane Doe', email: 'jane@example.com' });\n          else if (url === '/api/products') resolve([{ id: 1, name: 'Laptop' }, { id: 2, name: 'Keyboard' }]);\n          else throw new Error('Not Found');\n        }, 500));\n        setData(response);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchData();\n  }, [url]);\n\n  // 'children' is called as a function here\n  return children({ data, loading, error });\n}\n\n// Usage\nfunction UserDisplay() {\n  return (\n    <DataLoader url=\"/api/users\">\n      {({ data, loading, error }) => {\n        if (loading) return <div>Loading user...</div>;\n        if (error) return <div>Error: {error.message}</div>;\n        if (!data) return <div>No user data.</div>;\n        return (\n          <div>\n            <h2>User Profile</h2>\n            <p>Name: {data.name}</p>\n            <p>Email: {data.email}</p>\n          </div>\n        );\n      }}\n    </DataLoader>\n  );\n}\n\nfunction ProductList() {\n    return (\n      <DataLoader url=\"/api/products\">\n        {({ data, loading, error }) => {\n          if (loading) return <div>Loading products...</div>;\n          if (error) return <div>Error: {error.message}</div>;\n          if (!data || data.length === 0) return <div>No products.</div>;\n          return (\n            <div>\n              <h2>Product List</h2>\n              <ul>\n                {data.map(product => (\n                  <li key={product.id}>{product.name}</li>\n                ))}\n              </ul>\n            </div>\n          );\n        }}\n      </DataLoader>\n    );\n  }\n\nfunction App() {\n    return (\n        <div>\n            <UserDisplay />\n            <hr/>\n            <ProductList />\n        </div>\n    )\n}\n",
              "explanation": "This example uses the `children` prop as a render prop. `DataLoader` fetches data based on a URL and then passes `data`, `loading`, and `error` states to the function provided as `children`. This allows `UserDisplay` and `ProductList` to define their own UI based on the data loading status, demonstrating highly flexible data-driven UI rendering.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_render_props_1",
            "question_render_props_2",
            "question_render_props_3",
            "question_render_props_4",
            "question_render_props_5"
          ],
          "relatedTasks": [
            "task_theme_switcher"
          ],
          "tags": [
            "React",
            "Design Patterns",
            "Render Props",
            "Composition",
            "Reusability"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_props",
            "react_state",
            "javascript_functions"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "advanced_react_patterns",
            "logic_reusability",
            "flexible_component_design"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_hoc_1",
          "topic": "Higher-Order Components (HOCs) Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of a Higher-Order Component (HOC) in React?",
          "answer": "To reuse component logic across multiple components.",
          "options": [],
          "analysisPoints": [
            "Checks understanding of HOC core purpose.",
            "Distinguishes HOCs from simple utility functions or presentational components."
          ],
          "keyConcepts": [
            "HOC",
            "Logic Reusability",
            "React Patterns"
          ],
          "evaluationCriteria": [
            "Ability to recall core definition",
            "Understanding of HOC's main benefit"
          ],
          "example": "",
          "tags": [
            "HOC",
            "React",
            "Basics"
          ],
          "prerequisites": [
            "react_components"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_hoc_2",
          "topic": "Higher-Order Components (HOCs) Structure",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following best describes the typical structure of a Higher-Order Component (HOC)?\n\n```javascript\n// Option A\nfunction withLogger() {\n  return function(Component) {\n    return class extends React.Component {\n      // ... logic\n    };\n  };\n}\n\n// Option B\nconst withLogger = (Component) => {\n  return (props) => {\n    // ... logic\n    return <Component {...props} />;\n  };\n};\n\n// Option C\nclass withLogger extends React.Component {\n  render() {\n    const { children: Component, ...props } = this.props;\n    // ... logic\n    return <Component {...props} />;\n  }\n}\n\n// Option D\nfunction withLogger(Component, props) {\n  // ... logic\n  return <Component {...props} />;\n}\n```",
          "answer": "Option B",
          "options": [
            "Option A",
            "Option B",
            "Option C",
            "Option D"
          ],
          "analysisPoints": [
            "Tests understanding of HOC signature (function returning a function/component).",
            "Distinguishes HOCs from render props (Option C) or simple functional components (Option D).",
            "Highlights the common pattern of accepting a component and returning a new component (either functional or class-based)."
          ],
          "keyConcepts": [
            "HOC Structure",
            "Functional Components",
            "Class Components",
            "React.Component"
          ],
          "evaluationCriteria": [
            "Ability to identify correct HOC signature",
            "Understanding of functional vs class HOCs"
          ],
          "example": "Option B represents the most common and idiomatic functional HOC structure: a function that takes a component and returns a new functional component that wraps the original. Option A is also a valid HOC, but it returns a class component which is less common for simple HOCs nowadays. Option C describes the render props pattern (using children as a function). Option D is just a regular functional component or helper, not a HOC.",
          "tags": [
            "HOC",
            "React",
            "Syntax",
            "Structure"
          ],
          "prerequisites": [
            "react_components",
            "javascript_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_3",
          "topic": "Higher-Order Components (HOCs) Implementation",
          "level": "medium",
          "type": "code",
          "question": "Implement a Higher-Order Component named `withLoadingIndicator` that takes a `WrappedComponent`. If a `loading` prop passed to the `EnhancedComponent` is `true`, it should render a `<div>Loading...</div>`. Otherwise, it should render the `WrappedComponent` with all its original props. Ensure the `loading` prop is consumed by the HOC and not passed down to the `WrappedComponent`.",
          "answer": "```typescript\nimport React from 'react';\n\nconst withLoadingIndicator = (WrappedComponent) => {\n  const WithLoadingIndicator = ({ loading, ...restProps }) => {\n    if (loading) {\n      return <div>Loading...</div>;\n    }\n    return <WrappedComponent {...restProps} />;\n  };\n\n  WithLoadingIndicator.displayName = `WithLoadingIndicator(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return WithLoadingIndicator;\n};\n\n// Example Usage:\nconst MyComponent = ({ data }) => <div>Data: {data}</div>;\nconst MyComponentWithLoading = withLoadingIndicator(MyComponent);\n\nfunction App() {\n  return (\n    <div>\n      <MyComponentWithLoading loading={true} />\n      <MyComponentWithLoading loading={false} data=\"Hello World\" />\n    </div>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to correctly define and implement a functional HOC.",
            "Ensures understanding of prop destructuring to consume specific props (`loading`) and pass others (`...restProps`).",
            "Verifies handling of conditional rendering based on HOC-managed logic."
          ],
          "keyConcepts": [
            "HOC",
            "Prop Manipulation",
            "Conditional Rendering",
            "React.memo"
          ],
          "evaluationCriteria": [
            "Correct HOC function signature",
            "Proper prop handling (passing through, consuming)",
            "Accurate conditional rendering logic",
            "Setting displayName for debugging"
          ],
          "example": "The solution demonstrates a functional HOC named `withLoadingIndicator`. It destructures the `loading` prop from the incoming props. If `loading` is true, it renders a loading message. Otherwise, it spreads the `restProps` (all props except `loading`) onto the `WrappedComponent`, ensuring `loading` is handled by the HOC itself and not passed down unnecessarily.",
          "tags": [
            "HOC",
            "React",
            "Coding Challenge",
            "Intermediate"
          ],
          "prerequisites": [
            "react_components",
            "react_props",
            "javascript_destructuring"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_4",
          "topic": "HOC vs. Hooks",
          "level": "hard",
          "type": "open",
          "question": "Discuss the advantages and disadvantages of using Higher-Order Components (HOCs) versus React Hooks for sharing reusable logic. Provide scenarios where one might be preferred over the other.",
          "answer": "### Advantages and Disadvantages:\n\n**Higher-Order Components (HOCs):**\n*   **Advantages:**\n    *   Good for cross-cutting concerns like authentication, logging, data subscription where the component itself doesn't need to directly manage the state or lifecycle.\n    *   Works well with class components and older React codebases.\n    *   Can be used to abstract away complex prop transformations.\n*   **Disadvantages:**\n    *   **Wrapper Hell / Indirection:** Can create multiple layers of components in the React DevTools, making debugging harder and obscuring the source of props.\n    *   **Prop Collisions:** Risk of prop name clashes if HOCs inject props with the same names as those expected by the wrapped component.\n    *   **Ref Forwarding:** Requires `React.forwardRef` to pass refs through the HOC, adding boilerplate.\n    *   **Static Composition:** Logic is 'baked in' at component definition time, less flexible for dynamic behavior.\n\n**React Hooks:**\n*   **Advantages:**\n    *   **Direct Logic Access:** Allows direct access to stateful logic from functional components without introducing new component layers.\n    *   **No Wrapper Hell:** Doesn't add extra nodes to the component tree, leading to flatter hierarchies and easier debugging.\n    *   **Flexible Composition:** Hooks can be composed dynamically and conditionally, allowing for more granular and flexible reuse of logic.\n    *   **Clear Prop Flow:** Logic is exposed directly in the component, making the data flow more explicit.\n    *   **No Ref Forwarding Issues:** `useRef` works naturally within functional components and hooks.\n*   **Disadvantages:**\n    *   **Rules of Hooks:** Must follow strict rules (call only at top level, only from React functions) which can be a learning curve.\n    *   **Not for Class Components:** Hooks can only be used with functional components.\n    *   **Can lead to large components:** If logic isn't properly abstracted into custom hooks, functional components can become very large.\n\n### Scenarios for Preference:\n\n*   **Prefer HOCs when:**\n    *   You are working with an existing large codebase primarily built with class components.\n    *   You need to manipulate or transform props in a generic way before passing them to a component.\n    *   The logic truly abstracts away a concern that doesn't need direct state/effect management within the consuming component, and you don't mind the wrapper. (e.g., `redux`'s `connect` HOC, `react-router`'s `withRouter` in older versions).\n\n*   **Prefer Hooks when:**\n    *   You are building new features or refactoring existing ones using functional components.\n    *   You need to share stateful logic that directly interacts with React's lifecycle (e.g., `useState`, `useEffect`, `useContext`).\n    *   You want to avoid prop drilling and wrapper hell.\n    *   You need more dynamic and granular control over logic composition within a single component. (e.g., `useAuth`, `useForm`, `useWindowSize`).\n\n**Conclusion:** While HOCs are still valid, React Hooks are generally the preferred modern approach for logic reuse in functional components due to their flexibility, directness, and ability to avoid many of the downsides of HOCs.",
          "options": [],
          "analysisPoints": [
            "Comprehensive understanding of both patterns.",
            "Ability to articulate specific advantages and disadvantages for each.",
            "Insight into practical application scenarios.",
            "Knowledge of common pitfalls (wrapper hell, prop collisions, rules of Hooks)."
          ],
          "keyConcepts": [
            "HOC",
            "React Hooks",
            "Logic Reuse",
            "Composition",
            "Prop Collisions",
            "Wrapper Hell",
            "Rules of Hooks"
          ],
          "evaluationCriteria": [
            "Depth of comparison for pros and cons",
            "Clarity of explanation for each point",
            "Relevance of usage scenarios",
            "Demonstration of advanced React knowledge"
          ],
          "example": "",
          "tags": [
            "HOC",
            "React Hooks",
            "Comparison",
            "Advanced",
            "Design Patterns"
          ],
          "prerequisites": [
            "theory_hoc",
            "react_hooks_basics"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_5",
          "topic": "HOC Debugging and Best Practices",
          "level": "medium",
          "type": "mcq",
          "question": "When developing a Higher-Order Component (HOC), which best practice helps improve debugging in React DevTools?\n\n```javascript\n// HOC snippet\nconst withData = (WrappedComponent) => {\n  const WithData = (props) => {\n    // ... data fetching logic\n    return <WrappedComponent {...props} data={fetchedData} />;\n  };\n  // Which line helps debugging?\n  // A) WithData.displayName = WrappedComponent.displayName || 'UnnamedComponent';\n  // B) WithData.name = 'DataComponent';\n  // C) console.log('HOC loaded');\n  // D) return React.memo(WithData);\n  return WithData;\n};\n```",
          "answer": "A) WithData.displayName = `WithData(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;",
          "options": [
            "A) WithData.displayName = `WithData(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;",
            "B) WithData.name = 'DataComponent';",
            "C) console.log('HOC loaded');",
            "D) return React.memo(WithData);"
          ],
          "analysisPoints": [
            "Tests knowledge of `displayName` property for debugging HOCs.",
            "Distinguishes between actual debugging aids and unrelated code practices.",
            "Highlights how component names appear in DevTools."
          ],
          "keyConcepts": [
            "HOC",
            "Debugging",
            "React DevTools",
            "displayName"
          ],
          "evaluationCriteria": [
            "Understanding of React's debugging features",
            "Correct identification of `displayName` purpose"
          ],
          "example": "Setting the `displayName` property on the returned component of an HOC is a common best practice. It helps improve the readability of the component tree in React DevTools by providing a meaningful name like `WithData(MyComponent)` instead of just `Component` or `Anonymous`. Options B sets the internal `name` property of the function, which is less directly used by React DevTools for display compared to `displayName`. Option C is basic logging, not component naming. Option D is for performance optimization, not directly for debugging display name.",
          "tags": [
            "HOC",
            "Debugging",
            "Best Practices",
            "React"
          ],
          "prerequisites": [
            "theory_hoc",
            "react_components"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_specialization_1",
          "topic": "Component Specialization Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "In React, what is the core idea behind the Component Specialization pattern?",
          "answer": "To create a more specific version of a generic component by pre-setting some of its props, making it simpler to use for common scenarios.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of the pattern's fundamental purpose.",
            "Focuses on the transformation from generic to specific."
          ],
          "keyConcepts": [
            "Component Specialization",
            "Reusability",
            "React Patterns"
          ],
          "evaluationCriteria": [
            "Ability to recall core definition",
            "Understanding of pattern's goal"
          ],
          "example": "",
          "tags": [
            "Component Specialization",
            "React",
            "Basics"
          ],
          "prerequisites": [
            "react_components",
            "react_props"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_specialization_2",
          "topic": "Component Specialization Implementation",
          "level": "medium",
          "type": "mcq",
          "question": "Given a generic `Input` component:\n\n```javascript\nfunction Input({ type = 'text', placeholder, value, onChange, ...rest }) {\n  return (\n    <input \n      type={type} \n      placeholder={placeholder} \n      value={value} \n      onChange={onChange} \n      className=\"border p-2 rounded\" \n      {...rest} \n    />\n  );\n}\n```\n\nWhich of the following correctly implements a `PasswordInput` component using the Component Specialization pattern?",
          "answer": "```javascript\nfunction PasswordInput(props) {\n  return <Input type=\"password\" placeholder=\"Enter password\" {...props} />;\n}\n```",
          "options": [
            "```javascript\nfunction PasswordInput({ placeholder, ...props }) {\n  return <input type=\"password\" placeholder={placeholder || \"Enter password\"} {...props} />;\n}\n```",
            "```javascript\nfunction PasswordInput(props) {\n  return <Input type=\"password\" placeholder=\"Enter password\" {...props} />;\n}\n```",
            "```javascript\nconst PasswordInput = Input.bind(null, { type: 'password', placeholder: 'Enter password' });\n```",
            "```javascript\nfunction PasswordInput() {\n  return <Input type=\"password\" placeholder=\"Enter password\" />;\n}\n```"
          ],
          "analysisPoints": [
            "Tests understanding of how to pass fixed props and forward remaining props (`...props`).",
            "Ensures correct usage of the generic component within the specialized one.",
            "Differentiates between specialization and recreating component logic.",
            "Identifies common pitfalls like not forwarding `props`."
          ],
          "keyConcepts": [
            "Component Specialization",
            "Prop Forwarding",
            "Generic Components"
          ],
          "evaluationCriteria": [
            "Correct use of `...props` for forwarding",
            "Proper embedding of the generic component",
            "Adherence to the specialization pattern"
          ],
          "example": "The correct option creates a `PasswordInput` functional component that internally renders the generic `Input` component. It explicitly sets `type=\"password\"` and `placeholder=\"Enter password\"` for this specialized version. Crucially, it uses `{...props}` to forward any additional props (like `value`, `onChange`, `id`, `name`, etc.) that might be passed to `PasswordInput` down to the `Input` component, making it flexible.",
          "tags": [
            "Component Specialization",
            "React",
            "Code Example",
            "Pattern"
          ],
          "prerequisites": [
            "react_components",
            "react_props"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_specialization_3",
          "topic": "Component Specialization Use Cases",
          "level": "medium",
          "type": "open",
          "question": "Beyond simple UI elements like buttons, describe a more complex scenario where the Component Specialization pattern would be beneficial. Explain how it would simplify development and maintain consistency.",
          "answer": "A more complex scenario for Component Specialization would be creating different types of 'Card' components in a design system. Imagine a generic `Card` component that accepts props for `header`, `body`, `footer`, `image`, `actions`, `variant` (e.g., 'elevated', 'outlined'), `size` (e.g., 'small', 'medium', 'large'), etc.\n\n### Scenario: Different Card Types\nWe might need specific card types for different parts of an application:\n1.  **Product Card**: Displays product image, name, price, and an 'Add to Cart' button.\n2.  **User Profile Card**: Shows user avatar, name, email, and a 'View Profile' link.\n3.  **Information Alert Card**: A simple card with an icon, a title, and a descriptive message, often with a dismiss button.\n\n### How Specialization Helps:\nInstead of recreating the `Card` structure and styling for each type, we can specialize:\n\n```javascript\n// Generic Card component (simplified for example)\nfunction Card({ children, variant = 'elevated', className = '', ...rest }) {\n  const baseClasses = 'p-4 rounded-lg shadow-md';\n  const variantClasses = variant === 'outlined' ? 'border border-gray-300' : 'bg-white';\n  return (\n    <div className={`${baseClasses} ${variantClasses} ${className}`} {...rest}>\n      {children}\n    </div>\n  );\n}\n\n// Specialized ProductCard\nfunction ProductCard({ product, onAddToCart, ...rest }) {\n  return (\n    <Card className=\"w-64\" {...rest}>\n      <img src={product.imageUrl} alt={product.name} className=\"w-full h-40 object-cover mb-4\" />\n      <h3 className=\"text-lg font-bold mb-2\">{product.name}</h3>\n      <p className=\"text-gray-700 mb-4\">${product.price.toFixed(2)}</p>\n      <button onClick={() => onAddToCart(product.id)} className=\"bg-blue-500 text-white px-4 py-2 rounded\">Add to Cart</button>\n    </Card>\n  );\n}\n\n// Specialized InfoAlertCard\nfunction InfoAlertCard({ title, message, onDismiss, ...rest }) {\n    return (\n        <Card variant=\"outlined\" className=\"border-blue-400 bg-blue-50\" {...rest}>\n            <div className=\"flex items-center mb-2\">\n                <span className=\"text-blue-600 mr-2\"></span>\n                <h4 className=\"font-semibold text-blue-800\">{title}</h4>\n            </div>\n            <p className=\"text-blue-700 text-sm mb-4\">{message}</p>\n            {onDismiss && <button onClick={onDismiss} className=\"text-blue-600 text-sm\">Dismiss</button>}\n        </Card>\n    );\n}\n```\n\n### Simplification and Consistency:\n-   **Simplification**: Developers using `ProductCard` don't need to know all the internal `Card` props or structure. They just pass `product` and `onAddToCart`. This simplifies the API for common card types.\n-   **Consistency**: All specialized cards automatically inherit the base styling and structure from the `Card` component. If the base `Card` styling changes (e.g., border-radius, shadow), all specialized cards update automatically. Specific visual treatments (like `InfoAlertCard`'s blue border) are encapsulated within their specialized component.\n-   **Maintainability**: Changes to the core card layout or default behaviors are made in one place (`Card`), propagating consistently across the application.\n-   **Reusability**: `Card` is reusable generically, and `ProductCard`, `InfoAlertCard` are reusable in their specific contexts.",
          "options": [],
          "analysisPoints": [
            "Ability to apply the pattern to a non-trivial, real-world scenario.",
            "Demonstrates understanding of benefits beyond simple prop reduction.",
            "Highlights aspects like consistency, maintainability, and API simplification."
          ],
          "keyConcepts": [
            "Component Specialization",
            "Design System",
            "Reusability",
            "API Design",
            "Consistency"
          ],
          "evaluationCriteria": [
            "Clarity and complexity of the chosen scenario",
            "Detailed explanation of how the pattern applies",
            "Articulation of specific benefits in the scenario"
          ],
          "example": "",
          "tags": [
            "Component Specialization",
            "Design Patterns",
            "Advanced",
            "System Design"
          ],
          "prerequisites": [
            "theory_component_specialization",
            "react_props"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_specialization_4",
          "topic": "Component Specialization vs. Direct Prop Usage",
          "level": "easy",
          "type": "mcq",
          "question": "Consider a `Button` component that accepts a `variant` prop ('primary', 'secondary', 'danger'). Why might you choose to create a `PrimaryButton` specialized component (e.g., `<PrimaryButton>Click</PrimaryButton>`) instead of always using `<Button variant=\"primary\">Click</Button>` directly?",
          "answer": "To improve readability, provide semantic meaning, and reduce repetitive prop passing for common button types.",
          "options": [
            "To improve performance by reducing rendering overhead.",
            "To enforce stricter type checking at compile time.",
            "To allow `PrimaryButton` to have entirely different internal logic.",
            "To improve readability, provide semantic meaning, and reduce repetitive prop passing for common button types."
          ],
          "analysisPoints": [
            "Tests understanding of the 'why' behind specialization.",
            "Distinguishes benefits like readability and reduced boilerplate from technical performance or type-checking aspects.",
            "Emphasizes developer experience improvements."
          ],
          "keyConcepts": [
            "Component Specialization",
            "Readability",
            "DRY Principle",
            "Semantic Components"
          ],
          "evaluationCriteria": [
            "Correct identification of the pattern's benefits",
            "Ability to differentiate from incorrect or unrelated advantages"
          ],
          "example": "The primary reasons for creating a specialized `PrimaryButton` are improved code readability and maintainability. It makes the intent clearer (`<PrimaryButton>` vs. `<Button variant=\"primary\">`) and reduces the amount of boilerplate props that need to be passed every time a primary button is used. It's not primarily for performance or type checking, nor does it imply completely different internal logic from the generic component.",
          "tags": [
            "Component Specialization",
            "Best Practices",
            "Readability",
            "DRY"
          ],
          "prerequisites": [
            "theory_component_specialization"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_render_props_1",
          "topic": "Render Props Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the defining characteristic of the Render Props pattern in React?",
          "answer": "A component uses a prop (often named `render` or `children`) whose value is a function, which it calls to render its content, passing internal state/data as arguments.",
          "options": [],
          "analysisPoints": [
            "Checks understanding of the pattern's core mechanism.",
            "Highlights the 'function as a prop' concept."
          ],
          "keyConcepts": [
            "Render Props",
            "Function as Prop",
            "React Patterns"
          ],
          "evaluationCriteria": [
            "Ability to recall core definition",
            "Understanding of render prop mechanism"
          ],
          "example": "",
          "tags": [
            "Render Props",
            "React",
            "Basics"
          ],
          "prerequisites": [
            "react_components",
            "react_props"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_render_props_2",
          "topic": "Render Props Usage",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `WindowSize` component using the Render Props pattern:\n\n```javascript\nimport React, { useState, useEffect } from 'react';\n\nfunction WindowSize({ render }) {\n  const [size, setSize] = useState({ width: window.innerWidth, height: window.innerHeight });\n\n  useEffect(() => {\n    const handleResize = () => setSize({ width: window.innerWidth, height: window.innerHeight });\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return render(size);\n}\n```\n\nWhich code snippet correctly uses the `WindowSize` component to display the window's dimensions?",
          "answer": "```javascript\n<WindowSize\n  render={({ width, height }) => (\n    <div>\n      Window Width: {width}px, Height: {height}px\n    </div>\n  )}\n/>\n```",
          "options": [
            "```javascript\n<WindowSize>\n  {({ width, height }) => (\n    <div>\n      Window Width: {width}px, Height: {height}px\n    </div>\n  )}\n</WindowSize>\n```",
            "```javascript\n<WindowSize\n  render={({ width, height }) => (\n    <div>\n      Window Width: {width}px, Height: {height}px\n    </div>\n  )}\n/>\n```",
            "```javascript\n<WindowSize width=\"{width}\" height=\"{height}\" />\n```",
            "```javascript\nconst { width, height } = WindowSize();\n<div>Window Width: {width}px, Height: {height}px</div>\n```"
          ],
          "analysisPoints": [
            "Tests understanding of passing a function as a prop (`render`).",
            "Ensures correct destructuring of arguments passed by the render prop function.",
            "Differentiates between a named render prop and `children` as a render prop (Option A).",
            "Avoids common mistakes of passing strings or calling component as a hook."
          ],
          "keyConcepts": [
            "Render Props",
            "Prop Types",
            "Functional Components",
            "State Management"
          ],
          "evaluationCriteria": [
            "Correct syntax for render prop usage",
            "Proper function argument destructuring",
            "Understanding of how the parent component receives data"
          ],
          "example": "The correct option explicitly passes a function to the `render` prop. This function receives the `size` object (destructured into `width` and `height`) as its argument, which is then used to render the desired UI. Option A would be correct if `WindowSize` component rendered `this.props.children(size)` instead of `this.props.render(size)`. Options C and D are incorrect ways to use the render props pattern.",
          "tags": [
            "Render Props",
            "React",
            "Usage",
            "Pattern"
          ],
          "prerequisites": [
            "theory_render_props",
            "react_hooks_useState_useEffect"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_render_props_3",
          "topic": "Render Props Implementation",
          "level": "medium",
          "type": "code",
          "question": "Create a React component called `VisibilitySensor` that uses the Render Props pattern. This component should track whether it's currently in the viewport. It should accept a `children` prop which is a function. This function should receive a boolean `isVisible` as an argument. Use the `IntersectionObserver` API to determine visibility.",
          "answer": "```typescript\nimport React, { useRef, useState, useEffect } from 'react';\n\nfunction VisibilitySensor({ children }) {\n  const [isVisible, setIsVisible] = useState(false);\n  const elementRef = useRef(null);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        setIsVisible(entry.isIntersecting);\n      },\n      { threshold: 0.1 } // Trigger when 10% of the element is visible\n    );\n\n    if (elementRef.current) {\n      observer.observe(elementRef.current);\n    }\n\n    return () => {\n      if (elementRef.current) {\n        observer.unobserve(elementRef.current);\n      }\n      observer.disconnect();\n    };\n  }, []);\n\n  return (\n    <div ref={elementRef}>\n      {children(isVisible)}\n    </div>\n  );\n}\n\n// Example Usage:\nfunction App() {\n  return (\n    <div>\n      <p style={{ height: '100vh', background: '#eee' }}>Scroll down to see the sensor!</p>\n      <VisibilitySensor>\n        {(isVisible) => (\n          <div style={{ padding: '20px', border: '1px solid black', marginBottom: '20px' }}>\n            <h2>Visibility Status: {isVisible ? 'Visible' : 'Not Visible'}</h2>\n            {isVisible && <p>You can see me now!</p>}\n          </div>\n        )}\n      </VisibilitySensor>\n      <p style={{ height: '100vh', background: '#eee' }}>Scroll further!</p>\n    </div>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to implement the Render Props pattern using `children` as a function.",
            "Requires knowledge of `useState`, `useEffect`, `useRef` hooks.",
            "Demonstrates practical application of `IntersectionObserver`.",
            "Ensures correct cleanup for `useEffect`."
          ],
          "keyConcepts": [
            "Render Props",
            "IntersectionObserver",
            "React Hooks",
            "Refs",
            "Lifecycle"
          ],
          "evaluationCriteria": [
            "Correct `children` as render prop implementation",
            "Accurate `IntersectionObserver` setup and cleanup",
            "Proper state management for `isVisible`",
            "Effective use of `useRef` for DOM element reference"
          ],
          "example": "The solution implements `VisibilitySensor` which uses a `ref` to attach an `IntersectionObserver`. The observer updates the `isVisible` state. The component then calls `children(isVisible)`, passing the visibility status to its consumer. The `useEffect` hook ensures the observer is set up and cleaned up correctly.",
          "tags": [
            "Render Props",
            "React",
            "Coding Challenge",
            "IntersectionObserver",
            "Advanced"
          ],
          "prerequisites": [
            "theory_render_props",
            "react_hooks_useState_useEffect_useRef",
            "web_apis_intersection_observer"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_render_props_4",
          "topic": "Render Props vs. HOCs for Logic Reuse",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast the Render Props pattern with Higher-Order Components (HOCs) specifically for the purpose of sharing reusable component logic. Discuss when you might choose one over the other, considering their respective strengths and weaknesses.",
          "answer": "### Comparison of Render Props vs. HOCs for Logic Reuse:\n\n**Higher-Order Components (HOCs):**\n*   **Concept**: A function that takes a component and returns a new component (a wrapper).\n*   **Logic Sharing**: Injects props or modifies existing props to the wrapped component.\n*   **Pros**: \n    *   Can simplify components by abstracting away data fetching or complex prop transformations.\n    *   Useful for static enhancements that apply generally.\n*   **Cons**: \n    *   **Wrapper Hell**: Creates extra layers in the component tree, making debugging harder.\n    *   **Prop Collisions**: Risk of name clashes if HOCs and wrapped components use same prop names.\n    *   **Ref Forwarding**: Requires `React.forwardRef` to pass refs.\n    *   **Static Composition**: Logic is applied at definition time, less flexible for runtime variations.\n    *   **Indirect Props**: Consumer might not immediately know where props come from.\n\n**Render Props Pattern:**\n*   **Concept**: A component receives a function as a prop (e.g., `render` or `children`), which it calls to render its content, passing its internal state/data as arguments.\n*   **Logic Sharing**: Provides data/state directly to a function (the render prop) which then controls the rendering.\n*   **Pros**: \n    *   **Highly Flexible/Dynamic Composition**: The consumer has full control over *what* gets rendered with the shared logic/data, allowing for dynamic UI changes.\n    *   **Clear Prop Origin**: It's obvious where the data comes from (arguments to the render prop function).\n    *   **No Prop Collisions**: Data is passed as function arguments, avoiding name clashes.\n    *   **No Wrapper Hell (in tree)**: Doesn't add unnecessary nested components to the React DevTools tree for logic sharing.\n*   **Cons**: \n    *   **Nesting (Indentation) Hell**: Can lead to deeply nested JSX if many render props are used, impacting readability.\n    *   **Performance Concerns**: If the render prop function is defined inline, it can cause unnecessary re-renders of child components if not properly memoized.\n    *   **Less Intuitive for Beginners**: The concept of 'function as a prop' might require more explanation for new developers.\n\n### When to Choose Which:\n\n*   **Choose HOCs when:**\n    *   You are providing a generic, consistent behavior that wraps a component (e.g., `withAuthentication`, `withAnalytics`).\n    *   The enhancement is relatively static and doesn't require the consumer to dynamically change the UI structure based on the shared logic's state.\n    *   You are integrating with older React contexts or libraries that heavily use HOCs (e.g., older Redux `connect`).\n    *   You need to abstract away complex prop transformations.\n\n*   **Choose Render Props when:**\n    *   You need extreme flexibility in how the shared logic's data is consumed and rendered. The consumer needs full control over the UI.\n    *   You want to avoid prop collisions and deeply nested component trees in the DevTools.\n    *   The logic involves dynamic data or state (like mouse position, window size, network status) that directly influences how the UI should render.\n    *   You are building a reusable library component that exposes its internal state in a flexible way (e.g., `react-router`'s `Route` component using `children` prop in older versions).\n\n**Modern Context (React Hooks):**\nIt's important to note that React Hooks (`useState`, `useEffect`, `useContext`, custom hooks) have become the modern, preferred approach for sharing reusable logic in functional components, largely addressing the pain points of both HOCs and Render Props (like wrapper hell, prop collisions, and verbose nesting) by allowing direct access to stateful logic within the component itself. However, understanding HOCs and Render Props is crucial for legacy codebases and for understanding the evolution of React patterns.",
          "options": [],
          "analysisPoints": [
            "Thorough understanding of both patterns' mechanisms.",
            "Detailed articulation of their specific advantages and disadvantages.",
            "Insightful discussion of appropriate use cases for each.",
            "Awareness of modern alternatives (Hooks) and historical context."
          ],
          "keyConcepts": [
            "Render Props",
            "HOC",
            "Logic Reuse",
            "Composition",
            "Flexibility",
            "Debugging",
            "Performance"
          ],
          "evaluationCriteria": [
            "Depth and clarity of the comparison points",
            "Accuracy of pros and cons for each pattern",
            "Thoughtfulness of scenario-based preferences",
            "Inclusion of modern context (Hooks)"
          ],
          "example": "",
          "tags": [
            "Render Props",
            "HOC",
            "Comparison",
            "Advanced",
            "Design Patterns"
          ],
          "prerequisites": [
            "theory_render_props",
            "theory_hoc",
            "react_hooks_basics"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_render_props_5",
          "topic": "Render Props Performance",
          "level": "medium",
          "type": "mcq",
          "question": "When using the Render Props pattern, an inline function passed as the `render` prop can sometimes lead to unnecessary re-renders of the child component. Why does this happen, and what's a common React optimization technique to mitigate it?\n\n```javascript\n// Scenario:\n<DataFetcher\n  render={(data) => (\n    <DisplayComponent data={data} /> // This might re-render unnecessarily\n  )}\n/>\n\n// Assuming DisplayComponent is a functional component\n```",
          "answer": "Because the inline function creates a new function reference on every parent render, causing `DisplayComponent` to see a new prop even if `data` is the same. `React.memo` (or `useCallback` for the function itself) on `DisplayComponent` can prevent re-renders if its props haven't shallowly changed.",
          "options": [
            "Because the inline function creates a new function reference on every parent render, causing `DisplayComponent` to see a new prop even if `data` is the same. `React.memo` (or `useCallback` for the function itself) on `DisplayComponent` can prevent re-renders if its props haven't shallowly changed.",
            "Because the `render` prop is inherently slower due to function calls. Using a class component for `DisplayComponent` would solve this.",
            "It only happens if `data` itself is a new object on every render. `shouldComponentUpdate` on `DataFetcher` is needed.",
            "This is a misconception; React automatically optimizes inline functions for render props."
          ],
          "analysisPoints": [
            "Tests understanding of JavaScript reference equality.",
            "Connects function reference changes to React's re-render mechanism.",
            "Identifies `React.memo` (or `useCallback`) as the correct optimization.",
            "Dispels common myths or incorrect solutions."
          ],
          "keyConcepts": [
            "Render Props",
            "Performance Optimization",
            "React.memo",
            "useCallback",
            "Reference Equality",
            "Re-renders"
          ],
          "evaluationCriteria": [
            "Accurate explanation of the cause (new function reference)",
            "Correct identification of the mitigation technique",
            "Understanding of React's rendering lifecycle and optimizations"
          ],
          "example": "```typescript\nimport React, { useState, useEffect, memo, useCallback } from 'react';\n\n// Generic component using render props\nfunction DataFetcher({ render }) {\n  const [data, setData] = useState({ value: 'Initial' });\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      // Simulate data changing, but sometimes to the same value\n      const newValue = Math.random() > 0.5 ? 'Updated' : 'Initial';\n      setData(prev => ({ ...prev, value: newValue }));\n    }, 1000);\n    return () => clearInterval(intervalId);\n  }, []);\n\n  return render(data);\n}\n\n// Wrapped component that should only re-render if its *actual data* changes\nconst DisplayComponent = memo(({ data }) => {\n  console.log('DisplayComponent re-rendered with data:', data.value);\n  return <div>Current Data: {data.value}</div>;\n});\n\n// Usage with memoized render prop function\nfunction App() {\n  // This useCallback ensures the render function itself is stable\n  const memoizedRenderProp = useCallback(\n    (data) => <DisplayComponent data={data} />,\n    [] // No dependencies, as DisplayComponent props only depend on `data` from DataFetcher\n  );\n\n  return (\n    <div>\n      <DataFetcher render={memoizedRenderProp} />\n    </div>\n  );\n}\n```\nThe `DisplayComponent` is wrapped with `React.memo`. If the `render` prop function were defined inline as `render={(data) => <DisplayComponent data={data} />}`, even if `data.value` remains 'Initial', `DisplayComponent` would re-render because the *function itself* (`(data) => ...`) is a new reference on every `DataFetcher` re-render. By using `useCallback` for the `render` prop function, we stabilize the function reference, allowing `React.memo` on `DisplayComponent` to effectively prevent unnecessary re-renders when `data` (specifically `data.value`) hasn't shallowly changed.",
          "tags": [
            "Render Props",
            "Performance",
            "React.memo",
            "useCallback",
            "Optimization"
          ],
          "prerequisites": [
            "theory_render_props",
            "react_hooks_useState_useEffect",
            "react_memo",
            "react_useCallback"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_hoc_auth_logger",
          "title": "Implement an Authentication and Logging HOC",
          "description": "\nImplement two Higher-Order Components (HOCs):\n\n1.  **`withAuth(WrappedComponent)`**: This HOC should check if a user is authenticated. It should receive a `isAuthenticated` boolean prop. If `isAuthenticated` is `false`, it should render a \"Please log in to view this content.\" message. Otherwise, it should render the `WrappedComponent` with all its original props (except `isAuthenticated`).\n2.  **`withLogger(WrappedComponent)`**: This HOC should log a message to the console every time the `WrappedComponent` mounts and unmounts. The message should include the `WrappedComponent`'s display name. Use `useEffect` for lifecycle logging within the HOC.\n\nThen, apply both HOCs to a simple `Dashboard` component. The `Dashboard` component should just display \"Welcome to the Dashboard!\".\n\n**Requirements:**\n-   `withAuth` consumes `isAuthenticated` prop.\n-   `withLogger` logs mount/unmount events.\n-   Both HOCs correctly forward other props.\n-   Set `displayName` for wrapped components for better debugging.\n-   Demonstrate nested HOC usage on the `Dashboard` component.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// 1. Implement withAuth HOC here\nconst withAuth = (WrappedComponent) => {\n  // Your implementation\n};\n\n// 2. Implement withLogger HOC here\nconst withLogger = (WrappedComponent) => {\n  // Your implementation\n};\n\n// Simple Dashboard component\nconst Dashboard = ({ userName }) => {\n  return <div>Welcome to the Dashboard, {userName}!</div>;\n};\n\n// Apply HOCs here and render in App\nfunction App() {\n  const [loggedIn, setLoggedIn] = useState(false);\n  const [showDashboard, setShowDashboard] = useState(false);\n\n  // Your component usage here\n  // const AuthLoggedDashboard = ???\n\n  return (\n    <div>\n      <h1>HOC Demo</h1>\n      <button onClick={() => setLoggedIn(!loggedIn)}>\n        {loggedIn ? 'Log Out' : 'Log In'}\n      </button>\n      <button onClick={() => setShowDashboard(!showDashboard)}>\n        {showDashboard ? 'Hide Dashboard' : 'Show Dashboard'}\n      </button>\n\n      {showDashboard && (\n        <div>\n          {/* Render your HOC-wrapped component here */}\n          {/* Example: <AuthLoggedDashboard isAuthenticated={loggedIn} userName=\"Guest\" /> */}\n        </div>\n      )}\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// 1. Implement withAuth HOC here\nconst withAuth = (WrappedComponent) => {\n  const WithAuthComponent = ({ isAuthenticated, ...restProps }) => {\n    if (!isAuthenticated) {\n      return <div>Please log in to view this content.</div>;\n    }\n    return <WrappedComponent {...restProps} />;\n  };\n  WithAuthComponent.displayName = `withAuth(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return WithAuthComponent;\n};\n\n// 2. Implement withLogger HOC here\nconst withLogger = (WrappedComponent) => {\n  const WithLoggerComponent = (props) => {\n    useEffect(() => {\n      const componentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n      console.log(`${componentName} mounted.`);\n      return () => {\n        console.log(`${componentName} unmounted.`);\n      };\n    }, []);\n\n    return <WrappedComponent {...props} />;\n  };\n  WithLoggerComponent.displayName = `withLogger(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return WithLoggerComponent;\n};\n\n// Simple Dashboard component\nconst Dashboard = ({ userName }) => {\n  return <div>Welcome to the Dashboard, {userName}!</div>;\n};\n\n// Apply HOCs here and render in App\nconst AuthLoggedDashboard = withAuth(withLogger(Dashboard));\n\nfunction App() {\n  const [loggedIn, setLoggedIn] = useState(false);\n  const [showDashboard, setShowDashboard] = useState(false);\n\n  return (\n    <div>\n      <h1>HOC Demo</h1>\n      <button onClick={() => setLoggedIn(!loggedIn)}>\n        {loggedIn ? 'Log Out' : 'Log In'}\n      </button>\n      <button onClick={() => setShowDashboard(!showDashboard)}>\n        {showDashboard ? 'Hide Dashboard' : 'Show Dashboard'}\n      </button>\n\n      {showDashboard && (\n        <div>\n          <AuthLoggedDashboard isAuthenticated={loggedIn} userName=\"Guest\" />\n        </div>\n      )}\n    </div>\n  );\n}\n",
          "testCases": [
            "Initially, when `showDashboard` is true and `loggedIn` is false, it should display 'Please log in to view this content.'.",
            "When `loggedIn` becomes true, it should display 'Welcome to the Dashboard, Guest!'.",
            "Check console logs: When dashboard mounts (showDashboard true, loggedIn true), 'Dashboard mounted.' should appear. When it unmounts (showDashboard false or loggedIn false), 'Dashboard unmounted.' should appear.",
            "Ensure `userName` prop is correctly passed to `Dashboard` component."
          ],
          "hints": [
            "Remember that a HOC returns a new component, which receives the props that would normally go to the original component.",
            "Use prop destructuring (`{ propName, ...restProps }`) to easily consume specific props and pass the rest.",
            "For `withLogger`, `useEffect` with an empty dependency array (`[]`) and a cleanup function (`return () => ...`) is perfect for mount/unmount logging.",
            "Don't forget to set `displayName` for the returned HOC component for better debugging."
          ],
          "tags": [
            "HOC",
            "React",
            "Authentication",
            "Logging",
            "Composition"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_hoc",
            "react_hooks_useState_useEffect",
            "react_components",
            "javascript_destructuring"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "cross_cutting_concerns",
            "component_lifecycle",
            "prop_drilling"
          ]
        },
        {
          "id": "task_input_specialization",
          "title": "Create Specialized Input Components",
          "description": "\nImplement a generic `TextInput` component that accepts standard HTML input attributes (`type`, `placeholder`, `value`, `onChange`, `className`, etc.). Then, using the Component Specialization pattern, create the following specialized components:\n\n1.  **`EmailInput`**: An input pre-configured for email addresses (`type=\"email\"`, `placeholder=\"Enter your email\"`).\n2.  **`NumberInput`**: An input pre-configured for numerical values (`type=\"number\"`, `placeholder=\"Enter a number\"`).\n3.  **`SearchInput`**: An input pre-configured for search queries (`type=\"search\"`, `placeholder=\"Search...\"`, and a default `aria-label=\"Search input\"`).\n\nAll specialized components should correctly forward any additional props passed to them to the underlying `TextInput` component.\n\n**Requirements:**\n-   Generic `TextInput` is flexible.\n-   Specialized components use `TextInput` internally.\n-   Correctly set fixed props for each specialized component.\n-   All other props are forwarded using `...props`.\n-   Demonstrate usage of all components in an `App` component.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// Generic TextInput component\nfunction TextInput({ type = 'text', className = '', ...rest }) {\n  return (\n    <input \n      type={type} \n      className={`border p-2 rounded ${className}`}\n      {...rest} \n    />\n  );\n}\n\n// 1. Implement EmailInput here\n// function EmailInput(props) { /* ... */ }\n\n// 2. Implement NumberInput here\n// function NumberInput(props) { /* ... */ }\n\n// 3. Implement SearchInput here\n// function SearchInput(props) { /* ... */ }\n\nfunction App() {\n  const [email, setEmail] = useState('');\n  const [quantity, setQuantity] = useState(0);\n  const [searchQuery, setSearchQuery] = useState('');\n\n  return (\n    <div className=\"p-4 space-y-4\">\n      <h2>Input Specialization Demo</h2>\n\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        {/* Use EmailInput here */}\n        {/* <EmailInput id=\"email\" value={email} onChange={(e) => setEmail(e.target.value)} /> */}\n        <p>Value: {email}</p>\n      </div>\n\n      <div>\n        <label htmlFor=\"quantity\">Quantity:</label>\n        {/* Use NumberInput here */}\n        {/* <NumberInput id=\"quantity\" value={quantity} onChange={(e) => setQuantity(Number(e.target.value))} min=\"0\" max=\"100\" /> */}\n        <p>Value: {quantity}</p>\n      </div>\n\n      <div>\n        <label htmlFor=\"search\">Search:</label>\n        {/* Use SearchInput here */}\n        {/* <SearchInput id=\"search\" value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} /> */}\n        <p>Value: {searchQuery}</p>\n      </div>\n\n      <div>\n        <h3>Generic Input Usage:</h3>\n        <TextInput placeholder=\"Any text\" />\n      </div>\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState } from 'react';\n\n// Generic TextInput component\nfunction TextInput({ type = 'text', className = '', ...rest }) {\n  return (\n    <input \n      type={type} \n      className={`border p-2 rounded ${className}`}\n      {...rest} \n    />\n  );\n}\n\n// 1. Implement EmailInput here\nfunction EmailInput(props) {\n  return <TextInput type=\"email\" placeholder=\"Enter your email\" {...props} />;\n}\n\n// 2. Implement NumberInput here\nfunction NumberInput(props) {\n  return <TextInput type=\"number\" placeholder=\"Enter a number\" {...props} />;\n}\n\n// 3. Implement SearchInput here\nfunction SearchInput(props) {\n  return <TextInput type=\"search\" placeholder=\"Search...\" aria-label=\"Search input\" {...props} />;\n}\n\nfunction App() {\n  const [email, setEmail] = useState('');\n  const [quantity, setQuantity] = useState(0);\n  const [searchQuery, setSearchQuery] = useState('');\n\n  return (\n    <div className=\"p-4 space-y-4\">\n      <h2>Input Specialization Demo</h2>\n\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <EmailInput id=\"email\" value={email} onChange={(e) => setEmail(e.target.value)} />\n        <p>Value: {email}</p>\n      </div>\n\n      <div>\n        <label htmlFor=\"quantity\">Quantity:</label>\n        <NumberInput id=\"quantity\" value={quantity} onChange={(e) => setQuantity(Number(e.target.value))} min=\"0\" max=\"100\" />\n        <p>Value: {quantity}</p>\n      </div>\n\n      <div>\n        <label htmlFor=\"search\">Search:</label>\n        <SearchInput id=\"search\" value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} />\n        <p>Value: {searchQuery}</p>\n      </div>\n\n      <div>\n        <h3>Generic Input Usage:</h3>\n        <TextInput placeholder=\"Any text\" />\n      </div>\n    </div>\n  );\n}\n",
          "testCases": [
            "Verify `EmailInput`'s `type` attribute is 'email' in the DOM.",
            "Verify `NumberInput`'s `type` attribute is 'number' in the DOM.",
            "Verify `SearchInput`'s `type` attribute is 'search' and `aria-label` is 'Search input' in the DOM.",
            "Ensure `EmailInput` correctly updates `email` state on change.",
            "Ensure `NumberInput` correctly updates `quantity` state on change and respects `min`/`max` (if browser enforces).",
            "Ensure `SearchInput` correctly updates `searchQuery` state on change.",
            "Confirm that additional props like `id`, `value`, `onChange`, `min`, `max` are correctly passed through to the underlying `input` element for all specialized components."
          ],
          "hints": [
            "The specialized components should be simple functional components.",
            "Remember to pass all incoming props to the generic `TextInput` using the spread operator (`{...props}`).",
            "The fixed props (like `type` or `placeholder`) should be explicitly set on the `TextInput` when rendered by the specialized component."
          ],
          "tags": [
            "Component Specialization",
            "React",
            "Forms",
            "Reusability",
            "UI Components"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_component_specialization",
            "react_components",
            "react_props"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "DRY_principle",
            "design_systems",
            "semantic_html"
          ]
        },
        {
          "id": "task_theme_switcher",
          "title": "Build a Theme Switcher with Render Props",
          "description": "\nCreate a `ThemeContext` component using the Render Props pattern. This component should manage the current theme (e.g., 'light' or 'dark') and provide a way to toggle it.\n\n**Requirements:**\n1.  **`ThemeContext` Component**: \n    *   Manages a `theme` state ('light' initially).\n    *   Provides a `toggleTheme` function that switches between 'light' and 'dark'.\n    *   Uses the `children` prop as a render prop. The `children` function should receive an object `{ theme, toggleTheme }` as arguments.\n2.  **Usage in `App`**: \n    *   Wrap your main application content with `ThemeContext`.\n    *   Inside the `ThemeContext`'s `children` function, render a `ThemeDisplay` component and a `ThemeToggleButton` component.\n3.  **`ThemeDisplay` Component**: Displays the current `theme` (e.g., \"Current Theme: Light\"). Its styling should reflect the theme (e.g., light background for light theme, dark for dark).\n4.  **`ThemeToggleButton` Component**: A button that calls `toggleTheme` when clicked.\n\nThis task demonstrates how `ThemeContext` encapsulates the theme logic, while `ThemeDisplay` and `ThemeToggleButton` are responsible for UI, receiving the necessary data/functions via render props.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// 1. Implement ThemeContext component here\n// function ThemeContext({ children }) {\n//   const [theme, setTheme] = useState('light');\n//   const toggleTheme = () => {\n//     setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));\n//   };\n//   return children({ theme, toggleTheme });\n// }\n\n// 2. Implement ThemeDisplay component here\n// function ThemeDisplay({ theme }) { /* ... */ }\n\n// 3. Implement ThemeToggleButton component here\n// function ThemeToggleButton({ toggleTheme }) { /* ... */ }\n\nfunction App() {\n  return (\n    // Use ThemeContext here\n    // <ThemeContext>\n    //   {({ theme, toggleTheme }) => (\n    //     <div style={{ \n    //       background: theme === 'light' ? '#fff' : '#333',\n    //       color: theme === 'light' ? '#333' : '#fff',\n    //       minHeight: '100vh',\n    //       padding: '20px'\n    //     }}>\n    //       <h1>Theme Switcher Demo</h1>\n    //       {/* Render ThemeDisplay and ThemeToggleButton here */}\n    //     </div>\n    //   )}\n    // </ThemeContext>\n    <div>\n        <p>Starter code for App component</p>\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState } from 'react';\n\n// 1. Implement ThemeContext component here\nfunction ThemeContext({ children }) {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));\n  };\n\n  // children is the render prop function\n  return children({ theme, toggleTheme });\n}\n\n// 2. Implement ThemeDisplay component here\nfunction ThemeDisplay({ theme }) {\n  const displayStyle = {\n    padding: '10px',\n    border: '1px solid',\n    borderColor: theme === 'light' ? '#ccc' : '#666',\n    background: theme === 'light' ? '#f0f0f0' : '#444',\n    color: theme === 'light' ? '#333' : '#eee',\n    marginBottom: '10px'\n  };\n\n  return (\n    <div style={displayStyle}>\n      <h2>Current Theme: {theme.charAt(0).toUpperCase() + theme.slice(1)}</h2>\n      <p>This component's style reflects the current theme.</p>\n    </div>\n  );\n}\n\n// 3. Implement ThemeToggleButton component here\nfunction ThemeToggleButton({ toggleTheme }) {\n  return (\n    <button \n      onClick={toggleTheme} \n      style={{\n        padding: '10px 20px',\n        fontSize: '16px',\n        cursor: 'pointer',\n        background: '#007bff',\n        color: 'white',\n        border: 'none',\n        borderRadius: '5px'\n      }}\n    >\n      Toggle Theme\n    </button>\n  );\n}\n\nfunction App() {\n  return (\n    <ThemeContext>\n      {({ theme, toggleTheme }) => (\n        <div style={{\n          background: theme === 'light' ? '#fff' : '#222',\n          color: theme === 'light' ? '#333' : '#fff',\n          minHeight: '100vh',\n          padding: '20px',\n          fontFamily: 'Arial, sans-serif'\n        }}>\n          <h1>Theme Switcher Demo</h1>\n          <ThemeDisplay theme={theme} />\n          <ThemeToggleButton toggleTheme={toggleTheme} />\n          <p style={{ marginTop: '20px' }}>\n            The background and text color of this page change with the theme.\n          </p>\n        </div>\n      )}\n    </ThemeContext>\n  );\n}\n",
          "testCases": [
            "Initial render: Background should be light, text dark. Theme display should show 'Current Theme: Light'.",
            "Click 'Toggle Theme' button: Background should switch to dark, text to light. Theme display should show 'Current Theme: Dark'.",
            "Click 'Toggle Theme' again: Should switch back to light theme.",
            "Ensure `ThemeDisplay` and `ThemeToggleButton` receive correct `theme` and `toggleTheme` props from the `ThemeContext`'s render prop."
          ],
          "hints": [
            "The `ThemeContext` component needs `useState` to manage the `theme`.",
            "The `children` prop in `ThemeContext` will be a function. Remember to call it and pass the `theme` and `toggleTheme` values.",
            "You can use inline styles or simple class names to make `ThemeDisplay` visually change with the theme.",
            "Ensure the `toggleTheme` function correctly flips between 'light' and 'dark'."
          ],
          "tags": [
            "Render Props",
            "React",
            "State Management",
            "UI/UX",
            "Theming"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_render_props",
            "react_hooks_useState",
            "react_components"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "context_api",
            "separation_of_concerns",
            "dynamic_ui"
          ]
        }
      ]
    }
  }
]