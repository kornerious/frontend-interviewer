[
  {
    "id": "f5b48cca-63de-4855-b694-e79e62ebf099",
    "startLine": 5300,
    "endLine": 5399,
    "processedDate": "2025-06-17T09:30:24.703Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_jest_react_basics",
          "title": "Jest and React Testing Library Fundamentals",
          "content": "Jest is a powerful JavaScript testing framework that is widely used for React applications. It is known for its simplicity and 'batteries-included' approach, providing a complete testing solution out of the box, including assertion libraries, mocking capabilities, and test runners.\n\nReact Testing Library (RTL) is a set of utilities that help test React components by interacting with them in a way that resembles how real users would. Its guiding principle is to make tests reflect actual user behavior as closely as possible, discouraging reliance on component internals (like state or props).\n\n### Key Concepts:\n*   **`render` function (from `@testing-library/react`):** Renders a React component into a Document Object Model (DOM) container and returns a set of utilities to query that DOM. This function is the primary way to mount components for testing.\n*   **Queries (e.g., `getByRole`, `getByText`, `queryByTestId`):** RTL provides various query functions to find elements in the rendered DOM. `getByRole` is highly recommended as it encourages semantic HTML and helps ensure accessibility, simulating how assistive technologies would interact with the page.\n    *   `getByRole(role, options)`: Finds an element by its ARIA role (e.g., 'button', 'heading', 'navigation').\n    *   `getByText(text, options)`: Finds an element that contains the given text content.\n    *   `queryBy...`: Similar to `getBy...` but returns `null` if no element is found, instead of throwing an error. Useful for asserting an element is *not* present.\n    *   `findBy...`: Asynchronous versions of `getBy...`, useful for waiting for elements to appear in the DOM (e.g., after an API call).\n*   **`expect` and Matchers:** Jest provides `expect` to make assertions about values. Matchers are functions chained to `expect` that perform the actual comparison or check.\n    *   `toBeInTheDocument()`: Checks if an element exists within the document (provided by `@testing-library/jest-dom`).\n    *   `toHaveTextContent(text)`: Checks if an element contains the specified text content.\n*   **`describe` block:** A way to group related tests together. It often represents a component or a specific feature being tested.\n*   **`it` (or `test`) block:** Defines an individual test case. It should describe a single, specific behavior or outcome.",
          "examples": [
            {
              "id": "example_jest_react_basics_1",
              "title": "Basic Component Rendering and Assertion",
              "code": "import React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport MyComponent from './MyComponent';\n\ndescribe('MyComponent', () => {\n  it('should render the title and content correctly', () => {\n    render(<MyComponent title=\"Welcome\" content=\"Hello World\" />);\n    // Using getByRole for semantic elements\n    expect(screen.getByRole('heading', { level: 1 })).toHaveTextContent('Welcome');\n    // Using getByText for general text content\n    expect(screen.getByText('Hello World')).toBeInTheDocument();\n  });\n\n  it('should display a default message when no content is provided', () => {\n    render(<MyComponent title=\"Empty\" />);\n    expect(screen.getByText(/no content available/i)).toBeInTheDocument();\n  });\n});\n\n// MyComponent.jsx (for context)\n// import React from 'react';\n// const MyComponent = ({ title, content }) => (\n//   <div>\n//     <h1>{title}</h1>\n//     {content ? <p>{content}</p> : <p>No content available.</p>}\n//   </div>\n// );\n// export default MyComponent;\n",
              "explanation": "This example demonstrates how to render a simple React component (`MyComponent`) using `render` from React Testing Library. It then uses `screen.getByRole` to find a heading and `toHaveTextContent` to assert its text, and `screen.getByText` with `toBeInTheDocument` to check for paragraph text. The second test case shows how to test a default behavior when a prop is missing, using a regex for text matching.",
              "language": "typescript"
            },
            {
              "id": "example_jest_react_basics_2",
              "title": "Querying for specific HTML elements",
              "code": "import React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport Header from './Header';\n\ndescribe('Header component', () => {\n  it('renders correctly with a given title', () => {\n    // Render the Header component with a specific title prop\n    const { getByRole } = render(<Header title=\"Test Title\" />);\n    // Assert that a heading element (h1, h2, etc.) contains the title text\n    expect(getByRole('heading')).toHaveTextContent('Test Title');\n  });\n\n  it('contains a navigation menu', () => {\n    // Render the Header component (without title, if optional)\n    const { getByRole } = render(<Header />);\n    // Assert that an element with the 'navigation' ARIA role is present in the document\n    expect(getByRole('navigation')).toBeInTheDocument();\n  });\n});\n\n// Header.jsx (for context)\n// import React from 'react';\n// const Header = ({ title }) => (\n//   <header>\n//     <h1>{title || 'Default Header'}</h1>\n//     <nav aria-label=\"Main navigation\">\n//       <ul>\n//         <li>Home</li>\n//         <li>About</li>\n//       </ul>\n//     </nav>\n//   </header>\n// );\n// export default Header;\n",
              "explanation": "This example, directly from the provided markdown, illustrates basic component testing. It uses `getByRole` to locate elements based on their semantic roles (`heading` and `navigation`) which is a best practice for accessibility and robust tests. `toHaveTextContent` verifies the text within the heading, and `toBeInTheDocument` confirms the presence of the navigation element.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_jest_react_basics_1",
            "question_jest_react_basics_2",
            "question_jest_react_basics_3",
            "question_jest_react_basics_4"
          ],
          "relatedTasks": [
            "task_jest_react_basics_1",
            "task_jest_react_basics_2"
          ],
          "tags": [
            "Jest",
            "React Testing Library",
            "Unit Testing",
            "Frontend Testing",
            "TDD",
            "Accessibility"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "JavaScript ES6+",
            "HTML DOM"
          ],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Component Testing",
            "Integration Testing"
          ]
        },
        {
          "id": "theory_mock_functions",
          "title": "Mock Functions in React Tests",
          "content": "Mock functions in Jest allow you to test the links between code by erasing the actual implementation of a function, capturing calls to it, and allowing you to specify return values. This is crucial for isolating the unit under test and ensuring your tests are focused and fast.\n\n### Key Concepts:\n*   **`jest.fn()`:** Creates a mock function. By default, it's an empty function, but you can configure its behavior (e.g., return values, implementations).\n*   **`fireEvent` (from `@testing-library/react`):** A utility to simulate DOM events (e.g., `click`, `change`, `submit`). It dispatches native browser events, making tests more realistic.\n*   **Mock Matchers:** Jest provides specific matchers for mock functions:\n    *   `toHaveBeenCalled()`: Asserts that the mock function was called at least once.\n    *   `toHaveBeenCalledTimes(number)`: Asserts that the mock function was called exactly `number` times.\n    *   `toHaveBeenCalledWith(...args)`: Asserts that the mock function was called with specific arguments.\n    *   `toHaveBeenLastCalledWith(...args)`: Asserts that the mock function was last called with specific arguments.\n*   **`jest.spyOn()`:** This is used to spy on an existing function (e.g., a method on an object) without changing its original implementation. It allows you to track calls to the real function. You can optionally mock the implementation with `mockImplementation()` after spying.",
          "examples": [
            {
              "id": "example_mock_functions_1",
              "title": "Testing a Button Click with a Mock Handler",
              "code": "import React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport Button from './Button';\n\ntest('calls onClick handler when clicked', () => {\n  // Create a mock function using jest.fn()\n  const handleClick = jest.fn();\n  \n  // Render the Button component, passing the mock function as the onClick prop\n  render(<Button onClick={handleClick}>Click Me</Button>);\n  \n  // Find the button element by its role and accessible name\n  const button = screen.getByRole('button', { name: /click me/i });\n  \n  // Simulate a click event on the button\n  fireEvent.click(button);\n  \n  // Assert that the mock function was called exactly once\n  expect(handleClick).toHaveBeenCalledTimes(1);\n\n  // You could also check if it was called with specific arguments if applicable\n  // expect(handleClick).toHaveBeenCalledWith('someValue');\n});\n\n// Button.jsx (for context)\n// import React from 'react';\n// const Button = ({ onClick, children }) => (\n//   <button onClick={onClick}>\n//     {children}\n//   </button>\n// );\n// export default Button;\n",
              "explanation": "This example demonstrates mocking a callback function (`onClick`) passed as a prop to a `Button` component. `jest.fn()` creates the mock. `render` mounts the component. `screen.getByRole` finds the button. `fireEvent.click` simulates a user clicking the button. Finally, `expect(handleClick).toHaveBeenCalledTimes(1)` asserts that the mock function was indeed called once, verifying the button's intended behavior without actually executing the real `onClick` logic.",
              "language": "typescript"
            },
            {
              "id": "example_mock_functions_2",
              "title": "Mocking API Calls in Component Tests",
              "code": "import React from 'react';\nimport { render, screen, waitFor } from '@testing-library/react';\nimport UserProfile from './UserProfile';\n\n// Mock the entire 'axios' module\njest.mock('axios', () => ({\n  get: jest.fn(() => Promise.resolve({ data: { name: 'Alice', email: 'alice@example.com' } }))\n}));\n\nimport axios from 'axios'; // Import after jest.mock to get the mocked version\n\ndescribe('UserProfile', () => {\n  it('should display user data fetched from API', async () => {\n    render(<UserProfile userId={123} />);\n    \n    // Verify that axios.get was called with the correct URL\n    expect(axios.get).toHaveBeenCalledWith('/api/users/123');\n    \n    // Wait for the asynchronous data to appear in the DOM\n    await waitFor(() => {\n      expect(screen.getByText('Alice')).toBeInTheDocument();\n      expect(screen.getByText('alice@example.com')).toBeInTheDocument();\n    });\n  });\n});\n\n// UserProfile.jsx (for context)\n// import React, { useEffect, useState } from 'react';\n// import axios from 'axios';\n// const UserProfile = ({ userId }) => {\n//   const [user, setUser] = useState(null);\n//   useEffect(() => {\n//     axios.get(`/api/users/${userId}`).then(response => setUser(response.data));\n//   }, [userId]);\n//   if (!user) return <div>Loading...</div>;\n//   return (\n//     <div>\n//       <h2>{user.name}</h2>\n//       <p>{user.email}</p>\n//     </div>\n//   );\n// };\n// export default UserProfile;\n",
              "explanation": "This advanced example shows how to mock an external dependency (`axios`) for testing components that perform API calls. `jest.mock('axios', ...)` replaces the entire module with a mock. The mock's `get` method is configured to return a resolved promise with mock data. This allows the `UserProfile` component to render as if data was fetched, enabling isolated testing of the component's rendering logic without making actual network requests. `waitFor` is used to handle the asynchronous update of the DOM.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_mock_functions_1",
            "question_mock_functions_2",
            "question_mock_functions_3",
            "question_mock_functions_4"
          ],
          "relatedTasks": [
            "task_mock_functions_1"
          ],
          "tags": [
            "Jest",
            "Mocking",
            "Unit Testing",
            "API Testing",
            "Frontend Testing",
            "React Testing Library"
          ],
          "technology": "React",
          "prerequisites": [
            "Jest Basics",
            "React State & Props",
            "Asynchronous JavaScript"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Integration Testing",
            "Redux Testing"
          ]
        },
        {
          "id": "theory_snapshot_testing",
          "title": "Snapshot Testing in React",
          "content": "Snapshot testing is a powerful feature of Jest that allows you to capture the rendered output of a component at a specific point in time and compare it against a previously saved snapshot. This is particularly useful for UI components to ensure that unintended changes don't occur.\n\n### Key Concepts:\n*   **`react-test-renderer`:** A package that provides a React renderer that can be used to render React components to pure JavaScript objects, without depending on the DOM or a native mobile environment. This is what Jest uses under the hood for snapshot testing.\n*   **`renderer.create(<Component />).toJSON()`:** This method from `react-test-renderer` creates a JSON representation of the rendered component tree, which is then used to form the snapshot.\n*   **`toMatchSnapshot()`:** A Jest matcher that saves the JSON representation as a `.snap` file on the first run. On subsequent runs, it compares the current rendered output to the saved snapshot. If they don't match, the test fails, indicating a change in the component's output.\n*   **Updating Snapshots:** When a component's output changes intentionally (e.g., due to a feature update or bug fix), the saved snapshot needs to be updated. This is typically done by running Jest with the `-u` or `--updateSnapshot` flag (`jest -u`).\n\n### When to use Snapshot Testing:\n*   To ensure the UI doesn't change unexpectedly (e.g., regressions).\n*   For components with complex, static structures.\n*   To quickly catch accidental styling or structural changes.\n\n### When NOT to use Snapshot Testing:\n*   For frequently changing components or dynamic data, as it leads to frequent snapshot updates, making tests brittle.\n*   As a replacement for behavioral testing (e.g., checking user interactions). Snapshot tests confirm *what* is rendered, not *how* it behaves.\n*   For large, entire pages, as snapshots can become very large and hard to review.",
          "examples": [
            {
              "id": "example_snapshot_testing_1",
              "title": "Basic Snapshot Test for a Card Component",
              "code": "import React from 'react';\nimport renderer from 'react-test-renderer';\nimport Card from './Card';\n\ntest('Card component matches snapshot', () => {\n  // Create a React test renderer instance for the Card component\n  const component = renderer.create(\n    <Card title=\"Example Card\" content=\"This is an example card.\" />\n  );\n  \n  // Convert the rendered component to a JSON tree\n  const tree = component.toJSON();\n  \n  // Compare the JSON tree against the last saved snapshot\n  // On the first run, this creates the .snap file.\n  // On subsequent runs, it compares against the existing .snap file.\n  expect(tree).toMatchSnapshot();\n});\n\n// Card.jsx (for context)\n// import React from 'react';\n// const Card = ({ title, content }) => (\n//   <div className=\"card\">\n//     <h2 className=\"card-title\">{title}</h2>\n//     <p className=\"card-content\">{content}</p>\n//   </div>\n// );\n// export default Card;\n",
              "explanation": "This example demonstrates a basic snapshot test. A `Card` component is rendered using `react-test-renderer`. The rendered output is converted to a JSON object (`tree`) and then compared against a stored snapshot using `toMatchSnapshot()`. This ensures that any unintended changes to the `Card` component's structure or content will cause the test to fail, prompting a review of the changes.",
              "language": "typescript"
            },
            {
              "id": "example_snapshot_testing_2",
              "title": "Snapshot with Props Variations",
              "code": "import React from 'react';\nimport renderer from 'react-test-renderer';\nimport Profile from './Profile';\n\ndescribe('Profile component snapshots', () => {\n  it('renders a default profile correctly', () => {\n    const tree = renderer.create(<Profile />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders a profile with custom user data', () => {\n    const user = {\n      name: 'Jane Doe',\n      age: 30,\n      email: 'jane@example.com'\n    };\n    const tree = renderer.create(<Profile user={user} />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders a profile with a loading state', () => {\n    const tree = renderer.create(<Profile isLoading={true} />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n});\n\n// Profile.jsx (for context)\n// import React from 'react';\n// const Profile = ({ user, isLoading }) => {\n//   if (isLoading) return <div>Loading profile...</div>;\n//   if (!user) return <div>No profile data.</div>;\n//   return (\n//     <div className=\"profile-card\">\n//       <h3>{user.name}</h3>\n//       <p>Age: {user.age}</p>\n//       <p>Email: {user.email}</p>\n//     </div>\n//   );\n// };\n// export default Profile;\n",
              "explanation": "This example shows how to use multiple `it` blocks within a `describe` block to create different snapshots for a single component based on varying props or states. This helps ensure that the component renders correctly under different conditions, providing comprehensive UI regression protection.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_snapshot_testing_1",
            "question_snapshot_testing_2",
            "question_snapshot_testing_3",
            "question_snapshot_testing_4"
          ],
          "relatedTasks": [
            "task_snapshot_testing_1"
          ],
          "tags": [
            "Jest",
            "Snapshot Testing",
            "UI Testing",
            "Regression Testing",
            "Frontend Testing"
          ],
          "technology": "React",
          "prerequisites": [
            "Jest Basics",
            "React Component Structure"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Component Testing"
          ]
        },
        {
          "id": "theory_context_redux_testing",
          "title": "Testing React Components with Context and Redux",
          "content": "When testing React components that rely on Context or Redux, you need to ensure that the component has access to the necessary context or store. This typically involves wrapping the component under test with the appropriate provider components and providing a controlled state for your tests.\n\n### Key Concepts:\n*   **Providing Context/Redux Store:** Components consuming Context or Redux state must be rendered within their respective `Provider` components. In tests, you'll render the component under test wrapped by these providers.\n*   **`Provider` (from `react-redux` or custom context):** Makes the Redux store or context value available to all nested components.\n*   **`redux-mock-store`:** A library specifically designed to create mock Redux stores for testing. It allows you to define an initial state and then inspect actions dispatched to the store. This is preferred over a real Redux store in unit tests for performance and isolation.\n*   **`configureStore` (from `redux-mock-store`):** A function used to create the mock store factory.\n*   **Initial State:** When creating a mock store, you provide the `initialState` that the component under test expects to receive.\n\n### General Approach:\n1.  **Import necessary utilities:** `render` from `@testing-library/react`, `Provider` from `react-redux` (or your context), and `configureStore` from `redux-mock-store`.\n2.  **Create `mockStore` factory:** `const mockStore = configureStore([]);` (The empty array is for middleware, often not needed for simple unit tests).\n3.  **Define `initialState`:** Set up the slice of the Redux state that your component needs for the specific test case.\n4.  **Create a store instance:** `const store = mockStore(initialState);`\n5.  **Render the component:** Wrap the component under test with the `Provider`, passing your `store` instance.\n6.  **Assert:** Use React Testing Library queries to check the rendered output based on the provided state.\n\nFor React Context, the approach is similar: wrap the component with `MyContext.Provider` and pass a mock value to the `value` prop.",
          "examples": [
            {
              "id": "example_context_redux_testing_1",
              "title": "Testing a Redux-Connected Component",
              "code": "import { render, screen } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport configureStore from 'redux-mock-store';\nimport ConnectedComponent from './ConnectedComponent';\n\n// Create a mock store factory\nconst mockStore = configureStore([]);\n\ntest('connected component renders with redux store', () => {\n  // Define the initial state that the component expects\n  const initialState = { user: { name: 'John Doe', status: 'active' } };\n  // Create a mock store instance with the defined initial state\n  const store = mockStore(initialState);\n  \n  // Render the ConnectedComponent wrapped in the Redux Provider\n  render(\n    <Provider store={store}>\n      <ConnectedComponent />\n    </Provider>\n  );\n  \n  // Assert that elements deriving their content from the store are present\n  expect(screen.getByText(/John Doe/i)).toBeInTheDocument();\n  expect(screen.getByText(/Status: active/i)).toBeInTheDocument();\n\n  // You can also assert on actions dispatched, if your component dispatches actions\n  // fireEvent.click(screen.getByRole('button', { name: /logout/i }));\n  // const actions = store.getActions();\n  // expect(actions).toEqual([{ type: 'LOGOUT_USER' }]);\n});\n\n// ConnectedComponent.jsx (for context - example using useSelector)\n// import React from 'react';\n// import { useSelector } from 'react-redux';\n// const ConnectedComponent = () => {\n//   const user = useSelector(state => state.user);\n//   return (\n//     <div>\n//       <p>User Name: {user.name}</p>\n//       <p>Status: {user.status}</p>\n//     </div>\n//   );\n// };\n// export default ConnectedComponent;\n",
              "explanation": "This example, taken from the markdown, shows how to test a React component that is connected to a Redux store. `redux-mock-store` is used to create a lightweight, predictable store for testing purposes. The `ConnectedComponent` is wrapped in the `Provider` with the mock store, allowing it to access the `initialState` just as it would a real Redux store. Assertions then verify that the component correctly renders data from the provided state.",
              "language": "typescript"
            },
            {
              "id": "example_context_redux_testing_2",
              "title": "Testing Component with React Context",
              "code": "import React, { createContext, useContext } from 'react';\nimport { render, screen } from '@testing-library/react';\n\n// Define a mock context for testing\nconst ThemeContext = createContext('light');\n\nconst ThemedComponent = () => {\n  const theme = useContext(ThemeContext);\n  return <div data-testid=\"themed-div\">Current theme: {theme}</div>;\n};\n\ndescribe('ThemedComponent', () => {\n  it('renders with default context value', () => {\n    render(<ThemedComponent />);\n    expect(screen.getByText('Current theme: light')).toBeInTheDocument();\n  });\n\n  it('renders with provided context value', () => {\n    render(\n      <ThemeContext.Provider value=\"dark\">\n        <ThemedComponent />\n      </ThemeContext.Provider>\n    );\n    expect(screen.getByText('Current theme: dark')).toBeInTheDocument();\n  });\n});\n",
              "explanation": "This example illustrates how to test a component that consumes React Context. In the first test, the component renders with its default context value. In the second test, `ThemedComponent` is explicitly wrapped with `ThemeContext.Provider`, and a `value` prop is supplied, overriding the default. This allows testing how the component behaves when different context values are provided, ensuring proper data flow through context.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_context_redux_testing_1",
            "question_context_redux_testing_2",
            "question_context_redux_testing_3",
            "question_context_redux_testing_4"
          ],
          "relatedTasks": [
            "task_context_redux_testing_1"
          ],
          "tags": [
            "Jest",
            "Redux Testing",
            "Context API",
            "React Redux",
            "Integration Testing",
            "Frontend Testing"
          ],
          "technology": "React",
          "prerequisites": [
            "React Context API",
            "Redux Fundamentals",
            "Jest Basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "Complex Application Testing"
          ]
        },
        {
          "id": "theory_custom_hooks_testing",
          "title": "Testing React Custom Hooks",
          "content": "Testing custom hooks can be tricky because hooks are JavaScript functions that rely on React's internal mechanisms (like state, effects, context). You can't just call them like regular functions outside of a React component. The `@testing-library/react-hooks` library provides a solution by creating a temporary, isolated React component to run your hook within.\n\n### Key Concepts:\n*   **`@testing-library/react-hooks`:** A library specifically designed for testing React hooks in isolation. It manages the lifecycle of a test component where your hook can run.\n*   **`renderHook(callback, options)`:** The primary function from `@testing-library/react-hooks`. It takes a callback function that executes your hook and returns an object containing the `result` of the hook and `rerender` utility.\n    *   `callback`: A function that calls your custom hook. For example, `() => useCounter()`. Any props passed to the hook can be provided via `options.initialProps`.\n    *   `options.initialProps`: An object of props to pass to your hook during its initial render.\n*   **`result.current`:** The `result` object returned by `renderHook` has a `current` property that holds the latest value returned by your hook. This is how you access the hook's state, return values, or functions.\n*   **`act(() => ...)`:** A utility from `react-test-renderer/test-utils` (re-exported by `@testing-library/react` and `@testing-library/react-hooks`). It ensures that all updates related to your hook's state (e.g., state changes, effects) are processed before assertions are made. Any code that causes state updates or renders in your hook *must* be wrapped in `act()` to ensure predictable test behavior and avoid warnings.\n*   **`rerender(newProps)`:** A function returned by `renderHook` that allows you to simulate a re-render of the hook, optionally with new props, without re-mounting the underlying test component. Useful for testing effects that depend on prop changes.\n*   **`unmount()`:** A function returned by `renderHook` to simulate unmounting the component that uses the hook. Useful for testing cleanup logic in `useEffect`.\n\n### General Approach:\n1.  **Import `renderHook` and `act`:** From `@testing-library/react-hooks`.\n2.  **Call `renderHook`:** Pass a callback that invokes your custom hook. Destructure `result` (and `rerender`/`unmount` if needed).\n3.  **Interact with the hook (if applicable):** If your hook returns functions that modify its state, call them via `result.current`. **Wrap these calls in `act()`**.\n4.  **Assert:** Use `expect(result.current.value).toBe(...)` to check the hook's returned state or values.",
          "examples": [
            {
              "id": "example_custom_hooks_testing_1",
              "title": "Testing a simple useCounter Hook",
              "code": "import { renderHook, act } from '@testing-library/react-hooks';\nimport useCounter from './useCounter';\n\ntest('should increment counter', () => {\n  // Render the useCounter hook inside a test component\n  const { result } = renderHook(() => useCounter());\n  \n  // Interact with the hook's returned function, wrapped in `act`\n  // `act` ensures all state updates caused by increment() are processed\n  act(() => {\n    result.current.increment();\n  });\n  \n  // Assert the updated value of the counter\n  expect(result.current.count).toBe(1);\n});\n\ntest('should decrement counter', () => {\n  const { result } = renderHook(() => useCounter(5)); // Start with initial value\n  \n  act(() => {\n    result.current.decrement();\n  });\n  \n  expect(result.current.count).toBe(4);\n});\n\n// useCounter.js (for context)\n// import { useState, useCallback } from 'react';\n// const useCounter = (initialValue = 0) => {\n//   const [count, setCount] = useState(initialValue);\n//   const increment = useCallback(() => setCount(prevCount => prevCount + 1), []);\n//   const decrement = useCallback(() => setCount(prevCount => prevCount - 1), []);\n//   return { count, increment, decrement };\n// };\n// export default useCounter;\n",
              "explanation": "This example directly from the markdown illustrates testing a custom `useCounter` hook. `renderHook` is used to create a test environment for the hook. `result.current` provides access to the `count`, `increment`, and `decrement` values/functions returned by the hook. Crucially, the calls to `result.current.increment()` (or `decrement()`) are wrapped in `act()` to ensure that React processes all state updates before assertions are made, preventing potential race conditions or incorrect test results.",
              "language": "typescript"
            },
            {
              "id": "example_custom_hooks_testing_2",
              "title": "Testing a Hook with Effects and Async Operations",
              "code": "import { renderHook, act, waitFor } from '@testing-library/react-hooks';\nimport { useEffect, useState } from 'react';\n\nconst useFetch = (url) => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchData();\n  }, [url]);\n\n  return { data, loading, error };\n};\n\ndescribe('useFetch hook', () => {\n  beforeAll(() => {\n    global.fetch = jest.fn(() =>\n      Promise.resolve({\n        ok: true,\n        json: () => Promise.resolve({ message: 'Success!' })\n      })\n    );\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should fetch data successfully', async () => {\n    const { result, waitForNextUpdate } = renderHook(() => useFetch('/api/data'));\n\n    expect(result.current.loading).toBe(true);\n    expect(result.current.data).toBe(null);\n\n    await waitForNextUpdate(); // Wait for the effect to complete\n\n    expect(result.current.loading).toBe(false);\n    expect(result.current.data).toEqual({ message: 'Success!' });\n    expect(result.current.error).toBe(null);\n    expect(global.fetch).toHaveBeenCalledWith('/api/data');\n  });\n\n  it('should handle fetch errors', async () => {\n    global.fetch.mockImplementationOnce(() =>\n      Promise.resolve({ ok: false, status: 500 })\n    );\n\n    const { result, waitForNextUpdate } = renderHook(() => useFetch('/api/error'));\n\n    await waitForNextUpdate();\n\n    expect(result.current.loading).toBe(false);\n    expect(result.current.data).toBe(null);\n    expect(result.current.error).toBeInstanceOf(Error);\n  });\n});\n",
              "explanation": "This advanced example demonstrates testing a custom hook (`useFetch`) that performs asynchronous operations (fetching data). `global.fetch` is mocked to control the network response. `waitForNextUpdate()` (or `waitFor` if you're asserting DOM changes) is crucial here to await the completion of the `useEffect` and subsequent state updates. This ensures the test checks the final state of the hook after the async operation has resolved, including loading, data, and error states.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_custom_hooks_testing_1",
            "question_custom_hooks_testing_2",
            "question_custom_hooks_testing_3",
            "question_custom_hooks_testing_4"
          ],
          "relatedTasks": [
            "task_custom_hooks_testing_1"
          ],
          "tags": [
            "Jest",
            "Custom Hooks",
            "React Hooks",
            "Unit Testing",
            "Frontend Testing",
            "Asynchronous Testing"
          ],
          "technology": "React",
          "prerequisites": [
            "React Hooks",
            "Jest Basics",
            "Asynchronous JavaScript"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "Complex Hook Development"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_jest_react_basics_1",
          "topic": "Jest and React Testing Library Fundamentals",
          "level": "easy",
          "type": "mcq",
          "question": "Which `React Testing Library` function is best suited for rendering a React component into a test environment?",
          "answer": "`render`",
          "options": [
            "`mount`",
            "`render`",
            "`shallow`",
            "`createRoot`"
          ],
          "analysisPoints": [
            "Tests knowledge of basic RTL setup.",
            "Distinguishes between RTL and other testing paradigms (e.g., Enzyme's `mount`/`shallow`)."
          ],
          "keyConcepts": [
            "`render`",
            "React Testing Library",
            "Component Mounting"
          ],
          "evaluationCriteria": [
            "Correct identification of RTL's primary rendering function.",
            "Understanding of the purpose of component rendering in tests."
          ],
          "example": "The `render` function from `@testing-library/react` is the primary utility for rendering your React components into a DOM element that is attached to `document.body`. This allows you to interact with your component as a user would. Options like `mount` and `shallow` are associated with Enzyme, an older testing utility, while `createRoot` is for React 18+ client-side rendering setup, not typically for isolated component testing.",
          "tags": [
            "Jest",
            "React Testing Library",
            "Unit Testing"
          ],
          "prerequisites": [
            "React Testing Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_jest_react_basics_2",
          "topic": "Jest and React Testing Library Fundamentals",
          "level": "medium",
          "type": "open",
          "question": "Explain the primary philosophy behind React Testing Library (RTL) and how it differs from testing component internals. Provide an example of how this philosophy is applied when querying elements.",
          "answer": "React Testing Library's primary philosophy is to test components in a way that resembles how users interact with them. It encourages testing the *behavior* of the component from the user's perspective, rather than its internal implementation details (like state, props, or component methods). This leads to more robust and maintainable tests because they are less likely to break when the internal implementation of a component changes, as long as its public behavior remains consistent.\n\nThe philosophy can be summarized as: \"The more your tests resemble the way your software is used, the more confidence they can give you.\"\n\nThis differs from testing component internals because it avoids directly accessing a component's internal state (`component.state.value`) or props (`component.props.data`) or calling its methods directly. Instead, you interact with the rendered DOM nodes.\n\n**Example of application when querying elements:**\nInstead of querying by `data-testid` or component instance properties, RTL encourages using queries that reflect how a user or assistive technology would find an element. For instance, to find a button, you wouldn't query `getByTestId('my-button')` unless absolutely necessary. You would prefer:\n\n*   `getByRole('button', { name: /submit/i })`: This is the most preferred method as it mimics how a screen reader user would perceive the button.\n*   `getByText('Submit')`: If the button has visible text.\n\nThis approach ensures that if a developer changes the `data-testid` or adds/removes an internal prop, the test won't break, as long as the user can still interact with the button and its functionality remains the same. If the button no longer has a 'submit' role or text, then it's a user-facing change that *should* break the test, signaling a change in behavior.",
          "analysisPoints": [
            "Tests understanding of RTL's core principles.",
            "Evaluates ability to articulate the benefits of behavioral testing.",
            "Checks knowledge of preferred querying methods in RTL."
          ],
          "keyConcepts": [
            "React Testing Library Philosophy",
            "Behavioral Testing",
            "Accessibility (ARIA roles)",
            "Queries (getByRole, getByText)"
          ],
          "evaluationCriteria": [
            "Clear explanation of RTL philosophy.",
            "Correct comparison with internal testing.",
            "Appropriate and specific example of querying.",
            "Emphasis on user perspective and accessibility."
          ],
          "example": null,
          "tags": [
            "React Testing Library",
            "Testing Philosophy",
            "Best Practices",
            "Accessibility",
            "Queries"
          ],
          "prerequisites": [
            "React Testing Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_jest_react_basics_3",
          "topic": "Jest and React Testing Library Fundamentals",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of `expect(element).toBeInTheDocument()` in a React Testing Library test?",
          "answer": "It asserts that the given DOM element is present within the document (i.e., rendered and accessible in the DOM tree).",
          "analysisPoints": [
            "Verifies knowledge of common Jest-DOM matchers.",
            "Tests understanding of asserting element presence."
          ],
          "keyConcepts": [
            "`toBeInTheDocument`",
            "Jest-DOM",
            "Assertions"
          ],
          "evaluationCriteria": [
            "Accurate description of the matcher's function.",
            "Understanding its role in verifying rendering."
          ],
          "example": null,
          "tags": [
            "Jest",
            "React Testing Library",
            "Matchers"
          ],
          "prerequisites": [
            "Jest Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_jest_react_basics_4",
          "topic": "Jest and React Testing Library Fundamentals",
          "level": "medium",
          "type": "code",
          "question": "Given the following React component, write a Jest and React Testing Library test that verifies:\n1. The `title` prop is rendered as an `<h2>` element.\n2. The `description` prop is rendered as a `<p>` element.\n3. If `isFeatured` is true, a `<span>` with the text 'Featured!' is rendered.",
          "answer": "```typescript\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\n\n// MyCard.jsx (for context, imagine this is in a separate file)\nconst MyCard = ({ title, description, isFeatured }) => (\n  <div>\n    <h2>{title}</h2>\n    <p>{description}</p>\n    {isFeatured && <span data-testid=\"featured-badge\">Featured!</span>}\n  </div>\n);\n\ndescribe('MyCard component', () => {\n  it('renders title and description correctly', () => {\n    render(<MyCard title=\"Test Title\" description=\"Test Description\" />);\n    expect(screen.getByRole('heading', { level: 2, name: 'Test Title' })).toBeInTheDocument();\n    expect(screen.getByText('Test Description')).toBeInTheDocument();\n  });\n\n  it('renders featured badge when isFeatured is true', () => {\n    render(<MyCard title=\"Featured Card\" description=\"\" isFeatured={true} />);\n    expect(screen.getByText('Featured!')).toBeInTheDocument();\n    // Alternatively, using data-testid for non-semantic elements\n    expect(screen.getByTestId('featured-badge')).toBeInTheDocument();\n  });\n\n  it('does not render featured badge when isFeatured is false', () => {\n    render(<MyCard title=\"Regular Card\" description=\"\" isFeatured={false} />);\n    expect(screen.queryByText('Featured!')).not.toBeInTheDocument();\n    expect(screen.queryByTestId('featured-badge')).not.toBeInTheDocument();\n  });\n});\n```",
          "analysisPoints": [
            "Tests ability to use `render` and `screen`.",
            "Checks understanding of `getByRole`, `getByText`, and `queryByText`.",
            "Verifies conditional rendering assertion.",
            "Demonstrates proper `describe` and `it` block usage."
          ],
          "keyConcepts": [
            "React Testing Library",
            "Jest",
            "Queries",
            "Conditional Rendering",
            "Assertions"
          ],
          "evaluationCriteria": [
            "Correctly sets up the test file.",
            "Uses appropriate query methods (`getByRole`, `getByText`, `queryByText`).",
            "Accurately asserts text content and element presence/absence.",
            "Handles conditional rendering effectively."
          ],
          "example": null,
          "tags": [
            "Jest",
            "React Testing Library",
            "Code Challenge",
            "Unit Testing"
          ],
          "prerequisites": [
            "React Basics",
            "Jest Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_mock_functions_1",
          "topic": "Mock Functions in React Tests",
          "level": "medium",
          "type": "mcq",
          "question": "You have a `LoginForm` component with an `onSubmit` prop. You want to verify that `onSubmit` is called exactly once when the form is submitted. Which of the following code snippets correctly sets up the mock function and asserts its call count?",
          "answer": "```typescript\nconst handleSubmit = jest.fn();\nrender(<LoginForm onSubmit={handleSubmit} />);\nfireEvent.submit(screen.getByRole('form'));\nexpect(handleSubmit).toHaveBeenCalledTimes(1);\n```",
          "options": [
            "```typescript\nconst handleSubmit = () => {};\nrender(<LoginForm onSubmit={handleSubmit} />);\nfireEvent.submit(screen.getByRole('form'));\nexpect(handleSubmit).toHaveBeenCalled();\n```",
            "```typescript\nconst handleSubmit = jest.fn();\nrender(<LoginForm onSubmit={handleSubmit} />);\nfireEvent.submit(screen.getByRole('form'));\nexpect(handleSubmit).toHaveBeenCalledTimes(1);\n```",
            "```typescript\nconst handleSubmit = jest.mock();\nrender(<LoginForm onSubmit={handleSubmit} />);\nfireEvent.submit(screen.getByRole('form'));\nexpect(handleSubmit).toHaveBeenCalledTimes(1);\n```",
            "```typescript\nconst handleSubmit = jest.fn();\nrender(<LoginForm onSubmit={handleSubmit} />);\nhandleSubmit(); // Manually calling it\nexpect(handleSubmit).toHaveBeenCalledTimes(1);\n```"
          ],
          "analysisPoints": [
            "Tests correct usage of `jest.fn()` to create a mock.",
            "Verifies understanding of `fireEvent` to simulate user interaction.",
            "Checks knowledge of `toHaveBeenCalledTimes()` matcher.",
            "Distinguishes between a real function and a mock function for assertion."
          ],
          "keyConcepts": [
            "Mock Functions",
            "`jest.fn()`",
            "`fireEvent`",
            "Assertions (`toHaveBeenCalledTimes`)"
          ],
          "evaluationCriteria": [
            "Correct initialization of a mock function.",
            "Accurate simulation of a DOM event.",
            "Appropriate assertion for call count.",
            "Avoids common pitfalls like manually calling the mock or using non-mock functions."
          ],
          "example": "The correct option correctly uses `jest.fn()` to create a mock function that Jest can track. `fireEvent.submit` simulates the form submission, which in turn should trigger the `onSubmit` prop. Finally, `toHaveBeenCalledTimes(1)` precisely verifies that the mock function was invoked exactly once as a result of the form submission. The other options either don't create a mock (`() => {}`), use an incorrect mocking method (`jest.mock()`), or manually call the mock function, which doesn't test the component's behavior.",
          "tags": [
            "Jest",
            "Mocking",
            "React Testing Library",
            "MCQ"
          ],
          "prerequisites": [
            "Jest Basics",
            "React Forms"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_mock_functions_2",
          "topic": "Mock Functions in React Tests",
          "level": "hard",
          "type": "open",
          "question": "When testing a React component that makes an asynchronous API call (e.g., using `fetch` or `axios`), how would you use Jest's mocking capabilities to ensure your test is fast, isolated, and predictable? Describe the steps involved and differentiate between mocking a function prop and mocking an external module.",
          "answer": "To test a React component that makes an asynchronous API call, Jest's mocking capabilities are essential for ensuring the test is fast, isolated, and predictable. This involves preventing actual network requests and providing controlled responses.\n\n**Steps Involved:**\n1.  **Identify the dependency:** Determine which function or module is responsible for the API call (e.g., `window.fetch`, `axios`, or a custom API client). For third-party libraries like `axios`, module mocking is common.\n2.  **Create the mock:**\n    *   **For `window.fetch`:** Use `jest.spyOn(global, 'fetch')` to spy on the global `fetch` function, and then chain `.mockImplementation()` to control its return value (e.g., a resolved Promise with mock data or a rejected Promise for error scenarios).\n    *   **For an external module (e.g., `axios`):** Use `jest.mock('module-name')` at the top of your test file to mock the entire module. Inside the mock factory function, define the mocked methods (e.g., `get`, `post`) to return mock Promises. For example, `jest.mock('axios', () => ({ get: jest.fn(() => Promise.resolve({ data: { id: 1 } })) }));`.\n3.  **Render the component:** Use `render` from `@testing-library/react` to mount your component that performs the API call.\n4.  **Wait for asynchronous operations:** Since API calls are asynchronous, the component's state and DOM updates will happen after the promise resolves. Use `await screen.findBy...` queries, `waitFor` from RTL, or `waitForNextUpdate` (for hooks) to wait for the UI to reflect the data.\n5.  **Assert:** Verify that the mock function/method was called with the correct arguments (e.g., `expect(axios.get).toHaveBeenCalledWith('/api/users')`) and that the component renders the mock data correctly (`expect(screen.getByText('John Doe')).toBeInTheDocument()`).\n\n**Differentiation: Mocking a Function Prop vs. Mocking an External Module**\n\n*   **Mocking a Function Prop (`jest.fn()`):**\n    *   **Purpose:** Used when a component receives a function as a prop (e.g., `onSubmit`, `onSave`) and you want to ensure that the component calls this prop correctly when an event occurs.\n    *   **Mechanism:** You create a standalone mock function using `const myMock = jest.fn();` and pass it directly to the component as a prop: `<MyComponent onAction={myMock} />`.\n    *   **Isolation:** Tests the interaction *between* the parent and child component (the child calls the prop, the parent provides it). The focus is on verifying the callback was invoked.\n    *   **Example:** Testing a button's `onClick` prop, or a form's `onSubmit` prop.\n\n*   **Mocking an External Module (`jest.mock('module-name')` or `jest.spyOn()`):**\n    *   **Purpose:** Used when a component directly imports and uses functions/objects from external libraries (e.g., `axios`, `lodash`, `utility-functions.js`) or global APIs (`fetch`, `localStorage`). This allows you to control the behavior of these external dependencies during the test.\n    *   **Mechanism:** `jest.mock()` is typically placed at the top of the test file and replaces the entire module. `jest.spyOn()` allows you to monitor and/or replace a specific method on an existing object or module. The mocked behavior is defined within the mock factory function or using `mockImplementation()`.\n    *   **Isolation:** Achieves true unit testing by isolating the component from its external dependencies. The component behaves as if it's interacting with the real dependency, but under controlled conditions.\n    *   **Example:** Mocking `axios.get()` to control API responses, or mocking a custom logging utility to check if it was called.\n\nIn essence, `jest.fn()` is for testing interactions with *callback props*, while `jest.mock()` or `jest.spyOn()` are for isolating a component from its *external library/API dependencies*.",
          "analysisPoints": [
            "Comprehensive explanation of API mocking strategy.",
            "Clear distinction between `jest.fn()` and `jest.mock()`/`jest.spyOn()`.",
            "Demonstrates understanding of asynchronous testing with RTL utilities.",
            "Discusses benefits like speed, isolation, predictability."
          ],
          "keyConcepts": [
            "Mocking API Calls",
            "Jest.fn()",
            "Jest.mock()",
            "Jest.spyOn()",
            "Asynchronous Testing",
            "`waitFor`",
            "`findBy`"
          ],
          "evaluationCriteria": [
            "Detailed, step-by-step process for API mocking.",
            "Accurate and clear comparison of different mocking techniques.",
            "Correct mention of RTL's asynchronous utilities.",
            "Understanding of the core benefits of mocking in tests."
          ],
          "example": null,
          "tags": [
            "Jest",
            "Mocking",
            "API Testing",
            "Asynchronous",
            "Unit Testing",
            "Interview Question"
          ],
          "prerequisites": [
            "Jest Basics",
            "Asynchronous JavaScript"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_mock_functions_3",
          "topic": "Mock Functions in React Tests",
          "level": "easy",
          "type": "flashcard",
          "question": "What Jest mock matcher would you use to verify that a mock function was called with specific arguments, for example, `myMock('hello', 123)`?",
          "answer": "`expect(myMock).toHaveBeenCalledWith('hello', 123);`",
          "analysisPoints": [
            "Tests knowledge of specific mock matchers.",
            "Verifies correct syntax for `toHaveBeenCalledWith`."
          ],
          "keyConcepts": [
            "Mock Matchers",
            "`toHaveBeenCalledWith`",
            "Jest"
          ],
          "evaluationCriteria": [
            "Correct identification of the matcher.",
            "Accurate recall of its usage."
          ],
          "example": null,
          "tags": [
            "Jest",
            "Mocking",
            "Matchers",
            "Flashcard"
          ],
          "prerequisites": [
            "Jest Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_mock_functions_4",
          "topic": "Mock Functions in React Tests",
          "level": "medium",
          "type": "code",
          "question": "Create a React component `InputWithButton` that contains an input field and a button. When the button is clicked, it should call an `onSubmit` prop with the current value of the input field. Write a Jest and React Testing Library test to verify that the `onSubmit` prop is called with the correct input value.",
          "answer": "```typescript\nimport React, { useState } from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\n\n// InputWithButton.jsx (for context)\nconst InputWithButton = ({ onSubmit }) => {\n  const [value, setValue] = useState('');\n\n  const handleChange = (e) => {\n    setValue(e.target.value);\n  };\n\n  const handleClick = () => {\n    onSubmit(value);\n    setValue(''); // Clear input after submission\n  };\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={value}\n        onChange={handleChange}\n        placeholder=\"Enter text\"\n      />\n      <button onClick={handleClick}>Submit</button>\n    </div>\n  );\n};\n\ndescribe('InputWithButton', () => {\n  it('calls onSubmit with the input value when button is clicked', () => {\n    const mockOnSubmit = jest.fn();\n    render(<InputWithButton onSubmit={mockOnSubmit} />);\n\n    const inputElement = screen.getByPlaceholderText('Enter text');\n    const submitButton = screen.getByRole('button', { name: /submit/i });\n\n    // Simulate user typing into the input\n    fireEvent.change(inputElement, { target: { value: 'Hello Test!' } });\n\n    // Simulate user clicking the button\n    fireEvent.click(submitButton);\n\n    // Assert that the mock function was called once with the correct value\n    expect(mockOnSubmit).toHaveBeenCalledTimes(1);\n    expect(mockOnSubmit).toHaveBeenCalledWith('Hello Test!');\n\n    // Optionally, check if the input cleared\n    expect(inputElement).toHaveValue('');\n  });\n\n  it('does not call onSubmit if input is empty and button is clicked', () => {\n    const mockOnSubmit = jest.fn();\n    render(<InputWithButton onSubmit={mockOnSubmit} />);\n\n    const submitButton = screen.getByRole('button', { name: /submit/i });\n\n    fireEvent.click(submitButton);\n\n    // Assert that the mock function was NOT called\n    expect(mockOnSubmit).not.toHaveBeenCalled();\n  });\n});\n```",
          "analysisPoints": [
            "Tests ability to mock a function prop.",
            "Checks understanding of `fireEvent.change` for input fields.",
            "Verifies assertion using `toHaveBeenCalledWith`.",
            "Demonstrates testing component state changes (input clearing)."
          ],
          "keyConcepts": [
            "Mock Functions",
            "Jest.fn()",
            "FireEvent",
            "toHaveBeenCalledWith",
            "Component Interaction"
          ],
          "evaluationCriteria": [
            "Correct setup of mock function.",
            "Accurate simulation of user input and clicks.",
            "Precise assertions for function calls and arguments.",
            "Handles edge cases like empty input (optional, but good)."
          ],
          "example": null,
          "tags": [
            "Jest",
            "Mocking",
            "React Testing Library",
            "Code Challenge",
            "Forms"
          ],
          "prerequisites": [
            "React State",
            "Jest Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_snapshot_testing_1",
          "topic": "Snapshot Testing",
          "level": "easy",
          "type": "mcq",
          "question": "Which Jest matcher is used to perform a snapshot test?",
          "answer": "`toMatchSnapshot()`",
          "options": [
            "`toEqual()`",
            "`toMatchObject()`",
            "`toMatchSnapshot()`",
            "`toBe()`"
          ],
          "analysisPoints": [
            "Tests direct knowledge of Jest snapshot matchers.",
            "Distinguishes `toMatchSnapshot` from other common Jest matchers."
          ],
          "keyConcepts": [
            "Snapshot Testing",
            "Jest Matchers"
          ],
          "evaluationCriteria": [
            "Correct identification of the snapshot matcher.",
            "Basic understanding of Jest matchers."
          ],
          "example": "The `toMatchSnapshot()` matcher is specifically designed for snapshot testing in Jest. When called, it serializes the value it receives and compares it to a previously saved snapshot file. If no snapshot exists, it creates one. The other options are general Jest matchers used for different types of comparisons.",
          "tags": [
            "Jest",
            "Snapshot Testing",
            "MCQ"
          ],
          "prerequisites": [
            "Jest Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_snapshot_testing_2",
          "topic": "Snapshot Testing",
          "level": "medium",
          "type": "open",
          "question": "Discuss the primary advantages and disadvantages of using snapshot testing in a React application. When would it be most appropriate to use it, and when might it be problematic?",
          "answer": "**Advantages of Snapshot Testing:**\n1.  **Ease of Use & Quick Setup:** Snapshot tests are very easy to write and require minimal setup. A single `expect(component).toMatchSnapshot()` line can cover a large part of a component's rendering.\n2.  **Regression Detection:** They are excellent for catching unintended UI changes (regressions). If a change breaks the visual output, the snapshot test will fail, alerting the developer.\n3.  **Documentation:** Snapshots act as a form of documentation, showing exactly what a component renders at a given point in time.\n4.  **Coverage for Complex UIs:** For components with complex, static, or deeply nested structures, snapshot tests can provide extensive coverage with less effort than explicit DOM assertions.\n\n**Disadvantages of Snapshot Testing:**\n1.  **Brittleness:** They can be brittle. Minor, intentional changes (e.g., refactoring HTML structure, adding a new class for styling) will cause snapshot failures, requiring frequent updates (`jest -u`). This can lead to \"false positives\" where a test fails for a non-bug reason.\n2.  **Review Burden:** Large snapshots can be difficult and time-consuming to review during code reviews, making it hard to spot legitimate bugs amidst expected changes.\n3.  **Lack of Semantic Meaning:** Snapshots only capture the rendered output; they don't explicitly assert *what* that output means semantically or functionally. A button might be present in the snapshot, but the test doesn't confirm it's clickable or performs the correct action.\n4.  **Not a Replacement for Behavioral Tests:** They don't test user interactions or business logic. They are about *what* is rendered, not *how* it behaves.\n\n**When Most Appropriate:**\n*   **Static/Presentational Components:** Ideal for components that primarily render UI based on props and have a stable structure (e.g., `Header`, `Footer`, `Card`, `Icon`).\n*   **Regression Testing for Visual Changes:** To ensure that refactors or new features don't inadvertently alter existing UI elements.\n*   **Large, Complex HTML Structures:** When a component generates a lot of HTML, and explicitly asserting every element would be too verbose.\n\n**When Problematic:**\n*   **Highly Dynamic Components:** Components whose output changes frequently based on data or user interaction (e.g., a real-time chat window, a form that shows/hides many fields).\n*   **Components with Randomness/Timestamps:** Any component that includes dynamic data like current dates, unique IDs, or random values, as these will always cause snapshot mismatches.\n*   **As a Sole Testing Strategy:** Relying *only* on snapshot tests is insufficient. They should complement, not replace, unit and integration tests that verify behavior and functionality.",
          "analysisPoints": [
            "Covers both pros and cons comprehensively.",
            "Provides clear scenarios for appropriate and problematic use cases.",
            "Highlights the distinction between 'what' (snapshot) and 'how' (behavioral) testing."
          ],
          "keyConcepts": [
            "Snapshot Testing",
            "Advantages",
            "Disadvantages",
            "UI Regression",
            "Test Brittleness"
          ],
          "evaluationCriteria": [
            "Balanced perspective on snapshot testing.",
            "Specific examples for appropriate and problematic use.",
            "Demonstrates understanding of testing trade-offs.",
            "Clarity and organization of points."
          ],
          "example": null,
          "tags": [
            "Jest",
            "Snapshot Testing",
            "Testing Philosophy",
            "Best Practices",
            "Interview Question"
          ],
          "prerequisites": [
            "Jest Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_snapshot_testing_3",
          "topic": "Snapshot Testing",
          "level": "easy",
          "type": "flashcard",
          "question": "What command line flag do you use with Jest to update existing snapshots?",
          "answer": "`-u` or `--updateSnapshot` (e.g., `jest -u`)",
          "analysisPoints": [
            "Tests practical command-line usage.",
            "Verifies knowledge of common Jest flags."
          ],
          "keyConcepts": [
            "Snapshot Testing",
            "Jest CLI",
            "Updating Snapshots"
          ],
          "evaluationCriteria": [
            "Correct recall of the command line flag.",
            "Understanding its purpose."
          ],
          "example": null,
          "tags": [
            "Jest",
            "Snapshot Testing",
            "CLI",
            "Flashcard"
          ],
          "prerequisites": [
            "Jest Basics"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_snapshot_testing_4",
          "topic": "Snapshot Testing",
          "level": "medium",
          "type": "code",
          "question": "Consider a `ProductDisplay` component that receives `product` data as a prop. The `product` object can have `name`, `price`, and an optional `discount` property. If `discount` is present, it should render the original price struck through and the discounted price. Otherwise, just the regular price. Write snapshot tests to cover both scenarios (with and without discount).",
          "answer": "```typescript\nimport React from 'react';\nimport renderer from 'react-test-renderer';\n\n// ProductDisplay.jsx (for context)\nconst ProductDisplay = ({ product }) => {\n  const { name, price, discount } = product;\n\n  return (\n    <div className=\"product-card\">\n      <h3>{name}</h3>\n      {discount ? (\n        <p>\n          <span style={{ textDecoration: 'line-through' }}>${price.toFixed(2)}</span>\n          {' '}\n          <span style={{ color: 'red', fontWeight: 'bold' }}>${(price * (1 - discount)).toFixed(2)}</span>\n        </p>\n      ) : (\n        <p>${price.toFixed(2)}</p>\n      )}\n    </div>\n  );\n};\n\ndescribe('ProductDisplay snapshot tests', () => {\n  it('renders correctly for a product without discount', () => {\n    const product = {\n      name: 'Standard Widget',\n      price: 99.99,\n    };\n    const tree = renderer.create(<ProductDisplay product={product} />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders correctly for a product with a discount', () => {\n    const product = {\n      name: 'Premium Gizmo',\n      price: 150.00,\n      discount: 0.20, // 20% off\n    };\n    const tree = renderer.create(<ProductDisplay product={product} />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n});\n```",
          "analysisPoints": [
            "Tests ability to set up `react-test-renderer`.",
            "Verifies creation of JSON tree.",
            "Checks application of `toMatchSnapshot`.",
            "Demonstrates snapshot testing with different prop variations to cover conditional rendering."
          ],
          "keyConcepts": [
            "Snapshot Testing",
            "Conditional Rendering",
            "React Test Renderer",
            "Jest"
          ],
          "evaluationCriteria": [
            "Correct setup for snapshot tests.",
            "Covers both conditional rendering paths with separate snapshots.",
            "Uses appropriate data for each scenario.",
            "Clear and concise test structure."
          ],
          "example": null,
          "tags": [
            "Jest",
            "Snapshot Testing",
            "Code Challenge",
            "Conditional Rendering"
          ],
          "prerequisites": [
            "React Basics",
            "Jest Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_redux_testing_1",
          "topic": "Testing with Context and Redux",
          "level": "medium",
          "type": "mcq",
          "question": "When testing a React component that consumes Redux state, which of the following is the most appropriate approach using Jest and React Testing Library?",
          "answer": "Wrap the component under test with `Provider` from `react-redux` and pass a mock store created by `redux-mock-store`.",
          "options": [
            "Directly import the Redux store into the test file and pass it to the component as a prop.",
            "Mock the `useSelector` hook directly using `jest.mock('react-redux')` to control the returned state.",
            "Wrap the component under test with `Provider` from `react-redux` and pass a mock store created by `redux-mock-store`.",
            "Avoid testing Redux-connected components directly; instead, test the pure component and the Redux reducer separately."
          ],
          "analysisPoints": [
            "Tests understanding of Redux testing best practices.",
            "Evaluates knowledge of `Provider` and `redux-mock-store`.",
            "Differentiates between unit testing and integration testing contexts for Redux components."
          ],
          "keyConcepts": [
            "Redux Testing",
            "React Redux Provider",
            "Redux Mock Store",
            "Integration Testing"
          ],
          "evaluationCriteria": [
            "Correctly identifies the recommended approach for Redux integration testing.",
            "Understanding of why `redux-mock-store` is used.",
            "Recognition of the role of `Provider`."
          ],
          "example": "To effectively test a Redux-connected component, you need to provide it with a Redux store. Using `redux-mock-store` is the most common and recommended approach. It allows you to create a controlled, predictable store instance with a specific initial state for your test, and also enables you to inspect dispatched actions. The component is then rendered wrapped in the `Provider` from `react-redux`, connecting it to this mock store. Directly importing the real store or mocking `useSelector` directly can lead to less realistic or more brittle tests, respectively. While testing pure components and reducers separately is good, it doesn't cover the integration aspect of the connected component.",
          "tags": [
            "Redux",
            "Testing",
            "React Redux",
            "Mocking",
            "MCQ"
          ],
          "prerequisites": [
            "Redux Fundamentals",
            "React Testing Library"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_context_redux_testing_2",
          "topic": "Testing with Context and Redux",
          "level": "hard",
          "type": "open",
          "question": "Imagine you have a `UserDashboard` component that displays user information, which it retrieves using `useContext` from an `AuthContext` and potentially dispatches actions to a Redux store for logout functionality. Describe how you would set up your test environment to test this component's rendering and interaction behavior effectively. Include considerations for both context and Redux.",
          "answer": "To effectively test a `UserDashboard` component that consumes `AuthContext` and interacts with a Redux store, the test environment needs to provide controlled mock values for both dependencies. The goal is to isolate the `UserDashboard` component, ensuring its rendering and behavior are tested independently of the actual Redux store or Auth context's full implementation.\n\n**Setup for AuthContext:**\n1.  **Define a Mock Context Provider:** Create a simple wrapper component that provides a controlled `AuthContext.Provider` for your tests. This allows you to easily pass different mock `value` objects to the context for various test scenarios.\n    ```typescript\n    // test-utils.js (or similar)\n    import React from 'react';\n    import { render as rtlRender } from '@testing-library/react';\n    import { AuthContext } from './AuthContext'; // Assume AuthContext is exported\n\n    function renderWithAuthContext(ui, { providerProps, ...renderOptions } = {}) {\n      return rtlRender(\n        <AuthContext.Provider value={providerProps.value}>\n          {ui}\n        </AuthContext.Provider>,\n        renderOptions\n      );\n    }\n    export * from '@testing-library/react';\n    export { renderWithAuthContext as render };\n    ```\n2.  **Provide Mock Values:** In your tests, call this custom `render` function, passing the desired `value` for the context.\n\n**Setup for Redux Store:**\n1.  **`redux-mock-store`:** Use `redux-mock-store` to create a test-specific Redux store. This allows you to define the initial state the component expects and to inspect any actions dispatched by the component.\n    ```typescript\n    import configureStore from 'redux-mock-store';\n    const mockStore = configureStore([]); // No middleware for simple tests\n    ```\n2.  **Create Store Instance with Initial State:** For each test case, define the `initialState` relevant to that test and create a new mock store instance.\n    ```typescript\n    const initialState = { auth: { user: { name: 'Test User' } }, other: {} };\n    const store = mockStore(initialState);\n    ```\n\n**Combining Both for `UserDashboard` Testing:**\n\n```typescript\nimport React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport configureStore from 'redux-mock-store';\n// Assume UserDashboard uses useContext(AuthContext) and useDispatch()\nimport { AuthContext } from './AuthContext';\nimport UserDashboard from './UserDashboard'; \n\nconst mockReduxStore = configureStore([]);\n\ndescribe('UserDashboard', () => {\n  it('renders user name from AuthContext and Redux state', () => {\n    const mockAuthContextValue = { user: { id: '123', role: 'admin' }, isAuthenticated: true };\n    const mockReduxInitialState = { preferences: { theme: 'dark' } }; // Example Redux state\n    const store = mockReduxStore(mockReduxInitialState);\n\n    render(\n      <AuthContext.Provider value={mockAuthContextValue}>\n        <Provider store={store}>\n          <UserDashboard />\n        </Provider>\n      </AuthContext.Provider>\n    );\n\n    // Assertions based on AuthContext\n    expect(screen.getByText(/Welcome, admin user!/i)).toBeInTheDocument(); // Assuming component logic\n    // Assertions based on Redux state\n    expect(screen.getByText(/Current theme: dark/i)).toBeInTheDocument(); // Assuming component logic\n  });\n\n  it('dispatches logout action when logout button is clicked', () => {\n    const mockAuthContextValue = { user: { id: '123' }, isAuthenticated: true };\n    const mockReduxInitialState = { preferences: { theme: 'light' } };\n    const store = mockReduxStore(mockReduxInitialState);\n\n    render(\n      <AuthContext.Provider value={mockAuthContextValue}>\n        <Provider store={store}>\n          <UserDashboard />\n        </Provider>\n      </AuthContext.Provider>\n    );\n\n    fireEvent.click(screen.getByRole('button', { name: /logout/i }));\n\n    // Assert that the correct action was dispatched\n    const actions = store.getActions();\n    expect(actions).toEqual([{ type: 'AUTH_LOGOUT' }]);\n  });\n\n  it('shows login prompt if not authenticated via AuthContext', () => {\n    const mockAuthContextValue = { user: null, isAuthenticated: false };\n    const store = mockReduxStore({}); // Empty Redux state if not relevant\n\n    render(\n      <AuthContext.Provider value={mockAuthContextValue}>\n        <Provider store={store}>\n          <UserDashboard />\n        </Provider>\n      </AuthContext.Provider>\n    );\n    expect(screen.getByText(/Please log in/i)).toBeInTheDocument();\n  });\n});\n```\n\n**Considerations:**\n*   **Isolation:** Each test should ideally create its own mock context and store instances to ensure test isolation and prevent state leakage between tests.\n*   **Realism:** While mocking is used, the setup still mimics the real application structure (wrapping with Providers) as much as possible, aligning with RTL's philosophy.\n*   **Action Inspection:** `redux-mock-store`'s `getActions()` method is crucial for verifying that the component dispatches the correct Redux actions in response to user interactions.\n*   **Testing Different States:** Design tests to cover various states of both context and Redux (e.g., authenticated/unauthenticated, different user roles, various Redux data states).",
          "analysisPoints": [
            "Comprehensive plan for testing a multi-dependency component.",
            "Demonstrates combining mock context and mock Redux store setups.",
            "Illustrates how to provide different states/values for testing scenarios.",
            "Explains how to verify dispatched Redux actions.",
            "Highlights key considerations for robust testing."
          ],
          "keyConcepts": [
            "Context Testing",
            "Redux Testing",
            "Mocking Dependencies",
            "Integration Testing",
            "`redux-mock-store`",
            "`AuthContext.Provider`",
            "Action Inspection"
          ],
          "evaluationCriteria": [
            "Detailed and actionable test setup steps.",
            "Correct use of `Provider` and `redux-mock-store`.",
            "Shows how to test rendering based on provided state and dispatched actions.",
            "Addresses both context and Redux in a combined scenario.",
            "Demonstrates understanding of testing complex components."
          ],
          "example": null,
          "tags": [
            "Redux",
            "Context API",
            "Testing Strategy",
            "Integration Testing",
            "Advanced Testing",
            "Interview Question"
          ],
          "prerequisites": [
            "React Context API",
            "Redux Fundamentals",
            "Jest Mocking"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "expert"
        },
        {
          "id": "question_context_redux_testing_3",
          "topic": "Testing with Context and Redux",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using `redux-mock-store` instead of a real Redux store in unit tests for connected components?",
          "answer": "It provides a lightweight, predictable store for testing, allowing you to define a specific initial state and easily inspect dispatched actions without the overhead of a full Redux setup.",
          "analysisPoints": [
            "Tests understanding of mock store benefits.",
            "Highlights aspects of isolation and control in testing."
          ],
          "keyConcepts": [
            "`redux-mock-store`",
            "Unit Testing",
            "Isolation",
            "Predictability"
          ],
          "evaluationCriteria": [
            "Accurate description of benefits.",
            "Focus on key testing principles."
          ],
          "example": null,
          "tags": [
            "Redux",
            "Testing",
            "Mocking",
            "Flashcard"
          ],
          "prerequisites": [
            "Redux Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_redux_testing_4",
          "topic": "Testing with Context and Redux",
          "level": "medium",
          "type": "code",
          "question": "Create a `UserProfileDisplay` component that consumes a `UserContext` and displays the user's name and email. The `UserContext` provides an object `{ name: string, email: string }`. Write a test using React Testing Library to verify that the component correctly displays the user information provided by the context.",
          "answer": "```typescript\nimport React, { createContext, useContext } from 'react';\nimport { render, screen } from '@testing-library/react';\n\n// UserContext.js (for context)\nconst UserContext = createContext(null);\n\n// UserProfileDisplay.jsx (for context)\nconst UserProfileDisplay = () => {\n  const user = useContext(UserContext);\n  \n  if (!user) {\n    return <div>No user data available.</div>;\n  }\n\n  return (\n    <div>\n      <h2>Welcome, {user.name}!</h2>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n};\n\ndescribe('UserProfileDisplay', () => {\n  it('renders user details from UserContext', () => {\n    const mockUser = { name: 'Jane Doe', email: 'jane.doe@example.com' };\n\n    render(\n      <UserContext.Provider value={mockUser}>\n        <UserProfileDisplay />\n      </UserContext.Provider>\n    );\n\n    expect(screen.getByRole('heading', { name: 'Welcome, Jane Doe!' })).toBeInTheDocument();\n    expect(screen.getByText('Email: jane.doe@example.com')).toBeInTheDocument();\n  });\n\n  it('renders a fallback message when no user is provided', () => {\n    render(\n      <UserContext.Provider value={null}>\n        <UserProfileDisplay />\n      </UserContext.Provider>\n    );\n\n    expect(screen.getByText('No user data available.')).toBeInTheDocument();\n  });\n});\n```",
          "analysisPoints": [
            "Tests ability to mock React Context.",
            "Checks understanding of providing context values in tests.",
            "Verifies assertions for content derived from context.",
            "Demonstrates testing conditional rendering based on context availability."
          ],
          "keyConcepts": [
            "React Context API",
            "Context Testing",
            "Provider",
            "React Testing Library",
            "Code Challenge"
          ],
          "evaluationCriteria": [
            "Correctly sets up `UserContext.Provider` with a mock value.",
            "Accurately asserts the rendered content based on context.",
            "Handles the null/no user context scenario.",
            "Clean and readable test code."
          ],
          "example": null,
          "tags": [
            "React Context",
            "Testing",
            "Code Challenge",
            "Unit Testing"
          ],
          "prerequisites": [
            "React Context API Basics",
            "Jest Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_custom_hooks_testing_1",
          "topic": "Testing Custom Hooks",
          "level": "medium",
          "type": "mcq",
          "question": "When testing a custom React hook that updates its internal state (e.g., a counter hook), why is it important to wrap the hook's state-updating calls in `act()` from `@testing-library/react-hooks`?",
          "answer": "`act()` ensures that all updates related to the hook's state (including effects) are flushed and applied to the DOM before any assertions are made, making tests more predictable and avoiding warnings.",
          "options": [
            "`act()` is required to correctly mock asynchronous operations within the hook.",
            "`act()` helps to optimize the test performance by batching state updates.",
            "`act()` ensures that all updates related to the hook's state (including effects) are flushed and applied to the DOM before any assertions are made, making tests more predictable and avoiding warnings.",
            "`act()` is only necessary when testing hooks that interact with the actual DOM."
          ],
          "analysisPoints": [
            "Tests understanding of the purpose of `act()` in hook testing.",
            "Differentiates `act()`'s role from other testing concerns.",
            "Highlights predictability and warning prevention as key benefits."
          ],
          "keyConcepts": [
            "Custom Hooks Testing",
            "`act()`",
            "State Updates",
            "Asynchronous Testing"
          ],
          "evaluationCriteria": [
            "Accurate explanation of `act()`'s role.",
            "Understanding of its impact on test reliability.",
            "Avoids common misconceptions about its purpose."
          ],
          "example": "The `act()` function plays a crucial role in ensuring that your tests behave closer to how React works in a browser. React's updates (state changes, effects) are often batched and don't happen immediately. `act()` flushes these pending updates, making sure that the state of your hook (and the underlying test component's DOM) is stable and fully updated before you make any assertions. Without `act()`, your assertions might run against an outdated state, leading to flaky tests or 'act' warnings in the console.",
          "tags": [
            "React Hooks",
            "Testing",
            "Act",
            "MCQ"
          ],
          "prerequisites": [
            "React Hooks Basics",
            "Jest Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_custom_hooks_testing_2",
          "topic": "Testing Custom Hooks",
          "level": "hard",
          "type": "open",
          "question": "You are tasked with testing a custom hook, `useDebounce(value, delay)`, which delays updating a value until a certain `delay` has passed since the last change. Describe how you would approach testing this hook using `@testing-library/react-hooks`, specifically focusing on how to manage time (debouncing) in your tests. Include considerations for both initial value, updates, and cleanup.",
          "answer": "Testing a `useDebounce` hook, which inherently deals with time, requires careful management of Jest's timer mocks to ensure predictable and fast tests.\n\n**Hook Definition (for context):**\n```typescript\nimport { useState, useEffect } from 'react';\n\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n```\n\n**Testing Approach with Jest Timer Mocks:**\n\n1.  **Enable Jest Fake Timers:** At the beginning of your test file or `describe` block, enable Jest's fake timers. This replaces `setTimeout`, `setInterval`, etc., with Jest's controlled versions.\n    ```typescript\n    jest.useFakeTimers();\n    ```\n2.  **Render the Hook:** Use `renderHook` from `@testing-library/react-hooks` to run your `useDebounce` hook. You'll primarily interact with `result.current` and `rerender`.\n    ```typescript\n    const { result, rerender, unmount } = renderHook(\n      ({ value, delay }) => useDebounce(value, delay),\n      { initialProps: { value: 'initial', delay: 500 } }\n    );\n    ```\n3.  **Advance Timers:** Instead of waiting for real time, use `jest.advanceTimersByTime(ms)` to simulate the passage of time.\n\n**Specific Test Scenarios:**\n\n*   **Initial Value:**\n    Verify that the `debouncedValue` initially reflects the `value` passed on the first render, before any delay has passed.\n    ```typescript\n    it('should return the initial value immediately', () => {\n      const { result } = renderHook(() => useDebounce('initial', 500));\n      expect(result.current).toBe('initial');\n    });\n    ```\n\n*   **Debounce Behavior (Update after delay):**\n    Simulate a value change and then advance timers past the `delay` to ensure the debounced value updates correctly.\n    ```typescript\n    it('should debounce value changes', () => {\n      const { result, rerender } = renderHook(\n        ({ value, delay }) => useDebounce(value, delay),\n        { initialProps: { value: 'initial', delay: 500 } }\n      );\n\n      // Change value without advancing timers yet\n      rerender({ value: 'new value', delay: 500 });\n      expect(result.current).toBe('initial'); // Still old value\n\n      // Advance timers just enough for the debounce to trigger\n      act(() => {\n        jest.advanceTimersByTime(500);\n      });\n      expect(result.current).toBe('new value'); // New value should now be reflected\n    });\n    ```\n\n*   **Multiple Rapid Updates (Debouncing in action):**\n    Simulate multiple value changes within the `delay` period and ensure only the *last* value is debounced and applied.\n    ```typescript\n    it('should only update after the last change within delay', () => {\n      const { result, rerender } = renderHook(\n        ({ value, delay }) => useDebounce(value, delay),\n        { initialProps: { value: 'first', delay: 1000 } }\n      );\n\n      rerender({ value: 'second', delay: 1000 });\n      act(() => { jest.advanceTimersByTime(500); }); // Advance half the delay\n      expect(result.current).toBe('first');\n\n      rerender({ value: 'third', delay: 1000 });\n      act(() => { jest.advanceTimersByTime(500); }); // Advance another half (total 1000, but from last rerender, timeout reset)\n      expect(result.current).toBe('first'); // Still 'first' because new timeout started\n\n      act(() => { jest.advanceTimersByTime(500); }); // Advance again, passing 1000 from 'third'\n      expect(result.current).toBe('third'); // Finally, 'third' is debounced\n    });\n    ```\n\n*   **Cleanup:**\n    Ensure that the `clearTimeout` function is called when the component (or hook) unmounts. This prevents memory leaks.\n    ```typescript\n    it('should clear the timeout on unmount', () => {\n      const clearTimeoutSpy = jest.spyOn(global, 'clearTimeout');\n      const { unmount } = renderHook(() => useDebounce('test', 500));\n      \n      unmount();\n      expect(clearTimeoutSpy).toHaveBeenCalledTimes(1); // Or whatever count expected due to initial render\n      clearTimeoutSpy.mockRestore(); // Clean up the spy\n    });\n    ```\n\n**Cleanup:**\n*   After each test, it's good practice to clear all timers and restore them (`jest.clearAllTimers()` and `jest.runOnlyPendingTimers()` or `jest.runAllTimers()`) and then disable fake timers (`jest.useRealTimers()`) if other tests in the suite need real timers.\n\nThis comprehensive approach ensures that the `useDebounce` hook's behavior is thoroughly tested across different scenarios, including its time-dependent logic and proper cleanup, all without introducing actual delays into the test suite.",
          "analysisPoints": [
            "Demonstrates advanced hook testing with time manipulation.",
            "Correctly uses `jest.useFakeTimers()`, `jest.advanceTimersByTime()`, and `act()`.",
            "Covers initial state, update logic, and cleanup (useEffect return).",
            "Provides practical code examples for each scenario.",
            "Highlights the importance of `rerender` for prop changes."
          ],
          "keyConcepts": [
            "Custom Hooks Testing",
            "`useDebounce`",
            "Jest Fake Timers",
            "`jest.advanceTimersByTime`",
            "`act()`",
            "`rerender`",
            "useEffect Cleanup"
          ],
          "evaluationCriteria": [
            "Thorough understanding of testing time-sensitive hooks.",
            "Correct application of Jest's timer mocks.",
            "Ability to test various states and interactions of the hook.",
            "Consideration for cleanup and test isolation.",
            "Well-structured and explained code examples."
          ],
          "example": null,
          "tags": [
            "React Hooks",
            "Testing",
            "Asynchronous",
            "Jest",
            "Code Challenge",
            "Advanced"
          ],
          "prerequisites": [
            "React Hooks",
            "Jest Basics",
            "Mock Functions"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "expert"
        },
        {
          "id": "question_custom_hooks_testing_3",
          "topic": "Testing Custom Hooks",
          "level": "easy",
          "type": "flashcard",
          "question": "What property of the `result` object returned by `renderHook` allows you to access the current value(s) returned by your custom hook?",
          "answer": "`result.current`",
          "analysisPoints": [
            "Tests knowledge of `renderHook`'s return value structure.",
            "Verifies basic interaction with tested hooks."
          ],
          "keyConcepts": [
            "`renderHook`",
            "Custom Hooks Testing",
            "`result.current`"
          ],
          "evaluationCriteria": [
            "Correct identification of the property.",
            "Understanding of how to access hook values in tests."
          ],
          "example": null,
          "tags": [
            "React Hooks",
            "Testing",
            "Flashcard"
          ],
          "prerequisites": [
            "React Hooks Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_custom_hooks_testing_4",
          "topic": "Testing Custom Hooks",
          "level": "medium",
          "type": "code",
          "question": "Implement and test a custom hook `useToggle(initialValue)` that manages a boolean state. It should return the current boolean value and a `toggle` function to flip the value, and optionally an `on` and `off` function to explicitly set the value to `true` or `false` respectively.",
          "answer": "```typescript\nimport { useState, useCallback } from 'react';\nimport { renderHook, act } from '@testing-library/react-hooks';\n\n// useToggle.js (for context)\nconst useToggle = (initialValue = false) => {\n  const [value, setValue] = useState(initialValue);\n\n  const toggle = useCallback(() => {\n    setValue((prev) => !prev);\n  }, []);\n\n  const on = useCallback(() => {\n    setValue(true);\n  }, []);\n\n  const off = useCallback(() => {\n    setValue(false);\n  }, []);\n\n  return { value, toggle, on, off };\n};\n\ndescribe('useToggle', () => {\n  it('should toggle the value', () => {\n    const { result } = renderHook(() => useToggle(false));\n    expect(result.current.value).toBe(false);\n\n    act(() => {\n      result.current.toggle();\n    });\n    expect(result.current.value).toBe(true);\n\n    act(() => {\n      result.current.toggle();\n    });\n    expect(result.current.value).toBe(false);\n  });\n\n  it('should set the value to true using `on`', () => {\n    const { result } = renderHook(() => useToggle(false));\n    expect(result.current.value).toBe(false);\n\n    act(() => {\n      result.current.on();\n    });\n    expect(result.current.value).toBe(true);\n\n    // Calling 'on' when already true should keep it true\n    act(() => {\n      result.current.on();\n    });\n    expect(result.current.value).toBe(true);\n  });\n\n  it('should set the value to false using `off`', () => {\n    const { result } = renderHook(() => useToggle(true));\n    expect(result.current.value).toBe(true);\n\n    act(() => {\n      result.current.off();\n    });\n    expect(result.current.value).toBe(false);\n\n    // Calling 'off' when already false should keep it false\n    act(() => {\n      result.current.off();\n    });\n    expect(result.current.value).toBe(false);\n  });\n\n  it('should handle different initial values', () => {\n    const { result: trueResult } = renderHook(() => useToggle(true));\n    expect(trueResult.current.value).toBe(true);\n\n    const { result: falseResult } = renderHook(() => useToggle(false));\n    expect(falseResult.current.value).toBe(false);\n  });\n});\n```",
          "analysisPoints": [
            "Tests ability to implement a custom hook with multiple functions.",
            "Checks proper usage of `renderHook` and `act`.",
            "Verifies `useState` and `useCallback` usage within the hook.",
            "Demonstrates testing different methods returned by a hook.",
            "Covers various initial states and explicit state setting."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "Testing Hooks",
            "`renderHook`",
            "`act()`",
            "`useState`",
            "`useCallback`",
            "Code Challenge"
          ],
          "evaluationCriteria": [
            "Correct implementation of `useToggle` with all specified functions.",
            "Thorough test coverage for `toggle`, `on`, `off`, and initial values.",
            "Appropriate use of `act()` for state updates.",
            "Clear and effective assertions.",
            "Follows best practices for hook testing."
          ],
          "example": null,
          "tags": [
            "React Hooks",
            "Testing",
            "Code Challenge",
            "Unit Testing"
          ],
          "prerequisites": [
            "React Hooks",
            "Jest Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_jest_react_basics_1",
          "title": "Implement a Simple Greeting Component and Test its Display",
          "description": "\nCreate a React component named `Greeting` that accepts a `name` prop (string, default to 'Guest') and displays a personalized greeting. Then, write unit tests for this component using Jest and React Testing Library to ensure:\n\n1.  It renders 'Hello, Guest!' when no `name` prop is provided.\n2.  It renders 'Hello, [name]!' when a `name` prop is provided.\n3.  The greeting text is contained within an `<h1>` heading.\n\nYour solution should use `render`, `screen.getByRole`, and `toHaveTextContent`.\n",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\n\n// TODO: Implement the Greeting component here\nconst Greeting = ({ name = 'Guest' }) => {\n  return (\n    <h1>Hello, {name}!</h1>\n  );\n};\n\n// TODO: Write your tests below this line\ndescribe('Greeting component', () => {\n  // Test case 1\n  // Test case 2\n  // Test case 3\n});\n",
          "solutionCode": "import React from 'react';\nimport { render, screen } from '@testing-library/react';\n\nconst Greeting = ({ name = 'Guest' }) => {\n  return (\n    <h1>Hello, {name}!</h1>\n  );\n};\n\ndescribe('Greeting component', () => {\n  it('renders \"Hello, Guest!\" when no name prop is provided', () => {\n    render(<Greeting />);\n    expect(screen.getByRole('heading')).toHaveTextContent('Hello, Guest!');\n  });\n\n  it('renders \"Hello, John!\" when name prop is \"John\"', () => {\n    render(<Greeting name=\"John\" />);\n    expect(screen.getByRole('heading')).toHaveTextContent('Hello, John!');\n  });\n\n  it('renders the greeting text within an h1 element', () => {\n    render(<Greeting name=\"Tester\" />);\n    const headingElement = screen.getByText('Hello, Tester!');\n    expect(headingElement.tagName).toBe('H1'); // Verify it's an H1 tag\n    expect(headingElement.localName).toBe('h1'); // Alternative for lowercase check\n    expect(screen.getByRole('heading', { level: 1 })).toBeInTheDocument(); // Best practice to check role and level\n  });\n});\n",
          "testCases": [
            "Greeting component renders 'Hello, Guest!' by default.",
            "Greeting component renders 'Hello, Alice!' when name prop is 'Alice'.",
            "The rendered greeting is inside an `<h1>` tag."
          ],
          "hints": [
            "Remember to import `render` and `screen` from `@testing-library/react`.",
            "`screen.getByRole('heading', { level: 1 })` is a robust way to find an `<h1>`.",
            "Use `toHaveTextContent` to assert the text displayed."
          ],
          "tags": [
            "React",
            "Jest",
            "React Testing Library",
            "Unit Testing",
            "Basic Component"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "React Basics",
            "Jest Fundamentals"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "Component Props",
            "Conditional Rendering"
          ]
        },
        {
          "id": "task_jest_react_basics_2",
          "title": "Test a Navigation Bar with Conditional Links",
          "description": "\nImplement a `NavBar` React component that displays a list of navigation links. It should have:\n\n1.  A default set of links always visible (`Home`, `About`).\n2.  An optional `adminLinks` prop (an array of link objects `{ text: string, path: string }`) that, if provided, renders additional links under an 'Admin' heading.\n\nWrite Jest and React Testing Library tests to verify:\n\n*   The default 'Home' and 'About' links are always present.\n*   If `adminLinks` are provided, the 'Admin' heading and the specific admin links appear.\n*   If `adminLinks` are NOT provided, the 'Admin' heading and admin links are NOT present.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport { render, screen, queryByText } from '@testing-library/react';\n\n// TODO: Implement the NavBar component here\nconst NavBar = ({ adminLinks }) => {\n  const defaultLinks = [\n    { text: 'Home', path: '/' },\n    { text: 'About', path: '/about' },\n  ];\n\n  return (\n    <nav>\n      <ul>\n        {defaultLinks.map(link => (\n          <li key={link.path}><a href={link.path}>{link.text}</a></li>\n        ))}\n      </ul>\n      {/* TODO: Implement conditional rendering for admin links */}\n    </nav>\n  );\n};\n\ndescribe('NavBar component', () => {\n  // TODO: Write your tests here\n});\n",
          "solutionCode": "import React from 'react';\nimport { render, screen } from '@testing-library/react';\n\nconst NavBar = ({ adminLinks }) => {\n  const defaultLinks = [\n    { text: 'Home', path: '/' },\n    { text: 'About', path: '/about' },\n  ];\n\n  return (\n    <nav aria-label=\"Main Navigation\">\n      <ul>\n        {defaultLinks.map(link => (\n          <li key={link.path}><a href={link.path}>{link.text}</a></li>\n        ))}\n      </ul>\n      {adminLinks && adminLinks.length > 0 && (\n        <div>\n          <h3>Admin</h3>\n          <ul>\n            {adminLinks.map(link => (\n              <li key={link.path}><a href={link.path}>{link.text}</a></li>\n            ))}\n          </ul>\n        </div>\n      )}\n    </nav>\n  );\n};\n\ndescribe('NavBar component', () => {\n  it('renders default links correctly', () => {\n    render(<NavBar />);\n    expect(screen.getByRole('link', { name: 'Home' })).toBeInTheDocument();\n    expect(screen.getByRole('link', { name: 'About' })).toBeInTheDocument();\n  });\n\n  it('renders admin links and heading when provided', () => {\n    const adminLinks = [\n      { text: 'Dashboard', path: '/admin/dashboard' },\n      { text: 'Users', path: '/admin/users' },\n    ];\n    render(<NavBar adminLinks={adminLinks} />);\n    \n    expect(screen.getByRole('heading', { name: 'Admin' })).toBeInTheDocument();\n    expect(screen.getByRole('link', { name: 'Dashboard' })).toBeInTheDocument();\n    expect(screen.getByRole('link', { name: 'Users' })).toBeInTheDocument();\n  });\n\n  it('does not render admin links or heading when not provided', () => {\n    render(<NavBar />);\n    expect(screen.queryByRole('heading', { name: 'Admin' })).not.toBeInTheDocument();\n    // Using queryByRole/queryByText is important for asserting absence\n    expect(screen.queryByRole('link', { name: 'Dashboard' })).not.toBeInTheDocument();\n  });\n\n  it('does not render admin links or heading when provided with empty array', () => {\n    render(<NavBar adminLinks={[]} />);\n    expect(screen.queryByRole('heading', { name: 'Admin' })).not.toBeInTheDocument();\n  });\n});\n",
          "testCases": [
            "NavBar renders default 'Home' and 'About' links.",
            "NavBar renders 'Admin' heading and specific admin links when `adminLinks` prop is present.",
            "NavBar does NOT render 'Admin' heading or admin links when `adminLinks` prop is null or undefined.",
            "NavBar does NOT render 'Admin' heading or admin links when `adminLinks` prop is an empty array."
          ],
          "hints": [
            "Use `screen.queryByRole` or `screen.queryByText` when asserting that an element is *not* present in the DOM. These queries return `null` instead of throwing an error if the element is not found.",
            "Remember that `getByRole` with `name` option is great for finding links.",
            "Consider edge cases like an empty `adminLinks` array."
          ],
          "tags": [
            "React",
            "Jest",
            "React Testing Library",
            "Conditional Rendering",
            "Props",
            "Integration Testing"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Props",
            "Conditional Rendering",
            "Jest Basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component Structure",
            "Accessibility"
          ]
        },
        {
          "id": "task_mock_functions_1",
          "title": "Test an API-Dependent User Form with Mocked API Calls",
          "description": "\nCreate a React component `UserRegistrationForm` that takes `onSuccess` and `onError` callbacks as props. The form should have input fields for `username` and `email`, and a submit button. When submitted, it should make an asynchronous `POST` request to `/api/register` with the form data. Upon successful registration, it should call `onSuccess` with the response data; on failure, it should call `onError` with the error.\n\nYour task is to:\n1.  Implement the `UserRegistrationForm` component.\n2.  Write Jest and React Testing Library tests that:\n    *   Mock the `fetch` API (or `axios` if you prefer).\n    *   Verify `onSuccess` is called with the correct data on successful registration.\n    *   Verify `onError` is called with an error on failed registration (e.g., a 400 or 500 status).\n    *   Ensure the form input fields are cleared after a successful submission.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\n\n// Mock the fetch API globally before component import\n// For axios, you would typically use jest.mock('axios');\n// jest.mock('axios', () => ({\n//   post: jest.fn(),\n// }));\n\n// TODO: Implement the UserRegistrationForm component\nconst UserRegistrationForm = ({ onSuccess, onError }) => {\n  const [username, setUsername] = useState('');\n  const [email, setEmail] = useState('');\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      // Replace with actual fetch or axios call\n      const response = await fetch('/api/register', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ username, email }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      onSuccess(data);\n      setUsername('');\n      setEmail('');\n    } catch (error) {\n      onError(error);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"username\">Username:</label>\n        <input id=\"username\" type=\"text\" value={username} onChange={(e) => setUsername(e.target.value)} />\n      </div>\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input id=\"email\" type=\"email\" value={email} onChange={(e) => setEmail(e.target.value)} />\n      </div>\n      <button type=\"submit\">Register</button>\n    </form>\n  );\n};\n\ndescribe('UserRegistrationForm', () => {\n  let mockOnSuccess;\n  let mockOnError;\n\n  beforeEach(() => {\n    mockOnSuccess = jest.fn();\n    mockOnError = jest.fn();\n    // Reset mocks for fetch/axios for each test\n    // For fetch:\n    global.fetch = jest.fn();\n    // For axios:\n    // axios.post.mockClear();\n  });\n\n  // TODO: Write your tests for successful and failed registration\n});\n",
          "solutionCode": "import React, { useState } from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\n\n// NOTE: For 'fetch' API, mock it globally. For 'axios', use jest.mock('axios').\n// The solution uses 'fetch' as per the starting code's suggestion.\n\nconst UserRegistrationForm = ({ onSuccess, onError }) => {\n  const [username, setUsername] = useState('');\n  const [email, setEmail] = useState('');\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      const response = await fetch('/api/register', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ username, email }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      onSuccess(data);\n      setUsername('');\n      setEmail('');\n    } catch (error) {\n      onError(error);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"username\">Username:</label>\n        <input id=\"username\" type=\"text\" value={username} onChange={(e) => setUsername(e.target.value)} />\n      </div>\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input id=\"email\" type=\"email\" value={email} onChange={(e) => setEmail(e.target.value)} />\n      </div>\n      <button type=\"submit\">Register</button>\n    </form>\n  );\n};\n\ndescribe('UserRegistrationForm', () => {\n  let mockOnSuccess;\n  let mockOnError;\n\n  beforeEach(() => {\n    mockOnSuccess = jest.fn();\n    mockOnError = jest.fn();\n    // Clear all mocks before each test to ensure isolation\n    global.fetch = jest.fn();\n  });\n\n  it('calls onSuccess with data and clears form on successful registration', async () => {\n    // Mock a successful fetch response\n    global.fetch.mockResolvedValueOnce({\n      ok: true,\n      json: () => Promise.resolve({ id: 1, username: 'testuser', email: 'test@example.com' }),\n    });\n\n    render(\n      <UserRegistrationForm onSuccess={mockOnSuccess} onError={mockOnError} />\n    );\n\n    // Get input elements by label text\n    const usernameInput = screen.getByLabelText(/username:/i);\n    const emailInput = screen.getByLabelText(/email:/i);\n    const submitButton = screen.getByRole('button', { name: /register/i });\n\n    // Simulate user input\n    fireEvent.change(usernameInput, { target: { value: 'testuser' } });\n    fireEvent.change(emailInput, { target: { value: 'test@example.com' } });\n\n    // Simulate form submission\n    fireEvent.click(submitButton);\n\n    // Wait for the asynchronous operations to complete and state to update\n    await waitFor(() => {\n      expect(mockOnSuccess).toHaveBeenCalledTimes(1);\n      expect(mockOnSuccess).toHaveBeenCalledWith({ id: 1, username: 'testuser', email: 'test@example.com' });\n      expect(mockOnError).not.toHaveBeenCalled();\n    });\n    \n    // Verify form fields are cleared after success\n    expect(usernameInput).toHaveValue('');\n    expect(emailInput).toHaveValue('');\n\n    // Verify fetch was called with correct arguments\n    expect(global.fetch).toHaveBeenCalledTimes(1);\n    expect(global.fetch).toHaveBeenCalledWith(\n      '/api/register',\n      expect.objectContaining({\n        method: 'POST',\n        body: JSON.stringify({ username: 'testuser', email: 'test@example.com' }),\n      })\n    );\n  });\n\n  it('calls onError and does not clear form on failed registration', async () => {\n    // Mock a failed fetch response (e.g., 400 Bad Request)\n    global.fetch.mockResolvedValueOnce({\n      ok: false,\n      status: 400,\n      json: () => Promise.resolve({ message: 'Validation failed' }),\n    });\n\n    render(\n      <UserRegistrationForm onSuccess={mockOnSuccess} onError={mockOnError} />\n    );\n\n    const usernameInput = screen.getByLabelText(/username:/i);\n    const emailInput = screen.getByLabelText(/email:/i);\n    const submitButton = screen.getByRole('button', { name: /register/i });\n\n    fireEvent.change(usernameInput, { target: { value: 'invaliduser' } });\n    fireEvent.change(emailInput, { target: { value: 'invalid@example.com' } });\n\n    fireEvent.click(submitButton);\n\n    await waitFor(() => {\n      expect(mockOnError).toHaveBeenCalledTimes(1);\n      expect(mockOnError).toHaveBeenCalledWith(expect.any(Error)); // Checks it's an Error object\n      expect(mockOnSuccess).not.toHaveBeenCalled();\n    });\n    \n    // Verify form fields are NOT cleared after failure\n    expect(usernameInput).toHaveValue('invaliduser');\n    expect(emailInput).toHaveValue('invalid@example.com');\n\n    expect(global.fetch).toHaveBeenCalledTimes(1);\n  });\n});\n",
          "testCases": [
            "Successful registration: `onSuccess` is called with returned data, input fields are cleared.",
            "Failed registration: `onError` is called with an error, input fields are NOT cleared.",
            "Verify `fetch` (or `axios.post`) was called with correct URL and payload.",
            "Ensure no `onSuccess` call on error, and no `onError` call on success."
          ],
          "hints": [
            "Use `global.fetch = jest.fn()` to mock `fetch`. You can chain `.mockResolvedValueOnce()` to control its response.",
            "`fireEvent.change` for input fields and `fireEvent.submit` for forms.",
            "Remember to use `await waitFor(() => { /* assertions */ })` for asynchronous updates, especially after API calls.",
            "Use `jest.fn()` for `onSuccess` and `onError` props and `toHaveBeenCalledWith` to check arguments."
          ],
          "tags": [
            "React",
            "Jest",
            "Mocking",
            "API",
            "Forms",
            "Asynchronous",
            "Integration Testing",
            "Code Challenge"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React State & Forms",
            "Asynchronous JavaScript (Promises, async/await)",
            "Jest Mocking"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Error Handling",
            "User Interaction",
            "Form Validation"
          ]
        },
        {
          "id": "task_snapshot_testing_1",
          "title": "Create and Test a Multi-Variant Alert Component with Snapshots",
          "description": "\nImplement a React component named `Alert` that displays a message. The component should accept `message` (string) and `type` (string: 'info', 'success', 'warning', 'error') props. The `type` prop should affect the CSS class applied to the alert (e.g., `alert-info`, `alert-success`).\n\nYour task is to:\n1.  Create the `Alert` component with basic styling based on `type`.\n2.  Write Jest snapshot tests to ensure that the `Alert` component renders correctly for each of the `type` variants ('info', 'success', 'warning', 'error') and for a default (no type) case.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport renderer from 'react-test-renderer';\n\n// TODO: Implement the Alert component here\nconst Alert = ({ message, type = 'info' }) => {\n  // Consider a className based on type: `alert-${type}`\n  return (\n    <div className={`alert alert-${type}`}>\n      {message}\n    </div>\n  );\n};\n\ndescribe('Alert component snapshot tests', () => {\n  // TODO: Write snapshot tests for different alert types\n});\n",
          "solutionCode": "import React from 'react';\nimport renderer from 'react-test-renderer';\n\nconst Alert = ({ message, type = 'info' }) => {\n  return (\n    <div className={`alert alert-${type}`}>\n      {message}\n    </div>\n  );\n};\n\ndescribe('Alert component snapshot tests', () => {\n  it('renders correctly for info type', () => {\n    const component = renderer.create(\n      <Alert message=\"This is an informational message.\" type=\"info\" />\n    );\n    expect(component.toJSON()).toMatchSnapshot();\n  });\n\n  it('renders correctly for success type', () => {\n    const component = renderer.create(\n      <Alert message=\"Operation completed successfully!\" type=\"success\" />\n    );\n    expect(component.toJSON()).toMatchSnapshot();\n  });\n\n  it('renders correctly for warning type', () => {\n    const component = renderer.create(\n      <Alert message=\"Warning: Something might be wrong.\" type=\"warning\" />\n    );\n    expect(component.toJSON()).toMatchSnapshot();\n  });\n\n  it('renders correctly for error type', () => {\n    const component = renderer.create(\n      <Alert message=\"Error: An unexpected error occurred.\" type=\"error\" />\n    );\n    expect(component.toJSON()).toMatchSnapshot();\n  });\n\n  it('renders correctly with default type when no type is provided', () => {\n    const component = renderer.create(\n      <Alert message=\"Default alert message.\" />\n    );\n    expect(component.toJSON()).toMatchSnapshot();\n  });\n});\n",
          "testCases": [
            "Snapshot for 'info' type.",
            "Snapshot for 'success' type.",
            "Snapshot for 'warning' type.",
            "Snapshot for 'error' type.",
            "Snapshot for default type (no `type` prop provided)."
          ],
          "hints": [
            "Import `renderer` from `react-test-renderer`.",
            "Use `component.toJSON()` to get the render tree.",
            "Remember that each `it` block should ideally test one specific scenario or prop combination.",
            "Run `jest -u` on the first run to generate the snapshot files."
          ],
          "tags": [
            "React",
            "Jest",
            "Snapshot Testing",
            "Component Props",
            "UI Testing"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Basics",
            "Jest Fundamentals",
            "CSS Classes"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Conditional Styling"
          ]
        },
        {
          "id": "task_context_redux_testing_1",
          "title": "Test a User Profile Component Connected to a Redux Store",
          "description": "\nCreate a `UserProfile` React component that displays a user's `firstName` and `lastName` retrieved from a Redux store. It should also have a button labeled 'Reset Name' that, when clicked, dispatches a `RESET_NAME` action.\n\nYour task is to:\n1.  Implement the `UserProfile` component (you can use `useSelector` and `useDispatch` from `react-redux`).\n2.  Write Jest and React Testing Library tests that:\n    *   Provide a mock Redux store with an initial user state using `redux-mock-store`.\n    *   Verify that the component correctly displays the user's `firstName` and `lastName` from the store.\n    *   Simulate a click on the 'Reset Name' button.\n    *   Assert that the `RESET_NAME` action was dispatched exactly once.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport configureStore from 'redux-mock-store';\n\n// Action type for reset\nconst RESET_NAME = 'RESET_NAME';\n\n// TODO: Implement the UserProfile component\nconst UserProfile = () => {\n  const user = useSelector(state => state.user);\n  const dispatch = useDispatch();\n\n  const handleResetName = () => {\n    dispatch({ type: RESET_NAME });\n  };\n\n  return (\n    <div>\n      <h2>User Profile</h2>\n      <p>First Name: {user.firstName}</p>\n      <p>Last Name: {user.lastName}</p>\n      <button onClick={handleResetName}>Reset Name</button>\n    </div>\n  );\n};\n\nconst mockStore = configureStore([]);\n\ndescribe('UserProfile component', () => {\n  // TODO: Write your tests here\n});\n",
          "solutionCode": "import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport configureStore from 'redux-mock-store';\n\nconst RESET_NAME = 'RESET_NAME';\n\nconst UserProfile = () => {\n  const user = useSelector(state => state.user);\n  const dispatch = useDispatch();\n\n  const handleResetName = () => {\n    dispatch({ type: RESET_NAME });\n  };\n\n  return (\n    <div>\n      <h2>User Profile</h2>\n      <p>First Name: {user.firstName}</p>\n      <p>Last Name: {user.lastName}</p>\n      <button onClick={handleResetName}>Reset Name</button>\n    </div>\n  );\n};\n\nconst mockStore = configureStore([]);\n\ndescribe('UserProfile component', () => {\n  it('renders user information from the Redux store', () => {\n    const initialState = {\n      user: { firstName: 'John', lastName: 'Doe' }\n    };\n    const store = mockStore(initialState);\n\n    render(\n      <Provider store={store}>\n        <UserProfile />\n      </Provider>\n    );\n\n    expect(screen.getByText(/First Name: John/i)).toBeInTheDocument();\n    expect(screen.getByText(/Last Name: Doe/i)).toBeInTheDocument();\n  });\n\n  it('dispatches RESET_NAME action when Reset Name button is clicked', () => {\n    const initialState = {\n      user: { firstName: 'Jane', lastName: 'Smith' }\n    };\n    const store = mockStore(initialState);\n\n    render(\n      <Provider store={store}>\n        <UserProfile />\n      </Provider>\n    );\n\n    const resetButton = screen.getByRole('button', { name: /Reset Name/i });\n    fireEvent.click(resetButton);\n\n    // Get all actions that were dispatched to the mock store\n    const actions = store.getActions();\n\n    // Assert that the RESET_NAME action was dispatched\n    expect(actions).toEqual([{ type: RESET_NAME }]);\n    expect(actions).toHaveLength(1); // Ensure only one action was dispatched\n  });\n\n  it('renders correctly when user data is missing (edge case)', () => {\n    const initialState = { user: {} }; // Missing firstName, lastName\n    const store = mockStore(initialState);\n\n    render(\n      <Provider store={store}>\n        <UserProfile />\n      </Provider>\n    );\n\n    // Assuming component handles missing data gracefully, perhaps showing empty strings or a placeholder\n    expect(screen.getByText(/First Name:/i)).toBeInTheDocument();\n    expect(screen.getByText(/Last Name:/i)).toBeInTheDocument();\n  });\n});\n",
          "testCases": [
            "Component displays correct `firstName` and `lastName` from initial store state.",
            "Clicking 'Reset Name' button dispatches `RESET_NAME` action.",
            "Ensure no other actions are dispatched.",
            "Component handles missing user data in store gracefully."
          ],
          "hints": [
            "Remember to wrap `UserProfile` with `<Provider store={store}>`.",
            "Use `mockStore(initialState)` to define the starting Redux state for your test.",
            "`store.getActions()` will return an array of all actions dispatched to the mock store. You can then assert against this array.",
            "Use `fireEvent.click` to simulate button clicks."
          ],
          "tags": [
            "React",
            "Redux",
            "Jest",
            "React Testing Library",
            "Integration Testing",
            "Redux Testing"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Redux Fundamentals",
            "React Redux (useSelector, useDispatch)",
            "Jest Mocking"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "State Management",
            "Actions",
            "Dispatchers"
          ]
        },
        {
          "id": "task_custom_hooks_testing_1",
          "title": "Implement and Test a `useLocalStorage` Custom Hook",
          "description": "\nImplement a custom React hook `useLocalStorage(key, initialValue)` that allows you to store and retrieve a value from `localStorage`. The hook should:\n\n1.  Initialize its state with `initialValue` if nothing is found in `localStorage` for the given `key`.\n2.  Initialize its state with the value from `localStorage` if present.\n3.  Update the value in `localStorage` whenever the hook's state changes.\n4.  Return the current value and a setter function (similar to `useState`).\n\nWrite Jest tests using `@testing-library/react-hooks` to verify:\n\n*   The hook correctly initializes from `localStorage`.\n*   The hook correctly initializes with `initialValue` if `localStorage` is empty.\n*   Updating the hook's value also updates `localStorage`.\n*   The hook's value is reactive (changes when `localStorage` changes, though this requires more advanced mocking for `storage` events, focus on the setter for this task).\n\n**Note:** You will need to mock `localStorage` for your tests.\n",
          "difficulty": "hard",
          "startingCode": "import { useState, useEffect, useCallback } from 'react';\nimport { renderHook, act } from '@testing-library/react-hooks';\n\n// Mock localStorage for testing\nconst localStorageMock = {\n  getItem: jest.fn(),\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n  clear: jest.fn(),\n};\nObject.defineProperty(window, 'localStorage', {\n  value: localStorageMock,\n});\n\n// TODO: Implement the useLocalStorage hook\nconst useLocalStorage = (key, initialValue) => {\n  const [value, setValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.warn(`Error reading localStorage key ${key}:`, error);\n      return initialValue;\n    }\n  });\n\n  const setStoredValue = useCallback(newValue => {\n    try {\n      setValue(newValue);\n      window.localStorage.setItem(key, JSON.stringify(newValue));\n    } catch (error) {\n      console.warn(`Error setting localStorage key ${key}:`, error);\n    }\n  }, [key]);\n\n  return [value, setStoredValue];\n};\n\ndescribe('useLocalStorage', () => {\n  beforeEach(() => {\n    // Clear and reset all mocks before each test\n    localStorageMock.getItem.mockClear();\n    localStorageMock.setItem.mockClear();\n    localStorageMock.removeItem.mockClear();\n    localStorageMock.clear.mockClear();\n  });\n\n  // TODO: Write your tests here\n});\n",
          "solutionCode": "import { useState, useEffect, useCallback } from 'react';\nimport { renderHook, act } from '@testing-library/react-hooks';\n\n// Mock localStorage for testing\nconst localStorageMock = {\n  getItem: jest.fn(),\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n  clear: jest.fn(),\n};\nObject.defineProperty(window, 'localStorage', {\n  value: localStorageMock,\n});\n\nconst useLocalStorage = (key, initialValue) => {\n  const [value, setValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.warn(`Error reading localStorage key ${key}:`, error);\n      return initialValue;\n    }\n  });\n\n  const setStoredValue = useCallback(newValue => {\n    try {\n      // Allow newValue to be a function, just like useState's setter\n      const valueToStore = newValue instanceof Function ? newValue(value) : newValue;\n      setValue(valueToStore);\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.warn(`Error setting localStorage key ${key}:`, error);\n    }\n  }, [key, value]); // Add `value` to dependency array for function updates\n\n  // Optionally, you might add a useEffect to listen for storage events\n  // For this task, we focus on the setter for updates\n\n  return [value, setStoredValue];\n};\n\ndescribe('useLocalStorage', () => {\n  beforeEach(() => {\n    localStorageMock.getItem.mockClear();\n    localStorageMock.setItem.mockClear();\n    localStorageMock.removeItem.mockClear();\n    localStorageMock.clear.mockClear();\n  });\n\n  it('should initialize with initialValue if localStorage is empty', () => {\n    localStorageMock.getItem.mockReturnValue(null);\n    const { result } = renderHook(() => useLocalStorage('myKey', 'default'));\n    expect(result.current[0]).toBe('default');\n    expect(localStorageMock.getItem).toHaveBeenCalledWith('myKey');\n  });\n\n  it('should initialize with value from localStorage if present', () => {\n    localStorageMock.getItem.mockReturnValue(JSON.stringify('storedValue'));\n    const { result } = renderHook(() => useLocalStorage('myKey', 'default'));\n    expect(result.current[0]).toBe('storedValue');\n    expect(localStorageMock.getItem).toHaveBeenCalledWith('myKey');\n  });\n\n  it('should update localStorage when the value changes', () => {\n    localStorageMock.getItem.mockReturnValue(null); // Ensure initial state doesn't come from storage\n    const { result } = renderHook(() => useLocalStorage('myKey', 'default'));\n    \n    act(() => {\n      result.current[1]('newValue'); // Call the setter function\n    });\n    expect(result.current[0]).toBe('newValue');\n    expect(localStorageMock.setItem).toHaveBeenCalledWith('myKey', JSON.stringify('newValue'));\n    expect(localStorageMock.setItem).toHaveBeenCalledTimes(1); // Only one setItem call from this action\n  });\n\n  it('should handle function updates to the value', () => {\n    localStorageMock.getItem.mockReturnValue(null);\n    const { result } = renderHook(() => useLocalStorage('count', 0));\n    \n    act(() => {\n      result.current[1](prev => prev + 1);\n    });\n    expect(result.current[0]).toBe(1);\n    expect(localStorageMock.setItem).toHaveBeenCalledWith('count', JSON.stringify(1));\n  });\n\n  it('should handle complex objects correctly', () => {\n    const initialUser = { name: 'Bob', age: 30 };\n    localStorageMock.getItem.mockReturnValue(JSON.stringify(initialUser));\n    const { result } = renderHook(() => useLocalStorage('user', null));\n\n    expect(result.current[0]).toEqual(initialUser);\n\n    const updatedUser = { ...initialUser, age: 31 };\n    act(() => {\n      result.current[1](updatedUser);\n    });\n    expect(result.current[0]).toEqual(updatedUser);\n    expect(localStorageMock.setItem).toHaveBeenCalledWith('user', JSON.stringify(updatedUser));\n  });\n});\n",
          "testCases": [
            "Hook initializes with `initialValue` if `localStorage` is empty.",
            "Hook initializes with parsed value from `localStorage` if present.",
            "Calling the setter function updates the hook's value and saves it to `localStorage`.",
            "Calling the setter function with a functional updater (e.g., `prev => prev + 1`) works correctly.",
            "Hook correctly handles storing and retrieving complex JSON objects.",
            "Ensure `localStorage.getItem` and `setItem` are called with the correct key and value."
          ],
          "hints": [
            "Make sure your `useLocalStorage` hook uses `JSON.parse` when reading from `localStorage` and `JSON.stringify` when writing to it.",
            "Use `localStorageMock.getItem.mockReturnValueOnce()` to control what `getItem` returns for specific test scenarios.",
            "Remember to wrap state updates (`result.current[1](...)`) in `act()`.",
            "Use `toHaveBeenCalledWith` to verify the arguments passed to `localStorage.setItem`."
          ],
          "tags": [
            "React",
            "Custom Hooks",
            "LocalStorage",
            "Testing",
            "Jest",
            "Mocking",
            "Advanced"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React Hooks (useState, useEffect, useCallback)",
            "Jest Mocking",
            "Web Storage API"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "State Persistence",
            "Side Effects",
            "Test Doubles"
          ]
        }
      ]
    }
  }
]