[
  {
    "id": "aa13ee3a-31c9-4cb0-9751-8af930ef54cd",
    "startLine": 13200,
    "endLine": 13299,
    "processedDate": "2025-06-17T13:21:38.360Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_graphql_client_operations",
          "title": "GraphQL Client: Queries and Mutations",
          "content": "GraphQL is a powerful query language for APIs, providing a more efficient, powerful, and flexible alternative to REST. Clients like Apollo Client (implied by the provided code using `client.query` and `client.mutate` with `gql` tag) allow frontend applications to interact with GraphQL servers.\n\n## GraphQL Queries\nQueries in GraphQL are used to fetch data from a server. They are declarative, meaning you specify exactly what data you need, and the server returns only that data, avoiding over-fetching or under-fetching issues common with REST APIs. Queries can accept variables to make them dynamic, allowing for parameterized data requests (e.g., fetching a user by ID).\n\n### Structure of a Query\nA GraphQL query specifies the operation type (`query`), an optional operation name (`GetUser`), and variables (`$id: ID!`). Inside the curly braces, you define the fields you want to retrieve, potentially nesting them for related data (e.g., `user` and its `posts`).\n\n## GraphQL Mutations\nMutations are used to modify data on the server. This includes creating, updating, or deleting records. Like queries, mutations are declarative and can accept variables for the data being sent to the server. The response of a mutation typically includes the state of the data after the operation, allowing the client to update its UI or cache accordingly.\n\n### Structure of a Mutation\nA GraphQL mutation specifies the operation type (`mutation`), an optional operation name (`CreatePost`), and variables (`$title: String!, $content: String!, $authorId: ID!`). Within the mutation, you call a server-defined mutation field (e.g., `createPost`) and specify the fields you want to receive back from the server after the operation is complete.\n\n## `gql` Tag and Client Interaction\nModern GraphQL clients often use a `gql` tag (from `graphql-tag` or similar) to parse GraphQL query strings into an Abstract Syntax Tree (AST), which the client can then send to the server. The `client.query` and `client.mutate` methods are typically asynchronous, returning Promises that resolve with the server's response.",
          "examples": [
            {
              "id": "example_graphql_query",
              "title": "GraphQL Query Example: Fetch User Data",
              "code": "import { ApolloClient, InMemoryCache, gql } from '@apollo/client';\n\nconst client = new ApolloClient({\n  uri: 'http://localhost:4000/graphql',\n  cache: new InMemoryCache(),\n});\n\nclient.query({\n  query: gql`\n    query GetUser($id: ID!) {\n      user(id: $id) {\n        id\n        name\n        email\n        posts {\n          id\n          title\n        }\n      }\n    }\n  `,\n  variables: { id: \"1\" }\n}).then(result => console.log('Query Result:', result.data))\n  .catch(error => console.error('Query Error:', error));",
              "explanation": "This example demonstrates fetching user data using a GraphQL query. The `GetUser` query specifies an `id` variable to retrieve a specific user. It asks for the user's `id`, `name`, `email`, and a list of their `posts`, including each post's `id` and `title`. The `variables` object passes the actual `id` value. The `.then()` block logs the data received from the server.",
              "language": "typescript"
            },
            {
              "id": "example_graphql_mutation",
              "title": "GraphQL Mutation Example: Create a New Post",
              "code": "import { ApolloClient, InMemoryCache, gql } from '@apollo/client';\n\nconst client = new ApolloClient({\n  uri: 'http://localhost:4000/graphql',\n  cache: new InMemoryCache(),\n});\n\nclient.mutate({\n  mutation: gql`\n    mutation CreatePost($title: String!, $content: String!, $authorId: ID!) {\n      createPost(title: $title, content: $content, authorId: $authorId) {\n        id\n        title\n      }\n    }\n  `,\n  variables: {\n    title: \"New Post From Client\",\n    content: \"This is the content of the new post.\",\n    authorId: \"1\"\n  }\n}).then(result => console.log('Mutation Result:', result.data))\n  .catch(error => console.error('Mutation Error:', error));",
              "explanation": "This example shows how to perform a mutation to create a new post. The `CreatePost` mutation defines variables for `title`, `content`, and `authorId`. The `createPost` field is called on the server, and the client requests the `id` and `title` of the newly created post back in the response. The `variables` object provides the actual data for the new post.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "GraphQL",
            "API",
            "Data Fetching",
            "Mutations",
            "Queries",
            "Apollo Client"
          ],
          "technology": "GraphQL",
          "prerequisites": [
            "JavaScript_Promises",
            "HTTP_Requests",
            "Basic_API_Concepts"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "GraphQL_Backend_Integration",
            "Real-time_Data_with_Subscriptions"
          ]
        },
        {
          "id": "theory_babel_transpilation",
          "title": "Babel: JavaScript Transpilation for Compatibility",
          "content": "Babel is a powerful JavaScript compiler, often referred to as a transpiler. Its primary role in modern web development is to transform JavaScript code written with modern syntax (ES6+ features) into backward-compatible versions that can run on older browsers and environments that do not fully support the latest ECMAScript specifications.\n\n## Why Babel is Essential\nJavaScript evolves rapidly, introducing new syntax features (like arrow functions, classes, `let`/`const`, async/await, etc.) that improve developer productivity and code readability. However, not all browsers or Node.js environments immediately support these new features. Babel bridges this gap, allowing developers to write future-proof JavaScript today while ensuring broad compatibility for their applications.\n\n## Key Features of Babel\nBabel works by parsing modern JavaScript code into an Abstract Syntax Tree (AST), applying transformations (via plugins), and then generating new code from the transformed AST. This process effectively 'translates' high-level syntax into lower-level, more widely supported syntax.\n\n### Transformation Examples\n-   **Arrow Functions:** Converts `const add = (a, b) => a + b;` to `var add = function(a, b) { return a + b; };`.\n-   **Class Syntax:** Transforms `class Person { ... }` into traditional ES5 constructor functions and prototype-based methods.\n-   **`let`/`const`:** Converts these to `var` declarations (with appropriate scope handling).\n-   **Object Destructuring, Spread Syntax, Template Literals:** Converts these into equivalent ES5 operations.\n\n## Basic Configuration (`babel.config.js`)\nBabel's behavior is controlled via configuration files, commonly `babel.config.js` or `.babelrc`. These files specify which presets and plugins Babel should use during transpilation.\n\n-   **Presets:** A preset is a shareable set of Babel plugins. They are designed to transpile specific sets of features or for specific environments (e.g., all ES2015+ features, React JSX, TypeScript).\n-   **Plugins:** A plugin is a smaller, more granular transformation. Plugins handle a very specific syntactic transformation (e.g., transforming class properties).\n\n## Common Babel Presets\n-   **`@babel/preset-env`**: This is a 'smart' preset that determines which JavaScript features need to be transformed based on the specified target environments (e.g., specific browser versions, Node.js versions). It uses `browserslist` configuration to only apply necessary transformations, leading to smaller bundle sizes and faster compilation.\n    -   `targets`: Defines the target browsers or Node.js environments.\n    -   `useBuiltIns`: When set to `'usage'` or `'entry'`, it automatically adds `core-js` polyfills based on actual usage in your code or all features for the specified targets, respectively. This prevents including unnecessary polyfills.\n    -   `corejs`: Specifies the `core-js` version to use for polyfills.\n-   **`@babel/preset-react`**: This preset is essential for React development as it transforms JSX (JavaScript XML) syntax into `React.createElement()` calls, which browsers can understand.\n-   **`@babel/preset-typescript`**: This preset adds support for transpiling TypeScript code, allowing you to use TypeScript features without needing to compile TypeScript separately (though type checking still requires a TypeScript compiler).",
          "examples": [
            {
              "id": "example_babel_arrow_function",
              "title": "Babel Transpilation: Arrow Function",
              "code": "// ES6 arrow function\nconst add = (a, b) => a + b;\n\n// Transformed to ES5 by Babel\nvar add = function(a, b) {\n  return a + b;\n};",
              "explanation": "This example illustrates how Babel transforms a modern ES6 arrow function into its equivalent ES5 function expression, ensuring compatibility with older JavaScript environments.",
              "language": "javascript"
            },
            {
              "id": "example_babel_class_syntax",
              "title": "Babel Transpilation: Class Syntax",
              "code": "// ES6 class syntax\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHello() {\n    return `Hello, ${this.name}`;\n  }\n}\n\n// Transformed to ES5 by Babel (simplified example)\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.sayHello = function() {\n  return 'Hello, ' + this.name;\n};",
              "explanation": "This demonstrates Babel's transformation of ES6 class syntax into traditional ES5 constructor functions and prototype methods, which is how object-oriented programming was commonly achieved in older JavaScript versions.",
              "language": "javascript"
            },
            {
              "id": "example_babel_config",
              "title": "Babel Configuration File (`babel.config.js`)",
              "code": "// babel.config.js\nmodule.exports = {\n  presets: [\n    [\"@babel/preset-env\", {\n      targets: {\n        browsers: [\"last 2 versions\", \"not dead\"],\n      },\n      useBuiltIns: \"usage\",\n      corejs: 3\n    }],\n    \"@babel/preset-react\" // For React JSX transformation\n  ],\n  plugins: [\n    \"@babel/plugin-proposal-class-properties\",\n    \"@babel/plugin-transform-runtime\"\n  ]\n};",
              "explanation": "This configuration file shows how to set up Babel with common presets and plugins. `preset-env` targets modern browsers and includes polyfills for features used. `preset-react` handles JSX. Plugins like `plugin-proposal-class-properties` and `plugin-transform-runtime` add support for specific experimental features or optimize helper functions.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "JavaScript",
            "Transpilation",
            "Babel",
            "Build Tools",
            "ES6",
            "ES5",
            "Frontend Tooling",
            "Presets",
            "Plugins"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "JavaScript_Fundamentals",
            "ES6_Features",
            "Node.js_Basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Webpack_Integration",
            "Modern_Frontend_Development",
            "React_Development"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_graphql_query_vs_mutation_mcq",
          "topic": "GraphQL Queries vs. Mutations",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following best describes the primary use case for a GraphQL Query?",
          "answer": "To retrieve data from the server without modifying it.",
          "options": [
            "To modify existing data on the server.",
            "To subscribe to real-time data updates.",
            "To retrieve data from the server without modifying it.",
            "To define the schema of the GraphQL API."
          ],
          "analysisPoints": [
            "Queries are read operations.",
            "Mutations are write operations (create, update, delete).",
            "Subscriptions are for real-time data.",
            "Schema definition is server-side, not a client-side operation type."
          ],
          "keyConcepts": [
            "GraphQL Query",
            "GraphQL Mutation",
            "Data Fetching"
          ],
          "evaluationCriteria": [
            "Understanding of GraphQL operation types.",
            "Ability to distinguish between data retrieval and modification."
          ],
          "example": "GraphQL Queries are analogous to GET requests in REST, used purely for fetching information. Mutations are like POST, PUT, DELETE requests, used for changing server-side data.",
          "tags": [
            "GraphQL",
            "Query",
            "Basics"
          ],
          "prerequisites": [
            "GraphQL_Client_Operations"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_graphql_variable_usage_open",
          "topic": "GraphQL Variables",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose of using `variables` in GraphQL queries and mutations, and provide a brief example of how they are passed to a client method.",
          "answer": "Variables in GraphQL queries and mutations allow for dynamic values to be passed into an operation, making the operations reusable and preventing string concatenation for input data, which can lead to security vulnerabilities (like injection). They are defined with a `$` prefix and a type in the operation definition (e.g., `$id: ID!`) and then referenced within the query/mutation body. On the client-side, they are typically passed as a separate JavaScript object to the `variables` property of the `query` or `mutate` method.\n\n**Example:**\n```typescript\n// GraphQL operation definition\nconst GET_PRODUCT = gql`\n  query GetProductDetails($productId: ID!) {\n    product(id: $productId) {\n      name\n      price\n    }\n  }\n`;\n\n// Client-side execution\nclient.query({\n  query: GET_PRODUCT,\n  variables: { productId: \"abc-123\" }\n}).then(result => console.log(result.data.product));\n```",
          "analysisPoints": [
            "Reusability of operations.",
            "Prevention of injection attacks.",
            "Clear separation of operation logic and input data.",
            "Correct syntax for defining and passing variables."
          ],
          "keyConcepts": [
            "GraphQL Variables",
            "Parameterization",
            "Security"
          ],
          "evaluationCriteria": [
            "Understanding of dynamic data input in GraphQL.",
            "Ability to explain benefits and demonstrate usage."
          ],
          "example": null,
          "tags": [
            "GraphQL",
            "Variables",
            "Best Practices"
          ],
          "prerequisites": [
            "GraphQL_Client_Operations"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_graphql_create_post_code",
          "topic": "GraphQL Mutation Coding",
          "level": "medium",
          "type": "code",
          "question": "Given the following GraphQL mutation definition, write the JavaScript code snippet using an Apollo-like client (`client.mutate`) to create a new post with a title 'My New Article', content 'This is the body.', and author ID '5'. Log the `id` and `title` of the created post from the response.",
          "answer": "```typescript\nimport { ApolloClient, InMemoryCache, gql } from '@apollo/client';\n\nconst client = new ApolloClient({\n  uri: 'http://localhost:4000/graphql',\n  cache: new InMemoryCache(),\n});\n\nconst CREATE_POST_MUTATION = gql`\n  mutation CreatePost($title: String!, $content: String!, $authorId: ID!) {\n    createPost(title: $title, content: $content, authorId: $authorId) {\n      id\n      title\n    }\n  }\n`;\n\nclient.mutate({\n  mutation: CREATE_POST_MUTATION,\n  variables: {\n    title: \"My New Article\",\n    content: \"This is the body.\",\n    authorId: \"5\"\n  }\n}).then(result => {\n  if (result.data && result.data.createPost) {\n    console.log(`Created Post ID: ${result.data.createPost.id}`);\n    console.log(`Created Post Title: ${result.data.createPost.title}`);\n  } else {\n    console.warn('Post creation might have failed or returned unexpected data.');\n  }\n}).catch(error => console.error('Error creating post:', error));\n```",
          "analysisPoints": [
            "Correctly uses `client.mutate`.",
            "Passes the GraphQL mutation string using `gql`.",
            "Correctly structures the `variables` object.",
            "Accesses nested data in the `result.data` object.",
            "Includes basic error handling with `.catch()`."
          ],
          "keyConcepts": [
            "GraphQL Mutation",
            "Apollo Client",
            "Variables",
            "Asynchronous Operations"
          ],
          "evaluationCriteria": [
            "Ability to translate GraphQL definition to client code.",
            "Correct usage of `variables`.",
            "Understanding of promise-based API calls.",
            "Basic response parsing."
          ],
          "example": null,
          "tags": [
            "GraphQL",
            "Coding",
            "Mutation",
            "Intermediate"
          ],
          "prerequisites": [
            "GraphQL_Client_Operations"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_graphql_flashcard_gql_tag",
          "topic": "GraphQL Client Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `gql` tag (e.g., `gql` from `graphql-tag` or Apollo Client) when writing GraphQL operations in JavaScript?",
          "answer": "To parse GraphQL query strings into an Abstract Syntax Tree (AST), making them understandable and processable by the GraphQL client library.",
          "analysisPoints": [],
          "keyConcepts": [
            "GraphQL",
            "gql tag",
            "AST"
          ],
          "evaluationCriteria": [
            "Recall of basic GraphQL client components."
          ],
          "example": null,
          "tags": [
            "GraphQL",
            "Flashcard",
            "Tooling"
          ],
          "prerequisites": [
            "GraphQL_Client_Operations"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_babel_purpose_mcq",
          "topic": "Babel Core Purpose",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary function of Babel in modern JavaScript development?",
          "answer": "To transpile modern JavaScript code into backward-compatible versions for older environments.",
          "options": [
            "To manage project dependencies and packages.",
            "To transpile modern JavaScript code into backward-compatible versions for older environments.",
            "To optimize CSS and HTML for production.",
            "To bundle multiple JavaScript files into a single output file."
          ],
          "analysisPoints": [
            "Babel is a transpiler/compiler.",
            "Its focus is on syntax transformation, not dependency management (like npm/yarn), CSS/HTML optimization, or bundling (like Webpack/Rollup)."
          ],
          "keyConcepts": [
            "Babel",
            "Transpilation",
            "Compatibility"
          ],
          "evaluationCriteria": [
            "Understanding of Babel's core role.",
            "Distinguishing Babel from other build tools."
          ],
          "example": "Without Babel, many modern ES6+ features like arrow functions or classes would not run on older browsers such as Internet Explorer 11.",
          "tags": [
            "Babel",
            "Transpilation",
            "Fundamentals"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_babel_preset_env_open",
          "topic": "Babel Presets: `@babel/preset-env`",
          "level": "medium",
          "type": "open",
          "question": "Describe the main purpose of `@babel/preset-env` and explain how its `targets` and `useBuiltIns` options contribute to efficient JavaScript transpilation.",
          "answer": "`@babel/preset-env` is a 'smart' Babel preset that allows you to use the latest JavaScript features without needing to manage specific syntax transforms (plugins) manually. Its main purpose is to automatically determine the necessary Babel plugins and core-js polyfills based on your specified target environments.\n\n-   **`targets`**: This option allows you to specify the browser versions, Node.js versions, or other environments your code needs to support (e.g., `browsers: [\"last 2 versions\", \"not dead\"]`). Based on these targets, `preset-env` intelligently includes only the transformations and polyfills required by those specific environments. This prevents unnecessary transpilation and polyfilling, resulting in smaller bundle sizes and potentially faster build times.\n\n-   **`useBuiltIns`**: This option controls how polyfills from `core-js` are injected. When set to `'usage'`, `preset-env` analyzes your code and adds polyfills only for the features actually used. When set to `'entry'`, it imports all required polyfills for the specified `targets` at the very beginning of your application. Both options aim to avoid including redundant polyfills, optimizing the final bundle size. Using `'usage'` is generally preferred for optimal bundle size as it's more granular, but `'entry'` can be simpler for polyfilling an entire application's environment.",
          "analysisPoints": [
            "Understanding of adaptive transpilation.",
            "How `targets` optimize output size.",
            "How `useBuiltIns` manages polyfills efficiently.",
            "Distinction between `'usage'` and `'entry'` for `useBuiltIns`."
          ],
          "keyConcepts": [
            "Babel",
            "preset-env",
            "Polyfills",
            "Targets",
            "useBuiltIns"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of preset-env.",
            "Detailed understanding of configuration options and their impact.",
            "Ability to explain optimization benefits."
          ],
          "example": null,
          "tags": [
            "Babel",
            "Configuration",
            "Optimization",
            "Advanced"
          ],
          "prerequisites": [
            "Babel_JavaScript_Transpilation"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_babel_jsx_flashcard",
          "topic": "Babel Presets",
          "level": "easy",
          "type": "flashcard",
          "question": "Which Babel preset is specifically responsible for transforming JSX syntax into standard JavaScript (e.g., `React.createElement` calls)?",
          "answer": "`@babel/preset-react`",
          "analysisPoints": [],
          "keyConcepts": [
            "Babel",
            "JSX",
            "React"
          ],
          "evaluationCriteria": [
            "Recall of specific Babel preset functionalities."
          ],
          "example": null,
          "tags": [
            "Babel",
            "React",
            "Flashcard"
          ],
          "prerequisites": [
            "Babel_JavaScript_Transpilation"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_babel_es6_to_es5_code",
          "topic": "Babel Transformation",
          "level": "medium",
          "type": "code",
          "question": "Given the following ES6 code snippet, show how Babel would typically transform it into ES5-compatible code. Assume a basic setup with `preset-env`.",
          "answer": "```javascript\n// ES6 Code Input:\nconst multiply = (x, y) => x * y;\n\nclass Calculator {\n  constructor(initialValue) {\n    this.value = initialValue;\n  }\n  add(num) {\n    return this.value + num;\n  }\n}\n\n// ES5 Transformed Code (by Babel):\nvar multiply = function(x, y) {\n  return x * y;\n};\n\nfunction Calculator(initialValue) {\n  this.value = initialValue;\n}\n\nCalculator.prototype.add = function(num) {\n  return this.value + num;\n};\n```",
          "analysisPoints": [
            "Correct transformation of arrow function to traditional function expression.",
            "Correct transformation of class syntax to constructor function and prototype methods.",
            "Understanding of `const` vs `var` implications (though simple `var` is shown here for brevity)."
          ],
          "keyConcepts": [
            "Babel",
            "ES6 to ES5",
            "Arrow Functions",
            "Classes",
            "Transpilation"
          ],
          "evaluationCriteria": [
            "Ability to demonstrate fundamental Babel transformations.",
            "Knowledge of ES5 equivalents for modern JavaScript features."
          ],
          "example": null,
          "tags": [
            "Babel",
            "Coding",
            "ES6",
            "ES5"
          ],
          "prerequisites": [
            "Babel_JavaScript_Transpilation",
            "ES6_Features"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_babel_plugins_flashcard",
          "topic": "Babel Components",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the difference between a Babel 'preset' and a Babel 'plugin'?",
          "answer": "A **plugin** is a small JavaScript program that transforms specific syntax, handling a single type of transformation (e.g., converting arrow functions). A **preset** is a collection of plugins, often grouped by a particular year's ECMAScript features (e.g., `preset-env` for all modern JS features) or a specific library's syntax (e.g., `preset-react` for JSX). Presets simplify configuration by bundling related plugins.",
          "analysisPoints": [],
          "keyConcepts": [
            "Babel",
            "Plugins",
            "Presets"
          ],
          "evaluationCriteria": [
            "Recall of Babel architectural components."
          ],
          "example": null,
          "tags": [
            "Babel",
            "Configuration",
            "Flashcard"
          ],
          "prerequisites": [
            "Babel_JavaScript_Transpilation"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_graphql_mock_client",
          "title": "Simulate GraphQL Client Interactions",
          "description": "\nImplement a `MockGraphQLClient` class that simulates basic GraphQL query and mutation operations. Your client should:\n\n1.  Have a `query` method that takes an object with `query` (a string) and `variables` properties. It should return a Promise that resolves with a mock data structure based on the query string.\n2.  Have a `mutate` method that takes an object with `mutation` (a string) and `variables` properties. It should return a Promise that resolves with a mock data structure based on the mutation string.\n3.  For `query`, if the query string contains 'GetUser', return mock user data. If it contains 'GetPosts', return mock posts data.\n4.  For `mutate`, if the mutation string contains 'CreatePost', simulate creation by returning a mock new post object incorporating the input variables.\n5.  Include basic error handling (e.g., reject the promise if no matching operation is found).\n\nThis task focuses on understanding the client-side interaction pattern with GraphQL, rather than actual server communication.\n",
          "difficulty": "medium",
          "startingCode": "import { gql } from '@apollo/client'; // Assume gql is available for parsing, or simplify\n\n// Mock data for queries\nconst MOCK_USER_DATA = {\n  user: {\n    id: '101',\n    name: 'Alice Smith',\n    email: 'alice@example.com',\n    posts: [\n      { id: 'p1', title: 'My First Blog' },\n      { id: 'p2', title: 'GraphQL Basics' }\n    ]\n  }\n};\n\nconst MOCK_POSTS_DATA = {\n  posts: [\n    { id: 'p1', title: 'Post One' },\n    { id: 'p2', title: 'Post Two' },\n  ]\n};\n\nclass MockGraphQLClient {\n  constructor(uri) {\n    this.uri = uri;\n  }\n\n  query({ query, variables }) {\n    console.log('Mock Query Received:', { query, variables });\n    return new Promise((resolve, reject) => {\n      // TODO: Implement logic to return mock data based on query string\n      // Check if query string contains 'GetUser' or 'GetPosts'\n      // Resolve with { data: MOCK_USER_DATA } or { data: MOCK_POSTS_DATA }\n      // Reject for unknown queries\n    });\n  }\n\n  mutate({ mutation, variables }) {\n    console.log('Mock Mutation Received:', { mutation, variables });\n    return new Promise((resolve, reject) => {\n      // TODO: Implement logic to return mock data based on mutation string\n      // Check if mutation string contains 'CreatePost'\n      // Resolve with { data: { createPost: { id: 'new-id', title: variables.title } } }\n      // Reject for unknown mutations\n    });\n  }\n}\n\n// Example Usage (for testing your implementation)\nconst client = new MockGraphQLClient('http://mock-graphql.com/graphql');\n\n// Test Query\nclient.query({\n  query: gql`query GetUser($id: ID!) { user(id: $id) { name } }`,\n  variables: { id: '1' }\n}).then(result => console.log('Query Result:', result.data))\n  .catch(error => console.error('Query Error:', error));\n\n// Test Mutation\nclient.mutate({\n  mutation: gql`mutation CreatePost($title: String!) { createPost(title: $title) { id title } }`,\n  variables: { title: 'My New Mock Post' }\n}).then(result => console.log('Mutation Result:', result.data))\n  .catch(error => console.error('Mutation Error:', error));\n",
          "solutionCode": "import { gql } from '@apollo/client';\n\nconst MOCK_USER_DATA = {\n  user: {\n    id: '101',\n    name: 'Alice Smith',\n    email: 'alice@example.com',\n    posts: [\n      { id: 'p1', title: 'My First Blog' },\n      { id: 'p2', title: 'GraphQL Basics' }\n    ]\n  }\n};\n\nconst MOCK_POSTS_DATA = {\n  posts: [\n    { id: 'p1', title: 'Post One' },\n    { id: 'p2', title: 'Post Two' },\n  ]\n};\n\nclass MockGraphQLClient {\n  constructor(uri) {\n    this.uri = uri;\n  }\n\n  query({ query, variables }) {\n    console.log('Mock Query Received:', { query: query.loc.source.body.trim().split(/\\s+/)[1], variables });\n    return new Promise((resolve, reject) => {\n      setTimeout(() => { // Simulate network delay\n        if (query.loc.source.body.includes('GetUser')) {\n          resolve({ data: MOCK_USER_DATA });\n        } else if (query.loc.source.body.includes('GetPosts')) {\n          resolve({ data: MOCK_POSTS_DATA });\n        } else {\n          reject(new Error('Unknown mock query operation.'));\n        }\n      }, 100);\n    });\n  }\n\n  mutate({ mutation, variables }) {\n    console.log('Mock Mutation Received:', { mutation: mutation.loc.source.body.trim().split(/\\s+/)[1], variables });\n    return new Promise((resolve, reject) => {\n      setTimeout(() => { // Simulate network delay\n        if (mutation.loc.source.body.includes('CreatePost')) {\n          const newPostId = `p${Math.floor(Math.random() * 100000)}`;\n          const createdPost = {\n            id: newPostId,\n            title: variables.title || 'Untitled Post',\n            content: variables.content || 'No content provided',\n            authorId: variables.authorId || 'unknown'\n          };\n          resolve({ data: { createPost: { id: createdPost.id, title: createdPost.title } } });\n        } else {\n          reject(new Error('Unknown mock mutation operation.'));\n        }\n      }, 100);\n    });\n  }\n}\n\n// Example Usage (for testing your implementation)\nconst client = new MockGraphQLClient('http://mock-graphql.com/graphql');\n\n// Test Query\nclient.query({\n  query: gql`query GetUser($id: ID!) { user(id: $id) { name } }`,\n  variables: { id: '1' }\n}).then(result => console.log('Query Result:', result.data))\n  .catch(error => console.error('Query Error:', error));\n\nclient.query({\n  query: gql`query GetPosts { posts { id title } }`,\n  variables: {}\n}).then(result => console.log('Query Result:', result.data))\n  .catch(error => console.error('Query Error:', error));\n\n// Test Mutation\nclient.mutate({\n  mutation: gql`mutation CreatePost($title: String!, $content: String!) { createPost(title: $title, content: $content) { id title } }`,\n  variables: { title: 'My New Mock Post', content: 'This is some mock content.' }\n}).then(result => console.log('Mutation Result:', result.data))\n  .catch(error => console.error('Mutation Error:', error));\n\n// Test unknown operation\nclient.query({\n  query: gql`query InvalidQuery { invalid { field } }`\n}).catch(error => console.error('Expected Error (Invalid Query):', error.message));\n",
          "testCases": [
            "Call `client.query` with a 'GetUser' query string and verify it resolves with `MOCK_USER_DATA`.",
            "Call `client.query` with a 'GetPosts' query string and verify it resolves with `MOCK_POSTS_DATA`.",
            "Call `client.mutate` with a 'CreatePost' mutation string and verify it resolves with a new post object containing the provided `title` and a generated `id`.",
            "Call `client.query` or `client.mutate` with an unrecognized operation and verify that the promise rejects with an appropriate error.",
            "Ensure `variables` are correctly logged/used in the mock operation for mutations."
          ],
          "hints": [
            "Use `String.prototype.includes()` to check for operation names within the `query` or `mutation` string.",
            "Remember that the `gql` tagged template literal produces an object with a `loc.source.body` property containing the raw string if you're simulating without full AST parsing.",
            "Wrap the mock data resolution in a `setTimeout` to simulate asynchronous network requests."
          ],
          "tags": [
            "GraphQL",
            "Client",
            "Mocking",
            "Promises",
            "OOP"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "JavaScript_Promises",
            "GraphQL_Client_Operations",
            "ES6_Classes"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Asynchronous_JavaScript",
            "Testing_Strategies"
          ]
        },
        {
          "id": "task_babel_config_setup",
          "title": "Configure Babel for a Frontend Project",
          "description": "\nSet up a basic Babel configuration for a new frontend project. Your configuration should:\n\n1.  Transpile modern JavaScript (ES6+ syntax) to ES5 for broad browser compatibility.\n2.  Specifically target browsers that are 'last 2 versions' and 'not dead'.\n3.  Include polyfills only for features that are actually used in the code, leveraging `core-js` version 3.\n4.  Enable support for JSX syntax, assuming a React project.\n5.  Include support for Class Properties (e.g., `class MyComponent { myProp = 1; }`).\n\nProvide the `babel.config.js` file content and explain why each part is included. You don't need to write actual JavaScript code, just the configuration.\n",
          "difficulty": "medium",
          "startingCode": "/*\n  Task: Create babel.config.js\n\n  Your module.exports object should contain:\n  - presets array\n  - plugins array\n\n  Consider these requirements:\n  1. ES6+ to ES5 compatibility (use `preset-env`)\n  2. Browser targeting (`targets` option)\n  3. Usage-based polyfilling (`useBuiltIns`, `corejs`)\n  4. JSX support (`preset-react`)\n  5. Class Properties support (`plugin-proposal-class-properties`)\n*/\n\n// babel.config.js (Your solution will go here)\nmodule.exports = {\n  // TODO: Add your Babel presets and plugins here\n};\n",
          "solutionCode": "// babel.config.js\nmodule.exports = {\n  presets: [\n    [\"@babel/preset-env\", {\n      targets: {\n        browsers: [\"last 2 versions\", \"not dead\"],\n      },\n      useBuiltIns: \"usage\",\n      corejs: 3\n    }],\n    \"@babel/preset-react\"\n  ],\n  plugins: [\n    \"@babel/plugin-proposal-class-properties\"\n  ]\n};\n\n/*\nExplanation of Solution:\n\n- `@babel/preset-env`:\n  - `targets: { browsers: [\"last 2 versions\", \"not dead\"] }`: This configuration tells Babel to transpile JavaScript features only if they are not supported by the specified browser targets. 'last 2 versions' covers the two most recent versions of major browsers, and 'not dead' excludes browsers that are no longer officially supported.\n  - `useBuiltIns: \"usage\"`: This setting ensures that polyfills from `core-js` are included only for the specific JavaScript features (e.g., `Promise`, `Array.prototype.includes`) that are actually used in your codebase and are missing in your target environments. This minimizes bundle size.\n  - `corejs: 3`: Specifies that `core-js` version 3 should be used for polyfilling. It's crucial to have `core-js` installed as a dependency (`npm install core-js`).\n\n- `@babel/preset-react`:\n  - This preset is responsible for transforming JSX syntax (used extensively in React) into standard JavaScript function calls (e.g., `React.createElement`). This allows browsers to understand and render React components.\n\n- `@babel/plugin-proposal-class-properties`:\n  - This plugin enables support for the class properties syntax (e.g., `myProperty = 'value';` directly inside a class, without needing `this.myProperty = 'value';` in the constructor). This is a stage 3 ECMAScript proposal that provides a more concise way to define properties on a class instance.\n*/\n",
          "testCases": [
            "Verify `preset-env` is present with correct `targets`, `useBuiltIns`, and `corejs` options.",
            "Verify `preset-react` is included.",
            "Verify `plugin-proposal-class-properties` is included.",
            "Ensure no unnecessary presets/plugins are added."
          ],
          "hints": [
            "Remember that `preset-env` needs an array for its options.",
            "Think about what each requirement translates to in terms of Babel components (presets vs. plugins).",
            "The `plugin-transform-runtime` is often used but not explicitly required by the prompt's `class properties` mention, so consider if it's strictly necessary based on the requirements."
          ],
          "tags": [
            "Babel",
            "Configuration",
            "Frontend Tooling",
            "React",
            "ES6"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "Babel_JavaScript_Transpilation",
            "ES6_Classes"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Webpack",
            "Polyfills",
            "Browserslist"
          ]
        }
      ]
    }
  },
  {
    "id": "926ec145-0d15-49eb-8c97-a731bcaa855c",
    "startLine": 13300,
    "endLine": 13399,
    "processedDate": "2025-06-17T13:25:38.680Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_webpack_fundamentals",
          "title": "Webpack Fundamentals: Basic Configuration and Core Concepts",
          "content": "Webpack is a static module bundler for modern JavaScript applications. When Webpack processes your application, it internally builds a dependency graph from one or more entry points and then combines every module your project needs into one or more bundles.\n\n## Key Concepts\n\n*   **Entry**: The `entry` property indicates which module Webpack should use to begin building its internal dependency graph. Webpack will figure out which other modules and libraries that entry point depends on (directly and indirectly).\n*   **Output**: The `output` property tells Webpack where to emit the bundles it creates and how to name these files.\n    *   `path.resolve(__dirname, 'dist')`: Specifies the absolute path to the output directory.\n    *   `filename: 'bundle.[contenthash].js'`: Defines the name of the output bundle. `[contenthash]` is a placeholder that will be replaced by a hash of the content of the bundled file. This is useful for cache busting in production.\n*   **Loaders**: Loaders are crucial for Webpack. They tell Webpack how to process different types of files as modules in your dependency graph. For example, you can use loaders to transpile JavaScript (e.g., ES6+ to ES5), compile CSS/Sass/Less, or load image files.\n    *   `test`: A regular expression that matches the file types to be processed by the loader.\n    *   `exclude`: Specifies paths that should not be processed by the loader (e.g., `node_modules`).\n    *   `use`: An array of loaders to apply to the matching files. Loaders are applied in reverse order (right to left).\n        *   `babel-loader`: Transpiles modern JavaScript/React code into compatible versions for older browsers. Requires `@babel/preset-env` for general JS and `@babel/preset-react` for JSX.\n        *   `css-loader`: Interprets `@import` and `url()` like `import/require()` and resolves them.\n        *   `style-loader`: Injects CSS into the DOM by adding `<style>` tags.\n        *   `file-loader`: Resolves `import`/`require` on a file into a url and emits the file into the output directory.\n*   **Plugins**: Plugins are powerful tools that can perform a wide range of tasks, from bundle optimization and asset management to injecting environment variables. They hook into the entire compilation lifecycle.\n    *   `HtmlWebpackPlugin`: Simplifies creation of HTML files to serve your webpack bundles. This is especially useful for bundles with a `contenthash` in their filenames which change every compilation.\n*   **DevServer**: `webpack-dev-server` provides a simple web server with live reloading and hot module replacement (HMR) capabilities. It serves your bundled application from memory, making development faster.\n    *   `contentBase: './dist'`: Specifies the directory from which to serve static files.\n    *   `hot: true`: Enables Hot Module Replacement (HMR), which allows modules to be updated in the browser without a full page reload, preserving application state.\n\nWebpack's extensibility through loaders and plugins makes it a highly flexible and powerful tool for managing complex frontend builds, optimizing assets, and ensuring consistent application behavior across different environments.",
          "examples": [
            {
              "id": "example_webpack_basic_config",
              "title": "Basic Webpack Configuration",
              "code": "const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.[contenthash].js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react']\n          }\n        }\n      },\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      },\n      {\n        test: /\\.(png|svg|jpg|gif)$/,\n        use: ['file-loader']\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  devServer: {\n    contentBase: './dist',\n    hot: true\n  }\n};",
              "explanation": "This configuration sets up Webpack to bundle JavaScript, CSS, and image assets. It uses Babel for JavaScript transpilation, specific loaders for CSS and images, and `HtmlWebpackPlugin` to generate an HTML file that includes the bundled assets. The `devServer` is configured for live reloading and Hot Module Replacement during development.",
              "language": "javascript"
            },
            {
              "id": "example_webpack_run_script",
              "title": "Running Webpack via npm script",
              "code": "{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"build\": \"webpack --mode production\",\n    \"start\": \"webpack serve --mode development\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.23.9\",\n    \"@babel/preset-env\": \"^7.23.9\",\n    \"@babel/preset-react\": \"^7.23.3\",\n    \"babel-loader\": \"^9.1.3\",\n    \"css-loader\": \"^6.9.1\",\n    \"file-loader\": \"^6.2.0\",\n    \"html-webpack-plugin\": \"^5.6.0\",\n    \"style-loader\": \"^3.3.4\",\n    \"webpack\": \"^5.90.0\",\n    \"webpack-cli\": \"^5.1.4\",\n    \"webpack-dev-server\": \"^4.11.1\"\n  }\n}",
              "explanation": "This `package.json` snippet shows how to define `npm` scripts to run Webpack for building a production bundle (`webpack --mode production`) and starting a development server (`webpack serve --mode development`). It also lists the necessary Webpack and Babel related dependencies.",
              "language": "json"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "Webpack",
            "Bundler",
            "Configuration",
            "Frontend Build",
            "JavaScript",
            "Tools"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "Node.js",
            "npm/yarn",
            "Basic JavaScript Modules"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "React Development",
            "Vue Development",
            "Modern Web Development",
            "Build Optimization"
          ]
        },
        {
          "id": "theory_fibonacci_sequence",
          "title": "Fibonacci Sequence: Recursive vs. Iterative Implementations",
          "content": "The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence typically begins: 0, 1, 1, 2, 3, 5, 8, 13, 21, and so on.\nMathematically, it's defined by the recurrence relation: `F(n) = F(n-1) + F(n-2)` with base cases `F(0) = 0` and `F(1) = 1`.\n\n## Recursive Implementation\n\nThe recursive approach directly translates the mathematical definition into code. Each call `fibonacci(n)` makes two further calls to `fibonacci(n-1)` and `fibonacci(n-2)` until the base cases are reached. While elegant and easy to understand, this method is highly inefficient for larger `n` due to redundant calculations of the same Fibonacci numbers multiple times.\n\n*   **Time Complexity**: O(2^n). This is exponential because the number of function calls roughly doubles with each increase in `n`. The call tree branches out significantly, leading to re-computation of many subproblems.\n*   **Space Complexity**: O(n). This is due to the recursion stack depth. In the worst case, the stack will hold `n` frames before the base case is reached.\n\n## Iterative Implementation\n\nThe iterative approach, also known as a bottom-up approach or dynamic programming, calculates the Fibonacci numbers in a loop, storing only the necessary previous values. This avoids the redundant calculations and overhead of recursive function calls, making it significantly more efficient.\n\n*   **Time Complexity**: O(n). The loop runs `n` times, performing a constant amount of work in each iteration.\n*   **Space Complexity**: O(1). Only a constant number of variables are used to store `prev` and `curr` values, regardless of `n`.\n\nFor practical applications and larger `n` values, the iterative approach is almost always preferred due to its superior performance characteristics.",
          "examples": [
            {
              "id": "example_fibonacci_recursive",
              "title": "Recursive Fibonacci Implementation",
              "code": "const fibonacciRecursive = num => {\n  // If num equals 0 or 1, return num (base cases)\n  if(num < 2) {\n    return num;\n  }\n  \n  // Recursive implementation\n  return fibonacciRecursive(num - 1) + fibonacciRecursive(num - 2);\n};",
              "explanation": "This is a direct translation of the Fibonacci definition. For `fibonacciRecursive(5)`, it will calculate `fibonacciRecursive(4) + fibonacciRecursive(3)`. `fibonacciRecursive(4)` will again calculate `fibonacciRecursive(3) + fibonacciRecursive(2)`, demonstrating the redundant calculations that lead to its O(2^n) time complexity.",
              "language": "javascript"
            },
            {
              "id": "example_fibonacci_iterative",
              "title": "Iterative Fibonacci Implementation",
              "code": "function fibonacciIterative(n) {\n  if (n < 2) return n;\n  \n  let prev = 0;\n  let curr = 1;\n  \n  for (let i = 2; i <= n; i++) {\n    const temp = curr;\n    curr = prev + curr;\n    prev = temp;\n  }\n  \n  return curr;\n}",
              "explanation": "This iterative approach calculates Fibonacci numbers from the bottom up. It keeps track of the two previous numbers (`prev` and `curr`) to compute the next one. This avoids redundant computations and recursive call overhead, resulting in an efficient O(n) time and O(1) space complexity.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "Algorithm",
            "Recursion",
            "Iteration",
            "Dynamic Programming",
            "Time Complexity",
            "Space Complexity",
            "Fibonacci"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "Basic loops",
            "Functions",
            "Recursion concepts"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Dynamic Programming",
            "Algorithm Optimization",
            "Understanding Recursion"
          ]
        },
        {
          "id": "theory_fizzbuzz_problem",
          "title": "FizzBuzz Problem: Basic Conditional Logic and Loops",
          "content": "The FizzBuzz problem is a classic programming interview question used to gauge a candidate's basic understanding of loops, conditionals, and modulo arithmetic. The task is to iterate from 1 to 100 (or any given number) and for each number:\n\n*   If the number is divisible by both 3 and 5, print \"FizzBuzz\".\n*   If the number is divisible by 3 (but not 5), print \"Fizz\".\n*   If the number is divisible by 5 (but not 3), print \"Buzz\".\n*   Otherwise, print the number itself.\n\n## Implementation Details\n\nThe core of the solution involves a loop (typically a `for` loop) that iterates through the numbers. Inside the loop, a series of `if-else if-else` statements check the divisibility conditions. The order of these checks is crucial: the condition for divisibility by both 3 and 5 (`i % 5 === 0 && i % 3 === 0`) must be checked first. If this condition were checked after `i % 3 === 0` or `i % 5 === 0`, numbers divisible by both (e.g., 15) would incorrectly output \"Fizz\" or \"Buzz\" instead of \"FizzBuzz\".\n\nModulo operator (`%`): Returns the remainder of a division. If `a % b === 0`, then `a` is perfectly divisible by `b`.\n\nThis problem is simple but effective for quickly assessing foundational programming skills.",
          "examples": [
            {
              "id": "example_fizzbuzz_basic",
              "title": "Basic FizzBuzz Implementation",
              "code": "function fizzBuzz() {\n  for(let i = 1; i <= 100; i++) {\n    if(i % 5 === 0 && i % 3 === 0) {\n      console.log('FizzBuzz');\n    } else if(i % 3 === 0) {\n      console.log('Fizz');\n    } else if(i % 5 === 0) {\n      console.log('Buzz');\n    } else {\n      console.log(i);\n    }\n  }\n}",
              "explanation": "This implementation iterates from 1 to 100. It correctly prioritizes the 'FizzBuzz' condition by checking `i % 5 === 0 && i % 3 === 0` first. This ensures that numbers like 15, 30, etc., are correctly identified as 'FizzBuzz'. Subsequent `else if` statements handle 'Fizz' and 'Buzz' for numbers divisible by only 3 or 5, respectively. Otherwise, the number itself is printed.",
              "language": "javascript"
            },
            {
              "id": "example_fizzbuzz_alternative",
              "title": "FizzBuzz with String Concatenation",
              "code": "function fizzBuzzConcise() {\n  for (let i = 1; i <= 100; i++) {\n    let output = '';\n    if (i % 3 === 0) {\n      output += 'Fizz';\n    }\n    if (i % 5 === 0) {\n      output += 'Buzz';\n    }\n    console.log(output || i);\n  }\n}",
              "explanation": "This alternative FizzBuzz implementation uses string concatenation. It builds the `output` string by appending 'Fizz' if divisible by 3 and 'Buzz' if divisible by 5. If `output` remains an empty string (meaning not divisible by 3 or 5), it defaults to the number `i`. This approach naturally handles the 'FizzBuzz' case without needing a separate `&&` condition and can be more extensible for additional rules.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "Algorithm",
            "Conditionals",
            "Loops",
            "Modulo Operator",
            "Basic Programming",
            "FizzBuzz"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "Basic loops",
            "If/Else statements",
            "Modulo operator"
          ],
          "complexity": 3,
          "interviewRelevance": 6,
          "learningPath": "beginner",
          "requiredFor": [
            "Basic Programming Concepts",
            "Logic Building"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_webpack_entry_purpose",
          "topic": "Webpack Entry Point",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of the `entry` property in a Webpack configuration?",
          "answer": "It specifies the starting point(s) from which Webpack begins to build its dependency graph.",
          "options": [
            "It specifies the output directory for bundled files.",
            "It defines which loaders should be applied to JavaScript files.",
            "It specifies the starting point(s) from which Webpack begins to build its dependency graph.",
            "It configures the development server's content base."
          ],
          "analysisPoints": [
            "Tests understanding of core Webpack configuration properties.",
            "Distinguishes `entry` from `output`, `module.rules`, and `devServer`."
          ],
          "keyConcepts": [
            "Webpack Entry",
            "Dependency Graph",
            "Module Bundling"
          ],
          "evaluationCriteria": [
            "Correct identification of Webpack configuration roles."
          ],
          "example": "The `entry` property is fundamental to Webpack, telling it where to start processing your application's modules. For example: `entry: './src/index.js'` points to the main JavaScript file.",
          "tags": [
            "Webpack",
            "Configuration",
            "Entry Point"
          ],
          "prerequisites": [
            "Basic Webpack knowledge"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_webpack_loaders_purpose",
          "topic": "Webpack Loaders",
          "level": "medium",
          "type": "open",
          "question": "Explain the role of 'loaders' in Webpack. Provide an example of when you would use `babel-loader` and why.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Understanding of Webpack's processing pipeline.",
            "Ability to articulate the function of loaders.",
            "Knowledge of specific loader use cases (e.g., transpilation).",
            "Explanation of `babel-loader`'s necessity for modern JavaScript/React."
          ],
          "keyConcepts": [
            "Webpack Loaders",
            "Module Transformation",
            "Babel-Loader",
            "Transpilation"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of explanation.",
            "Relevance and correctness of the example provided.",
            "Depth of understanding regarding JavaScript compatibility."
          ],
          "example": "Loaders transform files that are not JavaScript (or even modern JavaScript) into valid modules that can be consumed by your application and added to the dependency graph. `babel-loader` is used to transpile modern JavaScript (ES6+) and JSX (for React) into backward-compatible versions of JavaScript that can run in older browsers. This is crucial for ensuring wide browser compatibility without sacrificing modern language features during development.",
          "tags": [
            "Webpack",
            "Loaders",
            "Babel",
            "Transpilation"
          ],
          "prerequisites": [
            "Webpack basics",
            "ES6+ JavaScript",
            "Browser compatibility"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_webpack_plugins_vs_loaders",
          "topic": "Webpack Loaders vs. Plugins",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following best describes the difference between Webpack loaders and plugins?",
          "answer": "Loaders handle specific file types during module import/loading, while plugins execute custom logic throughout the entire compilation lifecycle.",
          "options": [
            "Loaders are used for code splitting, while plugins are for tree-shaking.",
            "Loaders modify the output bundle, while plugins transform individual modules.",
            "Loaders handle specific file types during module import/loading, while plugins execute custom logic throughout the entire compilation lifecycle.",
            "Loaders only work with JavaScript files, while plugins can work with any file type."
          ],
          "analysisPoints": [
            "Differentiates between core Webpack extension mechanisms.",
            "Tests understanding of their scope and function.",
            "Identifies common misconceptions."
          ],
          "keyConcepts": [
            "Webpack Loaders",
            "Webpack Plugins",
            "Compilation Lifecycle",
            "Module Transformation"
          ],
          "evaluationCriteria": [
            "Accuracy in distinguishing roles.",
            "Understanding of Webpack's extensibility."
          ],
          "example": "Loaders operate on individual files *before* they are bundled (e.g., `css-loader` transforms CSS into a CommonJS module). Plugins, on the other hand, can hook into various stages of the build process to perform broader tasks like optimization, asset management, or injecting environment variables (e.g., `HtmlWebpackPlugin` generates HTML files).",
          "tags": [
            "Webpack",
            "Loaders",
            "Plugins"
          ],
          "prerequisites": [
            "Webpack fundamentals"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_webpack_cache_busting",
          "topic": "Webpack Cache Busting",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the purpose of `[contenthash]` in the `output.filename` property of a Webpack configuration?",
          "answer": "`[contenthash]` is used for cache busting. It generates a hash based on the content of the bundled file. If the file's content changes, the hash changes, resulting in a new filename. This forces browsers to download the new version instead of serving an outdated cached version.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Webpack Output",
            "Content Hash",
            "Cache Busting",
            "Browser Caching"
          ],
          "evaluationCriteria": [],
          "example": "If your `output.filename` is `bundle.[contenthash].js`, and the content of `bundle.js` changes, its name might change from `bundle.abcd123.js` to `bundle.efgh456.js`, signaling to the browser that it's a new file.",
          "tags": [
            "Webpack",
            "Caching",
            "Performance",
            "Content Hash"
          ],
          "prerequisites": [
            "Webpack output",
            "Browser caching"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_webpack_devserver_features",
          "topic": "Webpack DevServer",
          "level": "easy",
          "type": "mcq",
          "question": "Which `webpack-dev-server` feature allows modules to be updated in the browser without a full page reload, preserving application state?",
          "answer": "Hot Module Replacement (HMR)",
          "options": [
            "Live Reloading",
            "Content Base Serving",
            "Hot Module Replacement (HMR)",
            "Proxy Configuration"
          ],
          "analysisPoints": [
            "Tests knowledge of `webpack-dev-server` features.",
            "Distinguishes between HMR and simple live reloading."
          ],
          "keyConcepts": [
            "Webpack DevServer",
            "Hot Module Replacement (HMR)",
            "Live Reloading"
          ],
          "evaluationCriteria": [
            "Correctly identifies HMR's unique capability."
          ],
          "example": "In your `webpack.config.js`, setting `devServer: { hot: true }` enables HMR. When you make a change to a component, only that component is updated in the browser, rather than the entire page reloading, which saves time and preserves your current application state.",
          "tags": [
            "Webpack",
            "DevServer",
            "HMR"
          ],
          "prerequisites": [
            "Webpack fundamentals"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_fibonacci_complexity_recursive",
          "topic": "Fibonacci Time Complexity (Recursive)",
          "level": "medium",
          "type": "mcq",
          "question": "What is the approximate time complexity of the provided recursive `fibonacci` function for calculating the nth Fibonacci number, assuming no memoization?",
          "answer": "O(2^n)",
          "options": [
            "O(n)",
            "O(n log n)",
            "O(n^2)",
            "O(2^n)"
          ],
          "analysisPoints": [
            "Tests understanding of algorithmic complexity for recursive solutions.",
            "Highlights the inefficiency of naive recursion due to redundant computations."
          ],
          "keyConcepts": [
            "Time Complexity",
            "Recursion",
            "Fibonacci Sequence"
          ],
          "evaluationCriteria": [
            "Correct identification of exponential time complexity."
          ],
          "example": "```javascript\nconst fibonacci = num => {\n  if(num < 2) {\n    return num;\n  }\n  return fibonacci(num - 1) + fibonacci(num - 2);\n};\n```\nThis function recomputes the same Fibonacci numbers multiple times, leading to a rapidly growing number of function calls, hence exponential time complexity.",
          "tags": [
            "Algorithm",
            "Time Complexity",
            "Recursion",
            "Fibonacci"
          ],
          "prerequisites": [
            "Big O Notation",
            "Recursion"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_fibonacci_efficiency_comparison",
          "topic": "Fibonacci Efficiency",
          "level": "medium",
          "type": "open",
          "question": "Compare the iterative and recursive implementations of the Fibonacci sequence in terms of efficiency (Time and Space Complexity). Explain why the iterative approach is generally preferred for larger 'n'.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Understanding of Big O notation for time and space complexity.",
            "Ability to analyze different algorithmic approaches.",
            "Rationale for choosing an iterative over a recursive solution for performance.",
            "Explanation of redundant computations in recursion."
          ],
          "keyConcepts": [
            "Time Complexity",
            "Space Complexity",
            "Recursion",
            "Iteration",
            "Dynamic Programming (Implicit)",
            "Fibonacci Sequence"
          ],
          "evaluationCriteria": [
            "Accuracy of complexity analysis.",
            "Clarity of comparative explanation.",
            "Insight into practical performance considerations."
          ],
          "example": "The recursive `fibonacci` function has a time complexity of O(2^n) due to redundant calculations and a space complexity of O(n) due to the recursion stack. The iterative `fibonacciIterative` function has a time complexity of O(n) because it computes each number only once, and a space complexity of O(1) as it only stores a few variables. The iterative approach is preferred for larger `n` because its linear time complexity scales much better than the recursive approach's exponential complexity, preventing performance issues and stack overflows.",
          "tags": [
            "Algorithm",
            "Time Complexity",
            "Space Complexity",
            "Recursion",
            "Iteration",
            "Optimization"
          ],
          "prerequisites": [
            "Big O Notation",
            "Recursion",
            "Loops"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_fibonacci_iterative_details",
          "topic": "Fibonacci Iterative Implementation",
          "level": "easy",
          "type": "flashcard",
          "question": "In the iterative Fibonacci implementation, what is the purpose of the `temp` variable?",
          "answer": "The `temp` variable is used to temporarily store the current `curr` value before `curr` is updated to the sum of `prev` and `curr`. This allows the original `curr` value to be assigned to `prev` in the next step, correctly shifting the sequence forward.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Fibonacci",
            "Iterative Algorithm",
            "Variable Assignment"
          ],
          "evaluationCriteria": [],
          "example": "```javascript\nfunction fibonacciIterative(n) {\n  if (n < 2) return n;\n  let prev = 0;\n  let curr = 1;\n  for (let i = 2; i <= n; i++) {\n    const temp = curr; // Store the current 'curr' value\n    curr = prev + curr; // Calculate new 'curr'\n    prev = temp; // Update 'prev' with the old 'curr'\n  }\n  return curr;\n}\n```",
          "tags": [
            "Algorithm",
            "Iteration",
            "Fibonacci"
          ],
          "prerequisites": [
            "Basic variable assignment",
            "Looping"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_fizzbuzz_order_logic",
          "topic": "FizzBuzz Conditional Order",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following FizzBuzz implementation:\n\n```javascript\nfunction fizzBuzzProblematic() {\n  for (let i = 1; i <= 15; i++) {\n    if (i % 3 === 0) {\n      console.log('Fizz');\n    } else if (i % 5 === 0) {\n      console.log('Buzz');\n    } else if (i % 5 === 0 && i % 3 === 0) {\n      console.log('FizzBuzz');\n    } else {\n      console.log(i);\n    }\n  }\n}\n```\n\nWhat would be the output for the number `15` when `fizzBuzzProblematic()` is called?",
          "answer": "Fizz",
          "options": [
            "FizzBuzz",
            "Fizz",
            "Buzz",
            "15"
          ],
          "analysisPoints": [
            "Tests understanding of `if-else if` block execution flow.",
            "Highlights the importance of condition order in FizzBuzz.",
            "Identifies a common logical error in conditional statements."
          ],
          "keyConcepts": [
            "Conditional Logic",
            "Modulo Operator",
            "Execution Flow",
            "FizzBuzz Problem"
          ],
          "evaluationCriteria": [
            "Correctly predicts output based on logical flow.",
            "Demonstrates understanding of short-circuiting in `if-else if`."
          ],
          "example": "For `i = 15`, the first condition `i % 3 === 0` (15 % 3 === 0) is true. Therefore, 'Fizz' is printed, and the subsequent `else if` conditions (including the `i % 5 === 0 && i % 3 === 0` for 'FizzBuzz') are never evaluated. This shows why the 'FizzBuzz' condition must be checked first.",
          "tags": [
            "FizzBuzz",
            "Conditionals",
            "Logic Error",
            "Debugging"
          ],
          "prerequisites": [
            "If/Else statements",
            "Modulo operator"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_fizzbuzz_generalization",
          "topic": "FizzBuzz Variations",
          "level": "hard",
          "type": "code",
          "question": "Implement a generalized `fizzBuzz` function that takes an upper limit `n` and an array of rules. Each rule is an object `{ divisor: number, word: string }`. The function should return an array of strings, applying the rules in the order they appear, prioritizing longer matches (more divisors). If a number matches multiple rules, concatenate the words. If no rules match, return the number itself as a string.\n\nExample:\n`fizzBuzzGeneralized(15, [{divisor: 3, word: 'Fizz'}, {divisor: 5, word: 'Buzz'}])`\nExpected output (first few elements):\n`['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz']`\n\n`fizzBuzzGeneralized(10, [{divisor: 2, word: 'Foo'}, {divisor: 5, word: 'Bar'}])`\nExpected output:\n`['1', 'Foo', '3', 'Foo', 'Bar', 'Foo', '7', 'Foo', '9', 'FooBar']`",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Ability to handle dynamic rules and configurations.",
            "Correctly implementing string concatenation for multiple matches.",
            "Handling edge cases like no matches or empty rules.",
            "Prioritizing 'longer matches' (implicit: if a number is divisible by 3 and 5, it should output 'FizzBuzz', not just 'Fizz' or 'Buzz'). The current problem statement says 'prioritizing longer matches (more divisors)' which suggests sorting rules, or building up the string and checking if it's empty. The latter is generally easier.",
            "Using array methods for functional approach."
          ],
          "keyConcepts": [
            "Loops",
            "Conditionals",
            "Modulo Operator",
            "Array Iteration",
            "Object Handling",
            "String Manipulation"
          ],
          "evaluationCriteria": [
            "Correctness of the generalized logic.",
            "Code cleanliness and readability.",
            "Robustness to different rule sets.",
            "Edge case handling (e.g., empty rules array, n=0)."
          ],
          "example": "```javascript\nfunction fizzBuzzGeneralized(n, rules) {\n  const results = [];\n  for (let i = 1; i <= n; i++) {\n    let output = '';\n    // Sort rules by divisor to ensure consistent concatenation order if needed\n    // Or apply rules in given order and concatenate\n    for (const rule of rules) {\n      if (i % rule.divisor === 0) {\n        output += rule.word;\n      }\n    }\n    results.push(output || String(i));\n  }\n  return results;\n}\n\n// Test Cases\nconsole.log(fizzBuzzGeneralized(15, [{divisor: 3, word: 'Fizz'}, {divisor: 5, word: 'Buzz'}]));\n// Expected: ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz']\nconsole.log(fizzBuzzGeneralized(10, [{divisor: 2, word: 'Foo'}, {divisor: 5, word: 'Bar'}]));\n// Expected: ['1', 'Foo', '3', 'Foo', 'Bar', 'Foo', '7', 'Foo', '9', 'FooBar']\n```",
          "tags": [
            "FizzBuzz",
            "Algorithm",
            "Generalization",
            "Conditional Logic",
            "Array Manipulation"
          ],
          "prerequisites": [
            "Loops",
            "Conditionals",
            "Objects",
            "Arrays"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_webpack_scss_typescript_setup",
          "title": "Extend Webpack Configuration for SCSS and TypeScript",
          "description": "\nExtend the provided basic Webpack configuration to support:\n\n1.  **SCSS (Sass)**: Configure Webpack to compile `.scss` files into CSS and inject them into the DOM. Ensure source maps are enabled for easier debugging in development.\n2.  **TypeScript**: Configure Webpack to transpile `.ts` and `.tsx` files (if using React with TypeScript) into JavaScript using `ts-loader` or `babel-loader` with `@babel/preset-typescript`.\n\nYour solution should integrate these new capabilities while maintaining the existing JavaScript, CSS, and image handling. Provide a minimal `index.ts` and `style.scss` to demonstrate functionality.\n",
          "difficulty": "medium",
          "startingCode": "const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js', // Change this to index.ts/tsx as needed\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.[contenthash].js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react']\n          }\n        }\n      },\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      },\n      {\n        test: /\\.(png|svg|jpg|gif)$/,\n        use: ['file-loader']\n      },\n      // TODO: Add rules for SCSS and TypeScript here\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  devServer: {\n    contentBase: './dist',\n    hot: true\n  }\n  // TODO: Add resolve extensions for TypeScript\n};\n",
          "solutionCode": "const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  mode: 'development', // Added for clarity, can be 'production' too\n  entry: './src/index.ts', // Changed entry to TypeScript file\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.[contenthash].js'\n  },\n  module: {\n    rules: [\n      // JavaScript rule (can be extended for .jsx)\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react']\n          }\n        }\n      },\n      // CSS rule\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      },\n      // SCSS rule\n      {\n        test: /\\.(s[ac]ss)$/,\n        use: ['style-loader', 'css-loader', 'sass-loader'] // Order is crucial: sass-loader -> css-loader -> style-loader\n      },\n      // Image rule\n      {\n        test: /\\.(png|svg|jpg|gif)$/,\n        use: ['file-loader']\n      },\n      // TypeScript rule (using ts-loader)\n      {\n        test: /\\.(ts|tsx)$/,\n        exclude: /node_modules/,\n        use: 'ts-loader'\n      }\n      // Alternatively, for TypeScript with Babel:\n      // {\n      //   test: /\\.(ts|tsx)$/,\n      //   exclude: /node_modules/,\n      //   use: {\n      //     loader: 'babel-loader',\n      //     options: {\n      //       presets: ['@babel/preset-env', '@babel/preset-react', '@babel/preset-typescript']\n      //     }\n      //   }\n      // }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  devServer: {\n    static: './dist', // Modern way to specify contentBase\n    hot: true\n  },\n  resolve: {\n    extensions: ['.tsx', '.ts', '.js', '.jsx', '.json'] // Enable importing these file types without extensions\n  },\n  devtool: 'source-map' // Enable source maps for easier debugging\n};\n\n// Example of src/index.ts (create this file):\n// import './style.scss';\n// import { greet } from './utils';\n// console.log(greet('TypeScript User'));\n\n// Example of src/utils.ts:\n// export function greet(name: string): string {\n//   return `Hello, ${name}!`;\n// }\n\n// Example of src/style.scss:\n// $primary-color: #3498db;\n// body {\n//   background-color: lighten($primary-color, 40%);\n//   color: darken($primary-color, 20%);\n//   font-family: Arial, sans-serif;\n// }\n// h1 { color: $primary-color; }\n",
          "testCases": [
            "Verify `npm run build` generates a `bundle.js` with correct hashes.",
            "Verify `npm start` launches `webpack-dev-server` and opens the application.",
            "Confirm SCSS styles are applied correctly in the browser.",
            "Confirm TypeScript code compiles and runs without errors.",
            "Check that `console.log` output from TypeScript is visible.",
            "Inspect elements to confirm CSS from SCSS is applied."
          ],
          "hints": [
            "Remember to install necessary loaders like `sass-loader`, `node-sass` (or `sass`), and `ts-loader` or Babel presets.",
            "The order of loaders in the `use` array for SCSS is important: `sass-loader` processes first, then `css-loader`, then `style-loader`.",
            "For TypeScript, you'll also need a `tsconfig.json` file. A minimal one will suffice for basic compilation.",
            "Don't forget to add `.ts` and `.tsx` to the `resolve.extensions` array so Webpack can find these files without explicitly stating their extensions in imports."
          ],
          "tags": [
            "Webpack",
            "SCSS",
            "TypeScript",
            "Frontend Build",
            "Configuration",
            "Loaders",
            "Development Setup"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_webpack_fundamentals",
            "Node.js",
            "npm/yarn",
            "Basic SCSS",
            "Basic TypeScript"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Webpack Loaders",
            "Webpack Plugins",
            "Transpilation",
            "Module Resolution"
          ]
        },
        {
          "id": "task_fibonacci_memoization",
          "title": "Implement Fibonacci with Memoization (Dynamic Programming - Top-Down)",
          "description": "\nImplement a function `fibonacciMemoized(n)` that calculates the nth Fibonacci number using memoization (a top-down dynamic programming approach). This should combine the clarity of the recursive approach with the efficiency of caching previously computed results.\n\n**Requirements:**\n1.  The function should handle base cases `F(0) = 0` and `F(1) = 1`.\n2.  It must use a cache (e.g., an object or `Map`) to store results of subproblems.\n3.  Before computing `F(k)`, check if `F(k)` is already in the cache. If yes, return the cached value.\n4.  If not, compute `F(k)`, store it in the cache, and then return it.\n5.  Analyze its time and space complexity.\n",
          "difficulty": "medium",
          "startingCode": "function fibonacciMemoized(n) {\n  const memo = {}; // Cache to store computed Fibonacci numbers\n\n  // TODO: Implement the recursive logic with memoization\n  // Base cases:\n  // F(0) = 0\n  // F(1) = 1\n\n  // Check memo before computing\n  // Compute and store in memo if not present\n\n  return -1; // Placeholder\n}\n\n// Example usage:\n// console.log(fibonacciMemoized(10)); // Should be 55\n// console.log(fibonacciMemoized(40)); // Should be fast\n",
          "solutionCode": "function fibonacciMemoized(n) {\n  const memo = {}; // Cache to store computed Fibonacci numbers\n\n  function fib(num) {\n    if (num in memo) { // Check if result is already in cache\n      return memo[num];\n    }\n    \n    if (num < 2) { // Base cases\n      return num;\n    }\n    \n    // Compute, store in cache, and return\n    memo[num] = fib(num - 1) + fib(num - 2);\n    return memo[num];\n  }\n\n  return fib(n);\n}\n\n/*\nAnalysis:\nTime Complexity: O(n)\nEach Fibonacci number from 0 to n is computed only once. Although it's recursive, the memoization ensures that for each 'num', the 'fib' function is called exactly once to compute its value and store it. Subsequent calls retrieve the value directly from the memo.\n\nSpace Complexity: O(n)\nThis is due to two factors:\n1. The 'memo' object stores up to 'n' key-value pairs.\n2. The recursion call stack can go up to 'n' levels deep in the worst case (e.g., for fib(n), it will call fib(n-1), then fib(n-2) etc. until fib(1) or fib(0) is hit on one branch, before returning and exploring the other branch).\n*/\n\n// Test Cases\n// console.log(fibonacciMemoized(0));   // Expected: 0\n// console.log(fibonacciMemoized(1));   // Expected: 1\n// console.log(fibonacciMemoized(2));   // Expected: 1\n// console.log(fibonacciMemoized(3));   // Expected: 2\n// console.log(fibonacciMemoized(10));  // Expected: 55\n// console.log(fibonacciMemoized(40));  // Expected: 102334155 (should be very fast, unlike naive recursive)\n// console.log(fibonacciMemoized(50));  // Expected: 12586269025\n",
          "testCases": [
            "Test with F(0): `fibonacciMemoized(0)` should return `0`.",
            "Test with F(1): `fibonacciMemoized(1)` should return `1`.",
            "Test with F(5): `fibonacciMemoized(5)` should return `5`.",
            "Test with F(10): `fibonacciMemoized(10)` should return `55`.",
            "Test with a large number like F(40) to ensure performance: `fibonacciMemoized(40)` should compute quickly and return `102334155`.",
            "Verify `memo` is being used (e.g., by logging `memo` or by stepping through with a debugger to see if `fib` is called for previously computed values)."
          ],
          "hints": [
            "Define an inner helper function that takes `num` and the `memo` object as arguments (or a closure capturing `memo`).",
            "The base cases for Fibonacci are `F(0)=0` and `F(1)=1`.",
            "Before making recursive calls, always check if the result for the current `num` is already in your `memo` object.",
            "If the result is not in `memo`, compute it, store it, and then return it.",
            "Consider the difference in time complexity between this and the naive recursive approach. What is it now?"
          ],
          "tags": [
            "Algorithm",
            "Dynamic Programming",
            "Memoization",
            "Recursion",
            "Fibonacci",
            "Optimization",
            "Time Complexity",
            "Space Complexity"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_fibonacci_sequence",
            "Recursion",
            "JavaScript Objects/Maps"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Dynamic Programming",
            "Top-Down Approach",
            "Caching"
          ]
        },
        {
          "id": "task_fizzbuzz_return_array",
          "title": "Implement FizzBuzz Returning an Array",
          "description": "\nImplement a function `getFizzBuzzResults(start, end)` that generates the FizzBuzz sequence for a given range (`start` to `end`, inclusive). Instead of logging the output to the console, the function should return an array of strings containing the results.\n\n**Requirements:**\n1.  The function should accept two integer arguments: `start` and `end`.\n2.  It should iterate from `start` to `end` (inclusive).\n3.  For each number, apply the standard FizzBuzz rules:\n    *   Divisible by 3 and 5: 'FizzBuzz'\n    *   Divisible by 3: 'Fizz'\n    *   Divisible by 5: 'Buzz'\n    *   Otherwise: the number itself (as a string).\n4.  Return an array containing all generated strings.\n5.  Handle edge cases where `start` > `end` or `start`/`end` are non-positive.\n",
          "difficulty": "easy",
          "startingCode": "function getFizzBuzzResults(start, end) {\n  const results = [];\n  \n  // TODO: Implement loop from start to end\n  // TODO: Apply FizzBuzz logic for each number\n  // TODO: Add results to the 'results' array\n\n  return results; // Return the accumulated results\n}\n\n// Example usage:\n// console.log(getFizzBuzzResults(1, 15));\n/* Expected Output for 1 to 15:\n[\n  '1', '2', 'Fizz', '4', 'Buzz',\n  'Fizz', '7', '8', 'Fizz', 'Buzz',\n  '11', 'Fizz', '13', '14', 'FizzBuzz'\n]\n*/\n",
          "solutionCode": "function getFizzBuzzResults(start, end) {\n  const results = [];\n\n  // Handle edge case: if start > end or invalid range, return empty array\n  if (start > end || typeof start !== 'number' || typeof end !== 'number' || !Number.isInteger(start) || !Number.isInteger(end)) {\n    return [];\n  }\n\n  for (let i = start; i <= end; i++) {\n    if (i % 3 === 0 && i % 5 === 0) {\n      results.push('FizzBuzz');\n    } else if (i % 3 === 0) {\n      results.push('Fizz');\n    } else if (i % 5 === 0) {\n      results.push('Buzz');\n    } else {\n      results.push(String(i)); // Ensure numbers are stored as strings\n    }\n  }\n\n  return results;\n}\n\n// Test Cases\n// console.log(getFizzBuzzResults(1, 15));\n// /* Expected Output for 1 to 15:\n// [\n//   '1', '2', 'Fizz', '4', 'Buzz',\n//   'Fizz', '7', '8', 'Fizz', 'Buzz',\n//   '11', 'Fizz', '13', '14', 'FizzBuzz'\n// ]\n// */\n// console.log(getFizzBuzzResults(10, 20));\n// /* Expected:\n// [ 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz', '16', '17', 'Fizz', '19', 'Buzz' ]\n// */\n// console.log(getFizzBuzzResults(-5, 5));\n// /* Expected:\n// [ 'Buzz', '-4', 'Fizz', '-2', '-1', 'FizzBuzz', '1', '2', 'Fizz', '4', 'Buzz' ]\n// */\n// console.log(getFizzBuzzResults(5, 1)); // Expected: []\n// console.log(getFizzBuzzResults(0, 0)); // Expected: ['FizzBuzz']\n",
          "testCases": [
            "Test with standard range: `getFizzBuzzResults(1, 15)` should return the correct array of 15 elements, ending with 'FizzBuzz'.",
            "Test with a different range: `getFizzBuzzResults(10, 20)` should correctly produce the sequence for that range.",
            "Test with `start` > `end`: `getFizzBuzzResults(5, 1)` should return an empty array `[]`.",
            "Test with non-positive numbers: `getFizzBuzzResults(-5, 5)` should handle negative and zero values correctly (e.g., 0 % 3 === 0 and 0 % 5 === 0, so 'FizzBuzz').",
            "Test with single number range: `getFizzBuzzResults(7, 7)` should return `['7']`.",
            "Test with `start = end = 0`: `getFizzBuzzResults(0, 0)` should return `['FizzBuzz']`."
          ],
          "hints": [
            "Remember to convert numbers to strings before pushing them into the results array (`String(i)` or `${i}`).",
            "Pay attention to the order of conditional checks (`i % 3 === 0 && i % 5 === 0` should come first).",
            "Consider input validation for `start` and `end` to ensure they are valid numbers and `start` is not greater than `end`."
          ],
          "tags": [
            "Algorithm",
            "FizzBuzz",
            "Array Manipulation",
            "Loops",
            "Conditionals",
            "Edge Cases"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "theory_fizzbuzz_problem",
            "Arrays",
            "Loops",
            "Conditionals"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "Function Parameters",
            "Return Values"
          ]
        }
      ]
    }
  },
  {
    "id": "a581fd75-a75e-478e-b491-c01cc45db54d",
    "startLine": 13400,
    "endLine": 13499,
    "processedDate": "2025-06-17T13:26:47.814Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_key_best_practices",
          "title": "React Best Practices: Avoiding Index as Key",
          "content": "Using the `key` prop in React lists is crucial for performance and correctness. When rendering lists of components, React uses `keys` to identify which items have changed, are added, or are removed. This helps React efficiently update the UI during reconciliation.\n\n## The Problem with Using Index as Key\nUsing an array's index as a `key` (`key={index}`) is a common anti-pattern, especially when list items can be reordered, added, or removed. React uses keys to maintain the identity of components. If an item's position changes but its `key` (which is its index) remains the same as another item that was previously at that position, React might reuse the component instance instead of re-rendering it or moving it. This can lead to:\n\n1.  **Component State Mix-ups:** If a list item has internal state (e.g., an input field's value, a checkbox's checked state), that state might persist with the wrong item when the list is reordered, as React thinks it's the same component just at a new index.\n2.  **Unnecessary Re-renders and Performance Issues:** When items are inserted or removed in the middle of a list, all subsequent items will have their indices shifted. React will perceive these as new components at those new indices, leading to unnecessary re-mounting and re-rendering of many components instead of just the changed ones.\n3.  **Subtle UI Bugs:** These issues are often hard to track down because the UI might appear correct initially, but unexpected behavior emerges after list modifications.\n\n## Good Practice: Using Unique, Stable Identifiers\nAlways use a unique and stable identifier for each item in a list as its `key` prop. This identifier should be intrinsic to the data itself and remain consistent across re-renders and reordering.\n\n### When is `index` acceptable?\nUsing `index` as a `key` is generally discouraged. However, it *can* be acceptable in very specific scenarios where:\n1.  The list and its items are static and will **never** change (no additions, deletions, or reordering).\n2.  The items in the list have no unique IDs.\n3.  The list is never filtered or reordered.\n\nIn most real-world applications, these conditions are rarely met, making it safer to always use unique IDs.",
          "examples": [
            {
              "id": "example_key_bad_practice",
              "title": "Bad Practice: Using Index as Key",
              "code": "function ItemList({ items }) {\n  return (\n    <ul>\n      {items.map((item, index) => (\n        // BAD: Using index as key can lead to bugs and performance issues\n        <ListItem key={index} item={item} />\n      ))}\n    </ul>\n  );\n}\n\nfunction ListItem({ item }) {\n  // Imagine ListItem has internal state, e.g., an input field\n  return <li>{item.name}</li>;\n}",
              "explanation": "This example demonstrates the incorrect use of `index` as a key. If `items` array is reordered, React might not correctly update the DOM elements, leading to state persistence issues or incorrect rendering of list items.",
              "language": "typescript"
            },
            {
              "id": "example_key_good_practice",
              "title": "Good Practice: Using Unique ID as Key",
              "code": "function ItemList({ items }) {\n  return (\n    <ul>\n      {items.map(item => (\n        // GOOD: Using a stable, unique ID ensures correct component identity\n        <ListItem key={item.id} item={item} />\n      ))}\n    </ul>\n  );\n}\n\nfunction ListItem({ item }) {\n  // Imagine ListItem has internal state, e.g., an input field\n  return <li>{item.name}</li>;\n}",
              "explanation": "This example shows the recommended approach: using a unique, stable identifier (`item.id`) from the data as the key. This allows React to efficiently and correctly reconcile the list when items are added, removed, or reordered.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_key_purpose",
            "question_react_key_index_issue",
            "question_react_key_best_practice_mcq",
            "question_react_key_consequences_open"
          ],
          "relatedTasks": [
            "task_react_refactor_list_keys"
          ],
          "tags": [
            "React",
            "Performance",
            "Best Practices",
            "Lists",
            "Keys"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Components",
            "JavaScript_Array_Methods"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "React_Performance_Optimization",
            "Complex_List_Rendering"
          ]
        },
        {
          "id": "theory_javascript_fundamentals",
          "title": "JavaScript Fundamentals: Core Concepts",
          "content": "This section covers essential JavaScript concepts frequently tested in frontend interviews, focusing on how JavaScript handles events, comparisons, scope, inheritance, and asynchronous operations.\n\n## Event Delegation\nEvent delegation is a technique where you attach a single event listener to a parent element, rather than attaching separate listeners to each individual child element. When an event occurs on a child element, it 'bubbles up' (propagates) through the DOM tree to its parent elements. The single listener on the parent can then detect the event, identify the original target element (using `event.target`), and perform the appropriate action.\n\n### Benefits:\n*   **Performance:** Reduces memory consumption by minimizing the number of event listeners.\n*   **Dynamic Elements:** Automatically handles events for elements added to the DOM dynamically after the initial render.\n*   **Cleaner Code:** Centralizes event handling logic.\n\n## Comparison Operators: `==` vs `===`\nJavaScript provides two primary equality operators:\n\n*   **Loose Equality (`==`)**: Compares two values for equality after performing **type coercion**. If the operands are of different types, JavaScript attempts to convert one or both operands to a common type before comparison.\n    *   Example: `0 == '0'` evaluates to `true` because JavaScript converts `'0'` to the number `0`.\n    *   Example: `null == undefined` evaluates to `true`.\n\n*   **Strict Equality (`===`)**: Compares two values for equality **without** type coercion. It returns `true` only if both the value and the type of the operands are identical.\n    *   Example: `0 === '0'` evaluates to `false` because their types (number vs. string) are different.\n    *   Example: `null === undefined` evaluates to `false`.\n\n**Best Practice:** It is generally recommended to use `===` to avoid unexpected behavior due to type coercion, leading to more predictable and robust code.\n\n## Closures\nA closure is a function that remembers its outer lexical environment even after the outer function has finished executing. This means a closure has access to variables from its parent scope (the scope in which it was declared), even if the parent function has already returned.\n\n### Key Characteristics:\n*   **Lexical Scoping:** Closures are created when a function is defined within another function.\n*   **Data Privacy:** They allow for creating private variables and functions.\n*   **Stateful Functions:** They can maintain state across multiple calls.\n\n## Prototype Inheritance\nJavaScript is a prototype-based language, meaning objects can inherit properties and methods directly from other objects. Every JavaScript object has an internal `[[Prototype]]` property, which points to another object (its prototype). When you try to access a property or method on an object, JavaScript first looks on the object itself. If it's not found, it then looks on the object's prototype, and so on up the **prototype chain**, until it finds the property or reaches the end of the chain (which is `null`).\n\n### Key Concepts:\n*   `Object.prototype`: The base of all objects, containing fundamental methods like `toString()`, `hasOwnProperty()`, etc.\n*   `__proto__` (deprecated, but common for understanding): An accessor property on instances that exposes the internal `[[Prototype]]` link.\n*   `Object.getPrototypeOf()`: The standard way to get an object's prototype.\n*   Constructor Functions: Used with the `new` keyword to create objects that inherit from the constructor's `prototype` property.\n\n## The Event Loop\nJavaScript is single-threaded, meaning it can execute only one operation at a time. However, it can perform non-blocking operations (like fetching data, timers) due to the **Event Loop**. The Event Loop is a fundamental concurrency model that enables JavaScript to handle asynchronous callbacks.\n\n### Components of the Event Loop:\n1.  **Call Stack (Execution Stack):** Where synchronous code is executed. Functions are pushed onto the stack when called and popped off when they return.\n2.  **Web APIs (Browser APIs / Node.js APIs):** Provided by the browser or Node.js runtime, not JavaScript itself. These APIs handle asynchronous tasks (e.g., `setTimeout`, `fetch`, DOM events). When an async operation starts, it's offloaded to a Web API, allowing the Call Stack to continue executing other code.\n3.  **Callback Queue (Task Queue / Macrotask Queue):** After an asynchronous operation (e.g., `setTimeout` delay expires, `fetch` response arrives, DOM event fires) completes in a Web API, its associated callback function is moved to the Callback Queue.\n4.  **Microtask Queue:** A higher-priority queue than the Callback Queue. It holds callbacks for Promises (`.then()`, `.catch()`, `.finally()`) and `queueMicrotask`. Microtasks are processed *before* macrotasks (callbacks from the Callback Queue) after the Call Stack is empty.\n5.  **Event Loop:** Continuously monitors the Call Stack and the queues. When the Call Stack is empty, it checks the Microtask Queue first. If it's not empty, it moves all microtasks from the Microtask Queue to the Call Stack to be executed. Once the Microtask Queue is empty, it then checks the Callback Queue. If the Callback Queue is not empty, it takes the first callback from the Callback Queue and pushes it onto the Call Stack for execution. This process repeats indefinitely.\n\nThis mechanism allows JavaScript to appear non-blocking by deferring asynchronous operations and handling their results efficiently without halting the main thread.",
          "examples": [
            {
              "id": "example_event_delegation",
              "title": "Event Delegation Example",
              "code": "// HTML structure:\n// <ul id=\"myList\">\n//   <li>Item 1</li>\n//   <li>Item 2</li>\n//   <li>Item 3</li>\n// </ul>\n\nconst list = document.getElementById('myList');\nlist.addEventListener('click', function(event) {\n  if (event.target.tagName === 'LI') {\n    console.log('Clicked on:', event.target.textContent);\n  }\n});\n\n// Dynamically add a new item\nconst newItem = document.createElement('li');\nnewItem.textContent = 'Item 4';\nlist.appendChild(newItem);\n// Clicking 'Item 4' will still be handled by the parent listener.",
              "explanation": "This example shows event delegation. Instead of adding a click listener to each `<li>`, a single listener is attached to the `<ul>`. When an `<li>` is clicked, the event bubbles up to the `<ul>`, and `event.target` identifies the specific `<li>` that was clicked, allowing for efficient and dynamic event handling.",
              "language": "javascript"
            },
            {
              "id": "example_comparison_operators",
              "title": "Comparison Operators: == vs ===",
              "code": "console.log(0 == \"0\");    // true (type coercion: string \"0\" becomes number 0)\nconsole.log(0 === \"0\");   // false (different types: number vs string)\n\nconsole.log(1 == true);   // true (type coercion: boolean true becomes number 1)\nconsole.log(1 === true);  // false (different types: number vs boolean)\n\nconsole.log(null == undefined); // true (special rule for these two)\nconsole.log(null === undefined); // false (different types)\n\nconsole.log(\"2\" == 2);   // true\nconsole.log(\"2\" === 2);  // false",
              "explanation": "This example clearly illustrates the difference between loose (`==`) and strict (`===`) equality. Loose equality performs type coercion, which can lead to unexpected results, whereas strict equality requires both value and type to be identical, making it generally safer and more predictable.",
              "language": "javascript"
            },
            {
              "id": "example_closures",
              "title": "Closure Example: Counter Function",
              "code": "function createCounter() {\n  let count = 0; // 'count' is in the outer function's scope\n\n  return function() { // This inner function is a closure\n    return ++count; // It has access to 'count'\n  };\n}\n\nconst counter1 = createCounter();\nconsole.log(counter1()); // 1 (count for counter1 is 1)\nconsole.log(counter1()); // 2 (count for counter1 is 2)\n\nconst counter2 = createCounter(); // Creates a new independent closure\nconsole.log(counter2()); // 1 (count for counter2 is 1)\nconsole.log(counter1()); // 3 (count for counter1 continues from where it left off)",
              "explanation": "The `createCounter` function returns an inner (anonymous) function. This inner function 'closes over' the `count` variable from its outer scope. Even after `createCounter` has finished executing, the inner function retains access to `count`, allowing it to increment and return its value on subsequent calls. Each call to `createCounter` creates a new, independent closure and `count` variable.",
              "language": "javascript"
            },
            {
              "id": "example_prototype_inheritance",
              "title": "Prototype Inheritance Example",
              "code": "// Constructor function\nfunction Person(name) {\n  this.name = name;\n}\n\n// Add a method to the Person's prototype\nPerson.prototype.greet = function() {\n  console.log(`Hello, my name is ${this.name}`);\n};\n\nconst john = new Person('John');\njohn.greet(); // John inherits greet() from Person.prototype\n\nconsole.log(john.__proto__ === Person.prototype); // true\nconsole.log(Object.getPrototypeOf(john) === Person.prototype); // true\n\n// Another object inheriting from Person.prototype\nconst jane = new Person('Jane');\njane.greet();\n\n// Properties/methods not found on the instance are looked up on the prototype chain\nconsole.log(john.hasOwnProperty('name')); // true (name is directly on john)\nconsole.log(john.hasOwnProperty('greet')); // false (greet is on the prototype)\n",
              "explanation": "This example demonstrates how `Person` objects `john` and `jane` inherit the `greet` method from `Person.prototype`. When `john.greet()` is called, JavaScript first looks for `greet` on the `john` object itself. Since it's not found, it then looks up the prototype chain to `Person.prototype`, where it finds `greet` and executes it. This mechanism allows for efficient sharing of methods and properties among instances.",
              "language": "javascript"
            },
            {
              "id": "example_event_loop",
              "title": "Event Loop Execution Order Example",
              "code": "console.log('Start'); // 1. Synchronous code\n\nsetTimeout(() => { // 2. Macrotask (Callback Queue)\n  console.log('Timeout 1');\n}, 0);\n\nPromise.resolve().then(() => { // 3. Microtask (Microtask Queue)\n  console.log('Promise 1');\n});\n\nsetTimeout(() => { // 4. Macrotask (Callback Queue)\n  console.log('Timeout 2');\n}, 0);\n\nPromise.resolve().then(() => { // 5. Microtask (Microtask Queue)\n  console.log('Promise 2');\n});\n\nconsole.log('End'); // 6. Synchronous code\n\n// Expected Output:\n// Start\n// End\n// Promise 1\n// Promise 2\n// Timeout 1\n// Timeout 2",
              "explanation": "This example illustrates the Event Loop's execution order. All synchronous code (`Start`, `End`) runs first. Then, the Event Loop prioritizes the Microtask Queue over the Macrotask Queue. So, all Promise callbacks (`Promise 1`, `Promise 2`) execute before any `setTimeout` callbacks (`Timeout 1`, `Timeout 2`), even if `setTimeout` has a 0ms delay. This demonstrates the non-blocking nature and the asynchronous processing order facilitated by the event loop.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_js_event_delegation_explanation",
            "question_js_double_triple_equals_mcq",
            "question_js_closure_definition",
            "question_js_prototype_inheritance_open",
            "question_js_event_loop_flow",
            "question_js_event_loop_mcq",
            "question_js_closure_use_case_code",
            "question_js_event_delegation_benefits_open"
          ],
          "relatedTasks": [
            "task_event_delegation_list",
            "task_closure_private_counter",
            "task_event_loop_prediction"
          ],
          "tags": [
            "JavaScript",
            "Fundamentals",
            "Event Loop",
            "Closures",
            "Prototypes",
            "Equality",
            "Event Delegation"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "JavaScript_Basics",
            "Functions",
            "Objects"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Asynchronous_JavaScript",
            "Object_Oriented_JavaScript",
            "Advanced_DOM_Manipulation"
          ]
        },
        {
          "id": "theory_react_fundamentals",
          "title": "React Fundamentals: Core Concepts",
          "content": "This section delves into the foundational concepts of React, covering its core mechanisms for UI rendering, component communication, state management, and lifecycle management.\n\n## Virtual DOM\nReact introduces the concept of the **Virtual DOM (VDOM)**, which is a lightweight, in-memory representation of the actual DOM. When component state changes, React first updates this virtual DOM. It then compares the current virtual DOM with the previous one (a process called 'diffing'). Based on this comparison, React calculates the minimal set of changes needed to update the real DOM. This process, known as **Reconciliation**, then applies only those necessary changes to the actual DOM.\n\n### Benefits:\n*   **Performance Optimization:** Directly manipulating the actual DOM is a costly operation. By minimizing direct DOM operations, React significantly improves performance.\n*   **Cross-Platform Compatibility:** The abstraction of the Virtual DOM makes React adaptable to different rendering environments (e.g., web browsers, mobile apps via React Native).\n*   **Simplified UI Development:** Developers work with a declarative API, letting React handle the imperative DOM manipulations.\n\n## State vs. Props\nTwo fundamental concepts for managing data flow in React components:\n\n*   **Props (Properties):**\n    *   **Definition:** Arguments passed into React components from their parent components.\n    *   **Immutability:** Props are read-only. A component should never modify its own props.\n    *   **Data Flow:** Primarily used for communication from parent to child components (`uni-directional data flow`).\n    *   **Usage:** For passing data and callback functions down the component tree.\n\n*   **State:**\n    *   **Definition:** Data managed within a component that can change over time. It represents the mutable part of the component's data.\n    *   **Mutability (Managed):** State can be changed by the component itself using `setState` (for class components) or `useState` (for functional components).\n    *   **Data Flow:** Primarily affects the component that owns it and its child components that receive state via props.\n    *   **Usage:** For data that changes based on user interaction, network responses, or other events within the component.\n\n## React Hooks\n**React Hooks** are functions introduced in React 16.8 that let you use state and other React features (like lifecycle methods, context) in functional components without writing class components. They aim to simplify component logic, improve reusability, and solve common issues associated with classes (e.g., `this` binding, prop drilling for lifecycle logic).\n\n### Common Built-in Hooks:\n*   `useState`: For adding state to functional components.\n*   `useEffect`: For performing side effects (data fetching, subscriptions, manual DOM manipulations, timers) in functional components.\n*   `useContext`: For subscribing to React context, avoiding prop drilling.\n*   `useReducer`: An alternative to `useState` for more complex state logic.\n*   `useMemo`: For memoizing (caching) expensive computations, preventing re-computation on every render if dependencies haven't changed.\n*   `useCallback`: For memoizing callback functions, preventing unnecessary re-creation and helping optimize child components that rely on referential equality.\n\n## React's Diffing Algorithm (Reconciliation)\nReact's diffing algorithm is a set of heuristics used during the **Reconciliation** process to efficiently update the actual DOM. When the virtual DOM changes, React needs to figure out the most efficient way to update the real DOM. The algorithm makes two main assumptions:\n\n1.  **Two elements of different types will produce different trees:** If the element type changes (e.g., `<div>` to `<span>`), React will tear down the old tree and build the new one from scratch, destroying the old component instance and its state.\n2.  **The developer can hint at which child elements may be stable across different renders with a `key` prop:** For lists, keys help React identify unique items, allowing it to efficiently reorder, add, or remove elements rather than re-rendering the entire list.\n\n### Reconciliation Process:\n*   **Element Type Comparison:** React first compares the root elements. If types differ, the old component is unmounted, and the new one is mounted. If types are the same, React compares their attributes (props) and updates the real DOM only for changed attributes.\n*   **Recursive Children Comparison:** For elements with children, React recursively processes the children. By default, it iterates over the old list and the new list of children simultaneously. If unique `keys` are provided, React uses them to match children from the old list with children in the new list, enabling efficient moves, additions, and removals.\n\n## Redux\n**Redux** is a predictable state container for JavaScript applications. It's often used with React for managing application-wide state. Redux enforces a strict unidirectional data flow and follows three core principles:\n\n1.  **Single Source of Truth:** The entire application's state is stored in a single plain JavaScript object within one store.\n2.  **State is Read-Only:** The only way to change the state is by emitting an action, an object describing what happened. This ensures changes are explicit and traceable.\n3.  **Changes are Made with Pure Functions (Reducers):** To specify how the state tree is transformed by actions, you write pure functions called reducers. Reducers take the current state and an action, and return a *new* state object, without mutating the original state.\n\n### When to use Redux:\nRedux is beneficial in large, complex applications with:\n*   **Complex Shared State:** State needed by many components, sometimes deeply nested.\n*   **Frequent State Updates:** Many actions modify the state.\n*   **Predictable State Changes:** When you need strict control and debugging capabilities over state modifications.\n*   **Team Collaboration:** Provides a clear pattern for state management across a large codebase.\n\nFor simpler applications, React's built-in `useState` and `useContext` or other lightweight state management solutions might be sufficient.\n\n## `setState()` Synchronicity and Functional Updates\nIn React class components, `setState()` is **asynchronous**. React may batch multiple `setState()` calls into a single update for performance reasons, especially within event handlers or lifecycle methods. This means you cannot rely on `this.state` being immediately updated after calling `setState()`.\n\n### Ensuring Code Runs After State Update:\n1.  **Callback Function:** `setState()` accepts an optional second argument, which is a callback function that will be executed *after* the state update is applied and the component has re-rendered.\n    ```javascript\n    this.setState({ data: [1,2,3] }, () => {\n      console.log('State is now updated', this.state.data);\n    });\n    ```\n\n2.  **`componentDidUpdate` Lifecycle Method:** For logic that always needs to run after a state or prop update, `componentDidUpdate` is suitable. You can compare `prevProps` and `prevState` with current `this.props` and `this.state`.\n\n### Functional `setState()` for Updates Based on Previous State:\nWhen the new state depends on the previous state, you should use the **functional form** of `setState()`. This form receives `prevState` and `props` as arguments, ensuring you are working with the most up-to-date state values, preventing race conditions or stale state issues.\n```javascript\nthis.setState((prevState, props) => {\n  return { count: prevState.count + props.increment };\n});\n```\nThis approach is crucial for reliable state updates, particularly when multiple `setState` calls are batched or when state changes rapidly.",
          "examples": [
            {
              "id": "example_virtual_dom",
              "title": "Virtual DOM Concept",
              "code": "/* \n  Conceptual process: \n  1. Initial Render: \n     const vdom1 = React.render(<App />);\n     ReactDOM.render(vdom1, document.getElementById('root'));\n\n  2. State Update (e.g., click a button):\n     setState({ count: this.state.count + 1 });\n\n  3. Re-render Virtual DOM:\n     const vdom2 = React.render(<App newProps />);\n\n  4. Diffing:\n     React compares vdom1 and vdom2 to find differences.\n     \n  5. Reconciliation (Actual DOM Update):\n     ReactDOM.patch(document.getElementById('root'), diffs); \n     (Only apply the minimal changes to the real DOM)\n*/\n\n// No direct code example as Virtual DOM is an internal mechanism, \n// but this conceptual flow explains its role in a React component's life cycle.\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n\n  const increment = () => {\n    setCount(count + 1); // This triggers a Virtual DOM update internally\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}",
              "explanation": "This conceptual explanation highlights how the Virtual DOM works: React creates a lightweight representation of the UI, calculates differences efficiently, and then applies only the necessary updates to the actual DOM. The `Counter` component, when its state changes via `setCount`, internally triggers this Virtual DOM process, optimizing render performance.",
              "language": "javascript"
            },
            {
              "id": "example_state_vs_props",
              "title": "State vs. Props Example",
              "code": "function ParentComponent() {\n  // State managed by ParentComponent\n  const [message, setMessage] = React.useState('Hello from Parent!');\n\n  const handleButtonClick = () => {\n    setMessage('Message updated by Parent!');\n  };\n\n  return (\n    <div>\n      <ChildComponent greeting={message} /> {/* message passed as prop */}\n      <button onClick={handleButtonClick}>Update Message</button>\n    </div>\n  );\n}\n\nfunction ChildComponent(props) {\n  // props.greeting is read-only here\n  // props.greeting = 'New value'; // ERROR: Props are immutable\n\n  // State managed internally by ChildComponent\n  const [childClicks, setChildClicks] = React.useState(0);\n\n  const handleChildClick = () => {\n    setChildClicks(childClicks + 1);\n  };\n\n  return (\n    <div>\n      <p>Parent says: {props.greeting}</p>\n      <p>Child has been clicked: {childClicks} times</p>\n      <button onClick={handleChildClick}>Click Child</button>\n    </div>\n  );\n}",
              "explanation": "In this example, `message` is `state` in `ParentComponent` and is passed as a `prop` named `greeting` to `ChildComponent`. `ChildComponent` receives `greeting` as an immutable prop. `ChildComponent` also manages its own internal `state` called `childClicks`, which can be updated independently. This demonstrates the uni-directional flow of props (parent to child) and the local management of state within a component.",
              "language": "javascript"
            },
            {
              "id": "example_react_hooks_useState_useEffect",
              "title": "React Hooks Example: useState and useEffect",
              "code": "import React, { useState, useEffect } from 'react';\n\nfunction Timer() {\n  // useState: add state to functional component\n  const [seconds, setSeconds] = useState(0);\n\n  // useEffect: run side effects after render\n  useEffect(() => {\n    // This function runs once after initial render and on subsequent updates\n    const intervalId = setInterval(() => {\n      setSeconds(prevSeconds => prevSeconds + 1);\n    }, 1000);\n\n    // Cleanup function: runs when component unmounts or before re-running effect\n    return () => clearInterval(intervalId);\n  }, []); // Empty dependency array means effect runs once on mount and cleans up on unmount\n\n  return (\n    <div>\n      <p>Seconds: {seconds}</p>\n    </div>\n  );\n}",
              "explanation": "This `Timer` component uses `useState` to manage its `seconds` state. `useEffect` is used to set up a `setInterval` (a side effect) that updates the `seconds` every second. The cleanup function returned by `useEffect` ensures the interval is cleared when the component unmounts, preventing memory leaks. The empty dependency array `[]` ensures the effect runs only once after the initial render and its cleanup runs only on unmount.",
              "language": "javascript"
            },
            {
              "id": "example_setstate_async_and_functional",
              "title": "setState() Asynchronous & Functional Updates",
              "code": "class MyCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    this.handleClick = this.handleClick.bind(this);\n    this.handleAsyncClick = this.handleAsyncClick.bind(this);\n  }\n\n  handleClick() {\n    // Async nature: console.log might show old state if batched\n    this.setState({ count: this.state.count + 1 });\n    console.log('After setState (potentially stale):', this.state.count); \n    // ^ This will often log the value *before* the update\n\n    // Using callback to ensure code runs after update\n    this.setState({ count: this.state.count + 1 }, () => {\n      console.log('After setState (callback ensures updated):', this.state.count);\n    });\n\n    // Functional setState: recommended for updates depending on previous state\n    this.setState(prevState => ({\n      count: prevState.count + 1\n    }));\n  }\n\n  // Example where functional setState is critical\n  handleAsyncClick() {\n    // These two calls are likely batched, but functional form ensures correct increments\n    setTimeout(() => {\n      this.setState(prevState => ({ count: prevState.count + 1 }));\n      this.setState(prevState => ({ count: prevState.count + 1 }));\n      console.log('Async update complete:', this.state.count); // This will log the final batched value\n    }, 0);\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleClick}>Increment Sync</button>\n        <button onClick={this.handleAsyncClick}>Increment Async</button>\n      </div>\n    );\n  }\n}",
              "explanation": "This example demonstrates two key aspects of `setState()` in class components: its asynchronous nature and the importance of the functional update form. When `handleClick` is called, the first `console.log` often shows the outdated `count` because `setState` is asynchronous and potentially batched. The callback form (`setState(updater, callback)`) guarantees execution after the state update. The functional form (`setState(updaterFunction)`) is vital when the new state depends on the previous state, preventing race conditions, especially with batched updates or multiple rapid calls, as shown in `handleAsyncClick`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_react_virtual_dom_explanation",
            "question_react_state_vs_props",
            "question_react_hooks_definition",
            "question_react_diffing_algorithm",
            "question_react_redux_definition_when_to_use",
            "question_react_setstate_async",
            "question_react_vdom_performance_benefits",
            "question_react_hooks_types_flashcard",
            "question_react_setstate_functional_use_case_code",
            "question_react_redux_principles_open"
          ],
          "relatedTasks": [
            "task_react_simple_counter_with_props_state",
            "task_react_class_to_functional_component",
            "task_react_manage_async_state_update"
          ],
          "tags": [
            "React",
            "Virtual DOM",
            "State",
            "Props",
            "Hooks",
            "Reconciliation",
            "Redux",
            "setState",
            "Asynchronous"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript_Fundamentals",
            "HTML_CSS_Basics"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "requiredFor": [
            "React_Development",
            "State_Management",
            "Performance_Optimization"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_react_key_purpose",
          "topic": "React Keys",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `key` prop in React lists?",
          "answer": "The `key` prop helps React identify which items have changed, are added, or are removed in a list, allowing it to efficiently update the UI during reconciliation.",
          "analysisPoints": [
            "Identifies unique items in a list.",
            "Helps React's reconciliation algorithm.",
            "Crucial for efficient UI updates."
          ],
          "keyConcepts": [
            "React Keys",
            "Reconciliation",
            "List Rendering"
          ],
          "evaluationCriteria": [
            "Basic understanding of React rendering.",
            "Knowledge of key prop importance."
          ],
          "example": "",
          "tags": [
            "React",
            "Keys",
            "Lists",
            "Basics"
          ],
          "prerequisites": [
            "React_Components"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_key_index_issue",
          "topic": "React Keys",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a problem associated with using an array `index` as a `key` prop in React when list items can be reordered or removed?",
          "answer": "It causes the component to render slower than without keys.",
          "options": [
            "Component state may get mixed up if list order changes.",
            "It can cause unnecessary re-renders and performance issues.",
            "It may create subtle UI bugs that are difficult to track.",
            "It causes the component to render slower than without keys."
          ],
          "analysisPoints": [
            "Incorrect keys primarily cause state corruption and incorrect rendering, not necessarily slower initial rendering than no keys at all.",
            "Using `index` as a key can *lead* to unnecessary re-renders and performance issues due to inefficient diffing, but the option implies it makes rendering inherently slower than if no keys were used, which isn't the direct problem.",
            "Keys are for *reconciliation efficiency*, not initial render speed.",
            "State mix-up, unnecessary re-renders, and subtle bugs are direct consequences of incorrect keys."
          ],
          "keyConcepts": [
            "React Keys",
            "Reconciliation",
            "Performance",
            "State Management"
          ],
          "evaluationCriteria": [
            "Understanding of key prop pitfalls.",
            "Ability to distinguish true consequences from misleading statements."
          ],
          "example": "The problem with `index` as a key is not that it's inherently slower than no key (React still uses them internally if not provided, but less effectively), but that it breaks the identity mapping React needs for correct updates when the list changes. The performance hit comes from React re-rendering more components than necessary.",
          "tags": [
            "React",
            "Keys",
            "Lists",
            "Performance",
            "Bugs"
          ],
          "prerequisites": [
            "React_Keys"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_key_best_practice_mcq",
          "topic": "React Keys",
          "level": "easy",
          "type": "mcq",
          "question": "Given the following array of `users`, which is the best way to render a list of `UserListItem` components in React?",
          "answer": "{users.map(user => (<UserListItem key={user.id} user={user} />))}",
          "options": [
            "{users.map((user, index) => (<UserListItem key={index} user={user} />))}",
            "{users.map(user => (<UserListItem key={user.id} user={user} />))}",
            "{users.map(user => (<UserListItem user={user} />))}",
            "{users.map((user, index) => (<UserListItem key={user.name + index} user={user} />))}"
          ],
          "analysisPoints": [
            "Option 1 uses `index` which is bad if list items change order.",
            "Option 3 provides no key, which is also problematic for performance and correctness.",
            "Option 4 creates a composite key which might not be globally unique and stable if names can be duplicated or change.",
            "Option 2 uses a stable, unique ID (`user.id`), which is the best practice for React keys."
          ],
          "keyConcepts": [
            "React Keys",
            "List Rendering",
            "Best Practices"
          ],
          "evaluationCriteria": [
            "Understanding of correct key usage.",
            "Ability to identify optimal solutions."
          ],
          "example": "```javascript\nconst users = [\n  { id: 'a1', name: 'Alice' },\n  { id: 'b2', name: 'Bob' },\n  { id: 'c3', name: 'Charlie' }\n];\n\n// Correct:\n// {users.map(user => (<UserListItem key={user.id} user={user} />))}\n// This uses a unique and stable identifier for each list item.\n```",
          "tags": [
            "React",
            "Keys",
            "Best Practices",
            "MCQ"
          ],
          "prerequisites": [
            "React_Components",
            "React_Keys"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_key_consequences_open",
          "topic": "React Keys",
          "level": "hard",
          "type": "open",
          "question": "You have a React component that renders a list of items, each with a delete button. If you use the array index as the `key` prop, describe in detail the specific issues that might arise when an item is deleted from the middle of the list. How would using a stable unique ID prevent these issues?",
          "answer": "When an item is deleted from the middle of a list where array index is used as `key`, React's diffing algorithm can get confused. If, for example, you have items A, B, C with keys 0, 1, 2, and you delete B (index 1), the new list becomes A, C. The new item C now occupies index 1. React, seeing that key `1` still exists but its props have changed from B to C, will try to *update* the component previously at index 1 (which was B) to now represent C, instead of correctly removing B and simply shifting C.\n\nSpecific issues:\n1.  **State Corruption:** If `ListItem` components have internal state (e.g., an input field, a toggle button), the state of the old item at index 2 (C) might be lost, or worse, the component at index 1 (B's old spot) might retain B's internal state but render C's data. This leads to visual discrepancies and incorrect behavior.\n2.  **Performance Degradation:** Instead of performing a simple removal of one item and shifting others efficiently, React might perform more complex updates (e.g., updating props for many components, or even remounting components) because it misidentifies the elements.\n3.  **Unpredictable Behavior/Bugs:** User interactions might affect the wrong data, or components might not render as expected, making debugging very difficult.\n\nUsing a stable unique ID (e.g., `item.id`) ensures that each component instance is uniquely identified regardless of its position. When item B with `key='b_id'` is deleted, React sees that the component with `key='b_id'` is gone and efficiently unmounts it. Item C, with its stable `key='c_id'`, will be correctly identified and, if necessary, simply shifted in the DOM without losing its state or causing other components to be incorrectly updated. This maintains component identity and ensures correct rendering and state preservation.",
          "analysisPoints": [
            "Detailed explanation of state corruption.",
            "Explanation of performance degradation due to incorrect diffing.",
            "Clarity on how unique IDs solve the problem by preserving component identity."
          ],
          "keyConcepts": [
            "React Keys",
            "Diffing Algorithm",
            "Reconciliation",
            "State Management",
            "Performance",
            "Debugging"
          ],
          "evaluationCriteria": [
            "In-depth understanding of React's reconciliation process.",
            "Ability to articulate specific consequences of anti-patterns.",
            "Knowledge of best practices and their rationale."
          ],
          "example": "",
          "tags": [
            "React",
            "Keys",
            "Best Practices",
            "Performance",
            "Bugs"
          ],
          "prerequisites": [
            "React_Keys",
            "React_State"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_js_event_delegation_explanation",
          "topic": "JavaScript Event Delegation",
          "level": "medium",
          "type": "open",
          "question": "Explain event delegation in JavaScript and describe its benefits. Provide a simple example.",
          "answer": "Event delegation is a technique where you attach a single event listener to a parent element, instead of attaching separate listeners to each individual child element. When an event (like a click) occurs on a child, it 'bubbles up' the DOM tree. The single listener on the parent then catches the event, and by inspecting `event.target` (the element that originally triggered the event), it can determine which child was clicked and execute the appropriate logic.\n\n**Benefits:**\n1.  **Performance/Memory Efficiency:** Reduces the number of event listeners in the DOM, especially beneficial for large lists or tables. Each listener consumes memory and processing power.\n2.  **Handles Dynamic Elements:** Automatically works for elements added to the DOM *after* the page has loaded, without needing to attach new listeners to them explicitly.\n3.  **Simpler Code:** Centralizes event handling logic, making the code cleaner and easier to maintain.\n\n```javascript\n// HTML:\n// <ul id=\"parent-list\">\n//   <li>Item 1</li>\n//   <li>Item 2</li>\n// </ul>\n\nconst parentList = document.getElementById('parent-list');\n\nparentList.addEventListener('click', function(event) {\n  // Check if the clicked element is an <li>\n  if (event.target.tagName === 'LI') {\n    console.log(`Item clicked: ${event.target.textContent}`);\n    event.target.style.backgroundColor = 'lightblue';\n  }\n});\n\n// Add a new item dynamically - it will also be handled by the single listener\nconst newItem = document.createElement('li');\nnewItem.textContent = 'Item 3 (new)';\nparentList.appendChild(newItem);\n```",
          "analysisPoints": [
            "Clear definition of event delegation.",
            "Explanation of event bubbling mechanism.",
            "Identification of key benefits (performance, dynamic elements).",
            "Correct and runnable code example."
          ],
          "keyConcepts": [
            "Event Delegation",
            "Event Bubbling",
            "DOM Events",
            "Performance"
          ],
          "evaluationCriteria": [
            "Thorough understanding of the concept.",
            "Ability to provide a practical example.",
            "Knowledge of its advantages."
          ],
          "example": "```javascript\n// See answer for example code.\n```",
          "tags": [
            "JavaScript",
            "DOM",
            "Events",
            "Performance",
            "Event Delegation"
          ],
          "prerequisites": [
            "JavaScript_Basics",
            "DOM_Manipulation"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_js_double_triple_equals_mcq",
          "topic": "JavaScript Equality Operators",
          "level": "easy",
          "type": "mcq",
          "question": "What is the output of the following JavaScript code snippet?\n```javascript\nconsole.log(1 == '1');\nconsole.log(1 === '1');\n```",
          "answer": "true\nfalse",
          "options": [
            "true\ntrue",
            "false\nfalse",
            "true\nfalse",
            "false\ntrue"
          ],
          "analysisPoints": [
            "`==` (loose equality) performs type coercion, converting the string '1' to a number 1 before comparison, resulting in `true`.",
            "`===` (strict equality) compares both value and type without coercion. A number and a string are different types, resulting in `false`."
          ],
          "keyConcepts": [
            "Equality Operators",
            "Type Coercion",
            "JavaScript Types"
          ],
          "evaluationCriteria": [
            "Understanding of `==` vs `===`.",
            "Knowledge of JavaScript's type coercion rules."
          ],
          "example": "```javascript\nconsole.log(1 == '1');  // true (string '1' becomes number 1)\nconsole.log(1 === '1'); // false (number vs string)\n```",
          "tags": [
            "JavaScript",
            "Equality",
            "Operators",
            "MCQ"
          ],
          "prerequisites": [
            "JavaScript_Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_js_closure_definition",
          "topic": "JavaScript Closures",
          "level": "medium",
          "type": "flashcard",
          "question": "Define what a closure is in JavaScript.",
          "answer": "A closure is a function that has access to its outer function's scope, even after the outer function has returned. It 'remembers' the environment in which it was created.",
          "analysisPoints": [
            "Access to outer scope.",
            "Persistence after outer function returns.",
            "Lexical environment."
          ],
          "keyConcepts": [
            "Closures",
            "Scope",
            "Lexical Environment"
          ],
          "evaluationCriteria": [
            "Ability to define core concept.",
            "Understanding of scope persistence."
          ],
          "example": "",
          "tags": [
            "JavaScript",
            "Closures",
            "Scope",
            "Functions"
          ],
          "prerequisites": [
            "JavaScript_Functions",
            "Scope"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_js_closure_use_case_code",
          "topic": "JavaScript Closures",
          "level": "hard",
          "type": "code",
          "question": "Implement a function `createIdGenerator` that uses a closure to generate unique sequential IDs. The function should take an optional `startFrom` argument (defaulting to 1), and return an inner function. Each call to the inner function should return the next sequential ID. Demonstrate its usage.",
          "answer": "```javascript\nfunction createIdGenerator(startFrom = 1) {\n  let currentId = startFrom; // This variable is 'closed over'\n\n  return function() {\n    return currentId++; // Increments and returns the current ID, then increments for next call\n  };\n}\n\n// Demonstrating usage:\nconst generateDefaultId = createIdGenerator();\nconsole.log(generateDefaultId()); // Output: 1\nconsole.log(generateDefaultId()); // Output: 2\n\nconst generateUserId = createIdGenerator(100);\nconsole.log(generateUserId()); // Output: 100\nconsole.log(generateUserId()); // Output: 101\n\n// Independent generators\nconsole.log(generateDefaultId()); // Output: 3\n```",
          "analysisPoints": [
            "Correct use of `let` to maintain state.",
            "Inner function correctly accesses and modifies `currentId` from outer scope.",
            "Demonstrates independent instances of the closure.",
            "Handles default parameter."
          ],
          "keyConcepts": [
            "Closures",
            "Functions",
            "Scope",
            "State Management"
          ],
          "evaluationCriteria": [
            "Ability to apply closure concept.",
            "Correct implementation of stateful function.",
            "Understanding of independent closure instances."
          ],
          "example": "```javascript\n// See answer for example code.\n```",
          "tags": [
            "JavaScript",
            "Closures",
            "Code Challenge",
            "Functions"
          ],
          "prerequisites": [
            "JavaScript_Functions",
            "Scope"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_js_prototype_inheritance_open",
          "topic": "JavaScript Prototype Inheritance",
          "level": "medium",
          "type": "open",
          "question": "What is prototype inheritance in JavaScript? How does an object find a property or method that is not directly on itself?",
          "answer": "Prototype inheritance is the mechanism in JavaScript where objects can inherit properties and methods from other objects. Instead of traditional class-based inheritance, JavaScript uses prototypes. Every JavaScript object has an internal `[[Prototype]]` (or `__proto__`) property that links it to another object, its prototype.\n\nWhen you try to access a property or method on an object, JavaScript follows a specific lookup process:\n1.  It first checks if the property/method exists directly on the object itself.\n2.  If not found, it then looks for the property/method on the object's `[[Prototype]]` (the object it inherits from).\n3.  If still not found, it continues up the `prototype chain`, recursively checking the prototype's prototype, and so on.\n4.  This process continues until the property/method is found, or until it reaches the end of the prototype chain (which is `null`), at which point `undefined` is returned.\n\nThis chain allows objects to share properties and methods, promoting memory efficiency and inheritance.",
          "analysisPoints": [
            "Clear definition of prototype inheritance.",
            "Accurate description of the property lookup process.",
            "Mention of `[[Prototype]]` or `__proto__` and prototype chain.",
            "Understanding of the end of the chain."
          ],
          "keyConcepts": [
            "Prototype Inheritance",
            "Prototype Chain",
            "Objects",
            "JavaScript"
          ],
          "evaluationCriteria": [
            "Understanding of JavaScript's inheritance model.",
            "Ability to explain property lookup.",
            "Knowledge of core prototype concepts."
          ],
          "example": "",
          "tags": [
            "JavaScript",
            "Prototypes",
            "Inheritance",
            "Objects"
          ],
          "prerequisites": [
            "JavaScript_Objects"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_js_event_loop_flow",
          "topic": "JavaScript Event Loop",
          "level": "hard",
          "type": "open",
          "question": "Describe the main components of the JavaScript Event Loop and explain how it allows JavaScript to perform non-blocking operations despite being single-threaded. Illustrate the execution order with a conceptual example involving `setTimeout` and `Promise.resolve`.",
          "answer": "The JavaScript Event Loop is a crucial concurrency model that enables JavaScript to handle asynchronous operations without blocking the single execution thread. Its main components are:\n\n1.  **Call Stack:** This is where synchronous JavaScript code is executed. Functions are pushed onto the stack when invoked and popped off when they return. It's strictly LIFO (Last-In, First-Out).\n2.  **Web APIs / Node.js APIs:** These are environments (like browser APIs for `setTimeout`, `fetch`, DOM events, or Node.js APIs for file I/O) that handle asynchronous tasks. When JavaScript encounters an async operation, it offloads it to the respective Web API.\n3.  **Callback Queue (or Macrotask Queue):** After a Web API completes an asynchronous task (e.g., `setTimeout` delay expires, `fetch` response is ready, a DOM event fires), its associated callback function is moved to this queue.\n4.  **Microtask Queue:** This is a higher-priority queue than the Callback Queue. It holds callbacks for Promises (`.then()`, `.catch()`, `.finally()`) and `queueMicrotask`.\n5.  **Event Loop:** This is a continuous process that constantly monitors the Call Stack. When the Call Stack is empty, the Event Loop first checks the Microtask Queue. It dequeues and executes *all* microtasks until the Microtask Queue is empty. After that, it checks the Callback Queue. If it's not empty, it takes the first callback from the Callback Queue and pushes it onto the Call Stack for execution. This cycle repeats.\n\nThis mechanism allows JavaScript to be non-blocking: synchronous code runs first, then asynchronous tasks are offloaded, and their callbacks are queued. The Event Loop ensures these callbacks are executed *only* when the Call Stack is free, preventing blocking behavior.\n\n**Conceptual Example Execution Order:**\n```javascript\nconsole.log('Synchronous 1');\n\nsetTimeout(() => {\n  console.log('Macrotask (setTimeout)');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Microtask (Promise)');\n});\n\nconsole.log('Synchronous 2');\n\n// Execution Flow:\n// 1. 'Synchronous 1' is logged (Call Stack).\n// 2. setTimeout callback is sent to Web API, then moved to Callback Queue after 0ms.\n// 3. Promise.resolve().then() callback is sent to Microtask Queue.\n// 4. 'Synchronous 2' is logged (Call Stack).\n// 5. Call Stack is now empty.\n// 6. Event Loop checks Microtask Queue: Moves 'Microtask (Promise)' callback to Call Stack.\n// 7. 'Microtask (Promise)' is logged (Call Stack).\n// 8. Call Stack empty again.\n// 9. Event Loop checks Microtask Queue (empty).\n// 10. Event Loop checks Callback Queue: Moves 'Macrotask (setTimeout)' callback to Call Stack.\n// 11. 'Macrotask (setTimeout)' is logged (Call Stack).\n\n// Final Output Order:\n// Synchronous 1\n// Synchronous 2\n// Microtask (Promise)\n// Macrotask (setTimeout)\n```",
          "analysisPoints": [
            "Comprehensive description of Call Stack, Web APIs, Callback Queue, Microtask Queue, and Event Loop.",
            "Clear explanation of single-threaded non-blocking behavior.",
            "Accurate illustration of execution order with `setTimeout` and `Promise.resolve` demonstrating microtask priority."
          ],
          "keyConcepts": [
            "Event Loop",
            "Asynchronous JavaScript",
            "Call Stack",
            "Task Queue",
            "Microtask Queue",
            "Web APIs",
            "Single-threaded"
          ],
          "evaluationCriteria": [
            "Deep understanding of JS runtime environment.",
            "Ability to explain complex asynchronous concepts.",
            "Correctly illustrates priority of queues."
          ],
          "example": "```javascript\n// See answer for example code.\n```",
          "tags": [
            "JavaScript",
            "Event Loop",
            "Asynchronous",
            "Concurrency"
          ],
          "prerequisites": [
            "JavaScript_Functions",
            "Promises",
            "setTimeout"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_js_event_loop_mcq",
          "topic": "JavaScript Event Loop",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code:\n```javascript\nconsole.log('A');\n\nsetTimeout(() => {\n  console.log('B');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('C');\n});\n\nconsole.log('D');\n```\nWhat will be the exact order of console outputs?",
          "answer": "A, D, C, B",
          "options": [
            "A, B, C, D",
            "A, D, B, C",
            "A, C, B, D",
            "A, D, C, B"
          ],
          "analysisPoints": [
            "Synchronous code runs first: 'A' then 'D'.",
            "Promises (microtasks) have higher priority than `setTimeout` (macrotasks).",
            "So, 'C' (from Promise) executes before 'B' (from setTimeout), even with 0ms delay."
          ],
          "keyConcepts": [
            "Event Loop",
            "Microtasks",
            "Macrotasks",
            "Execution Order",
            "Promises",
            "setTimeout"
          ],
          "evaluationCriteria": [
            "Correct understanding of event loop queue priorities.",
            "Ability to trace execution flow."
          ],
          "example": "```javascript\n// The outputs will be:\n// A\n// D\n// C\n// B\n// Because synchronous code runs first, then microtasks (Promises), then macrotasks (setTimeout).\n```",
          "tags": [
            "JavaScript",
            "Event Loop",
            "Asynchronous",
            "MCQ"
          ],
          "prerequisites": [
            "Promises",
            "setTimeout"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_virtual_dom_explanation",
          "topic": "React Virtual DOM",
          "level": "medium",
          "type": "open",
          "question": "What is the Virtual DOM in React and why is it used?",
          "answer": "The Virtual DOM (VDOM) is a lightweight, in-memory representation of the actual DOM. It's a JavaScript object that mimics the structure of the browser's DOM tree. React uses it as an abstraction layer for rendering the UI.\n\n**Why it's used:**\nDirectly manipulating the actual DOM is a very expensive operation in terms of performance. Each time the DOM is modified, the browser has to re-calculate styles, layout, and repaint, which can be slow and lead to janky UIs, especially for complex applications with frequent updates.\n\nReact uses the Virtual DOM to optimize this process:\n1.  When a component's state or props change, React first re-renders its Virtual DOM representation.\n2.  It then compares this new Virtual DOM with the previous one (a process called 'diffing').\n3.  Based on the diff, React calculates the minimal set of changes (additions, deletions, updates) required.\n4.  Finally, React applies only these necessary changes to the actual DOM. This process is called 'Reconciliation'.\n\nThis approach minimizes direct DOM manipulations, leading to significant performance improvements and a smoother user experience, as React can batch updates and avoid unnecessary re-renders.",
          "analysisPoints": [
            "Clear definition of Virtual DOM.",
            "Explanation of its purpose (performance optimization).",
            "Description of diffing and reconciliation process.",
            "Understanding of the cost of direct DOM manipulation."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Reconciliation",
            "Diffing",
            "Performance Optimization",
            "React"
          ],
          "evaluationCriteria": [
            "Thorough understanding of VDOM mechanics.",
            "Ability to explain performance benefits.",
            "Knowledge of reconciliation process."
          ],
          "example": "",
          "tags": [
            "React",
            "Virtual DOM",
            "Performance",
            "Interview"
          ],
          "prerequisites": [
            "React_Components",
            "DOM_Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_vdom_performance_benefits",
          "topic": "React Virtual DOM",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary performance benefit of using the Virtual DOM in React?",
          "answer": "The primary benefit is minimizing direct manipulations of the actual DOM, which is a slow operation. React calculates the minimal changes needed and applies them efficiently.",
          "analysisPoints": [
            "Focus on DOM manipulation cost.",
            "Efficiency through minimal updates."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Performance",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Quick recall of VDOM's main advantage."
          ],
          "example": "",
          "tags": [
            "React",
            "Virtual DOM",
            "Performance",
            "Flashcard"
          ],
          "prerequisites": [
            "Virtual_DOM"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_state_vs_props",
          "topic": "React State & Props",
          "level": "medium",
          "type": "mcq",
          "question": "Which statement accurately describes the difference between `state` and `props` in React?",
          "answer": "Props are passed from parent to child and are immutable within the child; state is managed internally by a component and can be changed by the component itself.",
          "options": [
            "State is used for passing data down to child components, while props are for internal component data.",
            "Props can be modified by the component that receives them, whereas state is immutable.",
            "Props are passed from parent to child and are immutable within the child; state is managed internally by a component and can be changed by the component itself.",
            "Both state and props are managed internally by a component and can be changed over time."
          ],
          "analysisPoints": [
            "Option 1 incorrectly defines their usage.",
            "Option 2 incorrectly states mutability.",
            "Option 4 incorrectly states both are internal and mutable.",
            "Option 3 correctly identifies props as immutable and external/passed, and state as mutable and internal/managed."
          ],
          "keyConcepts": [
            "React State",
            "React Props",
            "Data Flow",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Clear understanding of `state` vs. `props` definitions.",
            "Knowledge of data flow and mutability rules."
          ],
          "example": "```javascript\n// ParentComponent passing props and managing state:\nfunction ParentComponent() {\n  const [count, setCount] = React.useState(0);\n  return <ChildComponent value={count} onIncrement={() => setCount(count + 1)} />;\n}\n\n// ChildComponent receiving props (value, onIncrement) and cannot change them:\nfunction ChildComponent(props) {\n  // props.value = 5; // ERROR: Cannot modify props\n  return (\n    <div>\n      <p>Received prop: {props.value}</p>\n      <button onClick={props.onIncrement}>Increment from Child</button>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "State",
            "Props",
            "MCQ",
            "Fundamentals"
          ],
          "prerequisites": [
            "React_Components"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_hooks_definition",
          "topic": "React Hooks",
          "level": "easy",
          "type": "flashcard",
          "question": "What are React Hooks?",
          "answer": "React Hooks are functions that let you 'hook into' React state and lifecycle features from functional components. They were introduced to allow functional components to have state and side effects without writing class components.",
          "analysisPoints": [
            "Functions for state/lifecycle in functional components.",
            "Alternative to class components for these features."
          ],
          "keyConcepts": [
            "React Hooks",
            "Functional Components",
            "State",
            "Lifecycle"
          ],
          "evaluationCriteria": [
            "Basic definition of Hooks."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Functional Components",
            "Flashcard"
          ],
          "prerequisites": [
            "React_Components"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_hooks_types_flashcard",
          "topic": "React Hooks",
          "level": "medium",
          "type": "flashcard",
          "question": "Name at least three common React Hooks and briefly describe their purpose.",
          "answer": "- `useState`: Adds state to functional components.\n- `useEffect`: Performs side effects (e.g., data fetching, subscriptions) after render.\n- `useContext`: Subscribes to React context.\n- `useReducer`: Alternative to `useState` for complex state logic.\n- `useMemo`: Memoizes (caches) expensive computations.\n- `useCallback`: Memoizes callback functions.",
          "analysisPoints": [
            "Recall common hooks.",
            "Briefly state their primary function."
          ],
          "keyConcepts": [
            "React Hooks",
            "useState",
            "useEffect",
            "useContext",
            "useReducer",
            "useMemo",
            "useCallback"
          ],
          "evaluationCriteria": [
            "Knowledge of commonly used Hooks.",
            "Ability to explain their basic use cases."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Functional Components",
            "Flashcard"
          ],
          "prerequisites": [
            "React_Hooks"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_diffing_algorithm",
          "topic": "React Diffing Algorithm",
          "level": "medium",
          "type": "open",
          "question": "Explain React's diffing algorithm and its primary heuristics.",
          "answer": "React's diffing algorithm is a part of the reconciliation process. It's the set of heuristics React uses to efficiently compare two virtual DOM trees (the old one and the new one after a state/prop update) to determine the minimal set of changes needed to update the actual DOM.\n\nIts primary heuristics are:\n1.  **Comparing two elements of different types:** If React sees two elements of different types at the same position (e.g., `<div>` changes to `<span>`), it will unmount the old component and destroy its subtree, then build the new tree from scratch. This is an efficient 'destroy and recreate' strategy.\n2.  **Comparing DOM elements of the same type:** If elements are of the same type (e.g., `<div>` to `<div>`), React looks at their attributes (props). It only updates the attributes that have changed on the existing actual DOM node.\n3.  **Recursing on children:** For elements with children, React processes the children. By default, it iterates over both the old and new lists of children simultaneously. If a `key` prop is provided for list items, React uses these keys to match children from the old list with children in the new list. This allows it to efficiently detect additions, removals, and reordering of list items, minimizing DOM operations.",
          "analysisPoints": [
            "Definition of diffing in context of reconciliation.",
            "Detailed explanation of heuristics for different types.",
            "Detailed explanation of heuristics for same types.",
            "Detailed explanation of how keys help with children comparison."
          ],
          "keyConcepts": [
            "React Diffing",
            "Reconciliation",
            "Virtual DOM",
            "Keys",
            "Performance"
          ],
          "evaluationCriteria": [
            "Understanding of how React optimizes DOM updates.",
            "Knowledge of the core rules of the diffing algorithm.",
            "Ability to explain key's role in diffing."
          ],
          "example": "",
          "tags": [
            "React",
            "Diffing",
            "Reconciliation",
            "Performance"
          ],
          "prerequisites": [
            "Virtual_DOM",
            "React_Keys"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_redux_definition_when_to_use",
          "topic": "Redux",
          "level": "medium",
          "type": "open",
          "question": "What is Redux and when would you typically use it in a React application?",
          "answer": "Redux is a predictable state container for JavaScript applications. It provides a centralized store for your application's state, making state changes predictable and easier to debug. It's often used with React to manage global or application-wide state.\n\n**When to use it:**\nRedux is generally considered for applications with:\n1.  **Complex State:** When the state is large, has many branches, or needs to be shared across many components, especially those not directly related (avoiding 'prop drilling').\n2.  **Frequent State Updates:** When many actions modify the state throughout the application, and you need a clear, centralized way to manage these updates.\n3.  **Predictable State Changes:** When you need strict control over how state changes occur, with clear actions and pure reducer functions, aiding in debugging and maintaining consistency.\n4.  **Large Teams/Codebases:** It provides a consistent pattern for state management, which is beneficial for collaboration on larger projects.\n\nFor simpler applications, React's built-in `useState` and `useContext` hooks are often sufficient for managing state.",
          "analysisPoints": [
            "Clear definition of Redux.",
            "Understanding of its core purpose (predictable state container).",
            "Identification of scenarios where Redux is beneficial.",
            "Contrast with simpler state management solutions."
          ],
          "keyConcepts": [
            "Redux",
            "State Management",
            "Predictable State",
            "Centralized Store",
            "Actions",
            "Reducers"
          ],
          "evaluationCriteria": [
            "Understanding of Redux's role.",
            "Ability to identify appropriate use cases for Redux.",
            "Awareness of alternatives."
          ],
          "example": "",
          "tags": [
            "React",
            "Redux",
            "State Management",
            "Architecture"
          ],
          "prerequisites": [
            "React_State_Props"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_redux_principles_open",
          "topic": "Redux",
          "level": "hard",
          "type": "open",
          "question": "Redux follows three core principles. List and briefly explain each one.",
          "answer": "Redux adheres to three fundamental principles that ensure predictable state management:\n\n1.  **Single Source of Truth:** The entire application's state is stored in a single, plain JavaScript object tree within one 'store'. This means there's only one place to find any piece of state, simplifying debugging and state synchronization across different parts of the application.\n\n2.  **State is Read-Only:** The only way to change the state is by emitting an action, which is a plain JavaScript object describing what happened (e.g., `{ type: 'ADD_TODO', text: 'Learn Redux' }`). You cannot directly modify the state object. This ensures that changes are explicit, traceable, and prevents accidental mutations, making it easier to understand how the state evolved.\n\n3.  **Changes Are Made with Pure Functions (Reducers):** To specify how the state tree is transformed by actions, you write pure functions called reducers. A reducer takes the current state and an action as arguments, and returns a *new* state object. It must not mutate the original state, perform side effects (like API calls or DOM manipulations), or have any randomness. This purity guarantees that given the same state and action, reducers will always produce the same output, leading to predictable state changes and easier testing.",
          "analysisPoints": [
            "Correctly lists all three principles.",
            "Provides a clear and concise explanation for each principle.",
            "Highlights the importance of each principle in ensuring predictability."
          ],
          "keyConcepts": [
            "Redux Principles",
            "Single Source of Truth",
            "State Immutability",
            "Pure Functions",
            "Reducers",
            "Actions"
          ],
          "evaluationCriteria": [
            "In-depth knowledge of Redux's core philosophy.",
            "Ability to articulate the rationale behind each principle."
          ],
          "example": "",
          "tags": [
            "Redux",
            "State Management",
            "Architecture",
            "Principles"
          ],
          "prerequisites": [
            "Redux_Basics"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_setstate_async",
          "topic": "React setState()",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following React class component method, what will be the most likely output in the console when `handleClick` is called?\n```javascript\nclass MyComponent extends React.Component {\n  state = { count: 0 };\n\n  handleClick = () => {\n    this.setState({ count: this.state.count + 1 });\n    console.log(this.state.count);\n\n    this.setState({ count: this.state.count + 1 });\n    console.log(this.state.count);\n  };\n\n  render() {\n    return <button onClick={this.handleClick}>Click</button>;\n  }\n}\n```\nAssume the initial `count` is 0.",
          "answer": "0\n0",
          "options": [
            "0\n1",
            "1\n2",
            "0\n0",
            "1\n1"
          ],
          "analysisPoints": [
            " `setState()` is asynchronous and React often batches multiple calls for performance.",
            "Therefore, `this.state.count` inside the `handleClick` function will likely still reflect the state *before* the `setState` calls have been processed and applied.",
            "Both `console.log` statements will read the `count` value as it was at the beginning of the `handleClick` execution (0)."
          ],
          "keyConcepts": [
            "React setState",
            "Asynchronous Operations",
            "State Batching",
            "Class Components"
          ],
          "evaluationCriteria": [
            "Understanding of `setState()`'s asynchronous nature.",
            "Knowledge of state batching in React."
          ],
          "example": "```javascript\n// In a real browser environment, due to batching of setState calls \n// within an event handler, both console.logs will likely output the original state value.\n// The final count will be 2 (from two +1 operations), but the console logs happen before that update is reflected.\n```",
          "tags": [
            "React",
            "setState",
            "Asynchronous",
            "MCQ"
          ],
          "prerequisites": [
            "React_State"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_setstate_functional_use_case_code",
          "topic": "React setState()",
          "level": "medium",
          "type": "code",
          "question": "You want to increment a counter in a React class component based on its current state. You also need to perform another action immediately after the state has *definitively* updated. Write the `handleClick` method for a `Counter` component that achieves this, using best practices for `setState`.",
          "answer": "```javascript\nclass Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  handleClick = () => {\n    // Functional form of setState for updates based on previous state\n    this.setState((prevState) => ({\n      count: prevState.count + 1\n    }), () => {\n      // Callback function executed AFTER state is updated and component re-rendered\n      console.log('State updated to:', this.state.count);\n      // Perform other actions that depend on the updated state here\n      this.props.onCountChange(this.state.count);\n    });\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleClick}>Increment</button>\n      </div>\n    );\n  }\n}\n```",
          "analysisPoints": [
            "Correct use of the functional form of `setState` (`prevState` => `newState`) for reliable updates.",
            "Correct use of the `setState` callback to ensure code runs after the state update.",
            "Demonstrates a practical scenario (e.g., passing updated state to a parent)."
          ],
          "keyConcepts": [
            "React setState",
            "Functional Updates",
            "Asynchronous Operations",
            "Callbacks",
            "Class Components"
          ],
          "evaluationCriteria": [
            "Ability to use functional `setState`.",
            "Correct implementation of `setState` callback.",
            "Understanding of reliable state updates."
          ],
          "example": "```javascript\n// See answer for example code.\n```",
          "tags": [
            "React",
            "setState",
            "Code Challenge",
            "Best Practices"
          ],
          "prerequisites": [
            "React_State",
            "React_Class_Components"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_react_refactor_list_keys",
          "title": "Refactor React List Keys",
          "description": "\nYou are given a React functional component `ShoppingCart` that displays a list of `cartItems`. Currently, it uses the array `index` as the `key` prop for its `CartItem` sub-components. This is causing issues when items are removed or reordered.\n\nYour task is to refactor the `ShoppingCart` component to use a stable, unique identifier as the `key` prop. Assume each `cartItem` object has a unique `id` property.\n\n**Requirements:**\n1.  Modify `ShoppingCart` to map `cartItems` using `item.id` as the `key`.\n2.  Keep the `CartItem` component unchanged, as it correctly displays item details.\n3.  Demonstrate how removing an item (e.g., 'Banana') now correctly updates the list without state mix-ups. You can simulate removal by filtering the `cartItems` state.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// Assume this component has some internal state, e.g., input for quantity\n// For simplicity, we'll just show its name here.\nfunction CartItem({ item, onRemove }) {\n  console.log(`Rendering CartItem: ${item.name} with key: ${item.id}`); // Added for debugging\n  const [quantity, setQuantity] = useState(1); // Simulating internal state\n\n  return (\n    <li style={{ border: '1px solid #ccc', margin: '5px', padding: '5px' }}>\n      {item.name} (Qty: {quantity})\n      <button onClick={() => setQuantity(quantity + 1)}>Add More</button>\n      <button onClick={() => onRemove(item.id)} style={{ marginLeft: '10px' }}>Remove</button>\n    </li>\n  );\n}\n\nfunction ShoppingCart() {\n  const initialCart = [\n    { id: 'uuid-1', name: 'Apple' },\n    { id: 'uuid-2', name: 'Banana' },\n    { id: 'uuid-3', name: 'Orange' }\n  ];\n\n  const [cartItems, setCartItems] = useState(initialCart);\n\n  const removeItem = (idToRemove) => {\n    setCartItems(prevItems => prevItems.filter(item => item.id !== idToRemove));\n  };\n\n  return (\n    <div>\n      <h2>Shopping Cart (Bad Key Practice)</h2>\n      <ul>\n        {cartItems.map((item, index) => (\n          // BAD PRACTICE: Using index as key\n          <CartItem key={index} item={item} onRemove={removeItem} />\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default ShoppingCart;\n",
          "solutionCode": "import React, { useState } from 'react';\n\n// Assume this component has some internal state, e.g., input for quantity\n// For simplicity, we'll just show its name here.\nfunction CartItem({ item, onRemove }) {\n  // console.log(`Rendering CartItem: ${item.name} with key: ${item.id}`); // Keep for debugging insight\n  const [quantity, setQuantity] = useState(1); // Simulating internal state\n\n  return (\n    <li style={{ border: '1px solid #ccc', margin: '5px', padding: '5px' }}>\n      {item.name} (Qty: {quantity})\n      <button onClick={() => setQuantity(quantity + 1)}>Add More</button>\n      <button onClick={() => onRemove(item.id)} style={{ marginLeft: '10px' }}>Remove</button>\n    </li>\n  );\n}\n\nfunction ShoppingCart() {\n  const initialCart = [\n    { id: 'uuid-1', name: 'Apple' },\n    { id: 'uuid-2', name: 'Banana' },\n    { id: 'uuid-3', name: 'Orange' }\n  ];\n\n  const [cartItems, setCartItems] = useState(initialCart);\n\n  const removeItem = (idToRemove) => {\n    setCartItems(prevItems => prevItems.filter(item => item.id !== idToRemove));\n  };\n\n  return (\n    <div>\n      <h2>Shopping Cart (Good Key Practice)</h2>\n      <ul>\n        {cartItems.map(item => (\n          // GOOD PRACTICE: Using item.id as key\n          <CartItem key={item.id} item={item} onRemove={removeItem} />\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default ShoppingCart;\n",
          "testCases": [
            "Initial render: All items should render correctly.",
            "Remove 'Banana' (id 'uuid-2'): The list should update, 'Apple' and 'Orange' should remain, and 'Orange' (original 'uuid-3') should retain any internal state it might have had (e.g., increased quantity).",
            "Add a new item dynamically: Ensure the new item is added correctly without affecting existing items.",
            "Verify `key` prop usage: Inspect the rendered DOM elements to ensure `data-key` attributes (or similar inspection) reflect `item.id` values, not indices."
          ],
          "hints": [
            "Focus on the `map` function within `ShoppingCart`.",
            "The `CartItem` component's `key` prop is the only place you need to change.",
            "Remember that each item in `initialCart` already has a unique `id` property."
          ],
          "tags": [
            "React",
            "Keys",
            "Lists",
            "Best Practices",
            "Refactoring"
          ],
          "timeEstimate": 20,
          "prerequisites": [
            "React_Components",
            "React_State",
            "React_Keys"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_key_best_practices",
            "question_react_key_index_issue"
          ]
        },
        {
          "id": "task_event_delegation_list",
          "title": "Implement Click Counter with Event Delegation",
          "description": "\nCreate an HTML page with a list (`<ul>`) containing several list items (`<li>`). Your task is to implement a click counter for each list item using **event delegation**. The counter for each item should be displayed next to its text. When an `<li>` is clicked, its individual counter should increment, and an alert should show the updated count for that specific item. You should only attach **one** event listener to the parent `<ul>`.\n\n**Requirements:**\n1.  HTML: A `<ul>` with at least 3 `<li>` elements, each containing some initial text (e.g., 'Item 1').\n2.  JavaScript: Implement event delegation on the `<ul>`.\n3.  Maintain individual click counts for each `<li>`.\n4.  Display the current count next to each `<li>`'s text.\n5.  When an `<li>` is clicked, increment its count and show an `alert` with the item's text and its new count.\n6.  Ensure newly added `<li>` elements are also handled by the existing listener.\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Event Delegation Click Counter</title>\n    <style>\n        li { cursor: pointer; padding: 5px; margin: 2px; border: 1px solid #eee; }\n        li:hover { background-color: #f0f0f0; }\n    </style>\n</head>\n<body>\n    <h1>Click Counter (Event Delegation)</h1>\n    <ul id=\"myList\">\n        <li data-item-id=\"item1\">Item 1 <span class=\"count\">(0)</span></li>\n        <li data-item-id=\"item2\">Item 2 <span class=\"count\">(0)</span></li>\n        <li data-item-id=\"item3\">Item 3 <span class=\"count\">(0)</span></li>\n    </ul>\n    <button id=\"addItemBtn\">Add New Item</button>\n\n    <script>\n        // Your JavaScript code goes here\n        const myList = document.getElementById('myList');\n        const addItemBtn = document.getElementById('addItemBtn');\n        let nextItemId = 4; // For dynamically added items\n\n        // You will need a way to store counts for each item\n        const itemCounts = {}; // Consider how to initialize and update this\n\n        // Add event listener to the parent list\n        myList.addEventListener('click', function(event) {\n          // TODO: Implement event delegation logic\n          // Check if the clicked target is an LI\n          // Get the item's ID from data-item-id attribute\n          // Update the count in itemCounts\n          // Update the DOM to reflect the new count\n          // Show an alert\n        });\n\n        addItemBtn.addEventListener('click', function() {\n          const newItemText = `Item ${nextItemId}`;\n          const newItemId = `item${nextItemId}`;\n          const newLi = document.createElement('li');\n          newLi.setAttribute('data-item-id', newItemId);\n          newLi.innerHTML = `${newItemText} <span class=\"count\">(0)</span>`;\n          myList.appendChild(newLi);\n          itemCounts[newItemId] = 0; // Initialize count for new item\n          nextItemId++;\n        });\n    </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Event Delegation Click Counter</title>\n    <style>\n        li { cursor: pointer; padding: 5px; margin: 2px; border: 1px solid #eee; }\n        li:hover { background-color: #f0f0f0; }\n    </style>\n</head>\n<body>\n    <h1>Click Counter (Event Delegation)</h1>\n    <ul id=\"myList\">\n        <li data-item-id=\"item1\">Item 1 <span class=\"count\">(0)</span></li>\n        <li data-item-id=\"item2\">Item 2 <span class=\"count\">(0)</span></li>\n        <li data-item-id=\"item3\">Item 3 <span class=\"count\">(0)</span></li>\n    </ul>\n    <button id=\"addItemBtn\">Add New Item</button>\n\n    <script>\n        const myList = document.getElementById('myList');\n        const addItemBtn = document.getElementById('addItemBtn');\n        let nextItemId = 4;\n\n        // Use a Map or an Object to store counts, initializing for existing items\n        const itemCounts = {\n            'item1': 0,\n            'item2': 0,\n            'item3': 0\n        };\n\n        myList.addEventListener('click', function(event) {\n          // Ensure the click was directly on an LI, not on the SPAN or UL itself\n          const clickedItem = event.target.closest('li');\n\n          if (clickedItem) {\n            const itemId = clickedItem.dataset.itemId;\n            // Initialize count if it's a new item added dynamically and clicked for the first time\n            if (itemCounts[itemId] === undefined) {\n                itemCounts[itemId] = 0;\n            }\n            itemCounts[itemId]++;\n            \n            // Update the display in the DOM\n            const countSpan = clickedItem.querySelector('.count');\n            if (countSpan) {\n              countSpan.textContent = `(${itemCounts[itemId]})`;\n            }\n            \n            alert(`'${clickedItem.firstChild.textContent.trim()}' clicked! New count: ${itemCounts[itemId]}`);\n          }\n        });\n\n        addItemBtn.addEventListener('click', function() {\n          const newItemText = `Item ${nextItemId}`;\n          const newItemId = `item${nextItemId}`;\n          const newLi = document.createElement('li');\n          newLi.setAttribute('data-item-id', newItemId);\n          newLi.innerHTML = `${newItemText} <span class=\"count\">(0)</span>`;\n          myList.appendChild(newLi);\n          itemCounts[newItemId] = 0; // Initialize count for new item\n          nextItemId++;\n        });\n    </script>\n</body>\n</html>\n",
          "testCases": [
            "Click on 'Item 1': Its count should increment to 1, and an alert should appear.",
            "Click on 'Item 1' again: Its count should increment to 2.",
            "Click on 'Item 2': Its count should increment to 1, independently of 'Item 1'.",
            "Click 'Add New Item' button: A new item should appear in the list.",
            "Click on the newly added item: Its count should increment, demonstrating that the single listener handles dynamically added elements.",
            "Click on an area of the list that is not an `<li>` (e.g., padding on the `<ul>`): No alert or count increment should occur."
          ],
          "hints": [
            "Use `event.target` to identify the element that was actually clicked.",
            "`event.target.tagName` or `event.target.closest('li')` can help verify if the clicked element is an `<li>` or one of its children.",
            "You'll need a JavaScript object or `Map` to store the counts for each item, perhaps keyed by a `data-item-id` attribute on the `<li>`.",
            "Remember to update both your JavaScript data structure (for counts) and the DOM element's text content."
          ],
          "tags": [
            "JavaScript",
            "DOM",
            "Events",
            "Event Delegation",
            "Front-end"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "JavaScript_Basics",
            "DOM_Manipulation",
            "Event_Bubbling"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_javascript_fundamentals",
            "question_js_event_delegation_explanation"
          ]
        },
        {
          "id": "task_closure_private_counter",
          "title": "Build a Private Counter Module with Closure",
          "description": "\nImplement a JavaScript module that exports a factory function `createPrivateCounter`. This function should return an object with two methods: `increment()` and `getCount()`. The counter's value should be private and only accessible or modifiable through these two methods.\n\n**Requirements:**\n1.  Define a function `createPrivateCounter`.\n2.  Inside `createPrivateCounter`, declare a variable `count` initialized to `0`. This variable must be truly private to the returned object.\n3.  Return an object with:\n    *   `increment()`: A method that increments `count` by 1 and returns the new count.\n    *   `getCount()`: A method that returns the current `count`.\n4.  Demonstrate that each instance created by `createPrivateCounter` has its own independent `count`.\n",
          "difficulty": "medium",
          "startingCode": "function createPrivateCounter() {\n  // TODO: Declare a private 'count' variable\n\n  return {\n    increment: function() {\n      // TODO: Increment and return count\n    },\n    getCount: function() {\n      // TODO: Return count\n    }\n  };\n}\n\n// Example Usage (for testing your implementation):\n// const counter1 = createPrivateCounter();\n// console.log(counter1.getCount()); // Should be 0\n// console.log(counter1.increment()); // Should be 1\n// console.log(counter1.getCount()); // Should be 1\n//\n// const counter2 = createPrivateCounter();\n// console.log(counter2.getCount()); // Should be 0 (independent)\n// console.log(counter1.increment()); // Should be 2\n",
          "solutionCode": "function createPrivateCounter() {\n  let count = 0; // This 'count' variable is private due to closure\n\n  return {\n    increment: function() {\n      count++;\n      return count;\n    },\n    getCount: function() {\n      return count;\n    }\n  };\n}\n\n// Demonstrating independent instances:\nconst counter1 = createPrivateCounter();\nconsole.log(\"Counter 1 Initial:\", counter1.getCount()); // Output: 0\nconsole.log(\"Counter 1 Increment:\", counter1.increment()); // Output: 1\nconsole.log(\"Counter 1 Increment:\", counter1.increment()); // Output: 2\nconsole.log(\"Counter 1 Current:\", counter1.getCount());   // Output: 2\n\nconst counter2 = createPrivateCounter();\nconsole.log(\"Counter 2 Initial:\", counter2.getCount()); // Output: 0 (independent from counter1)\nconsole.log(\"Counter 2 Increment:\", counter2.increment()); // Output: 1\nconsole.log(\"Counter 1 Current (again):\", counter1.getCount()); // Output: 2 (counter1 still at 2)\n",
          "testCases": [
            "`counter1.getCount()` after initialization should return 0.",
            "Multiple calls to `counter1.increment()` should correctly increase its count.",
            "`counter2 = createPrivateCounter()` should create an independent counter starting from 0.",
            "Operations on `counter1` should not affect `counter2` and vice-versa.",
            "Attempting to directly access `counter1.count` or `counter2.count` should result in `undefined` (demonstrating privacy)."
          ],
          "hints": [
            "The `count` variable should be declared within `createPrivateCounter` but outside the returned object's methods.",
            "The inner functions will naturally form a closure over `count`."
          ],
          "tags": [
            "JavaScript",
            "Closures",
            "Encapsulation",
            "Functions",
            "Module Pattern"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "JavaScript_Functions",
            "Scope"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_javascript_fundamentals",
            "question_js_closure_definition",
            "question_js_closure_use_case_code"
          ]
        },
        {
          "id": "task_event_loop_prediction",
          "title": "Predict Event Loop Execution Order",
          "description": "\nGiven a series of JavaScript statements involving synchronous code, `setTimeout`, and `Promise.resolve`, you need to predict the exact order of console outputs based on the Event Loop mechanism. Explain your reasoning step-by-step, detailing which queue each task goes into and when it's processed.\n\n**Task:**\n1.  Analyze the provided code snippet.\n2.  Determine the final output order.\n3.  Write a detailed explanation of *why* the output is in that order, referring to the Call Stack, Web APIs, Microtask Queue, and Callback Queue.\n",
          "difficulty": "hard",
          "startingCode": "```javascript\nconsole.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout 1 (0ms)');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 1');\n});\n\nconsole.log('Middle');\n\nsetTimeout(() => {\n  console.log('Timeout 2 (10ms)');\n}, 10);\n\nPromise.resolve().then(() => {\n  console.log('Promise 2');\n});\n\nfunction syncFunction() {\n  console.log('Sync Function');\n}\nsyncFunction();\n\nconsole.log('End');\n```\n",
          "solutionCode": "```javascript\n// Expected Output Order:\n// Start\n// Middle\n// Sync Function\n// End\n// Promise 1\n// Promise 2\n// Timeout 1 (0ms)\n// Timeout 2 (10ms)\n\n// Step-by-step Explanation:\n\n// 1. Initial Synchronous Execution:\n//    - `console.log('Start');` -> Logs 'Start'. Call Stack: [console.log]\n//    - `setTimeout(() => { console.log('Timeout 1 (0ms)'); }, 0);` -> Timer starts, callback moves to Web API, then to Callback (Macrotask) Queue when 0ms expires. Call Stack: []\n//    - `Promise.resolve().then(() => { console.log('Promise 1'); });` -> Promise resolves immediately, callback moves to Microtask Queue. Call Stack: []\n//    - `console.log('Middle');` -> Logs 'Middle'. Call Stack: [console.log]\n//    - `setTimeout(() => { console.log('Timeout 2 (10ms)'); }, 10);` -> Timer starts, callback moves to Web API, then to Callback (Macrotask) Queue after 10ms. Call Stack: []\n//    - `Promise.resolve().then(() => { console.log('Promise 2'); });` -> Promise resolves immediately, callback moves to Microtask Queue. Call Stack: []\n//    - `syncFunction();` -> `console.log('Sync Function');` -> Logs 'Sync Function'. Call Stack: [syncFunction, console.log]\n//    - `console.log('End');` -> Logs 'End'. Call Stack: [console.log]\n//    At this point, all synchronous code is done. Call Stack is empty.\n\n// Current state of queues (conceptual):\n// Microtask Queue: [() => { console.log('Promise 1'); }, () => { console.log('Promise 2'); }]\n// Callback Queue:  [() => { console.log('Timeout 1 (0ms)'); }, () => { console.log('Timeout 2 (10ms)'); }]\n\n// 2. Event Loop Cycle Begins (Call Stack is empty):\n//    - Event Loop checks Microtask Queue first.\n//    - Dequeues `Promise 1` callback and pushes to Call Stack.\n//    - `console.log('Promise 1');` -> Logs 'Promise 1'. Call Stack: [console.log]\n//    - Call Stack becomes empty.\n//    - Event Loop checks Microtask Queue again (it processes *all* microtasks before checking macrotasks).\n//    - Dequeues `Promise 2` callback and pushes to Call Stack.\n//    - `console.log('Promise 2');` -> Logs 'Promise 2'. Call Stack: [console.log]\n//    - Call Stack becomes empty. Microtask Queue is now empty.\n\n// 3. Event Loop Processes Callback (Macrotask) Queue:\n//    - Event Loop checks Callback Queue.\n//    - Dequeues `Timeout 1 (0ms)` callback and pushes to Call Stack.\n//    - `console.log('Timeout 1 (0ms)');` -> Logs 'Timeout 1 (0ms)'. Call Stack: [console.log]\n//    - Call Stack becomes empty.\n//    - Event Loop checks Microtask Queue (still empty).\n//    - Event Loop checks Callback Queue.\n//    - Dequeues `Timeout 2 (10ms)` callback and pushes to Call Stack (assuming 10ms has passed).\n//    - `console.log('Timeout 2 (10ms)');` -> Logs 'Timeout 2 (10ms)'. Call Stack: [console.log]\n//    - Call Stack becomes empty. Callback Queue is now empty.\n\n// The Event Loop continues to run, but all queues are empty.\n```",
          "testCases": [
            "Predict output for the given snippet.",
            "Explain the role of Call Stack, Microtask Queue, and Callback Queue.",
            "Demonstrate understanding of task priority (microtasks before macrotasks)."
          ],
          "hints": [
            "Remember that synchronous code always runs first.",
            "Understand the difference in priority between the Microtask Queue (Promises, `queueMicrotask`) and the Callback (Macrotask) Queue (`setTimeout`, `setInterval`, DOM events).",
            "The Event Loop will clear all microtasks before picking up any macrotask, even if a macrotask has a 0ms delay."
          ],
          "tags": [
            "JavaScript",
            "Event Loop",
            "Asynchronous",
            "Promises",
            "setTimeout",
            "Execution Order"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Promises",
            "setTimeout",
            "JavaScript_Functions"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_javascript_fundamentals",
            "question_js_event_loop_flow",
            "question_js_event_loop_mcq"
          ]
        },
        {
          "id": "task_react_simple_counter_with_props_state",
          "title": "Create a React Counter with State and Props",
          "description": "\nBuild a simple React application consisting of two components: `App` (parent) and `CounterDisplay` (child). The `App` component should manage a `count` state. The `CounterDisplay` component should receive the `count` as a prop and display it. Implement a button in the `App` component that increments the `count` state, demonstrating the unidirectional data flow from parent to child.\n\n**Requirements:**\n1.  Create a functional component `App`.\n2.  `App` should manage a piece of state called `count`, initialized to 0, using `useState`.\n3.  `App` should render a button that, when clicked, increments `count`.\n4.  Create a functional component `CounterDisplay`.\n5.  `CounterDisplay` should accept a `count` prop and display its value.\n6.  `App` should pass its `count` state down to `CounterDisplay` as a prop.\n7.  Ensure `CounterDisplay` does NOT try to modify the `count` prop directly.\n",
          "difficulty": "easy",
          "startingCode": "import React, { useState } from 'react';\n\n// Child Component\nfunction CounterDisplay(props) {\n  // TODO: Display the count prop\n  // TODO: Ensure no direct modification of props (e.g., props.count = 10;)\n  return (\n    <div>\n      {/* Your display logic here */}\n    </div>\n  );\n}\n\n// Parent Component\nfunction App() {\n  // TODO: Manage 'count' state\n  // TODO: Implement an increment function\n\n  return (\n    <div>\n      <h1>Simple Counter</h1>\n      {/* TODO: Pass count to CounterDisplay */}\n      <CounterDisplay />\n      {/* TODO: Add a button to increment count */}\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { useState } from 'react';\n\n// Child Component\nfunction CounterDisplay(props) {\n  return (\n    <h2>Current Count: {props.count}</h2>\n  );\n}\n\n// Parent Component\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const incrementCount = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <h1>Simple Counter</h1>\n      <CounterDisplay count={count} />\n      <button onClick={incrementCount}>Increment Count</button>\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Initial render: Counter display should show '0'.",
            "Click 'Increment Count' button: Counter display should update to '1'.",
            "Multiple clicks: Counter display should continue to increment correctly.",
            "Verify `CounterDisplay` receives `count` as prop and doesn't manage its own `count` state."
          ],
          "hints": [
            "Use `useState` in the `App` component to declare and manage the `count` state.",
            "Pass the `count` state from `App` to `CounterDisplay` using a prop.",
            "The `CounterDisplay` component should only read from its `props`."
          ],
          "tags": [
            "React",
            "State",
            "Props",
            "Functional Components",
            "Data Flow"
          ],
          "timeEstimate": 25,
          "prerequisites": [
            "React_Components",
            "React_State",
            "React_Hooks"
          ],
          "complexity": 4,
          "interviewRelevance": 8,
          "learningPath": "beginner",
          "relatedConcepts": [
            "theory_react_fundamentals",
            "question_react_state_vs_props"
          ]
        },
        {
          "id": "task_react_class_to_functional_component",
          "title": "Convert a Class Component to a Functional Component with Hooks",
          "description": "\nYou are provided with a React class component named `DataFetcher` that fetches data from an API and displays it. Your task is to refactor this class component into a functional component using React Hooks (`useState` and `useEffect`) to achieve the same functionality.\n\n**Original Class Component Functionality:**\n*   Fetches data from `https://jsonplaceholder.typicode.com/posts/1` when the component mounts.\n*   Stores the fetched data in its state.\n*   Displays a loading message while fetching.\n*   Displays the data (specifically the `title` and `body`) once fetched.\n*   Handles potential errors during fetching.\n\n**Requirements:**\n1.  Convert `DataFetcher` from a class component to a functional component.\n2.  Replace `this.state` with `useState` hooks for `data`, `loading`, and `error`.\n3.  Replace `componentDidMount` and any potential `componentDidUpdate` logic with `useEffect` for data fetching.\n4.  Maintain the same UI (loading, error, data display).\n",
          "difficulty": "medium",
          "startingCode": "import React, { Component } from 'react';\n\n// Original Class Component\nclass DataFetcher extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      data: null,\n      loading: true,\n      error: null,\n    };\n  }\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  fetchData = async () => {\n    this.setState({ loading: true, error: null });\n    try {\n      const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      this.setState({ data, loading: false });\n    } catch (error) {\n      this.setState({ error, loading: false });\n    }\n  };\n\n  render() {\n    const { data, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading data...</div>;\n    }\n\n    if (error) {\n      return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n    }\n\n    return (\n      <div>\n        <h2>Fetched Data:</h2>\n        <h3>{data.title}</h3>\n        <p>{data.body}</p>\n      </div>\n    );\n  }\n}\n\nexport default DataFetcher;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// Converted Functional Component\nfunction DataFetcher() {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null); // Reset error on new fetch attempt\n      try {\n        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n    // Empty dependency array ensures this effect runs only once on mount\n  }, []); \n\n  if (loading) {\n    return <div>Loading data...</div>;\n  }\n\n  if (error) {\n    return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n  }\n\n  return (\n    <div>\n      <h2>Fetched Data:</h2>\n      <h3>{data.title}</h3>\n      <p>{data.body}</p>\n    </div>\n  );\n}\n\nexport default DataFetcher;\n",
          "testCases": [
            "Component loads: 'Loading data...' message should appear initially.",
            "Successful fetch: After a short delay, the title and body of the post should be displayed.",
            "Simulate network error (e.g., change URL to an invalid one): An error message should be displayed.",
            "Verify `useState` and `useEffect` are correctly used, replacing class state and lifecycle methods."
          ],
          "hints": [
            "You'll need three `useState` calls for `data`, `loading`, and `error`.",
            "`useEffect` with an empty dependency array (`[]`) behaves like `componentDidMount`.",
            "Remember to handle `async/await` within `useEffect` by defining an inner `async` function and calling it immediately."
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "useEffect",
            "Class Components",
            "Functional Components",
            "Refactoring",
            "Data Fetching"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "React_Class_Components",
            "React_Hooks",
            "Asynchronous_JavaScript"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_fundamentals",
            "question_react_hooks_definition"
          ]
        },
        {
          "id": "task_react_manage_async_state_update",
          "title": "Manage Asynchronous `setState` Updates with Callbacks and Functional Forms",
          "description": "\nCreate a React class component `AsyncCounter` that demonstrates proper handling of asynchronous `setState` updates.\n\n**Requirements:**\n1.  Initialize `count` state to 0.\n2.  Implement a button that increments `count` by 1 **twice** in a single click handler.\n3.  After the first `setState` call, log `this.state.count` *before* the state update is guaranteed to be applied (demonstrating asynchronicity).\n4.  For the second `setState` call, use the **functional form** (updater function) to increment `count` and include a **callback function** that logs the *correct, updated* `count` after both increments have been processed.\n5.  Add another button that calls an `async` function (`incrementTwiceAsync`) which uses the functional `setState` form twice in quick succession to increment the counter, simulating batched updates outside of React's direct control (e.g., within a `setTimeout`). Log the final count after these async updates.\n",
          "difficulty": "hard",
          "startingCode": "import React, { Component } from 'react';\n\nclass AsyncCounter extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  handleSyncClick = () => {\n    // Task 3: Log before guaranteed update\n    this.setState({ count: this.state.count + 1 });\n    console.log('Sync Click - After 1st setState (before update):', this.state.count);\n\n    // Task 4: Functional setState with callback\n    // TODO: Implement functional setState here\n    // TODO: Add a callback to log the final updated count\n  };\n\n  incrementTwiceAsync = () => {\n    // Task 5: Simulate batched async updates\n    setTimeout(() => {\n      // TODO: Use functional setState twice here\n      console.log('Async Update Complete:', this.state.count);\n    }, 0);\n  };\n\n  render() {\n    return (\n      <div>\n        <h1>Async setState Demo</h1>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleSyncClick}>Increment Sync (x2)</button>\n        <button onClick={this.incrementTwiceAsync}>Increment Async (x2)</button>\n      </div>\n    );\n  }\n}\n\nexport default AsyncCounter;\n",
          "solutionCode": "import React, { Component } from 'react';\n\nclass AsyncCounter extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  handleSyncClick = () => {\n    // First setState: demonstrates asynchronous nature\n    this.setState({ count: this.state.count + 1 });\n    console.log('Sync Click - After 1st setState (before update):', this.state.count);\n\n    // Second setState: functional form with callback for guaranteed update\n    this.setState((prevState) => ({\n      count: prevState.count + 1\n    }), () => {\n      console.log('Sync Click - After 2nd setState (callback):', this.state.count);\n      console.log('--- Sync Click batch complete ---');\n    });\n  };\n\n  incrementTwiceAsync = () => {\n    setTimeout(() => {\n      // Using functional setState in an asynchronous context (like setTimeout)\n      // ensures correct updates even when React's internal batching is bypassed.\n      this.setState(prevState => ({ count: prevState.count + 1 }));\n      this.setState(prevState => ({ count: prevState.count + 1 }));\n      console.log('Async Update Complete (via setTimeout):', this.state.count);\n      console.log('--- Async Click batch complete ---');\n    }, 0);\n  };\n\n  render() {\n    return (\n      <div>\n        <h1>Async setState Demo</h1>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleSyncClick}>Increment Sync (x2)</button>\n        <button onClick={this.incrementTwiceAsync}>Increment Async (x2)</button>\n      </div>\n    );\n  }\n}\n\nexport default AsyncCounter;\n",
          "testCases": [
            "Initial render: Count should be 0.",
            "Click 'Increment Sync (x2)':\n  - The first `console.log` should output 0 (stale state).\n  - The `console.log` inside the callback should output 2 (correct final state).\n  - The displayed count in the UI should become 2.",
            "Click 'Increment Async (x2)':\n  - After a slight delay, the `console.log` should output the correct incremented count (e.g., if starting at 2, it should output 4).",
            "Multiple clicks on either button should consistently increment the counter correctly."
          ],
          "hints": [
            "Remember that `setState` calls within React's event handlers are often batched.",
            "To get the *latest* state after an update within the same tick, use the `setState` callback function.",
            "When the new state depends on the previous state, always use the functional form of `setState` (`(prevState, props) => ({ ... })`).",
            "Even when `setState` is called in an asynchronous context (like `setTimeout`), the functional form ensures reliability because `prevState` is guaranteed to be the most recent state at the time of the update."
          ],
          "tags": [
            "React",
            "setState",
            "Asynchronous",
            "State Management",
            "Class Components",
            "Best Practices"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React_State",
            "JavaScript_Asynchronous"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_react_fundamentals",
            "question_react_setstate_async",
            "question_react_setstate_functional_use_case_code"
          ]
        }
      ]
    }
  }
]