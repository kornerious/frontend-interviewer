[
  {
    "id": "335856c4-4f49-4c58-b3f1-c2aa7ce61f04",
    "startLine": 12200,
    "endLine": 12299,
    "processedDate": "2025-06-17T12:47:48.108Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_component_basics",
          "title": "React Functional Components and State Management with Hooks",
          "content": "React applications are built using components, which are independent, reusable pieces of UI. Functional components are JavaScript functions that accept props (properties) as input and return React elements describing what should appear on the screen.\n\n### `useState` Hook\n`useState` is a React Hook that lets you add state to functional components. Before Hooks, state was primarily managed in class components. `useState` returns an array with two elements:\n\n1.  **Current state value**: The current value of the state variable.\n2.  **Setter function**: A function that lets you update the state. When the setter function is called with a new state value, React re-renders the component.\n\n#### Basic Usage\n```typescript\nimport React, { useState } from 'react';\n\nfunction MyComponent() {\n  // Declares a state variable 'count' initialized to 0\n  // and a setter function 'setCount'\n  const [count, setCount] = useState(0);\n\n  // When 'setCount' is called, 'count' updates and the component re-renders.\n  const increment = () => setCount(count + 1);\n\n  return (\n    <div>\n      <p>Current Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n```\n\n### JSX (JavaScript XML)\nReact components use JSX, a syntax extension for JavaScript. JSX allows you to write HTML-like structures directly within your JavaScript code. It's not mandatory to use JSX, but it makes React code more readable and concise. JSX expressions are compiled down to `React.createElement()` calls.",
          "examples": [
            {
              "id": "example_react_counter_1",
              "title": "React Counter Component",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nexport default Counter;",
              "explanation": "This example demonstrates a basic React functional component. `useState(0)` initializes `count` to 0. The button's `onClick` handler calls `setCount` to update the state, which triggers a re-render of the component, displaying the new `count` value.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_hooks_1",
            "question_react_mcq_1",
            "question_react_open_1",
            "question_react_flashcard_1"
          ],
          "relatedTasks": [
            "task_react_simple_counter"
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "Functional Components",
            "JSX",
            "State Management"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript ES6",
            "HTML basics"
          ],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "React State Management",
            "React Hooks Deep Dive",
            "Building SPAs with React"
          ]
        },
        {
          "id": "theory_angular_component_basics",
          "title": "Angular Component Fundamentals",
          "content": "Angular applications are composed of NgModules, which provide a compilation context for components. Components are the fundamental building blocks of an Angular application, responsible for controlling a part of the screen (a view) through its template.\n\n### `@Component` Decorator\nComponents are defined using the `@Component` decorator, which attaches metadata to a TypeScript class, marking it as an Angular component. Key properties include:\n\n*   **`selector`**: A CSS selector that tells Angular to create and insert an instance of this component wherever it finds the corresponding tag in the HTML. (e.g., `app-counter` means use `<app-counter>`).\n*   **`template`** or **`templateUrl`**: Defines the component's view. `template` allows inline HTML, while `templateUrl` points to an external HTML file.\n*   **`styleUrls`**: An array of URLs pointing to CSS files to apply to this component's view. These styles are encapsulated by default.\n\n### Component Class and Data Binding\nAn Angular component is a plain TypeScript class. Properties declared in this class are accessible within the component's template. Angular uses two main types of data binding:\n\n*   **Interpolation `{{ }}`**: Displays a component property's value in the template. This is a one-way data binding from component to view.\n*   **Event Binding `( )`**: Binds a DOM event (like `click`, `submit`) to a method in the component class. When the event occurs, the method is executed. This is a one-way data binding from view to component.\n\n#### Basic Usage\n```typescript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  template: `\n    <div>\n      <p>{{message}}</p>\n      <button (click)=\"changeMessage()\">Change</button>\n    </div>\n  `\n})\nexport class MyComponent {\n  message = 'Hello Angular!';\n\n  changeMessage() {\n    this.message = 'Message Changed!';\n  }\n}\n```",
          "examples": [
            {
              "id": "example_angular_counter_1",
              "title": "Angular Counter Component",
              "code": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-counter',\n  template: `\n    <div>\n      <p>Count: {{count}}</p>\n      <button (click)=\"increment()\">Increment</button>\n    </div>\n  `\n})\nexport class CounterComponent {\n  count = 0;\n  \n  increment() {\n    this.count++;\n  }\n}",
              "explanation": "This example shows an Angular component. The `@Component` decorator defines its selector (`app-counter`) and inline template. `{{count}}` uses interpolation to display the `count` property's value. `(click)=\"increment()\"` binds the button's click event to the `increment` method, which updates `this.count`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_angular_mcq_1",
            "question_angular_open_1",
            "question_angular_flashcard_1",
            "question_angular_code_1"
          ],
          "relatedTasks": [
            "task_angular_data_binding"
          ],
          "tags": [
            "Angular",
            "Components",
            "Decorators",
            "Data Binding",
            "TypeScript"
          ],
          "technology": "Angular",
          "prerequisites": [
            "TypeScript basics",
            "HTML basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Angular Architecture",
            "Angular Forms",
            "Angular Routing"
          ]
        },
        {
          "id": "theory_vue_component_basics",
          "title": "Vue Component Structure and Options API",
          "content": "Vue.js applications are composed of reusable components. A Vue component typically consists of three main blocks: `<template>`, `<script>`, and `<style>` (not shown in the example, but common).\n\n### Single File Components (SFCs)\nVue often uses Single File Components (SFCs) with a `.vue` extension. These files encapsulate the component's template, logic, and styles in a single, cohesive file.\n\n*   **`<template>`**: Contains the HTML structure of the component's view. It must have a single root element.\n*   **`<script>`**: Contains the component's JavaScript logic. When using the Options API (as in the example), `export default` is used to define the component's options.\n    *   **`data()`**: A function that returns an object containing the reactive data for the component. Each property in this object will become reactive, meaning Vue will track its changes and update the view accordingly.\n    *   **`methods`**: An object containing methods (functions) that can be called from the template (e.g., in response to user events).\n*   **`<style>` (Optional)**: Contains the CSS for the component. Can be scoped to prevent styles from leaking to other components.\n\n### Data Reactivity and Event Handling\nVue's reactivity system automatically tracks changes to data properties and efficiently updates the DOM. Event handling in Vue templates uses the `v-on` directive, often shortened to `@`. For example, `@click=\"methodName\"` binds a click event to a method defined in the `methods` option.\n\n#### Basic Usage\n```html\n<template>\n  <div>\n    <p>{{ message }}</p>\n    <button @click=\"changeMessage\">Change Message</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      message: 'Hello Vue!'\n    };\n  },\n  methods: {\n    changeMessage() {\n      this.message = 'Message Changed!';\n    }\n  }\n};\n</script>\n```",
          "examples": [
            {
              "id": "example_vue_counter_1",
              "title": "Vue Counter Component",
              "code": "<template>\n  <div>\n    <p>Count: {{ count }}</p>\n    <button @click=\"increment\">Increment</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      count: 0\n    };\n  },\n  methods: {\n    increment() {\n      this.count++;\n    }\n  }\n};\n</script>",
              "explanation": "This example showcases a Vue Single File Component. The `<template>` defines the view. In the `<script>` block, `data()` returns the reactive `count` property, initialized to 0. The `increment` method, defined in `methods`, updates `this.count`. The `@click` directive on the button calls this method.",
              "language": "html"
            }
          ],
          "relatedQuestions": [
            "question_vue_mcq_1",
            "question_vue_open_1",
            "question_vue_flashcard_1",
            "question_vue_code_1"
          ],
          "relatedTasks": [
            "task_vue_todo_list"
          ],
          "tags": [
            "Vue.js",
            "Components",
            "Options API",
            "Data Reactivity",
            "SFC",
            "Event Handling"
          ],
          "technology": "Vue.js",
          "prerequisites": [
            "JavaScript ES6",
            "HTML basics"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Vue State Management (Vuex)",
            "Vue Routing",
            "Vue Composition API"
          ]
        },
        {
          "id": "theory_code_splitting_intro",
          "title": "Introduction to Code Splitting",
          "content": "Code splitting is a technique used in modern web development to break down a large JavaScript bundle into smaller, more manageable chunks. Instead of loading an entire application's code at once, code splitting allows for loading parts of the application on demand, improving performance.\n\n### Why Code Splitting?\n\n*   **Improved Initial Load Time**: Users only download the code necessary for the current view, reducing the initial load time of the application.\n*   **Reduced Bandwidth Usage**: Less data needs to be transferred over the network, which is particularly beneficial for users on slower connections or with limited data plans.\n*   **Better Resource Utilization**: Browsers can prioritize loading critical resources, leading to a faster 'time to interactive'.\n*   **Optimized Caching**: Smaller chunks can be cached independently. If only a small part of the application changes, only that chunk needs to be re-downloaded, rather than the entire bundle.\n\nCode splitting is typically achieved using dynamic imports, which allow you to load modules asynchronously. Build tools like Webpack, Rollup, and Parcel support code splitting out of the box.",
          "examples": [
            {
              "id": "example_code_splitting_before_after",
              "title": "Before and After Code Splitting (Conceptual)",
              "code": "// Before code splitting\nimport LargeComponent from './LargeComponent';\n\nfunction App() {\n  return <LargeComponent />;\n}\n\n// After code splitting (conceptual, framework-specific implementations vary)\n// The LargeComponent is only loaded when needed, e.g., when a route is activated.\nconst LargeComponent = () => import('./LargeComponent'); // Dynamic import\n\nfunction App() {\n  // Render LargeComponent only when it's accessed or its route is matched\n  return <SomeWrapperComponent renderOnDemand={LargeComponent} />;\n}",
              "explanation": "The 'Before' example shows a typical static import where `LargeComponent` is bundled with the main application. The 'After' example conceptually illustrates that `LargeComponent` is dynamically imported, meaning its code will be in a separate chunk and loaded only when requested, typically when a specific feature or route is accessed.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_codesplitting_open_1",
            "question_codesplitting_mcq_1",
            "question_codesplitting_flashcard_1"
          ],
          "relatedTasks": [
            "task_react_lazy_loading"
          ],
          "tags": [
            "Code Splitting",
            "Performance Optimization",
            "Webpack",
            "Bundling",
            "Dynamic Import"
          ],
          "technology": "Frontend Architecture",
          "prerequisites": [
            "JavaScript Modules",
            "Webpack basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "Web Performance Optimization",
            "Large Scale Application Architecture"
          ]
        },
        {
          "id": "theory_react_lazy_suspense",
          "title": "Code Splitting in React with `React.lazy` and `Suspense`",
          "content": "React provides built-in mechanisms for code splitting via `React.lazy` and `Suspense`, which work seamlessly with bundlers like Webpack.\n\n### `React.lazy()`\n`React.lazy()` is a function that lets you render a dynamic import as a regular component. It takes a function that returns a Promise, which resolves to a module with a default export containing a React component. The component code is loaded only when it's actually rendered.\n\n### `Suspense` Component\n`Suspense` is a React component that lets you \"wait\" for some code to load and declaratively specify a loading indicator (fallback) while that code is being loaded. It can wrap one or more `React.lazy` components.\n\n#### How it Works Together\nWhen a component loaded with `React.lazy` is rendered, and its code has not yet been loaded, the `Suspense` component renders its `fallback` prop (e.g., a loading spinner or text). Once the component's code is downloaded, `Suspense` renders the actual component.\n\n#### Important Considerations\n*   **SSR (Server-Side Rendering)**: `React.lazy` and `Suspense` are not fully supported for server-side rendering out of the box. Solutions like Loadable Components are often used for SSR with code splitting.\n*   **Error Boundaries**: It's good practice to wrap lazy-loaded components with an Error Boundary to catch any loading failures (e.g., network errors).\n\n#### Example Flow\n1.  Browser requests `App` component.\n2.  `App` renders `Suspense`.\n3.  Inside `Suspense`, `LargeComponent` (lazy-loaded) is encountered.\n4.  If `LargeComponent`'s chunk is not loaded, `Suspense` displays `fallback` (`<div>Loading...</div>`).\n5.  Webpack (or other bundler) initiates loading of `LargeComponent`'s chunk.\n6.  Once loaded, `LargeComponent` renders, and the `fallback` is hidden.",
          "examples": [
            {
              "id": "example_react_lazy_suspense_1",
              "title": "Implementing Code Splitting with React.lazy and Suspense",
              "code": "import React, { Suspense } from 'react';\n// Before code splitting\n// import LargeComponent from './LargeComponent';\n\n// function App() {\n//   return <LargeComponent />;\n// }\n\n// After code splitting with React.lazy\nconst LargeComponent = React.lazy(() => import('./LargeComponent'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <LargeComponent />\n    </Suspense>\n  );\n}",
              "explanation": "This example demonstrates how to use `React.lazy` and `Suspense`. `LargeComponent` is dynamically imported using `React.lazy`. The `Suspense` component wraps `LargeComponent` and displays 'Loading...' as a fallback until `LargeComponent`'s code chunk is downloaded and ready to render.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_lazy_mcq_1",
            "question_react_lazy_open_1",
            "question_react_lazy_flashcard_1",
            "question_react_lazy_code_1"
          ],
          "relatedTasks": [
            "task_react_lazy_loading"
          ],
          "tags": [
            "React",
            "Code Splitting",
            "React.lazy",
            "Suspense",
            "Performance Optimization",
            "Dynamic Import"
          ],
          "technology": "React",
          "prerequisites": [
            "React Components",
            "JavaScript Promises"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "Large Scale React Apps",
            "Optimizing React Performance"
          ]
        },
        {
          "id": "theory_webpack_bundle_analyzer",
          "title": "Webpack Bundle Analyzer for Performance Optimization",
          "content": "The Webpack Bundle Analyzer is a powerful tool that visualizes the contents of your Webpack output bundles in an interactive treemap. It helps developers understand what makes up the size of their bundles, identify large dependencies, and find opportunities for optimization.\n\n### How it Works\nIt creates an HTML file that contains a treemap visualization of your bundle. Each rectangle in the treemap represents a module (a file or a dependency) within your bundle. The size of the rectangle is proportional to the size of the module in the bundle.\n\n### Benefits\n*   **Identify Large Modules**: Quickly pinpoint which modules or third-party libraries are contributing most to your bundle size.\n*   **Detect Duplicates**: Discover if the same library is included multiple times due to different versions or conflicting dependencies.\n*   **Optimize Imports**: See if you are importing entire libraries when only a small part is needed (e.g., importing all of `lodash` instead of `lodash/get`).\n*   **Validate Code Splitting**: Verify that your code splitting strategies are effectively creating smaller chunks and not still including unnecessary code in initial bundles.\n\n### Usage\nIt's typically configured as a Webpack plugin. After running a Webpack build with the plugin enabled, it will generate an HTML report in your build output directory, which opens automatically in your browser.",
          "examples": [
            {
              "id": "example_webpack_bundle_analyzer_config",
              "title": "Webpack Bundle Analyzer Configuration",
              "code": "const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  // ... other webpack configurations\n  plugins: [\n    new BundleAnalyzerPlugin({\n      analyzerMode: 'static', // Generates an HTML file with the report\n      reportFilename: 'bundle-report.html', // Name of the report file\n      openAnalyzer: false, // Don't open the report automatically in the browser\n      logLevel: 'info' // Suppress or show more info logs\n    })\n  ]\n};",
              "explanation": "This code snippet shows how to integrate `webpack-bundle-analyzer` into a Webpack configuration. The `BundleAnalyzerPlugin` is added to the `plugins` array. Setting `analyzerMode: 'static'` generates a standalone HTML report file, `reportFilename` specifies its name, and `openAnalyzer: false` prevents automatic opening.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_webpack_analyzer_open_1",
            "question_webpack_analyzer_mcq_1",
            "question_webpack_analyzer_flashcard_1"
          ],
          "relatedTasks": [
            "task_performance_optimization_analysis"
          ],
          "tags": [
            "Webpack",
            "Performance Optimization",
            "Bundling",
            "Tooling",
            "Developer Tools"
          ],
          "technology": "Webpack",
          "prerequisites": [
            "Webpack basics",
            "NPM/Yarn"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "requiredFor": [
            "Build Process Optimization",
            "Frontend Tooling",
            "Advanced Webpack Configuration"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_react_hooks_1",
          "topic": "React Hooks: `useState`",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `useState` hook in React functional components?",
          "answer": "`useState` allows functional components to manage and update their internal state, enabling re-renders when the state changes.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of core React hooks.",
            "Focuses on the primary utility of `useState`.",
            "Distinguishes functional component capabilities."
          ],
          "keyConcepts": [
            "useState",
            "React Hooks",
            "Functional Components",
            "State Management",
            "Re-rendering"
          ],
          "evaluationCriteria": [
            "Accuracy in defining `useState`'s role.",
            "Conciseness of the explanation."
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useState",
            "Flashcard"
          ],
          "prerequisites": [
            "React basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_mcq_1",
          "topic": "React State Updates",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React component:\n```typescript\nimport React, { useState } from 'react';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n  \n  const handleClick = () => {\n    setCount(count + 1);\n    setCount(count + 1);\n  };\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Increment Twice</button>\n    </div>\n  );\n}\n```\nIf `count` is initially `0`, what will be the value of `count` displayed after clicking the 'Increment Twice' button once?",
          "answer": "1",
          "options": [
            "0",
            "1",
            "2",
            "undefined"
          ],
          "analysisPoints": [
            "Tests understanding of how React batches state updates.",
            "Highlights that `setCount` calls inside the same event handler might use a stale closure over the `count` variable.",
            "Explains the difference between synchronous and asynchronous updates."
          ],
          "keyConcepts": [
            "useState",
            "State Updates",
            "React Batching",
            "Closures"
          ],
          "evaluationCriteria": [
            "Correct understanding of React's update mechanism.",
            "Ability to identify potential pitfalls with `useState`."
          ],
          "example": "The correct answer is **1**. In React, `setCount` calls within the same event loop cycle (like a single `onClick` handler) are often batched for performance. When `handleClick` runs, both `setCount(count + 1)` calls see the `count` variable as its value *at the beginning of the `handleClick` function execution*. So, if `count` is `0`, both calls become `setCount(0 + 1)`, effectively `setCount(1)`. React then applies this `setCount(1)` operation once.",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "MCQ",
            "State Management"
          ],
          "prerequisites": [
            "React Hooks",
            "JavaScript closures"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_open_1",
          "topic": "React State vs. Props",
          "level": "medium",
          "type": "open",
          "question": "Explain the difference between 'state' and 'props' in React components. When would you use one over the other?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "**State**: Internal to a component, managed by the component itself (e.g., using `useState` or `this.state`). It is mutable and changes trigger re-renders. Used for data that can change over time within the component (e.g., form input values, loading status, counter value).",
            "**Props**: External data passed from a parent component to a child component. They are immutable (read-only) for the child component. Used for passing data down the component tree to configure or customize child components.",
            "**When to use**: Use state for data that changes *within* the component. Use props for data that is passed *into* the component from outside, or for configuration.",
            "**Relationship**: State changes in a parent can be passed as props to children, causing children to re-render."
          ],
          "keyConcepts": [
            "State",
            "Props",
            "React Components",
            "Data Flow",
            "Reactivity"
          ],
          "evaluationCriteria": [
            "Clear and accurate definitions of both concepts.",
            "Correct identification of mutability/immutability.",
            "Appropriate use cases for each.",
            "Understanding of data flow in React."
          ],
          "example": null,
          "tags": [
            "React",
            "State Management",
            "Props",
            "Open-Ended"
          ],
          "prerequisites": [
            "React Components"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_flashcard_1",
          "topic": "React Event Handling",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you typically handle events (like `click`) on DOM elements in React JSX?",
          "answer": "You pass a function (event handler) as a prop to the DOM element using camelCase naming (e.g., `onClick`, `onChange`). The function will be executed when the event occurs.",
          "options": [],
          "analysisPoints": [
            "Focuses on basic event handling syntax.",
            "Highlights the camelCase convention in JSX."
          ],
          "keyConcepts": [
            "React Events",
            "JSX",
            "Event Handlers"
          ],
          "evaluationCriteria": [
            "Correctly identifies the syntax for event handling.",
            "Mentions passing a function as a prop."
          ],
          "example": null,
          "tags": [
            "React",
            "Events",
            "JSX",
            "Flashcard"
          ],
          "prerequisites": [
            "React JSX basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_angular_mcq_1",
          "topic": "Angular Component Decorator",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a valid property that can be defined directly within the `@Component` decorator in Angular?",
          "answer": "NgModule",
          "options": [
            "selector",
            "template",
            "styleUrls",
            "NgModule"
          ],
          "analysisPoints": [
            "Tests knowledge of Angular component metadata.",
            "Identifies common properties of `@Component`.",
            "Distinguishes between component-level metadata and module-level organization (`NgModule`)."
          ],
          "keyConcepts": [
            "Angular Components",
            "@Component Decorator",
            "Metadata",
            "NgModule"
          ],
          "evaluationCriteria": [
            "Correctly identifies the invalid option.",
            "Demonstrates understanding of Angular component structure."
          ],
          "example": "The correct answer is **NgModule**. `selector`, `template`, and `styleUrls` are common properties used to configure an Angular component via its `@Component` decorator. `NgModule` is a separate Angular concept used to organize and compile parts of an application, not a property within a component's decorator itself.",
          "tags": [
            "Angular",
            "Components",
            "Decorators",
            "MCQ"
          ],
          "prerequisites": [
            "Angular basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_angular_open_1",
          "topic": "Angular Data Binding",
          "level": "medium",
          "type": "open",
          "question": "Describe the difference between interpolation (`{{ }}`) and event binding (`( )`) in Angular templates. Provide a simple use case for each.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "**Interpolation (`{{ }}`)**: Used for one-way data binding from the component's TypeScript class to the template. It displays the value of a component property as text in the HTML. Example: `{{ userName }}` to display a user's name.",
            "**Event Binding (`( )`)**: Used for one-way data binding from the template (DOM event) to the component's TypeScript class. It executes a component method when a specific DOM event occurs. Example: `(click)=\"submitForm()\"` to call `submitForm` method on button click.",
            "Both facilitate communication but in opposite directions: interpolation pushes data *to* the view, event binding pulls actions *from* the view."
          ],
          "keyConcepts": [
            "Angular Data Binding",
            "Interpolation",
            "Event Binding",
            "One-way Data Flow"
          ],
          "evaluationCriteria": [
            "Accurate definitions for both types of binding.",
            "Clear distinction in data flow direction.",
            "Relevant and correct use cases provided."
          ],
          "example": null,
          "tags": [
            "Angular",
            "Data Binding",
            "Open-Ended"
          ],
          "prerequisites": [
            "Angular templates"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_angular_flashcard_1",
          "topic": "Angular Component Selector",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of the `selector` property in an Angular `@Component` decorator?",
          "answer": "The `selector` defines the CSS selector (e.g., `app-root`, `app-my-component`) that Angular uses to locate and instantiate the component in the HTML.",
          "options": [],
          "analysisPoints": [
            "Tests basic Angular component configuration.",
            "Focuses on how components are used in templates."
          ],
          "keyConcepts": [
            "Angular Component",
            "Selector",
            "@Component Decorator"
          ],
          "evaluationCriteria": [
            "Correctly identifies the role of the selector.",
            "Provides a clear example of its format."
          ],
          "example": null,
          "tags": [
            "Angular",
            "Components",
            "Flashcard"
          ],
          "prerequisites": [
            "Angular basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_angular_code_1",
          "topic": "Angular Component Logic",
          "level": "medium",
          "type": "code",
          "question": "Modify the `CounterComponent` to prevent the count from going below zero. If the user tries to decrement when count is 0, it should remain 0.",
          "answer": "```typescript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-counter',\n  template: `\n    <div>\n      <p>Count: {{count}}</p>\n      <button (click)=\"increment()\">Increment</button>\n      <button (click)=\"decrement()\">Decrement</button>\n    </div>\n  `\n})\nexport class CounterComponent {\n  count = 0;\n  \n  increment() {\n    this.count++;\n  }\n\n  decrement() {\n    if (this.count > 0) {\n      this.count--;\n    }\n  }\n}\n```",
          "options": [],
          "analysisPoints": [
            "Tests ability to add new methods to an Angular component.",
            "Evaluates conditional logic implementation within component methods.",
            "Requires adding a new button and event binding in the template."
          ],
          "keyConcepts": [
            "Angular Component Methods",
            "Conditional Logic",
            "Event Binding",
            "Template Syntax"
          ],
          "evaluationCriteria": [
            "Correct implementation of `decrement` method.",
            "Appropriate conditional check (`this.count > 0`).",
            "Proper addition of new button and event binding in template.",
            "No side effects beyond the requirement."
          ],
          "example": null,
          "tags": [
            "Angular",
            "Components",
            "Coding Challenge",
            "Logic"
          ],
          "prerequisites": [
            "Angular Component Basics",
            "TypeScript"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_vue_mcq_1",
          "topic": "Vue Component Data",
          "level": "medium",
          "type": "mcq",
          "question": "In a Vue Options API component, why is the `data` property typically defined as a function that returns an object, rather than just a plain object?\n\n```javascript\n// Option A\nexport default {\n  data: {\n    message: 'Hello'\n  },\n  // ...\n};\n\n// Option B\nexport default {\n  data() {\n    return {\n      message: 'Hello'\n    };\n  },\n  // ...\n};\n```\nWhich option is the correct and why?",
          "answer": "Option B is correct because it ensures that each component instance gets a fresh, independent copy of the data object, preventing unintended state sharing between instances.",
          "options": [
            "Option A is correct because it's simpler and more direct.",
            "Option B is correct because it makes the data reactive.",
            "Option A is correct because it's a newer syntax for data definition.",
            "Option B is correct because it ensures that each component instance gets a fresh, independent copy of the data object, preventing unintended state sharing between instances."
          ],
          "analysisPoints": [
            "Tests understanding of Vue's reactivity system and component instance isolation.",
            "Highlights a common JavaScript closure/reference issue for objects.",
            "Explains the importance of returning a new object for each instance."
          ],
          "keyConcepts": [
            "Vue Reactivity",
            "Data Function",
            "Component Instances",
            "State Isolation",
            "Options API"
          ],
          "evaluationCriteria": [
            "Correctly identifies Option B as the best practice.",
            "Provides the accurate reason related to instance data isolation."
          ],
          "example": "The correct answer is **Option B**. If `data` were a plain object (Option A), all instances of that component would share the *same* data object by reference. Changes made by one instance would affect all other instances. By defining `data` as a function that returns a *new* object, each component instance gets its own unique data object, ensuring proper state isolation.",
          "tags": [
            "Vue.js",
            "Components",
            "Data Reactivity",
            "MCQ",
            "Options API"
          ],
          "prerequisites": [
            "Vue basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_vue_open_1",
          "topic": "Vue Single File Components (SFCs)",
          "level": "medium",
          "type": "open",
          "question": "What are the main sections of a Vue Single File Component (SFC) and what is the primary purpose of each section?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "**`<template>`**: Defines the component's HTML structure. It must contain a single root element. Purpose: Renders the component's UI.",
            "**`<script>`**: Contains the component's JavaScript logic (data, methods, computed properties, lifecycle hooks). Purpose: Manages component state, behavior, and reactivity.",
            "**`<style>` (Optional)**: Contains the component's CSS. Can be scoped to apply styles only to the current component. Purpose: Styles the component's UI, often with encapsulation."
          ],
          "keyConcepts": [
            "Vue SFC",
            "Template",
            "Script",
            "Style",
            "Component Structure",
            "Encapsulation"
          ],
          "evaluationCriteria": [
            "Correctly identifies all three main sections.",
            "Provides accurate and concise purpose for each section.",
            "Mentions optionality and scoping for `<style>`."
          ],
          "example": null,
          "tags": [
            "Vue.js",
            "SFC",
            "Component Structure",
            "Open-Ended"
          ],
          "prerequisites": [
            "Vue basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_vue_flashcard_1",
          "topic": "Vue Event Handling Syntax",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the shorthand syntax for the `v-on` directive when handling events in Vue templates (e.g., for a click event)?",
          "answer": "The shorthand is `@`. For a click event, you would use `@click=\"methodName\"`.",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of Vue's template syntax.",
            "Focuses on common directives and their shorthands."
          ],
          "keyConcepts": [
            "Vue Events",
            "v-on",
            "Directives",
            "Template Syntax"
          ],
          "evaluationCriteria": [
            "Correctly identifies the `@` shorthand.",
            "Provides a valid example of its usage."
          ],
          "example": null,
          "tags": [
            "Vue.js",
            "Events",
            "Flashcard"
          ],
          "prerequisites": [
            "Vue templates"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_vue_code_1",
          "topic": "Vue Reactive Data",
          "level": "medium",
          "type": "code",
          "question": "Create a Vue component that displays a message and has a button to toggle its visibility. The message should initially be visible.",
          "answer": "<template>\n  <div>\n    <p v-if=\"isVisible\">Hello Vue!</p>\n    <button @click=\"toggleVisibility\">Toggle Message</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      isVisible: true\n    };\n  },\n  methods: {\n    toggleVisibility() {\n      this.isVisible = !this.isVisible;\n    }\n  }\n};\n</script>",
          "options": [],
          "analysisPoints": [
            "Tests ability to define reactive data (`isVisible`).",
            "Evaluates implementation of a method to change data (`toggleVisibility`).",
            "Requires use of a conditional rendering directive (`v-if`).",
            "Requires correct event binding (`@click`)."
          ],
          "keyConcepts": [
            "Vue Data",
            "Vue Methods",
            "Reactivity",
            "Conditional Rendering",
            "v-if",
            "Event Handling"
          ],
          "evaluationCriteria": [
            "Correct setup of `data` property.",
            "Proper implementation of `toggleVisibility` method.",
            "Effective use of `v-if` for conditional rendering.",
            "Correct event binding for the button."
          ],
          "example": null,
          "tags": [
            "Vue.js",
            "Components",
            "Coding Challenge",
            "Reactivity"
          ],
          "prerequisites": [
            "Vue Component Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_codesplitting_open_1",
          "topic": "Benefits of Code Splitting",
          "level": "medium",
          "type": "open",
          "question": "List and explain at least three significant benefits of implementing code splitting in a large-scale frontend application.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "**Improved Initial Load Time**: By loading only the essential code for the current view, the initial bundle size is reduced, leading to faster page load and Time To Interactive (TTI).",
            "**Reduced Bandwidth Usage**: Less data is transferred over the network, which benefits users with limited data plans or slow internet connections.",
            "**Optimized Caching**: Smaller, independent chunks can be cached separately. If a change occurs in one part of the application, only the affected chunk needs to be re-downloaded, rather than the entire large bundle.",
            "**Better Resource Utilization**: Allows the browser to parse and execute smaller JavaScript files more efficiently, preventing performance bottlenecks associated with very large scripts.",
            "**Better User Experience**: Faster loads and more responsive interactions lead to a better overall user experience, reducing abandonment rates."
          ],
          "keyConcepts": [
            "Code Splitting",
            "Performance Optimization",
            "Bundle Size",
            "Load Time",
            "Caching",
            "Bandwidth"
          ],
          "evaluationCriteria": [
            "Identifies at least three distinct benefits.",
            "Provides clear and concise explanations for each benefit.",
            "Demonstrates understanding of the practical implications of code splitting."
          ],
          "example": null,
          "tags": [
            "Code Splitting",
            "Performance",
            "Optimization",
            "Open-Ended"
          ],
          "prerequisites": [
            "Web Development Fundamentals"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_codesplitting_mcq_1",
          "topic": "Code Splitting Implementation",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following JavaScript features is commonly used by modern bundlers (like Webpack) to enable code splitting?",
          "answer": "Dynamic `import()`",
          "options": [
            "`require()` statements",
            "Static `import` statements",
            "Dynamic `import()`",
            "`<script defer>` tags"
          ],
          "analysisPoints": [
            "Tests knowledge of the underlying mechanism for code splitting.",
            "Distinguishes between static and dynamic module loading.",
            "Connects a JavaScript feature to a build tool capability."
          ],
          "keyConcepts": [
            "Code Splitting",
            "Dynamic Import",
            "Webpack",
            "Modules"
          ],
          "evaluationCriteria": [
            "Correctly identifies `import()` as the key feature.",
            "Understands the distinction from static imports."
          ],
          "example": "The correct answer is **Dynamic `import()`**. While static `import` statements declare dependencies upfront, dynamic `import()` (a standard JavaScript feature) allows modules to be loaded asynchronously, on demand. Bundlers leverage this syntax to create separate JavaScript chunks for the dynamically imported modules.",
          "tags": [
            "Code Splitting",
            "JavaScript",
            "Modules",
            "MCQ"
          ],
          "prerequisites": [
            "JavaScript Modules"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_codesplitting_flashcard_1",
          "topic": "Code Splitting Core Idea",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the core idea behind 'code splitting' in web development?",
          "answer": "The core idea is to break a large JavaScript bundle into smaller, independently loadable chunks, allowing parts of the application to be loaded on demand instead of all at once.",
          "options": [],
          "analysisPoints": [
            "Focuses on the fundamental concept.",
            "Highlights the 'on-demand' aspect."
          ],
          "keyConcepts": [
            "Code Splitting",
            "Bundling",
            "Performance"
          ],
          "evaluationCriteria": [
            "Accurate and concise definition.",
            "Captures the essence of the technique."
          ],
          "example": null,
          "tags": [
            "Code Splitting",
            "Performance",
            "Flashcard"
          ],
          "prerequisites": [
            "Web basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_lazy_mcq_1",
          "topic": "React.lazy and Suspense",
          "level": "medium",
          "type": "mcq",
          "question": "Which statement best describes the relationship between `React.lazy` and `Suspense` when implementing code splitting in React?",
          "answer": "`React.lazy` defines a dynamically loaded component, while `Suspense` provides a fallback UI to display until that component's code is loaded.",
          "options": [
            "`React.lazy` is used for server-side rendering, and `Suspense` manages data fetching.",
            "`React.lazy` is an alternative to `useState`, and `Suspense` handles component lifecycle.",
            "`React.lazy` defines a dynamically loaded component, while `Suspense` provides a fallback UI to display until that component's code is loaded.",
            "`Suspense` is a higher-order component that wraps `React.lazy` for error handling."
          ],
          "analysisPoints": [
            "Tests understanding of the specific roles of `React.lazy` and `Suspense`.",
            "Distinguishes their functions in the context of code splitting.",
            "Discounts common misconceptions about their usage."
          ],
          "keyConcepts": [
            "React.lazy",
            "Suspense",
            "Code Splitting",
            "Dynamic Import",
            "Fallback UI"
          ],
          "evaluationCriteria": [
            "Accurate description of both `React.lazy` and `Suspense` roles.",
            "Correctly identifies their complementary nature for code splitting."
          ],
          "example": "The correct answer is **`React.lazy` defines a dynamically loaded component, while `Suspense` provides a fallback UI to display until that component's code is loaded.** `React.lazy` marks a component for dynamic loading via dynamic `import()`. `Suspense` is then needed to wrap the `lazy`-loaded component and define what React should render (the `fallback`) while the component's chunk is being fetched.",
          "tags": [
            "React",
            "Code Splitting",
            "React.lazy",
            "Suspense",
            "MCQ"
          ],
          "prerequisites": [
            "React Components",
            "Code Splitting"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_lazy_open_1",
          "topic": "React.lazy SSR Limitations",
          "level": "hard",
          "type": "open",
          "question": "Discuss a significant limitation of using `React.lazy` and `Suspense` in applications that require Server-Side Rendering (SSR). How are these limitations typically addressed?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "**Limitation**: `React.lazy` and `Suspense` are primarily designed for client-side rendering. During SSR, the server needs to render the complete HTML before sending it to the client. When a `lazy`-loaded component is encountered on the server, its code isn't immediately available, leading to a hydration mismatch or an incomplete initial render.",
            "The server doesn't know what components need to be loaded asynchronously on the client, and `Suspense`'s `fallback` mechanism is not suitable for server-side rendering the final content.",
            "**Addressing Limitations**: This is typically addressed by using **SSR-aware code splitting solutions** like `Loadable Components` or React's experimental `Suspense for SSR` (which requires a compatible server-side rendering environment and React 18+ streaming APIs). These solutions collect information about dynamically loaded components during the server render pass and ensure their code is bundled and delivered correctly for the initial HTML, preventing hydration issues."
          ],
          "keyConcepts": [
            "React.lazy",
            "Suspense",
            "SSR",
            "Hydration",
            "Code Splitting",
            "Loadable Components"
          ],
          "evaluationCriteria": [
            "Clearly identifies the SSR limitation (hydration mismatch, incomplete render).",
            "Explains *why* it's a limitation (server doesn't know about dynamic imports).",
            "Proposes standard solutions (`Loadable Components`, React 18+ SSR features).",
            "Demonstrates advanced understanding of React rendering paradigms."
          ],
          "example": null,
          "tags": [
            "React",
            "Code Splitting",
            "SSR",
            "Performance",
            "Advanced",
            "Open-Ended"
          ],
          "prerequisites": [
            "React.lazy/Suspense",
            "SSR concepts"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_lazy_flashcard_1",
          "topic": "React Suspense Fallback",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of the `fallback` prop in the React `Suspense` component?",
          "answer": "The `fallback` prop in `Suspense` is used to define the UI (e.g., a loading spinner, text) that will be displayed while the lazy-loaded component (or any suspended content) is loading.",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of `Suspense` configuration.",
            "Focuses on its role in user experience during loading."
          ],
          "keyConcepts": [
            "React Suspense",
            "Fallback UI",
            "Loading State",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Accurate description of the `fallback` prop's function.",
            "Provides examples of what it displays."
          ],
          "example": null,
          "tags": [
            "React",
            "Suspense",
            "Flashcard"
          ],
          "prerequisites": [
            "React.lazy"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_lazy_code_1",
          "topic": "Implement Route-Based Lazy Loading",
          "level": "medium",
          "type": "code",
          "question": "Using React.lazy and Suspense, implement a simple router that lazy-loads two different components (`HomePage` and `AboutPage`) based on a URL path. Display 'Loading...' while components are being fetched. Assume `HomePage.js` and `AboutPage.js` exist as default exports of simple functional components.\n\n```typescript\nimport React, { Suspense } from 'react';\n\n// Assume these components exist in separate files:\n// export default function HomePage() { return <h2>Home Page</h2>; }\n// export default function AboutPage() { return <h2>About Page</h2>; }\n\nconst App = () => {\n  // Simulate a simple routing mechanism\n  const path = window.location.pathname;\n\n  return (\n    <div>\n      <h1>My App</h1>\n      <nav>\n        <a href=\"/\">Home</a> | <a href=\"/about\">About</a>\n      </nav>\n      {/* Your implementation here */}\n    </div>\n  );\n};\n\nexport default App;\n```",
          "answer": "```typescript\nimport React, { Suspense, lazy } from 'react';\n\n// Assume these components exist in separate files:\n// export default function HomePage() { return <h2>Home Page</h2>; }\n// export default function AboutPage() { return <h2>About Page</h2>; }\n\nconst HomePage = lazy(() => import('./HomePage'));\nconst AboutPage = lazy(() => import('./AboutPage'));\n\nconst App = () => {\n  // Simulate a simple routing mechanism\n  const path = window.location.pathname;\n\n  let ComponentToRender = null;\n  if (path === '/') {\n    ComponentToRender = HomePage;\n  } else if (path === '/about') {\n    ComponentToRender = AboutPage;\n  }\n\n  return (\n    <div>\n      <h1>My App</h1>\n      <nav>\n        <a href=\"/\">Home</a> | <a href=\"/about\">About</a>\n      </nav>\n      <Suspense fallback={<div>Loading...</div>}>\n        {ComponentToRender ? <ComponentToRender /> : <div>Page not found</div>}\n      </Suspense>\n    </div>\n  );\n};\n\nexport default App;\n```",
          "options": [],
          "analysisPoints": [
            "Tests proper usage of `lazy` for dynamic imports.",
            "Evaluates the wrapping of `lazy` components with `Suspense`.",
            "Checks for correct `fallback` prop usage.",
            "Requires basic conditional rendering based on a 'route'."
          ],
          "keyConcepts": [
            "React.lazy",
            "Suspense",
            "Code Splitting",
            "Routing",
            "Dynamic Import",
            "Conditional Rendering"
          ],
          "evaluationCriteria": [
            "Correctly defines lazy-loaded components.",
            "Wraps the rendering logic in `Suspense`.",
            "Provides a valid `fallback` UI.",
            "Properly renders the selected component based on `path`."
          ],
          "example": null,
          "tags": [
            "React",
            "Code Splitting",
            "Routing",
            "Coding Challenge",
            "Performance"
          ],
          "prerequisites": [
            "React.lazy/Suspense basics",
            "JavaScript conditional logic"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_webpack_analyzer_open_1",
          "topic": "Webpack Bundle Analyzer Use Cases",
          "level": "medium",
          "type": "open",
          "question": "You notice your application's initial load time is slow. How can the Webpack Bundle Analyzer assist you in diagnosing and addressing this performance issue?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "**Visualization**: It provides an interactive treemap visualization of the bundle content, showing the size of each module and dependency.",
            "**Identifying Large Dependencies**: Allows quick identification of large third-party libraries or internal modules contributing significantly to the bundle size.",
            "**Detecting Duplicates**: Helps spot if multiple versions of the same library, or the same library multiple times, are included in the bundle.",
            "**Optimizing Imports (Tree Shaking)**: Reveals if entire libraries are being included when only a small portion is used (e.g., if tree shaking is not effective).",
            "**Validating Code Splitting**: Shows if code splitting is working as intended and if lazy-loaded chunks are indeed separate, or if critical paths are still too large.",
            "**Guidance for Optimization**: Provides data to make informed decisions on what to optimize: replacing large libraries, fine-tuning imports, or adjusting code splitting points."
          ],
          "keyConcepts": [
            "Webpack Bundle Analyzer",
            "Performance Optimization",
            "Bundle Size",
            "Tree Shaking",
            "Code Splitting",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Clearly explains the tool's core function.",
            "Lists multiple actionable ways the tool helps.",
            "Connects the tool's features to specific performance bottlenecks.",
            "Demonstrates practical understanding of performance debugging."
          ],
          "example": null,
          "tags": [
            "Webpack",
            "Performance",
            "Optimization",
            "Tooling",
            "Open-Ended"
          ],
          "prerequisites": [
            "Webpack basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_webpack_analyzer_mcq_1",
          "topic": "Webpack Bundle Analyzer Output",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary visual output of the Webpack Bundle Analyzer that helps identify large dependencies?",
          "answer": "An interactive treemap visualization",
          "options": [
            "A console log of file sizes",
            "A CSV file listing all modules",
            "An interactive treemap visualization",
            "A network waterfall chart"
          ],
          "analysisPoints": [
            "Tests knowledge of the specific visualization provided by the tool.",
            "Distinguishes it from other types of performance reports."
          ],
          "keyConcepts": [
            "Webpack Bundle Analyzer",
            "Visualization",
            "Bundle Size"
          ],
          "evaluationCriteria": [
            "Correctly identifies the treemap as the primary output.",
            "Demonstrates familiarity with the tool's interface."
          ],
          "example": "The correct answer is **An interactive treemap visualization**. The Webpack Bundle Analyzer generates an HTML file containing a treemap where the size of each colored rectangle represents the relative size of a module or dependency within your JavaScript bundles. This visual representation makes it easy to spot the largest contributors.",
          "tags": [
            "Webpack",
            "Performance",
            "Tooling",
            "MCQ"
          ],
          "prerequisites": [
            "Webpack basics"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_webpack_analyzer_flashcard_1",
          "topic": "Webpack Bundle Analyzer Purpose",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main goal of using the Webpack Bundle Analyzer?",
          "answer": "To visualize the contents of Webpack output bundles and identify which modules are contributing most to the bundle size, helping optimize performance.",
          "options": [],
          "analysisPoints": [
            "Focuses on the tool's core utility.",
            "Highlights its connection to bundle size and optimization."
          ],
          "keyConcepts": [
            "Webpack Bundle Analyzer",
            "Bundle Size",
            "Optimization"
          ],
          "evaluationCriteria": [
            "Accurate and concise statement of purpose.",
            "Mentions both visualization and optimization."
          ],
          "example": null,
          "tags": [
            "Webpack",
            "Performance",
            "Tooling",
            "Flashcard"
          ],
          "prerequisites": [
            "Webpack basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_react_simple_counter",
          "title": "React: Enhanced Counter with Reset and Max Limit",
          "description": "\nImplement a React functional component that functions as a counter. \n\n1.  **Display Count**: Show the current count.\n2.  **Increment Button**: A button to increment the count by 1.\n3.  **Decrement Button**: A button to decrement the count by 1. The count should not go below 0.\n4.  **Reset Button**: A button to reset the count to its initial value (0).\n5.  **Max Limit**: The count should not exceed 10. If an increment operation would push it above 10, it should remain at 10.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  // Implement increment, decrement, reset logic here\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      {/* Add your buttons here */}\n    </div>\n  );\n}\n\nexport default Counter;",
          "solutionCode": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const MAX_COUNT = 10;\n\n  const increment = () => {\n    setCount(prevCount => Math.min(prevCount + 1, MAX_COUNT));\n  };\n\n  const decrement = () => {\n    setCount(prevCount => Math.max(prevCount - 1, 0));\n  };\n\n  const reset = () => {\n    setCount(0);\n  };\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment} disabled={count === MAX_COUNT}>Increment</button>\n      <button onClick={decrement} disabled={count === 0}>Decrement</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}\n\nexport default Counter;",
          "testCases": [
            "Initial render: Count should be 0.",
            "Increment once: Count should be 1.",
            "Increment multiple times: Count should increase accordingly.",
            "Decrement once: Count should be -1 if no lower bound, 0 if lower bound is 0.",
            "Decrement below 0: Count should remain 0.",
            "Increment above 10: Count should remain 10.",
            "Click Reset: Count should return to 0 from any value."
          ],
          "hints": [
            "Use multiple `useState` calls if you need separate pieces of state, or derive state from a single `count` variable.",
            "For increment/decrement, consider using the functional update form of `setCount` (`setCount(prevCount => ...)`) to avoid stale closures, especially if updates are batched.",
            "Use conditional rendering or `disabled` prop on buttons based on current `count` value to enhance UX."
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "State Management",
            "Functional Components",
            "Frontend Interview"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React useState",
            "JavaScript Math functions"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "React Event Handling",
            "Conditional Logic in JSX"
          ]
        },
        {
          "id": "task_angular_data_binding",
          "title": "Angular: Dynamic Text Display and Input Handling",
          "description": "\nCreate an Angular component that demonstrates various data binding techniques.\n\n1.  **Display Greeting**: Show a default greeting message (e.g., \"Hello, Angular!\") using interpolation.\n2.  **Input Field**: Add an `<input type=\"text\">` element.\n3.  **Two-way Binding**: Use two-way data binding (`ngModel`) to connect the input field's value to a component property (e.g., `userName`).\n4.  **Display User Name**: Update the greeting message to include the `userName` as the user types (e.g., \"Hello, [UserName]!\"). If the `userName` is empty, revert to the default greeting.\n5.  **Button Action**: Add a button that, when clicked, clears the `userName` and reverts the greeting to default.\n\n**Note**: You might need to import `FormsModule` in your `AppModule` to use `ngModel`.\n",
          "difficulty": "medium",
          "startingCode": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-greeting',\n  template: `\n    <div>\n      <!-- Your template code here -->\n    </div>\n  `,\n  styles: []\n})\nexport class GreetingComponent {\n  defaultGreeting = 'Hello, Angular!';\n  userName = ''; // This property should be bound to the input\n\n  // Implement methods here\n}\n",
          "solutionCode": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-greeting',\n  template: `\n    <div>\n      <h2>{{ displayGreeting() }}</h2>\n      <input type=\"text\" [(ngModel)]=\"userName\" placeholder=\"Enter your name\">\n      <button (click)=\"clearName()\">Clear Name</button>\n    </div>\n  `,\n  styles: []\n})\nexport class GreetingComponent {\n  defaultGreeting = 'Hello, Angular!';\n  userName = '';\n\n  displayGreeting(): string {\n    return this.userName ? `Hello, ${this.userName}!` : this.defaultGreeting;\n  }\n\n  clearName(): void {\n    this.userName = '';\n  }\n}\n",
          "testCases": [
            "Initial render: Greeting should be 'Hello, Angular!'. Input should be empty.",
            "Typing 'Alice' in input: Greeting should change to 'Hello, Alice!'.",
            "Clearing input: Greeting should revert to 'Hello, Angular!'.",
            "Clicking 'Clear Name' button after typing: Input should clear, greeting should revert to default."
          ],
          "hints": [
            "Remember to enable `FormsModule` in `AppModule` to use `[(ngModel)]`.",
            "You can use a getter method or a simple conditional (`this.userName ? ... : ...`) in the template for the dynamic greeting.",
            "Ensure `clearName()` method correctly resets the `userName` property."
          ],
          "tags": [
            "Angular",
            "Components",
            "Data Binding",
            "ngModel",
            "Frontend Interview"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Angular Component Basics",
            "TypeScript basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Angular Modules",
            "Event Binding",
            "Interpolation"
          ]
        },
        {
          "id": "task_vue_todo_list",
          "title": "Vue: Simple Todo List with Add and Remove Functionality",
          "description": "\nBuild a basic Todo List Vue component using the Options API.\n\n1.  **Display Todos**: Show a list of existing todo items. Each todo item should display its text and have a 'Remove' button next to it.\n2.  **Add Todo**: An input field and an 'Add Todo' button to add new items to the list.\n3.  **Remove Todo**: The 'Remove' button next to each todo item should delete that item from the list.\n4.  **Empty State**: If there are no todo items, display a message like \"No todos yet!\".\n\nInitial todos can be an empty array or a few sample items.\n",
          "difficulty": "medium",
          "startingCode": "<template>\n  <div>\n    <h2>My Todo List</h2>\n    <!-- Input and Add button here -->\n    \n    <!-- Todo list and No todos message here -->\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      newTodoText: '',\n      todos: [] // or [{ id: 1, text: 'Learn Vue' }] for initial data\n    };\n  },\n  methods: {\n    // Implement addTodo and removeTodo here\n  }\n};\n</script>",
          "solutionCode": "<template>\n  <div>\n    <h2>My Todo List</h2>\n    <input type=\"text\" v-model=\"newTodoText\" @keyup.enter=\"addTodo\" placeholder=\"Add a new todo\">\n    <button @click=\"addTodo\">Add Todo</button>\n\n    <p v-if=\"todos.length === 0\">No todos yet!</p>\n\n    <ul v-else>\n      <li v-for=\"todo in todos\" :key=\"todo.id\">\n        {{ todo.text }}\n        <button @click=\"removeTodo(todo.id)\">Remove</button>\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      newTodoText: '',\n      todos: []\n    };\n  },\n  methods: {\n    addTodo() {\n      if (this.newTodoText.trim() === '') return;\n      this.todos.push({\n        id: Date.now(), // Simple unique ID\n        text: this.newTodoText.trim()\n      });\n      this.newTodoText = ''; // Clear input\n    },\n    removeTodo(id) {\n      this.todos = this.todos.filter(todo => todo.id !== id);\n    }\n  }\n};\n</script>",
          "testCases": [
            "Initial render: 'No todos yet!' message should be visible.",
            "Add a todo: Type 'Buy milk', click 'Add'. List should show 'Buy milk'. Input should clear.",
            "Add another todo: Type 'Walk dog', click 'Add'. List should show both items.",
            "Remove a todo: Click 'Remove' next to 'Buy milk'. Only 'Walk dog' should remain.",
            "Remove last todo: Click 'Remove' for 'Walk dog'. 'No todos yet!' should reappear."
          ],
          "hints": [
            "Use `v-model` for two-way data binding on the input field.",
            "Use `v-for` to render the list of todos and ensure you provide a `:key` for list items.",
            "Implement `addTodo` to push new items to the `todos` array and `removeTodo` to filter items out.",
            "Consider using `v-if` and `v-else` for the 'No todos yet!' message.",
            "You can use `Date.now()` or a simple counter for unique IDs."
          ],
          "tags": [
            "Vue.js",
            "Components",
            "Data Reactivity",
            "v-model",
            "v-for",
            "Event Handling",
            "Frontend Interview"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Vue Component Basics",
            "JavaScript Array methods"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Vue Directives",
            "List Rendering",
            "Conditional Rendering"
          ]
        },
        {
          "id": "task_react_lazy_loading",
          "title": "React: Route-Based Lazy Loading with Authentication Guard",
          "description": "\nImplement a React application using `React.lazy` and `Suspense` for route-based code splitting. Additionally, add a simple authentication guard.\n\n1.  **Homepage (`/`)**: Always accessible, static content.\n2.  **Dashboard Page (`/dashboard`)**: Only accessible if `isAuthenticated` is true. If not authenticated, redirect to the login page (`/login`).\n3.  **Login Page (`/login`)**: Simple form with a button to toggle `isAuthenticated` state.\n4.  **Lazy Loading**: The `DashboardPage` and `LoginPage` should be lazy-loaded.\n5.  **Suspense Fallback**: Display a 'Loading...' message while lazy components are loading.\n\nAssume a global `isAuthenticated` state managed by `useState` in `App` for simplicity. Use `react-router-dom` for routing.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, Suspense, lazy } from 'react';\nimport { BrowserRouter as Router, Route, Routes, Link, Navigate } from 'react-router-dom';\n\nconst HomePage = () => <h2>Welcome Home!</h2>;\n\n// Lazy load DashboardPage and LoginPage here\n\nconst App = () => {\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n  const handleLoginToggle = () => {\n    setIsAuthenticated(prev => !prev);\n  };\n\n  return (\n    <Router>\n      <nav>\n        <Link to=\"/\">Home</Link> |\n        <Link to=\"/dashboard\">Dashboard</Link> |\n        <Link to=\"/login\">Login</Link>\n        <button onClick={handleLoginToggle}>\n          {isAuthenticated ? 'Logout' : 'Login'}\n        </button>\n      </nav>\n      <hr />\n      <Suspense fallback={<div>Loading...</div>}>\n        <Routes>\n          <Route path=\"/\" element={<HomePage />} />\n          {/* Implement protected route and login route here */}\n        </Routes>\n      </Suspense>\n    </Router>\n  );\n};\n\nexport default App;",
          "solutionCode": "import React, { useState, Suspense, lazy } from 'react';\nimport { BrowserRouter as Router, Route, Routes, Link, Navigate, Outlet } from 'react-router-dom';\n\nconst HomePage = () => <h2>Welcome Home!</h2>;\nconst DashboardPage = lazy(() => import('./DashboardPage')); // Assume DashboardPage.js exists\nconst LoginPage = lazy(() => import('./LoginPage')); // Assume LoginPage.js exists\n\n// Example content for DashboardPage.js\n// export default function DashboardPage() { return <h2>Dashboard Content</h2>; }\n\n// Example content for LoginPage.js\n// export default function LoginPage() { return <h2>Login Form</h2>; }\n\nconst ProtectedRoute = ({ isAuthenticated, redirectPath = '/login' }) => {\n  if (!isAuthenticated) {\n    return <Navigate to={redirectPath} replace />;\n  }\n  return <Outlet />;\n};\n\nconst App = () => {\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n  const handleLoginToggle = () => {\n    setIsAuthenticated(prev => !prev);\n  };\n\n  return (\n    <Router>\n      <nav>\n        <Link to=\"/\">Home</Link> |\n        <Link to=\"/dashboard\">Dashboard</Link> |\n        <Link to=\"/login\">Login</Link>\n        <button onClick={handleLoginToggle}>\n          {isAuthenticated ? 'Logout' : 'Login'}\n        </button>\n        <p>Status: {isAuthenticated ? 'Logged In' : 'Logged Out'}</p>\n      </nav>\n      <hr />\n      <Suspense fallback={<div>Loading...</div>}>\n        <Routes>\n          <Route path=\"/\" element={<HomePage />} />\n          <Route path=\"/login\" element={<LoginPage />} />\n          \n          {/* Protected Route */}\n          <Route element={<ProtectedRoute isAuthenticated={isAuthenticated} />}>\n            <Route path=\"/dashboard\" element={<DashboardPage />} />\n          </Route>\n        </Routes>\n      </Suspense>\n    </Router>\n  );\n};\n\nexport default App;",
          "testCases": [
            "Initial Load (`/`): HomePage should be visible, Dashboard and Login components should not be loaded.",
            "Navigate to `/login`: LoginPage should load and display, isAuthenticated should be false.",
            "Click Login/Logout button: isAuthenticated state should toggle.",
            "Navigate to `/dashboard` (logged out): Should redirect to `/login`.",
            "Navigate to `/dashboard` (logged in): DashboardPage should lazy-load and display.",
            "Observe network requests: Verify that `DashboardPage` and `LoginPage` chunks are only loaded when navigated to (and not on initial app load)."
          ],
          "hints": [
            "Define `DashboardPage` and `LoginPage` using `React.lazy(() => import('./path/to/Component'))`.",
            "Wrap the `Routes` component with `Suspense` to provide a loading fallback.",
            "For the authentication guard, you can create a wrapper component (`ProtectedRoute`) that checks `isAuthenticated` and uses `Navigate` from `react-router-dom` to redirect.",
            "Make sure to set up your `package.json` to include `react-router-dom`."
          ],
          "tags": [
            "React",
            "Code Splitting",
            "React.lazy",
            "Suspense",
            "Routing",
            "Authentication",
            "Frontend Interview"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React Hooks",
            "React Router",
            "Code Splitting Concepts"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "SPA Architecture",
            "Conditional Rendering",
            "Performance Optimization"
          ]
        },
        {
          "id": "task_performance_optimization_analysis",
          "title": "Performance: Analyze Bundle & Suggest Optimizations",
          "description": "\nGiven a scenario where a large React application has slow initial load times, your task is to outline a strategy for using `webpack-bundle-analyzer` and other techniques to identify and address the performance issues. You do not need to write code for the analysis tool itself, but explain how you would use its output.\n\n**Scenario**: A React single-page application built with Webpack contains many features and third-party libraries. Users report long loading screens when they first visit the site. You suspect the main JavaScript bundle is too large.\n\n**Your Task**: Describe a step-by-step process you would follow to diagnose and optimize the bundle size. Include:\n\n1.  **Tool Setup**: How would you enable/run `webpack-bundle-analyzer`?\n2.  **Analysis**: What specific information would you look for in the analyzer's report?\n3.  **Optimization Strategies**: Based on the insights, what actionable steps would you take to reduce the bundle size and improve load times? Provide at least three distinct strategies.\n4.  **Verification**: How would you confirm your optimizations were successful?\n",
          "difficulty": "hard",
          "startingCode": "/* No starting code needed, this is a conceptual task. */",
          "solutionCode": "## Solution: Bundle Analysis and Optimization Strategy\n\n**1. Tool Setup:**\nTo enable `webpack-bundle-analyzer`, I would first install it as a development dependency:\n```bash\nnpm install --save-dev webpack-bundle-analyzer\n# or\nyarn add --dev webpack-bundle-analyzer\n```\nThen, I would add it to the `plugins` array in the `webpack.config.js`:\n```javascript\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  // ... other webpack config\n  plugins: [\n    new BundleAnalyzerPlugin({\n      analyzerMode: 'static', // Generates an HTML file, useful for CI/CD\n      reportFilename: 'bundle-report.html', // Output file name\n      openAnalyzer: false // Prevent opening automatically, useful for CI/CD or specific script\n    })\n  ],\n};\n```\nFinally, I would run a production build of the application (e.g., `npm run build`), which would generate the `bundle-report.html` file in the output directory. I would then open this HTML file in a browser.\n\n**2. Analysis (What to Look For in the Report):**\nUpon opening the interactive treemap report, I would focus on the following:\n*   **Largest Rectangles (Modules/Dependencies)**: Immediately identify the largest blocks, which represent the biggest contributors to the bundle size. This helps prioritize optimization efforts.\n*   **Duplicate Dependencies**: Look for multiple instances of the same library (e.g., different versions of `lodash` or `moment`) that could be resolved by configuring Webpack's `resolve.alias` or `optimization.splitChunks`.\n*   **Unused Code (Dead Code)**: While the analyzer itself doesn't directly show unused code, very large components or libraries that are rarely used could indicate poor tree-shaking effectiveness or unnecessary imports.\n*   **Shared Dependencies**: Identify modules that are included in multiple chunks, which might be candidates for further `splitChunks` configuration.\n\n**3. Optimization Strategies:**\nBased on the analysis, I would employ a combination of these strategies:\n*   **A. Code Splitting (Route/Component-Based)**: If the analyzer shows that entire feature modules or pages are bundled into the initial chunk, I would implement `React.lazy` and `Suspense` (or dynamic `import()` for non-React contexts) to lazy-load these components only when they are needed (e.g., when a user navigates to a specific route). This significantly reduces the initial payload.\n    *   *Example*: `const AdminDashboard = React.lazy(() => import('./AdminDashboard'));`\n*   **B. Tree Shaking & Smaller Imports**: For large third-party libraries, I would ensure effective tree shaking is enabled (Webpack does this by default for ES Modules in production). More importantly, I would switch from importing entire libraries (e.g., `import { Button } from 'antd';` instead of `import Antd from 'antd';`) or use specific utility imports (e.g., `import get from 'lodash/get';` instead of `import _ from 'lodash';`). If a library doesn't support tree shaking, I'd consider alternatives.\n*   **C. Dependency Optimization / Deduplication**: If duplicate libraries are found, I'd explicitly set up Webpack's `resolve.alias` or `optimization.splitChunks.cacheGroups` to ensure only one version of a library is bundled, or that common vendor code is extracted into its own cacheable chunk, preventing repetition across multiple bundles.\n*   **D. Image Optimization**: While not directly shown in JS bundles, large images are common culprits. I would use image optimization tools (Webpack loaders like `image-webpack-loader` or external services) to compress and serve appropriately sized images.\n\n**4. Verification:**\nAfter implementing optimizations, I would verify their effectiveness by:\n*   **Re-running Webpack Bundle Analyzer**: Generate a new report and visually compare it with the previous one. I would expect to see smaller rectangle sizes for optimized modules/dependencies and potentially new, smaller chunks for lazy-loaded code.\n*   **Performance Metrics (Lighthouse/WebPageTest)**: Use tools like Google Lighthouse (in Chrome DevTools) or WebPageTest to measure key performance metrics (First Contentful Paint, Largest Contentful Paint, Time to Interactive, Total Blocking Time) before and after optimizations. I'd specifically look for improvements in 'Time to Interactive' and 'Total Blocking Time' as these are directly impacted by JavaScript bundle size.",
          "testCases": [
            "The strategy should clearly outline how to set up the analyzer.",
            "The strategy should identify specific types of issues visible in the analyzer's output (e.g., large modules, duplicates).",
            "At least three distinct, actionable optimization strategies should be proposed, explaining how they address identified issues.",
            "A clear method for verifying the success of optimizations should be described (re-analysis, performance metrics)."
          ],
          "hints": [
            "Think about what a treemap visually represents regarding file sizes.",
            "Consider common causes of large JavaScript bundles beyond just application code.",
            "How do `import()` statements relate to Webpack's chunking?",
            "What performance metrics are most relevant when optimizing bundle size?"
          ],
          "tags": [
            "Webpack",
            "Performance Optimization",
            "Bundle Analysis",
            "Code Splitting",
            "Tree Shaking",
            "Frontend Interview",
            "Architecture"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "Webpack Configuration",
            "Code Splitting Concepts",
            "General Web Performance knowledge"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "expert",
          "relatedConcepts": [
            "Web Performance Metrics",
            "CI/CD Integration",
            "Build Tools"
          ]
        }
      ]
    }
  },
  {
    "id": "e508a269-88ad-4265-86f3-d0e691df2ddf",
    "startLine": 12300,
    "endLine": 12399,
    "processedDate": "2025-06-17T12:51:27.624Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_bundle_analyzer_plugin",
          "title": "Webpack Bundle Analyzer Plugin",
          "content": "The Webpack Bundle Analyzer is a powerful tool for visualizing the size of webpack output files with an interactive treemap. It helps developers understand what makes up the bundle size, identify large modules or dependencies, and pinpoint areas for optimization.\n\n## Key Concepts\n*   **Bundle Visualization:** Provides a graphical representation of your webpack bundle, showing the size of each module and dependency.\n*   **Interactive Treemap:** Allows for detailed exploration of bundle content, enabling drill-down into specific sections.\n*   **Optimization Insights:** Helps in identifying duplicate modules, large libraries, or unused code that might be contributing to a bloated bundle.\n\n## Installation\n```bash\nnpm install --save-dev webpack-bundle-analyzer\n```\n\n## Usage\nTo use the plugin, import it and add it to the `plugins` array in your `webpack.config.js` file, typically within the `plugins` section of your configuration.\n\n```javascript\n// webpack.config.js\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  // ... other webpack configurations\n  plugins: [\n    new BundleAnalyzerPlugin() // Add the plugin here\n  ]\n};\n```\n\nWhen webpack runs with this plugin, it will open a browser window displaying the treemap visualization of your build output.",
          "examples": [
            {
              "id": "example_bundle_analyzer_1",
              "title": "Basic Webpack Configuration with Bundle Analyzer",
              "code": "const path = require('path');\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n  },\n  plugins: [\n    new BundleAnalyzerPlugin({\n      analyzerMode: 'static', // Generates a static HTML file instead of starting a server\n      openAnalyzer: false,    // Prevents opening browser automatically\n      reportFilename: 'bundle-report.html' // Custom report file name\n    })\n  ]\n};\n",
              "explanation": "This example shows a basic webpack configuration for a production build, integrating the `BundleAnalyzerPlugin`. The `analyzerMode` is set to 'static' to generate an HTML report file, and `openAnalyzer` is set to `false` to prevent the browser from automatically opening. This setup is useful for CI/CD environments or when you want to review the report later.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_bundle_analyzer_1",
            "question_bundle_analyzer_2",
            "question_bundle_analyzer_3",
            "question_bundle_analyzer_4"
          ],
          "relatedTasks": [
            "task_bundle_analyzer_1"
          ],
          "tags": [
            "webpack",
            "bundle-optimization",
            "tooling",
            "performance"
          ],
          "technology": "Webpack",
          "prerequisites": [
            "webpack_basics",
            "javascript_modules"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "performance_optimization",
            "webpack_advanced_config"
          ]
        },
        {
          "id": "theory_tree_shaking",
          "title": "Tree Shaking",
          "content": "Tree shaking, also known as 'dead code elimination', is a form of optimization used by modern JavaScript bundlers (like Webpack, Rollup, Parcel) to remove unused code from your final bundle. The term 'tree shaking' comes from the mental model of your application as a tree: the live code branches are included, and the dead code leaves are shaken off.\n\n## How it Works\nTree shaking relies on ES Modules (ESM) `import` and `export` statements. Unlike CommonJS `require()`, ESM imports are static, meaning the bundler can analyze the dependency graph at compile time to determine which exports are actually used. If an exported module member is never imported or used, it can be safely removed.\n\n## Benefits\n*   **Reduced Bundle Size:** Directly leads to smaller JavaScript bundles.\n*   **Improved Load Times:** Smaller bundles download faster, improving initial page load performance.\n*   **Better Performance:** Less code to parse and execute in the browser.\n\n## Prerequisites for Effective Tree Shaking\n1.  **ES Modules (ESM):** Your code and the libraries you use must be written using `import` and `export` syntax. Libraries often provide an `es` or `module` field in their `package.json` to point to their ESM build.\n2.  **Side-Effect Free Modules:** For optimal tree shaking, modules should be 'side-effect free'. A side effect is code that performs actions beyond just returning a value (e.g., modifying global scope, logging). Webpack can be informed about side-effect free modules via `\"sideEffects\": false` in `package.json` or specific configuration.\n3.  **Webpack Configuration:** Ensure your webpack configuration (especially in 'production' mode) is set up to perform tree shaking (e.g., `optimization.usedExports = true`, `TerserPlugin` for minification).\n\n## Practical Examples for Tree Shaking\nTo effectively tree shake, you should import only the specific functions or components you need, rather than importing an entire library.\n\n```javascript\n// Bad Practice: Imports the entire lodash library\nimport lodash from 'lodash';\nconst array1 = lodash.chunk(['a', 'b', 'c', 'd'], 2);\nconst array2 = lodash.flatten([1, [2, 3], 4]); // Even if flatten is not used, it's included.\n\n// Good Practice: Imports specific functions using ES Modules for tree shaking\nimport { chunk } from 'lodash-es'; // lodash-es provides ESM compatible builds\nconst array3 = chunk(['a', 'b', 'c', 'd'], 2);\n\n// Even Better: Imports specific functions from individual packages/paths\n// Many libraries offer direct paths to modules for even finer control\nimport chunk from 'lodash/chunk'; // Points directly to the chunk module\nconst array4 = chunk(['a', 'b', 'c', 'd'], 2);\n```\nIn the 'Good' and 'Even Better' examples, only the `chunk` function (and its dependencies) would be included in the final bundle, assuming `flatten` or other `lodash` functions are not used elsewhere.",
          "examples": [
            {
              "id": "example_tree_shaking_1",
              "title": "Demonstrating Tree Shaking Effectiveness",
              "code": "// my-utils.js\nexport function add(a, b) {\n  console.log('add called');\n  return a + b;\n}\n\nexport function subtract(a, b) {\n  console.log('subtract called');\n  return a - b;\n}\n\n// index.js\nimport { add } from './my-utils';\n\nconst sum = add(5, 3);\nconsole.log(sum);\n\n// If bundled with tree shaking enabled, 'subtract' function will be removed from the final bundle\n// because it's never imported or used.\n",
              "explanation": "This example demonstrates how tree shaking works. The `my-utils.js` file exports two functions: `add` and `subtract`. In `index.js`, only the `add` function is imported and used. When a bundler with tree shaking (like webpack in production mode) processes this, it will detect that `subtract` is unused and eliminate it from the final output, reducing bundle size.",
              "language": "javascript"
            },
            {
              "id": "example_tree_shaking_2",
              "title": "Configuring Webpack for Tree Shaking",
              "code": "const path = require('path');\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n  optimization: {\n    usedExports: true, // Tell webpack to detect unused exports\n    minimize: true,    // Enable minification\n    minimizer: [\n      new (require('terser-webpack-plugin'))({\n        extractComments: false, // Prevent creation of separate license files\n      }),\n    ],\n  },\n  // Important: Ensure package.json has \"sideEffects\": false for libraries\n  // or specify sideEffects in webpack config if needed.\n  // Example: in package.json\n  // {\n  //   \"name\": \"my-app\",\n  //   \"version\": \"1.0.0\",\n  //   \"sideEffects\": false, // Indicates that all modules in the package are side-effect free\n  //   ...\n  // }\n};\n",
              "explanation": "This webpack configuration snippet shows how to enable and optimize tree shaking. Setting `mode` to 'production' automatically enables many optimizations, including `usedExports: true` by default (though explicitly setting it is good for clarity). `TerserPlugin` is crucial for actually removing the dead code during minification. The `sideEffects` property in `package.json` is vital for informing webpack about modules that can be safely removed without causing issues.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_tree_shaking_1",
            "question_tree_shaking_2",
            "question_tree_shaking_3",
            "question_tree_shaking_4",
            "question_tree_shaking_5",
            "question_tree_shaking_6"
          ],
          "relatedTasks": [
            "task_tree_shaking_1"
          ],
          "tags": [
            "webpack",
            "performance",
            "optimization",
            "javascript",
            "es-modules"
          ],
          "technology": "Webpack",
          "prerequisites": [
            "javascript_modules",
            "webpack_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "performance_optimization",
            "bundle_size_reduction"
          ]
        },
        {
          "id": "theory_webpack_production_config",
          "title": "Webpack Configuration Best Practices for Production",
          "content": "Optimizing a webpack configuration for production is crucial for achieving small, fast, and cached bundles. This involves setting the `mode` to 'production' and leveraging various optimization features and plugins.\n\n## Core Production Configuration\n\n### `mode: 'production'`\nSetting `mode` to `'production'` automatically enables many built-in optimizations in webpack, such as minification, tree shaking, scope hoisting, and more.\n\n```javascript\nmodule.exports = {\n  mode: 'production',\n  // ...\n};\n```\n\n### Output Configuration\n\n*   **`filename: '[name].[contenthash].js'`**: Using `[contenthash]` in the output filename is critical for cache busting. The `contenthash` changes only when the content of the file changes, allowing browsers to cache static assets effectively. `[name]` refers to the entry point name.\n*   **`chunkFilename: '[name].[contenthash].chunk.js'`**: Similar to `filename`, this applies to non-entry chunks (e.g., those created by code splitting or dynamic imports). It ensures that dynamically loaded modules also benefit from cache busting.\n\n```javascript\noutput: {\n  path: path.resolve(__dirname, 'dist'),\n  filename: '[name].[contenthash].js',\n  chunkFilename: '[name].[contenthash].chunk.js',\n},\n```\n\n### Optimization\n\n#### `minimize` and `minimizer`\n*   **`minimize: true`**: Enables minification of the output bundles. This is often automatically true in production mode.\n*   **`minimizer`**: An array of plugins used to minify your code. Common ones include:\n    *   **`TerserPlugin`**: For minifying JavaScript. It replaces UglifyJSPlugin and offers advanced optimizations like dead code elimination, mangling, and more.\n    *   **`CssMinimizerPlugin`**: For minifying CSS. It uses `cssnano` or other processors to reduce CSS file size.\n\n```javascript\noptimization: {\n  minimize: true,\n  minimizer: [\n    new TerserPlugin({ /* options */ }),\n    new CssMinimizerPlugin(),\n  ],\n  // ...\n},\n```\n\n#### Code Splitting (`splitChunks`)\n`splitChunks` allows webpack to split your code into various chunks, which can be loaded on demand or in parallel. This significantly improves initial load time by only loading what's immediately necessary.\n\n*   **`chunks: 'all'`**: Optimizes all types of chunks (initial, async, and `all`).\n*   **`maxInitialRequests: Infinity`**: Controls how many parallel requests can be made for an entry point. `Infinity` allows as many as needed, which can be beneficial with HTTP/2.\n*   **`minSize: 0`**: Ensures even small modules are considered for splitting if they meet other criteria.\n*   **`cacheGroups`**: Defines groups of modules that should be bundled together. A common use case is bundling vendor (node_modules) code separately.\n    *   **`vendor` group**: Often used to put all code from `node_modules` into a separate chunk. The `name` function can derive a unique name for each vendor package, aiding in specific caching strategies.\n\n```javascript\noptimization: {\n  // ...\n  splitChunks: {\n    chunks: 'all',\n    maxInitialRequests: Infinity,\n    minSize: 0,\n    cacheGroups: {\n      vendor: {\n        test: /[\\\\/]node_modules[\\\\/]/,\n        name(module) {\n          const packageName = module.context.match(/[\\\\/]node_modules[\\\\/](.+?)(?:[\\\\/]|$)/)[1];\n          return `npm.${packageName.replace('@', '')}`; // e.g., npm.react, npm.lodash\n        },\n      },\n    },\n  },\n  // ...\n},\n```\n\n#### `runtimeChunk: 'single'`\nThis option creates a separate chunk for the webpack runtime code. This is beneficial because the runtime chunk contains the webpack manifest, which changes frequently. By separating it, other content-hashed bundles will remain unchanged when only the manifest changes, improving long-term caching.\n\n```javascript\noptimization: {\n  // ...\n  runtimeChunk: 'single',\n},\n```\n\n### Production Plugins\n\n*   **`MiniCssExtractPlugin`**: Extracts CSS into separate files instead of bundling it into JavaScript. This allows CSS to be loaded in parallel, preventing Flash of Unstyled Content (FOUC).\n    *   `filename: '[name].[contenthash].css'`**: Uses `contenthash` for CSS files for effective caching.\n\n*   **`CompressionPlugin`**: Prepares compressed versions of your assets (e.g., `.gz` or `.br` files) that can be served by the web server (e.g., Nginx, Apache) if the client supports it, reducing download size and improving speed.\n\n*   **`webpack.ids.HashedModuleIdsPlugin` (or `webpack.HashedModuleIdsPlugin` in older versions)**:\n    This plugin (or `optimization.moduleIds: 'hashed'` in webpack 5) ensures that module IDs are hashed based on their content. Without it, if a new module is added or an existing one is removed, the order of module IDs can shift, causing unrelated module hashes to change and invalidating client caches. Using content-based hashing stabilizes module IDs.\n\n```javascript\nplugins: [\n  new MiniCssExtractPlugin({\n    filename: '[name].[contenthash].css',\n  }),\n  new CompressionPlugin(),\n  new webpack.ids.HashedModuleIdsPlugin(), // For stable module IDs across builds\n],\n```\n\nThese practices combined lead to highly optimized, performant, and efficiently cached frontend applications.",
          "examples": [
            {
              "id": "example_webpack_prod_config_1",
              "title": "Comprehensive Production Webpack Config",
              "code": "const path = require('path');\nconst webpack = require('webpack');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin');\nconst TerserPlugin = require('terser-webpack-plugin');\nconst CompressionPlugin = require('compression-webpack-plugin');\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].[contenthash].js',\n    chunkFilename: '[name].[contenthash].chunk.js',\n    clean: true, // Cleans the output directory before each build\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [MiniCssExtractPlugin.loader, 'css-loader'],\n      },\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: 'babel-loader',\n      },\n    ],\n  },\n  optimization: {\n    minimize: true,\n    minimizer: [\n      new TerserPlugin({\n        parallel: true, // Use multi-process parallel running to improve build speed\n        terserOptions: {\n          compress: {\n            drop_console: true, // Remove console.log in production\n          },\n          format: {\n            comments: false, // Remove comments\n          },\n        },\n        extractComments: false,\n      }),\n      new CssMinimizerPlugin(),\n    ],\n    splitChunks: {\n      chunks: 'all',\n      maxInitialRequests: Infinity,\n      minSize: 0,\n      cacheGroups: {\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name(module) {\n            const packageName = module.context.match(/[\\\\/]node_modules[\\\\/](.+?)(?:[\\\\/]|$)/)[1];\n            return `npm.${packageName.replace('@', '')}`; // e.g., npm.react, npm.lodash\n          },\n        },\n      },\n    },\n    runtimeChunk: 'single',\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: '[name].[contenthash].css',\n    }),\n    new CompressionPlugin({\n      test: /\\.js$|\\.css$|\\.html$|\\.svg$/,\n      threshold: 8192, // Only assets bigger than this size are processed\n      minRatio: 0.8,   // Compress only if the compression ratio is better than this\n    }),\n    new webpack.ids.HashedModuleIdsPlugin(),\n  ],\n};\n",
              "explanation": "This example provides a full webpack production configuration demonstrating many best practices. It includes `mode: 'production'`, content hashing for output files, `TerserPlugin` for JS minification with console log removal, `CssMinimizerPlugin` for CSS, aggressive code splitting for vendors and other chunks, a separate runtime chunk for caching stability, `MiniCssExtractPlugin` for external CSS, `CompressionPlugin` for pre-compressed assets, and `HashedModuleIdsPlugin` for stable module IDs. The `clean: true` option is added to `output` to ensure the `dist` folder is cleared before each build.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_webpack_prod_config_1",
            "question_webpack_prod_config_2",
            "question_webpack_prod_config_3",
            "question_webpack_prod_config_4",
            "question_webpack_prod_config_5",
            "question_webpack_prod_config_6",
            "question_webpack_prod_config_7",
            "question_webpack_prod_config_8"
          ],
          "relatedTasks": [
            "task_webpack_prod_config_1",
            "task_webpack_prod_config_2"
          ],
          "tags": [
            "webpack",
            "performance",
            "optimization",
            "build-tools",
            "caching",
            "production"
          ],
          "technology": "Webpack",
          "prerequisites": [
            "webpack_basics",
            "javascript_modules",
            "npm_package_management"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "requiredFor": [
            "frontend_architecture",
            "devops",
            "performance_engineering"
          ]
        },
        {
          "id": "theory_server_side_rendering",
          "title": "Server-Side Rendering (SSR)",
          "content": "Server-Side Rendering (SSR) is a technique where the initial rendering of a client-side JavaScript application happens on the server. Instead of sending an empty HTML file and relying on the browser to fetch and execute JavaScript to build the DOM, the server sends a fully-rendered HTML page to the client. Once the HTML is received and displayed by the browser, the client-side JavaScript then 'hydrates' the static HTML, making it interactive.\n\n## How SSR Works\n1.  **Request:** A user's browser sends a request to the server.\n2.  **Server Rendering:** The server receives the request, executes the React (or Vue, Angular) application, and generates the initial HTML string representation of the component tree.\n3.  **Response:** The server sends this fully-formed HTML, along with references to JavaScript and CSS bundles, back to the browser.\n4.  **Initial Display:** The browser receives the HTML and immediately displays the page content to the user, providing a fast 'first paint'.\n5.  **Hydration:** In the background, the browser downloads the JavaScript bundles. Once loaded, the client-side framework (e.g., React) takes over the already rendered HTML, attaching event listeners and making the page interactive. This process is called hydration.\n\n## Benefits of SSR\n*   **Improved Initial Load Performance:** Users see content much faster because the browser doesn't have to wait for JavaScript to download and execute before rendering.\n*   **Better SEO (Search Engine Optimization):** Search engine crawlers can easily index the content because it's available directly in the HTML. While modern crawlers can execute JavaScript, SSR provides content faster and more reliably.\n*   **Enhanced User Experience:** Faster time-to-content leads to a perception of a more responsive application.\n*   **Accessibility:** Content is available even if JavaScript is disabled (though interactivity will be lost without hydration).\n\n## Challenges of SSR\n*   **Increased Server Load:** Rendering on the server consumes server CPU and memory resources. Scalability needs careful consideration.\n*   **Complexity:** Adds complexity to the development workflow, build process, and deployment.\n*   **Potential for Hydration Mismatch:** If the server-rendered HTML doesn't exactly match what the client-side JavaScript expects to render, hydration errors can occur.\n*   **Longer Time To Interactive (TTI) for complex apps:** While Time To First Byte (TTFB) and First Contentful Paint (FCP) are improved, Time To Interactive (TTI) might be delayed if large JavaScript bundles need to be downloaded and hydrated.\n\n## Basic React SSR Example with Express\n\n```javascript\n// server.js (Node.js/Express server)\nimport express from 'express';\nimport React from 'react';\nimport { renderToString } from 'react-dom/server'; // Key for server-side React rendering\nimport App from './src/App'; // Your React root component\nimport path from 'path';\n\nconst app = express();\n\n// Serve static files (e.g., bundle.js, styles.css) from the 'dist' directory\napp.use(express.static(path.resolve(__dirname, 'dist')));\n\napp.get('*', (req, res) => {\n  // Render the React component to an HTML string\n  const html = renderToString(<App />);\n  \n  // Send the fully formed HTML response\n  res.send(`\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>My SSR App</title>\n        <link rel=\"stylesheet\" href=\"/styles.css\" />\n      </head>\n      <body>\n        <div id=\"root\">${html}</div>\n        <script src=\"/bundle.js\"></script> <!-- Client-side bundle for hydration -->\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => {\n  console.log('Server is listening on port 3000');\n});\n\n// src/App.js (Your React Root Component)\nimport React from 'react';\n\nfunction App() {\n  const [count, setCount] = React.useState(0);\n\n  return (\n    <div>\n      <h1>Hello from SSR React App!</h1>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nexport default App;\n\n// src/index.js (Client-side entry point for hydration)\nimport React from 'react';\nimport ReactDOM from 'react-dom/client'; // Use createRoot for React 18+ for hydration\nimport App from './App';\n\n// Hydrate the existing HTML, instead of rendering from scratch\nconst root = ReactDOM.hydrateRoot(\n  document.getElementById('root'),\n  <App />\n);\n// For React 17 and below, it would be ReactDOM.hydrate(<App />, document.getElementById('root'));\n\n// webpack.client.js (Example client-side webpack config)\n// module.exports = {\n//   entry: './src/index.js',\n//   target: 'web',\n//   output: { filename: 'bundle.js' }\n//   // ... other client-side loaders/plugins\n// };\n\n// webpack.server.js (Example server-side webpack config)\n// module.exports = {\n//   entry: './server.js',\n//   target: 'node',\n//   output: { filename: 'server.bundle.js' },\n//   // Important: externals to prevent bundling node_modules on server\n//   externals: [nodeExternals()], \n//   // ... other server-side loaders/plugins (e.g., for ES6 imports)\n// };\n```\n\nThis setup typically requires two separate webpack configurations: one for the client-side bundle and one for the server-side bundle.",
          "examples": [
            {
              "id": "example_ssr_1",
              "title": "React SSR with Initial Data",
              "code": "// server.js\nimport express from 'express';\nimport React from 'react';\nimport { renderToString } from 'react-dom/server';\nimport App from './src/App';\nimport path from 'path';\n\nconst app = express();\napp.use(express.static(path.resolve(__dirname, 'dist')));\n\napp.get('/', async (req, res) => {\n  // Simulate fetching initial data\n  const initialData = { message: 'Data fetched from server!', items: ['item1', 'item2'] };\n  \n  // Pass initial data as a prop to the App component\n  const html = renderToString(<App initialData={initialData} />);\n  \n  res.send(`\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>My SSR App with Data</title>\n      </head>\n      <body>\n        <div id=\"root\">${html}</div>\n        <script>\n          window.__INITIAL_DATA__ = ${JSON.stringify(initialData)}; // Embed data for client hydration\n        </script>\n        <script src=\"/bundle.js\"></script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => console.log('Server listening on port 3000'));\n\n// src/App.js\nimport React from 'react';\n\nfunction App({ initialData }) {\n  const [data, setData] = React.useState(initialData || { message: 'Loading...', items: [] });\n\n  // Example of client-side fetch, this would typically be done if no initialData\n  React.useEffect(() => {\n    if (!initialData) {\n      // This branch would run if client-side rendering was primary, or for subsequent data fetches\n      // console.log('Client-side data fetch simulation');\n      // setTimeout(() => setData({ message: 'Client-side data!', items: ['c-item1'] }), 500);\n    }\n  }, [initialData]);\n\n  return (\n    <div>\n      <h1>{data.message}</h1>\n      <ul>\n        {data.items.map((item, index) => <li key={index}>{item}</li>)}\n      </ul>\n      <button onClick={() => setData({ message: 'Updated!', items: ['new item'] })}>Update Client-Side</button>\n    </div>\n  );\n}\n\nexport default App;\n\n// src/index.js (Client-side entry for hydration)\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nconst root = ReactDOM.hydrateRoot(\n  document.getElementById('root'),\n  <App initialData={window.__INITIAL_DATA__} />\n);\n",
              "explanation": "This example extends the basic SSR setup to include initial data fetching on the server. The `initialData` is fetched (simulated here), passed as a prop to the React `App` component during server rendering, and then embedded into the HTML using `window.__INITIAL_DATA__`. On the client side, `ReactDOM.hydrateRoot` uses this global variable to hydrate the `App` component with the same initial state, avoiding a loading flicker and ensuring a consistent experience between server and client rendering.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_ssr_1",
            "question_ssr_2",
            "question_ssr_3",
            "question_ssr_4",
            "question_ssr_5",
            "question_ssr_6"
          ],
          "relatedTasks": [
            "task_ssr_1"
          ],
          "tags": [
            "ssr",
            "react",
            "express",
            "performance",
            "seo",
            "node.js"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "node.js_basics",
            "express_basics",
            "webpack_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "frontend_architecture",
            "web_performance",
            "full_stack_development"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_bundle_analyzer_1",
          "topic": "Webpack Bundle Analyzer",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the Webpack Bundle Analyzer?",
          "answer": "To visualize the size and composition of webpack output files with an interactive treemap.",
          "options": [],
          "analysisPoints": [
            "Understanding of build tools' utility.",
            "Recognition of performance optimization tools."
          ],
          "keyConcepts": [
            "Webpack",
            "Bundle Optimization",
            "Tooling"
          ],
          "evaluationCriteria": [
            "Ability to recall tool's primary function"
          ],
          "example": "",
          "tags": [
            "webpack",
            "performance",
            "tooling"
          ],
          "prerequisites": [
            "webpack_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_bundle_analyzer_2",
          "topic": "Webpack Bundle Analyzer",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a typical insight gained from using Webpack Bundle Analyzer?\n\n```javascript\n// webpack.config.js\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  plugins: [\n    new BundleAnalyzerPlugin()\n  ]\n};\n```",
          "answer": "Identifying the most frequently called functions in your application at runtime.",
          "options": [
            "Identifying large third-party libraries contributing to bundle size.",
            "Detecting duplicate modules loaded into the bundle.",
            "Pinpointing custom application code that is unexpectedly large.",
            "Identifying the most frequently called functions in your application at runtime."
          ],
          "analysisPoints": [
            "Understanding the scope of static bundle analysis.",
            "Distinguishing between build-time analysis and runtime profiling."
          ],
          "keyConcepts": [
            "Webpack",
            "Bundle Analysis",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Understanding the capabilities and limitations of build analysis tools.",
            "Knowledge of performance profiling techniques."
          ],
          "example": "The Webpack Bundle Analyzer focuses on static analysis of the compiled bundle. It shows *what* is in the bundle and *how big* it is. It does not analyze runtime behavior like function call frequency, which would require tools like browser developer tools' performance profilers.",
          "tags": [
            "webpack",
            "performance",
            "tooling",
            "optimization"
          ],
          "prerequisites": [
            "webpack_basics",
            "javascript_performance"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_bundle_analyzer_3",
          "topic": "Webpack Bundle Analyzer",
          "level": "medium",
          "type": "open",
          "question": "After using Webpack Bundle Analyzer, you identify a significantly large third-party library. What steps would you consider to reduce its impact on your bundle size?",
          "answer": "1.  **Check for specific imports:** See if the library supports tree shaking and if you are importing only necessary parts (e.g., `import { chunk } from 'lodash-es'` instead of `import lodash from 'lodash';`).\n2.  **Evaluate alternatives:** Is there a smaller, more specialized library that can achieve the same functionality?\n3.  **Dynamic Imports (Code Splitting):** If the library is only used in certain parts of the application, consider dynamically importing it (`import()` syntax) so it's loaded only when needed.\n4.  **CDN:** For very large, widely used libraries, consider serving them from a CDN via `<script>` tags, especially if your users are likely to have them cached already. This offloads the burden from your bundle.\n5.  **Remove unused features:** If the library has optional features, ensure you're not including them if they're not needed.",
          "options": [],
          "analysisPoints": [
            "Problem-solving skills related to bundle optimization.",
            "Knowledge of various webpack and general frontend optimization techniques.",
            "Ability to prioritize optimization strategies."
          ],
          "keyConcepts": [
            "Bundle Optimization",
            "Tree Shaking",
            "Code Splitting",
            "CDN",
            "Webpack"
          ],
          "evaluationCriteria": [
            "Breadth of knowledge on performance optimization.",
            "Practical application of theoretical concepts.",
            "Ability to propose actionable solutions."
          ],
          "example": "",
          "tags": [
            "webpack",
            "performance",
            "optimization",
            "bundle-size",
            "tree-shaking",
            "code-splitting"
          ],
          "prerequisites": [
            "webpack_basics",
            "tree_shaking",
            "code_splitting"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_bundle_analyzer_4",
          "topic": "Webpack Bundle Analyzer",
          "level": "hard",
          "type": "code",
          "question": "You want to configure `webpack-bundle-analyzer` to generate a static HTML report without opening a browser automatically, suitable for a CI/CD pipeline. Modify the following `webpack.config.js` to achieve this, saving the report as `bundle-report.html` in the `dist` folder.",
          "answer": "```javascript\nconst path = require('path');\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n  },\n  plugins: [\n    new BundleAnalyzerPlugin({\n      analyzerMode: 'static',      // Generate a static HTML file\n      openAnalyzer: false,         // Prevent opening the browser automatically\n      reportFilename: path.resolve(__dirname, 'dist', 'bundle-report.html') // Specify output path and filename\n    })\n  ]\n};\n```",
          "options": [],
          "analysisPoints": [
            "Knowledge of `webpack-bundle-analyzer` configuration options.",
            "Ability to apply specific configurations for different environments (e.g., CI/CD).",
            "Correct usage of Node.js `path` module for file paths."
          ],
          "keyConcepts": [
            "Webpack",
            "Bundle Analyzer",
            "CI/CD",
            "Configuration"
          ],
          "evaluationCriteria": [
            "Accuracy of plugin configuration.",
            "Understanding of `analyzerMode` and `openAnalyzer` options.",
            "Correct path handling for `reportFilename`."
          ],
          "example": "The key to this task is knowing the `analyzerMode`, `openAnalyzer`, and `reportFilename` options for the `BundleAnalyzerPlugin`. `analyzerMode: 'static'` ensures an HTML file is generated, `openAnalyzer: false` prevents automatic browser launch, and `reportFilename` defines the output path and name for the report, which should be within the `dist` directory.",
          "tags": [
            "webpack",
            "tooling",
            "configuration",
            "ci-cd"
          ],
          "prerequisites": [
            "webpack_basics",
            "node.js_path"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_tree_shaking_1",
          "topic": "Tree Shaking",
          "level": "easy",
          "type": "flashcard",
          "question": "What is another common name for 'Tree Shaking'?",
          "answer": "Dead Code Elimination.",
          "options": [],
          "analysisPoints": [
            "Basic terminology recall.",
            "Understanding of fundamental webpack optimizations."
          ],
          "keyConcepts": [
            "Tree Shaking",
            "Dead Code Elimination",
            "Optimization"
          ],
          "evaluationCriteria": [
            "Ability to recall related terms"
          ],
          "example": "",
          "tags": [
            "webpack",
            "performance",
            "optimization"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_tree_shaking_2",
          "topic": "Tree Shaking",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `my-utils.js` and `index.js` files:\n\n`my-utils.js`:\n```javascript\nexport function funcA() { return 'A'; }\nexport function funcB() { return 'B'; }\nexport function funcC() { console.log('Side effect C'); return 'C'; }\n```\n\n`index.js`:\n```javascript\nimport { funcA } from './my-utils';\nconst result = funcA();\nconsole.log(result);\n```\n\nIf Webpack is configured for production mode with tree shaking, which function(s) will likely be included in the final bundle?",
          "answer": "Only `funcA`.",
          "options": [
            "Only `funcA`.",
            "`funcA` and `funcB`.",
            "`funcA`, `funcB`, and `funcC`.",
            "None of the functions, as `funcC` has a side effect."
          ],
          "analysisPoints": [
            "Understanding how tree shaking works with ES modules.",
            "Identifying used vs. unused exports.",
            "Recognizing that `console.log` within `funcC` is a side effect, but `funcC` itself would still be eliminated if unused and the module is marked side-effect free."
          ],
          "keyConcepts": [
            "Tree Shaking",
            "ES Modules",
            "Dead Code Elimination",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Correctly applying tree shaking principles.",
            "Distinguishing between module-level side effects and function-level side effects."
          ],
          "example": "Tree shaking works by identifying exports that are *not imported* anywhere in the dependency graph. Since only `funcA` is imported in `index.js`, `funcB` and `funcC` (despite `funcC` having an internal side effect) will be eliminated from the bundle, assuming `my-utils.js` or the entire project is configured as side-effect free.",
          "tags": [
            "webpack",
            "tree-shaking",
            "es-modules",
            "optimization"
          ],
          "prerequisites": [
            "javascript_modules"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_tree_shaking_3",
          "topic": "Tree Shaking",
          "level": "medium",
          "type": "open",
          "question": "Explain why `import lodash from 'lodash';` is generally less optimal for tree shaking compared to `import { chunk } from 'lodash-es';` or `import chunk from 'lodash/chunk';`.",
          "answer": "The primary reason is the module system used. When you use `import lodash from 'lodash';`, you are typically importing the CommonJS (CJS) build of `lodash`. CommonJS modules are dynamic, meaning a bundler cannot statically determine which parts of the `lodash` object (`lodash.chunk`, `lodash.map`, etc.) will actually be used at compile time. Therefore, the entire `lodash` library is included in the bundle.\n\nConversely, `import { chunk } from 'lodash-es';` or `import chunk from 'lodash/chunk';` leverages ES Modules (ESM) syntax. ESM imports are static, allowing bundlers like Webpack to perform 'dead code elimination' (tree shaking). The bundler can analyze that only the `chunk` export is used and therefore includes only that specific function (and its dependencies) in the final bundle, discarding all other unused `lodash` functions. `lodash-es` specifically provides an ESM-compatible build, and `lodash/chunk` directly imports the ES module for the `chunk` function.",
          "options": [],
          "analysisPoints": [
            "Understanding the difference between CommonJS and ES Modules regarding static analysis.",
            "Explaining how bundlers leverage ESM for tree shaking.",
            "Providing concrete examples of good vs. bad import practices."
          ],
          "keyConcepts": [
            "Tree Shaking",
            "ES Modules",
            "CommonJS",
            "Static Analysis",
            "Bundle Size"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of explanation.",
            "Demonstration of deep understanding of module systems.",
            "Ability to connect concepts to practical optimization."
          ],
          "example": "",
          "tags": [
            "tree-shaking",
            "es-modules",
            "commonjs",
            "webpack",
            "optimization",
            "javascript"
          ],
          "prerequisites": [
            "javascript_modules"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_tree_shaking_4",
          "topic": "Tree Shaking",
          "level": "hard",
          "type": "mcq",
          "question": "Which of the following is NOT a common prerequisite or configuration step for effective tree shaking in a webpack project?\n\nA. Using ES module syntax (`import`/`export`) throughout your codebase and dependencies.\nB. Ensuring modules are marked as 'side-effect free' where appropriate (e.g., via `package.json`'s `sideEffects` field).\nC. Configuring a minifier like `TerserPlugin` to remove unused code.\nD. Setting `optimization.usedExports` to `false` in webpack configuration.",
          "answer": "D. Setting `optimization.usedExports` to `false` in webpack configuration.",
          "options": [
            "A. Using ES module syntax (`import`/`export`) throughout your codebase and dependencies.",
            "B. Ensuring modules are marked as 'side-effect free' where appropriate (e.g., via `package.json`'s `sideEffects` field).",
            "C. Configuring a minifier like `TerserPlugin` to remove unused code.",
            "D. Setting `optimization.usedExports` to `false` in webpack configuration."
          ],
          "analysisPoints": [
            "Understanding the core requirements for tree shaking.",
            "Identifying correct webpack optimization settings.",
            "Distinguishing between enabling and disabling features."
          ],
          "keyConcepts": [
            "Tree Shaking",
            "ES Modules",
            "Side Effects",
            "Minification",
            "Webpack Optimization"
          ],
          "evaluationCriteria": [
            "Comprehensive knowledge of tree shaking prerequisites.",
            "Accuracy in identifying incorrect configuration.",
            "Understanding of webpack's `optimization.usedExports`."
          ],
          "example": "`optimization.usedExports` (which is enabled by default in `production` mode) is responsible for marking unused exports in the bundle, allowing the minifier (like Terser) to actually remove them. Setting it to `false` would disable this essential part of tree shaking, hence it's not a prerequisite for *effective* tree shaking.",
          "tags": [
            "webpack",
            "tree-shaking",
            "optimization",
            "configuration",
            "performance"
          ],
          "prerequisites": [
            "webpack_optimization"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_tree_shaking_5",
          "topic": "Tree Shaking",
          "level": "medium",
          "type": "flashcard",
          "question": "What role does the `\"sideEffects\": false` property in `package.json` play in tree shaking?",
          "answer": "It informs webpack that all modules within the package are 'side-effect free', meaning they don't perform actions beyond exporting values (e.g., global variable modification, console logs at module level). This allows webpack to safely remove unused exports without concern for breaking functionality.",
          "options": [],
          "analysisPoints": [
            "Understanding of `sideEffects` property.",
            "Connecting it to safe code elimination."
          ],
          "keyConcepts": [
            "Tree Shaking",
            "Side Effects",
            "package.json",
            "Webpack"
          ],
          "evaluationCriteria": [
            "Ability to explain the purpose of `sideEffects` in context of tree shaking"
          ],
          "example": "",
          "tags": [
            "webpack",
            "tree-shaking",
            "package.json",
            "optimization"
          ],
          "prerequisites": [
            "webpack_optimization"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_tree_shaking_6",
          "topic": "Tree Shaking",
          "level": "medium",
          "type": "open",
          "question": "Describe a scenario where tree shaking might not work as expected, even with ES Modules, and suggest a solution.",
          "answer": "One common scenario where tree shaking might not work as expected is when a module or library has **side effects** that prevent it from being safely removed, even if its exports are unused. For instance, a library might register a global polyfill, modify a DOM element, or log something upon import. If webpack doesn't know that such a module is side-effect free, it will err on the side of caution and include it.\n\n**Example:**\n```javascript\n// library.js\nconsole.log('This module initializes on import!'); // Side effect\nexport function funcA() { /* ... */ }\nexport function funcB() { /* ... */ }\n\n// app.js\nimport { funcA } from './library'; // Only funcA is used\n```\nEven if `funcB` is not used, the `console.log` statement in `library.js` makes the entire module potentially have side effects. If webpack isn't explicitly told otherwise, it might include the entire `library.js` module.\n\n**Solution:**\nTo address this, the library author (or you, if it's your code) can specify `\"sideEffects\": false` in the `package.json` for that package (if the whole package is side-effect free) or use an array of paths that contain side effects (e.g., `\"sideEffects\": [\"./src/polyfills.js\"]`). This explicit declaration tells webpack that modules *not* listed as having side effects can be safely tree-shaken if their exports are unused. If the module genuinely has necessary side effects, then it cannot be fully tree-shaken, and you might need to reconsider its usage or break it down into smaller, side-effect-free parts.",
          "options": [],
          "analysisPoints": [
            "Identifying edge cases for tree shaking.",
            "Understanding the concept of 'side effects' in modules.",
            "Proposing practical solutions using `package.json`'s `sideEffects` field."
          ],
          "keyConcepts": [
            "Tree Shaking",
            "Side Effects",
            "Webpack",
            "Module Bundling",
            "Optimization"
          ],
          "evaluationCriteria": [
            "Depth of understanding of tree shaking mechanics.",
            "Ability to diagnose and solve optimization issues.",
            "Knowledge of `sideEffects` configuration."
          ],
          "example": "",
          "tags": [
            "webpack",
            "tree-shaking",
            "optimization",
            "side-effects",
            "javascript"
          ],
          "prerequisites": [
            "tree_shaking_theory"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_webpack_prod_config_1",
          "topic": "Webpack Production Configuration",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using `[contenthash]` in webpack output filenames for production builds?",
          "answer": "Enables long-term caching for static assets by invalidating the cache only when the file's content changes.",
          "options": [],
          "analysisPoints": [
            "Understanding of caching strategies.",
            "Recognition of hash types in webpack."
          ],
          "keyConcepts": [
            "Webpack",
            "Caching",
            "Contenthash",
            "Performance"
          ],
          "evaluationCriteria": [
            "Ability to recall caching benefits of contenthash"
          ],
          "example": "",
          "tags": [
            "webpack",
            "caching",
            "performance"
          ],
          "prerequisites": [
            "webpack_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_webpack_prod_config_2",
          "topic": "Webpack Production Configuration",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following webpack `optimization` configurations is primarily responsible for splitting vendor code (from `node_modules`) into a separate chunk?",
          "answer": "`splitChunks.cacheGroups.vendor`",
          "options": [
            "`minimize: true`",
            "`runtimeChunk: 'single'`",
            "`splitChunks.cacheGroups.vendor`",
            "`TerserPlugin`"
          ],
          "analysisPoints": [
            "Understanding different webpack optimization features.",
            "Identifying the specific configuration for code splitting by vendor.",
            "Distinguishing between minification, runtime chunking, and code splitting."
          ],
          "keyConcepts": [
            "Webpack",
            "Code Splitting",
            "Optimization",
            "Vendor Bundling"
          ],
          "evaluationCriteria": [
            "Accurate identification of webpack configuration purpose.",
            "Knowledge of `splitChunks` options."
          ],
          "example": "The `splitChunks` configuration within the `optimization` object is used for code splitting. Specifically, `cacheGroups` allow defining rules for grouping modules into chunks. The `vendor` cache group, often defined with a `test: /[\\\\/]node_modules[\\\\/]/` regex, is standard for isolating third-party libraries.",
          "tags": [
            "webpack",
            "code-splitting",
            "optimization",
            "performance"
          ],
          "prerequisites": [
            "webpack_optimization"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_webpack_prod_config_3",
          "topic": "Webpack Production Configuration",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose of `runtimeChunk: 'single'` in a webpack production configuration and how it contributes to caching strategies.",
          "answer": "`runtimeChunk: 'single'` in webpack's `optimization` configuration tells webpack to extract the webpack runtime and manifest into a separate, single chunk. The webpack runtime contains the code necessary to load and execute other chunks, including information about module IDs and chunk mappings (the manifest).\n\n**Contribution to Caching:**\nWithout `runtimeChunk: 'single'`, the manifest (which changes frequently due to new builds, module additions/deletions, or even just changes to module order) would be embedded within one of your application bundles (e.g., the entry chunk or a vendor chunk). If the manifest changes, the `contenthash` of that entire bundle would also change, forcing browsers to re-download the entire bundle, even if the actual application code within it hasn't changed.\n\nBy isolating the runtime into its own chunk, only *that* small runtime chunk needs to be re-downloaded when the manifest changes. All other application and vendor chunks, whose `contenthash` depends only on their actual content, will remain stable in the browser cache as long as their source code doesn't change. This significantly improves long-term caching effectiveness and reduces data transfer on subsequent visits.",
          "options": [],
          "analysisPoints": [
            "Understanding webpack's runtime concept.",
            "Explaining the interaction between runtime, manifest, and content hashing.",
            "Clearly articulating the caching benefit."
          ],
          "keyConcepts": [
            "Webpack",
            "Caching",
            "Runtime Chunk",
            "Contenthash",
            "Optimization"
          ],
          "evaluationCriteria": [
            "Accuracy and depth of technical explanation.",
            "Ability to connect configuration to performance impact.",
            "Clarity of communication."
          ],
          "example": "",
          "tags": [
            "webpack",
            "caching",
            "optimization",
            "performance"
          ],
          "prerequisites": [
            "webpack_optimization",
            "caching_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_webpack_prod_config_4",
          "topic": "Webpack Production Configuration",
          "level": "hard",
          "type": "code",
          "question": "A production webpack configuration needs to ensure that: \n1. CSS is extracted into separate files with content hashing.\n2. JavaScript and CSS files are minified.\n3. Pre-compressed Gzip files are generated for both JS and CSS.\n4. Module IDs are stable across builds to prevent cache invalidation due to minor changes.\n\nModify the following partial `webpack.config.js` to implement these requirements. Assume `MiniCssExtractPlugin`, `CssMinimizerPlugin`, `TerserPlugin`, and `CompressionPlugin` are already installed.",
          "answer": "```javascript\nconst path = require('path');\nconst webpack = require('webpack');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin');\nconst TerserPlugin = require('terser-webpack-plugin');\nconst CompressionPlugin = require('compression-webpack-plugin');\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].[contenthash].js',\n    chunkFilename: '[name].[contenthash].chunk.js',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [MiniCssExtractPlugin.loader, 'css-loader'],\n      },\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: 'babel-loader',\n      },\n    ],\n  },\n  optimization: {\n    minimize: true,\n    minimizer: [\n      new TerserPlugin(),   // For JavaScript minification\n      new CssMinimizerPlugin(), // For CSS minification\n    ],\n    // Ensure usedExports is true (default in production) for tree shaking\n    // runtimeChunk: 'single' // Also good practice, but not explicitly requested for this question\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: '[name].[contenthash].css', // 1. CSS extracted with content hash\n    }),\n    new CompressionPlugin(), // 3. Generates .gz files for JS, CSS (default test regex covers them)\n    new webpack.ids.HashedModuleIdsPlugin(), // 4. Stable module IDs\n    // Note: TerserPlugin and CssMinimizerPlugin are placed in optimization.minimizer\n  ],\n};\n```",
          "options": [],
          "analysisPoints": [
            "Correctly configuring `MiniCssExtractPlugin` with `[contenthash]`.",
            "Placing `TerserPlugin` and `CssMinimizerPlugin` in `optimization.minimizer`.",
            "Including `CompressionPlugin` for pre-compression.",
            "Adding `webpack.ids.HashedModuleIdsPlugin` for stable module IDs.",
            "Understanding the roles of different plugins and optimization settings."
          ],
          "keyConcepts": [
            "Webpack",
            "Plugins",
            "Optimization",
            "Minification",
            "Caching",
            "Compression",
            "CSS Extraction"
          ],
          "evaluationCriteria": [
            "Accuracy in implementing all four requirements.",
            "Correct placement of plugins and optimization options.",
            "Demonstration of comprehensive webpack configuration knowledge."
          ],
          "example": "The solution leverages key webpack features for production. `MiniCssExtractPlugin` handles CSS extraction, with `[contenthash]` for caching. `TerserPlugin` and `CssMinimizerPlugin` are correctly placed in `optimization.minimizer` for minification. `CompressionPlugin` is added to `plugins` for generating compressed assets. Finally, `webpack.ids.HashedModuleIdsPlugin` is included to stabilize module IDs, which is crucial for cache invalidation strategies.",
          "tags": [
            "webpack",
            "configuration",
            "optimization",
            "performance",
            "plugins",
            "caching"
          ],
          "prerequisites": [
            "webpack_plugins",
            "webpack_optimization"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_webpack_prod_config_5",
          "topic": "Webpack Production Configuration",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary function of `CompressionPlugin` in a webpack build?",
          "answer": "To pre-compress webpack assets (like JS, CSS, HTML) using algorithms like Gzip or Brotli, allowing web servers to serve smaller, pre-compressed files and reduce client download times.",
          "options": [],
          "analysisPoints": [
            "Understanding of asset compression.",
            "Benefits for network performance."
          ],
          "keyConcepts": [
            "Webpack",
            "Compression",
            "Performance",
            "Optimization"
          ],
          "evaluationCriteria": [
            "Ability to explain `CompressionPlugin`'s role"
          ],
          "example": "",
          "tags": [
            "webpack",
            "performance",
            "optimization",
            "compression"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_webpack_prod_config_6",
          "topic": "Webpack Production Configuration",
          "level": "medium",
          "type": "mcq",
          "question": "You observe that even after small changes to a single application file, your entire `vendor.js` bundle's hash changes, causing users to re-download it. Which webpack configuration option or plugin is most likely missing or misconfigured to prevent this issue?",
          "answer": "`webpack.ids.HashedModuleIdsPlugin` (or `optimization.moduleIds: 'hashed'` in webpack 5)",
          "options": [
            "`mode: 'production'`",
            "`optimization.splitChunks.chunks: 'all'`",
            "`webpack.ids.HashedModuleIdsPlugin` (or `optimization.moduleIds: 'hashed'` in webpack 5)",
            "`MiniCssExtractPlugin`"
          ],
          "analysisPoints": [
            "Diagnosing caching issues related to module IDs.",
            "Knowledge of webpack's module ID generation and stabilization.",
            "Distinguishing between general optimization and specific ID stabilization."
          ],
          "keyConcepts": [
            "Webpack",
            "Caching",
            "Module IDs",
            "HashedModuleIdsPlugin",
            "Performance"
          ],
          "evaluationCriteria": [
            "Correctly identifying the root cause of the caching problem.",
            "Knowledge of specific webpack solutions for module ID stability."
          ],
          "example": "When module IDs are not stable (e.g., they are numeric and assigned based on build order), adding or removing a new module can shift the IDs of all subsequent modules. This change in ID, even if the module's content hasn't changed, would cause its hash to change if the hash includes the ID. `webpack.ids.HashedModuleIdsPlugin` (or `optimization.moduleIds: 'hashed'`) solves this by hashing module IDs based on their content, making them stable across builds.",
          "tags": [
            "webpack",
            "caching",
            "optimization",
            "module-ids",
            "troubleshooting"
          ],
          "prerequisites": [
            "webpack_optimization",
            "caching_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_webpack_prod_config_7",
          "topic": "Webpack Production Configuration",
          "level": "hard",
          "type": "open",
          "question": "A developer argues that setting `optimization.maxInitialRequests` to `Infinity` in `splitChunks` for an application served over HTTP/1.1 is always a good idea for performance. Do you agree? Justify your answer, considering both HTTP/1.1 and HTTP/2 implications.",
          "answer": "I would **disagree** with the statement that setting `optimization.maxInitialRequests` to `Infinity` is *always* a good idea, especially for an application served over **HTTP/1.1**.\n\n**HTTP/1.1 Implications:**\n*   HTTP/1.1 has a limitation on the number of concurrent requests (typically 6-8 per domain). If `maxInitialRequests` is set to `Infinity`, webpack will generate as many initial chunks as possible, potentially leading to a large number of small network requests.\n*   Under HTTP/1.1, these numerous requests would block each other, leading to increased overhead from connection setup/teardown for each request, Head-of-Line Blocking, and overall slower page load times due to serial loading of too many assets.\n*   For HTTP/1.1, it's generally better to have a moderate number of larger chunks (e.g., 2-5) to optimize for the limited parallelism, balancing the benefits of code splitting with the overhead of too many requests.\n\n**HTTP/2 Implications:**\n*   HTTP/2 supports multiplexing, allowing multiple requests and responses to be sent concurrently over a single TCP connection. This significantly reduces the overhead associated with many small requests.\n*   Therefore, setting `maxInitialRequests` to `Infinity` can be a **good strategy** for applications served over HTTP/2, as it fully leverages the protocol's capabilities for parallel loading and finer-grained caching (smaller, more independent chunks are less likely to change). This allows for maximum code splitting benefit without the performance penalty seen in HTTP/1.1.\n\n**Conclusion:**\nThe optimal value for `maxInitialRequests` is highly dependent on the serving protocol. While `Infinity` is excellent for HTTP/2, it can be detrimental for HTTP/1.1. Developers should analyze their deployment environment and target audience's browser support to make an informed decision.",
          "options": [],
          "analysisPoints": [
            "Understanding of HTTP/1.1 and HTTP/2 differences.",
            "Knowledge of `splitChunks` options and their impact on network performance.",
            "Ability to analyze a statement critically and provide nuanced justification.",
            "Connecting webpack configuration to underlying web protocols."
          ],
          "keyConcepts": [
            "Webpack",
            "Code Splitting",
            "HTTP/1.1",
            "HTTP/2",
            "Performance Optimization",
            "Networking"
          ],
          "evaluationCriteria": [
            "Accuracy of protocol knowledge.",
            "Thoroughness of explanation regarding the impact of `maxInitialRequests`.",
            "Ability to articulate a well-reasoned argument.",
            "Practical application of performance principles."
          ],
          "example": "",
          "tags": [
            "webpack",
            "performance",
            "networking",
            "http",
            "code-splitting",
            "optimization"
          ],
          "prerequisites": [
            "webpack_optimization",
            "http_protocols"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "expert"
        },
        {
          "id": "question_webpack_prod_config_8",
          "topic": "Webpack Production Configuration",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the main benefit of using `MiniCssExtractPlugin` in a webpack production build, compared to including CSS directly in JavaScript bundles?",
          "answer": "It extracts CSS into separate `.css` files, allowing browsers to load CSS asynchronously and in parallel with JavaScript, preventing Flash of Unstyled Content (FOUC) and improving initial render performance.",
          "options": [],
          "analysisPoints": [
            "Understanding of CSS loading best practices.",
            "Knowledge of FOUC and its prevention."
          ],
          "keyConcepts": [
            "Webpack",
            "CSS Optimization",
            "Performance",
            "FOUC"
          ],
          "evaluationCriteria": [
            "Ability to explain `MiniCssExtractPlugin`'s advantage"
          ],
          "example": "",
          "tags": [
            "webpack",
            "css",
            "performance",
            "plugin"
          ],
          "prerequisites": [],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_ssr_1",
          "topic": "Server-Side Rendering (SSR)",
          "level": "easy",
          "type": "flashcard",
          "question": "What does SSR stand for?",
          "answer": "Server-Side Rendering.",
          "options": [],
          "analysisPoints": [
            "Basic terminology recall."
          ],
          "keyConcepts": [
            "SSR"
          ],
          "evaluationCriteria": [
            "Ability to recall abbreviation"
          ],
          "example": "",
          "tags": [
            "ssr",
            "fundamentals"
          ],
          "prerequisites": [],
          "complexity": 1,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_ssr_2",
          "topic": "Server-Side Rendering (SSR)",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a primary benefit of using Server-Side Rendering for a Single Page Application (SPA)?",
          "answer": "Reduced server load and complexity.",
          "options": [
            "Improved SEO for search engine crawlers.",
            "Faster Time to First Contentful Paint (FCP).",
            "Better user experience on slower networks.",
            "Reduced server load and complexity."
          ],
          "analysisPoints": [
            "Understanding the trade-offs of SSR.",
            "Identifying common misconceptions about SSR benefits."
          ],
          "keyConcepts": [
            "SSR",
            "SEO",
            "Performance",
            "Server Load"
          ],
          "evaluationCriteria": [
            "Accurate knowledge of SSR advantages and disadvantages.",
            "Ability to distinguish between client-side and server-side rendering characteristics."
          ],
          "example": "SSR generally *increases* server load and adds complexity because the server now has to render the application for each request. Benefits like improved SEO, faster FCP, and better user experience are indeed primary advantages.",
          "tags": [
            "ssr",
            "performance",
            "seo",
            "architecture"
          ],
          "prerequisites": [
            "ssr_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_ssr_3",
          "topic": "Server-Side Rendering (SSR)",
          "level": "medium",
          "type": "open",
          "question": "Explain the concept of 'hydration' in the context of React Server-Side Rendering. Why is it important?",
          "answer": "In React Server-Side Rendering, 'hydration' is the process where the client-side JavaScript takes over the HTML that was initially rendered by the server. When the browser receives the server-rendered HTML, it displays the content immediately (fast 'first paint'). However, this initial HTML is static and non-interactive.\n\nOnce the client-side JavaScript bundles (containing React) are downloaded and executed, React scans the existing DOM (created by the server) and attaches event listeners, sets up component state, and makes the application interactive. Instead of re-rendering the entire component tree from scratch (which would cause a flicker and wasted work), React 'hydrates' the pre-existing server-rendered markup, bringing it to life.\n\n**Importance:**\n*   **Seamless Transition:** It provides a smooth transition from a static server-rendered page to a fully interactive client-side application without a noticeable re-render.\n*   **Performance:** It avoids the double-rendering problem, where the client would first re-create the DOM, then update it. Hydration is more efficient as it reuses the server-generated DOM.\n*   **User Experience:** Ensures that content is visible quickly while interactivity becomes available shortly after, combining the benefits of static pages with the richness of SPAs.",
          "options": [],
          "analysisPoints": [
            "Clear definition of hydration.",
            "Explanation of the process (server-to-client transition).",
            "Articulating the benefits of hydration (performance, UX, seamlessness)."
          ],
          "keyConcepts": [
            "SSR",
            "Hydration",
            "React",
            "Performance",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Accuracy and completeness of explanation.",
            "Understanding of the client-server interaction in SSR.",
            "Clarity of the concept's importance."
          ],
          "example": "",
          "tags": [
            "ssr",
            "react",
            "hydration",
            "performance",
            "client-server"
          ],
          "prerequisites": [
            "react_basics",
            "ssr_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_ssr_4",
          "topic": "Server-Side Rendering (SSR)",
          "level": "hard",
          "type": "code",
          "question": "Given the following React component:\n\n`src/PostDetail.js`:\n```javascript\nimport React, { useState, useEffect } from 'react';\n\nfunction PostDetail({ postId, initialPostData }) {\n  const [post, setPost] = useState(initialPostData);\n  const [loading, setLoading] = useState(!initialPostData);\n\n  useEffect(() => {\n    if (!initialPostData) {\n      setLoading(true);\n      fetch(`/api/posts/${postId}`)\n        .then(res => res.json())\n        .then(data => {\n          setPost(data);\n          setLoading(false);\n        });\n    }\n  }, [postId, initialPostData]);\n\n  if (loading) {\n    return <div>Loading post...</div>;\n  }\n\n  if (!post) {\n    return <div>Post not found.</div>;\n  }\n\n  return (\n    <div>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </div>\n  );\n}\n\nexport default PostDetail;\n```\n\nModify the `server.js` Express route to perform server-side data fetching for `PostDetail` before rendering, embedding the fetched data into the HTML for client hydration. Assume `fetch` is available on the server (e.g., via `node-fetch`).",
          "answer": "```javascript\n// server.js\nimport express from 'express';\nimport React from 'react';\nimport { renderToString } from 'react-dom/server';\nimport PostDetail from './src/PostDetail'; // Assuming PostDetail is the root component\nimport path from 'path';\nimport fetch from 'node-fetch'; // Assuming node-fetch is installed for server-side fetch\n\nconst app = express();\n\napp.use(express.static(path.resolve(__dirname, 'dist'))); // Serve static client bundle\n\napp.get('/posts/:id', async (req, res) => {\n  const postId = req.params.id;\n  let initialPostData = null;\n\n  try {\n    // Simulate server-side data fetching\n    const response = await fetch(`http://localhost:3000/api/posts/${postId}`); // Adjust URL as needed\n    if (response.ok) {\n      initialPostData = await response.json();\n    } else {\n      // Handle cases where post is not found or API error\n      console.error(`Error fetching post ${postId}: ${response.status}`);\n    }\n  } catch (error) {\n    console.error('Server-side data fetch error:', error);\n  }\n\n  // Render the React component with initial data\n  const html = renderToString(\n    <PostDetail postId={postId} initialPostData={initialPostData} />\n  );\n  \n  // Embed initial data into the HTML for client hydration\n  const initialDataScript = initialPostData \n    ? `<script>window.__INITIAL_DATA__ = ${JSON.stringify(initialPostData)};</script>`\n    : `<script>window.__INITIAL_DATA__ = null;</script>`;\n\n  res.send(`\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>${initialPostData ? initialPostData.title : 'Post'}</title>\n      </head>\n      <body>\n        <div id=\"root\">${html}</div>\n        ${initialDataScript}\n        <script src=\"/bundle.js\"></script>\n      </body>\n    </html>\n  `);\n});\n\n// Example API endpoint for testing data fetching\napp.get('/api/posts/:id', (req, res) => {\n  const id = req.params.id;\n  if (id === '123') {\n    res.json({ id: '123', title: 'My First SSR Post', content: 'This content was rendered on the server!' });\n  } else {\n    res.status(404).json({ message: 'Post not found' });\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is listening on port 3000');\n});\n\n// src/index.js (Client-side hydration for PostDetail)\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport PostDetail from './PostDetail';\n\n// Assuming the postId comes from the URL, or similar context\n// For a real app, you'd parse the URL or pass it from a higher component.\nconst postIdFromUrl = window.location.pathname.split('/').pop(); // Basic example\n\nconst root = ReactDOM.hydrateRoot(\n  document.getElementById('root'),\n  <PostDetail postId={postIdFromUrl} initialPostData={window.__INITIAL_DATA__} />\n);\n```",
          "options": [],
          "analysisPoints": [
            "Implementing server-side data fetching (`async/await` with `fetch`).",
            "Passing fetched data as props to the React component during `renderToString`.",
            "Embedding initial data into the HTML via a `script` tag for client hydration.",
            "Ensuring the client-side hydration logic correctly uses the embedded data.",
            "Handling cases where data fetching might fail."
          ],
          "keyConcepts": [
            "SSR",
            "Data Fetching",
            "Hydration",
            "React",
            "Express",
            "Node.js"
          ],
          "evaluationCriteria": [
            "Correct implementation of server-side data fetching.",
            "Proper embedding and retrieval of initial data.",
            "Seamless integration between server and client rendering logic.",
            "Robustness in handling data loading states."
          ],
          "example": "This solution demonstrates a common pattern for SSR with initial data. The server fetches the data *before* rendering the React component to a string. This `initialPostData` is then passed as a prop to the `PostDetail` component. Crucially, the same data is serialized and embedded into the HTML, typically in a `window.__INITIAL_DATA__` global variable. On the client, `ReactDOM.hydrateRoot` retrieves this data and uses it to initialize the `PostDetail` component's state, preventing a data re-fetch and ensuring the client-side component's state matches the server-rendered markup.",
          "tags": [
            "ssr",
            "react",
            "data-fetching",
            "express",
            "node.js",
            "advanced"
          ],
          "prerequisites": [
            "ssr_basics",
            "react_hooks",
            "async_await"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "expert"
        },
        {
          "id": "question_ssr_5",
          "topic": "Server-Side Rendering (SSR)",
          "level": "medium",
          "type": "flashcard",
          "question": "What common issue can occur if the HTML generated by the server for SSR does not exactly match what the client-side React application expects to render?",
          "answer": "A 'hydration mismatch' error, which can lead to React throwing warnings, unexpected behavior, or even re-rendering the entire component tree on the client side, negating some SSR benefits.",
          "options": [],
          "analysisPoints": [
            "Understanding of hydration and its dependency on matching DOM.",
            "Awareness of common SSR pitfalls."
          ],
          "keyConcepts": [
            "SSR",
            "Hydration",
            "React",
            "Errors"
          ],
          "evaluationCriteria": [
            "Ability to identify consequences of hydration mismatch"
          ],
          "example": "",
          "tags": [
            "ssr",
            "react",
            "hydration",
            "troubleshooting"
          ],
          "prerequisites": [
            "ssr_basics",
            "react_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_ssr_6",
          "topic": "Server-Side Rendering (SSR)",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast Server-Side Rendering (SSR) with Client-Side Rendering (CSR) and Static Site Generation (SSG) in terms of initial load performance, SEO, and development complexity.",
          "answer": "**Server-Side Rendering (SSR)**\n*   **Initial Load Performance:** Good. Sends fully rendered HTML to the browser quickly, leading to faster First Contentful Paint (FCP). Time To Interactive (TTI) might be slower than SSG if bundles are large, but faster than CSR.\n*   **SEO:** Excellent. Search engine crawlers receive full HTML content directly, which is easily indexed.\n*   **Development Complexity:** High. Requires a Node.js server, managing server and client bundles, data hydration, and handling server-specific APIs/logic.\n\n**Client-Side Rendering (CSR)**\n*   **Initial Load Performance:** Poor for first load. Sends a minimal HTML file (often just a `div#root`) and relies on JavaScript to fetch data and build the DOM. Leads to slower FCP.\n*   **SEO:** Fair/Challenging. Modern crawlers can execute JavaScript, but it's less reliable and can be slower for indexing than server-rendered content. Requires careful handling (e.g., pre-rendering, dynamic rendering).\n*   **Development Complexity:** Lower. Simpler build process (one bundle), no server-side concerns beyond serving static files.\n\n**Static Site Generation (SSG)**\n*   **Initial Load Performance:** Excellent. HTML is pre-built at compile time and served as static files via a CDN. Extremely fast FCP and TTI.\n*   **SEO:** Excellent. Full HTML available at build time, optimized for crawlers.\n*   **Development Complexity:** Medium. Requires a build process to generate static files. Best for content that doesn't change frequently or requires immediate updates. More complex for dynamic, highly personalized content (might use client-side fetching after initial load).\n\n**Summary Table:**\n\n| Feature              | SSR (Server-Side Rendering)                                     | CSR (Client-Side Rendering)                                | SSG (Static Site Generation)                                 |\n| :------------------- | :-------------------------------------------------------------- | :--------------------------------------------------------- | :----------------------------------------------------------- |\n| **FCP**              | Fast (full HTML on first byte)                                  | Slow (empty HTML, needs JS to render)                      | Very Fast (pre-built HTML, often CDN-served)                 |\n| **TTI**              | Variable (depends on hydration, usually slower than FCP)        | Variable (depends on JS load/execution, often slower FCP)  | Very Fast (JS for interactivity loads after static content)  |\n| **SEO**              | Excellent (full HTML for crawlers)                              | Fair/Challenging (requires JS execution by crawler)        | Excellent (full HTML pre-built)                              |\n| **Data Freshness**   | Real-time (data fetched on each request)                        | Real-time (data fetched client-side)                       | Stale at build time (requires re-deploy for updates)         |\n| **Server Load**      | High (renders on each request)                                  | Low (serves static files)                                  | None (serves static files, built once)                       |\n| **Complexity**       | High (server, client, hydration, two build processes)           | Low (simple static serving)                                | Medium (build process, data fetching at build time)          |\n| **Best Use Case**    | Dynamic, personalized content requiring good SEO and fast FCP   | Highly interactive apps, dashboards (less SEO critical)    | Content-heavy, rarely changing sites (blogs, marketing)      |",
          "options": [],
          "analysisPoints": [
            "Comprehensive understanding of rendering strategies.",
            "Ability to articulate pros and cons across multiple dimensions (performance, SEO, complexity).",
            "Clear differentiation between each rendering type.",
            "Structured and organized comparison."
          ],
          "keyConcepts": [
            "SSR",
            "CSR",
            "SSG",
            "Performance",
            "SEO",
            "Architecture",
            "Web Rendering"
          ],
          "evaluationCriteria": [
            "Depth and accuracy of the comparison.",
            "Clarity and conciseness of explanations.",
            "Ability to synthesize complex information.",
            "Identification of appropriate use cases for each strategy."
          ],
          "example": "",
          "tags": [
            "ssr",
            "csr",
            "ssg",
            "architecture",
            "performance",
            "seo",
            "comparison"
          ],
          "prerequisites": [
            "web_fundamentals",
            "react_basics"
          ],
          "complexity": 10,
          "interviewFrequency": 10,
          "learningPath": "expert"
        }
      ],
      "tasks": [
        {
          "id": "task_bundle_analyzer_1",
          "title": "Integrate and Configure Webpack Bundle Analyzer",
          "description": "\nYour task is to integrate `webpack-bundle-analyzer` into an existing webpack configuration. You need to:\n\n1.  Install the necessary package.\n2.  Add `BundleAnalyzerPlugin` to the webpack configuration.\n3.  Configure the plugin to generate a static HTML report named `analyzer-report.html` in your `dist` directory, without automatically opening the report in the browser.\n\nThis setup is typical for CI/CD environments where you want to review bundle statistics after a build.\n",
          "difficulty": "medium",
          "startingCode": "const path = require('path');\n// const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; // Uncomment after npm install\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n  },\n  plugins: [\n    // TODO: Add the BundleAnalyzerPlugin here with the specified configuration\n  ],\n  // Assume src/index.js and other necessary files exist\n};\n",
          "solutionCode": "const path = require('path');\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n  },\n  plugins: [\n    new BundleAnalyzerPlugin({\n      analyzerMode: 'static',      // Generate a static HTML file\n      openAnalyzer: false,         // Prevent opening the browser automatically\n      reportFilename: path.resolve(__dirname, 'dist', 'analyzer-report.html') // Specify output path and filename\n    })\n  ],\n};\n",
          "testCases": [
            "Verify `webpack-bundle-analyzer` is listed as a dev dependency in `package.json`.",
            "Run `webpack` command (e.g., `npx webpack --config webpack.config.js`).",
            "Check that `dist/analyzer-report.html` file is generated.",
            "Confirm that a browser window does NOT automatically open after the build."
          ],
          "hints": [
            "Remember to run `npm install webpack-bundle-analyzer --save-dev` first.",
            "Look into the plugin's documentation for options to control the analyzer mode and whether to open the browser.",
            "`path.resolve` is useful for constructing absolute file paths."
          ],
          "tags": [
            "webpack",
            "tooling",
            "performance",
            "optimization",
            "ci-cd"
          ],
          "timeEstimate": 20,
          "prerequisites": [
            "webpack_basics",
            "npm_package_management"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "bundle_analysis",
            "webpack_plugins"
          ]
        },
        {
          "id": "task_tree_shaking_1",
          "title": "Optimize Imports for Tree Shaking",
          "description": "\nYour task is to refactor a JavaScript application to improve its tree-shaking efficiency, specifically focusing on `lodash` imports. You have an `index.js` file that uses `lodash` functions.\n\n**Requirements:**\n1.  **Refactor `index.js`:** Change the `lodash` imports from global/bad practices to tree-shakable ES Module imports.\n2.  **Ensure functionality:** The application should continue to work correctly.\n3.  **Explain the improvement:** Briefly explain why the refactored code is better for bundle size.\n\nAssume you have `lodash` and `lodash-es` installed.\n",
          "difficulty": "medium",
          "startingCode": "// src/index.js\nimport lodash from 'lodash';\n\nconst array = [1, 2, 3, 4, 5];\n\n// Usage 1: Get a chunk of the array\nconst chunkedArray = lodash.chunk(array, 2);\nconsole.log('Chunked Array:', chunkedArray);\n\n// Usage 2: Flatten a nested array\nconst nestedArray = [1, [2, 3], 4];\nconst flattenedArray = lodash.flatten(nestedArray);\nconsole.log('Flattened Array:', flattenedArray);\n\n// Usage 3: Find the maximum value (assume this is used elsewhere but not shown)\n// const maxVal = lodash.max(array);\n\n// TODO: Refactor the imports and usage to enable better tree shaking\n",
          "solutionCode": "// src/index.js\n// Import only the specific functions needed using ES module paths or lodash-es\nimport chunk from 'lodash/chunk';      // Preferred for direct module import\nimport { flatten } from 'lodash-es'; // Alternative if specific path is not available or less convenient\n\nconst array = [1, 2, 3, 4, 5];\n\n// Usage 1: Get a chunk of the array\nconst chunkedArray = chunk(array, 2);\nconsole.log('Chunked Array:', chunkedArray);\n\n// Usage 2: Flatten a nested array\nconst nestedArray = [1, [2, 3], 4];\nconst flattenedArray = flatten(nestedArray);\nconsole.log('Flattened Array:', flattenedArray);\n\n// Usage 3: Find the maximum value (if `max` was not used, it would be tree-shaken)\n// If 'max' was actually needed, it would be imported: `import max from 'lodash/max';`\n\n/*\nExplanation of Improvement:\nOriginal: `import lodash from 'lodash';` imports the entire lodash library (often the CommonJS build),\nmaking the bundler unable to remove unused functions like `max` even if they're not explicitly called.\n\nRefactored: `import chunk from 'lodash/chunk';` and `import { flatten } from 'lodash-es';`\nuse ES Module syntax or direct paths to specific functions. This allows modern bundlers (like Webpack)\nwith tree shaking enabled to statically analyze the imports. Only the `chunk` and `flatten` functions\n(and their minimal dependencies) will be included in the final bundle. Any other lodash functions\nthat are not explicitly imported and used will be 'shaken off', significantly reducing bundle size.\n*/\n",
          "testCases": [
            "Run the refactored code to ensure `chunkedArray` and `flattenedArray` are correctly calculated.",
            "Simulate a webpack build (e.g., using a basic `webpack.config.js` in production mode) and verify that the bundle size is smaller than with the original `lodash` import, ideally by inspecting the bundle with a tool like `webpack-bundle-analyzer`.",
            "Check that `console.log` outputs match the expected results from the `chunk` and `flatten` operations."
          ],
          "hints": [
            "Recall the 'Good' and 'Even Better' examples for `lodash` imports from the theory.",
            "Consider which version of `lodash` is optimized for ES Modules.",
            "The goal is to import only what's explicitly used."
          ],
          "tags": [
            "tree-shaking",
            "optimization",
            "lodash",
            "javascript",
            "es-modules"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "javascript_modules",
            "webpack_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "bundle_size_reduction",
            "dead_code_elimination"
          ]
        },
        {
          "id": "task_webpack_prod_config_1",
          "title": "Optimize Webpack for Production Performance",
          "description": "\nYour team needs to optimize a webpack configuration for a production environment to ensure maximum performance and caching efficiency.\n\n**Requirements:**\n1.  Set `mode` to `'production'`.\n2.  Configure `output` to use `[contenthash]` for both main bundle filenames and chunk filenames (`.chunk.js`).\n3.  Enable CSS extraction into separate files with content hashing using `MiniCssExtractPlugin`.\n4.  Enable JavaScript and CSS minification using `TerserPlugin` and `CssMinimizerPlugin`.\n5.  Implement aggressive code splitting for all chunks (`chunks: 'all'`, `minSize: 0`, `maxInitialRequests: Infinity`) with a `vendor` cache group that names chunks `npm.<packageName>`.\n6.  Extract the webpack runtime into a `single` chunk.\n7.  Add `CompressionPlugin` to generate gzipped assets.\n8.  Ensure stable module IDs across builds using `webpack.ids.HashedModuleIdsPlugin`.\n\nAssume all necessary plugins (`MiniCssExtractPlugin`, `CssMinimizerPlugin`, `TerserPlugin`, `CompressionPlugin`) are installed. You can also assume `babel-loader` is configured for `.js` files and `css-loader` for `.css` files.\n",
          "difficulty": "hard",
          "startingCode": "const path = require('path');\nconst webpack = require('webpack'); // Needed for webpack.ids.HashedModuleIdsPlugin\n\n// Plugins to be used (assume they are installed)\n// const MiniCssExtractPlugin = require('mini-css-extract-plugin');\n// const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');\n// const TerserPlugin = require('terser-webpack-plugin');\n// const CompressionPlugin = require('compression-webpack-plugin');\n\nmodule.exports = {\n  // TODO: Set mode to production\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    // TODO: Configure filename and chunkFilename with contenthash\n    filename: 'bundle.js',\n    chunkFilename: '[name].js',\n    clean: true, // Good practice to clean dist folder\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        // TODO: Use MiniCssExtractPlugin.loader here\n        use: ['style-loader', 'css-loader'], \n      },\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: 'babel-loader',\n      },\n    ],\n  },\n  optimization: {\n    // TODO: Configure minimization, minimizers, splitChunks, and runtimeChunk\n  },\n  plugins: [\n    // TODO: Add MiniCssExtractPlugin, CompressionPlugin, and HashedModuleIdsPlugin\n  ],\n};\n",
          "solutionCode": "const path = require('path');\nconst webpack = require('webpack');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin');\nconst TerserPlugin = require('terser-webpack-plugin');\nconst CompressionPlugin = require('compression-webpack-plugin');\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].[contenthash].js',\n    chunkFilename: '[name].[contenthash].chunk.js',\n    clean: true,\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [MiniCssExtractPlugin.loader, 'css-loader'],\n      },\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: 'babel-loader',\n      },\n    ],\n  },\n  optimization: {\n    minimize: true,\n    minimizer: [\n      new TerserPlugin({\n        parallel: true,\n        terserOptions: {\n          compress: {\n            drop_console: true,\n          },\n          format: {\n            comments: false,\n          },\n        },\n        extractComments: false,\n      }),\n      new CssMinimizerPlugin(),\n    ],\n    splitChunks: {\n      chunks: 'all',\n      maxInitialRequests: Infinity,\n      minSize: 0,\n      cacheGroups: {\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name(module) {\n            const packageName = module.context.match(/[\\\\/]node_modules[\\\\/](.+?)(?:[\\\\/]|$)/)[1];\n            return `npm.${packageName.replace('@', '')}`;\n          },\n          priority: 20,\n          enforce: true,\n        },\n        defaultVendors: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          priority: 10,\n          reuseExistingChunk: true,\n        },\n        common: {\n          minChunks: 2,\n          priority: -10,\n          reuseExistingChunk: true,\n        },\n        default: {\n          minChunks: 2,\n          priority: -20,\n          reuseExistingChunk: true,\n        },\n      },\n    },\n    runtimeChunk: 'single',\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: '[name].[contenthash].css',\n    }),\n    new CompressionPlugin({\n      test: /\\.js$|\\.css$|\\.html$|\\.svg$/,\n      threshold: 8192,\n      minRatio: 0.8,\n    }),\n    new webpack.ids.HashedModuleIdsPlugin(),\n  ],\n};\n",
          "testCases": [
            "Run `npx webpack --config webpack.config.js`.",
            "Check `dist` folder: Verify `bundle.[contenthash].js`, `[name].[contenthash].chunk.js`, and `[name].[contenthash].css` files exist.",
            "Verify `dist` folder: Look for `runtime.[contenthash].js` and gzipped `.gz` or `.br` versions of your assets (e.g., `bundle.js.gz`, `main.css.gz`).",
            "Inspect bundle sizes using `webpack-bundle-analyzer` (if configured) to confirm minification and code splitting effectiveness.",
            "Make a small change to `src/index.js` and rebuild; verify only `runtime` and the affected JS chunks' hashes change, not all others (due to stable module IDs)."
          ],
          "hints": [
            "Remember that `MiniCssExtractPlugin.loader` is used in `module.rules` for CSS.",
            "`TerserPlugin` and `CssMinimizerPlugin` go into `optimization.minimizer`.",
            "The `name` function in `cacheGroups` is crucial for creating distinct vendor chunk names.",
            "`webpack.ids.HashedModuleIdsPlugin` is part of the `webpack` object directly.",
            "Consider `clean: true` in `output` to ensure a clean build directory."
          ],
          "tags": [
            "webpack",
            "performance",
            "optimization",
            "production",
            "caching",
            "code-splitting",
            "plugins"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "webpack_basics",
            "webpack_plugins",
            "webpack_loaders",
            "javascript_modules"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "bundle_size_reduction",
            "caching_strategies",
            "front_end_architecture"
          ]
        },
        {
          "id": "task_webpack_prod_config_2",
          "title": "Debug Webpack Production Bundle Size",
          "description": "\nYou are given a `webpack.config.js` and `package.json` for a React application. The production bundle size is unexpectedly large (e.g., 2MB+), and you suspect a third-party library is being fully included without proper tree shaking. \n\n**Your task is to:**\n1.  Identify the likely cause of poor tree shaking for `lodash` based on the provided `package.json` and a common `webpack.config.js` setup.\n2.  Modify the `webpack.config.js` and suggest a change to `package.json` to enable better tree shaking for such libraries.\n\n**`package.json` (partial):**\n```json\n{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"lodash\": \"^4.17.21\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\"\n  },\n  \"scripts\": {\n    \"build\": \"webpack --config webpack.config.js\"\n  },\n  \"main\": \"dist/main.js\",\n  \"module\": \"dist/es/main.js\" // This field indicates an ES module entry point\n}\n```\n\n**`webpack.config.js` (partial):**\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: { presets: ['@babel/preset-env', '@babel/preset-react'] }\n        }\n      }\n    ]\n  },\n  // optimization: { /* Nothing specific for tree shaking here */ }\n};\n```\n\n**`src/index.js` (partial):**\n```javascript\nimport _ from 'lodash';\n\nconst numbers = [1, 2, 3, 4];\nconst doubled = _.map(numbers, n => n * 2);\nconsole.log(doubled);\n\n// Assume other lodash functions like _.debounce, _.throttle are *not* used\n// elsewhere in the application.\n```\n",
          "difficulty": "hard",
          "startingCode": "const path = require('path');\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: { presets: ['@babel/preset-env', '@babel/preset-react'] }\n        }\n      }\n    ]\n  },\n  // TODO: Add optimization for tree shaking\n};\n\n// src/index.js (for context)\n/*\nimport _ from 'lodash';\nconst numbers = [1, 2, 3, 4];\nconst doubled = _.map(numbers, n => n * 2);\nconsole.log(doubled);\n*/\n\n// package.json (for context)\n/*\n{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"lodash\": \"^4.17.21\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\"\n  },\n  \"scripts\": {\n    \"build\": \"webpack --config webpack.config.js\"\n  },\n  \"main\": \"dist/main.js\",\n  \"module\": \"dist/es/main.js\"\n}\n*/\n",
          "solutionCode": "// webpack.config.js\nconst path = require('path');\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: { presets: ['@babel/preset-env', '@babel/preset-react'] }\n        }\n      }\n    ]\n  },\n  optimization: {\n    usedExports: true, // Crucial for marking unused exports\n    minimize: true,    // Essential for TerserPlugin to remove dead code\n    minimizer: [\n      new (require('terser-webpack-plugin'))(), // Add TerserPlugin for minification and dead code removal\n    ],\n  },\n};\n\n// src/index.js (Refactored for better tree shaking)\n/*\nimport { map } from 'lodash'; // Using named import directly from lodash, which works if lodash's package.json has 'module' field set correctly, or better: 'lodash-es'\n// OR: import map from 'lodash/map'; // Even better: direct module import if available and side-effect free\n\nconst numbers = [1, 2, 3, 4];\nconst doubled = map(numbers, n => n * 2);\nconsole.log(doubled);\n*/\n\n// package.json (Suggested change)\n/*\n{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"lodash\": \"^4.17.21\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\"\n  },\n  \"scripts\": {\n    \"build\": \"webpack --config webpack.config.js\"\n  },\n  \"main\": \"dist/main.js\",\n  \"module\": \"dist/es/main.js\",\n  \"sideEffects\": false // <--- ADD THIS LINE to allow webpack to safely tree-shake\n}\n*/\n",
          "testCases": [
            "**Original Problem Diagnosis:** Explain why `import _ from 'lodash';` and the missing `optimization` config lead to poor tree shaking for `lodash`.",
            "**Proposed `src/index.js` Refactoring:** Show the import change from `import _ from 'lodash';` to `import { map } from 'lodash';` (or `import map from 'lodash/map';` for best practice).",
            "**Proposed `webpack.config.js` Changes:** Ensure `optimization.usedExports: true` is set (it's default in production, but good to show intent) and `TerserPlugin` is included in `optimization.minimizer`.",
            "**Proposed `package.json` Change:** Suggest adding `\"sideEffects\": false` to the application's `package.json` (or the `lodash` package's `package.json` if you were the library author, but for this task, it's about *your* app's configuration for the library)."
          ],
          "hints": [
            "Focus on the `import` statement in `src/index.js` and how it affects static analysis.",
            "Recall the prerequisites for effective tree shaking mentioned in the theory.",
            "Think about what webpack needs to know to safely remove unused code, beyond just using ES Modules.",
            "What webpack `optimization` settings are specifically related to identifying and removing unused exports?"
          ],
          "tags": [
            "webpack",
            "tree-shaking",
            "optimization",
            "bundle-size",
            "debugging",
            "performance"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "webpack_optimization",
            "tree_shaking_theory",
            "javascript_modules"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "dead_code_elimination",
            "package_json_side_effects",
            "terser_plugin"
          ]
        },
        {
          "id": "task_ssr_1",
          "title": "Implement Basic React Server-Side Rendering with Express",
          "description": "\nYour task is to set up a basic React Server-Side Rendering (SSR) application using Express. You will create a simple React component, configure an Express server to render it to HTML, and ensure the client-side React code hydrates this server-generated HTML.\n\n**Requirements:**\n1.  Create a simple React `App` component (e.g., displaying a greeting and a counter).\n2.  Set up an Express server to handle all routes (`app.get('*')`).\n3.  On the server, use `react-dom/server.renderToString` to convert the React `App` component into an HTML string.\n4.  Embed the server-rendered HTML into a basic HTML template.\n5.  Include a `<script>` tag in the HTML template that points to a client-side bundle (e.g., `/bundle.js`).\n6.  On the client side, use `ReactDOM.hydrateRoot` (for React 18+) to hydrate the server-generated HTML.\n7.  Assume two webpack configurations: `webpack.client.js` and `webpack.server.js` are used to build `dist/bundle.js` and `dist/server.bundle.js` respectively. The task focuses on `server.js` and `src/index.js`.\n\n**Provided Files (conceptual):**\n*   `src/App.js` (Your React component)\n*   `src/index.js` (Client-side entry point)\n*   `server.js` (Express server entry point)\n*   `dist/bundle.js` (Client-side webpack output)\n\n",
          "difficulty": "hard",
          "startingCode": "// server.js\nimport express from 'express';\nimport React from 'react';\nimport { renderToString } from 'react-dom/server';\nimport App from './src/App'; // Your React root component\nimport path from 'path';\n\nconst app = express();\n\n// Serve static files from the 'dist' directory (for client-side bundle)\napp.use(express.static(path.resolve(__dirname, 'dist')));\n\napp.get('*', (req, res) => {\n  // TODO: Render React App to HTML string\n  const html = '<!-- TODO: Server-rendered HTML here -->';\n  \n  res.send(`\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>My SSR App</title>\n      </head>\n      <body>\n        <div id=\"root\">${html}</div>\n        <script src=\"/bundle.js\"></script> <!-- Client-side bundle for hydration -->\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => {\n  console.log('Server is listening on port 3000');\n});\n\n// src/App.js\nimport React, { useState } from 'react';\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <h1>Hello SSR!</h1>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nexport default App;\n\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client'; // For React 18+\nimport App from './App';\n\n// TODO: Hydrate the application\n// const root = ReactDOM.createRoot(document.getElementById('root'));\n// root.render(<App />); // This is for CSR, change for SSR hydration\n",
          "solutionCode": "// server.js\nimport express from 'express';\nimport React from 'react';\nimport { renderToString } from 'react-dom/server';\nimport App from './src/App';\nimport path from 'path';\n\nconst app = express();\n\napp.use(express.static(path.resolve(__dirname, 'dist')));\n\napp.get('*', (req, res) => {\n  const html = renderToString(<App />); // Render React App to HTML string\n  \n  res.send(`\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>My SSR App</title>\n      </head>\n      <body>\n        <div id=\"root\">${html}</div>\n        <script src=\"/bundle.js\"></script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => {\n  console.log('Server is listening on port 3000');\n});\n\n// src/App.js\nimport React, { useState } from 'react';\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <h1>Hello SSR!</h1>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nexport default App;\n\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\n// Hydrate the application using ReactDOM.hydrateRoot for React 18+\nconst root = ReactDOM.hydrateRoot(\n  document.getElementById('root'),\n  <App />\n);\n",
          "testCases": [
            "Run the Node.js server (`node server.js` after building).",
            "Open browser to `http://localhost:3000`.",
            "View page source (Ctrl+U or Cmd+Option+U): Verify that the initial HTML contains the `<h1>Hello SSR!</h1>` and `<p>Count: 0</p>` elements, meaning it was server-rendered.",
            "Interact with the page: Click the 'Increment' button. Verify the counter updates, indicating client-side React has successfully hydrated and taken over.",
            "Check browser console for hydration errors (e.g., 'Warning: Expected server HTML to contain a matching...'). There should be none."
          ],
          "hints": [
            "Remember to use `renderToString` from `react-dom/server` on the server.",
            "On the client, for React 18+, use `ReactDOM.hydrateRoot` instead of `ReactDOM.createRoot` to attach to existing HTML.",
            "Ensure the server serves the client-side JavaScript bundle correctly (e.g., using `express.static`).",
            "The `div` with `id=\"root\"` is critical for both server rendering and client hydration."
          ],
          "tags": [
            "ssr",
            "react",
            "express",
            "node.js",
            "frontend-architecture"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_basics",
            "node.js_basics",
            "express_basics",
            "webpack_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "hydration",
            "render_to_string",
            "client_server_architecture"
          ]
        }
      ]
    }
  }
]