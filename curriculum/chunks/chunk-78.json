[
  {
    "id": "86533d9a-4bcf-47c4-9c31-377c497659fd",
    "startLine": 16200,
    "endLine": 16299,
    "processedDate": "2025-06-17T15:20:01.107Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_oop_fundamentals_vehicle_parkinglot_structure",
          "title": "Object-Oriented Programming Fundamentals: Vehicle and ParkingLot Class Structure",
          "content": "This section introduces the foundational concepts of Object-Oriented Programming (OOP) in JavaScript through the definition of `Vehicle` and `ParkingLot` classes. OOP principles like encapsulation, abstraction, and modularity are demonstrated by structuring the application logic into reusable and distinct entities.\n\n## Vehicle Class\nThe `Vehicle` class serves as a blueprint for creating vehicle objects. Each `Vehicle` instance encapsulates properties such as `registrationNumber` and `color`. The `constructor` method is used to initialize these properties when a new `Vehicle` object is created.\n\n## ParkingLot Class\nThe `ParkingLot` class manages the parking facility. It encapsulates the state of the parking lot (e.g., available slots, occupied slots) and provides methods to interact with it, such as parking, unparking, and querying vehicle information. This design promotes a clear separation of concerns, making the code more organized and maintainable.\n\n### Key Concepts\n-   **Classes (`class` keyword):** A template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods).\n-   **Constructors (`constructor` method):** A special method for creating and initializing an object created with a `class`.\n-   **`this` keyword:** Refers to the current instance of the class within its methods, allowing access to its properties and other methods.\n-   **Encapsulation:** Bundling data (properties) and methods (functions) that operate on the data into a single unit (class), and restricting direct access to some of the object's components.",
          "examples": [
            {
              "id": "example_vehicle_class_1",
              "title": "Defining the Vehicle Class",
              "code": "class Vehicle {\n  constructor(registrationNumber, color) {\n    this.registrationNumber = registrationNumber;\n    this.color = color;\n  }\n}",
              "explanation": "This code defines the `Vehicle` class with a constructor that takes `registrationNumber` and `color` as arguments and assigns them to the instance properties. This allows creating vehicle objects with specific details.",
              "language": "javascript"
            },
            {
              "id": "example_parkinglot_structure_1",
              "title": "Basic ParkingLot Class Structure",
              "code": "class ParkingLot {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.slots = new Array(capacity).fill(null);\n    this.availableSlots = new Set();\n    for (let i = 0; i < capacity; i++) {\n      this.availableSlots.add(i);\n    }\n  }\n\n  // Other methods will go here\n  parkVehicle(vehicle) { /* ... */ }\n  removeVehicle(slotNumber) { /* ... */ }\n  // ...\n}",
              "explanation": "This snippet shows the basic structure of the `ParkingLot` class, including its constructor which initializes the total capacity, an array `slots` to hold vehicles, and a `Set` `availableSlots` to keep track of empty slots. The constructor pre-populates `availableSlots` with all slot numbers.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_class_definition_1",
            "question_this_keyword_1",
            "question_oop_principles_1",
            "question_constructor_purpose_1"
          ],
          "relatedTasks": [
            "task_refactor_vehicle_parking_classes"
          ],
          "tags": [
            "OOP",
            "Classes",
            "Constructor",
            "this",
            "JavaScript",
            "Fundamentals"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_basics",
            "functions"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "beginner",
          "requiredFor": [
            "data_structures_in_js",
            "design_patterns"
          ]
        },
        {
          "id": "theory_parkinglot_initialization_data_structures",
          "title": "Parking Lot Initialization and Data Structure Choices",
          "content": "The `ParkingLot` class's constructor is crucial for setting up the initial state of the parking facility. It takes a `capacity` argument, which determines the total number of parking slots available. The choice of internal data structures significantly impacts the efficiency of parking operations.\n\n## Internal Data Structures\n-   **`slots` (Array):** An array of size `capacity` is used to represent the physical parking slots. Each index in the array corresponds to a slot number. Initially, all slots are `null`, indicating they are empty. When a vehicle is parked, the corresponding array element is updated with the `Vehicle` object.\n    -   **Advantage:** Direct access to a slot by its number (index). Useful for `removeVehicle` and querying by slot number.\n    -   **Disadvantage:** Can lead to sparse arrays if many slots are empty and accessed by iteration.\n\n-   **`availableSlots` (Set):** A `Set` is used to store the numbers of all currently available (empty) parking slots. The `Set` is initialized in the constructor by adding all slot numbers from `0` to `capacity - 1`.\n    -   **Why a `Set`?** `Set` objects are collections of unique values. They offer excellent performance for operations like:\n        -   **Adding (`add()`):** Constant time on average.\n        -   **Deleting (`delete()`):** Constant time on average.\n        -   **Checking for existence (`has()`):** Constant time on average.\n        -   **Getting any element (`values().next().value`):** Efficient way to pick an arbitrary available slot.\n    -   This makes `Set` an ideal choice for quickly managing the pool of available slots, ensuring that `parkVehicle` and `removeVehicle` operations are efficient in determining and updating slot availability.",
          "examples": [
            {
              "id": "example_parkinglot_constructor_1",
              "title": "ParkingLot Constructor Implementation",
              "code": "class ParkingLot {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.slots = new Array(capacity).fill(null); // Array to hold vehicle objects or null\n    this.availableSlots = new Set(); // Set to store available slot numbers\n\n    // Populate availableSlots initially\n    for (let i = 0; i < capacity; i++) {\n      this.availableSlots.add(i);\n    }\n  }\n}",
              "explanation": "This constructor initializes `capacity`, creates a `slots` array filled with `null`s, and populates the `availableSlots` Set with all possible slot numbers. This setup ensures the parking lot starts in a known, empty state, ready for operations.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_set_vs_array_1",
            "question_available_slots_set_1",
            "question_initial_state_1",
            "question_data_structure_choice_1"
          ],
          "relatedTasks": [
            "task_optimize_parkinglot_datastructures"
          ],
          "tags": [
            "Data Structures",
            "Set",
            "Array",
            "Initialization",
            "Efficiency",
            "JavaScript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "javascript_sets"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "performance_optimization",
            "system_design"
          ]
        },
        {
          "id": "theory_parking_unparking_operations",
          "title": "Parking and Unparking Operations: `parkVehicle` and `removeVehicle`",
          "content": "The core functionality of the `ParkingLot` class revolves around parking and unparking vehicles. These operations involve careful management of both the `slots` array and the `availableSlots` Set, along with robust error handling.\n\n## `parkVehicle(vehicle)` Method\nThis method attempts to park a given `vehicle` object. It performs the following steps:\n1.  **Check for Availability:** It first checks if there are any available slots using `this.availableSlots.size === 0`. If no slots are available, it returns an error message.\n2.  **Retrieve Slot:** If slots are available, it gets the *first* available slot number from the `Set` using `this.availableSlots.values().next().value`. The `values().next().value` pattern is a common way to get an arbitrary element from a Set (as Sets do not have direct indexing).\n3.  **Occupy Slot:** The retrieved slot number is then removed from `this.availableSlots` using `delete()`, and the `vehicle` object is placed into the `this.slots` array at that index.\n4.  **Return Status:** It returns an object indicating success and the assigned slot number.\n\n## `removeVehicle(slotNumber)` Method\nThis method attempts to remove a vehicle from a specific `slotNumber`. It includes several validation checks:\n1.  **Invalid Slot Number:** It checks if the provided `slotNumber` is within the valid range (`0` to `capacity - 1`).\n2.  **Empty Slot:** It verifies if the slot is already empty (`this.slots[slotNumber] === null`). If so, it returns an error.\n3.  **Remove Vehicle:** If the slot is valid and occupied, the `Vehicle` object is retrieved, the slot in `this.slots` array is set back to `null`, and the `slotNumber` is added back to `this.availableSlots` Set.\n4.  **Return Status:** It returns an object indicating success and the removed `vehicle` object.",
          "examples": [
            {
              "id": "example_park_vehicle_1",
              "title": "parkVehicle Method Implementation",
              "code": "parkVehicle(vehicle) {\n  if (this.availableSlots.size === 0) {\n    return { success: false, message: \"No available parking slots\" };\n  }\n  \n  // Get the first available slot\n  const slotNumber = this.availableSlots.values().next().value;\n  this.availableSlots.delete(slotNumber);\n  \n  // Park the vehicle\n  this.slots[slotNumber] = vehicle;\n  \n  return { \n    success: true, \n    message: `Vehicle parked successfully`,\n    slotNumber \n  };\n}",
              "explanation": "This example demonstrates how `parkVehicle` finds an available slot using the `Set`, removes it from the `availableSlots` pool, and places the vehicle in the `slots` array, returning the outcome.",
              "language": "javascript"
            },
            {
              "id": "example_remove_vehicle_1",
              "title": "removeVehicle Method Implementation",
              "code": "removeVehicle(slotNumber) {\n  if (slotNumber < 0 || slotNumber >= this.capacity) {\n    return { success: false, message: \"Invalid slot number\" };\n  }\n  \n  if (this.slots[slotNumber] === null) {\n    return { success: false, message: \"Slot is already empty\" };\n  }\n  \n  // Remove the vehicle\n  const vehicle = this.slots[slotNumber];\n  this.slots[slotNumber] = null;\n  this.availableSlots.add(slotNumber);\n  \n  return { \n    success: true, \n    message: \"Vehicle removed successfully\", \n    vehicle \n  };\n}",
              "explanation": "This code for `removeVehicle` shows input validation for the slot number, checks if the slot is actually occupied, and then clears the slot while returning its number to the `availableSlots` Set.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_park_unpark_logic_1",
            "question_error_handling_1",
            "question_set_operations_1",
            "question_return_values_1"
          ],
          "relatedTasks": [
            "task_implement_advanced_parking",
            "task_handle_parking_errors"
          ],
          "tags": [
            "Methods",
            "Parking Logic",
            "Set Operations",
            "Error Handling",
            "Vehicle Management"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_operators",
            "conditional_statements",
            "javascript_sets"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "system_design",
            "backend_api_design"
          ]
        },
        {
          "id": "theory_query_operations",
          "title": "Parking Lot Query Operations: Retrieving Information",
          "content": "The `ParkingLot` class provides several methods to query the state of parked vehicles and available slots. These methods leverage JavaScript's powerful array manipulation functions and Set conversions to efficiently retrieve specific information.\n\n## `getVehiclesByColor(color)`\nThis method filters all currently parked vehicles and returns those matching a specified `color`. It returns an array of objects, where each object contains the `vehicle` details and its `slotNumber`.\n-   Uses `filter()` to select vehicles that are not `null` and match the `color`.\n-   Uses `map()` to transform the filtered `vehicle` and `index` (slotNumber) into the desired object format.\n\n## `getSlotByRegistration(registrationNumber)`\nThis method finds the slot number of a vehicle given its `registrationNumber`. It returns the index (slot number) if found, otherwise `null`.\n-   Uses `findIndex()` to iterate through the `slots` array and find the index of the first vehicle whose `registrationNumber` matches.\n\n## `getSlotsByColor(color)`\nSimilar to `getVehiclesByColor`, but specifically returns an array of *slot numbers* for vehicles of a given `color`.\n-   First `map()` to create objects containing both `vehicle` and `index`.\n-   Then `filter()` based on vehicle existence and color.\n-   Final `map()` to extract only the `index` (slot number).\n\n## `getAvailableSlots()`\nThis method returns an array of all currently unoccupied slot numbers.\n-   Uses `Array.from()` to convert the `Set` of `availableSlots` into a standard JavaScript `Array`.",
          "examples": [
            {
              "id": "example_get_vehicles_by_color_1",
              "title": "getVehiclesByColor Implementation",
              "code": "getVehiclesByColor(color) {\n  return this.slots\n    .filter(vehicle => vehicle && vehicle.color === color)\n    .map((vehicle, index) => ({ vehicle, slotNumber: index }));\n}",
              "explanation": "This method efficiently finds all vehicles of a certain color. The `filter` ensures only occupied slots with a matching color are considered, and `map` transforms the result into a more useful format including the slot number.",
              "language": "javascript"
            },
            {
              "id": "example_get_slot_by_registration_1",
              "title": "getSlotByRegistration Implementation",
              "code": "getSlotByRegistration(registrationNumber) {\n  const index = this.slots.findIndex(\n    vehicle => vehicle && vehicle.registrationNumber === registrationNumber\n  );\n  \n  return index !== -1 ? index : null;\n}",
              "explanation": "`findIndex` is used here to locate the slot number of a vehicle by its registration. It returns the index if found, or `-1` which is then converted to `null` for a clearer representation of 'not found'.",
              "language": "javascript"
            },
            {
              "id": "example_get_available_slots_1",
              "title": "getAvailableSlots Implementation",
              "code": "getAvailableSlots() {\n  return Array.from(this.availableSlots);\n}",
              "explanation": "This simple method demonstrates converting a `Set` to an `Array`, which is often useful when a list of items is needed from a `Set` for iteration or display.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_array_methods_1",
            "question_query_efficiency_1",
            "question_set_to_array_1",
            "question_filter_map_chaining_1"
          ],
          "relatedTasks": [
            "task_implement_additional_queries"
          ],
          "tags": [
            "Querying",
            "Array Methods",
            "filter",
            "map",
            "findIndex",
            "Set to Array",
            "Information Retrieval"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "javascript_loops",
            "javascript_sets"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_processing",
            "api_development"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_class_definition_1",
          "topic": "Class Definition and Instantiation",
          "level": "easy",
          "type": "mcq",
          "question": "Which keyword is used in JavaScript to define a class?",
          "answer": "class",
          "options": [
            "function",
            "object",
            "class",
            "define"
          ],
          "analysisPoints": [
            "Tests basic knowledge of JavaScript class syntax.",
            "Differentiates between functions (which can also act as constructors pre-ES6) and explicit class definitions."
          ],
          "keyConcepts": [
            "Classes",
            "ES6 syntax",
            "OOP fundamentals"
          ],
          "evaluationCriteria": [
            "Correct recall of ES6 class syntax."
          ],
          "example": "```javascript\n// Correct usage:\nclass MyClass {\n  constructor() {}\n}\n\n// Incorrect usage example:\n// function MyClass() {} // This is a constructor function, not a class definition\n```",
          "tags": [
            "OOP",
            "Classes",
            "Syntax",
            "JavaScript"
          ],
          "prerequisites": [
            "javascript_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_this_keyword_1",
          "topic": "The `this` Keyword in Class Methods",
          "level": "medium",
          "type": "mcq",
          "question": "In the `parkVehicle` method of the `ParkingLot` class, what does `this` refer to?",
          "answer": "The current instance of the ParkingLot class.",
          "options": [
            "The `vehicle` object passed as an argument.",
            "The `parkVehicle` method itself.",
            "The global window object.",
            "The current instance of the ParkingLot class."
          ],
          "analysisPoints": [
            "Tests understanding of `this` context within class methods.",
            "Distinguishes `this` from method arguments or global objects."
          ],
          "keyConcepts": [
            "this keyword",
            "Class methods",
            "Context",
            "OOP"
          ],
          "evaluationCriteria": [
            "Understanding of lexical `this` binding in classes.",
            "Ability to identify the correct object instance."
          ],
          "example": "```javascript\nclass ExampleClass {\n  constructor(name) {\n    this.name = name;\n  }\n  greet() {\n    return `Hello, ${this.name}!`; // 'this' refers to the instance (e.g., myInstance)\n  }\n}\nconst myInstance = new ExampleClass('Alice');\nconsole.log(myInstance.greet()); // Output: Hello, Alice!\n```",
          "tags": [
            "OOP",
            "this",
            "Context",
            "Classes",
            "JavaScript"
          ],
          "prerequisites": [
            "javascript_functions",
            "oop_fundamentals"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_set_vs_array_1",
          "topic": "Choosing Data Structures (Set vs. Array)",
          "level": "medium",
          "type": "open",
          "question": "The `ParkingLot` class uses a `Set` for `availableSlots` and an `Array` for `slots`. Explain why a `Set` is a good choice for `availableSlots` and an `Array` is suitable for `slots`, considering the typical operations performed on each.",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Demonstrates understanding of `Set` properties: unique values, efficient add/delete/has operations (average O(1)).",
            "Demonstrates understanding of `Array` properties: ordered collection, direct index access (O(1)), suitable for representing fixed-size slots.",
            "Compares and contrasts the use cases for each data structure in the context of the parking lot problem.",
            "Discusses how the chosen data structures optimize specific operations (`parkVehicle`, `removeVehicle`, `getSlotByRegistration`)."
          ],
          "keyConcepts": [
            "Set",
            "Array",
            "Data structures",
            "Time complexity",
            "Optimization"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of explanation regarding `Set` and `Array` characteristics.",
            "Ability to relate data structure choice to operational efficiency.",
            "Comprehensive comparison of use cases within the given context."
          ],
          "example": "```javascript\n// Set operations for available slots:\nconst available = new Set([1, 2, 3]);\navailable.add(4); // O(1) average\navailable.delete(2); // O(1) average\navailable.has(1); // O(1) average\n\n// Array operations for occupied slots:\nconst slots = [null, 'Car A', 'Car B', null];\nslots[1]; // O(1) direct access\nslots.findIndex(v => v === 'Car B'); // O(N) search\n```",
          "tags": [
            "Data Structures",
            "Set",
            "Array",
            "Performance",
            "Interview Question"
          ],
          "prerequisites": [
            "javascript_sets",
            "javascript_arrays",
            "time_complexity_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_park_vehicle_logic_1",
          "topic": "Parking Logic and Edge Cases",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `parkVehicle` method. What would be the expected output if `parkingLot.parkVehicle(car4)` is called when all slots are already occupied in a `ParkingLot` instance?",
          "answer": "{ success: false, message: \"No available parking slots\" }",
          "options": [
            "{ success: true, message: \"Vehicle parked successfully\", slotNumber: -1 }",
            "{ success: false, message: \"Parking lot is full\" }",
            "An error would be thrown.",
            "{ success: false, message: \"No available parking slots\" }"
          ],
          "analysisPoints": [
            "Tests understanding of the `parkVehicle` method's `if (this.availableSlots.size === 0)` condition.",
            "Verifies knowledge of the specific error message returned when no slots are available.",
            "Highlights the importance of handling edge cases (full parking lot)."
          ],
          "keyConcepts": [
            "Method logic",
            "Edge cases",
            "Error handling",
            "Return values"
          ],
          "evaluationCriteria": [
            "Accurate recall of the method's behavior under specific conditions.",
            "Understanding of the method's return structure for failure cases."
          ],
          "example": "```javascript\nclass ParkingLot {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.slots = new Array(capacity).fill(null);\n    this.availableSlots = new Set();\n    for (let i = 0; i < capacity; i++) this.availableSlots.add(i);\n  }\n  parkVehicle(vehicle) {\n    if (this.availableSlots.size === 0) {\n      return { success: false, message: \"No available parking slots\" };\n    }\n    const slotNumber = this.availableSlots.values().next().value;\n    this.availableSlots.delete(slotNumber);\n    this.slots[slotNumber] = vehicle;\n    return { success: true, message: `Vehicle parked successfully`, slotNumber };\n  }\n}\n\nconst parkingLot = new ParkingLot(1);\nconst car1 = { registrationNumber: \"A\", color: \"Red\" };\nconst car2 = { registrationNumber: \"B\", color: \"Blue\" };\n\nparkingLot.parkVehicle(car1); // Parks car1\nconsole.log(parkingLot.parkVehicle(car2)); // Calls parkVehicle when full\n// Expected output: { success: false, message: \"No available parking slots\" }\n```",
          "tags": [
            "Methods",
            "Logic",
            "Edge Cases",
            "Error Handling"
          ],
          "prerequisites": [
            "conditional_statements"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_remove_vehicle_validation_1",
          "topic": "Input Validation in `removeVehicle`",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following scenarios would cause the `removeVehicle` method to return `{ success: false, message: 'Invalid slot number' }`?",
          "answer": "Calling `parkingLot.removeVehicle(-1)` or `parkingLot.removeVehicle(parkingLot.capacity)`",
          "options": [
            "Calling `parkingLot.removeVehicle(5)` when slot 5 is already empty.",
            "Calling `parkingLot.removeVehicle(0)` when slot 0 is occupied.",
            "Calling `parkingLot.removeVehicle(-1)` or `parkingLot.removeVehicle(parkingLot.capacity)`",
            "Calling `parkingLot.removeVehicle()` with no arguments."
          ],
          "analysisPoints": [
            "Tests understanding of the `removeVehicle` method's input validation for `slotNumber`.",
            "Distinguishes between 'invalid slot number' and 'slot already empty' error messages.",
            "Reinforces awareness of array boundary conditions."
          ],
          "keyConcepts": [
            "Input validation",
            "Method parameters",
            "Edge cases",
            "Error messages"
          ],
          "evaluationCriteria": [
            "Accurate identification of the condition that triggers a specific error message.",
            "Knowledge of array indexing bounds."
          ],
          "example": "```javascript\nclass ParkingLot {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.slots = new Array(capacity).fill(null);\n    this.availableSlots = new Set();\n    for (let i = 0; i < capacity; i++) this.availableSlots.add(i);\n  }\n  removeVehicle(slotNumber) {\n    if (slotNumber < 0 || slotNumber >= this.capacity) {\n      return { success: false, message: \"Invalid slot number\" };\n    }\n    if (this.slots[slotNumber] === null) {\n      return { success: false, message: \"Slot is already empty\" };\n    }\n    const vehicle = this.slots[slotNumber];\n    this.slots[slotNumber] = null;\n    this.availableSlots.add(slotNumber);\n    return { success: true, message: \"Vehicle removed successfully\", vehicle };\n  }\n}\n\nconst parkingLot = new ParkingLot(5);\nconsole.log(parkingLot.removeVehicle(-1)); // Expected: { success: false, message: \"Invalid slot number\" }\nconsole.log(parkingLot.removeVehicle(5));  // Expected: { success: false, message: \"Invalid slot number\" }\nconsole.log(parkingLot.removeVehicle(0));  // Expected: { success: false, message: \"Slot is already empty\" } (if slot 0 is empty)\n```",
          "tags": [
            "Input Validation",
            "Edge Cases",
            "Methods",
            "Error Handling"
          ],
          "prerequisites": [
            "conditional_statements"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_method_get_slots_by_color_1",
          "topic": "Array Methods: `filter` and `map` Chaining",
          "level": "hard",
          "type": "code",
          "question": "The `getSlotsByColor` method uses a chain of `map` and `filter` operations. Rewrite this method to achieve the same result using a single `forEach` loop and an array to collect the results. Discuss the trade-offs between the two approaches.",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Demonstrates ability to refactor array method chains into imperative loops.",
            "Requires understanding of how `map` and `filter` operate internally.",
            "Prompts discussion on code readability, functional programming paradigms vs. imperative, and potential performance implications for very large arrays."
          ],
          "keyConcepts": [
            "Array methods",
            "`forEach` loop",
            "`filter`",
            "`map`",
            "Refactoring",
            "Performance trade-offs",
            "Functional vs Imperative programming"
          ],
          "evaluationCriteria": [
            "Correct implementation of the `forEach` version.",
            "Insightful discussion of pros and cons for both approaches (readability, conciseness, performance, intermediate array creation).",
            "Adherence to the original method's logic."
          ],
          "example": "```javascript\n// Original (using map and filter chaining):\ngetSlotsByColor(color) {\n  return this.slots\n    .map((vehicle, index) => ({ vehicle, index }))\n    .filter(item => item.vehicle && item.vehicle.color === color)\n    .map(item => item.index);\n}\n\n// Rewritten using forEach:\ngetSlotsByColorRefactored(color) {\n  const resultSlots = [];\n  for (let i = 0; i < this.slots.length; i++) {\n    const vehicle = this.slots[i];\n    if (vehicle && vehicle.color === color) {\n      resultSlots.push(i);\n    }\n  }\n  return resultSlots;\n}\n\n// Trade-offs discussion:\n// Chaining `map` and `filter` is often more declarative, concise, and readable for simple transformations.\n// It can sometimes create intermediate arrays, which might have a minor performance overhead for extremely large datasets.\n// A `forEach` loop (or traditional `for` loop) can be more performant as it avoids intermediate array creation and offers more control.\n// However, it can be more verbose and less 'functional' in style.\n```",
          "tags": [
            "Code Challenge",
            "Array Methods",
            "Refactoring",
            "Performance",
            "Functional Programming"
          ],
          "prerequisites": [
            "javascript_arrays",
            "javascript_loops",
            "javascript_functions"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_flashcard_set_purpose",
          "topic": "Set Data Structure Purpose",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using a `Set` for `availableSlots` in the `ParkingLot` class?",
          "answer": "Efficient (average O(1)) addition, deletion, and checking for existence of unique slot numbers.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Set",
            "Data Structures",
            "Efficiency"
          ],
          "evaluationCriteria": [
            "Quick recall of `Set` advantages."
          ],
          "example": "N/A",
          "tags": [
            "Flashcard",
            "Set",
            "Data Structures"
          ],
          "prerequisites": [
            "javascript_sets"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_flashcard_get_slot_by_reg",
          "topic": "Getting Slot by Registration Number",
          "level": "easy",
          "type": "flashcard",
          "question": "Which `ParkingLot` method would you use to find the parking slot number of a vehicle given its registration number?",
          "answer": "`getSlotByRegistration(registrationNumber)`",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Method usage",
            "Query operations"
          ],
          "evaluationCriteria": [
            "Quick recall of method names and their purpose."
          ],
          "example": "N/A",
          "tags": [
            "Flashcard",
            "Methods",
            "Querying"
          ],
          "prerequisites": [
            "oop_fundamentals"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_coding_implement_is_parked",
          "topic": "Adding a New Query Method",
          "level": "medium",
          "type": "code",
          "question": "Add a new method `isVehicleParked(registrationNumber)` to the `ParkingLot` class. This method should return `true` if a vehicle with the given registration number is currently parked, and `false` otherwise.",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Requires understanding of how to iterate through `slots`.",
            "Tests ability to use `findIndex` or a loop to search for a specific vehicle property.",
            "Ensures correct handling of `null` values in `slots`.",
            "Demonstrates modular thinking by building on existing `getSlotByRegistration` logic."
          ],
          "keyConcepts": [
            "Class methods",
            "Array iteration",
            "Conditional logic",
            "Boolean return values"
          ],
          "evaluationCriteria": [
            "Correct implementation of the search logic.",
            "Efficiency of the search (e.g., direct use of `findIndex`).",
            "Adherence to class structure."
          ],
          "example": "```javascript\nclass ParkingLot {\n  // ... (previous constructor and methods)\n\n  getSlotByRegistration(registrationNumber) {\n    const index = this.slots.findIndex(\n      vehicle => vehicle && vehicle.registrationNumber === registrationNumber\n    );\n    return index !== -1 ? index : null;\n  }\n\n  // New method implementation:\n  isVehicleParked(registrationNumber) {\n    return this.getSlotByRegistration(registrationNumber) !== null;\n  }\n}\n\n// Example usage:\nconst parkingLot = new ParkingLot(2);\nconst car1 = new Vehicle(\"ABC\", \"Red\");\nparkingLot.parkVehicle(car1);\nconsole.log(parkingLot.isVehicleParked(\"ABC\")); // true\nconsole.log(parkingLot.isVehicleParked(\"XYZ\")); // false\n```",
          "tags": [
            "Coding Challenge",
            "Methods",
            "Querying",
            "Array Search"
          ],
          "prerequisites": [
            "javascript_arrays",
            "oop_fundamentals"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_open_scaling_parking_lot_1",
          "topic": "System Design: Scaling the Parking Lot",
          "level": "hard",
          "type": "open",
          "question": "Imagine this `ParkingLot` system needs to be scaled to manage a multi-story parking garage with potentially thousands of slots and different vehicle types (e.g., motorcycles, cars, trucks, each requiring different slot sizes). What modifications would you propose to the `ParkingLot` and `Vehicle` classes, and what new data structures or concepts might be introduced to handle this complexity?",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Discusses extending `Vehicle` (e.g., with `size` property, or inheritance for `Car`, `Motorcycle`, `Truck`).",
            "Proposes changes to `ParkingLot` to handle different slot sizes or types (e.g., `slots` could be a 2D array or an object mapping floor numbers to arrays; `availableSlots` could be a `Map<SlotType, Set<SlotNumber>>`).",
            "Considers strategies for parking logic: finding suitable slots based on vehicle type/size.",
            "Mentions potential need for more complex query methods (e.g., `getAvailableSlotsByType`).",
            "Touches on database persistence or distributed system considerations if 'thousands of slots' implies a persistent, large-scale system.",
            "Identifies the challenge of slot allocation optimization (e.g., 'best fit' algorithm)."
          ],
          "keyConcepts": [
            "System design",
            "Scalability",
            "Inheritance",
            "Polymorphism",
            "Advanced data structures (Maps of Sets)",
            "Database integration",
            "Algorithm design (slot allocation)"
          ],
          "evaluationCriteria": [
            "Breadth and depth of proposed architectural changes.",
            "Practicality and justification of data structure choices.",
            "Consideration of various aspects of system design (OOP, data, algorithms, persistence).",
            "Ability to think beyond the immediate problem and anticipate future requirements."
          ],
          "example": "N/A",
          "tags": [
            "System Design",
            "Scalability",
            "OOP",
            "Advanced Data Structures",
            "Architecture"
          ],
          "prerequisites": [
            "design_patterns",
            "advanced_data_structures",
            "oop_principles"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "expert"
        }
      ],
      "tasks": [
        {
          "id": "task_refactor_vehicle_parking_classes",
          "title": "Refactor Vehicle and ParkingLot Classes with Type Safety",
          "description": "\nRefactor the `Vehicle` and `ParkingLot` classes using TypeScript to introduce type safety. Ensure all properties and method parameters/return types are explicitly defined. Pay special attention to the `slots` array and `availableSlots` Set, correctly typing their elements.\n\n**Requirements:**\n1.  Convert `Vehicle` class to TypeScript, explicitly typing `registrationNumber` and `color`.\n2.  Convert `ParkingLot` class to TypeScript.\n3.  Type `capacity`, `slots` (e.g., `(Vehicle | null)[]`), and `availableSlots` (e.g., `Set<number>`).\n4.  Add explicit types for all method parameters and return values (e.g., `parkVehicle(vehicle: Vehicle): { success: boolean; message: string; slotNumber?: number; }`).\n5.  Ensure the example usage still works without type errors.\n",
          "difficulty": "medium",
          "startingCode": "class Vehicle {\n  constructor(registrationNumber, color) {\n    this.registrationNumber = registrationNumber;\n    this.color = color;\n  }\n}\n\nclass ParkingLot {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.slots = new Array(capacity).fill(null);\n    this.availableSlots = new Set();\n    for (let i = 0; i < capacity; i++) {\n      this.availableSlots.add(i);\n    }\n  }\n  \n  parkVehicle(vehicle) {\n    if (this.availableSlots.size === 0) {\n      return { success: false, message: \"No available parking slots\" };\n    }\n    const slotNumber = this.availableSlots.values().next().value;\n    this.availableSlots.delete(slotNumber);\n    this.slots[slotNumber] = vehicle;\n    return { \n      success: true, \n      message: `Vehicle parked successfully`, \n      slotNumber \n    };\n  }\n  \n  removeVehicle(slotNumber) {\n    if (slotNumber < 0 || slotNumber >= this.capacity) {\n      return { success: false, message: \"Invalid slot number\" };\n    }\n    if (this.slots[slotNumber] === null) {\n      return { success: false, message: \"Slot is already empty\" };\n    }\n    const vehicle = this.slots[slotNumber];\n    this.slots[slotNumber] = null;\n    this.availableSlots.add(slotNumber);\n    return { \n      success: true, \n      message: \"Vehicle removed successfully\", \n      vehicle \n    };\n  }\n  \n  getVehiclesByColor(color) {\n    return this.slots\n      .filter(vehicle => vehicle && vehicle.color === color)\n      .map((vehicle, index) => ({ vehicle, slotNumber: index }));\n  }\n  \n  getSlotByRegistration(registrationNumber) {\n    const index = this.slots.findIndex(\n      vehicle => vehicle && vehicle.registrationNumber === registrationNumber\n    );\n    return index !== -1 ? index : null;\n  }\n  \n  getSlotsByColor(color) {\n    return this.slots\n      .map((vehicle, index) => ({ vehicle, index }))\n      .filter(item => item.vehicle && item.vehicle.color === color)\n      .map(item => item.index);\n  }\n  \n  getAvailableSlots() {\n    return Array.from(this.availableSlots);\n  }\n}\n\n// Example usage (should be type-safe after refactoring)\nconst parkingLot = new ParkingLot(3);\nconst car1 = new Vehicle(\"KA-01-HH-1234\", \"White\");\nconsole.log(parkingLot.parkVehicle(car1));\n",
          "solutionCode": "class Vehicle {\n  registrationNumber: string;\n  color: string;\n\n  constructor(registrationNumber: string, color: string) {\n    this.registrationNumber = registrationNumber;\n    this.color = color;\n  }\n}\n\ninterface ParkResult {\n  success: boolean;\n  message: string;\n  slotNumber?: number;\n}\n\ninterface RemoveResult {\n  success: boolean;\n  message: string;\n  vehicle?: Vehicle;\n}\n\ninterface VehicleInSlot {\n  vehicle: Vehicle;\n  slotNumber: number;\n}\n\nclass ParkingLot {\n  private capacity: number;\n  private slots: (Vehicle | null)[];\n  private availableSlots: Set<number>;\n\n  constructor(capacity: number) {\n    this.capacity = capacity;\n    this.slots = new Array<Vehicle | null>(capacity).fill(null);\n    this.availableSlots = new Set<number>();\n    for (let i = 0; i < capacity; i++) {\n      this.availableSlots.add(i);\n    }\n  }\n  \n  parkVehicle(vehicle: Vehicle): ParkResult {\n    if (this.availableSlots.size === 0) {\n      return { success: false, message: \"No available parking slots\" };\n    }\n    \n    const slotNumber: number = this.availableSlots.values().next().value;\n    this.availableSlots.delete(slotNumber);\n    \n    this.slots[slotNumber] = vehicle;\n    \n    return { \n      success: true, \n      message: `Vehicle parked successfully`, \n      slotNumber \n    };\n  }\n  \n  removeVehicle(slotNumber: number): RemoveResult {\n    if (slotNumber < 0 || slotNumber >= this.capacity) {\n      return { success: false, message: \"Invalid slot number\" };\n    }\n    \n    if (this.slots[slotNumber] === null) {\n      return { success: false, message: \"Slot is already empty\" };\n    }\n    \n    const vehicle: Vehicle = this.slots[slotNumber] as Vehicle; // Type assertion as it's guaranteed not null here\n    this.slots[slotNumber] = null;\n    this.availableSlots.add(slotNumber);\n    \n    return { \n      success: true, \n      message: \"Vehicle removed successfully\", \n      vehicle \n    };\n  }\n  \n  getVehiclesByColor(color: string): VehicleInSlot[] {\n    return this.slots\n      .map((vehicle, index) => ({ vehicle, slotNumber: index }))\n      .filter((item): item is VehicleInSlot => item.vehicle !== null && item.vehicle.color === color)\n      .map(item => ({ vehicle: item.vehicle, slotNumber: item.slotNumber }));\n  }\n  \n  getSlotByRegistration(registrationNumber: string): number | null {\n    const index: number = this.slots.findIndex(\n      vehicle => vehicle && vehicle.registrationNumber === registrationNumber\n    );\n    \n    return index !== -1 ? index : null;\n  }\n  \n  getSlotsByColor(color: string): number[] {\n    return this.slots\n      .map((vehicle, index) => ({ vehicle, index }))\n      .filter((item): item is { vehicle: Vehicle; index: number } => item.vehicle !== null && item.vehicle.color === color)\n      .map(item => item.index);\n  }\n  \n  getAvailableSlots(): number[] {\n    return Array.from(this.availableSlots);\n  }\n}\n\n// Example usage (now type-safe)\nconst parkingLot = new ParkingLot(3);\nconst car1 = new Vehicle(\"KA-01-HH-1234\", \"White\");\nconst car2 = new Vehicle(\"KA-01-HH-9999\", \"White\");\nconst car3 = new Vehicle(\"KA-01-BB-0001\", \"Black\");\n\nconsole.log(parkingLot.parkVehicle(car1));\nconsole.log(parkingLot.parkVehicle(car2));\nconsole.log(parkingLot.parkVehicle(car3));\n\nconsole.log(parkingLot.getVehiclesByColor(\"White\"));\nconsole.log(parkingLot.getSlotByRegistration(\"KA-01-HH-1234\"));\nconsole.log(parkingLot.getSlotsByColor(\"White\"));\nconsole.log(parkingLot.getAvailableSlots());\n\nconsole.log(parkingLot.removeVehicle(0));\nconsole.log(parkingLot.getAvailableSlots());\n",
          "testCases": [
            "Constructor: `new ParkingLot(5)` should create a `slots` array of 5 `null`s and `availableSlots` Set with {0,1,2,3,4}.",
            "parkVehicle: Parking a vehicle should return `{ success: true, ... }` and correctly update `slots` and `availableSlots`.",
            "parkVehicle (full): Calling `parkVehicle` on a full lot should return `{ success: false, message: 'No available parking slots' }`.",
            "removeVehicle: Removing a vehicle from an occupied slot should return `{ success: true, ... }` and update `slots` and `availableSlots`.",
            "removeVehicle (invalid slot): Calling `removeVehicle(-1)` or `removeVehicle(capacity)` should return `{ success: false, message: 'Invalid slot number' }`.",
            "removeVehicle (empty slot): Calling `removeVehicle` on an already empty slot should return `{ success: false, message: 'Slot is already empty' }`.",
            "getVehiclesByColor: Should correctly return all vehicles of a specified color with their slot numbers.",
            "getSlotByRegistration: Should return the correct slot number or `null` if not found.",
            "getSlotsByColor: Should return an array of slot numbers for vehicles of a specified color.",
            "getAvailableSlots: Should return an array of all currently available slot numbers, matching the state of `availableSlots`."
          ],
          "hints": [
            "Start by defining interfaces for the return types of methods like `parkVehicle` and `removeVehicle` for better clarity.",
            "Remember that `slots` can hold either a `Vehicle` object or `null`, so use a union type like `(Vehicle | null)[]`.",
            "For `filter` methods on arrays that contain `null`, you might need a type predicate (e.g., `(item): item is VehicleInSlot => item.vehicle !== null`) to correctly narrow types for subsequent `map` operations in TypeScript.",
            "The `Set` type in TypeScript is generic, so specify the type of elements it holds, e.g., `Set<number>`."
          ],
          "tags": [
            "TypeScript",
            "Refactoring",
            "Type Safety",
            "OOP",
            "Data Structures"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "typescript_basics",
            "oop_fundamentals",
            "javascript_arrays",
            "javascript_sets"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "interfaces",
            "union_types",
            "type_predicates"
          ]
        },
        {
          "id": "task_implement_advanced_parking",
          "title": "Implement Priority Parking for Handicapped Vehicles",
          "description": "\nExtend the `ParkingLot` class to support a new feature: priority parking for vehicles that are marked as 'handicapped'.\n\n**Requirements:**\n1.  Modify the `Vehicle` class to include an optional `isHandicapped` boolean property.\n2.  Modify the `ParkingLot` constructor to optionally reserve a certain number of slots (e.g., the first `N` slots) as 'handicapped-only' slots. These slots should only be assigned to handicapped vehicles.\n3.  Update the `parkVehicle` method:\n    *   If a handicapped vehicle is being parked, it should prioritize parking in a handicapped-only slot if available.\n    *   If no handicapped-only slots are available, it can park in a regular available slot.\n    *   If a non-handicapped vehicle is being parked, it should *not* be able to park in a handicapped-only slot.\n4.  Update the `removeVehicle` method: Ensure removed handicapped-only slots are correctly returned to the `handicappedAvailableSlots` pool.\n5.  Add a new method `getHandicappedSlots()` that returns the numbers of all handicapped-only slots.\n",
          "difficulty": "hard",
          "startingCode": "class Vehicle {\n  constructor(registrationNumber, color) {\n    this.registrationNumber = registrationNumber;\n    this.color = color;\n    // Add isHandicapped here\n  }\n}\n\nclass ParkingLot {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.slots = new Array(capacity).fill(null);\n    this.availableSlots = new Set();\n    for (let i = 0; i < capacity; i++) {\n      this.availableSlots.add(i);\n    }\n    // Add handicapped related properties here\n  }\n  \n  parkVehicle(vehicle) {\n    // Modify this logic for handicapped priority\n    if (this.availableSlots.size === 0) {\n      return { success: false, message: \"No available parking slots\" };\n    }\n    const slotNumber = this.availableSlots.values().next().value;\n    this.availableSlots.delete(slotNumber);\n    this.slots[slotNumber] = vehicle;\n    return { success: true, message: `Vehicle parked successfully`, slotNumber };\n  }\n  \n  removeVehicle(slotNumber) {\n    // Modify this logic for handicapped slots\n    if (slotNumber < 0 || slotNumber >= this.capacity) {\n      return { success: false, message: \"Invalid slot number\" };\n    }\n    if (this.slots[slotNumber] === null) {\n      return { success: false, message: \"Slot is already empty\" };\n    }\n    const vehicle = this.slots[slotNumber];\n    this.slots[slotNumber] = null;\n    this.availableSlots.add(slotNumber);\n    return { success: true, message: \"Vehicle removed successfully\", vehicle };\n  }\n  \n  // Add getHandicappedSlots method\n}\n\n// Example usage\n// const parkingLot = new ParkingLot(5, 2); // 5 total slots, 2 handicapped\n// const regularCar = new Vehicle(\"R123\", \"Blue\", false);\n// const handicappedCar = new Vehicle(\"H456\", \"Green\", true);\n// console.log(parkingLot.parkVehicle(regularCar));\n// console.log(parkingLot.parkVehicle(handicappedCar));\n// console.log(parkingLot.getAvailableSlots());\n// console.log(parkingLot.getHandicappedSlots());\n",
          "solutionCode": "class Vehicle {\n  registrationNumber;\n  color;\n  isHandicapped;\n\n  constructor(registrationNumber, color, isHandicapped = false) {\n    this.registrationNumber = registrationNumber;\n    this.color = color;\n    this.isHandicapped = isHandicapped;\n  }\n}\n\nclass ParkingLot {\n  capacity;\n  handicappedCapacity;\n  slots;\n  availableSlots;\n  handicappedAvailableSlots;\n  handicappedReservedSlots;\n\n  constructor(capacity, handicappedCapacity = 0) {\n    if (handicappedCapacity > capacity) {\n      throw new Error(\"Handicapped capacity cannot exceed total capacity.\");\n    }\n    this.capacity = capacity;\n    this.handicappedCapacity = handicappedCapacity;\n    this.slots = new Array(capacity).fill(null);\n    this.availableSlots = new Set(); // Regular available slots\n    this.handicappedAvailableSlots = new Set(); // Available handicapped slots\n    this.handicappedReservedSlots = new Set(); // Fixed handicapped slot numbers\n\n    for (let i = 0; i < capacity; i++) {\n      if (i < handicappedCapacity) {\n        this.handicappedAvailableSlots.add(i);\n        this.handicappedReservedSlots.add(i);\n      } else {\n        this.availableSlots.add(i);\n      }\n    }\n  }\n  \n  parkVehicle(vehicle) {\n    let slotNumber = null;\n\n    if (vehicle.isHandicapped) {\n      if (this.handicappedAvailableSlots.size > 0) {\n        slotNumber = this.handicappedAvailableSlots.values().next().value;\n        this.handicappedAvailableSlots.delete(slotNumber);\n      } else if (this.availableSlots.size > 0) {\n        slotNumber = this.availableSlots.values().next().value;\n        this.availableSlots.delete(slotNumber);\n      }\n    } else { // Regular vehicle\n      if (this.availableSlots.size > 0) {\n        slotNumber = this.availableSlots.values().next().value;\n        this.availableSlots.delete(slotNumber);\n      } else {\n        return { success: false, message: \"No regular or available handicapped slots for a non-handicapped vehicle\" };\n      }\n    }\n\n    if (slotNumber === null) {\n      return { success: false, message: \"No available parking slots\" };\n    }\n    \n    this.slots[slotNumber] = vehicle;\n    \n    return { \n      success: true, \n      message: `Vehicle parked successfully`, \n      slotNumber \n    };\n  }\n  \n  removeVehicle(slotNumber) {\n    if (slotNumber < 0 || slotNumber >= this.capacity) {\n      return { success: false, message: \"Invalid slot number\" };\n    }\n    \n    if (this.slots[slotNumber] === null) {\n      return { success: false, message: \"Slot is already empty\" };\n    }\n    \n    const vehicle = this.slots[slotNumber];\n    this.slots[slotNumber] = null;\n\n    if (this.handicappedReservedSlots.has(slotNumber)) {\n      this.handicappedAvailableSlots.add(slotNumber);\n    } else {\n      this.availableSlots.add(slotNumber);\n    }\n    \n    return { \n      success: true, \n      message: \"Vehicle removed successfully\", \n      vehicle \n    };\n  }\n  \n  getVehiclesByColor(color) {\n    return this.slots\n      .filter(vehicle => vehicle && vehicle.color === color)\n      .map((vehicle, index) => ({ vehicle, slotNumber: index }));\n  }\n  \n  getSlotByRegistration(registrationNumber) {\n    const index = this.slots.findIndex(\n      vehicle => vehicle && vehicle.registrationNumber === registrationNumber\n    );\n    \n    return index !== -1 ? index : null;\n  }\n  \n  getSlotsByColor(color) {\n    return this.slots\n      .map((vehicle, index) => ({ vehicle, index }))\n      .filter(item => item.vehicle && item.vehicle.color === color)\n      .map(item => item.index);\n  }\n  \n  getAvailableSlots() {\n    return Array.from(this.availableSlots).concat(Array.from(this.handicappedAvailableSlots)).sort((a, b) => a - b);\n  }\n\n  getHandicappedSlots() {\n    return Array.from(this.handicappedReservedSlots).sort((a, b) => a - b);\n  }\n}\n\n// Example usage\nconst parkingLot = new ParkingLot(5, 2); // 5 total slots, 2 handicapped (slots 0, 1)\n\nconst regularCar1 = new Vehicle(\"R123\", \"Blue\");\nconst regularCar2 = new Vehicle(\"R456\", \"Red\");\nconst handicappedCar1 = new Vehicle(\"H789\", \"Green\", true);\nconst handicappedCar2 = new Vehicle(\"H111\", \"Yellow\", true);\nconst regularCar3 = new Vehicle(\"R222\", \"Black\");\n\nconsole.log(\"Initial available:\", parkingLot.getAvailableSlots()); // Should include all 0-4\nconsole.log(\"Handicapped reserved:\", parkingLot.getHandicappedSlots()); // Should be [0, 1]\n\nconsole.log(parkingLot.parkVehicle(regularCar1)); // Parks in 2\nconsole.log(parkingLot.parkVehicle(regularCar2)); // Parks in 3\nconsole.log(parkingLot.parkVehicle(handicappedCar1)); // Parks in 0 (handicapped slot)\nconsole.log(parkingLot.parkVehicle(regularCar3)); // Parks in 4\n\nconsole.log(\"After parking:\");\nconsole.log(\"Available slots:\", parkingLot.getAvailableSlots()); // Only slot 1 (handicapped) should be available\nconsole.log(\"Handicapped available slots (internal):\", Array.from(parkingLot.handicappedAvailableSlots)); // Should be [1]\n\nconsole.log(parkingLot.parkVehicle(handicappedCar2)); // Parks in 1\n\nconsole.log(\"After all parking:\");\nconsole.log(\"Available slots:\", parkingLot.getAvailableSlots()); // Should be empty\n\nconst regularCar4 = new Vehicle(\"R999\", \"White\");\nconsole.log(parkingLot.parkVehicle(regularCar4)); // Should fail: \"No regular or available handicapped slots for a non-handicapped vehicle\"\n\nconsole.log(parkingLot.removeVehicle(0)); // Remove handicappedCar1\nconsole.log(\"After removing handicappedCar1:\");\nconsole.log(\"Handicapped available slots (internal):\", Array.from(parkingLot.handicappedAvailableSlots)); // Should be [0]\nconsole.log(\"Available slots:\", parkingLot.getAvailableSlots()); // Should include 0\n\nconsole.log(parkingLot.parkVehicle(regularCar4)); // Should fail again as 0 is handicapped only\n\nconst handicappedCar3 = new Vehicle(\"H000\", \"Orange\", true);\nconsole.log(parkingLot.parkVehicle(handicappedCar3)); // Should park in 0\n",
          "testCases": [
            "Constructor: `new ParkingLot(5, 2)` should correctly initialize `availableSlots` and `handicappedAvailableSlots` sets.",
            "parkVehicle (handicapped, has priority slot): A handicapped vehicle should first occupy a handicapped-only slot.",
            "parkVehicle (handicapped, no priority slot): A handicapped vehicle should then occupy a regular available slot if no priority slots are free.",
            "parkVehicle (regular, has regular slot): A regular vehicle should occupy a regular slot.",
            "parkVehicle (regular, no regular slot, handicapped slots available): A regular vehicle *must not* park in a handicapped-only slot.",
            "parkVehicle (full): Both regular and handicapped calls should fail if no suitable slots are available.",
            "removeVehicle (from handicapped slot): Removing a vehicle from a handicapped slot should return that slot to `handicappedAvailableSlots`.",
            "removeVehicle (from regular slot): Removing a vehicle from a regular slot should return that slot to `availableSlots`.",
            "getHandicappedSlots(): Should correctly return the array of handicapped slot numbers.",
            "getAvailableSlots(): Should return all available slots (regular + handicapped available), sorted."
          ],
          "hints": [
            "You'll need two separate `Set`s for available slots: one for regular slots (`availableSlots`) and one for handicapped slots (`handicappedAvailableSlots`).",
            "The `handicappedCapacity` parameter in the `ParkingLot` constructor can define the number of initial handicapped-only slots (e.g., `0` to `handicappedCapacity - 1`).",
            "When parking a handicapped vehicle, check `handicappedAvailableSlots` first, then `availableSlots`. For regular vehicles, only check `availableSlots`.",
            "When removing a vehicle, you need to determine if the `slotNumber` belongs to the `handicappedReservedSlots` (you might need a separate `Set` to store these fixed slot numbers) to return it to the correct available pool.",
            "Consider how `getAvailableSlots` should combine the two sets for a complete list."
          ],
          "tags": [
            "OOP",
            "Feature Implementation",
            "Conditional Logic",
            "Data Structures",
            "Edge Cases",
            "Complex Logic"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "oop_fundamentals",
            "parking_unparking_operations",
            "javascript_sets"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "inheritance",
            "polymorphism",
            "design_patterns"
          ]
        },
        {
          "id": "task_implement_additional_queries",
          "title": "Implement Advanced Parking Lot Query Methods",
          "description": "\nExtend the `ParkingLot` class with two new query methods that provide more specific insights into the parking lot's state.\n\n**Requirements:**\n1.  Implement `getOccupiedSlotsCount()`: This method should return the total number of currently occupied parking slots.\n2.  Implement `getVehiclesByType(type: string)`: This method requires an extension to the `Vehicle` class first. Add a `type` property (e.g., 'car', 'motorcycle', 'truck') to the `Vehicle` class. Then, `getVehiclesByType` should return an array of `VehicleInSlot` objects (similar to `getVehiclesByColor`) for vehicles matching the given type.\n",
          "difficulty": "medium",
          "startingCode": "class Vehicle {\n  constructor(registrationNumber, color) {\n    this.registrationNumber = registrationNumber;\n    this.color = color;\n    // Add type property here\n  }\n}\n\nclass ParkingLot {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.slots = new Array(capacity).fill(null);\n    this.availableSlots = new Set();\n    for (let i = 0; i < capacity; i++) {\n      this.availableSlots.add(i);\n    }\n  }\n  \n  parkVehicle(vehicle) { /* ... */ }\n  removeVehicle(slotNumber) { /* ... */ }\n  getVehiclesByColor(color) { /* ... */ }\n  getSlotByRegistration(registrationNumber) { /* ... */ }\n  getSlotsByColor(color) { /* ... */ }\n  getAvailableSlots() { /* ... */ }\n\n  // Add getOccupiedSlotsCount() here\n  // Add getVehiclesByType(type) here\n}\n\n// Example Usage:\n// const parkingLot = new ParkingLot(5);\n// const car = new Vehicle(\"C123\", \"Blue\", \"car\");\n// const bike = new Vehicle(\"M456\", \"Red\", \"motorcycle\");\n// parkingLot.parkVehicle(car);\n// parkingLot.parkVehicle(bike);\n// console.log(parkingLot.getOccupiedSlotsCount()); // Expected: 2\n// console.log(parkingLot.getVehiclesByType(\"car\")); // Expected: [{ vehicle: car, slotNumber: X }]\n",
          "solutionCode": "class Vehicle {\n  registrationNumber;\n  color;\n  type; // New property\n\n  constructor(registrationNumber, color, type) {\n    this.registrationNumber = registrationNumber;\n    this.color = color;\n    this.type = type; \n  }\n}\n\ninterface VehicleInSlot {\n  vehicle: Vehicle;\n  slotNumber: number;\n}\n\nclass ParkingLot {\n  capacity;\n  slots;\n  availableSlots;\n\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.slots = new Array(capacity).fill(null);\n    this.availableSlots = new Set();\n    for (let i = 0; i < capacity; i++) {\n      this.availableSlots.add(i);\n    }\n  }\n  \n  parkVehicle(vehicle) {\n    if (this.availableSlots.size === 0) {\n      return { success: false, message: \"No available parking slots\" };\n    }\n    const slotNumber = this.availableSlots.values().next().value;\n    this.availableSlots.delete(slotNumber);\n    this.slots[slotNumber] = vehicle;\n    return { success: true, message: `Vehicle parked successfully`, slotNumber };\n  }\n  \n  removeVehicle(slotNumber) {\n    if (slotNumber < 0 || slotNumber >= this.capacity) {\n      return { success: false, message: \"Invalid slot number\" };\n    }\n    if (this.slots[slotNumber] === null) {\n      return { success: false, message: \"Slot is already empty\" };\n    }\n    const vehicle = this.slots[slotNumber];\n    this.slots[slotNumber] = null;\n    this.availableSlots.add(slotNumber);\n    return { success: true, message: \"Vehicle removed successfully\", vehicle };\n  }\n  \n  getVehiclesByColor(color) {\n    return this.slots\n      .map((vehicle, index) => ({ vehicle, slotNumber: index }))\n      .filter(item => item.vehicle && item.vehicle.color === color)\n      .map(item => ({ vehicle: item.vehicle, slotNumber: item.slotNumber }));\n  }\n  \n  getSlotByRegistration(registrationNumber) {\n    const index = this.slots.findIndex(\n      vehicle => vehicle && vehicle.registrationNumber === registrationNumber\n    );\n    return index !== -1 ? index : null;\n  }\n  \n  getSlotsByColor(color) {\n    return this.slots\n      .map((vehicle, index) => ({ vehicle, index }))\n      .filter(item => item.vehicle && item.vehicle.color === color)\n      .map(item => item.index);\n  }\n  \n  getAvailableSlots() {\n    return Array.from(this.availableSlots);\n  }\n\n  // New method 1\n  getOccupiedSlotsCount() {\n    return this.capacity - this.availableSlots.size;\n    // Alternative: return this.slots.filter(slot => slot !== null).length;\n  }\n\n  // New method 2\n  getVehiclesByType(type) {\n    return this.slots\n      .map((vehicle, index) => ({ vehicle, slotNumber: index }))\n      .filter(item => item.vehicle && item.vehicle.type === type)\n      .map(item => ({ vehicle: item.vehicle, slotNumber: item.slotNumber }));\n  }\n}\n\n// Example Usage:\nconst parkingLot = new ParkingLot(5);\nconst car1 = new Vehicle(\"C123\", \"Blue\", \"car\");\nconst bike1 = new Vehicle(\"M456\", \"Red\", \"motorcycle\");\nconst car2 = new Vehicle(\"C789\", \"Green\", \"car\");\n\nparkingLot.parkVehicle(car1);\nparkingLot.parkVehicle(bike1);\nparkingLot.parkVehicle(car2);\n\nconsole.log(\"Occupied slots count:\", parkingLot.getOccupiedSlotsCount()); // Expected: 3\nconsole.log(\"Vehicles of type 'car':\", parkingLot.getVehiclesByType(\"car\"));\n/* Expected:\n[\n  { vehicle: Vehicle { registrationNumber: 'C123', color: 'Blue', type: 'car' }, slotNumber: 0 },\n  { vehicle: Vehicle { registrationNumber: 'C789', color: 'Green', type: 'car' }, slotNumber: 2 }\n]\n*/\nconsole.log(\"Vehicles of type 'motorcycle':\", parkingLot.getVehiclesByType(\"motorcycle\"));\n/* Expected:\n[\n  { vehicle: Vehicle { registrationNumber: 'M456', color: 'Red', type: 'motorcycle' }, slotNumber: 1 }\n]\n*/\nconsole.log(\"Vehicles of type 'truck':\", parkingLot.getVehiclesByType(\"truck\")); // Expected: []\n",
          "testCases": [
            "getOccupiedSlotsCount: Should return 0 for an empty lot.",
            "getOccupiedSlotsCount: Should return the correct count after multiple park operations.",
            "getOccupiedSlotsCount: Should return the correct count after multiple remove operations.",
            "getVehiclesByType: Should correctly filter and return vehicles of a specific type (e.g., 'car').",
            "getVehiclesByType: Should return an empty array if no vehicles of the specified type are parked.",
            "getVehiclesByType: Should correctly handle scenarios where `Vehicle` objects might be `null` in `slots` array."
          ],
          "hints": [
            "For `getOccupiedSlotsCount()`, consider how the `availableSlots` Set relates to the total `capacity`.",
            "For `getVehiclesByType()`, you can adapt the logic from `getVehiclesByColor()` to filter by the new `type` property on the `Vehicle` object.",
            "Remember to update the `Vehicle` class constructor to accept the new `type` parameter."
          ],
          "tags": [
            "Feature Implementation",
            "Querying",
            "Array Methods",
            "OOP Extension"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "oop_fundamentals",
            "array_methods",
            "query_operations"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "object_properties",
            "data_filtering"
          ]
        }
      ]
    }
  },
  {
    "id": "439ce207-65d1-45be-84d5-3fe416b6d723",
    "startLine": 16300,
    "endLine": 16399,
    "processedDate": "2025-06-17T15:22:56.019Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_component_design_data_polling",
          "title": "React Component Design, Lifecycle, and Data Polling",
          "content": "This section covers the principles of creating functional React components, managing component lifecycle effects using the `useEffect` hook, handling state with `useState`, performing asynchronous data fetching, and implementing periodic data updates (polling). It also touches upon robust error handling and conditional rendering based on different component states.\n\n## Key Concepts\n\n### Functional Components and Hooks\nReact functional components are JavaScript functions that accept props as arguments and return React elements. Hooks are special functions that let you \"hook into\" React features from functional components. `useState` allows adding state to functional components, while `useEffect` handles side effects like data fetching, subscriptions, or manually changing the DOM.\n\n### `useState` for State Management\n`useState` is a Hook that lets you add React state to functional components. It returns a pair: the current state value and a function that lets you update it. The updater function causes a re-render of the component.\n\n### `useEffect` for Side Effects and Lifecycle\n`useEffect` is used for side effects in functional components. It runs after every render, but you can control when it runs by providing a dependency array.\n\n-   **No dependency array**: Runs after every render.\n-   **Empty dependency array (`[]`)**: Runs only once after the initial render (like `componentDidMount`). Cleanup function runs on unmount (like `componentWillUnmount`).\n-   **With dependencies (`[dep1, dep2]`)**: Runs after the initial render and whenever any dependency in the array changes. Cleanup function runs before re-running the effect and on unmount.\n\n**Cleanup Function**: The `useEffect` hook can return a function. This return function is the cleanup function. It runs before the component unmounts, and also before the effect runs again if the dependencies change. This is crucial for clearing timers, unsubscribing from events, or canceling network requests to prevent memory leaks or unexpected behavior.\n\n### Data Fetching with `fetch` API\nThe `fetch` API provides an interface for fetching resources (e.g., across the network). It returns a Promise that resolves to a `Response` object. It's important to check `response.ok` (status in the 200-299 range) to determine if the request was successful, as `fetch` only rejects a Promise if a network error occurs, not for HTTP errors like 404 or 500.\n\n### Polling\nPolling is a technique where a client repeatedly requests information from a server at a regular interval. This is useful for maintaining up-to-date data without a constant connection (like WebSockets), but it can be inefficient if updates are infrequent or if many clients poll simultaneously.\n\n### Conditional Rendering\nReact allows you to render different elements or components based on certain conditions. This is essential for displaying loading states, error messages, or different UI based on data availability or user permissions.\n\n## Implementation Steps for a Polling Component\n1.  **State Initialization**: Use `useState` to manage loading, error, and online status.\n2.  **Effect for Polling**: Use `useEffect` to initiate the first status check and set up an `setInterval` for periodic checks.\n3.  **Cleanup**: Return a cleanup function from `useEffect` to clear the `setInterval` when the component unmounts to prevent memory leaks.\n4.  **Data Fetching Logic**: Inside the effect, define an `async` function to use `fetch`, handle successful responses (check `response.status === 200`), and `try-catch` for network errors.\n5.  **Conditional UI**: Render different UI elements (loading, error, online, offline) based on the component's state.\n\n",
          "examples": [
            {
              "id": "example_user_status_indicator_1",
              "title": "User Status Indicator Component with Polling",
              "code": "import React, { useState, useEffect } from 'react';\n\nconst UserStatusIndicator = ({ url, pollingInterval = 5000 }) => {\n  const [isOnline, setIsOnline] = useState(null);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // Function to check user status\n    async function checkStatus() {\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          // Handle HTTP errors (e.g., 404, 500)\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        // Consider user online only if status code is 200\n        setIsOnline(response.status === 200);\n        setError(null);\n      } catch (err) {\n        // Handle network errors or errors thrown above\n        setIsOnline(false);\n        setError(err.message);\n      }\n    }\n\n    // Check status immediately on mount\n    checkStatus();\n    \n    // Set up polling interval\n    const intervalId = setInterval(checkStatus, pollingInterval);\n    \n    // Clean up on unmount or before dependencies change\n    return () => {\n      console.log('Clearing interval:', intervalId);\n      clearInterval(intervalId);\n    };\n    \n  }, [url, pollingInterval]); // Dependencies ensure effect re-runs if url or interval changes\n\n  // Loading state\n  if (isOnline === null && !error) {\n    return <div className=\"status-indicator loading\">Checking status...</div>;\n  }\n\n  // Error state\n  if (error) {\n    return <div className=\"status-indicator error\">Error: {error}</div>;\n  }\n\n  // Online/Offline state\n  return (\n    <div className={`status-indicator ${isOnline ? 'online' : 'offline'}`}>\n      <div className=\"indicator-dot\"></div>\n      <span>{isOnline ? 'Online' : 'Offline'}</span>\n    </div>\n  );\n};\n\nexport default UserStatusIndicator;\n",
              "explanation": "This component demonstrates several key React concepts:\n1.  **State Management**: `isOnline` tracks the connection status (null for loading, true for online, false for offline). `error` stores any network or HTTP error messages.\n2.  **Side Effects with `useEffect`**: The `useEffect` hook is used to perform the data fetching logic. It's invoked immediately on mount and then repeatedly at `pollingInterval` using `setInterval`.\n3.  **Dependency Array**: `[url, pollingInterval]` ensures that if these props change, the old interval is cleared, and a new one is set up with the updated values. This is crucial for correct component behavior.\n4.  **Cleanup Function**: The `return () => clearInterval(intervalId);` within `useEffect` is vital. It clears the interval when the component unmounts (or before the effect re-runs due to dependency changes), preventing memory leaks and ensuring resources are properly released.\n5.  **Asynchronous Operations**: `async/await` syntax is used with `fetch` for cleaner asynchronous code.\n6.  **Error Handling**: A `try-catch` block wraps the `fetch` call to catch network errors. Additionally, `response.ok` is checked to handle HTTP response errors (like 404 or 500) that `fetch` itself doesn't throw as rejections.\n7.  **Conditional Rendering**: The component renders different UI elements (`Checking status...`, `Error: ...`, `Online`, `Offline`) based on the `isOnline` and `error` state variables, providing clear user feedback.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_user_status_1",
            "question_user_status_2",
            "question_user_status_3",
            "question_user_status_4",
            "question_user_status_5",
            "question_user_status_6",
            "question_user_status_7",
            "question_user_status_8",
            "question_user_status_9"
          ],
          "relatedTasks": [
            "task_resilient_api_polling"
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "useState",
            "Data Fetching",
            "Polling",
            "Component Design",
            "Error Handling",
            "Conditional Rendering"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript Basics",
            "Promises",
            "React Fundamentals"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced React Hooks",
            "Real-time UI",
            "Client-Server Communication"
          ]
        },
        {
          "id": "theory_dynamic_form_generation",
          "title": "Dynamic Form Generation using JSON Schema in React",
          "content": "Building forms dynamically from a JSON schema is a powerful pattern in frontend development. It allows for flexible and configurable user interfaces without hardcoding form structures, which is particularly useful for admin panels, configuration tools, or applications requiring customizable data input.\n\n## Key Concepts\n\n### JSON Schema for Forms\nA JSON schema can define the structure and validation rules for your form data. For dynamic forms, this schema typically includes an array of field definitions, where each field specifies its `type` (e.g., 'text', 'textarea', 'number', 'select', 'checkbox'), `id`, `name`, `label`, `placeholder`, `required` status, and possibly options for select fields or initial values.\n\n### Recursive Component Design\nThe core idea is to create a generic `FormField` component that can render different input types based on a `field` object passed as a prop. A parent `DynamicForm` component then iterates over the array of field definitions in the JSON schema and renders a `FormField` for each. For complex or nested structures (e.g., fieldsets, arrays of objects), the `DynamicForm` or `FormField` might recursively render itself or another component.\n\n### Controlled Components\nIn React, form elements whose values are controlled by React state are called controlled components. This means the value of the input is always driven by the state, and any changes to the input are handled via an `onChange` event handler that updates the state. This makes form data predictable and easy to validate.\n\n### State Management for Forms\nFor dynamic forms, a single state object can hold all form data, with keys corresponding to field IDs or names. The `onChange` handler for each `FormField` updates the relevant part of this state object. This centralizes form data management.\n\n## Implementation Steps for a Dynamic Form\n1.  **Define Field Schema**: Create a JSON array of objects, where each object describes a form field (type, name, label, placeholder, etc.).\n2.  **`FormField` Component**: Create a reusable component (`FormField`) that takes a single field definition and the current form value for that field, along with an `onChange` handler. Use a `switch` statement or conditional rendering to render the appropriate HTML input element (`<input>`, `<textarea>`, `<select>`, etc.) based on `field.type`.\n3.  **`DynamicForm` Component**: This component will:\n    *   Accept the JSON schema as a prop.\n    *   Manage the overall form state using `useState`, typically an object where keys are field names/IDs and values are the current input values.\n    *   Iterate over the field definitions in the schema.\n    *   For each field, render the `FormField` component, passing the field definition, the current value from its state, and an `onChange` handler.\n    *   Implement a generic `handleFieldChange` function that updates the form's state based on the field's ID and its new value.\n    *   Handle form submission, often by calling an `onSubmit` prop with the collected form data.\n4.  **Input Types**: Support common input types like `text`, `textarea`, `number`, `email`, `password`, `checkbox`, `radio`, `select`. Each type requires specific HTML attributes and event handling.\n5.  **Validation (Optional but Recommended)**: Integrate validation logic, either within `FormField` or `DynamicForm`, based on rules specified in the JSON schema (e.g., `required`, `minLength`, `pattern`). Display validation messages to the user.\n\n",
          "examples": [
            {
              "id": "example_form_field_1",
              "title": "FormField Component - Handling Various Input Types",
              "code": "import React from 'react';\n\nconst FormField = ({ field, onChange, value }) => {\n  const commonProps = {\n    id: field.id,\n    name: field.name,\n    value: value || '',\n    onChange: e => onChange(field.id, e.target.value),\n    placeholder: field.placeholder,\n    required: field.required,\n    className: 'form-field-input'\n  };\n\n  switch (field.type) {\n    case 'text':\n    case 'email':\n    case 'password':\n    case 'number':\n      return (\n        <div className=\"form-group\">\n          <label htmlFor={field.id}>{field.label}</label>\n          <input type={field.type} {...commonProps} />\n        </div>\n      );\n    case 'textarea':\n      return (\n        <div className=\"form-group\">\n          <label htmlFor={field.id}>{field.label}</label>\n          <textarea {...commonProps} rows={field.rows || 3} />\n        </div>\n      );\n    case 'checkbox':\n      // Checkbox uses `checked` and different onChange handling\n      return (\n        <div className=\"form-group checkbox-group\">\n          <input\n            type=\"checkbox\"\n            id={field.id}\n            name={field.name}\n            checked={!!value} // Convert truthy/falsy to boolean\n            onChange={e => onChange(field.id, e.target.checked)}\n            required={field.required}\n            className=\"form-field-checkbox\"\n          />\n          <label htmlFor={field.id}>{field.label}</label>\n        </div>\n      );\n    case 'select':\n      return (\n        <div className=\"form-group\">\n          <label htmlFor={field.id}>{field.label}</label>\n          <select {...commonProps}>\n            {field.options && field.options.map(option => (\n              <option key={option.value} value={option.value}>\n                {option.label}\n              </option>\n            ))}\n          </select>\n        </div>\n      );\n    default:\n      return (\n        <div className=\"form-group error\">\n          <p>Unknown field type: {field.type}</p>\n        </div>\n      );\n  }\n};\n\nexport default FormField;\n",
              "explanation": "This `FormField` component is responsible for rendering individual form elements based on the `field` object passed via props. It uses a `switch` statement to handle different input types. \n- `text`, `email`, `password`, `number`: Render standard `<input>` elements.\n- `textarea`: Renders a `<textarea>`, allowing for `rows` customization.\n- `checkbox`: Handles the `checked` attribute and ensures `onChange` passes the boolean value (`e.target.checked`).\n- `select`: Renders a `<select>` element and maps `field.options` to `<option>` tags, setting up correct `value` and `onChange` for controlled behavior.\n- `commonProps`: A pattern to collect shared attributes for input types, reducing code duplication.\n- **Controlled Components**: The `value` prop (or `checked` for checkboxes) ensures that the input's displayed value is always derived from React's state, and the `onChange` handler updates that state.",
              "language": "typescript"
            },
            {
              "id": "example_dynamic_form_1",
              "title": "DynamicForm Component - Orchestrating Field Rendering",
              "code": "import React, { useState } from 'react';\nimport FormField from './FormField'; // Assume FormField is in a separate file\n\nconst DynamicForm = ({ schema, onSubmit }) => {\n  // Initialize form data from schema or empty object\n  const initialFormData = schema.reduce((acc, field) => {\n    acc[field.id] = field.defaultValue || ''; // Initialize with default or empty string\n    if (field.type === 'checkbox') acc[field.id] = !!field.defaultValue;\n    return acc;\n  }, {});\n\n  const [formData, setFormData] = useState(initialFormData);\n\n  const handleFieldChange = (id, value) => {\n    setFormData(prevData => ({\n      ...prevData,\n      [id]: value,\n    }));\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    // Here you would typically add validation logic before submitting\n    console.log('Form submitted with data:', formData);\n    onSubmit(formData);\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"dynamic-form\">\n      {schema.map(field => (\n        <FormField\n          key={field.id} // Essential for list rendering performance and correctness\n          field={field}\n          value={formData[field.id]}\n          onChange={handleFieldChange}\n        />\n      ))}\n      <button type=\"submit\" className=\"submit-button\">Submit Form</button>\n    </form>\n  );\n};\n\nexport default DynamicForm;\n",
              "explanation": "The `DynamicForm` component acts as the orchestrator for the dynamic form. \n- **Schema Input**: It accepts a `schema` prop, which is an array of field definitions.\n- **Centralized State**: It uses `useState` to manage `formData`, an object that holds the current values for all fields. The `initialFormData` is built by iterating through the schema and setting default values.\n- **`handleFieldChange`**: This single function is passed down to every `FormField`. When a field's value changes, it calls `handleFieldChange` with its `id` and new `value`, which then updates the `formData` state. This makes `formData` a controlled state for the entire form.\n- **Mapping Fields**: It iterates over the `schema` array using `map`, rendering a `FormField` component for each field definition. The `key` prop is crucial when rendering lists in React for performance and correct reconciliation.\n- **Form Submission**: An `onSubmit` handler prevents default form submission and logs/passes the current `formData`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_dynamic_form_1",
            "question_dynamic_form_2",
            "question_dynamic_form_3",
            "question_dynamic_form_4",
            "question_dynamic_form_5",
            "question_dynamic_form_6",
            "question_dynamic_form_7",
            "question_dynamic_form_8",
            "question_dynamic_form_9"
          ],
          "relatedTasks": [
            "task_dynamic_form_validation"
          ],
          "tags": [
            "React",
            "Forms",
            "Dynamic UI",
            "JSON Schema",
            "Component Composition",
            "State Management",
            "Controlled Components",
            "Recursion"
          ],
          "technology": "React",
          "prerequisites": [
            "React State",
            "React Props",
            "Component Lifecycle",
            "JavaScript Objects"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "Form Builders",
            "Content Management Systems",
            "Configurators"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_user_status_1",
          "topic": "React Component Design and Data Polling",
          "level": "medium",
          "type": "open",
          "question": "How would you create a React component for a user status indicator that regularly checks an API endpoint and updates its UI based on the response? Describe the key React hooks and concepts you would use.",
          "answer": "This question assesses the candidate's understanding of React functional components, state management, side effects, data fetching, and conditional rendering. A good answer should cover:\n1.  **Functional Component Structure**: Using a functional component (e.g., `UserStatusIndicator`).\n2.  **`useState`**: To manage the `isOnline` status (e.g., `null` for loading, `true` for online, `false` for offline) and `error` state.\n3.  **`useEffect`**: For handling side effects like initial data fetch and setting up the polling interval. Emphasize its dependency array for controlling re-runs and the cleanup function to clear the interval on unmount.\n4.  **`fetch` API**: To make asynchronous requests to the API endpoint. Discuss handling both network errors (try/catch) and HTTP status code errors (checking `response.ok`).\n5.  **`setInterval`**: For implementing the polling mechanism.\n6.  **Conditional Rendering**: To display different UI states (loading, error, online, offline).\n7.  **Props**: To receive `url` and `pollingInterval`.",
          "options": [],
          "analysisPoints": [
            "Identifies and correctly applies `useState` for UI state.",
            "Correctly uses `useEffect` for side effects, including the dependency array and cleanup function.",
            "Demonstrates understanding of asynchronous data fetching with `fetch` and error handling.",
            "Explains the polling mechanism using `setInterval`.",
            "Describes conditional rendering for various UI states."
          ],
          "keyConcepts": [
            "React Hooks",
            "useState",
            "useEffect",
            "Data Fetching",
            "Polling",
            "Conditional Rendering",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Clarity and completeness of explanation.",
            "Correct use of React terminology and concepts.",
            "Ability to structure a practical React solution.",
            "Demonstrates awareness of performance/cleanup considerations."
          ],
          "example": "```typescript\nimport React, { useState, useEffect } from 'react';\n\nconst UserStatusIndicator = ({ url, pollingInterval = 5000 }) => {\n  const [isOnline, setIsOnline] = useState(null);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    async function checkStatus() {\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        setIsOnline(response.status === 200);\n        setError(null);\n      } catch (err) {\n        setIsOnline(false);\n        setError(err.message);\n      }\n    }\n\n    checkStatus();\n    const intervalId = setInterval(checkStatus, pollingInterval);\n    \n    return () => clearInterval(intervalId);\n  }, [url, pollingInterval]);\n\n  if (isOnline === null && !error) return <div className=\"status-indicator loading\">Checking status...</div>;\n  if (error) return <div className=\"status-indicator error\">Error: {error}</div>;\n  return (\n    <div className={`status-indicator ${isOnline ? 'online' : 'offline'}`}>\n      <div className=\"indicator-dot\"></div>\n      <span>{isOnline ? 'Online' : 'Offline'}</span>\n    </div>\n  );\n};\n```",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "useState",
            "Data Fetching",
            "Polling"
          ],
          "prerequisites": [
            "React Basics",
            "JavaScript Asynchronous"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_user_status_2",
          "topic": "React `useEffect` Cleanup",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `UserStatusIndicator` component. Why is it crucial to return `() => clearInterval(intervalId)` from the `useEffect` hook?\n\n```typescript\nuseEffect(() => {\n  // ... (async function checkStatus, initial call)\n  const intervalId = setInterval(checkStatus, pollingInterval);\n  \n  return () => clearInterval(intervalId); // <-- This line\n}, [url, pollingInterval]);\n```",
          "answer": "To prevent memory leaks by clearing the interval when the component unmounts or its dependencies change.",
          "options": [
            "To prevent memory leaks by clearing the interval when the component unmounts or its dependencies change.",
            "To ensure the interval runs only once after the component mounts.",
            "To explicitly stop the API calls after a certain number of attempts.",
            "To pause the polling when the user navigates away from the tab."
          ],
          "analysisPoints": [
            "The `useEffect` cleanup function runs when the component unmounts or when the dependencies change (before the effect runs again).",
            "Failing to clear intervals or subscriptions leads to memory leaks and unwanted side effects on unmounted components.",
            "This ensures that the `checkStatus` function is not called on a component that no longer exists in the DOM, preventing errors and resource consumption."
          ],
          "keyConcepts": [
            "useEffect",
            "Cleanup Function",
            "Memory Leaks",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Understanding of `useEffect` lifecycle.",
            "Awareness of memory management in React components.",
            "Ability to identify common pitfalls in asynchronous operations."
          ],
          "example": "The cleanup function returned by `useEffect` is invoked by React when the component unmounts, or before the effect runs again if its dependencies have changed. In the context of `setInterval`, this is critical to stop the timer. Without it, the interval would continue to fire even after the `UserStatusIndicator` component is removed from the DOM, leading to unnecessary API calls, potential errors (e.g., trying to update state on an unmounted component), and a memory leak as the interval keeps a reference to the component's scope alive.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Memory Management"
          ],
          "prerequisites": [
            "React Basics",
            "JavaScript Timers"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_user_status_3",
          "topic": "React `useEffect` Dependencies",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of the dependency array in `useEffect` (e.g., `[url, pollingInterval]`)?",
          "answer": "The dependency array controls when the `useEffect` hook re-runs. The effect will re-run if any value in the array changes between renders.",
          "options": [],
          "analysisPoints": [
            "Explains the role of dependencies in `useEffect`.",
            "Distinguishes between an empty array, no array, and an array with values."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "React Lifecycle"
          ],
          "evaluationCriteria": [
            "Basic understanding of `useEffect` behavior."
          ],
          "example": "Without a dependency array, `useEffect` runs after every render. With an empty array (`[]`), it runs only once on mount. With specific dependencies (`[url, pollingInterval]`), it re-runs when `url` or `pollingInterval` change, ensuring the effect uses the latest props.",
          "tags": [
            "React",
            "Hooks",
            "useEffect"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_user_status_4",
          "topic": "Error Handling with `fetch`",
          "level": "medium",
          "type": "mcq",
          "question": "In the `checkStatus` function, why is `if (!response.ok) { throw new Error(...) }` included in addition to the `try-catch` block?\n\n```typescript\nasync function checkStatus() {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) { // <-- This line\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    setIsOnline(response.status === 200);\n    setError(null);\n  } catch (err) {\n    setIsOnline(false);\n    setError(err.message);\n  }\n}\n```",
          "answer": "The `fetch` API only rejects the Promise on network errors (e.g., no internet); it resolves for HTTP errors like 404 or 500, so `response.ok` is needed to explicitly throw for these.",
          "options": [
            "The `fetch` API only rejects the Promise on network errors (e.g., no internet); it resolves for HTTP errors like 404 or 500, so `response.ok` is needed to explicitly throw for these.",
            "It's a redundant check, as the `try-catch` block will catch all errors automatically.",
            "It ensures that only successful HTTP status codes (2xx) are processed.",
            "It prevents infinite loops in case of a server-side error."
          ],
          "analysisPoints": [
            "Highlights a common misconception about `fetch`'s error handling.",
            "Explains the difference between network errors (caught by `catch`) and HTTP errors (require manual check).",
            "Emphasizes the importance of `response.ok` for robust API calls."
          ],
          "keyConcepts": [
            "fetch API",
            "Error Handling",
            "Promises",
            "HTTP Status Codes"
          ],
          "evaluationCriteria": [
            "Deep understanding of `fetch` API behavior.",
            "Ability to implement robust error handling in asynchronous operations."
          ],
          "example": "The `fetch` API's promise only rejects if there's a network error (e.g., DNS lookup failure, no internet connection, preflight request failed). If the server responds, even with a 4xx or 5xx status code, the promise resolves successfully. Therefore, `response.ok` (which is `true` for status codes 200-299) must be explicitly checked to treat non-2xx responses as errors and propagate them to the `catch` block for unified error handling.",
          "tags": [
            "JavaScript",
            "fetch",
            "Error Handling",
            "API"
          ],
          "prerequisites": [
            "JavaScript Promises"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_user_status_5",
          "topic": "State Initialization in React",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the initial value of `isOnline` (`null`) used for in the `UserStatusIndicator` component?",
          "answer": "It signifies a loading or initial state before the first API check has completed, allowing the component to render a 'Checking status...' message.",
          "options": [],
          "analysisPoints": [
            "Understanding of initial state meaning.",
            "Importance of distinct states for UI feedback."
          ],
          "keyConcepts": [
            "useState",
            "State Management",
            "Loading State"
          ],
          "evaluationCriteria": [
            "Basic understanding of `useState` initialization.",
            "Ability to design for different UI states."
          ],
          "example": "By initializing `isOnline` to `null`, the component can distinguish between 'loading' (`null`), 'online' (`true`), and 'offline' (`false`). This enables the conditional rendering of a 'Checking status...' message, providing immediate feedback to the user while the API call is in progress, rather than showing a default 'Offline' state prematurely.",
          "tags": [
            "React",
            "useState",
            "UI/UX"
          ],
          "prerequisites": [
            "React State"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_user_status_6",
          "topic": "React Performance Optimization",
          "level": "hard",
          "type": "open",
          "question": "Discuss potential performance issues and alternative approaches to polling for real-time status updates in a React application. When would you prefer one method over another?",
          "answer": "Polling can be inefficient for real-time updates due to:\n1.  **High Network Traffic**: Frequent requests even when no data changes.\n2.  **Increased Server Load**: More requests per client.\n3.  **Latency**: Updates only appear at the polling interval, not instantly.\n\nAlternative approaches include:\n\n*   **WebSockets**: Provides a full-duplex communication channel over a single TCP connection. The server can push updates to the client in real-time without the client explicitly requesting them. This is ideal for truly real-time features like chat applications, live dashboards, or user presence indicators where instant updates are critical and polling would be inefficient.\n    *   **Pros**: Low latency, efficient bandwidth usage (after initial handshake), true real-time.\n    *   **Cons**: More complex server-side implementation, browser compatibility for older browsers, potential firewall issues.\n\n*   **Server-Sent Events (SSE)**: A simpler alternative to WebSockets where the server pushes updates to the client over a single HTTP connection. It's unidirectional (server to client only). Suitable for continuous streams of data like stock tickers, news feeds, or status updates where the client doesn't need to send data back to the server in real-time.\n    *   **Pros**: Simpler to implement than WebSockets (especially server-side), leverages HTTP, automatic reconnection.\n    *   **Cons**: Unidirectional, not suitable for two-way communication, less performant than WebSockets for high-frequency updates.\n\n*   **Long Polling**: The client makes a request to the server, and the server holds the connection open until new data is available or a timeout occurs. Once data is sent (or timeout), the connection closes, and the client immediately re-initiates a new request. This is a compromise between traditional polling and WebSockets.\n    *   **Pros**: More real-time than traditional polling, less overhead than WebSockets for infrequent updates.\n    *   **Cons**: Still uses request/response model, can be resource-intensive on the server if many connections are held open.\n\n**When to Prefer Which:**\n*   **Polling**: Simple to implement, works well for infrequent updates or when slight delays are acceptable. Good for legacy APIs or when server-side push capabilities are not available/feasible.\n*   **SSE**: When you need a continuous stream of updates from the server to the client and two-way communication is not required (e.g., news feeds, real-time metrics display).\n*   **WebSockets**: When true bidirectional, low-latency, real-time communication is essential (e.g., chat apps, collaborative editing, gaming).\n*   **Long Polling**: A good fallback when WebSockets/SSE are not an option, but you need more responsiveness than traditional polling for infrequent updates.",
          "options": [],
          "analysisPoints": [
            "Identifies the inefficiencies of basic polling (network traffic, server load, latency).",
            "Explains WebSockets, SSE, and Long Polling with their characteristics.",
            "Compares and contrasts these alternatives, highlighting their pros and cons.",
            "Provides clear use cases for when each approach would be most appropriate.",
            "Demonstrates knowledge beyond basic React implementation into system design."
          ],
          "keyConcepts": [
            "Polling",
            "WebSockets",
            "Server-Sent Events (SSE)",
            "Long Polling",
            "Real-time Communication",
            "Performance Optimization",
            "Network Protocols"
          ],
          "evaluationCriteria": [
            "Depth of knowledge regarding real-time communication patterns.",
            "Ability to analyze trade-offs between different solutions.",
            "Understanding of network performance implications.",
            "System design thinking."
          ],
          "example": "",
          "tags": [
            "Performance",
            "Network",
            "Real-time",
            "System Design"
          ],
          "prerequisites": [
            "Networking Basics",
            "HTTP"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_user_status_7",
          "topic": "React StrictMode and `useEffect`",
          "level": "medium",
          "type": "flashcard",
          "question": "How does React's `StrictMode` affect the behavior of `useEffect` with an empty dependency array (`[]`) during development, and why?",
          "answer": "`StrictMode` will run the `useEffect` cleanup function, then the effect function itself, twice on mount. This helps detect issues like missing cleanup functions or incorrect side effects by simulating unmount/remount behavior.",
          "options": [],
          "analysisPoints": [
            "Understands `StrictMode`'s behavior with `useEffect`.",
            "Explains the reason behind this behavior (issue detection).",
            "Implication for cleanup functions."
          ],
          "keyConcepts": [
            "StrictMode",
            "useEffect",
            "React Development Tools",
            "Cleanup Function"
          ],
          "evaluationCriteria": [
            "Awareness of React development best practices.",
            "Understanding of `StrictMode`'s role in debugging.",
            "Knowledge of component lifecycle nuances."
          ],
          "example": "In `StrictMode`, during development, React intentionally mounts, unmounts, and then re-mounts components (or runs the effect, then its cleanup, then the effect again) to help developers catch issues related to side effects that don't have proper cleanup, or that rely on effects running only once without clean state. For a `useEffect` with `[]`, this means your initial `setInterval` will be set up, then immediately cleared (by the cleanup), then set up again. If you hadn't implemented the `clearInterval` properly, this behavior would highlight that bug by trying to clear a non-existent interval or creating duplicate intervals.",
          "tags": [
            "React",
            "StrictMode",
            "Debugging"
          ],
          "prerequisites": [
            "React Hooks",
            "React Development"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_user_status_8",
          "topic": "Controlled vs. Uncontrolled Components",
          "level": "easy",
          "type": "flashcard",
          "question": "Is the `<input>` element within `FormField` an example of a controlled or uncontrolled component?",
          "answer": "It is a controlled component because its value is tied to the `value` prop which is managed by React state, and its changes are handled via the `onChange` event.",
          "options": [],
          "analysisPoints": [
            "Correctly identifies controlled component.",
            "Explains criteria for controlled component."
          ],
          "keyConcepts": [
            "Controlled Components",
            "Uncontrolled Components",
            "React Forms"
          ],
          "evaluationCriteria": [
            "Basic React form knowledge."
          ],
          "example": "A controlled component means that the form element's value is controlled by React state. The `FormField` component receives `value` as a prop and passes it to the `<input>`'s `value` attribute. Any change to the input triggers the `onChange` handler, which then updates the parent component's state. This state change re-renders the `FormField` with the new `value`, thus React has full control over the input's rendered value.",
          "tags": [
            "React",
            "Forms",
            "Controlled Components"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_user_status_9",
          "topic": "Refactoring `UserStatusIndicator`",
          "level": "hard",
          "type": "code",
          "question": "Refactor the `checkStatus` logic within the `UserStatusIndicator` component to be more resilient to transient network failures. Implement a simple retry mechanism with a fixed number of retries and a delay between attempts. For simplicity, do not implement exponential backoff.\n\n```typescript\nimport React, { useState, useEffect } from 'react';\n\nconst UserStatusIndicator = ({ url, pollingInterval = 5000 }) => {\n  const [isOnline, setIsOnline] = useState(null);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    async function checkStatus() {\n      // TODO: Implement retry logic here\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        setIsOnline(response.status === 200);\n        setError(null);\n      } catch (err) {\n        setIsOnline(false);\n        setError(err.message);\n      }\n    }\n\n    checkStatus();\n    const intervalId = setInterval(checkStatus, pollingInterval);\n    \n    return () => clearInterval(intervalId);\n  }, [url, pollingInterval]);\n\n  if (isOnline === null && !error) return <div className=\"status-indicator loading\">Checking status...</div>;\n  if (error) return <div className=\"status-indicator error\">Error: {error}</div>;\n  return (\n    <div className={`status-indicator ${isOnline ? 'online' : 'offline'}`}>\n      <div className=\"indicator-dot\"></div>\n      <span>{isOnline ? 'Online' : 'Offline'}</span>\n    </div>\n  );\n};\n\nexport default UserStatusIndicator;\n```",
          "answer": "The refactored `checkStatus` function incorporates a retry mechanism with a fixed delay. It attempts the fetch a maximum number of times before giving up and setting an error state.",
          "options": [],
          "analysisPoints": [
            "Correctly implements a loop for retries.",
            "Uses `setTimeout` or similar for delaying retries.",
            "Manages attempt count and breaks loop on success.",
            "Properly propagates final error if all retries fail."
          ],
          "keyConcepts": [
            "Error Handling",
            "Retry Mechanism",
            "Asynchronous JavaScript",
            "Promises"
          ],
          "evaluationCriteria": [
            "Ability to write robust asynchronous code.",
            "Problem-solving for common network issues.",
            "Clean integration into existing component logic."
          ],
          "example": "```typescript\nimport React, { useState, useEffect } from 'react';\n\nconst UserStatusIndicator = ({ url, pollingInterval = 5000, retries = 3, retryDelay = 1000 }) => {\n  const [isOnline, setIsOnline] = useState(null);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    async function checkStatusWithRetry(attempt = 1) {\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          // Throw error for non-2xx status codes\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        setIsOnline(response.status === 200);\n        setError(null);\n      } catch (err) {\n        console.error(`Attempt ${attempt} failed:`, err.message);\n        if (attempt < retries) {\n          // Retry after a delay\n          setTimeout(() => {\n            checkStatusWithRetry(attempt + 1);\n          }, retryDelay);\n        } else {\n          // All retries failed\n          setIsOnline(false);\n          setError(`Failed after ${retries} attempts: ${err.message}`);\n        }\n      }\n    }\n\n    // Initial check and subsequent polling\n    checkStatusWithRetry();\n    const intervalId = setInterval(() => checkStatusWithRetry(), pollingInterval);\n    \n    return () => clearInterval(intervalId);\n  }, [url, pollingInterval, retries, retryDelay]);\n\n  if (isOnline === null && !error) {\n    return <div className=\"status-indicator loading\">Checking status...</div>;\n  }\n  if (error) {\n    return <div className=\"status-indicator error\">Error: {error}</div>;\n  }\n  return (\n    <div className={`status-indicator ${isOnline ? 'online' : 'offline'}`}>\n      <div className=\"indicator-dot\"></div>\n      <span>{isOnline ? 'Online' : 'Offline'}</span>\n    </div>\n  );\n};\n\nexport default UserStatusIndicator;\n```",
          "tags": [
            "React",
            "Hooks",
            "Error Handling",
            "Retry",
            "Asynchronous"
          ],
          "prerequisites": [
            "JavaScript Promises",
            "setTimeout"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_dynamic_form_1",
          "topic": "Dynamic Form Generation",
          "level": "medium",
          "type": "open",
          "question": "How would you build a dynamic form generator in React that takes a JSON schema as input and renders the appropriate form elements? Describe the components involved and their responsibilities.",
          "answer": "This question evaluates the ability to design a flexible UI system. A comprehensive answer should detail:\n1.  **JSON Schema Structure**: Explain how the JSON schema would define fields (e.g., `id`, `name`, `type`, `label`, `placeholder`, `required`, `options` for select).\n2.  **`DynamicForm` Component**: This would be the main container component. Its responsibilities include:\n    *   Receiving the `schema` as a prop.\n    *   Managing the overall form `formData` state using `useState`, typically an object where keys are field `id`s and values are current input values.\n    *   Iterating over the `schema` array and rendering individual `FormField` components.\n    *   Providing a generic `onChange` handler (`handleFieldChange`) that `FormField`s can call to update the central `formData` state.\n    *   Handling form submission (`onSubmit`).\n3.  **`FormField` Component**: A reusable component responsible for rendering a single form element. Its responsibilities include:\n    *   Receiving a `field` definition object, the `value` for that field, and the `onChange` handler from `DynamicForm`.\n    *   Using a `switch` statement or conditional rendering to render the correct HTML input element (`<input>`, `<textarea>`, `<select>`, `<input type='checkbox'>`) based on `field.type`.\n    *   Ensuring the input is a controlled component by binding its `value` to the `value` prop and calling the `onChange` handler on input changes.\n4.  **Controlled Components Principle**: Emphasize how input values are controlled by React state for predictable behavior and easier validation.\n5.  **Key Prop**: Mention the importance of the `key` prop when rendering lists of `FormField` components for React's reconciliation process.\n\nExample Schema:\n```json\n[\n  { \"id\": \"name\", \"type\": \"text\", \"label\": \"Full Name\", \"required\": true },\n  { \"id\": \"email\", \"type\": \"email\", \"label\": \"Email\", \"required\": true, \"placeholder\": \"Enter your email\" },\n  { \"id\": \"message\", \"type\": \"textarea\", \"label\": \"Message\", \"rows\": 4 },\n  { \"id\": \"country\", \"type\": \"select\", \"label\": \"Country\", \"options\": [\n    { \"label\": \"USA\", \"value\": \"US\" }, \n    { \"label\": \"Canada\", \"value\": \"CA\" }\n  ]},\n  { \"id\": \"terms\", \"type\": \"checkbox\", \"label\": \"Agree to terms\", \"defaultValue\": false }\n]\n```",
          "options": [],
          "analysisPoints": [
            "Clearly outlines the architecture (DynamicForm, FormField).",
            "Describes responsibilities of each component.",
            "Explains state management for dynamic forms.",
            "Understands controlled components and their application.",
            "Demonstrates knowledge of rendering different input types.",
            "Mentions important React list properties (`key`)."
          ],
          "keyConcepts": [
            "Dynamic Forms",
            "JSON Schema",
            "React Components",
            "Controlled Components",
            "State Management",
            "Component Composition"
          ],
          "evaluationCriteria": [
            "Architectural design skills.",
            "Understanding of React's core principles for forms.",
            "Ability to translate data structures into UI."
          ],
          "example": "",
          "tags": [
            "React",
            "Forms",
            "Dynamic UI",
            "Component Design"
          ],
          "prerequisites": [
            "React State & Props"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_dynamic_form_2",
          "topic": "Controlled Components in Dynamic Forms",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following best describes why form fields in a dynamic form generator in React are typically implemented as 'controlled components'?",
          "answer": "To keep the form state synchronized with React's state, enabling easy validation, manipulation, and submission.",
          "options": [
            "To allow direct DOM manipulation for performance optimization.",
            "To completely decouple the form's state from React's rendering cycle.",
            "To keep the form state synchronized with React's state, enabling easy validation, manipulation, and submission.",
            "To automatically manage focus and blur events without manual handling."
          ],
          "analysisPoints": [
            "Identifies the core benefit of controlled components.",
            "Contrasts with misconceptions about uncontrolled components or direct DOM manipulation.",
            "Emphasizes advantages like validation and data handling."
          ],
          "keyConcepts": [
            "Controlled Components",
            "React Forms",
            "State Management",
            "Form Validation"
          ],
          "evaluationCriteria": [
            "Fundamental understanding of React form principles.",
            "Ability to explain the rationale behind architectural choices."
          ],
          "example": "In a controlled component, the input element's value is driven by React state. Whenever the input changes (e.g., user types), an `onChange` handler updates the React state, which then re-renders the input with the new value. This centralized control makes it straightforward to:\n1.  **Validate input**: As soon as a user types, you can check constraints and provide immediate feedback.\n2.  **Manipulate input**: You can programmatically set or clear input values based on other logic.\n3.  **Submit data**: All form data is readily available in a single state object for submission.\n4.  **Debug**: The state accurately reflects the UI, simplifying debugging.",
          "tags": [
            "React",
            "Forms",
            "State Management"
          ],
          "prerequisites": [
            "React Forms"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_dynamic_form_3",
          "topic": "Dynamic Form - Key Prop",
          "level": "easy",
          "type": "flashcard",
          "question": "When mapping over an array of field definitions to render multiple `FormField` components, why is it important to include a `key` prop?",
          "answer": "The `key` prop helps React efficiently update the UI by identifying which items have changed, are added, or are removed, improving performance and preventing rendering issues.",
          "options": [],
          "analysisPoints": [
            "Understands React list rendering requirements.",
            "Explains the purpose of the `key` prop."
          ],
          "keyConcepts": [
            "React Lists",
            "Key Prop",
            "Reconciliation"
          ],
          "evaluationCriteria": [
            "Basic React rendering knowledge."
          ],
          "example": "The `key` prop provides a stable identity to each element in a list. When the list changes (e.g., fields are reordered, added, or removed in the schema), React uses the keys to match old elements with new elements in the virtual DOM. This allows React to efficiently update only the necessary parts of the actual DOM, rather than re-rendering the entire list. Without unique and stable keys, React might behave unpredictably, leading to performance issues or incorrect component state.",
          "tags": [
            "React",
            "Lists",
            "Performance"
          ],
          "prerequisites": [
            "React Rendering"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_dynamic_form_4",
          "topic": "Form State Management",
          "level": "medium",
          "type": "open",
          "question": "In a dynamic form, how would you manage the overall form state (`formData`) when individual `FormField` components are responsible for their own input types and `onChange` handling? What challenges might arise?",
          "answer": "The `DynamicForm` parent component typically holds the overall `formData` state using `useState`. This state is usually an object where keys correspond to field `id`s from the schema, and values are the current input values. Each `FormField` component receives two crucial props from the parent:\n1.  `value`: The current value for that specific field from the parent's `formData` state.\n2.  `onChange`: A function (e.g., `handleFieldChange`) that the `FormField` calls whenever its input value changes.\n\nThe `handleFieldChange` function in `DynamicForm` would then take the field's `id` and its new `value` as arguments, and update the `formData` state accordingly using `setFormData(prevData => ({ ...prevData, [id]: value }))`.\n\n**Challenges that might arise:**\n*   **Performance with Large Forms**: If `formData` is a single large object and every field change causes a re-render of the entire `DynamicForm` (and potentially all `FormField`s), performance can degrade. Memoization (`React.memo`) on `FormField`s can help, but careful state structure is more effective.\n*   **Nested Structures/Arrays**: Handling deeply nested objects or arrays of fields in the `formData` requires more complex state updates (e.g., using libraries like Immer or deep cloning).\n*   **Complex Validation**: Implementing interdependent field validations or complex regex validations on the fly can be challenging to manage efficiently and display feedback.\n*   **Initialization**: Properly initializing `formData` from a schema, especially for different field types (e.g., booleans for checkboxes, arrays for multi-selects), requires careful logic.\n*   **Prop Drilling**: If the `onChange` handler or validation logic needs to be passed deeply through several layers of components, it can lead to prop drilling. Context API or state management libraries (Redux, Zustand) can mitigate this.",
          "options": [],
          "analysisPoints": [
            "Explains the flow of state updates from child to parent.",
            "Identifies `formData` structure and `handleFieldChange` pattern.",
            "Discusses performance concerns (re-renders, memoization).",
            "Addresses complexities like nested data and advanced validation.",
            "Mentions potential challenges like prop drilling.",
            "Suggests solutions for complex scenarios (Immer, Context API, state management libraries)."
          ],
          "keyConcepts": [
            "State Management",
            "Controlled Components",
            "Component Communication",
            "Performance",
            "Form Validation",
            "Prop Drilling"
          ],
          "evaluationCriteria": [
            "In-depth understanding of React state flow.",
            "Ability to anticipate and address common frontend challenges.",
            "Knowledge of performance optimization techniques.",
            "Awareness of advanced state management patterns."
          ],
          "example": "",
          "tags": [
            "React",
            "Forms",
            "State Management",
            "Performance",
            "Architecture"
          ],
          "prerequisites": [
            "React State",
            "Component Props"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_dynamic_form_5",
          "topic": "Implementing Checkbox in Dynamic Forms",
          "level": "medium",
          "type": "code",
          "question": "Modify the `FormField` component to correctly handle a 'checkbox' input type. Ensure it is a controlled component and that its value passed to `onChange` is a boolean.\n\n```typescript\nimport React from 'react';\n\nconst FormField = ({ field, onChange, value }) => {\n  const commonProps = {\n    id: field.id,\n    name: field.name,\n    value: value || '', // This might need adjustment for checkbox\n    onChange: e => onChange(field.id, e.target.value), // This definitely needs adjustment\n    placeholder: field.placeholder,\n    required: field.required,\n    className: 'form-field-input'\n  };\n\n  switch (field.type) {\n    case 'text':\n      return (\n        <input type=\"text\" {...commonProps} />\n      );\n    case 'textarea':\n      return (\n        <textarea {...commonProps} rows={field.rows || 3} />\n      );\n    // TODO: Add case for 'checkbox'\n    default:\n      return null;\n  }\n};\n\nexport default FormField;\n```",
          "answer": "The `checkbox` case must use the `checked` attribute instead of `value`, and `e.target.checked` instead of `e.target.value` for its `onChange` handler.",
          "options": [],
          "analysisPoints": [
            "Correctly identifies `checked` attribute for checkboxes.",
            "Uses `e.target.checked` to get the boolean state.",
            "Ensures the checkbox is controlled.",
            "Correctly adapts `value` prop handling for boolean state."
          ],
          "keyConcepts": [
            "React Forms",
            "Controlled Components",
            "Checkbox Input"
          ],
          "evaluationCriteria": [
            "Accuracy of React form element implementation.",
            "Understanding of specific input type properties."
          ],
          "example": "```typescript\nimport React from 'react';\n\nconst FormField = ({ field, onChange, value }) => {\n  const commonInputProps = {\n    id: field.id,\n    name: field.name,\n    placeholder: field.placeholder,\n    required: field.required,\n    className: 'form-field-input'\n  };\n\n  switch (field.type) {\n    case 'text':\n    case 'email':\n    case 'password':\n    case 'number':\n      return (\n        <div className=\"form-group\">\n          <label htmlFor={field.id}>{field.label}</label>\n          <input type={field.type} value={value || ''} onChange={e => onChange(field.id, e.target.value)} {...commonInputProps} />\n        </div>\n      );\n    case 'textarea':\n      return (\n        <div className=\"form-group\">\n          <label htmlFor={field.id}>{field.label}</label>\n          <textarea value={value || ''} onChange={e => onChange(field.id, e.target.value)} rows={field.rows || 3} {...commonInputProps} />\n        </div>\n      );\n    case 'checkbox':\n      return (\n        <div className=\"form-group checkbox-group\">\n          <input\n            type=\"checkbox\"\n            id={field.id}\n            name={field.name}\n            checked={!!value} // Checkbox uses 'checked' attribute for its state\n            onChange={e => onChange(field.id, e.target.checked)} // Get boolean value from e.target.checked\n            required={field.required}\n            className=\"form-field-checkbox\"\n          />\n          <label htmlFor={field.id}>{field.label}</label>\n        </div>\n      );\n    case 'select':\n      return (\n        <div className=\"form-group\">\n          <label htmlFor={field.id}>{field.label}</label>\n          <select value={value || ''} onChange={e => onChange(field.id, e.target.value)} {...commonInputProps}>\n            {field.options && field.options.map(option => (\n              <option key={option.value} value={option.value}>\n                {option.label}\n              </option>\n            ))}\n          </select>\n        </div>\n      );\n    default:\n      return (\n        <div className=\"form-group error\">\n          <p>Unknown field type: {field.type}</p>\n        </div>\n      );\n  }\n};\n\nexport default FormField;\n```",
          "tags": [
            "React",
            "Forms",
            "Coding Challenge"
          ],
          "prerequisites": [
            "React Forms",
            "JavaScript Events"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_dynamic_form_6",
          "topic": "Form Validation Strategy",
          "level": "hard",
          "type": "open",
          "question": "How would you integrate client-side validation into the dynamic form generator based on rules defined in the JSON schema (e.g., `required`, `minLength`, `pattern`)? Discuss where validation logic would reside and how errors would be displayed.",
          "answer": "Integrating client-side validation:\n\n**1. JSON Schema Augmentation:**\n   The schema would need additional properties for validation rules, e.g.:\n   ```json\n   { \"id\": \"username\", \"type\": \"text\", \"label\": \"Username\", \"required\": true, \"minLength\": 5, \"pattern\": \"^[a-zA-Z0-9]+$\" }\n   ```\n\n**2. Validation Logic Location:**\n   *   **`DynamicForm` (Centralized)**: The `DynamicForm` component is ideal for housing the primary validation logic. It can validate the entire `formData` object against the `schema` before submission. This allows for cross-field validation if needed.\n   *   **`FormField` (Field-level)**: Each `FormField` can perform its own immediate validation (e.g., on `blur` or `onChange`) against its specific field rules, providing instant feedback. It would then report its validity status or error message back up to the `DynamicForm`.\n\n**3. Validation Process & State:**\n   *   **Validation State**: The `DynamicForm` would need an additional state to store validation errors, e.g., `const [errors, setErrors] = useState({});`. This `errors` object would map field `id`s to error messages.\n   *   **Validation Function**: A `validateForm` function in `DynamicForm` would iterate through `formData` and `schema`, applying validation rules.\n   *   **When to Validate:**\n        *   **On `submit`**: Always validate the entire form. If invalid, prevent submission and display errors.\n        *   **On `blur` / `onChange`**: Field-level validation can be triggered as the user interacts, providing real-time feedback. This logic might live in `FormField` and update parent state.\n\n**4. Displaying Errors:**\n   *   **Error State Propagation**: The `DynamicForm` would pass relevant error messages (`errors[field.id]`) down to each `FormField` as a prop (e.g., `errorMsg`).\n   *   **`FormField` Responsibility**: `FormField` would then conditionally render an error message (e.g., `<span className=\"error-message\">{errorMsg}</span>`) near the input and/or apply error styling (e.g., red border).\n   *   **Form-level Summary**: For forms with many fields, a summary of all errors at the top of the form can be helpful.\n\n**Example Validation (inside DynamicForm's `validateForm`):**\n```typescript\nconst validateForm = () => {\n  let newErrors = {};\n  let isValid = true;\n\n  schema.forEach(field => {\n    const value = formData[field.id];\n\n    if (field.required && (value === '' || value === false || value === null)) {\n      newErrors[field.id] = `${field.label} is required.`;\n      isValid = false;\n    }\n    // Add more validation rules (minLength, pattern, etc.)\n    // Example: minLength for text\n    if (field.minLength && typeof value === 'string' && value.length < field.minLength) {\n      newErrors[field.id] = `${field.label} must be at least ${field.minLength} characters.`;\n      isValid = false;\n    }\n    // Example: pattern validation\n    if (field.pattern && value) {\n        const regex = new RegExp(field.pattern);\n        if (!regex.test(value)) {\n            newErrors[field.id] = `${field.label} format is invalid.`;\n            isValid = false;\n        }\n    }\n  });\n  setErrors(newErrors);\n  return isValid;\n};\n\nconst handleSubmit = (e) => {\n  e.preventDefault();\n  if (validateForm()) {\n    onSubmit(formData);\n  }\n};\n```",
          "options": [],
          "analysisPoints": [
            "Defines schema extension for validation rules.",
            "Discusses the logical placement of validation (centralized vs. field-level).",
            "Explains the state management for errors.",
            "Details when validation should occur (on submit, on change/blur).",
            "Describes how error messages are passed and displayed in the UI.",
            "Provides a clear code example of basic validation logic."
          ],
          "keyConcepts": [
            "Form Validation",
            "JSON Schema",
            "State Management",
            "Error Handling",
            "Controlled Components",
            "UI/UX Feedback"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of validation strategies.",
            "Ability to design scalable validation systems.",
            "Consideration of user experience for error display.",
            "Practical implementation details."
          ],
          "example": "",
          "tags": [
            "React",
            "Forms",
            "Validation",
            "Architecture"
          ],
          "prerequisites": [
            "React State",
            "Component Communication"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_dynamic_form_7",
          "topic": "Form Performance",
          "level": "medium",
          "type": "flashcard",
          "question": "What is `React.memo` and how could it potentially be used to optimize the `FormField` component in a large dynamic form?",
          "answer": "`React.memo` is a higher-order component (HOC) that memoizes a component's rendering. It prevents a functional component from re-rendering if its props (and state) have not changed. It could optimize `FormField` by preventing unnecessary re-renders of unrelated fields when only one field's value changes.",
          "options": [],
          "analysisPoints": [
            "Defines `React.memo`.",
            "Explains its mechanism (prop comparison).",
            "Applies it to the specific context of a dynamic form for optimization.",
            "Understands trade-offs (shallow comparison, overhead)."
          ],
          "keyConcepts": [
            "React.memo",
            "Performance Optimization",
            "Higher-Order Components",
            "Re-rendering"
          ],
          "evaluationCriteria": [
            "Knowledge of React performance features.",
            "Ability to apply optimization techniques.",
            "Understanding of component rendering lifecycles."
          ],
          "example": "```typescript\nimport React from 'react';\n\nconst FormField = React.memo(({ field, onChange, value }) => {\n  // ... (existing FormField implementation)\n  return (/* JSX */)\n});\n\nexport default FormField;\n```\nIn a large dynamic form, when one field's value changes, the `DynamicForm`'s `formData` state updates. This causes the `DynamicForm` to re-render, and by default, all its child `FormField` components would also re-render. By wrapping `FormField` with `React.memo`, it will only re-render if its `field`, `onChange`, or `value` props actually change. Since `onChange` is usually stable (if defined properly, or passed down from a `useCallback`), and `field` objects often don't change, only the `FormField` whose `value` prop changed (or was involved in the input) would re-render. This significantly reduces unnecessary renders, improving performance.",
          "tags": [
            "React",
            "Performance",
            "Optimization",
            "Memoization"
          ],
          "prerequisites": [
            "React Hooks",
            "Functional Components"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_dynamic_form_8",
          "topic": "Form Element Accessibility",
          "level": "medium",
          "type": "open",
          "question": "What accessibility considerations are important when building dynamic forms in React? Provide specific examples from the `FormField` component.",
          "answer": "Accessibility (A11y) is crucial for dynamic forms to ensure they are usable by everyone, including those with disabilities, often relying on screen readers or keyboard navigation.\n\nKey considerations and examples:\n\n1.  **Labels and `htmlFor`**: Every input field should have a descriptive label associated with it. The `htmlFor` attribute on the `<label>` should match the `id` of the input element. This links the label to the input, allowing screen readers to announce the label when the input is focused.\n    *   **Example (from `FormField`)**: \n        ```jsx\n        <label htmlFor={field.id}>{field.label}</label>\n        <input id={field.id} ... />\n        ```\n        This ensures `label` clicks also focus the input.\n\n2.  **Keyboard Navigation**: All interactive elements (inputs, buttons, select) must be keyboard-focusable and navigable using Tab and Shift+Tab. Standard HTML form elements generally handle this by default.\n    *   **Example**: Using native `<input>`, `<textarea>`, `<select>` elements inherently supports keyboard navigation.\n\n3.  **Error Messages and `aria-describedby` / `aria-live`**: When validation errors occur, they should be clearly communicated to screen readers.\n    *   **`aria-describedby`**: Link the input to its error message element using `aria-describedby=\"error-id\"`. When the input is focused, the screen reader will announce both the label and the error.\n    *   **`aria-live` regions**: For dynamic error messages that appear or disappear, wrap the error message container in an `aria-live` region (e.g., `<div aria-live=\"polite\">`). This tells screen readers to announce changes within that region.\n\n4.  **Semantic HTML**: Use appropriate HTML5 input types (`type=\"email\"`, `type=\"number\"`, `type=\"password\"`) for better browser validation, autofill, and assistive technology interpretation.\n    *   **Example (from `FormField`)**: `input type={field.type}` correctly uses the semantic type.\n\n5.  **Focus Management**: Ensure logical focus order, especially after dynamic content changes (e.g., new fields appearing, error messages). Sometimes `useRef` and `focus()` can be needed to direct focus.\n\n6.  **Required Fields**: Clearly indicate required fields, both visually (e.g., an asterisk `*`) and programmatically using the `required` HTML attribute and/or `aria-required=\"true\"`.\n    *   **Example (from `FormField`)**: `required={field.required}` attribute is passed to the input.\n\nBy following these principles, dynamically generated forms can be made accessible to a broader audience.",
          "options": [],
          "analysisPoints": [
            "Identifies key accessibility principles for forms.",
            "Provides specific HTML attributes and their use cases (`htmlFor`, `aria-describedby`, `aria-live`, `required`).",
            "Connects accessibility features to the `FormField` component's implementation.",
            "Demonstrates understanding of semantic HTML and keyboard navigation."
          ],
          "keyConcepts": [
            "Accessibility (A11y)",
            "Semantic HTML",
            "ARIA Attributes",
            "Form Design",
            "Screen Readers",
            "UI/UX"
          ],
          "evaluationCriteria": [
            "Awareness of web accessibility standards.",
            "Ability to apply accessibility best practices in code.",
            "Understanding of how assistive technologies interact with forms."
          ],
          "example": "",
          "tags": [
            "Accessibility",
            "A11y",
            "Forms",
            "UI/UX",
            "Best Practices"
          ],
          "prerequisites": [
            "HTML Forms",
            "Web Accessibility Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_dynamic_form_9",
          "topic": "Dynamic Form - Nested Structures",
          "level": "hard",
          "type": "code",
          "question": "Extend the `DynamicForm` and `FormField` components to support a nested JSON schema, allowing for a field of `type: 'object'` that contains its own array of `fields`. The `formData` should correctly reflect this nested structure.\n\n**Example Nested Schema:**\n```json\n[\n  { \"id\": \"name\", \"type\": \"text\", \"label\": \"Name\" },\n  {\n    \"id\": \"address\",\n    \"type\": \"object\",\n    \"label\": \"Address Information\",\n    \"fields\": [\n      { \"id\": \"street\", \"type\": \"text\", \"label\": \"Street\" },\n      { \"id\": \"city\", \"type\": \"text\", \"label\": \"City\" }\n    ]\n  }\n]\n```\n\nYour task is to modify the `DynamicForm` and `FormField` (if necessary) to handle `type: 'object'` and update `formData` to be like: `{ name: '...', address: { street: '...', city: '...' } }`.\n\n```typescript\n// DynamicForm.tsx (Simplified for question)\nimport React, { useState } from 'react';\nimport FormField from './FormField'; \n\nconst DynamicForm = ({ schema, onSubmit }) => {\n  const initialFormData = schema.reduce((acc, field) => {\n    acc[field.id] = field.defaultValue || ''; \n    if (field.type === 'checkbox') acc[field.id] = !!field.defaultValue;\n    // TODO: Handle 'object' type initialization\n    return acc;\n  }, {});\n\n  const [formData, setFormData] = useState(initialFormData);\n\n  const handleFieldChange = (id, value) => {\n    // TODO: Handle nested updates\n    setFormData(prevData => ({\n      ...prevData,\n      [id]: value,\n    }));\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Form submitted with data:', formData);\n    onSubmit(formData);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      {schema.map(field => (\n        <FormField\n          key={field.id}\n          field={field}\n          value={formData[field.id]}\n          onChange={handleFieldChange}\n        />\n      ))}\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};\n\nexport default DynamicForm;\n\n// FormField.tsx (Simplified for question)\nimport React from 'react';\n\nconst FormField = ({ field, onChange, value }) => {\n  switch (field.type) {\n    case 'text':\n    case 'textarea':\n    case 'checkbox':\n    case 'select':\n      // ... (existing implementation)\n      return (\n        <div>\n          <label htmlFor={field.id}>{field.label}</label>\n          {/* Input/Textarea/Checkbox/Select */}\n          <input type=\"text\" id={field.id} value={value || ''} onChange={e => onChange(field.id, e.target.value)} />\n        </div>\n      );\n    // TODO: Handle 'object' type. It should recursively render DynamicForm\n    default:\n      return null;\n  }\n};\n\n// NOTE: Assume FormField.tsx is separate and DynamicForm imports it.\n```",
          "answer": "To support nested objects, the `FormField` component must conditionally render another `DynamicForm` instance when `field.type` is 'object'. The `DynamicForm`'s `handleFieldChange` must be updated to correctly merge nested object updates into the overall `formData` state.",
          "options": [],
          "analysisPoints": [
            "Correctly identifies the need for recursion for 'object' type fields.",
            "Modifies `FormField` to render `DynamicForm` for nested schemas.",
            "Adjusts `DynamicForm`'s `initialFormData` logic to initialize nested objects.",
            "Crucially, refactors `handleFieldChange` to perform a shallow or deep merge for nested updates, preserving other fields.",
            "Ensures `key` prop is used in recursive mapping if applicable."
          ],
          "keyConcepts": [
            "Dynamic Forms",
            "Recursion",
            "Nested Objects",
            "State Management",
            "Immutability",
            "Component Composition"
          ],
          "evaluationCriteria": [
            "Ability to implement recursive component patterns.",
            "Proficiency in managing complex nested state.",
            "Understanding of immutable state updates in React.",
            "Problem-solving for complex UI structures."
          ],
          "example": "```typescript\n// DynamicForm.tsx\nimport React, { useState } from 'react';\nimport FormField from './FormField'; // Assume FormField is in a separate file\n\nconst DynamicForm = ({ schema, onSubmit, initialValues = {} }) => {\n  // Helper to initialize nested objects recursively\n  const initializeFormData = (s, currentValues = {}) => {\n    return s.reduce((acc, field) => {\n      if (field.type === 'object' && field.fields) {\n        acc[field.id] = initializeFormData(field.fields, currentValues[field.id] || {});\n      } else if (field.type === 'checkbox') {\n        acc[field.id] = typeof currentValues[field.id] !== 'undefined' ? !!currentValues[field.id] : !!field.defaultValue;\n      } else {\n        acc[field.id] = typeof currentValues[field.id] !== 'undefined' ? currentValues[field.id] : (field.defaultValue || '');\n      }\n      return acc;\n    }, {});\n  };\n\n  const [formData, setFormData] = useState(() => initializeFormData(schema, initialValues));\n\n  // Function to deeply update nested state\n  const setNestedValue = (obj, path, value) => {\n    const newObj = { ...obj };\n    let current = newObj;\n    for (let i = 0; i < path.length - 1; i++) {\n      const key = path[i];\n      if (!current[key] || typeof current[key] !== 'object') {\n        current[key] = {}; // Ensure path exists\n      }\n      current = current[key];\n    }\n    current[path[path.length - 1]] = value;\n    return newObj;\n  };\n\n  const handleFieldChange = (path, value) => {\n    // Path can be a string (e.g., 'name') or an array (e.g., ['address', 'street'])\n    const fullPath = Array.isArray(path) ? path : [path];\n    setFormData(prevData => setNestedValue(prevData, fullPath, value));\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Form submitted with data:', formData);\n    onSubmit(formData);\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"dynamic-form\">\n      {schema.map(field => (\n        <FormField\n          key={field.id}\n          field={field}\n          value={formData[field.id]}\n          // Pass current path for nested fields. If it's a top-level field, pass its ID.\n          // If it's a nested form, it will append its own field IDs to this path.\n          onChange={(fieldId, val) => handleFieldChange(fieldId, val)}\n        />\n      ))}\n      <button type=\"submit\" className=\"submit-button\">Submit Form</button>\n    </form>\n  );\n};\n\nexport default DynamicForm;\n\n// FormField.tsx\nimport React from 'react';\nimport DynamicForm from './DynamicForm'; // Import DynamicForm for recursion\n\nconst FormField = ({ field, onChange, value, currentPath = [] }) => {\n  const commonProps = {\n    id: field.id,\n    name: field.name,\n    placeholder: field.placeholder,\n    required: field.required,\n    className: 'form-field-input'\n  };\n\n  // Helper to construct path for nested fields\n  const getFullPath = (fieldId) => [...currentPath, fieldId];\n\n  switch (field.type) {\n    case 'text':\n    case 'email':\n    case 'password':\n    case 'number':\n      return (\n        <div className=\"form-group\">\n          <label htmlFor={field.id}>{field.label}</label>\n          <input type={field.type} value={value || ''} onChange={e => onChange(getFullPath(field.id), e.target.value)} {...commonProps} />\n        </div>\n      );\n    case 'textarea':\n      return (\n        <div className=\"form-group\">\n          <label htmlFor={field.id}>{field.label}</label>\n          <textarea value={value || ''} onChange={e => onChange(getFullPath(field.id), e.target.value)} rows={field.rows || 3} {...commonProps} />\n        </div>\n      );\n    case 'checkbox':\n      return (\n        <div className=\"form-group checkbox-group\">\n          <input\n            type=\"checkbox\"\n            id={field.id}\n            name={field.name}\n            checked={!!value}\n            onChange={e => onChange(getFullPath(field.id), e.target.checked)}\n            required={field.required}\n            className=\"form-field-checkbox\"\n          />\n          <label htmlFor={field.id}>{field.label}</label>\n        </div>\n      );\n    case 'select':\n      return (\n        <div className=\"form-group\">\n          <label htmlFor={field.id}>{field.label}</label>\n          <select value={value || ''} onChange={e => onChange(getFullPath(field.id), e.target.value)} {...commonProps}>\n            {field.options && field.options.map(option => (\n              <option key={option.value} value={option.value}>\n                {option.label}\n              </option>\n            ))}\n          </select>\n        </div>\n      );\n    case 'object':\n      // Recursive rendering for nested objects\n      if (!field.fields || !Array.isArray(field.fields)) {\n        console.warn(`Object field '${field.id}' must have a 'fields' array.`);\n        return null;\n      }\n      return (\n        <fieldset className=\"form-group nested-fieldset\">\n          <legend>{field.label}</legend>\n          <DynamicForm\n            schema={field.fields}\n            initialValues={value} // Pass current nested object as initialValues to the nested form\n            // This onChange is crucial: it passes the entire nested form's data up\n            onSubmit={(nestedData) => onChange(getFullPath(field.id), nestedData)}\n          />\n        </fieldset>\n      );\n    default:\n      return (\n        <div className=\"form-group error\">\n          <p>Unknown field type: {field.type}</p>\n        </div>\n      );\n  }\n};\n\nexport default FormField;\n```",
          "tags": [
            "React",
            "Forms",
            "Recursion",
            "State Management",
            "Complex Data Structures"
          ],
          "prerequisites": [
            "React State & Props",
            "JavaScript Objects"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "expert"
        }
      ],
      "tasks": [
        {
          "id": "task_resilient_api_polling",
          "title": "Implement a Resilient API Polling Component with Exponential Backoff",
          "description": "\nExtend the `UserStatusIndicator` component to make its API polling more robust. Implement a retry mechanism with exponential backoff for network or HTTP errors.\n\n**Requirements:**\n1.  **Exponential Backoff**: After a failed attempt, wait for `initialDelay * (2^attempt)` milliseconds before retrying. For example, if `initialDelay` is 1000ms:\n    *   1st retry (after 1st failure): 1000ms\n    *   2nd retry (after 2nd failure): 2000ms\n    *   3rd retry (after 3rd failure): 4000ms\n2.  **Maximum Retries**: Allow a configurable maximum number of retry attempts.\n3.  **Polling Resumption**: After a successful retry, the component should resume regular polling at the `pollingInterval`.\n4.  **Error State**: If all retries fail, update the UI to show a persistent error message.\n5.  **Clean up**: Ensure all timers (polling and retry) are correctly cleared on unmount.\n\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\ninterface UserStatusIndicatorProps {\n  url: string;\n  pollingInterval?: number; // interval for regular successful polls\n  maxRetries?: number; // max retry attempts on failure\n  initialRetryDelay?: number; // initial delay for exponential backoff\n}\n\nconst UserStatusIndicator: React.FC<UserStatusIndicatorProps> = ({\n  url,\n  pollingInterval = 5000,\n  maxRetries = 5,\n  initialRetryDelay = 1000,\n}) => {\n  const [isOnline, setIsOnline] = useState<boolean | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [currentAttempt, setCurrentAttempt] = useState(0);\n\n  useEffect(() => {\n    let pollingTimer: NodeJS.Timeout | null = null;\n    let retryTimer: NodeJS.Timeout | null = null;\n\n    const cleanup = () => {\n      if (pollingTimer) clearInterval(pollingTimer);\n      if (retryTimer) clearTimeout(retryTimer);\n    };\n\n    async function checkStatus() {\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        setIsOnline(response.status === 200);\n        setError(null);\n        setCurrentAttempt(0); // Reset retry count on success\n        \n        // Schedule next regular poll\n        cleanup(); // Clear any existing timers\n        pollingTimer = setInterval(checkStatus, pollingInterval);\n\n      } catch (err: any) {\n        console.error('Fetch error:', err.message);\n        setCurrentAttempt(prevAttempt => prevAttempt + 1);\n\n        if (currentAttempt < maxRetries) {\n          const delay = initialRetryDelay * Math.pow(2, currentAttempt);\n          console.log(`Retrying in ${delay}ms (attempt ${currentAttempt + 1}/${maxRetries})`);\n          cleanup(); // Clear polling timer before scheduling retry\n          retryTimer = setTimeout(() => {\n            checkStatus(); // Call self for retry\n          }, delay);\n        } else {\n          // All retries failed\n          setIsOnline(false);\n          setError(`Failed to connect after ${maxRetries} attempts: ${err.message}`);\n          cleanup(); // Stop all timers\n        }\n      }\n    }\n\n    // Initial check on mount\n    checkStatus();\n\n    return cleanup; // Cleanup function for useEffect\n  }, [url, pollingInterval, maxRetries, initialRetryDelay, currentAttempt]); // currentAttempt is a dependency to re-run effect for retry logic\n\n  // Loading state\n  if (isOnline === null && !error) {\n    return <div className=\"status-indicator loading\">Checking status...</div>;\n  }\n\n  // Error state\n  if (error) {\n    return <div className=\"status-indicator error\">Error: {error}</div>;\n  }\n\n  // Online/Offline state\n  return (\n    <div className={`status-indicator ${isOnline ? 'online' : 'offline'}`}>\n      <div className=\"indicator-dot\"></div>\n      <span>{isOnline ? 'Online' : 'Offline'}</span>\n    </div>\n  );\n};\n\nexport default UserStatusIndicator;\n",
          "solutionCode": "import React, { useState, useEffect, useRef, useCallback } from 'react';\n\ninterface UserStatusIndicatorProps {\n  url: string;\n  pollingInterval?: number; // interval for regular successful polls\n  maxRetries?: number; // max retry attempts on failure\n  initialRetryDelay?: number; // initial delay for exponential backoff\n}\n\nconst UserStatusIndicator: React.FC<UserStatusIndicatorProps> = ({\n  url,\n  pollingInterval = 5000,\n  maxRetries = 5,\n  initialRetryDelay = 1000,\n}) => {\n  const [isOnline, setIsOnline] = useState<boolean | null>(null);\n  const [error, setError] = useState<string | null>(null);\n\n  // Using useRef to store mutable timers without re-rendering\n  const pollingTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const retryTimerRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Ref for mutable retry attempt counter (so it doesn't trigger effect re-runs)\n  const currentAttemptRef = useRef(0);\n\n  // Cleanup function for timers\n  const clearTimers = useCallback(() => {\n    if (pollingTimerRef.current) {\n      clearInterval(pollingTimerRef.current);\n      pollingTimerRef.current = null;\n    }\n    if (retryTimerRef.current) {\n      clearTimeout(retryTimerRef.current);\n      retryTimerRef.current = null;\n    }\n  }, []);\n\n  // Use useCallback to memoize checkStatus, preventing unnecessary effect re-runs\n  const checkStatus = useCallback(async () => {\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      setIsOnline(response.status === 200);\n      setError(null);\n      currentAttemptRef.current = 0; // Reset retry count on success\n\n      clearTimers(); // Clear any existing timers (retry or previous poll)\n      pollingTimerRef.current = setInterval(checkStatus, pollingInterval); // Schedule next regular poll\n\n    } catch (err: any) {\n      console.error('Fetch error:', err.message);\n      currentAttemptRef.current++;\n\n      if (currentAttemptRef.current <= maxRetries) {\n        const delay = initialRetryDelay * Math.pow(2, currentAttemptRef.current - 1); // currentAttemptRef.current starts at 1 for first retry\n        console.log(`Retrying in ${delay}ms (attempt ${currentAttemptRef.current}/${maxRetries})`);\n\n        clearTimers(); // Clear polling timer before scheduling retry\n        retryTimerRef.current = setTimeout(() => {\n          checkStatus(); // Call self for retry\n        }, delay);\n      } else {\n        // All retries failed\n        setIsOnline(false);\n        setError(`Failed to connect after ${maxRetries} attempts: ${err.message}`);\n        clearTimers(); // Stop all timers definitively\n      }\n    }\n  }, [url, pollingInterval, maxRetries, initialRetryDelay, clearTimers]);\n  // The dependency array for useCallback ensures checkStatus is recreated only when these props change.\n\n  useEffect(() => {\n    // Initial check on mount\n    checkStatus();\n\n    // Cleanup function for useEffect to clear timers on unmount\n    return clearTimers;\n  }, [checkStatus, clearTimers]); // checkStatus and clearTimers are dependencies because they are defined outside\n\n  // Loading state\n  if (isOnline === null && !error) {\n    return <div className=\"status-indicator loading\">Checking status...</div>;\n  }\n\n  // Error state\n  if (error) {\n    return <div className=\"status-indicator error\">Error: {error}</div>;\n  }\n\n  // Online/Offline state\n  return (\n    <div className={`status-indicator ${isOnline ? 'online' : 'offline'}`}>\n      <div className=\"indicator-dot\"></div>\n      <span>{isOnline ? 'Online' : 'Offline'}</span>\n    </div>\n  );\n};\n\nexport default UserStatusIndicator;\n",
          "testCases": [
            "**Test Case 1: Initial Success**\n- `url`: A URL that consistently returns status 200.\n- Expected: `isOnline` becomes `true`, UI shows 'Online', polling continues normally.",
            "**Test Case 2: Transient Failure (Recovers)**\n- `url`: A URL that returns status 500 for the first 2 calls, then 200.\n- `maxRetries`: 3, `initialRetryDelay`: 100.\n- Expected: UI shows 'Checking status...', then 'Error' briefly, then retries and shows 'Online'. `currentAttemptRef` should reset to 0 after success.",
            "**Test Case 3: Persistent Failure (All Retries Fail)**\n- `url`: A URL that consistently returns status 500 or throws a network error.\n- `maxRetries`: 2, `initialRetryDelay`: 100.\n- Expected: UI shows 'Checking status...', then transitions to 'Error' state after 2 retries (3 total attempts), stopping all polling/retries.",
            "**Test Case 4: Component Unmount**\n- Mount the component, wait a few seconds, then unmount it.\n- Expected: No `setInterval` or `setTimeout` calls should remain active after unmount. Check console logs for 'Clearing interval' / 'Clearing timeout' messages.",
            "**Test Case 5: Prop Change (url or pollingInterval)**\n- Mount component with `url A`. After 5 seconds, change `url` prop to `url B`.\n- Expected: Old timers for `url A` should be cleared, and new polling for `url B` should start immediately."
          ],
          "hints": [
            "Consider using `useRef` to store mutable values like `currentAttempt` and timer IDs (`pollingTimer`, `retryTimer`) to avoid making them dependencies of `useEffect` or `useCallback` unless their change truly needs to trigger re-execution of the effect/callback.",
            "The `checkStatus` function itself should be wrapped in `useCallback` to prevent unnecessary re-creation on every render, which would lead to `useEffect` re-running more often than desired.",
            "Ensure the cleanup logic correctly clears both `setInterval` and `setTimeout` timers to prevent resource leaks and unexpected behavior.",
            "Remember that `Math.pow(2, 0)` is 1, so the delay for the first retry attempt should be `initialRetryDelay * Math.pow(2, 0)` if `currentAttempt` is 0-indexed for retries (meaning `currentAttempt` is 0 for first failure, 1 for second etc.) or `initialRetryDelay * Math.pow(2, currentAttempt - 1)` if `currentAttempt` is 1-indexed for retries.",
            "The `checkStatus` function needs to manage when to re-schedule polling (after success) versus scheduling a retry (after failure).",
            "The `useEffect` dependency array needs to include `checkStatus` (if memoized with `useCallback`) and `clearTimers` if they are defined outside `useEffect` and used within it."
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Data Fetching",
            "Error Handling",
            "Polling",
            "Exponential Backoff",
            "Resilience"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Hooks (useState, useEffect, useRef, useCallback)",
            "JavaScript Promises",
            "Error Handling",
            "setTimeout",
            "setInterval"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Component Lifecycle",
            "Asynchronous JavaScript",
            "Network Resilience"
          ]
        },
        {
          "id": "task_dynamic_form_validation",
          "title": "Build a Full Dynamic Form with Client-Side Validation",
          "description": "\nComplete the dynamic form generator to handle a wider range of input types and implement basic client-side validation based on the JSON schema.\n\n**Requirements:**\n1.  **Extend `FormField`**: Ensure `FormField.tsx` can correctly render and manage state for `text`, `textarea`, `checkbox`, `select`, `email`, and `password` input types. The example `FormField` provides a good starting point.\n2.  **Add Validation Rules to Schema**: Augment the JSON schema to include validation rules. At a minimum, support `required: true` for all input types and `minLength: number` for `text`, `textarea`, `email`, `password` types.\n3.  **Implement Validation Logic**: \n    *   Create a validation function within `DynamicForm.tsx` that iterates through the `schema` and `formData`.\n    *   This function should check all validation rules (e.g., `required`, `minLength`).\n    *   Store validation errors in the `DynamicForm`'s state (e.g., an object mapping `field.id` to error messages).\n4.  **Display Error Messages**: Pass error messages from `DynamicForm` to relevant `FormField` components. Each `FormField` should display its specific error message clearly (e.g., red text below the input) when validation fails.\n5.  **Form Submission**: Prevent form submission if validation fails. Only call the `onSubmit` prop with the `formData` if the form is valid.\n6.  **User Experience**: Display errors on form submission. (Optional: Implement validation on blur for individual fields).\n\n**Example JSON Schema with Validation:**\n```json\n[\n  { \"id\": \"username\", \"type\": \"text\", \"label\": \"Username\", \"required\": true, \"minLength\": 3, \"placeholder\": \"Enter username\" },\n  { \"id\": \"email\", \"type\": \"email\", \"label\": \"Email Address\", \"required\": true, \"placeholder\": \"your@example.com\" },\n  { \"id\": \"password\", \"type\": \"password\", \"label\": \"Password\", \"required\": true, \"minLength\": 6 },\n  { \"id\": \"bio\", \"type\": \"textarea\", \"label\": \"Biography\", \"minLength\": 10, \"rows\": 4 },\n  { \"id\": \"country\", \"type\": \"select\", \"label\": \"Country\", \"required\": true, \"options\": [\n    { \"label\": \"Select Country\", \"value\": \"\" },\n    { \"label\": \"USA\", \"value\": \"US\" },\n    { \"label\": \"Canada\", \"value\": \"CA\" },\n    { \"label\": \"Mexico\", \"value\": \"MX\" }\n  ]},\n  { \"id\": \"newsletter\", \"type\": \"checkbox\", \"label\": \"Subscribe to newsletter\", \"defaultValue\": true }\n]\n```\n",
          "difficulty": "medium",
          "startingCode": "// DynamicForm.tsx\nimport React, { useState } from 'react';\nimport FormField from './FormField'; // Assume FormField is implemented as in theory example\n\nconst DynamicForm = ({ schema, onSubmit }) => {\n  const initialFormData = schema.reduce((acc, field) => {\n    acc[field.id] = field.defaultValue || '';\n    if (field.type === 'checkbox') acc[field.id] = !!field.defaultValue;\n    return acc;\n  }, {});\n\n  const [formData, setFormData] = useState(initialFormData);\n  const [errors, setErrors] = useState<{ [key: string]: string }>({}); // State for validation errors\n\n  const handleFieldChange = (id, value) => {\n    setFormData(prevData => ({\n      ...prevData,\n      [id]: value,\n    }));\n    // Optional: Clear error for this field immediately on change\n    setErrors(prevErrors => { \n      const newErrors = { ...prevErrors };\n      delete newErrors[id];\n      return newErrors;\n    });\n  };\n\n  // TODO: Implement validateForm function\n  const validateForm = () => {\n    let newErrors: { [key: string]: string } = {};\n    let isValid = true;\n\n    schema.forEach(field => {\n      const value = formData[field.id];\n      \n      // Example: Required check\n      if (field.required && (value === '' || value === null || (field.type === 'checkbox' && value === false))) {\n        newErrors[field.id] = `${field.label} is required.`;\n        isValid = false;\n      }\n\n      // TODO: Add minLength check for text, textarea, email, password\n\n      // TODO: Add email format check (optional but good)\n\n    });\n\n    setErrors(newErrors);\n    return isValid;\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (validateForm()) {\n      console.log('Form submitted with data:', formData);\n      onSubmit(formData);\n    } else {\n      console.log('Form has validation errors:', errors);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"dynamic-form\">\n      {schema.map(field => (\n        <FormField\n          key={field.id}\n          field={field}\n          value={formData[field.id]}\n          onChange={handleFieldChange}\n          error={errors[field.id]} // Pass error message to FormField\n        />\n      ))}\n      <button type=\"submit\" className=\"submit-button\">Submit Form</button>\n    </form>\n  );\n};\n\nexport default DynamicForm;\n\n// FormField.tsx (Extend this based on the theory example to support all types)\nimport React from 'react';\n\nconst FormField = ({ field, onChange, value, error }) => {\n  const commonProps = {\n    id: field.id,\n    name: field.name,\n    value: value || '',\n    onChange: e => onChange(field.id, e.target.value),\n    placeholder: field.placeholder,\n    required: field.required,\n    className: `form-field-input ${error ? 'error-input' : ''}` // Apply error class\n  };\n\n  switch (field.type) {\n    case 'text':\n    case 'email':\n    case 'password':\n      return (\n        <div className=\"form-group\">\n          <label htmlFor={field.id}>{field.label}</label>\n          <input type={field.type} {...commonProps} />\n          {error && <span className=\"error-message\">{error}</span>} {/* Display error */}\n        </div>\n      );\n    case 'textarea':\n      return (\n        <div className=\"form-group\">\n          <label htmlFor={field.id}>{field.label}</label>\n          <textarea {...commonProps} rows={field.rows || 3} />\n          {error && <span className=\"error-message\">{error}</span>}\n        </div>\n      );\n    case 'checkbox':\n      return (\n        <div className=\"form-group checkbox-group\">\n          <input\n            type=\"checkbox\"\n            id={field.id}\n            name={field.name}\n            checked={!!value}\n            onChange={e => onChange(field.id, e.target.checked)}\n            required={field.required}\n            className={`form-field-checkbox ${error ? 'error-input' : ''}`}\n          />\n          <label htmlFor={field.id}>{field.label}</label>\n          {error && <span className=\"error-message\">{error}</span>}\n        </div>\n      );\n    case 'select':\n      return (\n        <div className=\"form-group\">\n          <label htmlFor={field.id}>{field.label}</label>\n          <select {...commonProps}>\n            {field.options && field.options.map(option => (\n              <option key={option.value} value={option.value}>\n                {option.label}\n              </option>\n            ))}\n          </select>\n          {error && <span className=\"error-message\">{error}</span>}\n        </div>\n      );\n    default:\n      return (\n        <div className=\"form-group error\">\n          <p>Unknown field type: {field.type}</p>\n        </div>\n      );\n  }\n};\n\nexport default FormField;\n",
          "solutionCode": "// DynamicForm.tsx\nimport React, { useState } from 'react';\nimport FormField from './FormField'; \n\ninterface FieldSchema {\n  id: string;\n  type: string;\n  label: string;\n  required?: boolean;\n  minLength?: number;\n  maxLength?: number;\n  placeholder?: string;\n  rows?: number;\n  options?: { label: string; value: string }[];\n  pattern?: string;\n  defaultValue?: any;\n}\n\ninterface DynamicFormProps {\n  schema: FieldSchema[];\n  onSubmit: (data: { [key: string]: any }) => void;\n}\n\nconst DynamicForm: React.FC<DynamicFormProps> = ({ schema, onSubmit }) => {\n  const initialFormData = schema.reduce((acc, field) => {\n    acc[field.id] = field.defaultValue || (field.type === 'checkbox' ? false : '');\n    if (field.type === 'select' && field.options && field.options.length > 0 && field.options[0].value === '') {\n      acc[field.id] = ''; // Ensure default empty value for select if first option is empty\n    }\n    return acc;\n  }, {});\n\n  const [formData, setFormData] = useState<{ [key: string]: any }>(initialFormData);\n  const [errors, setErrors] = useState<{ [key: string]: string }>({});\n\n  const handleFieldChange = (id: string, value: any) => {\n    setFormData(prevData => ({\n      ...prevData,\n      [id]: value,\n    }));\n    // Clear error for this field immediately on change\n    setErrors(prevErrors => {\n      const newErrors = { ...prevErrors };\n      delete newErrors[id];\n      return newErrors;\n    });\n  };\n\n  const validateForm = () => {\n    let newErrors: { [key: string]: string } = {};\n    let isValid = true;\n\n    schema.forEach(field => {\n      const value = formData[field.id];\n      \n      // Required check\n      if (field.required) {\n        if (field.type === 'checkbox' && value === false) {\n          newErrors[field.id] = `${field.label} is required.`;\n          isValid = false;\n        } else if (typeof value === 'string' && value.trim() === '') {\n          newErrors[field.id] = `${field.label} is required.`;\n          isValid = false;\n        } else if (value === null || typeof value === 'undefined') {\n          newErrors[field.id] = `${field.label} is required.`;\n          isValid = false;\n        }\n      }\n\n      // minLength check for string-based inputs\n      if (field.minLength && typeof value === 'string' && value.length < field.minLength) {\n        newErrors[field.id] = `${field.label} must be at least ${field.minLength} characters.`;\n        isValid = false;\n      }\n\n      // Optional: Email format check (basic regex)\n      if (field.type === 'email' && value && !/^[\\w.-]+@[\\w.-]+\\.\\w{2,4}$/i.test(value)) {\n        newErrors[field.id] = `Please enter a valid email address.`;\n        isValid = false;\n      }\n\n      // Optional: Pattern check (more generic regex)\n      if (field.pattern && typeof value === 'string' && value && !new RegExp(field.pattern).test(value)) {\n        newErrors[field.id] = `${field.label} format is invalid.`;\n        isValid = false;\n      }\n\n    });\n\n    setErrors(newErrors);\n    return isValid;\n  };\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (validateForm()) {\n      console.log('Form submitted with data:', formData);\n      onSubmit(formData);\n    } else {\n      console.log('Form has validation errors:', errors);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"dynamic-form\">\n      {schema.map(field => (\n        <FormField\n          key={field.id}\n          field={field}\n          value={formData[field.id]}\n          onChange={handleFieldChange}\n          error={errors[field.id]} // Pass error message to FormField\n        />\n      ))}\n      <button type=\"submit\" className=\"submit-button\">Submit Form</button>\n    </form>\n  );\n};\n\nexport default DynamicForm;\n\n// FormField.tsx\nimport React from 'react';\n\ninterface FieldProps {\n  id: string;\n  type: string;\n  label: string;\n  required?: boolean;\n  minLength?: number;\n  placeholder?: string;\n  rows?: number;\n  options?: { label: string; value: string }[];\n  pattern?: string;\n}\n\ninterface FormFieldProps {\n  field: FieldProps;\n  onChange: (id: string, value: any) => void;\n  value: any;\n  error?: string;\n}\n\nconst FormField: React.FC<FormFieldProps> = ({ field, onChange, value, error }) => {\n  const commonInputProps = {\n    id: field.id,\n    name: field.id, // Use id as name for consistency\n    placeholder: field.placeholder,\n    required: field.required,\n    className: `form-field-input ${error ? 'error-input' : ''}`\n  };\n\n  switch (field.type) {\n    case 'text':\n    case 'email':\n    case 'password':\n      return (\n        <div className=\"form-group\">\n          <label htmlFor={field.id}>{field.label}</label>\n          <input type={field.type} value={value || ''} onChange={e => onChange(field.id, e.target.value)} {...commonInputProps} />\n          {error && <span className=\"error-message\" aria-live=\"polite\">{error}</span>}\n        </div>\n      );\n    case 'textarea':\n      return (\n        <div className=\"form-group\">\n          <label htmlFor={field.id}>{field.label}</label>\n          <textarea value={value || ''} onChange={e => onChange(field.id, e.target.value)} rows={field.rows || 3} {...commonInputProps} />\n          {error && <span className=\"error-message\" aria-live=\"polite\">{error}</span>}\n        </div>\n      );\n    case 'checkbox':\n      return (\n        <div className=\"form-group checkbox-group\">\n          <input\n            type=\"checkbox\"\n            id={field.id}\n            name={field.id}\n            checked={!!value}\n            onChange={e => onChange(field.id, e.target.checked)}\n            required={field.required}\n            className={`form-field-checkbox ${error ? 'error-input' : ''}`}\n          />\n          <label htmlFor={field.id}>{field.label}</label>\n          {error && <span className=\"error-message\" aria-live=\"polite\">{error}</span>}\n        </div>\n      );\n    case 'select':\n      return (\n        <div className=\"form-group\">\n          <label htmlFor={field.id}>{field.label}</label>\n          <select value={value || ''} onChange={e => onChange(field.id, e.target.value)} {...commonInputProps}>\n            {field.options && field.options.map(option => (\n              <option key={option.value} value={option.value}>\n                {option.label}\n              </option>\n            ))}\n          </select>\n          {error && <span className=\"error-message\" aria-live=\"polite\">{error}</span>}\n        </div>\n      );\n    default:\n      return (\n        <div className=\"form-group error\">\n          <p>Unknown field type: {field.type}</p>\n        </div>\n      );\n  }\n};\n\nexport default FormField;\n",
          "testCases": [
            "**Test Case 1: All Fields Valid**\n- Input valid data for all fields (e.g., username 'testuser' minLength 3, email 'test@example.com', password 'password123' minLength 6, biography 'This is my bio and it has enough characters.', country 'USA', newsletter checked).\n- Expected: Form submits successfully, `onSubmit` is called with correct `formData`, no error messages displayed.",
            "**Test Case 2: Required Field Empty (Text)**\n- Leave 'Username' field empty.\n- Expected: On submit, 'Username is required.' error message appears below the field, form does not submit.",
            "**Test Case 3: Required Field Empty (Select)**\n- Set 'Country' to 'Select Country' (empty value).\n- Expected: On submit, 'Country is required.' error message appears, form does not submit.",
            "**Test Case 4: Required Field Empty (Checkbox)**\n- Uncheck 'Subscribe to newsletter' if `required: true` is added for it.\n- Expected: On submit, 'Subscribe to newsletter is required.' error message appears, form does not submit.",
            "**Test Case 5: `minLength` Violation**\n- Enter 'ab' for 'Username' (minLength 3).\n- Expected: On submit, 'Username must be at least 3 characters.' error message appears, form does not submit.",
            "**Test Case 6: Invalid Email Format**\n- Enter 'invalid-email' for 'Email Address'.\n- Expected: On submit, 'Please enter a valid email address.' error message appears, form does not submit.",
            "**Test Case 7: Mixed Valid and Invalid**\n- Fill some fields correctly, leave others with validation errors.\n- Expected: Only fields with errors display messages, form does not submit.",
            "**Test Case 8: Error Clears on Input**\n- Submit form with errors. Then, type valid input into one of the errored fields.\n- Expected: As user types, the error message for *that specific field* should disappear, while others remain."
          ],
          "hints": [
            "Start by defining your `FieldSchema` interface or type to clearly specify the properties for each field, including validation rules.",
            "The `validateForm` function in `DynamicForm` should iterate through the `schema` array. For each field, access its `value` from `formData` and apply the relevant validation rules.",
            "Remember that `checkbox` inputs use `checked` instead of `value`, and `e.target.checked` returns a boolean, not a string. Adjust your `onChange` handler and validation logic accordingly.",
            "For `minLength` validation, ensure you're only applying it to string-based input types and checking `value.length`.",
            "The `error` prop passed from `DynamicForm` to `FormField` will be `undefined` if there's no error for that field, or a string with the error message. Use conditional rendering (`{error && <span>{error}</span>}`) in `FormField`.",
            "Consider adding a CSS class (e.g., `error-input`) to input fields when they have an error to provide visual feedback.",
            "To clear errors as the user types, modify `handleFieldChange` to `delete newErrors[id]` for the field being updated."
          ],
          "tags": [
            "React",
            "Forms",
            "Validation",
            "Client-Side",
            "Dynamic UI",
            "State Management"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React State & Props",
            "JavaScript Fundamentals",
            "HTML Forms"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Controlled Components",
            "Error Handling",
            "UI/UX"
          ]
        }
      ]
    }
  }
]