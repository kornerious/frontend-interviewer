[
  {
    "id": "550b85bd-efb1-47df-a9c0-14c1601a1cc3",
    "startLine": 1800,
    "endLine": 1899,
    "processedDate": "2025-06-17T08:03:18.115Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_event_propagation",
          "title": "Event Propagation: Capturing and Bubbling",
          "content": "Event propagation is the order in which event listeners are triggered when an event occurs on an element. It involves two phases:\n\n### 1. Capturing Phase\nThis phase starts from the `Window` object, goes down through the DOM tree, visiting all ancestors of the target element, until it reaches the target itself. During this phase, listeners registered with `useCapture: true` (or `true` as the third argument in `addEventListener`) are triggered.\n\n### 2. Bubbling Phase\nThis phase starts from the target element itself and bubbles up through the DOM tree, visiting all ancestors, up to the `Window` object. Most event listeners are registered to run in this phase by default (i.e., `useCapture: false` or omitting the third argument in `addEventListener`).\n\n### Order of Event Firing\nWhen a click event, for instance, occurs on a child element, the sequence of event listener execution is:\n1.  **Parent (capturing phase)**\n2.  **Child (capturing phase)**\n3.  **Child (bubbling phase)**\n4.  **Parent (bubbling phase)**\n\nThis ordered execution allows for fine-grained control over how events are handled at different levels of the DOM tree.",
          "examples": [
            {
              "id": "example_event_propagation_1",
              "title": "Basic Event Propagation Example",
              "code": "<html>\n<head>\n  <title>Event Propagation</title>\n</head>\n<body>\n  <div id=\"parent\" style=\"padding: 20px; background-color: lightblue;\">\n    Parent\n    <button id=\"child\" style=\"padding: 10px; background-color: lightcoral;\">\n      Child Button\n    </button>\n  </div>\n\n  <script>\n    const parent = document.getElementById('parent');\n    const child = document.getElementById('child');\n\n    parent.addEventListener('click', function(e) {\n      console.log('Parent - Capturing Phase (default: bubbling phase, but showing conceptual order)');\n    }, true); // True for capturing\n\n    child.addEventListener('click', function(e) {\n      console.log('Child - Capturing Phase (default: bubbling phase, but showing conceptual order)');\n    }, true); // True for capturing\n\n    child.addEventListener('click', function(e) {\n      console.log('Child - Bubbling Phase');\n    }, false); // False for bubbling (default)\n\n    parent.addEventListener('click', function(e) {\n      console.log('Parent - Bubbling Phase');\n    }, false); // False for bubbling (default)\n  </script>\n</body>\n</html>",
              "explanation": "This HTML and JavaScript demonstrates the order of event propagation. When the 'Child Button' is clicked, the console logs will show the event traversing down the DOM in the capturing phase and then bubbling up in the bubbling phase, hitting the child's bubbling listener, and finally the parent's bubbling listener. Note that 'Child - Capturing Phase' will log before 'Child - Bubbling Phase' if you have both.",
              "language": "html"
            }
          ],
          "relatedQuestions": [
            "question_event_propagation_1",
            "question_event_propagation_2",
            "question_event_propagation_3",
            "question_event_propagation_flashcard_1"
          ],
          "relatedTasks": [
            "task_event_propagation_visualizer"
          ],
          "tags": [
            "DOM",
            "Events",
            "Event Handling",
            "JavaScript Fundamentals"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "dom_manipulation",
            "event_listeners"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "event_delegation",
            "advanced_dom_manipulation"
          ]
        },
        {
          "id": "theory_stopping_event_propagation_default",
          "title": "Stopping Event Propagation and Preventing Default Behavior",
          "content": "While event propagation (capturing and bubbling) is crucial for event delegation, there are scenarios where you need to stop the propagation of an event or prevent the browser's default action for an event.\n\n### `e.stopPropagation()`\nThis method prevents the event from bubbling up (or capturing down, if in the capturing phase) to parent (or child) elements. It stops the propagation chain at the current element, meaning no more listeners further up (or down) the DOM tree will be triggered for this specific event.\n\n### `e.stopImmediatePropagation()`\nThis method does two things:\n1.  It stops the event from propagating further up (or down) the DOM tree, similar to `stopPropagation()`.\n2.  Crucially, it also prevents any other event handlers attached to the *same element* for the *same event type* from being executed. If an element has multiple click listeners, `stopImmediatePropagation()` will ensure only handlers registered *before* it are run.\n\n### `e.preventDefault()`\nThis method prevents the browser's default action associated with an event. For example, clicking on a link (`<a>`) normally navigates to the `href` URL; calling `e.preventDefault()` stops this navigation. Submitting a form normally reloads the page; `e.preventDefault()` stops this. It *does not* stop event propagation; the event will still bubble up (or capture down) and trigger other listeners.\n\n**Key Point**: `stopPropagation()` stops all bubbling through the DOM tree, while `preventDefault()` only prevents the default action of the element but allows event propagation to continue.",
          "examples": [
            {
              "id": "example_stop_propagation",
              "title": "Stopping Event Bubbling with stopPropagation()",
              "code": "document.getElementById('child').addEventListener('click', function(e) {\n  e.stopPropagation();\n  console.log('This event will not bubble up to parent elements.');\n});",
              "explanation": "This example demonstrates `stopPropagation()`. When the element with ID 'child' is clicked, this handler will execute, but the event will not reach any click listeners on its parent elements.",
              "language": "javascript"
            },
            {
              "id": "example_stop_immediate_propagation",
              "title": "Stopping Immediate Propagation with stopImmediatePropagation()",
              "code": "document.getElementById('child').addEventListener('click', function(e) {\n  e.stopImmediatePropagation();\n  console.log('This handler will run.');\n});\n\ndocument.getElementById('child').addEventListener('click', function(e) {\n  console.log('This handler will NOT run due to stopImmediatePropagation.');\n});",
              "explanation": "Here, `stopImmediatePropagation()` is used. The first handler attached to 'child' will execute, but because `e.stopImmediatePropagation()` is called, the second handler attached to 'child' for the same event type will *not* execute, nor will the event propagate to parent elements.",
              "language": "javascript"
            },
            {
              "id": "example_prevent_default",
              "title": "Preventing Default Behavior with preventDefault()",
              "code": "document.getElementById('link').addEventListener('click', function(e) {\n  e.preventDefault(); // Prevents the link from navigating\n  console.log('Link clicked but default behavior prevented. Event still bubbles.');\n  // Event still bubbles up to parents\n});",
              "explanation": "This example shows `preventDefault()`. A click on the 'link' element will trigger this handler, preventing the default navigation action, but the click event will still continue to bubble up to its parent elements.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_stopping_propagation_1",
            "question_stopping_propagation_2",
            "question_stopping_propagation_3",
            "question_stopping_propagation_flashcard_1"
          ],
          "relatedTasks": [
            "task_form_validation_and_propagation"
          ],
          "tags": [
            "DOM",
            "Events",
            "Event Handling",
            "JavaScript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "event_listeners",
            "event_propagation"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "event_delegation",
            "custom_components"
          ]
        },
        {
          "id": "theory_event_delegation",
          "title": "Event Delegation",
          "content": "Event delegation is a powerful technique that leverages event bubbling to handle events efficiently. Instead of attaching individual event listeners to multiple child elements, a single event listener is attached to a common ancestor element. When an event occurs on a child, it bubbles up to the ancestor, where the delegated listener can then identify the actual target element that originated the event.\n\n### Benefits of Event Delegation:\n1.  **Memory efficiency**: Fewer event listeners are attached to the DOM, regardless of how many child elements there are. This reduces memory footprint and improves performance, especially in applications with many interactive elements.\n2.  **Dynamic elements**: It works seamlessly for elements added to the DOM *after* the listener was initially attached. Since the listener is on an ancestor, new children will automatically participate in event propagation and be handled.\n3.  **Less code**: No need to explicitly attach or detach listeners when elements are added or removed, simplifying code maintenance.\n4.  **Smaller DOM footprint**: Directly contributes to improved performance in large-scale applications by keeping the number of active listeners low.\n\n### How it Works:\n1.  Attach a single event listener to a stable parent element (e.g., a container `div` or `ul`).\n2.  Inside the event handler, use `event.target` (the element that originally triggered the event) to determine which specific child element was clicked.\n3.  Apply logic based on `event.target`'s `tagName`, `id`, `className`, or other attributes to perform the desired action.",
          "examples": [
            {
              "id": "example_event_delegation_basic",
              "title": "Basic Event Delegation Example",
              "code": "<!-- HTML Structure -->\n<div id=\"button-container\">\n  <button id=\"btn1\">Button 1</button>\n  <button id=\"btn2\">Button 2</button>\n  <button id=\"btn3\">Button 3</button>\n</div>\n\n<script>\n  // Instead of adding event listeners to multiple buttons\n  document.getElementById('button-container').addEventListener('click', function(e) {\n    // Check if the clicked element is a button\n    if (e.target.tagName === 'BUTTON') {\n      console.log('Button ' + e.target.id + ' was clicked');\n    }\n  });\n</script>",
              "explanation": "This example shows basic event delegation. A single click listener is placed on `button-container`. When any of the buttons inside it are clicked, the event bubbles up. The handler then checks `e.target.tagName` to ensure it was a button that was clicked and logs its ID.",
              "language": "html"
            },
            {
              "id": "example_event_delegation_dynamic",
              "title": "Event Delegation with Dynamic Elements",
              "code": "<!-- HTML Structure -->\n<ul id=\"myList\">\n  <li>Item 1</li>\n  <li>Item 2</li>\n</ul>\n<button id=\"addItemBtn\">Add New Item</button>\n\n<script>\n  const myList = document.getElementById('myList');\n  const addItemBtn = document.getElementById('addItemBtn');\n\n  // Delegate the click listener to the ul\n  myList.addEventListener('click', function(e) {\n    if (e.target.tagName === 'LI') {\n      console.log('Clicked on list item:', e.target.textContent);\n    }\n  });\n\n  // Function to add new items dynamically\n  addItemBtn.addEventListener('click', function() {\n    const newItem = document.createElement('li');\n    newItem.textContent = 'New Item ' + (myList.children.length + 1);\n    myList.appendChild(newItem);\n    console.log('Added new item.');\n  });\n</script>",
              "explanation": "This advanced example illustrates how event delegation handles dynamically added elements. Even after new `<li>` elements are added to `myList`, the single listener on `myList` will correctly detect clicks on these new items without needing to attach new listeners.",
              "language": "html"
            }
          ],
          "relatedQuestions": [
            "question_event_delegation_1",
            "question_event_delegation_2",
            "question_event_delegation_3",
            "question_event_delegation_flashcard_1"
          ],
          "relatedTasks": [
            "task_dynamic_list_management"
          ],
          "tags": [
            "DOM",
            "Events",
            "Event Handling",
            "Performance",
            "Dynamic Content",
            "JavaScript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "event_propagation",
            "dom_manipulation"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "large_scale_applications",
            "frameworks_libraries"
          ]
        },
        {
          "id": "theory_async_await_basics",
          "title": "Async/Await Patterns and Best Practices: Core Concepts",
          "content": "Async/await is a modern JavaScript syntax that simplifies working with asynchronous code, making it appear and behave more like synchronous code, while still maintaining its non-blocking nature. It builds on Promises and provides a more readable and maintainable alternative to chaining `.then()` and `.catch()`.\n\n### `async` Keyword\n*   An `async` function is a function declared with the `async` keyword.\n*   It always implicitly returns a Promise. If the function returns a non-Promise value, JavaScript automatically wraps it in a resolved Promise. If it throws an error, it returns a rejected Promise.\n\n### `await` Keyword\n*   The `await` keyword can only be used inside an `async` function.\n*   It pauses the execution of the `async` function until the Promise it's waiting for settles (either resolves or rejects).\n*   If the Promise resolves, `await` returns the resolved value. If the Promise rejects, `await` throws the rejected value as an error, which can then be caught using a `try...catch` block.\n\n### Benefits:\n*   **Readability**: Makes complex asynchronous flows much easier to follow.\n*   **Error Handling**: Allows using standard `try...catch` blocks for asynchronous errors.\n*   **Debugging**: Easier to debug as the execution flow resembles synchronous code.",
          "examples": [
            {
              "id": "example_async_await_basic",
              "title": "Basic Async/Await Pattern",
              "code": "async function resolveAfterDelay(value, delay) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(value), delay);\n  });\n}\n\nasync function processData() {\n  try {\n    console.log('Starting data processing...');\n    const data = await resolveAfterDelay('Success Data', 2000); // Pauses for 2 seconds\n    console.log(data);  // Logs 'Success Data' after 2 seconds\n    return data;\n  } catch (error) {\n    console.error('An error occurred:', error);\n    throw error; // Re-throw to propagate error further if needed\n  }\n}\n\nprocessData();\nconsole.log('Function call initiated, but this logs immediately (non-blocking)');",
              "explanation": "This example demonstrates the core async/await pattern. `resolveAfterDelay` returns a Promise that resolves after a specified delay. `processData` is an `async` function that uses `await` to pause its execution until `resolveAfterDelay`'s Promise resolves. The `console.log` outside `processData` shows that the `processData` call itself is non-blocking.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_async_await_1",
            "question_async_await_2",
            "question_async_await_3",
            "question_async_await_flashcard_1"
          ],
          "relatedTasks": [
            "task_fetch_and_display_data"
          ],
          "tags": [
            "Asynchronous JavaScript",
            "Promises",
            "Error Handling",
            "JavaScript ES2017+"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "promises",
            "callbacks",
            "event_loop"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "modern_web_development",
            "api_integration"
          ]
        },
        {
          "id": "theory_async_await_error_handling_timeout",
          "title": "Async/Await: Advanced Error Handling and Timeout Patterns",
          "content": "Robust asynchronous code requires proper error handling and mechanisms to deal with potentially long-running or unresponsive operations, such as network requests. Async/await facilitates these patterns with `try...catch` blocks and the `AbortController` API.\n\n### Error Handling Patterns\nJust like synchronous code, `async`/`await` functions can use `try...catch` blocks to handle errors (rejected Promises). If an `await`ed Promise rejects, the execution jumps to the `catch` block.\n\n```javascript\nasync function getProcessedData(url) {\n  let data;\n  try {\n    data = await fetchData(url); // fetchData might throw an error (reject a promise)\n  } catch (error) {\n    console.error('Fetch error:', error.message);\n    // Handle fetch error, e.g., retry, use cached data, or fetch fallback data\n    data = await fetchFallbackData(url); // Attempt to get fallback data\n  }\n  return processDataInWorker(data); // Process whatever data was successfully obtained\n}\n```\n\n### Timeout Pattern with `AbortController`\nNetwork requests might hang indefinitely. The `AbortController` API provides a way to abort a DOM request (like `fetch()`) and signal an ongoing asynchronous operation to cancel itself. This is crucial for implementing timeouts.\n\nHere's how `AbortController` works for timeouts:\n1.  Create an `AbortController` instance.\n2.  Pass its `signal` property to the `fetch` (or other abortable) API.\n3.  Set a `setTimeout` to call `controller.abort()` after a specified duration.\n4.  The `fetch` Promise will then reject with an `AbortError`, which can be caught.\n\nThis pattern ensures that a network request doesn't block resources indefinitely and provides a better user experience by allowing you to handle requests that take too long.",
          "examples": [
            {
              "id": "example_async_await_error_handling",
              "title": "Async/Await Error Handling with Fallback",
              "code": "async function fetchData(url) {\n  // Simulate an API call that might fail\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (Math.random() > 0.5) {\n        resolve(`Data from ${url}`);\n      } else {\n        reject(new Error(`Failed to fetch data from ${url}`));\n      }\n    }, 500);\n  });\n}\n\nasync function fetchFallbackData(url) {\n  // Simulate fetching from a fallback source\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(`Using fallback data for ${url}`);\n      resolve(`Fallback data for ${url}`);\n    }, 200);\n  });\n}\n\nasync function getProcessedData(url) {\n  let data;\n  try {\n    console.log(`Attempting to fetch from ${url}`);\n    data = await fetchData(url); // This might fail\n  } catch (error) {\n    console.error('Caught error during primary fetch:', error.message);\n    data = await fetchFallbackData(url); // Fetch fallback if primary fails\n  }\n  console.log('Processed Data:', data);\n  return data;\n}\n\ngetProcessedData('https://api.example.com/data');",
              "explanation": "This example shows how `try...catch` works with `async`/`await` for error handling. If `fetchData` simulates a failure, the `catch` block executes, and `fetchFallbackData` is called to provide an alternative. The `processDataInWorker` is replaced with a simple log for demonstration.",
              "language": "javascript"
            },
            {
              "id": "example_async_await_timeout",
              "title": "Fetch with Timeout using AbortController",
              "code": "async function fetchWithTimeout(url, timeout = 5000) {\n  const controller = new AbortController();\n  const { signal } = controller;\n\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n  try {\n    const response = await fetch(url, { signal });\n    clearTimeout(timeoutId);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    clearTimeout(timeoutId); // Ensure timeout is cleared even on other errors\n    if (error.name === 'AbortError') {\n      console.error('Fetch timed out for:', url);\n      throw new Error('Request timed out');\n    } else {\n      console.error('Fetch error:', error);\n      throw error;\n    }\n  }\n}\n\n// Example Usage (assuming a local test server or a reliable public API that might be slow)\nasync function getPosts() {\n  try {\n    console.log('Fetching posts with a 2-second timeout...');\n    const posts = await fetchWithTimeout('https://jsonplaceholder.typicode.com/posts?_delay=3000', 2000);\n    console.log('Posts fetched:', posts.slice(0, 2));\n  } catch (err) {\n    console.error('Failed to get posts:', err.message);\n  }\n}\n\nasync function getFastData() {\n    try {\n        console.log('Fetching fast data with a 5-second timeout...');\n        const data = await fetchWithTimeout('https://jsonplaceholder.typicode.com/todos/1', 5000);\n        console.log('Fast data fetched:', data);\n    } catch (err) {\n        console.error('Failed to get fast data:', err.message);\n    }\n}\n\ngetPosts();\ngetFastData();",
              "explanation": "This example provides a complete `fetchWithTimeout` function. It creates an `AbortController` and a `setTimeout` to call `controller.abort()`. If `fetch` takes longer than the `timeout`, the `AbortController` will cancel the request, causing the `fetch` Promise to reject with an `AbortError`. This error is then caught and handled. `clearTimeout` is used to prevent the timeout from firing if the fetch completes successfully or fails for other reasons.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_async_await_error_1",
            "question_async_await_error_2",
            "question_async_await_error_3",
            "question_async_await_error_flashcard_1"
          ],
          "relatedTasks": [
            "task_robust_api_client"
          ],
          "tags": [
            "Asynchronous JavaScript",
            "Promises",
            "Error Handling",
            "Network Requests",
            "AbortController",
            "JavaScript ES2017+"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "promises",
            "async_await_basics",
            "error_handling"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "robust_api_clients",
            "real_time_applications"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_event_propagation_1",
          "topic": "Event Propagation Order",
          "level": "easy",
          "type": "mcq",
          "question": "When a click event occurs on a child element within a parent element, which of the following describes the correct order of phases in which event listeners are triggered by default?",
          "answer": "Capturing phase (parent) -> Capturing phase (child) -> Bubbling phase (child) -> Bubbling phase (parent)",
          "options": [
            "Capturing phase (parent) -> Bubbling phase (parent) -> Capturing phase (child) -> Bubbling phase (child)",
            "Bubbling phase (child) -> Bubbling phase (parent) -> Capturing phase (child) -> Capturing phase (parent)",
            "Capturing phase (parent) -> Capturing phase (child) -> Bubbling phase (child) -> Bubbling phase (parent)",
            "Bubbling phase (parent) -> Capturing phase (parent) -> Bubbling phase (child) -> Capturing phase (child)"
          ],
          "analysisPoints": [
            "Understanding that event propagation starts with the capturing phase.",
            "Recognizing the flow from ancestor to target in capturing.",
            "Recognizing the flow from target to ancestor in bubbling.",
            "Knowing that event listeners on the target itself will trigger capturing first, then bubbling."
          ],
          "keyConcepts": [
            "Event Capturing",
            "Event Bubbling",
            "Event Flow"
          ],
          "evaluationCriteria": [
            "Correct recall of event propagation phases.",
            "Ability to sequence event listener execution."
          ],
          "example": "The browser first performs the capturing phase, moving from the document root down to the target element. Then, it performs the bubbling phase, moving from the target element back up to the document root. Listeners on the element itself fire during both phases, with capturing listeners firing first.",
          "tags": [
            "DOM",
            "Events",
            "Event Propagation"
          ],
          "prerequisites": [
            "event_listeners"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_propagation_2",
          "topic": "addEventListener useCapture Parameter",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose of the third argument (or options object with `capture` property) in `addEventListener`. Provide a scenario where setting it to `true` would be beneficial.",
          "answer": "The third argument in `addEventListener` (or the `capture` property in the options object) determines whether the listener is registered for the capturing phase (`true`) or the bubbling phase (`false`, which is the default). When set to `true`, the listener will be triggered during the capturing phase as the event propagates down to the target element.\n\n**Scenario for `capture: true`:**\nConsider a case where you want to prevent clicks on any element *inside* a specific container from reaching their intended target, perhaps to implement a modal overlay that blocks interaction with the underlying content. You could attach a click listener to the container with `capture: true` and call `e.stopPropagation()` and/or `e.preventDefault()`. This listener would fire during the capturing phase *before* the click event reaches any child elements, allowing you to intercept and stop it early. This is useful for implementing global interceptors or decorators for events.",
          "analysisPoints": [
            "Understanding `useCapture`'s role in event phases.",
            "Ability to articulate the practical benefits of capturing.",
            "Providing a relevant and well-explained use case."
          ],
          "keyConcepts": [
            "Event Capturing",
            "addEventListener",
            "Event Propagation"
          ],
          "evaluationCriteria": [
            "Clarity of explanation.",
            "Practical application understanding.",
            "Accuracy of technical details."
          ],
          "example": "```javascript\n<div id=\"overlay\" style=\"position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center;\">\n  <button id=\"modalButton\">Click Me (within modal)</button>\n</div>\n<button id=\"pageButton\">Click Me (on page)</button>\n\n<script>\n  document.getElementById('overlay').addEventListener('click', function(e) {\n    console.log('Overlay capturing:', e.target.id);\n    e.stopPropagation(); // Stop propagation from going further down or bubbling up\n  }, true); // Listen in capturing phase\n\n  document.getElementById('modalButton').addEventListener('click', function(e) {\n    console.log('Modal button clicked');\n  });\n\n  document.getElementById('pageButton').addEventListener('click', function(e) {\n    console.log('Page button clicked');\n  });\n\n  // To demonstrate, try clicking pageButton when overlay is visible.\n  // If overlay has capture:true and stopPropagation, pageButton's click will be blocked.\n</script>\n```",
          "tags": [
            "DOM",
            "Events",
            "Event Listeners",
            "JavaScript"
          ],
          "prerequisites": [
            "event_propagation"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_propagation_3",
          "topic": "Event Propagation Scenario Analysis",
          "level": "hard",
          "type": "code",
          "question": "Consider the following HTML and JavaScript. Predict the exact sequence of console logs when the 'Inner Div' is clicked. Explain your reasoning for each log.",
          "answer": "```javascript\n// Expected Output:\n// Outer Div (Capturing)\n// Inner Div (Capturing)\n// Inner Div (Bubbling)\n// Outer Div (Bubbling)\n```\n\n**Reasoning:**\n1.  **'Outer Div (Capturing)'**: The click event originates on the 'Inner Div'. The browser first enters the capturing phase, traversing from the `document` down to the target. The `outerDiv` has a listener attached with `true` for the capturing phase, so it logs first.\n2.  **'Inner Div (Capturing)'**: The event continues its capturing journey. The `innerDiv` also has a listener attached with `true` for the capturing phase, so it logs next.\n3.  **'Inner Div (Bubbling)'**: After the capturing phase completes, the event switches to the bubbling phase, starting at the target element (`innerDiv`). The `innerDiv` has a listener attached with `false` (or default) for the bubbling phase, so it logs.\n4.  **'Outer Div (Bubbling)'**: The event then bubbles up to the parent element. The `outerDiv` has a listener attached with `false` (or default) for the bubbling phase, so it logs last.",
          "options": [],
          "analysisPoints": [
            "Correctly identifying the capturing phase flow.",
            "Correctly identifying the bubbling phase flow.",
            "Understanding that `addEventListener`'s third argument controls the phase.",
            "Applying the complete event propagation model (capturing down, then bubbling up)."
          ],
          "keyConcepts": [
            "Event Capturing",
            "Event Bubbling",
            "addEventListener",
            "Event Flow"
          ],
          "evaluationCriteria": [
            "Precise prediction of output.",
            "Clear and accurate justification for each step.",
            "Demonstrated deep understanding of event propagation."
          ],
          "example": "```html\n<div id=\"outerDiv\" style=\"padding: 20px; background-color: lightblue;\">\n  Outer Div\n  <div id=\"innerDiv\" style=\"padding: 10px; background-color: lightcoral;\">\n    Inner Div\n  </div>\n</div>\n\n<script>\n  const outerDiv = document.getElementById('outerDiv');\n  const innerDiv = document.getElementById('innerDiv');\n\n  outerDiv.addEventListener('click', function(e) {\n    console.log('Outer Div (Capturing)');\n  }, true); // Capturing phase\n\n  innerDiv.addEventListener('click', function(e) {\n    console.log('Inner Div (Capturing)');\n  }, true); // Capturing phase\n\n  innerDiv.addEventListener('click', function(e) {\n    console.log('Inner Div (Bubbling)');\n  }, false); // Bubbling phase (default)\n\n  outerDiv.addEventListener('click', function(e) {\n    console.log('Outer Div (Bubbling)');\n  }, false); // Bubbling phase (default)\n</script>\n```",
          "tags": [
            "DOM",
            "Events",
            "JavaScript",
            "Event Propagation"
          ],
          "prerequisites": [
            "event_listeners",
            "event_propagation"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_event_propagation_flashcard_1",
          "topic": "Event Propagation Phases",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the two main phases of event propagation in the DOM?",
          "answer": "Capturing phase and Bubbling phase.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Event Propagation",
            "Capturing Phase",
            "Bubbling Phase"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "DOM",
            "Events",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_stopping_propagation_1",
          "topic": "Event Stopping Methods",
          "level": "easy",
          "type": "mcq",
          "question": "Which method prevents the browser's default action associated with an event (e.g., navigating when clicking a link) but allows the event to continue propagating through the DOM?",
          "answer": "`e.preventDefault()`",
          "options": [
            "`e.stopPropagation()`",
            "`e.stopImmediatePropagation()`",
            "`e.cancelBubble()`",
            "`e.preventDefault()`"
          ],
          "analysisPoints": [
            "Distinguishing between preventing default behavior and stopping propagation.",
            "Identifying the correct method for each scenario."
          ],
          "keyConcepts": [
            "preventDefault",
            "stopPropagation",
            "Event Handling"
          ],
          "evaluationCriteria": [
            "Correctly identifying the method for default action prevention.",
            "Understanding the side effects (or lack thereof) on propagation."
          ],
          "example": "When a user clicks on an `<a>` tag, `e.preventDefault()` will stop the browser from navigating to the `href` URL, but the click event will still bubble up to parent elements. This is crucial for single-page applications where navigation is handled by JavaScript.",
          "tags": [
            "DOM",
            "Events",
            "JavaScript"
          ],
          "prerequisites": [
            "event_listeners"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_stopping_propagation_2",
          "topic": "Difference between stopPropagation and stopImmediatePropagation",
          "level": "medium",
          "type": "open",
          "question": "Explain the difference between `e.stopPropagation()` and `e.stopImmediatePropagation()`. Provide a simple code example illustrating when `stopImmediatePropagation()` would be necessary.",
          "answer": "`e.stopPropagation()` prevents the event from continuing its journey up (or down) the DOM tree to parent (or child) elements. It stops propagation to subsequent elements in the hierarchy.\n\n`e.stopImmediatePropagation()` does two things: it stops propagation to parent/child elements (like `stopPropagation()`), AND it prevents any other event handlers *on the same element* (for the same event type) from executing. If an element has multiple listeners for the same event, `stopImmediatePropagation()` ensures only the ones registered before it will run.\n\n**Example for `stopImmediatePropagation()`:**\n```html\n<button id=\"myButton\">Click Me</button>\n\n<script>\n  const button = document.getElementById('myButton');\n\n  button.addEventListener('click', function(e) {\n    console.log('Handler 1: This will always run.');\n    e.stopImmediatePropagation(); // Stops further handlers on this element AND bubbling\n  });\n\n  button.addEventListener('click', function(e) {\n    console.log('Handler 2: This will NOT run because Handler 1 called stopImmediatePropagation.');\n  });\n\n  document.body.addEventListener('click', function(e) {\n    console.log('Body Handler: This will NOT run either due to stopImmediatePropagation from button.');\n  });\n</script>\n```\nIn this example, clicking 'myButton' will only log 'Handler 1'. 'Handler 2' (on the same button) and 'Body Handler' (on a parent element) will not execute.",
          "analysisPoints": [
            "Clear distinction between stopping propagation to ancestors vs. stopping propagation to sibling handlers.",
            "Accurate code example that highlights the unique effect of `stopImmediatePropagation()`."
          ],
          "keyConcepts": [
            "stopPropagation",
            "stopImmediatePropagation",
            "Event Handling"
          ],
          "evaluationCriteria": [
            "Accuracy of definitions.",
            "Effectiveness of the illustrative code.",
            "Understanding of specific use cases."
          ],
          "example": "See provided answer for code example.",
          "tags": [
            "DOM",
            "Events",
            "JavaScript"
          ],
          "prerequisites": [
            "event_listeners",
            "event_propagation"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_stopping_propagation_3",
          "topic": "Combined Event Handling Scenario",
          "level": "hard",
          "type": "code",
          "question": "Given the following HTML and JavaScript, what will be printed to the console when the `link` element is clicked? Explain the behavior of each event handler.",
          "answer": "```javascript\n// Expected Output:\n// Link clicked! Default prevented.\n// Parent div click detected.\n```\n\n**Reasoning:**\n1.  **`link` click handler**: When the link is clicked, its first `addEventListener` is triggered. `e.preventDefault()` is called, which stops the default browser behavior of navigating to 'https://example.com'. `console.log('Link clicked! Default prevented.')` is then executed.\n2.  **`link` second click handler**: This handler is not affected by `e.preventDefault()`, as `preventDefault()` only stops the browser's default action, not propagation or other handlers on the same element. So, `console.log('Another handler on link.')` would normally run. *However*, there is no second handler on the `link` in the provided code snippet, only the `div`'s bubbling handler. If there was one, it would run.\n3.  **`div` click handler**: Since `e.preventDefault()` does *not* stop event propagation, the click event continues to bubble up to the `div` element. The `div`'s click listener then triggers, executing `console.log('Parent div click detected.')`.",
          "options": [],
          "analysisPoints": [
            "Understanding that `preventDefault()` doesn't stop propagation.",
            "Recognizing that events bubble up from target to ancestors.",
            "Correctly predicting the console output based on event flow."
          ],
          "keyConcepts": [
            "preventDefault",
            "Event Bubbling",
            "Event Handling"
          ],
          "evaluationCriteria": [
            "Accurate prediction of console logs.",
            "Clear explanation of `preventDefault()`'s scope.",
            "Demonstrated understanding of event flow."
          ],
          "example": "```html\n<div id=\"parentDiv\" style=\"padding: 20px; background-color: lightblue;\">\n  Parent Div\n  <a href=\"https://example.com\" id=\"link\" style=\"display: block; margin-top: 10px;\">Click Me Link</a>\n</div>\n\n<script>\n  document.getElementById('link').addEventListener('click', function(e) {\n    e.preventDefault(); // Prevents navigation\n    console.log('Link clicked! Default prevented.');\n    // Event still bubbles\n  });\n\n  document.getElementById('parentDiv').addEventListener('click', function(e) {\n    console.log('Parent div click detected.');\n  });\n</script>\n```",
          "tags": [
            "DOM",
            "Events",
            "JavaScript",
            "preventDefault",
            "Event Propagation"
          ],
          "prerequisites": [
            "event_listeners",
            "event_propagation",
            "stopping_event_propagation_default"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_stopping_propagation_flashcard_1",
          "topic": "Preventing Default Behavior",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of `event.preventDefault()`?",
          "answer": "To stop the browser's default action associated with an event (e.g., submitting a form, navigating a link) without necessarily stopping event propagation.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "preventDefault",
            "Event Handling"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "DOM",
            "Events",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_delegation_1",
          "topic": "Benefits of Event Delegation",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is NOT a primary benefit of using event delegation?",
          "answer": "It automatically adjusts event listeners if the DOM structure changes drastically.",
          "options": [
            "Reduced memory footprint due to fewer event listeners.",
            "Automatic handling of dynamically added elements.",
            "Simplified code by reducing the need for attach/detach logic.",
            "It automatically adjusts event listeners if the DOM structure changes drastically."
          ],
          "analysisPoints": [
            "Recalling the core benefits of event delegation (efficiency, dynamic elements, simpler code).",
            "Identifying a statement that is not a direct benefit or is misleading (structural changes may still require re-evaluation of target logic, but not listener re-attachment).",
            "Understanding that 'drastically' changed DOM structure might still require changes to the delegation logic itself, even if listeners don't need re-attaching."
          ],
          "keyConcepts": [
            "Event Delegation",
            "Performance",
            "Dynamic Elements"
          ],
          "evaluationCriteria": [
            "Correctly identifying non-benefits.",
            "Understanding the scope of event delegation's advantages."
          ],
          "example": "Event delegation's strength is that it manages events for current and future children within a *stable* parent. While adding/removing children is fine, a fundamental restructuring of the *parent-child relationship* or the `tagName` logic used within the delegate might still require code changes, which is what the incorrect option implies.",
          "tags": [
            "DOM",
            "Events",
            "Event Delegation",
            "Performance"
          ],
          "prerequisites": [
            "event_propagation"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_delegation_2",
          "topic": "Implementing Event Delegation",
          "level": "medium",
          "type": "code",
          "question": "You have an unordered list (`<ul>`) with several list items (`<li>`). You want to log the text content of any `<li>` that is clicked. Demonstrate how to achieve this using event delegation, including how to handle `e.target`.",
          "answer": "```html\n<ul id=\"myList\">\n  <li>Item One</li>\n  <li>Item Two</li>\n  <li>Item Three</li>\n</ul>\n\n<script>\n  const myList = document.getElementById('myList');\n\n  myList.addEventListener('click', function(e) {\n    // Check if the clicked element (e.target) is an <li>\n    if (e.target.tagName === 'LI') {\n      console.log('Clicked item:', e.target.textContent);\n      // You could also add more specific checks, e.g., by class name:\n      // if (e.target.classList.contains('clickable-item')) {\n      //   console.log('Clickable item clicked:', e.target.textContent);\n      // }\n    }\n  });\n</script>\n```",
          "options": [],
          "analysisPoints": [
            "Correctly attaching the listener to the parent (`ul`).",
            "Using `e.target` to identify the specific child element that was clicked.",
            "Implementing a check (e.g., `tagName`) to ensure the target is the desired element type.",
            "Accessing properties like `textContent` from `e.target`."
          ],
          "keyConcepts": [
            "Event Delegation",
            "e.target",
            "Event Bubbling",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Correct implementation of event delegation.",
            "Proper use of `e.target`.",
            "Clear and functional code."
          ],
          "example": "The code demonstrates attaching a single click listener to the `<ul>` element. When a click occurs anywhere within the `<ul>`, the event bubbles up to it. Inside the handler, `e.target` is used to identify the actual element that was clicked (e.g., one of the `<li>`s). A check ensures that only clicks on `<li>` elements are processed, and their `textContent` is logged.",
          "tags": [
            "DOM",
            "Events",
            "Event Delegation",
            "JavaScript"
          ],
          "prerequisites": [
            "event_propagation",
            "event_listeners"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_delegation_3",
          "topic": "Event Delegation vs. Individual Listeners",
          "level": "hard",
          "type": "open",
          "question": "You are building a dynamic photo gallery where users can add or remove images. Each image, when clicked, should open a full-screen viewer. Discuss the advantages of using event delegation for this feature compared to attaching individual listeners to each image element. How would you handle clicks on non-image elements within the gallery container?",
          "answer": "**Advantages of Event Delegation:**\n1.  **Memory Efficiency**: Instead of `N` listeners for `N` images, only one listener is needed on the gallery container. This significantly reduces memory consumption, especially with many images.\n2.  **Dynamic Elements**: When new images are added or existing ones are removed, no manual `addEventListener` or `removeEventListener` calls are needed. The single delegated listener on the container will automatically handle events for all current and future images.\n3.  **Simplified Code**: Less boilerplate code is required for managing listeners, leading to cleaner and more maintainable code.\n4.  **Performance**: Fewer active listeners in the DOM can lead to better overall performance, especially during DOM mutations.\n\n**Handling Clicks on Non-Image Elements:**\nWhen using event delegation, the listener is on a parent element, so clicks on *any* child of that parent will trigger the handler. To ensure only image clicks are processed, you'd check `e.target` within the delegated handler:\n\n```javascript\nconst gallery = document.getElementById('photoGallery');\n\ngallery.addEventListener('click', function(e) {\n  // Check if the clicked element (e.target) is an <img> tag\n  // Or, if images have a specific class, e.g., 'gallery-image'\n  if (e.target.tagName === 'IMG' || e.target.classList.contains('gallery-image')) {\n    console.log('Image clicked:', e.target.src); // Or e.target.dataset.imageId\n    openFullScreenViewer(e.target.src);\n  } else {\n    // Optionally handle clicks on non-image elements, or do nothing\n    console.log('Clicked on a non-image element within the gallery:', e.target.tagName);\n  }\n});\n\nfunction openFullScreenViewer(imageUrl) {\n  // Logic to display image in full-screen\n  alert('Opening: ' + imageUrl);\n}\n```\nThis approach ensures that clicks on elements like text descriptions, navigation buttons, or placeholders within the gallery container are ignored or handled differently without interfering with the image click logic.",
          "analysisPoints": [
            "Thorough understanding of event delegation benefits.",
            "Ability to compare delegated vs. individual listener approaches.",
            "Practical application of `e.target` to filter events.",
            "Consideration of edge cases (non-target clicks)."
          ],
          "keyConcepts": [
            "Event Delegation",
            "Performance Optimization",
            "Dynamic Content",
            "e.target",
            "DOM Events"
          ],
          "evaluationCriteria": [
            "Comprehensive enumeration of advantages.",
            "Clear and correct explanation of event filtering.",
            "Appropriate code example for the scenario."
          ],
          "example": "See provided answer for code example.",
          "tags": [
            "DOM",
            "Events",
            "Event Delegation",
            "Performance",
            "Architecture"
          ],
          "prerequisites": [
            "event_delegation",
            "dom_manipulation"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_event_delegation_flashcard_1",
          "topic": "Event Delegation Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What is event delegation?",
          "answer": "A technique where you attach a single event listener to a common ancestor element, rather than individual listeners to multiple descendant elements, leveraging event bubbling to handle events.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Event Delegation",
            "Event Bubbling"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "DOM",
            "Events",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_await_1",
          "topic": "Async/Await Basics",
          "level": "easy",
          "type": "mcq",
          "question": "Which statement about `async` and `await` is true?",
          "answer": "An `async` function always returns a Promise.",
          "options": [
            "The `await` keyword can be used anywhere in JavaScript code.",
            "An `async` function always returns a Promise.",
            "Using `async/await` makes JavaScript code blocking.",
            "`await` can only be used with synchronous functions."
          ],
          "analysisPoints": [
            "Understanding that `await` must be inside an `async` function.",
            "Knowing that `async` functions always return Promises.",
            "Clarifying that `async/await` is non-blocking.",
            "Recognizing that `await` is for Promises (asynchronous operations)."
          ],
          "keyConcepts": [
            "async",
            "await",
            "Promises",
            "Asynchronous JavaScript"
          ],
          "evaluationCriteria": [
            "Correctly identifying core characteristics of `async`/`await`.",
            "Dispelling common misconceptions (blocking nature, placement of `await`)."
          ],
          "example": "```javascript\nasync function myFunction() {\n  return 10; // This will return Promise.resolve(10)\n}\nmyFunction().then(value => console.log(value)); // Logs 10\n\nasync function otherFunction() {\n  const result = await Promise.resolve(5);\n  console.log(result); // Logs 5 after the promise resolves\n}\notherFunction();\n```",
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Promises"
          ],
          "prerequisites": [
            "promises"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_await_2",
          "topic": "Async/Await Error Handling",
          "level": "medium",
          "type": "code",
          "question": "Write an `async` function called `fetchUserData` that takes a `userId`. Inside this function, simulate fetching user data from an API that might fail. Implement error handling using `try...catch` such that if the fetch fails, it logs an error message and returns `null`.",
          "answer": "```javascript\nasync function simulateFetchUser(userId) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId === 1) {\n        resolve({ id: 1, name: 'Alice', email: 'alice@example.com' });\n      } else if (userId === 2) {\n        reject(new Error('User with ID 2 not found.'));\n      } else {\n        reject(new Error('Invalid user ID provided.'));\n      }\n    }, 500);\n  });\n}\n\nasync function fetchUserData(userId) {\n  try {\n    console.log(`Attempting to fetch user with ID: ${userId}`);\n    const userData = await simulateFetchUser(userId);\n    console.log(`Successfully fetched user: ${JSON.stringify(userData)}`);\n    return userData;\n  } catch (error) {\n    console.error(`Error fetching user ${userId}: ${error.message}`);\n    return null; // Return null or a default value on error\n  }\n}\n\n// Test cases\n(async () => {\n  await fetchUserData(1); // Should succeed\n  await fetchUserData(2); // Should fail (User not found)\n  await fetchUserData(3); // Should fail (Invalid user ID)\n})();\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `async` keyword.",
            "Proper use of `await` with a Promise.",
            "Implementation of `try...catch` for error handling.",
            "Handling the rejected Promise from `await` by logging and returning `null`.",
            "Providing simulated asynchronous operation (Promise with `setTimeout`)."
          ],
          "keyConcepts": [
            "async",
            "await",
            "Error Handling",
            "Promises",
            "try...catch"
          ],
          "evaluationCriteria": [
            "Functional `async` function.",
            "Correct error handling implementation.",
            "Clear and understandable code."
          ],
          "example": "See provided answer for code example.",
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Error Handling",
            "Promises"
          ],
          "prerequisites": [
            "promises",
            "async_await_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_await_3",
          "topic": "Async/Await Execution Flow",
          "level": "hard",
          "type": "code",
          "question": "Analyze the following JavaScript code. What will be the exact order of console logs? Explain why.",
          "answer": "```javascript\n// Expected Output:\n// Start\n// Before await\n// Function call complete (non-blocking)\n// After await (resolved)\n```\n\n**Reasoning:**\n1.  **`console.log('Start');`**: This is the first synchronous line of code, so it executes immediately.\n2.  **`console.log('Before await');`**: `myAsyncFunction` is called. The first line inside it is synchronous, so it logs immediately.\n3.  **`await delay(1000);`**: The `await` keyword pauses the execution of `myAsyncFunction`. It does *not* pause the entire program. The `delay` function returns a Promise that will resolve after 1 second. The `myAsyncFunction` is suspended, and control is returned to the event loop.\n4.  **`console.log('Function call complete (non-blocking)');`**: This line is outside the `async` function and runs immediately after `myAsyncFunction` is called and pauses at `await`. This demonstrates the non-blocking nature of `async/await`.\n5.  **`// 1 second delay passes`**\n6.  **`console.log('After await (resolved)');`**: After 1 second, the `delay(1000)` Promise resolves. The `myAsyncFunction` resumes execution from where it left off (after the `await`), and this line is logged.",
          "options": [],
          "analysisPoints": [
            "Understanding that `await` pauses only the `async` function, not the entire program.",
            "Identifying synchronous vs. asynchronous execution parts.",
            "Correctly predicting the interleaving of logs due to the event loop."
          ],
          "keyConcepts": [
            "async",
            "await",
            "Event Loop",
            "Asynchronous JavaScript"
          ],
          "evaluationCriteria": [
            "Accurate prediction of console output.",
            "Clear explanation of `async`/`await`'s non-blocking behavior.",
            "Demonstrated understanding of the JavaScript Event Loop."
          ],
          "example": "```javascript\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function myAsyncFunction() {\n  console.log('Before await');\n  await delay(1000); // This pauses the function for 1 second\n  console.log('After await (resolved)');\n}\n\nconsole.log('Start');\nmyAsyncFunction();\nconsole.log('Function call complete (non-blocking)');\n```",
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Event Loop",
            "Concurrency"
          ],
          "prerequisites": [
            "promises",
            "async_await_basics",
            "event_loop_concept"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_async_await_flashcard_1",
          "topic": "Async/Await Purpose",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using `async/await`?",
          "answer": "It makes asynchronous code look and behave like synchronous code, improving readability and maintainability while retaining non-blocking behavior.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "async",
            "await",
            "Readability",
            "Asynchronous JavaScript"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_await_error_1",
          "topic": "Error Handling in Async/Await",
          "level": "easy",
          "type": "mcq",
          "question": "How should errors (rejected Promises) be handled within an `async` function using `await`?",
          "answer": "Using a `try...catch` block around the `await` expression.",
          "options": [
            "Using a `.then().catch()` chain after the `await`.",
            "Using a `try...catch` block around the `await` expression.",
            "Errors are automatically caught by the surrounding function without explicit `try...catch`.",
            "Only global error handlers can catch errors from `await`."
          ],
          "analysisPoints": [
            "Identifying the standard pattern for error handling with `async/await`.",
            "Differentiating from Promise chaining, which `async/await` simplifies.",
            "Understanding that `await` effectively converts Promise rejections into thrown errors."
          ],
          "keyConcepts": [
            "Error Handling",
            "async",
            "await",
            "try...catch"
          ],
          "evaluationCriteria": [
            "Correctly identifying the `try...catch` pattern.",
            "Understanding how `await` integrates with traditional error handling."
          ],
          "example": "```javascript\nasync function mightFail() {\n  return Promise.reject(new Error('Something went wrong!'));\n}\n\nasync function process() {\n  try {\n    const result = await mightFail();\n    console.log(result);\n  } catch (error) {\n    console.error('Caught an error:', error.message);\n  }\n}\nprocess(); // Will log 'Caught an error: Something went wrong!'\n```",
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Error Handling"
          ],
          "prerequisites": [
            "async_await_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_await_error_2",
          "topic": "AbortController for Timeouts",
          "level": "medium",
          "type": "open",
          "question": "Explain the role of `AbortController` in implementing a timeout for a `fetch` request with `async/await`. Describe the sequence of steps involved.",
          "answer": "The `AbortController` API provides a mechanism to cancel (abort) DOM requests like `fetch`. It's crucial for timeouts because `fetch` itself doesn't have a built-in timeout option.\n\n**Role of `AbortController`:**\n`AbortController` creates an `AbortSignal` object, which can be associated with an `fetch` request. When `controller.abort()` is called, the signal is triggered, causing any associated `fetch` request to immediately reject with an `AbortError` (a DOMException).\n\n**Sequence of Steps for Timeout:**\n1.  **Instantiate `AbortController`**: Create `const controller = new AbortController();`.\n2.  **Get the Signal**: Access the signal: `const signal = controller.signal;`.\n3.  **Set Timeout for Abort**: Use `setTimeout` to call `controller.abort()` after the desired timeout duration: `const timeoutId = setTimeout(() => controller.abort(), timeoutMs);`.\n4.  **Pass Signal to `fetch`**: Include the `signal` in the `fetch` options: `const response = await fetch(url, { signal });`.\n5.  **Clear Timeout**: If the `fetch` request resolves or rejects for reasons *other than* a timeout (e.g., successful response, network error), call `clearTimeout(timeoutId)` to prevent `controller.abort()` from being called unnecessarily.\n6.  **Handle AbortError**: In the `catch` block of the `try...catch` surrounding the `fetch`, check if `error.name === 'AbortError'` to specifically handle the timeout case, distinguishing it from other network errors.",
          "analysisPoints": [
            "Understanding `AbortController`'s purpose.",
            "Correctly outlining the steps to implement a timeout.",
            "Knowing how to differentiate `AbortError` from other errors.",
            "Importance of `clearTimeout`."
          ],
          "keyConcepts": [
            "AbortController",
            "fetch API",
            "Timeouts",
            "Asynchronous Programming",
            "Error Handling"
          ],
          "evaluationCriteria": [
            "Clear and concise explanation.",
            "Accurate step-by-step process.",
            "Demonstrated knowledge of `AbortController` and error types."
          ],
          "example": "See `theory_async_await_error_handling_timeout` for the code example. It clearly shows the usage of `AbortController` within a `fetchWithTimeout` function.",
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Network",
            "Error Handling",
            "API"
          ],
          "prerequisites": [
            "async_await_basics",
            "fetch_api",
            "promises"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_async_await_error_3",
          "topic": "Chaining Async Operations with Error Handling",
          "level": "hard",
          "type": "code",
          "question": "Implement an `async` function `processUserWorkflow` that performs the following steps in sequence:\n1.  `fetchUser(id)`: Fetches user data. Should simulate a network error (reject) if `id` is 0.\n2.  `validateUser(user)`: Validates user data. Should simulate a validation error (reject) if `user.name` is empty.\n3.  `saveUser(user)`: Saves the user data. Should always resolve.\n\nYour `processUserWorkflow` function should use `async/await` and handle errors at each step, logging a specific message for each type of error. If any step fails, the subsequent steps should not execute, and the function should return `false`. If all steps succeed, it should return `true`.",
          "answer": "```javascript\nasync function fetchUser(id) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (id === 0) {\n        reject(new Error('Network Error: User ID 0 is reserved.'));\n      } else {\n        resolve({ id: id, name: id === 99 ? '' : `User ${id}`, email: `user${id}@example.com` });\n      }\n    }, 500);\n  });\n}\n\nasync function validateUser(user) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (!user || !user.name) {\n        reject(new Error('Validation Error: User name cannot be empty.'));\n      } else {\n        resolve(user);\n      }\n    }, 200);\n  });\n}\n\nasync function saveUser(user) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(`User ${user.id} saved successfully!`);\n      resolve(true);\n    }, 300);\n  });\n}\n\nasync function processUserWorkflow(userId) {\n  let user;\n  try {\n    console.log(`Starting workflow for user ${userId}...`);\n    user = await fetchUser(userId);\n    console.log(`User ${userId} fetched.`);\n\n    await validateUser(user);\n    console.log(`User ${userId} validated.`);\n\n    await saveUser(user);\n    console.log(`Workflow for user ${userId} completed successfully.`);\n    return true;\n  } catch (error) {\n    if (error.message.includes('Network Error')) {\n      console.error(`Workflow Failed: ${error.message}`);\n    } else if (error.message.includes('Validation Error')) {\n      console.error(`Workflow Failed: ${error.message}`);\n    } else {\n      console.error(`An unexpected error occurred during workflow for user ${userId}: ${error.message}`);\n    }\n    return false;\n  }\n}\n\n// Test cases\n(async () => {\n  console.log('\\n--- Test Case 1: Success ---');\n  let result1 = await processUserWorkflow(1);\n  console.log(`Result for user 1: ${result1}`); // Expected: true\n\n  console.log('\\n--- Test Case 2: Network Error ---');\n  let result2 = await processUserWorkflow(0);\n  console.log(`Result for user 0: ${result2}`); // Expected: false\n\n  console.log('\\n--- Test Case 3: Validation Error ---');\n  let result3 = await processUserWorkflow(99); // Simulates empty name\n  console.log(`Result for user 99: ${result3}`); // Expected: false\n})();\n```",
          "options": [],
          "analysisPoints": [
            "Correctly structuring chained `await` calls.",
            "Centralized `try...catch` block for multiple `await` calls.",
            "Differentiating error types using `error.message` or custom error classes.",
            "Returning appropriate boolean status.",
            "Simulating realistic async operations and failures."
          ],
          "keyConcepts": [
            "async",
            "await",
            "Promises",
            "Error Handling",
            "Chaining Asynchronous Operations",
            "Control Flow"
          ],
          "evaluationCriteria": [
            "Functional, robust `async` workflow.",
            "Effective error handling for different failure points.",
            "Correct return values based on success/failure.",
            "Readable and maintainable code structure."
          ],
          "example": "See provided answer for comprehensive code example and test cases.",
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Error Handling",
            "Workflow",
            "Promises"
          ],
          "prerequisites": [
            "async_await_basics",
            "async_await_error_handling_timeout"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_async_await_error_flashcard_1",
          "topic": "Aborting Fetch Requests",
          "level": "medium",
          "type": "flashcard",
          "question": "Which API is commonly used with `fetch` to cancel a request, often for implementing timeouts?",
          "answer": "The `AbortController` API.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "AbortController",
            "fetch API",
            "Timeouts"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "JavaScript",
            "Network",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_event_propagation_visualizer",
          "title": "Interactive Event Propagation Visualizer",
          "description": "\nCreate a simple HTML page with nested `div` elements (e.g., Grandparent > Parent > Child). Attach click event listeners to each `div`.\n\n**Requirements:**\n1.  Each `div` should display its name (e.g., 'Grandparent', 'Parent', 'Child').\n2.  When a `div` is clicked, log to the console the `id` of the element, the `event.target.id`, the `event.currentTarget.id`, and indicate if the listener is for the 'capturing' or 'bubbling' phase.\n3.  Implement listeners for *both* capturing and bubbling phases on all three `div`s.\n4.  Add a button to the child div. When clicked, it should call `e.stopPropagation()` and log a message indicating that propagation was stopped.\n5.  Visually distinguish the `div`s (e.g., with different background colors and borders).\n\nYour solution should help demonstrate the order of event propagation and the effect of `stopPropagation()`.\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Event Propagation Visualizer</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    .grandparent, .parent, .child {\n      padding: 20px;\n      border: 2px solid black;\n      margin: 10px;\n      text-align: center;\n      font-weight: bold;\n    }\n    .grandparent { background-color: #e0f2f7; border-color: blue; }\n    .parent { background-color: #c8e6c9; border-color: green; }\n    .child { background-color: #ffe0b2; border-color: orange; }\n    button { margin-top: 10px; padding: 5px 10px; }\n  </style>\n</head>\n<body>\n  <div id=\"grandparent\" class=\"grandparent\">\n    Grandparent\n    <div id=\"parent\" class=\"parent\">\n      Parent\n      <div id=\"child\" class=\"child\">\n        Child\n        <button id=\"stopBtn\">Stop Propagation</button>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    const grandparent = document.getElementById('grandparent');\n    const parent = document.getElementById('parent');\n    const child = document.getElementById('child');\n    const stopBtn = document.getElementById('stopBtn');\n\n    // TODO: Add event listeners for capturing and bubbling phases for grandparent, parent, and child\n    // TODO: Implement stopPropagation on the stopBtn click handler\n\n  </script>\n</body>\n</html>",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Event Propagation Visualizer</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    .grandparent, .parent, .child {\n      padding: 20px;\n      border: 2px solid black;\n      margin: 10px;\n      text-align: center;\n      font-weight: bold;\n    }\n    .grandparent { background-color: #e0f2f7; border-color: blue; }\n    .parent { background-color: #c8e6c9; border-color: green; }\n    .child { background-color: #ffe0b2; border-color: orange; }\n    button { margin-top: 10px; padding: 5px 10px; }\n  </style>\n</head>\n<body>\n  <div id=\"grandparent\" class=\"grandparent\">\n    Grandparent\n    <div id=\"parent\" class=\"parent\">\n      Parent\n      <div id=\"child\" class=\"child\">\n        Child\n        <button id=\"stopBtn\">Stop Propagation</button>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    const grandparent = document.getElementById('grandparent');\n    const parent = document.getElementById('parent');\n    const child = document.getElementById('child');\n    const stopBtn = document.getElementById('stopBtn');\n\n    function addListeners(element, name) {\n      element.addEventListener('click', function(e) {\n        console.log(`[${name} - Capturing] target: ${e.target.id}, currentTarget: ${e.currentTarget.id}`);\n      }, true); // Capturing Phase\n\n      element.addEventListener('click', function(e) {\n        console.log(`[${name} - Bubbling] target: ${e.target.id}, currentTarget: ${e.currentTarget.id}`);\n      }, false); // Bubbling Phase\n    }\n\n    addListeners(grandparent, 'Grandparent');\n    addListeners(parent, 'Parent');\n    addListeners(child, 'Child');\n\n    stopBtn.addEventListener('click', function(e) {\n      console.log('Stop Button Clicked! Calling stopPropagation().');\n      e.stopPropagation();\n    });\n  </script>\n</body>\n</html>",
          "testCases": [
            "Click the 'Grandparent' div: Only Grandparent capturing and bubbling logs should appear.",
            "Click the 'Parent' div: Grandparent capturing -> Parent capturing -> Parent bubbling -> Grandparent bubbling logs should appear.",
            "Click the 'Child' div: Grandparent capturing -> Parent capturing -> Child capturing -> Child bubbling -> Parent bubbling -> Grandparent bubbling logs should appear.",
            "Click the 'Stop Propagation' button: Grandparent capturing -> Parent capturing -> Child capturing -> 'Stop Button Clicked!' log should appear, and then propagation should stop. No bubbling logs from Child, Parent, or Grandparent should appear."
          ],
          "hints": [
            "Remember that `event.target` is the element where the event originated, while `event.currentTarget` is the element to which the event listener is currently attached.",
            "The third argument of `addEventListener` (or the `capture` property in the options object) is key for distinguishing between capturing and bubbling phase listeners.",
            "Test clicking different elements to observe the full propagation path."
          ],
          "tags": [
            "DOM",
            "Events",
            "Event Propagation",
            "JavaScript",
            "Front-end Basics"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "event_propagation",
            "event_listeners"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "event_delegation",
            "stopPropagation"
          ]
        },
        {
          "id": "task_form_validation_and_propagation",
          "title": "Preventing Default Form Submission with Event Propagation Control",
          "description": "\nCreate an HTML form with a text input, a checkbox, and a submit button inside a `div` container. Implement client-side validation and demonstrate control over event propagation.\n\n**Requirements:**\n1.  When the form is submitted:\n    *   Prevent the default form submission (page reload).\n    *   Validate that the text input is not empty and the checkbox is checked.\n    *   If validation fails, display an error message below the form.\n    *   If validation passes, display a success message.\n2.  Add a click listener to the `div` container that wraps the form. This listener should log a message indicating that a click inside the container occurred.\n3.  Add a click listener directly to the submit button that logs 'Submit button clicked' and uses `e.stopImmediatePropagation()`.\n4.  Add a *second* click listener directly to the submit button that logs 'This should NOT appear'.\n\nObserve and explain the console output when you submit the form, especially noting the effects of `preventDefault()` and `stopImmediatePropagation()`.\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Form Validation & Propagation Control</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    .container { padding: 20px; border: 2px solid purple; margin-bottom: 20px; }\n    form { border: 1px solid #ccc; padding: 15px; }\n    label, input { display: block; margin-bottom: 10px; }\n    .error, .success { color: red; font-weight: bold; margin-top: 10px; }\n    .success { color: green; }\n  </style>\n</head>\n<body>\n  <div id=\"formContainer\" class=\"container\">\n    <h2>User Registration Form</h2>\n    <form id=\"myForm\">\n      <label for=\"username\">Username:</label>\n      <input type=\"text\" id=\"username\" name=\"username\">\n      \n      <input type=\"checkbox\" id=\"agree\" name=\"agree\">\n      <label for=\"agree\">I agree to terms and conditions</label>\n      \n      <button type=\"submit\" id=\"submitBtn\">Register</button>\n    </form>\n    <p id=\"message\"></p>\n  </div>\n\n  <script>\n    const form = document.getElementById('myForm');\n    const usernameInput = document.getElementById('username');\n    const agreeCheckbox = document.getElementById('agree');\n    const messagePara = document.getElementById('message');\n    const formContainer = document.getElementById('formContainer');\n    const submitBtn = document.getElementById('submitBtn');\n\n    // TODO: Add event listeners for form submission, container click, and submit button clicks\n\n  </script>\n</body>\n</html>",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Form Validation & Propagation Control</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    .container { padding: 20px; border: 2px solid purple; margin-bottom: 20px; }\n    form { border: 1px solid #ccc; padding: 15px; }\n    label, input { display: block; margin-bottom: 10px; }\n    .error, .success { color: red; font-weight: bold; margin-top: 10px; }\n    .success { color: green; }\n  </style>\n</head>\n<body>\n  <div id=\"formContainer\" class=\"container\">\n    <h2>User Registration Form</h2>\n    <form id=\"myForm\">\n      <label for=\"username\">Username:</label>\n      <input type=\"text\" id=\"username\" name=\"username\">\n      \n      <input type=\"checkbox\" id=\"agree\" name=\"agree\">\n      <label for=\"agree\">I agree to terms and conditions</label>\n      \n      <button type=\"submit\" id=\"submitBtn\">Register</button>\n    </form>\n    <p id=\"message\"></p>\n  </div>\n\n  <script>\n    const form = document.getElementById('myForm');\n    const usernameInput = document.getElementById('username');\n    const agreeCheckbox = document.getElementById('agree');\n    const messagePara = document.getElementById('message');\n    const formContainer = document.getElementById('formContainer');\n    const submitBtn = document.getElementById('submitBtn');\n\n    // 1. Form submission handler\n    form.addEventListener('submit', function(e) {\n      e.preventDefault(); // Prevent default page reload\n      messagePara.textContent = ''; // Clear previous messages\n      messagePara.className = '';\n\n      const username = usernameInput.value.trim();\n      const agreed = agreeCheckbox.checked;\n\n      if (username === '') {\n        messagePara.textContent = 'Error: Username cannot be empty.';\n        messagePara.className = 'error';\n        return;\n      }\n      if (!agreed) {\n        messagePara.textContent = 'Error: You must agree to the terms.';\n        messagePara.className = 'error';\n        return;\n      }\n\n      messagePara.textContent = 'Success! Form submitted.';\n      messagePara.className = 'success';\n      console.log('Form submission processed (validation passed).');\n    });\n\n    // 2. Container click listener\n    formContainer.addEventListener('click', function(e) {\n      console.log(`Container click detected. Target: ${e.target.id || e.target.tagName}. CurrentTarget: ${e.currentTarget.id}`);\n    });\n\n    // 3. First submit button click listener with stopImmediatePropagation\n    submitBtn.addEventListener('click', function(e) {\n      console.log('Submit button clicked! (Handler 1)');\n      e.stopImmediatePropagation(); // Stops further handlers on this button and bubbling\n    });\n\n    // 4. Second submit button click listener (will not run)\n    submitBtn.addEventListener('click', function(e) {\n      console.log('This should NOT appear! (Handler 2)');\n    });\n  </script>\n</body>\n</html>",
          "testCases": [
            "Submit an empty form: Should display 'Username cannot be empty.' and not reload. Console should show 'Submit button clicked! (Handler 1)'.",
            "Submit with username but unchecked checkbox: Should display 'You must agree to the terms.' and not reload. Console should show 'Submit button clicked! (Handler 1)'.",
            "Submit with valid username and checked checkbox: Should display 'Success!' and not reload. Console should show 'Submit button clicked! (Handler 1)' and 'Form submission processed (validation passed).'",
            "Click anywhere inside the container but not on the button (e.g., on the label): Container click log should appear.",
            "Observe console: Verify that 'This should NOT appear!' never logs and that 'Container click detected' does not log when the submit button is clicked (due to `stopImmediatePropagation`)."
          ],
          "hints": [
            "Remember that `preventDefault()` prevents the browser's default action, but it does *not* stop event propagation. `stopPropagation()` or `stopImmediatePropagation()` are needed for that.",
            "`submit` events on forms can be triggered by clicking a submit button or pressing Enter in a text field.",
            "Pay close attention to the order of `addEventListener` calls when testing `stopImmediatePropagation()`."
          ],
          "tags": [
            "DOM",
            "Forms",
            "Events",
            "Validation",
            "JavaScript",
            "stopPropagation",
            "preventDefault",
            "stopImmediatePropagation"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "event_propagation",
            "stopping_event_propagation_default",
            "form_handling"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "event_delegation",
            "client_side_validation"
          ]
        },
        {
          "id": "task_dynamic_list_management",
          "title": "Interactive Shopping List with Event Delegation",
          "description": "\nBuild a simple interactive shopping list application. Users should be able to add new items, mark items as 'purchased', and remove items.\n\n**Requirements:**\n1.  **Add Item**: An input field and a 'Add Item' button. When the button is clicked, the text from the input field should be added as a new `<li>` to an unordered list (`<ul>`). The input field should be cleared after adding.\n2.  **Mark as Purchased**: When an `<li>` is clicked, toggle a 'purchased' class on it. This class should apply a strikethrough style.\n3.  **Remove Item**: Each `<li>` should have a 'Remove' button next to it. Clicking this button should remove the corresponding `<li>` from the list.\n4.  **Event Delegation**: Crucially, *all* interactions (marking as purchased, removing) on list items should be handled using **event delegation** on the `<ul>` element. This means only one click listener on the `<ul>` for handling clicks on dynamically added `<li>`s and their nested 'Remove' buttons.\n",
          "difficulty": "hard",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Shopping List with Delegation</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    ul { list-style: none; padding: 0; }\n    li { background-color: #f0f0f0; padding: 10px; margin-bottom: 5px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; }\n    li.purchased { text-decoration: line-through; background-color: #d4edda; color: #505050; }\n    li button { background-color: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; }\n    #addItemContainer { margin-bottom: 20px; }\n    #addItemInput { padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-right: 10px; }\n    #addItemButton { background-color: #007bff; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; }\n  </style>\n</head>\n<body>\n  <h1>My Shopping List</h1>\n\n  <div id=\"addItemContainer\">\n    <input type=\"text\" id=\"addItemInput\" placeholder=\"Add a new item\">\n    <button id=\"addItemButton\">Add Item</button>\n  </div>\n\n  <ul id=\"shoppingList\">\n    <!-- Dynamic items will go here -->\n  </ul>\n\n  <script>\n    const addItemInput = document.getElementById('addItemInput');\n    const addItemButton = document.getElementById('addItemButton');\n    const shoppingList = document.getElementById('shoppingList');\n\n    // TODO: Implement adding new items\n\n    // TODO: Implement event delegation for mark/remove actions\n\n  </script>\n</body>\n</html>",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Shopping List with Delegation</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    ul { list-style: none; padding: 0; }\n    li { background-color: #f0f0f0; padding: 10px; margin-bottom: 5px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; }\n    li.purchased { text-decoration: line-through; background-color: #d4edda; color: #505050; }\n    li button { background-color: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; }\n    #addItemContainer { margin-bottom: 20px; }\n    #addItemInput { padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-right: 10px; }\n    #addItemButton { background-color: #007bff; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; }\n  </style>\n</head>\n<body>\n  <h1>My Shopping List</h1>\n\n  <div id=\"addItemContainer\">\n    <input type=\"text\" id=\"addItemInput\" placeholder=\"Add a new item\">\n    <button id=\"addItemButton\">Add Item</button>\n  </div>\n\n  <ul id=\"shoppingList\">\n    <!-- Dynamic items will go here -->\n  </ul>\n\n  <script>\n    const addItemInput = document.getElementById('addItemInput');\n    const addItemButton = document.getElementById('addItemButton');\n    const shoppingList = document.getElementById('shoppingList');\n\n    // Function to add new list item\n    addItemButton.addEventListener('click', function() {\n      const itemText = addItemInput.value.trim();\n      if (itemText === '') return;\n\n      const listItem = document.createElement('li');\n      listItem.innerHTML = `\n        <span>${itemText}</span>\n        <button class=\"remove-btn\">Remove</button>\n      `;\n      shoppingList.appendChild(listItem);\n      addItemInput.value = ''; // Clear input\n    });\n\n    // Event Delegation for mark as purchased and remove item\n    shoppingList.addEventListener('click', function(e) {\n      // Check if a remove button was clicked\n      if (e.target.classList.contains('remove-btn')) {\n        e.target.closest('li').remove(); // Remove the parent <li>\n      } \n      // Check if an <li> was clicked (but not on the remove button itself)\n      else if (e.target.tagName === 'LI' || e.target.closest('li')) {\n        // Use closest('li') to ensure we get the LI element even if a child span was clicked\n        const listItem = e.target.closest('li');\n        if (listItem) {\n            listItem.classList.toggle('purchased');\n        }\n      }\n    });\n  </script>\n</body>\n</html>",
          "testCases": [
            "Add a new item: Enter text and click 'Add Item'. Verify a new `<li>` appears.",
            "Click on a newly added item's text: Verify it gets the 'purchased' (strikethrough) style. Click again to remove the style.",
            "Click the 'Remove' button on a newly added item: Verify the item is removed from the list.",
            "Add multiple items, mark some, remove others: Ensure all functionalities work correctly for all items, demonstrating delegation.",
            "Verify no direct listeners are attached to `<li>` or `.remove-btn` elements."
          ],
          "hints": [
            "Attach only ONE event listener to the `<ul>` element.",
            "Use `event.target` inside the delegated listener to determine *what* exactly was clicked (the `<li>` text, or the 'Remove' button).",
            "You'll need `e.target.tagName` or `e.target.classList.contains()` to differentiate between a click on the `<li>` itself (for toggling 'purchased') and a click on the 'Remove' button.",
            "For removing an item, `e.target.closest('li')` can be useful to get the parent `<li>` element of the clicked 'Remove' button."
          ],
          "tags": [
            "DOM",
            "Events",
            "Event Delegation",
            "Dynamic Content",
            "JavaScript",
            "Front-end Development"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "event_delegation",
            "dom_manipulation"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "single_page_application",
            "component_architecture"
          ]
        },
        {
          "id": "task_fetch_and_display_data",
          "title": "Asynchronous Data Fetching and Display",
          "description": "\nImplement a web page that fetches a list of users from a public API and displays them dynamically. Use `async/await` for the API call.\n\n**Requirements:**\n1.  Create an HTML structure with a button to 'Load Users' and an empty `<ul>` to display the users.\n2.  When the 'Load Users' button is clicked, make an asynchronous request to `https://jsonplaceholder.typicode.com/users`.\n3.  Use an `async` function and `await` for the `fetch` call.\n4.  Parse the JSON response.\n5.  For each user received, create a new `<li>` element containing the user's `name` and `email`, and append it to the `<ul>`.\n6.  Implement basic error handling: If the fetch fails (e.g., network error, invalid URL), log the error to the console and display an error message on the page instead of the user list.\n7.  Show a 'Loading...' message while the data is being fetched and remove it once data is displayed or an error occurs.\n",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Fetch Users</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    #userList { list-style: none; padding: 0; }\n    #userList li { background-color: #f4f4f4; margin-bottom: 5px; padding: 10px; border-radius: 4px; }\n    .message { font-style: italic; color: gray; }\n    .error { color: red; font-weight: bold; }\n  </style>\n</head>\n<body>\n  <h1>User List</h1>\n  <button id=\"loadUsersBtn\">Load Users</button>\n  <p id=\"statusMessage\" class=\"message\"></p>\n  <ul id=\"userList\"></ul>\n\n  <script>\n    const loadUsersBtn = document.getElementById('loadUsersBtn');\n    const userList = document.getElementById('userList');\n    const statusMessage = document.getElementById('statusMessage');\n\n    // TODO: Implement the async function to fetch and display users\n\n    loadUsersBtn.addEventListener('click', () => {\n      // TODO: Call the async function and handle initial state/loading\n    });\n  </script>\n</body>\n</html>",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Fetch Users</title>\n  <style>\n    body { font-family: sans-serif; margin: 20px; }\n    #userList { list-style: none; padding: 0; }\n    #userList li { background-color: #f4f4f4; margin-bottom: 5px; padding: 10px; border-radius: 4px; }\n    .message { font-style: italic; color: gray; }\n    .error { color: red; font-weight: bold; }\n  </style>\n</head>\n<body>\n  <h1>User List</h1>\n  <button id=\"loadUsersBtn\">Load Users</button>\n  <p id=\"statusMessage\" class=\"message\"></p>\n  <ul id=\"userList\"></ul>\n\n  <script>\n    const loadUsersBtn = document.getElementById('loadUsersBtn');\n    const userList = document.getElementById('userList');\n    const statusMessage = document.getElementById('statusMessage');\n\n    async function fetchAndDisplayUsers() {\n      userList.innerHTML = ''; // Clear previous list\n      statusMessage.textContent = 'Loading users...';\n      statusMessage.className = 'message';\n\n      try {\n        const response = await fetch('https://jsonplaceholder.typicode.com/users');\n        \n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        const users = await response.json();\n\n        if (users.length === 0) {\n          statusMessage.textContent = 'No users found.';\n          statusMessage.className = 'message';\n          return;\n        }\n\n        users.forEach(user => {\n          const listItem = document.createElement('li');\n          listItem.textContent = `${user.name} (${user.email})`;\n          userList.appendChild(listItem);\n        });\n\n        statusMessage.textContent = ''; // Clear loading message\n      } catch (error) {\n        console.error('Failed to fetch users:', error);\n        statusMessage.textContent = `Error: ${error.message}. Could not load users.`;\n        statusMessage.className = 'error';\n      }\n    }\n\n    loadUsersBtn.addEventListener('click', fetchAndDisplayUsers);\n\n    // Optional: Load users automatically on page load\n    // document.addEventListener('DOMContentLoaded', fetchAndDisplayUsers);\n  </script>\n</body>\n</html>",
          "testCases": [
            "Click 'Load Users' button: Verify 'Loading...' message appears, then disappears, and a list of users (e.g., Leanne Graham, Ervin Howell) is displayed.",
            "Simulate network error (e.g., change URL to `invalid-url`): Verify an error message is displayed on the page and logged to the console.",
            "Handle empty response (e.g., modify API to return `[]`): Verify 'No users found.' message is displayed.",
            "Multiple clicks: Ensure list is cleared and repopulated correctly on successive clicks."
          ],
          "hints": [
            "Remember to use `response.json()` to parse the response body into a JavaScript object.",
            "Check `response.ok` (or `response.status`) to handle HTTP errors explicitly, as `fetch` itself doesn't reject on HTTP error codes (like 404 or 500) by default.",
            "Clear previous content of `userList` before appending new items on subsequent loads.",
            "Manage the `statusMessage` text and class to provide visual feedback for loading and errors."
          ],
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Fetch API",
            "DOM Manipulation",
            "Error Handling"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "async_await_basics",
            "fetch_api"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "promises",
            "error_handling"
          ]
        },
        {
          "id": "task_robust_api_client",
          "title": "Building a Robust API Client with Timeout and Retry Logic",
          "description": "\nDevelop a robust `fetchWithRetryAndTimeout` function that can make HTTP GET requests. This function should include both a timeout mechanism and a retry strategy for transient network failures.\n\n**Requirements:**\n1.  **`fetchWithRetryAndTimeout(url, options)` function**: \n    *   Takes `url` and an `options` object. The `options` object can include `timeout` (in ms, default 5000) and `retries` (number of retries, default 3) properties.\n    *   Uses `async/await` and `AbortController` for the timeout.\n    *   If the request fails due to a network error (`TypeError` or `AbortError`), it should retry the request up to the specified `retries` count.\n    *   Include a small delay (e.g., 500ms) between retries to avoid overwhelming the server.\n    *   If all retries are exhausted or the error is not a network error (e.g., HTTP 4xx/5xx status), it should throw the final error.\n2.  **Usage Example**: Demonstrate its usage by fetching data from a hypothetical API endpoint that sometimes fails or is slow.\n    *   Make a call to `https://jsonplaceholder.typicode.com/todos/1?_delay=X` where `X` is a random delay to simulate slow/timeout cases.\n    *   Make a call to a non-existent URL or one that returns a 500 error to test retry logic.\n    *   Log success or failure messages clearly.\n",
          "difficulty": "hard",
          "startingCode": "```typescript\ninterface FetchOptions extends RequestInit {\n  timeout?: number;\n  retries?: number;\n}\n\nasync function fetchWithRetryAndTimeout(url: string, options: FetchOptions = {}): Promise<any> {\n  const { timeout = 5000, retries = 3, ...fetchInit } = options;\n\n  // TODO: Implement the fetch with timeout and retry logic\n\n  // Hint: You'll need AbortController for timeout.\n  // Hint: Use a loop for retries and try/catch inside.\n  // Hint: Add a delay between retries using new Promise(resolve => setTimeout(resolve, delay));\n\n  throw new Error('Not implemented yet');\n}\n\n// Example Usage (Test Cases)\n(async () => {\n  console.log('--- Test Case 1: Successful Fetch ---');\n  try {\n    const data = await fetchWithRetryAndTimeout('https://jsonplaceholder.typicode.com/posts/1', { timeout: 10000 });\n    console.log('Success:', data.title.substring(0, 30) + '...');\n  } catch (err) {\n    console.error('Failure:', err.message);\n  }\n\n  console.log('\\n--- Test Case 2: Simulating Timeout and Retry ---');\n  // This URL can be manipulated to introduce delay (e.g., ?_delay=6000)\n  // You might need a local mock server to reliably simulate random failures/delays\n  // For testing, let's assume this might timeout given a low timeout value.\n  try {\n    // This endpoint has variable delay, simulate it sometimes timing out\n    const data = await fetchWithRetryAndTimeout('https://jsonplaceholder.typicode.com/posts/1?_delay=6000', { timeout: 2000, retries: 2 });\n    console.log('Success (after retry/timeout test):', data.title.substring(0, 30) + '...');\n  } catch (err) {\n    console.error('Failure (after retry/timeout test):', err.message);\n  }\n\n  console.log('\\n--- Test Case 3: Simulating HTTP Error (No Retry) ---');\n  try {\n    // This URL will return 404, should not retry\n    const data = await fetchWithRetryAndTimeout('https://jsonplaceholder.typicode.com/non-existent-path', { retries: 3 });\n    console.log('Success (should not happen):', data);\n  } catch (err) {\n    console.error('Failure (HTTP error, no retry):', err.message);\n  }\n})();\n\n```",
          "solutionCode": "```typescript\ninterface FetchOptions extends RequestInit {\n  timeout?: number;\n  retries?: number;\n  retryDelay?: number;\n}\n\nasync function fetchWithRetryAndTimeout(url: string, options: FetchOptions = {}): Promise<any> {\n  const { timeout = 5000, retries = 3, retryDelay = 500, ...fetchInit } = options;\n\n  for (let i = 0; i <= retries; i++) {\n    const controller = new AbortController();\n    const { signal } = controller;\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n      const response = await fetch(url, { signal, ...fetchInit });\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        // HTTP errors (4xx, 5xx) are not retried by default, throw immediately\n        const errorBody = await response.text();\n        throw new Error(`HTTP error! Status: ${response.status}. Body: ${errorBody.substring(0, 100)}`);\n      }\n\n      return await response.json();\n    } catch (error: any) {\n      clearTimeout(timeoutId); // Clear timeout even if fetch fails for other reasons\n\n      const isNetworkError = error.name === 'TypeError' || error.name === 'AbortError';\n      \n      if (isNetworkError && i < retries) {\n        console.warn(`Attempt ${i + 1}/${retries + 1} failed for ${url}: ${error.message}. Retrying in ${retryDelay}ms...`);\n        await new Promise(resolve => setTimeout(resolve, retryDelay));\n        continue; // Go to next retry attempt\n      } else {\n        // If not a network error, or max retries reached, re-throw\n        console.error(`Final attempt failed for ${url}: ${error.message}`);\n        throw error;\n      }\n    }\n  }\n}\n\n// Example Usage (Test Cases)\n(async () => {\n  console.log('--- Test Case 1: Successful Fetch ---');\n  try {\n    const data = await fetchWithRetryAndTimeout('https://jsonplaceholder.typicode.com/posts/1', { timeout: 10000 });\n    console.log('Success:', data.title.substring(0, 30) + '...');\n  } catch (err: any) {\n    console.error('Failure:', err.message);\n  }\n\n  console.log('\\n--- Test Case 2: Simulating Timeout and Retry ---');\n  // To reliably test timeout, you'd need a server that can introduce delays.\n  // `jsonplaceholder.typicode.com` often has _delay param, but it's not always reliable in all environments.\n  // This example simulates a timeout by making the API call take longer than the local timeout.\n  try {\n    const data = await fetchWithRetryAndTimeout('https://jsonplaceholder.typicode.com/posts/1?_delay=6000', { timeout: 2000, retries: 2 });\n    console.log('Success (after retry/timeout test):', data.title.substring(0, 30) + '...');\n  } catch (err: any) {\n    console.error('Failure (after retry/timeout test):', err.message);\n  }\n\n  console.log('\\n--- Test Case 3: Simulating Network Error and Retry ---');\n  // Temporarily change to a non-existent domain to simulate DNS/network error for retries\n  try {\n    const data = await fetchWithRetryAndTimeout('http://nonexistent-domain-for-test.com/data', { retries: 3 });\n    console.log('Success (should not happen):', data);\n  } catch (err: any) {\n    console.error('Failure (Network error, retried):', err.message);\n  }\n\n  console.log('\\n--- Test Case 4: Simulating HTTP Error (No Retry) ---');\n  try {\n    const data = await fetchWithRetryAndTimeout('https://jsonplaceholder.typicode.com/non-existent-path-404', { retries: 3 });\n    console.log('Success (should not happen):', data);\n  } catch (err: any) {\n    console.error('Failure (HTTP 404 error, no retry):', err.message);\n  }\n})();\n```",
          "testCases": [
            "Successful fetch: Call with a valid URL and sufficient timeout. Verify data is returned.",
            "Timeout (no retry succeeds): Call with a URL that will delay longer than `timeout`, but with `retries: 0`. Verify an `AbortError` is thrown.",
            "Timeout (retry succeeds): Call with a URL that delays, but is eventually shorter than `timeout * (retries + 1)`. Verify it retries and then succeeds.",
            "Network Error (retry fails): Use an invalid URL (e.g., `http://localhost:9999/` if nothing is running there) and `retries > 0`. Verify it retries `retries` times and then throws the final network error.",
            "HTTP Error (e.g., 404 or 500): Call with a valid URL that returns an HTTP error code. Verify it throws the HTTP error immediately without retries.",
            "Edge case: `retries: 0` should mean no retries are attempted."
          ],
          "hints": [
            "Wrap the `fetch` call in a `for` loop to manage retries.",
            "Inside the loop, each iteration needs its own `AbortController` and `setTimeout` for the timeout.",
            "Distinguish between network errors (e.g., `TypeError`, `AbortError`) that warrant a retry, and HTTP errors (like 404, 500) that usually indicate a server-side problem and typically don't benefit from retries.",
            "A `Promise` with `setTimeout` is a simple way to create a delay between retries: `await new Promise(resolve => setTimeout(resolve, delay));`.",
            "Ensure `clearTimeout` is called in both success and catch blocks to prevent memory leaks."
          ],
          "tags": [
            "JavaScript",
            "Asynchronous Programming",
            "Fetch API",
            "Error Handling",
            "Retries",
            "Timeouts",
            "AbortController",
            "Advanced Concepts"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "async_await_basics",
            "async_await_error_handling_timeout",
            "promises"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "expert",
          "relatedConcepts": [
            "network_requests",
            "api_design_patterns",
            "resilience"
          ]
        }
      ]
    }
  },
  {
    "id": "35a33fd1-3f87-4ae5-a5ec-f1ef7f0bc4fd",
    "startLine": 1900,
    "endLine": 1999,
    "processedDate": "2025-06-17T08:05:25.469Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_async_timeout_abortcontroller",
          "title": "Asynchronous Operations with Timeout and AbortController",
          "content": "Asynchronous operations like fetching data from an API are fundamental in frontend development. However, these operations can sometimes hang indefinitely or take too long, leading to a poor user experience. Implementing timeouts is crucial to prevent such scenarios and provide responsive feedback.\n\n## Key Concepts\n\n### `AbortController`\nThe `AbortController` interface provides a way to abort one or more Web requests as and when desired. It's a modern and recommended way to cancel `fetch` requests or any other asynchronous operation that accepts an `AbortSignal`.\n\n-   **`AbortController` instance:** `const controller = new AbortController();`\n-   **`signal` property:** `controller.signal` returns an `AbortSignal` object. This signal can be passed to an asynchronous operation (e.g., `fetch(url, { signal: controller.signal })`).\n-   **`abort()` method:** `controller.abort()` aborts the associated signal. When the signal is aborted, any operations listening to it (like an ongoing `fetch` request) will be cancelled, and a `DOMException` with `name` 'AbortError' will be thrown.\n\n### Timeout Mechanism\nCombining `setTimeout` with `AbortController` allows for implementing a timeout for network requests:\n\n1.  Start a timer using `setTimeout`.\n2.  If the timer expires before the `fetch` request completes, call `controller.abort()` to cancel the request.\n3.  If the `fetch` request completes successfully before the timer expires, clear the timer using `clearTimeout` to prevent the `abort()` call from executing.\n\n### Error Handling\nProper error handling is vital for robust asynchronous code:\n\n-   **`try...catch` block:** Catches errors thrown by the `await` expression, including network errors, JSON parsing errors, or `AbortError`.\n-   **`AbortError`:** Specifically checks for `error.name === 'AbortError'` to differentiate a user-initiated or timeout-based cancellation from other network errors.\n-   **HTTP Status Codes:** After a successful `fetch` call (meaning the network request completed, even if the server responded with an error status like 404 or 500), check `response.ok`. If `response.ok` is `false`, it indicates an HTTP error (status outside 200-299 range), and you should throw a custom error.\n\n## Best Practices\n- Always clear the timeout (`clearTimeout`) on successful completion to avoid memory leaks and unintended `abort()` calls.\n- Provide clear error messages to the user for timeouts or other network failures.\n- Consider retries for transient errors, but not for timeouts or permanent errors.",
          "examples": [
            {
              "id": "example_timeout_abort_1",
              "title": "Implementing fetch with Timeout",
              "code": "async function fetchWithTimeout(url, timeout = 5000) {\n  const controller = new AbortController();\n  // Set up a timeout to abort the request\n  const id = setTimeout(() => controller.abort(), timeout);\n  \n  try {\n    // Initiate fetch with the signal\n    const response = await fetch(url, { signal: controller.signal });\n    // Clear the timeout if fetch completes successfully\n    clearTimeout(id);\n    \n    // Check for HTTP errors (e.g., 404, 500)\n    if (!response.ok) {\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    // Always clear timeout in catch block too to prevent hanging timers\n    clearTimeout(id);\n    \n    // Distinguish timeout errors from other errors\n    if (error.name === 'AbortError') {\n      throw new Error(`Request timed out after ${timeout}ms`);\n    }\n    // Re-throw other errors\n    throw error;\n  }\n}\n\n// Example usage:\n// (async () => {\n//   try {\n//     const data = await fetchWithTimeout('https://jsonplaceholder.typicode.com/todos/1', 2000);\n//     console.log('Fetched data:', data);\n//   } catch (e) {\n//     console.error('Fetch error:', e.message);\n//   }\n// })();",
              "explanation": "This example demonstrates how to implement a timeout for a `fetch` request using `AbortController` and `setTimeout`. It shows how to create an `AbortController`, link its `signal` to the `fetch` request, and use `setTimeout` to trigger the `abort()` method if the request takes too long. Crucially, `clearTimeout` is used in both the `try` and `catch` blocks to ensure the timeout is always cleared once the `fetch` promise settles, preventing resource leaks. Error handling differentiates between `AbortError` (timeout) and other potential fetch errors.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "async",
            "fetch",
            "AbortController",
            "timeout",
            "error-handling",
            "web-apis"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "promises",
            "async-await",
            "event-loop-basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "robust-api-clients",
            "real-time-applications"
          ]
        },
        {
          "id": "theory_async_retry_pattern",
          "title": "Asynchronous Operations with Retry Pattern",
          "content": "In distributed systems and web applications, transient network issues, server overloads, or temporary service unavailability can cause API requests to fail. A retry pattern is a common strategy to make asynchronous operations more resilient by automatically re-attempting a failed request a certain number of times before giving up.\n\n## Key Concepts\n\n### Retry Logic\nThe core of a retry pattern involves re-executing the failed operation. This can be implemented using:\n\n-   **Recursion:** A function calls itself upon failure, decrementing a retry counter.\n-   **Looping:** A `while` or `for` loop attempts the operation repeatedly until success or retries are exhausted.\n\n### Delay Between Retries\nInstead of immediately retrying, introducing a delay is crucial:\n\n-   **Prevents overloading the server:** Gives the server time to recover.\n-   **Avoids busy-waiting:** Doesn't block the event loop unnecessarily.\n-   **`setTimeout` with `Promise`:** A common way to create a delay in `async/await` contexts is `await new Promise(resolve => setTimeout(resolve, delay));`.\n\n### Exponential Backoff\nThis is a strategy where the delay between retries increases exponentially (e.g., 1s, 2s, 4s, 8s...). This is generally preferred over fixed delays:\n\n-   **Reduces server load:** When a server is struggling, repeated rapid retries can exacerbate the problem.\n-   **Increases success probability:** Gives more time for the underlying issue to resolve.\n-   **Formula:** `delay * multiplier` (e.g., `delay * 2`).\n\n### Maximum Retries\nA finite number of retries must be set to prevent infinite loops and ensure the application eventually fails fast if the issue is persistent.\n\n### Error Handling\n-   Only retry for *transient* errors (e.g., network issues, 5xx server errors). Do not retry for *permanent* errors (e.g., 4xx client errors like 404 Not Found, 401 Unauthorized, or validation errors).\n-   If all retries fail, the original error should be re-thrown so the calling code can handle the ultimate failure.\n\n## Considerations\n-   **Idempotency:** Retrying operations that are not idempotent (i.e., multiple executions have different effects than one execution) can lead to unintended side effects (e.g., creating duplicate records). Only retry idempotent operations or design your retry mechanism to handle non-idempotent operations carefully.\n-   **Jitter:** Adding a small random variation to the backoff delay can help prevent multiple clients from retrying simultaneously, causing a 'thundering herd' problem.",
          "examples": [
            {
              "id": "example_retry_1",
              "title": "Recursive Fetch with Retry and Exponential Backoff",
              "code": "async function fetchWithRetry(url, options = {}, retries = 3, delay = 1000) {\n  try {\n    // Attempt the fetch operation\n    const response = await fetch(url, options);\n    \n    // If response is not OK, consider it a failure for retry purposes\n    // (This example retries on any fetch error, but in practice, you'd check response.ok or specific status codes)\n    if (!response.ok && response.status >= 500) { // Example: Only retry 5xx errors\n       throw new Error(`Server error: ${response.status}`);\n    }\n    \n    return response;\n  } catch (error) {\n    // Check if retries are exhausted\n    if (retries <= 1) {\n      console.error(`Fetch failed after ${retries} attempt(s).`);\n      throw error; // Re-throw the original error\n    }\n    \n    console.warn(`Fetch failed, retrying in ${delay}ms... (Attempts left: ${retries - 1})`);\n    \n    // Wait before retrying using a Promise-based delay\n    await new Promise(resolve => setTimeout(resolve, delay));\n    \n    // Recursively call itself with decremented retries and increased delay\n    return fetchWithRetry(url, options, retries - 1, delay * 2); // Exponential backoff\n  }\n}\n\n// Example usage:\n// (async () => {\n//   try {\n//     // This URL might fail initially for demonstration if configured to do so\n//     const data = await fetchWithRetry('https://httpstat.us/503', {}, 5, 500);\n//     // Or a successful one:\n//     // const data = await fetchWithRetry('https://jsonplaceholder.typicode.com/todos/1');\n//     console.log('Fetched data successfully after retries:', await data.json());\n//   } catch (e) {\n//     console.error('Final fetch error:', e.message);\n//   }\n// })();",
              "explanation": "This example implements a `fetchWithRetry` function using a recursive approach and exponential backoff. It attempts the `fetch` operation. If it fails (either a network error or a 5xx HTTP status code in this refined example), it checks if there are retries left. If so, it waits for a `delay` period (which doubles with each attempt) and then calls itself again. If retries are exhausted, the original error is re-thrown. This pattern makes network requests more resilient to transient failures.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "async",
            "retry",
            "fetch",
            "error-handling",
            "resilience",
            "exponential-backoff",
            "recursion"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "promises",
            "async-await",
            "error-handling-basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "robust-api-clients",
            "microservices-communication"
          ]
        },
        {
          "id": "theory_event_loop_micro_macro",
          "title": "JavaScript Event Loop: Microtasks vs Macrotasks",
          "content": "Understanding the JavaScript Event Loop is crucial for writing non-blocking and efficient asynchronous code. It dictates the order in which different types of asynchronous operations are executed.\n\n## Key Concepts\n\n### The Event Loop\nJavaScript is single-threaded, meaning it can only execute one task at a time. The Event Loop enables non-blocking asynchronous operations by offloading tasks to the browser's Web APIs (or Node.js's C++ APIs) and then queuing their callbacks to be executed once the main call stack is empty.\n\n### Macrotasks (Tasks)\nMacrotasks (also known as tasks) represent discrete, larger units of work. The browser processes one macrotask at a time from the macrotask queue. After a macrotask completes, the browser renders, and then it processes the *entire* microtask queue before picking up the next macrotask.\n\n**Examples of Macrotasks:**\n-   `setTimeout()`\n-   `setInterval()`\n-   `setImmediate()` (Node.js specific)\n-   `requestAnimationFrame()` (browser specific, often considered a distinct phase after rendering)\n-   I/O operations (e.g., network requests, file reading)\n-   UI rendering (browser specific)\n-   User interactions (e.g., `click`, `keydown` events)\n\n### Microtasks\nMicrotasks are smaller, higher-priority tasks that are executed *after* the currently executing script finishes, but *before* the next macrotask is picked from the macrotask queue. The microtask queue is processed completely before the event loop proceeds to the next macrotask.\n\n**Examples of Microtasks:**\n-   `Promise.then()`, `Promise.catch()`, `Promise.finally()` callbacks\n-   `queueMicrotask()`\n-   `process.nextTick()` (Node.js specific, runs before all other microtasks)\n-   `MutationObserver` callbacks\n\n### Execution Order\nThe general order of execution within a single pass of the Event Loop:\n\n1.  **Synchronous Code:** The main script runs to completion.\n2.  **Microtask Queue:** All microtasks generated during the synchronous execution (or previous macrotask execution) are executed until the microtask queue is empty.\n3.  **Render (Browser only):** The browser may choose to render UI updates.\n4.  **Macrotask Queue:** The event loop picks *one* macrotask from its queue and executes it.\n5.  **Repeat:** After that macrotask completes, the process returns to step 2 (execute all microtasks), then step 3 (render), then step 4 (next macrotask), and so on.\n\nThis cycle ensures that promises and other high-priority asynchronous operations resolve quickly and consistently before the browser moves on to potentially slower tasks like UI rendering or I/O.",
          "examples": [
            {
              "id": "example_event_loop_1",
              "title": "Microtasks vs Macrotasks Execution Order",
              "code": "// Macrotasks: setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering\n// Microtasks: Promises, process.nextTick, queueMicrotask, MutationObserver\n\nconsole.log('Script start');\n\nsetTimeout(() => {\n  console.log('Timeout 1'); // Macrotask\n}, 0);\n\nqueueMicrotask(() => {\n  console.log('Microtask 1');\n  \n  queueMicrotask(() => {\n    console.log('Nested microtask');\n  });\n});\n\nPromise.resolve().then(() => {\n  console.log('Promise 1'); // Microtask\n  \n  setTimeout(() => {\n    console.log('Timeout in promise'); // Macrotask\n  }, 0);\n});\n\nsetTimeout(() => {\n  console.log('Timeout 2'); // Macrotask\n}, 0);\n\nconsole.log('Script end');\n\n/*\nExpected Output Explanation:\n1. 'Script start' (Synchronous code)\n2. 'Script end' (Synchronous code completes)\n\n--- End of current script execution. Now process Microtasks. ---\n\n3. 'Microtask 1' (queueMicrotask callback)\n4. 'Promise 1' (Promise.resolve().then() callback)\n   - During 'Promise 1' execution, a new setTimeout ('Timeout in promise') is scheduled, adding to Macrotask queue.\n5. 'Nested microtask' (queueMicrotask callback scheduled from 'Microtask 1')\n\n--- Microtask queue is now empty. Now process next Macrotask. ---\n\n6. 'Timeout 1' (First setTimeout callback)\n\n--- 'Timeout 1' macrotask completes. Microtask queue is empty. Now process next Macrotask. ---\n\n7. 'Timeout 2' (Second setTimeout callback)\n\n--- 'Timeout 2' macrotask completes. Microtask queue is empty. Now process next Macrotask. ---\n\n8. 'Timeout in promise' (setTimeout callback scheduled from 'Promise 1')\n\nFinal Output:\nScript start\nScript end\nMicrotask 1\nPromise 1\nNested microtask\nTimeout 1\nTimeout 2\nTimeout in promise\n*/",
              "explanation": "This example vividly illustrates the priority and execution order of synchronous code, microtasks, and macrotasks. First, all synchronous `console.log` statements run. Then, the microtask queue is fully drained: `queueMicrotask` and `Promise.then` callbacks execute. Any new microtasks created within these (like 'Nested microtask') are also processed in the same microtask phase. Only after the microtask queue is completely empty does the event loop proceed to pick and execute one macrotask from its queue. This process repeats: one macrotask, then all microtasks, then the next macrotask.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "event-loop",
            "asynchronicity",
            "microtasks",
            "macrotasks",
            "promises",
            "setTimeout",
            "JavaScript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "callbacks",
            "asynchronous-javascript",
            "scope-closure"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "requiredFor": [
            "performance-optimization",
            "complex-async-flows",
            "debugging-async-issues"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_async_timeout_abortcontroller_1",
          "topic": "Asynchronous Operations with Timeout and AbortController",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of `AbortController` in the context of `fetch` API requests?",
          "answer": "To cancel ongoing `fetch` requests.",
          "options": [
            "To handle HTTP status codes (e.g., 404, 500).",
            "To automatically retry failed requests.",
            "To convert response data to JSON format.",
            "To cancel ongoing `fetch` requests."
          ],
          "analysisPoints": [
            "`AbortController` is specifically designed for cancellation of asynchronous tasks, notably `fetch` requests.",
            "HTTP status codes are handled by checking `response.ok` or `response.status` after the `fetch` completes.",
            "Retry logic is a separate pattern, often built on top of `fetch`.",
            "JSON conversion is done via `response.json()`."
          ],
          "keyConcepts": [
            "AbortController",
            "fetch",
            "cancellation"
          ],
          "evaluationCriteria": [
            "Understanding of `AbortController`'s core functionality.",
            "Ability to distinguish its purpose from other `fetch`-related concerns."
          ],
          "example": "```typescript\nconst controller = new AbortController();\nconst signal = controller.signal;\n\n// To cancel a fetch request:\n// fetch(url, { signal });\n// controller.abort();\n```",
          "tags": [
            "AbortController",
            "fetch",
            "basic",
            "API",
            "web-apis"
          ],
          "prerequisites": [
            "fetch-api"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_timeout_abortcontroller_2",
          "topic": "Asynchronous Operations with Timeout and AbortController",
          "level": "medium",
          "type": "code",
          "question": "Modify the `fetchWithTimeout` function to include a `finally` block that *always* clears the timeout, even if an error is caught before `clearTimeout(id)` in the `try` block. Assume `id` is the `setTimeout` ID.",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "The `finally` block in `try...catch...finally` always executes regardless of whether an exception was thrown or caught.",
            "Placing `clearTimeout(id)` in `finally` guarantees resource cleanup for the timer.",
            "This is a best practice to prevent memory leaks from uncleaned timers."
          ],
          "keyConcepts": [
            "try-catch-finally",
            "setTimeout",
            "clearTimeout",
            "resource-management"
          ],
          "evaluationCriteria": [
            "Correct use of `finally` block.",
            "Understanding of guaranteed execution in `finally`.",
            "Awareness of best practices for timer cleanup."
          ],
          "example": "```typescript\nasync function fetchWithTimeoutImproved(url, timeout = 5000) {\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), timeout);\n  \n  try {\n    const response = await fetch(url, { signal: controller.signal });\n    // Removed clearTimeout from here\n    if (!response.ok) {\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    }\n    return response.json();\n  } catch (error) {\n    // Removed clearTimeout from here\n    if (error.name === 'AbortError') {\n      throw new Error(`Request timed out after ${timeout}ms`);\n    }\n    throw error;\n  } finally {\n    clearTimeout(id); // Ensures timeout is always cleared\n  }\n}\n```",
          "tags": [
            "AbortController",
            "fetch",
            "error-handling",
            "code-refactoring",
            "best-practices"
          ],
          "prerequisites": [
            "async-await",
            "try-catch"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_timeout_abortcontroller_3",
          "topic": "Asynchronous Operations with Timeout and AbortController",
          "level": "hard",
          "type": "open",
          "question": "Explain the difference between a `fetch` request failing due to a network error (e.g., no internet connection) and failing due to an `AbortError` caused by a timeout. How would you differentiate and handle these in your `fetchWithTimeout` implementation?",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Network errors (e.g., DNS resolution failure, no internet) typically result in a `TypeError` for `fetch` promises, or a generic `Error` object depending on the environment/browser.",
            "`AbortError` is a specific `DOMException` with `error.name === 'AbortError'` that occurs when `controller.abort()` is called and the `fetch` request's `signal` is aborted.",
            "Differentiation: Inside the `catch` block, check `if (error.name === 'AbortError')` to identify a timeout. Any other error typically indicates a network issue or other problem during the `fetch` operation.",
            "Handling: For `AbortError`, you'd inform the user about a timeout. For other errors, you might inform them about a general network problem or server issue."
          ],
          "keyConcepts": [
            "fetch-errors",
            "AbortError",
            "error-handling",
            "network-issues",
            "DOMException"
          ],
          "evaluationCriteria": [
            "Detailed understanding of `fetch` error types.",
            "Ability to distinguish between specific error scenarios.",
            "Practical application of error differentiation in code."
          ],
          "example": "```typescript\n// Inside a catch block:\n// try { ... } catch (error) {\n//   if (error.name === 'AbortError') {\n//     console.error('Request was aborted due to timeout.');\n//   } else if (error instanceof TypeError) { // Common for network errors\n//     console.error('Network error (e.g., no internet connection):', error.message);\n//   } else {\n//     console.error('Other fetch error:', error.message);\n//   }\n//   throw error;\n// }\n```",
          "tags": [
            "AbortController",
            "fetch",
            "error-handling",
            "conceptual",
            "interview"
          ],
          "prerequisites": [
            "async-error-handling",
            "javascript-error-types"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_async_timeout_abortcontroller_4",
          "topic": "Asynchronous Operations with Timeout and AbortController",
          "level": "easy",
          "type": "flashcard",
          "question": "What happens when `controller.abort()` is called on an `AbortController` linked to an ongoing `fetch` request?",
          "answer": "The `fetch` request is cancelled, and its promise rejects with an `AbortError`.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "AbortController",
            "cancellation",
            "fetch",
            "AbortError"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "AbortController",
            "fetch",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_retry_pattern_1",
          "topic": "Asynchronous Operations with Retry Pattern",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `fetchWithRetry` function. What is the purpose of `await new Promise(resolve => setTimeout(resolve, delay));`?",
          "answer": "To pause execution for a specified `delay` before the next retry attempt.",
          "options": [
            "To immediately re-execute the `fetch` request.",
            "To transform the `fetch` response into a Promise.",
            "To ensure the `fetch` request completes within the `delay`.",
            "To pause execution for a specified `delay` before the next retry attempt."
          ],
          "analysisPoints": [
            "The `await` keyword pauses the `async` function's execution.",
            "The `new Promise` combined with `setTimeout` creates a Promise that resolves after the `delay`.",
            "When this Promise resolves, the `await` expression completes, and the function resumes, allowing the next retry attempt.",
            "This is a standard pattern for introducing delays in `async/await` flows."
          ],
          "keyConcepts": [
            "async-await",
            "promises",
            "setTimeout",
            "delay",
            "retry-pattern"
          ],
          "evaluationCriteria": [
            "Understanding of `await` and `setTimeout` with Promises for delaying execution.",
            "Correct interpretation of the code snippet's role in the retry pattern."
          ],
          "example": "```typescript\nasync function simulateDelay(ms) {\n  console.log(`Waiting for ${ms}ms...`);\n  await new Promise(resolve => setTimeout(resolve, ms));\n  console.log('Done waiting!');\n}\n\n// simulateDelay(1000); // This would pause execution for 1 second\n```",
          "tags": [
            "retry",
            "async",
            "promises",
            "setTimeout",
            "basic"
          ],
          "prerequisites": [
            "promises",
            "async-await"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_retry_pattern_2",
          "topic": "Asynchronous Operations with Retry Pattern",
          "level": "medium",
          "type": "open",
          "question": "The provided `fetchWithRetry` function uses `delay * 2` for subsequent retries. What is this technique called, and what is its main advantage in a retry mechanism?",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "The technique is called **Exponential Backoff**.",
            "Main advantage: It helps prevent overwhelming a struggling server or service by increasing the delay between retries. If many clients are retrying, exponential backoff spreads out the load, giving the server more time to recover, thus increasing the chance of successful future retries for all clients. It also prevents the 'thundering herd' problem."
          ],
          "keyConcepts": [
            "exponential-backoff",
            "retry-pattern",
            "resilience",
            "server-load",
            "thundering-herd"
          ],
          "evaluationCriteria": [
            "Knowledge of exponential backoff terminology.",
            "Understanding the benefits of exponential backoff for system stability and resilience.",
            "Ability to articulate the 'why' behind this design choice."
          ],
          "example": "```typescript\n// Initial delay = D\n// 1st retry delay = D * 2\n// 2nd retry delay = D * 2 * 2 = D * 4\n// 3rd retry delay = D * 4 * 2 = D * 8\n// ...and so on.\n```",
          "tags": [
            "retry",
            "exponential-backoff",
            "design-pattern",
            "interview"
          ],
          "prerequisites": [],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_retry_pattern_3",
          "topic": "Asynchronous Operations with Retry Pattern",
          "level": "hard",
          "type": "code",
          "question": "Modify the `fetchWithRetry` function to only retry if the `fetch` operation results in an HTTP status code 5xx (Server Error) or a network error. Client errors (4xx) should not trigger a retry.",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "The `catch` block handles network errors by default.",
            "Within the `try` block, after `await fetch(url, options)`, check `response.ok` or `response.status`.",
            "If `!response.ok` and `response.status` is in the 5xx range (`>= 500 && < 600`), then throw an error to trigger the retry logic.",
            "If `!response.ok` and `response.status` is in the 4xx range (`>= 400 && < 500`), immediately `throw new Error` without triggering a retry."
          ],
          "keyConcepts": [
            "retry-pattern",
            "error-handling",
            "HTTP-status-codes",
            "conditional-logic"
          ],
          "evaluationCriteria": [
            "Ability to implement nuanced error handling.",
            "Correctly applying HTTP status code logic.",
            "Understanding which errors are transient vs. permanent for retries."
          ],
          "example": "```typescript\nasync function fetchWithRetrySelective(url, options = {}, retries = 3, delay = 1000) {\n  try {\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      if (response.status >= 500 && response.status < 600) {\n        // Server error (5xx) - potentially transient, throw to retry\n        throw new Error(`Server error: ${response.status}`);\n      } else if (response.status >= 400 && response.status < 500) {\n        // Client error (4xx) - usually permanent, do NOT retry\n        // Instead, throw a specific error that isn't caught for retry\n        throw new Error(`Client error: ${response.status}`);\n      } else {\n        // Other non-ok responses (e.g., 3xx redirects without follow)\n        throw new Error(`Unexpected HTTP status: ${response.status}`);\n      }\n    }\n    return response;\n  } catch (error) {\n    // Only retry if it's a network error or a specific error we threw for retries\n    // Check if error message indicates 5xx or it's a generic network error\n    const shouldRetry = (error.message.includes('Server error') || error instanceof TypeError || (error.message && !error.message.includes('Client error')));\n    \n    if (retries <= 1 || !shouldRetry) {\n      throw error; \n    }\n    \n    await new Promise(resolve => setTimeout(resolve, delay));\n    return fetchWithRetrySelective(url, options, retries - 1, delay * 2);\n  }\n}\n```",
          "tags": [
            "retry",
            "error-handling",
            "HTTP",
            "advanced",
            "code-challenge"
          ],
          "prerequisites": [
            "async-await",
            "http-status-codes",
            "error-handling"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_async_retry_pattern_4",
          "topic": "Asynchronous Operations with Retry Pattern",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary concern when retrying an operation that is *not* idempotent?",
          "answer": "Retrying a non-idempotent operation can lead to unintended side effects, such as creating duplicate records or incorrect state changes.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "idempotency",
            "retry-pattern",
            "side-effects"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "retry",
            "idempotency",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_micro_macro_1",
          "topic": "JavaScript Event Loop: Microtasks vs Macrotasks",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following code, what will be the correct output order?\n\n```javascript\nconsole.log('A');\n\nsetTimeout(() => {\n  console.log('B');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('C');\n});\n\nconsole.log('D');\n```",
          "answer": "A, D, C, B",
          "options": [
            "A, B, C, D",
            "A, D, B, C",
            "A, C, D, B",
            "A, D, C, B"
          ],
          "analysisPoints": [
            "Synchronous code runs first: 'A', then 'D'.",
            "After synchronous code, the microtask queue is processed entirely. `Promise.resolve().then()` adds 'C' to the microtask queue.",
            "After microtasks, one macrotask is picked. `setTimeout()` adds 'B' to the macrotask queue. Since its delay is 0, it's ready, but it's a macrotask, so it runs after all microtasks."
          ],
          "keyConcepts": [
            "event-loop",
            "microtasks",
            "macrotasks",
            "promises",
            "setTimeout"
          ],
          "evaluationCriteria": [
            "Correctly identifies synchronous execution.",
            "Understands the priority of microtasks over macrotasks.",
            "Predicts the final output sequence accurately."
          ],
          "example": "```javascript\n// Output Explained:\n// 1. 'A' (sync)\n// 2. 'D' (sync)\n// (End of script, microtask queue gets priority)\n// 3. 'C' (microtask from Promise)\n// (Microtask queue empty, macrotask queue next)\n// 4. 'B' (macrotask from setTimeout)\n```",
          "tags": [
            "event-loop",
            "microtasks",
            "macrotasks",
            "prediction",
            "JavaScript"
          ],
          "prerequisites": [
            "callbacks",
            "promises"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_micro_macro_2",
          "topic": "JavaScript Event Loop: Microtasks vs Macrotasks",
          "level": "hard",
          "type": "mcq",
          "question": "Referencing the original example output:\n`Script start`\n`Script end`\n`Microtask 1`\n`Promise 1`\n`Nested microtask`\n`Timeout 1`\n`Timeout 2`\n`Timeout in promise`\n\nWhy does 'Nested microtask' execute before 'Timeout 1', even though 'Timeout 1' was scheduled earlier than the `setTimeout` inside 'Promise 1'?",
          "answer": "All microtasks from the current and previous phases are executed before the next macrotask is picked, and 'Nested microtask' is a microtask.",
          "options": [
            "'Timeout 1' has a minimum delay of 4ms, making it slower than microtasks.",
            "'Nested microtask' is a special type of `queueMicrotask` that has higher priority than `setTimeout`.",
            "All microtasks from the current and previous phases are executed before the next macrotask is picked, and 'Nested microtask' is a microtask.",
            "The browser optimizes `setTimeout` calls, reordering them based on their content."
          ],
          "analysisPoints": [
            "The core understanding here is the Event Loop's processing order: synchronous code completes, then *all* pending microtasks (including new ones queued during the current microtask phase) are processed. Only then does the event loop pick *one* macrotask.",
            "'Timeout 1' is a macrotask. 'Nested microtask' is a microtask, even if it's 'nested' or queued later than 'Timeout 1' in terms of code flow.",
            "The 0ms delay for `setTimeout` means it's queued immediately, but still as a macrotask.",
            "Microtasks have higher priority and are completely drained before any macrotasks are processed."
          ],
          "keyConcepts": [
            "event-loop",
            "microtasks-priority",
            "macrotasks-execution-order",
            "queueMicrotask",
            "setTimeout"
          ],
          "evaluationCriteria": [
            "Deep understanding of microtask/macrotask processing flow.",
            "Ability to explain nested asynchronous behavior.",
            "Accurate application of event loop rules to predict output."
          ],
          "example": "```javascript\n// Explanation Trace:\n// 1. Script start (sync)\n// 2. setTimeout(() => console.log('Timeout 1')) -> Macrotask Queue [T1]\n// 3. queueMicrotask(() => { console.log('Microtask 1'); queueMicrotask(() => console.log('Nested microtask')); }) -> Microtask Queue [M1]\n// 4. Promise.resolve().then(() => { console.log('Promise 1'); setTimeout(() => console.log('Timeout in promise')); }) -> Microtask Queue [M1, P1]\n// 5. setTimeout(() => console.log('Timeout 2')) -> Macrotask Queue [T1, T2]\n// 6. Script end (sync)\n\n// *Drain Microtask Queue:*\n// 7. M1 executes -> console.log('Microtask 1'); queueMicrotask(() => console.log('Nested microtask')) -> Microtask Queue [P1, NestedM]\n// 8. P1 executes -> console.log('Promise 1'); setTimeout(() => console.log('Timeout in promise')) -> Macrotask Queue [T1, T2, T_in_P]\n// 9. NestedM executes -> console.log('Nested microtask')\n// Microtask Queue empty.\n\n// *Process ONE Macrotask:*\n// 10. T1 executes -> console.log('Timeout 1')\n\n// *Microtask Queue empty, Process ONE Macrotask:*\n// 11. T2 executes -> console.log('Timeout 2')\n\n// *Microtask Queue empty, Process ONE Macrotask:*\n// 12. T_in_P executes -> console.log('Timeout in promise')\n```",
          "tags": [
            "event-loop",
            "microtasks",
            "macrotasks",
            "advanced",
            "conceptual"
          ],
          "prerequisites": [
            "event-loop-basics",
            "promises",
            "queueMicrotask"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_event_loop_micro_macro_3",
          "topic": "JavaScript Event Loop: Microtasks vs Macrotasks",
          "level": "medium",
          "type": "open",
          "question": "Name two types of microtasks and two types of macrotasks in a browser environment, and briefly explain when their callbacks are typically executed by the Event Loop.",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Microtasks: `Promise.then/catch/finally` callbacks, `queueMicrotask` callbacks, `MutationObserver` callbacks.",
            "Macrotasks: `setTimeout`, `setInterval`, I/O operations (like `fetch` completion), UI rendering, user interaction events (e.g., `click`).",
            "Execution Timing: Microtask callbacks are executed immediately after the currently executing script or macrotask finishes, and the entire microtask queue is emptied before the next macrotask is processed. Macrotask callbacks are picked one at a time from their queue, and after each macrotask, the microtask queue is drained again."
          ],
          "keyConcepts": [
            "microtasks",
            "macrotasks",
            "event-loop-timing",
            "callbacks"
          ],
          "evaluationCriteria": [
            "Correctly identifies examples of both task types.",
            "Accurate description of their execution phases within the event loop cycle.",
            "Clarity and conciseness of explanation."
          ],
          "example": "```javascript\n// Microtask examples: Promise.resolve().then(() => {}), queueMicrotask(() => {})\n// Macrotask examples: setTimeout(() => {}, 0), fetch('/api').then(() => {})\n\n// Execution:\n// 1. Current script runs to completion.\n// 2. All microtasks (Promises, queueMicrotask) run until the microtask queue is empty.\n// 3. Browser may render.\n// 4. One macrotask (setTimeout, fetch callback) runs.\n// 5. Go back to step 2 (drain microtasks again).\n```",
          "tags": [
            "event-loop",
            "microtasks",
            "macrotasks",
            "conceptual",
            "interview"
          ],
          "prerequisites": [
            "asynchronous-javascript"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_event_loop_micro_macro_4",
          "topic": "JavaScript Event Loop: Microtasks vs Macrotasks",
          "level": "easy",
          "type": "flashcard",
          "question": "Is `setTimeout` a microtask or a macrotask?",
          "answer": "Macrotask",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "setTimeout",
            "macrotask",
            "event-loop"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "event-loop",
            "macrotasks",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_loop_micro_macro_5",
          "topic": "JavaScript Event Loop: Microtasks vs Macrotasks",
          "level": "easy",
          "type": "flashcard",
          "question": "Are Promise callbacks (`.then()`, `.catch()`) microtasks or macrotasks?",
          "answer": "Microtasks",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "promises",
            "microtasks",
            "event-loop"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "event-loop",
            "microtasks",
            "flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_async_timeout_abortcontroller_1",
          "title": "Implement a Cancellable Data Fetcher with Timeout Display",
          "description": "\nImplement a function `createCancellableFetcher` that returns an object with a `fetchData` method and a `cancel` method. The `fetchData` method should behave like `fetchWithTimeout` and also emit progress updates to a provided callback. The `cancel` method should abort any ongoing `fetchData` call.\n\n**Requirements:**\n1.  `createCancellableFetcher()` should return an object `{ fetchData, cancel }`.\n2.  `fetchData(url: string, timeoutMs: number, onProgress?: (msg: string) => void)`:\n    *   Uses `AbortController` for cancellation and timeout.\n    *   `onProgress` callback should be called with messages like 'Fetching...', 'Timed out!', 'Fetch successful!', 'Request cancelled!' or 'Error: [message]'.\n    *   Returns the parsed JSON data on success or throws an error on failure/timeout/cancellation.\n3.  `cancel()`: Aborts any ongoing `fetchData` call.\n4.  Ensure proper cleanup of `setTimeout` timers.\n5.  Handle `AbortError` specifically for timeout vs. manual cancellation (distinguish by `controller.signal.aborted` status or context).\n",
          "difficulty": "medium",
          "startingCode": "class CancellableFetcher {\n  private controller: AbortController | null = null;\n  private timeoutId: NodeJS.Timeout | null = null;\n\n  constructor() {}\n\n  async fetchData(url: string, timeoutMs: number, onProgress?: (msg: string) => void): Promise<any> {\n    // TODO: Implement fetch with timeout and progress updates\n    // Use this.controller and this.timeoutId\n    // Call onProgress as appropriate\n    // Handle AbortError distinguishing timeout vs manual cancel\n    return Promise.reject(new Error('Not implemented'));\n  }\n\n  cancel(): void {\n    // TODO: Implement cancellation\n    // Call onProgress if a fetch was ongoing\n  }\n}\n\n// Example usage:\n// const fetcher = new CancellableFetcher();\n// (async () => {\n//   try {\n//     console.log('--- Test 1: Successful Fetch ---');\n//     const data = await fetcher.fetchData('https://jsonplaceholder.typicode.com/todos/1', 5000, (msg) => console.log('Progress:', msg));\n//     console.log('Result:', data);\n\n//     console.log('\\n--- Test 2: Timeout ---');\n//     const data2 = await fetcher.fetchData('https://httpstat.us/200?sleep=6000', 3000, (msg) => console.log('Progress:', msg));\n//     console.log('Result:', data2);\n//   } catch (e) {\n//     console.error('Error in test 1/2:', e.message);\n//   }\n// })();\n\n// (async () => {\n//   console.log('\\n--- Test 3: Manual Cancel ---');\n//   const fetcher2 = new CancellableFetcher();\n//   const fetchPromise = fetcher2.fetchData('https://httpstat.us/200?sleep=5000', 10000, (msg) => console.log('Progress (T3):', msg));\n//   setTimeout(() => fetcher2.cancel(), 1000);\n//   try {\n//     await fetchPromise;\n//   } catch (e) {\n//     console.error('Error in test 3:', e.message);\n//   }\n// })();",
          "solutionCode": "class CancellableFetcher {\n  private controller: AbortController | null = null;\n  private timeoutId: NodeJS.Timeout | null = null;\n\n  constructor() {}\n\n  async fetchData(url: string, timeoutMs: number, onProgress?: (msg: string) => void): Promise<any> {\n    if (this.controller) {\n      // Abort any existing ongoing request before starting a new one\n      this.cancel();\n      if (onProgress) onProgress('Previous request aborted for new one.');\n    }\n\n    this.controller = new AbortController();\n    const signal = this.controller.signal;\n    let isTimeout = false;\n\n    if (onProgress) onProgress('Fetching...');\n\n    this.timeoutId = setTimeout(() => {\n      isTimeout = true; // Flag to distinguish timeout from manual cancel\n      this.controller?.abort();\n    }, timeoutMs);\n\n    try {\n      const response = await fetch(url, { signal });\n\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = null;\n      }\n      this.controller = null; // Clear controller after successful completion\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! Status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (onProgress) onProgress('Fetch successful!');\n      return data;\n    } catch (error: any) {\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = null;\n      }\n      this.controller = null; // Clear controller after error\n\n      if (error.name === 'AbortError') {\n        if (onProgress) {\n          onProgress(isTimeout ? `Timed out after ${timeoutMs}ms!` : 'Request cancelled!');\n        }\n        // Re-throw specific error messages for external handling\n        throw new Error(isTimeout ? `Request timed out after ${timeoutMs}ms` : 'Request cancelled by user');\n      } else {\n        if (onProgress) onProgress(`Error: ${error.message}`);\n        throw error;\n      }\n    }\n  }\n\n  cancel(): void {\n    if (this.controller) {\n      this.controller.abort();\n      this.controller = null;\n    }\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = null;\n    }\n  }\n}\n",
          "testCases": [
            "Test with a successful fetch call: `fetcher.fetchData('https://jsonplaceholder.typicode.com/todos/1', 5000)` should resolve with data and emit 'Fetch successful!'.",
            "Test with a timeout: `fetcher.fetchData('https://httpstat.us/200?sleep=6000', 3000)` should throw an error containing 'timed out' and emit 'Timed out!'.",
            "Test with manual cancellation: Call `fetcher.fetchData` and then `fetcher.cancel()` shortly after. It should throw an error containing 'cancelled' and emit 'Request cancelled!'.",
            "Test with HTTP error (e.g., 404): `fetcher.fetchData('https://jsonplaceholder.typicode.com/nonexistent', 5000)` should throw an 'HTTP error!' and emit 'Error: HTTP error!'.",
            "Test subsequent calls: Ensure calling `fetchData` multiple times correctly aborts previous requests."
          ],
          "hints": [
            "The `onProgress` callback should be used for status messages.",
            "You can use a flag (e.g., `isTimeout`) to differentiate between `AbortError` caused by `setTimeout` and `AbortError` caused by a manual `cancel()` call.",
            "Remember to reset `this.controller` and `this.timeoutId` to `null` after the fetch operation completes (success or failure) and in the `cancel` method for proper state management.",
            "Consider using a class to manage the state of the `AbortController` and `timeoutId`."
          ],
          "tags": [
            "fetch-api",
            "AbortController",
            "timeout",
            "cancellation",
            "error-handling",
            "class-design",
            "state-management"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "async-await",
            "promises",
            "AbortController",
            "setTimeout"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "observable-pattern",
            "resource-management"
          ]
        },
        {
          "id": "task_async_retry_pattern_1",
          "title": "Build a Generic Retry Utility Function",
          "description": "\nCreate a generic `retry` utility function that can execute any asynchronous function with a specified number of retries and an exponential backoff delay.\n\n**Requirements:**\n1.  `retry<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T>`:\n    *   `fn`: An asynchronous function that returns a Promise.\n    *   `options`: An optional object with:\n        *   `attempts?: number` (default: 3) - Maximum number of retry attempts.\n        *   `delay?: number` (default: 1000) - Initial delay in milliseconds.\n        *   `backoffFactor?: number` (default: 2) - Factor by which delay increases each retry.\n        *   `shouldRetry?: (error: any) => boolean` (default: always retry) - A predicate function to determine if a specific error warrants a retry.\n    *   Returns a Promise that resolves with the `fn`'s result or rejects after all attempts fail.\n2.  Implement exponential backoff for delays.\n3.  Allow custom retry logic via `shouldRetry` predicate. If `shouldRetry` is not provided or returns `true`, retry.\n4.  Log retry attempts (optional, but good for debugging).\n",
          "difficulty": "medium",
          "startingCode": "interface RetryOptions {\n  attempts?: number;\n  delay?: number;\n  backoffFactor?: number;\n  shouldRetry?: (error: any) => boolean;\n}\n\nasync function retry<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T> {\n  const { \n    attempts = 3,\n    delay = 1000,\n    backoffFactor = 2,\n    shouldRetry = () => true // Default: always retry\n  } = options || {};\n\n  // TODO: Implement the retry logic with exponential backoff and custom retry predicate\n  return Promise.reject(new Error('Not implemented'));\n}\n\n// Example usage:\n// async function flakyOperation(attempt: number): Promise<string> {\n//   console.log(`Attempt ${attempt}: Executing flaky operation...`);\n//   if (attempt < 2) { // Fail first 2 attempts\n//     throw new Error('Simulated transient failure');\n//   }\n//   return 'Operation successful!';\n// }\n\n// (async () => {\n//   try {\n//     const result = await retry(() => flakyOperation(1), {\n//       attempts: 3,\n//       delay: 200,\n//       shouldRetry: (error) => error.message === 'Simulated transient failure'\n//     });\n//     console.log('Final Result:', result);\n//   } catch (error: any) {\n//     console.error('Operation failed after all retries:', error.message);\n//   }\n// })();\n\n// async function alwaysFailsOperation(): Promise<string> {\n//   throw new Error('Permanent failure');\n// }\n\n// (async () => {\n//   try {\n//     const result = await retry(() => alwaysFailsOperation(), {\n//       attempts: 2,\n//       delay: 100,\n//       shouldRetry: (error) => error.message === 'Simulated transient failure' // This won't retry 'Permanent failure'\n//     });\n//     console.log('Final Result (Should not be seen):', result);\n//   } catch (error: any) {\n//     console.error('Operation failed immediately as not retryable:', error.message);\n//   }\n// })();",
          "solutionCode": "interface RetryOptions {\n  attempts?: number;\n  delay?: number;\n  backoffFactor?: number;\n  shouldRetry?: (error: any) => boolean;\n}\n\nasync function retry<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T> {\n  const { \n    attempts = 3,\n    delay = 1000,\n    backoffFactor = 2,\n    shouldRetry = () => true // Default: always retry\n  } = options || {};\n\n  let currentDelay = delay;\n  for (let i = 0; i < attempts; i++) {\n    try {\n      return await fn();\n    } catch (error: any) {\n      // Check if this error should trigger a retry and if attempts are left\n      if (i < attempts - 1 && shouldRetry(error)) {\n        console.warn(`Attempt ${i + 1} failed. Retrying in ${currentDelay}ms... (Error: ${error.message})`);\n        await new Promise(resolve => setTimeout(resolve, currentDelay));\n        currentDelay *= backoffFactor; // Increase delay for next attempt\n      } else {\n        // No more attempts or error is not retryable, re-throw\n        console.error(`Operation failed after ${i + 1} attempt(s). Last error: ${error.message}`);\n        throw error; \n      }\n    }\n  }\n  // This part should ideally not be reached if initial 'attempts' is > 0 and loop is correctly structured.\n  // Added for strict typing, though the loop ensures an eventual return or throw.\n  throw new Error('Retry logic exhausted without success.');\n}\n",
          "testCases": [
            "Test with a function that succeeds on the first attempt: `retry(() => Promise.resolve('Success'))` should resolve immediately.",
            "Test with a function that fails a few times then succeeds: `retry(() => flakyOp(N))` where `flakyOp` fails `N-1` times, then succeeds. Verify it resolves on the `N`th attempt.",
            "Test with a function that always fails: `retry(() => Promise.reject('Always fails'))` should reject after `attempts` tries.",
            "Test with `shouldRetry` predicate: Pass a function that only retries for specific error messages. Ensure non-retryable errors fail immediately.",
            "Test default options: Call `retry(fn)` without options and verify it uses default attempts and delay.",
            "Test `backoffFactor`: Verify delays are correctly increasing (e.g., by logging `currentDelay`)."
          ],
          "hints": [
            "Use a `for` loop to iterate through the attempts.",
            "The `await new Promise(resolve => setTimeout(resolve, currentDelay))` pattern is key for the delay.",
            "Remember to update `currentDelay` within the loop for exponential backoff.",
            "The `shouldRetry` predicate needs to be checked before waiting for a delay and before deciding to re-throw the error."
          ],
          "tags": [
            "retry-pattern",
            "async-await",
            "promises",
            "utility-function",
            "higher-order-function",
            "error-handling"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "promises",
            "async-await",
            "functions-as-arguments"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "design-patterns",
            "resilience",
            "fault-tolerance"
          ]
        },
        {
          "id": "task_event_loop_micro_macro_1",
          "title": "Predict and Verify Event Loop Execution Order",
          "description": "\nWrite a JavaScript program that uses `setTimeout`, `Promise.resolve().then()`, and `queueMicrotask` to demonstrate the priority and execution order of tasks in the Event Loop. Your program should print messages to the console that clearly show this order. Then, explain the output based on your understanding of microtasks and macrotasks.\n\n**Requirements:**\n1.  Include at least two `setTimeout` calls with `0` delay.\n2.  Include at least two `Promise.resolve().then()` calls.\n3.  Include at least one `queueMicrotask` call.\n4.  Include synchronous `console.log` statements at the start and end of the main script, and within the asynchronous callbacks.\n5.  The `console.log` messages should be descriptive (e.g., 'Sync start', 'Promise 1', 'Timeout 2').\n6.  **Crucially:** After the code, provide a detailed textual explanation of *why* the output appears in that specific order, referencing the concepts of synchronous code, microtask queue, macrotask queue, and the event loop's processing cycle.\n",
          "difficulty": "medium",
          "startingCode": "console.log('// --- START YOUR CODE HERE ---');\n\n// Add your synchronous, setTimeout, Promise, and queueMicrotask calls here.\n// Make sure to include descriptive console.log statements.\n\nconsole.log('// --- END YOUR CODE HERE ---');\n\n/*\n\n   --- DETAILED EXPLANATION OF OUTPUT ORDER --- \n\n   (Provide your explanation here. Example structure below)\n\n   1.  Synchronous Code:\n       - Explain which `console.log` statements run first and why.\n\n   2.  Microtask Queue Processing:\n       - Explain how microtasks are gathered.\n       - Explain the order in which they execute and why they execute before macrotasks.\n       - Mention if any new microtasks/macrotasks are scheduled during this phase.\n\n   3.  Macrotask Queue Processing:\n       - Explain how macrotasks are picked one by one.\n       - Explain the order in which they execute.\n       - Mention if any new microtasks/macrotasks are scheduled during this phase.\n\n   4.  Overall Cycle:\n       - Summarize the continuous cycle of the Event Loop.\n\n*/\n",
          "solutionCode": "console.log('// --- START YOUR CODE HERE ---');\n\nconsole.log('1. Sync: Script Start');\n\nsetTimeout(() => {\n  console.log('4. Macrotask: Timeout 1');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('3. Microtask: Promise 1');\n  Promise.resolve().then(() => {\n    console.log('3.2 Microtask: Nested Promise');\n  });\n  setTimeout(() => {\n    console.log('5. Macrotask: Timeout in Promise');\n  }, 0);\n});\n\nqueueMicrotask(() => {\n  console.log('3.1 Microtask: Queue Microtask');\n});\n\nsetTimeout(() => {\n  console.log('6. Macrotask: Timeout 2');\n}, 0);\n\nconsole.log('2. Sync: Script End');\n\nconsole.log('// --- END YOUR CODE HERE ---');\n\n/*\n\n   --- DETAILED EXPLANATION OF OUTPUT ORDER ---\n\n   The JavaScript Event Loop processes tasks in a specific order: all synchronous code, then all microtasks, then one macrotask, then all microtasks again, and so on.\n\n   1.  Synchronous Code:\n       - **Output: '1. Sync: Script Start'**\n       - **Output: '2. Sync: Script End'**\n       - Explanation: All top-level synchronous code executes first and completely before any asynchronous callbacks are considered. The `setTimeout`, `Promise.then`, and `queueMicrotask` calls merely schedule their respective callbacks; their execution doesn't happen immediately.\n\n   2.  Microtask Queue Processing:\n       - After the synchronous script finishes, the Event Loop checks the Microtask Queue. All microtasks in this queue are executed *before* any macrotasks.\n       - **Output: '3. Microtask: Queue Microtask'**\n           - This was queued by `queueMicrotask`.\n       - **Output: '3.1 Microtask: Promise 1'**\n           - This was queued by `Promise.resolve().then()`.\n           - Inside this microtask, a *new microtask* ('3.2 Microtask: Nested Promise') and a *new macrotask* ('5. Macrotask: Timeout in Promise') are scheduled. The new microtask is added to the *current* microtask queue to be processed in this same phase.\n       - **Output: '3.2 Microtask: Nested Promise'**\n           - This microtask, queued during the execution of '3.1 Microtask: Promise 1', is processed immediately because the microtask queue must be fully drained before moving to macrotasks.\n       - The microtask queue is now empty.\n\n   3.  Macrotask Queue Processing:\n       - Once the microtask queue is empty, the Event Loop picks *one* macrotask from the Macrotask Queue (which holds callbacks from `setTimeout`, `setInterval`, I/O, etc.). After executing that single macrotask, it goes back to drain the microtask queue again (though in this specific example, no new microtasks are scheduled by the remaining macrotasks).\n       - **Output: '4. Macrotask: Timeout 1'**\n           - This was the first `setTimeout` scheduled. It's the first macrotask to be picked.\n       - **Output: '6. Macrotask: Timeout 2'**\n           - This was the second `setTimeout` scheduled. It's picked after '4. Macrotask: Timeout 1' and any intervening microtasks (none in this step).\n       - **Output: '5. Macrotask: Timeout in Promise'**\n           - This `setTimeout` was scheduled *from within a microtask ('Promise 1')*. It's added to the macrotask queue, but because macrotasks are processed one by one, and it was scheduled after 'Timeout 1' and 'Timeout 2' (in terms of being added to the queue), it executes last among the timeouts in this sequence.\n       - The macrotask queue is now empty.\n\n   4.  Overall Cycle:\n       The Event Loop continuously cycles: (1) Execute synchronous code. (2) Execute all microtasks. (3) (Browser render optional). (4) Execute one macrotask. Then repeat from (2).\n\n*/",
          "testCases": [
            "Run the code in a browser's console or Node.js environment.",
            "Compare the actual output to the predicted output and the detailed explanation provided.",
            "Verify that `console.log` messages appear in the exact order predicted by the event loop rules."
          ],
          "hints": [
            "Remember the strict priority: Synchronous code -> All Microtasks -> One Macrotask -> All Microtasks -> One Macrotask, and so on.",
            "New microtasks generated *during* a microtask phase are processed within the *same* phase.",
            "New macrotasks generated are added to the macrotask queue and will be picked up in subsequent macrotask phases.",
            "Use clear prefixes in your `console.log` messages (e.g., 'Sync:', 'Micro:', 'Macro:') to make the output easy to follow."
          ],
          "tags": [
            "event-loop",
            "microtasks",
            "macrotasks",
            "asynchronicity",
            "JavaScript",
            "conceptual",
            "debugging"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "promises",
            "setTimeout",
            "queueMicrotask"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "non-blocking-io",
            "concurrency-model"
          ]
        }
      ]
    }
  }
]