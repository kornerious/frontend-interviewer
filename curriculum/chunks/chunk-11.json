[
  {
    "id": "ea875451-4590-4345-ae70-694522064542",
    "startLine": 2100,
    "endLine": 2199,
    "processedDate": "2025-06-17T08:12:06.642Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_es6_classes",
          "title": "ES6 Classes: Syntax and Basic Usage",
          "content": "ES6 Classes provide a syntactic sugar over JavaScript's existing prototype-based inheritance. They offer a cleaner and more structured way to create objects and handle inheritance compared to traditional constructor functions and prototype chains, making code more readable and maintainable, especially for developers familiar with class-based languages. However, it's crucial to understand that under the hood, ES6 classes still operate on the prototypal inheritance model.\n\n## Key Concepts\n\n*   **`class` Keyword**: Used to declare a class. Class declarations are not hoisted, unlike function declarations.\n*   **`constructor` Method**: A special method for creating and initializing an object created with a class. There can only be one special method with the name \"constructor\" in a class. If you don't specify a constructor method, a default empty one is used.\n*   **Instance Properties**: Properties assigned within the `constructor` using `this` become instance-specific properties.\n*   **Methods**: Functions defined directly within the class body (outside the constructor) become methods on the class's prototype, meaning they are shared by all instances of the class, saving memory and allowing for method inheritance.\n*   **Instantiation**: Classes are instantiated using the `new` keyword, which calls the `constructor` method.\n\n## Class Declaration Syntax\n```javascript\nclass ClassName {\n  constructor(param1, param2) {\n    this.param1 = param1;\n    this.param2 = param2;\n  }\n\n  methodName() {\n    // Class method logic\n  }\n}\n```\n\n## Class Expression Syntax\nClasses can also be defined using expressions, which can be named or unnamed. A named class expression's name is only visible within the class scope.\n\n```javascript\n// Unnamed class expression\nconst MyClass = class {\n  constructor(name) {\n    this.name = name;\n  }\n};\n\n// Named class expression\nconst AnotherClass = class NamedClass {\n  constructor(value) {\n    this.value = value;\n  }\n  getName() {\n    // NamedClass is accessible here\n    return NamedClass.name; \n  }\n};\n```",
          "examples": [
            {
              "id": "example_es6_classes_1",
              "title": "Basic Class Definition and Instantiation",
              "code": "class PersonClass {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n  \n  getFullName() {\n    return this.firstName + ' ' + this.lastName;\n  }\n}\n\nconst alice = new PersonClass('Alice', 'Johnson');\nconsole.log(alice.getFullName()); // Alice Johnson\nconsole.log(alice.firstName);     // Alice\n",
              "explanation": "This example demonstrates a basic `PersonClass` with a constructor to initialize `firstName` and `lastName`, and a `getFullName` method. An instance `alice` is created using `new`, and its method is called.",
              "language": "javascript"
            },
            {
              "id": "example_es6_classes_2",
              "title": "Understanding Class Methods and Prototype",
              "code": "class Car {\n  constructor(make, model) {\n    this.make = make;\n    this.model = model;\n  }\n  \n  getDetails() {\n    return `${this.make} ${this.model}`;\n  }\n}\n\nconst myCar = new Car('Toyota', 'Camry');\nconst otherCar = new Car('Honda', 'Civic');\n\n// getDetails is a method on the prototype, shared by all instances\nconsole.log(myCar.getDetails === otherCar.getDetails); // true\nconsole.log(myCar.hasOwnProperty('getDetails')); // false (it's on prototype)\n",
              "explanation": "This example illustrates that methods defined within a class body (like `getDetails`) are added to the class's prototype (`Car.prototype`), not directly to each instance. This allows all instances to share the same method, promoting memory efficiency. Instance-specific properties (like `make`, `model`) are defined in the constructor using `this`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_es6_classes_1",
            "question_es6_classes_2",
            "question_es6_classes_3",
            "question_es6_classes_4"
          ],
          "relatedTasks": [
            "task_es6_classes_1"
          ],
          "tags": [
            "ES6",
            "Classes",
            "OOP",
            "JavaScript",
            "Frontend"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "this_keyword"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_components",
            "angular_components"
          ]
        },
        {
          "id": "theory_prototypal_inheritance",
          "title": "Prototypal Inheritance in JavaScript",
          "content": "JavaScript is a prototype-based language, meaning that objects inherit properties and methods from other objects. This is a fundamental concept distinct from class-based inheritance found in languages like Java or C++. Every JavaScript object has an internal `[[Prototype]]` property (accessible via `__proto__` or `Object.getPrototypeOf()`) that links to another object, forming a 'prototype chain'. When a property or method is accessed on an object, if it's not found directly on the object itself, the JavaScript engine looks up the prototype chain until it finds the property or reaches the end of the chain (null).\n\n## Key Concepts\n\n*   **Prototype Chain**: A series of links from one object's `[[Prototype]]` to another, ending in `null`. This chain determines how properties and methods are inherited.\n*   **`prototype` Property of Functions**: Functions in JavaScript automatically get a `prototype` property. This property is an object that becomes the `[[Prototype]]` of objects created with `new` using that function as a constructor.\n*   **Constructor Functions**: Historically, objects were created using constructor functions, where methods and shared properties were added to the `constructor.prototype`.\n*   **`__proto__`**: A non-standard, but widely supported, property that exposes an object's `[[Prototype]]`. While useful for inspection, `Object.getPrototypeOf()` and `Object.setPrototypeOf()` are the standard ways to interact with prototypes.\n*   **`Object.create()`**: A method for creating a new object, using an existing object as the prototype of the newly created object. This is a clean way to implement prototypal inheritance without constructor functions.\n\n## How Prototypal Inheritance Works\nWhen you try to access a property `prop` on an object `obj`:\n1.  The engine first checks if `prop` exists directly on `obj`.\n2.  If not, it checks `obj`'s prototype (`obj.__proto__`).\n3.  If still not found, it checks the prototype's prototype, and so on.\n4.  This continues until the property is found or the end of the prototype chain (which is `null`) is reached. If not found, `undefined` is returned.\n\n## Modifying Prototypes\nModifying a prototype affects all objects that inherit from it. If you reassign the `prototype` property of a constructor function *after* instances have been created, those existing instances will retain a link to the *original* prototype object. New instances created after the reassignment will link to the *new* prototype object. This can lead to unexpected behavior if not understood.",
          "examples": [
            {
              "id": "example_prototypal_inheritance_1",
              "title": "Basic Prototype Inheritance with Constructor Functions",
              "code": "function Main() {}\nMain.prototype = { protected: true, someMethod: function() { console.log('Method from prototype'); } };\nconst obj = new Main();\n\nconsole.log('Object protection (initial): ', obj.protected); // true\nobj.someMethod(); // Method from prototype\n\n// Reassigning Main.prototype AFTER obj is created\nMain.prototype = { protected: false, anotherMethod: function() { console.log('New method'); } };\n\nconsole.log('Object protection (after reassign): ', obj.protected); // true (obj still links to the OLD prototype)\n// obj.anotherMethod(); // TypeError: obj.anotherMethod is not a function (obj doesn't have the new method)\n\nconst newObj = new Main();\nconsole.log('New object protection: ', newObj.protected); // false (newObj links to the NEW prototype)\nnewObj.anotherMethod(); // New method\n",
              "explanation": "This example illustrates a critical aspect of prototypal inheritance: when an object is created using `new`, its `[[Prototype]]` link is established to the `prototype` object that the constructor function *currently* points to. Subsequent reassignment of `Constructor.prototype` will *not* affect already existing instances, only new ones.",
              "language": "javascript"
            },
            {
              "id": "example_prototypal_inheritance_2",
              "title": "Prototypal Inheritance with Object.create",
              "code": "const animal = {\n  init: function(name) {\n    this.name = name;\n    return this;\n  },\n  eat: function() {\n    console.log(`${this.name} is eating.`);\n  }\n};\n\nconst dog = Object.create(animal);\ndog.bark = function() {\n  console.log(`${this.name} is barking.`);\n};\n\nconst bingo = Object.create(dog).init('Bingo');\nbingo.eat();  // Bingo is eating.\nbingo.bark(); // Bingo is barking.\nconsole.log(Object.getPrototypeOf(bingo) === dog); // true\nconsole.log(Object.getPrototypeOf(dog) === animal); // true\n",
              "explanation": "`Object.create()` creates a new object and sets its `[[Prototype]]` to the specified object. Here, `dog` inherits from `animal`, and `bingo` inherits from `dog`. This creates a prototype chain: `bingo` -> `dog` -> `animal` -> `Object.prototype` -> `null`. `bingo` can access methods from `dog` (its direct prototype) and `animal` (via `dog`'s prototype). The `init` method is used for initialization as `Object.create` does not call a constructor.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_prototypal_inheritance_1",
            "question_prototypal_inheritance_2",
            "question_prototypal_inheritance_3",
            "question_prototypal_inheritance_4",
            "question_prototypal_inheritance_5"
          ],
          "relatedTasks": [
            "task_prototypal_inheritance_1",
            "task_prototypal_inheritance_2"
          ],
          "tags": [
            "JavaScript",
            "Inheritance",
            "Prototypes",
            "OOP",
            "Fundamental"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_objects",
            "functions_as_first_class_citizens"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced_javascript",
            "understanding_frameworks"
          ]
        },
        {
          "id": "theory_class_inheritance",
          "title": "ES6 Class Inheritance",
          "content": "ES6 classes introduce the `extends` keyword, providing a much cleaner and more familiar syntax for implementing inheritance compared to traditional prototypal inheritance. Despite the syntactic sugar, it still leverages JavaScript's underlying prototype chain. When one class `extends` another, it creates a prototype chain where the child class's prototype inherits from the parent class's prototype.\n\n## Key Concepts\n\n*   **`extends` Keyword**: Used to create a class that is a child of another class. The child class inherits all methods and properties from the parent class.\n*   **`super()` Keyword**: In a subclass constructor, `super()` must be called before `this` can be accessed. `super()` calls the constructor of the parent class, ensuring that the parent class's properties are initialized on the instance. If a subclass does not have a constructor, a default one is provided that calls `super()`.\n*   **Method Overriding**: A subclass can provide its own implementation for a method that is already defined in its superclass. To call the parent class's method from the overridden method, use `super.methodName()`.\n*   **`instanceof` Operator**: This operator checks if an object is an instance of a particular class (or a class that inherits from it) in its prototype chain. `childInstance instanceof ChildClass` and `childInstance instanceof ParentClass` will both return `true`.\n\n## Inheritance Process\n1.  When a `ChildClass` `extends` a `ParentClass`:\n    *   `ChildClass.prototype.__proto__` is set to `ParentClass.prototype`.\n    *   `ChildClass.__proto__` (the static `[[Prototype]]`) is set to `ParentClass` (allowing inheritance of static methods).\n2.  When `new ChildClass()` is called:\n    *   A new instance `this` is created.\n    *   The `ChildClass` constructor is executed.\n    *   If `super()` is called, the `ParentClass` constructor is executed on the `this` context, initializing parent properties.\n    *   After `super()`, `this` can be used to add child-specific properties.\n\nUnderstanding `super()` is crucial: when used as a function (`super()`), it calls the parent constructor. When used as an object (`super.methodName`), it refers to the parent's prototype methods.",
          "examples": [
            {
              "id": "example_class_inheritance_1",
              "title": "Basic Class Inheritance",
              "code": "class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  eat() {\n    console.log(`${this.name} is eating.`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name); // Call parent constructor with 'name'\n    this.breed = breed; // Add Dog-specific property\n  }\n  \n  bark() {\n    console.log(`${this.name} is barking.`);\n  }\n}\n\nconst rex = new Dog('Rex', 'German Shepherd');\nrex.eat();  // Rex is eating. (inherited from Animal)\nrex.bark(); // Rex is barking. (Dog's own method)\nconsole.log(rex.breed); // German Shepherd\n",
              "explanation": "This example shows `Dog` extending `Animal`. The `Dog` constructor calls `super(name)` to initialize the `name` property from the `Animal` class, then adds its own `breed` property. `rex` can call both its own `bark` method and the inherited `eat` method.",
              "language": "javascript"
            },
            {
              "id": "example_class_inheritance_2",
              "title": "Method Overriding and Calling Super Method",
              "code": "class Vehicle {\n  start() {\n    return 'Vehicle starting...';\n  }\n  stop() {\n    return 'Vehicle stopping...';\n  }\n}\n\nclass Car extends Vehicle {\n  start() {\n    console.log(super.start()); // Call the parent's start method\n    return 'Car engine ignites!';\n  }\n  honk() {\n    return 'Beep beep!';\n  }\n}\n\nconst myCar = new Car();\nconsole.log(myCar.start());\n// Expected Output:\n// Vehicle starting...\n// Car engine ignites!\nconsole.log(myCar.stop()); // Vehicle stopping...\n",
              "explanation": "Here, `Car` overrides the `start` method from `Vehicle`. Inside the `Car`'s `start` method, `super.start()` is used to explicitly call the overridden `start` method from the `Vehicle` parent class. This demonstrates how to extend and modify parent behavior while still leveraging its original logic.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_class_inheritance_1",
            "question_class_inheritance_2",
            "question_class_inheritance_3",
            "question_class_inheritance_4",
            "question_class_inheritance_5"
          ],
          "relatedTasks": [
            "task_class_inheritance_1"
          ],
          "tags": [
            "ES6",
            "Classes",
            "Inheritance",
            "OOP",
            "JavaScript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "theory_es6_classes",
            "theory_prototypal_inheritance"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_class_components",
            "vue_components",
            "angular_components"
          ]
        },
        {
          "id": "theory_object_descriptors_attributes",
          "title": "Object Descriptors and Property Attributes",
          "content": "In JavaScript, every property of an object has a set of attributes that define its behavior. These attributes are not directly visible when you access a property, but they control how the property can be read, written, enumerated, and configured. `Object.defineProperty()` and `Object.defineProperties()` are powerful methods that allow direct manipulation of these attributes, giving fine-grained control over object properties.\n\n## Key Concepts\n\nProperties can be categorized into two main types:\n\n1.  **Data Properties**: These hold a value.\n    *   **`value`**: The actual value of the property. (Default: `undefined`)\n    *   **`writable`**: A boolean indicating whether the property's `value` can be changed using the assignment operator (`=`). (Default: `false`)\n    *   **`enumerable`**: A boolean indicating whether the property will show up during enumeration (e.g., in `for...in` loops, `Object.keys()`, `JSON.stringify()`). (Default: `false`)\n    *   **`configurable`**: A boolean indicating whether the property's descriptor can be changed (i.e., its attributes reconfigured), and whether the property can be deleted from the object. (Default: `false`)\n\n2.  **Accessor Properties (Getters and Setters)**: These do not hold a value directly but instead consist of a getter function and/or a setter function.\n    *   **`get`**: A function that serves as a getter for the property. When the property is read, this function is called. (Default: `undefined`)\n    *   **`set`**: A function that serves as a setter for the property. When the property is assigned a value, this function is called. (Default: `undefined`)\n    *   **`enumerable`**: Same as for data properties. (Default: `false`)\n    *   **`configurable`**: Same as for data properties. (Default: `false`)\n\n    *Important Note*: An accessor property cannot have `value` or `writable` attributes. It must have either `get` or `set` (or both) and its `enumerable` and `configurable` attributes.\n\n## `Object.defineProperty()`\n\nSyntax:\n`Object.defineProperty(obj, prop, descriptor)`\n\n*   `obj`: The object on which to define the property.\n*   `prop`: The name of the property to be defined or modified.\n*   `descriptor`: An object whose properties specify the attributes for the property being defined or modified. If an attribute is omitted from the descriptor, its default value (usually `false` for boolean flags, `undefined` for `value`/`get`/`set`) is used.\n\nThis method returns the object that had the property defined.\n\n## Default Attribute Values\nWhen a property is created in a typical way (e.g., `obj.prop = value` or within an object literal `{ prop: value }`), its attributes default to `true` for `writable`, `enumerable`, and `configurable`. When `Object.defineProperty` is used without explicitly setting these, they default to `false`.\n\nThis distinction is crucial for understanding why `Object.defineProperty` provides such strong control.",
          "examples": [
            {
              "id": "example_object_descriptors_1",
              "title": "Defining Data Properties with Attributes",
              "code": "const user = {};\n\nObject.defineProperty(user, 'name', {\n  value: 'John Doe',\n  writable: true,      // Allows name to be changed\n  enumerable: true,    // Allows name to show up in for...in loops, Object.keys()\n  configurable: true   // Allows name to be deleted or its attributes to be modified\n});\n\nObject.defineProperty(user, 'id', {\n  value: 12345,\n  writable: false,     // Makes id read-only\n  enumerable: false,   // Hides id from enumeration\n  configurable: false  // Prevents id from being deleted or its attributes changed\n});\n\nconsole.log(user.name); // John Doe\nuser.name = 'Jane Doe';\nconsole.log(user.name); // Jane Doe\n\nconsole.log(user.id);   // 12345\ntry {\n  user.id = 54321; // Attempt to change read-only property\n} catch (e) {\n  console.log('Error setting id:', e.message); // In strict mode, this would throw a TypeError\n} \nconsole.log(user.id); // 12345 (value remains unchanged)\n\nfor (let key in user) {\n  console.log(key); // Only 'name' will be logged, 'id' is not enumerable\n}\n\ndelete user.name; // Allowed because configurable: true\nconsole.log(user.name); // undefined\n\ntry {\n  delete user.id; // Not allowed because configurable: false\n} catch (e) {\n  console.log('Error deleting id:', e.message); // In strict mode, this would throw a TypeError\n}\nconsole.log(user.id); // 12345 (value remains)\n\n// Attempt to redefine 'id' property (will fail)\ntry {\n  Object.defineProperty(user, 'id', { writable: true });\n} catch (e) {\n  console.log('Error reconfiguring id:', e.message); // TypeError: Cannot redefine property: id\n}\n",
              "explanation": "This example demonstrates how `writable`, `enumerable`, and `configurable` attributes control property behavior. `name` is fully mutable, enumerable, and configurable. `id` is a read-only, non-enumerable, non-configurable property, showing how its value cannot be changed, it won't appear in `for...in` loops, and its attributes cannot be altered.",
              "language": "javascript"
            },
            {
              "id": "example_object_descriptors_2",
              "title": "Defining Accessor Properties (Getters and Setters)",
              "code": "const person = {\n  firstName: 'John',\n  lastName: 'Doe'\n};\n\nObject.defineProperty(person, 'fullName', {\n  get: function() {\n    console.log('Getting fullName...');\n    return `${this.firstName} ${this.lastName}`;\n  },\n  set: function(value) {\n    console.log('Setting fullName to:', value);\n    const parts = value.split(' ');\n    this.firstName = parts[0];\n    this.lastName = parts[1] || '';\n  },\n  enumerable: true, // Make it enumerable so it shows up like a regular property\n  configurable: true // Allow it to be deleted or reconfigured\n});\n\nconsole.log(person.fullName); // Getting fullName...\n                              // John Doe\n\nperson.fullName = 'Jane Smith'; // Setting fullName to: Jane Smith\nconsole.log(person.firstName); // Jane\nconsole.log(person.lastName);  // Smith\nconsole.log(person.fullName); // Getting fullName...\n                              // Jane Smith\n\n// Attempt to define value/writable on an accessor property (will throw error)\ntry {\n  Object.defineProperty(person, 'age', {\n    value: 30,\n    get: function() { return this._age; }\n  });\n} catch (e) {\n  console.error('Error defining mixed property:', e.message);\n  // TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute\n}\n",
              "explanation": "This example creates a `fullName` accessor property on `person`. When `person.fullName` is read, the `get` function is called. When `person.fullName` is assigned a value, the `set` function is called, which then updates `firstName` and `lastName`. This demonstrates how getters and setters can provide calculated properties or control how values are set, decoupling direct property access from underlying data storage. It also shows the error when attempting to mix `value`/`writable` with `get`/`set`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_object_descriptors_1",
            "question_object_descriptors_2",
            "question_object_descriptors_3",
            "question_object_descriptors_4",
            "question_object_descriptors_5"
          ],
          "relatedTasks": [
            "task_object_descriptors_1"
          ],
          "tags": [
            "JavaScript",
            "Objects",
            "Descriptors",
            "Attributes",
            "Advanced",
            "Meta-programming"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_objects",
            "functions_as_first_class_citizens"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "requiredFor": [
            "proxy_api",
            "custom_frameworks"
          ]
        },
        {
          "id": "theory_this_keyword",
          "title": "Understanding the `this` Keyword in JavaScript",
          "content": "The `this` keyword in JavaScript is one of the most frequently misunderstood concepts. Its value is not determined by where the function is defined, but by *how* and *where* the function is called. This dynamic nature means `this` can refer to different objects depending on the execution context. Understanding `this` is fundamental for working with objects, classes, and event handlers.\n\n## Key Binding Rules for `this`\n\nThere are generally four main rules that determine the value of `this`:\n\n1.  **Default Binding (Global Object)**: If a function is called in strict mode, `this` is `undefined`. In non-strict mode, `this` refers to the global object (`window` in browsers, `global` in Node.js).\n    ```javascript\n    function showThis() { console.log(this); }\n    showThis(); // In browser: Window object; In strict mode: undefined\n    ```\n\n2.  **Implicit Binding (Object Method Call)**: When a function is called as a method of an object, `this` refers to the object that owns the method.\n    ```javascript\n    const person = { \n      name: 'Alice', \n      greet: function() { console.log(`Hello, I'm ${this.name}`); }\n    };\n    person.greet(); // this refers to 'person'\n    ```\n\n3.  **Explicit Binding (`call`, `apply`, `bind`)**: You can explicitly set the value of `this` using `call()`, `apply()`, or `bind()` methods available on all functions.\n    *   `call(thisArg, arg1, arg2, ...)`: Executes the function immediately with `this` set to `thisArg` and arguments passed individually.\n    *   `apply(thisArg, [argsArray])`: Executes the function immediately with `this` set to `thisArg` and arguments passed as an array.\n    *   `bind(thisArg)`: Returns a *new* function with `this` permanently bound to `thisArg`. The function is not executed immediately.\n    ```javascript\n    function introduce(age) { console.log(`My name is ${this.name} and I'm ${age}.`); }\n    const user = { name: 'Bob' };\n    introduce.call(user, 30);  // My name is Bob and I'm 30.\n    const boundIntroduce = introduce.bind(user, 40);\n    boundIntroduce(); // My name is Bob and I'm 40.\n    ```\n\n4.  **New Binding (Constructor Call)**: When a function is called with the `new` keyword (as a constructor), `this` refers to the newly created object instance.\n    ```javascript\n    function Person(name) { this.name = name; }\n    const john = new Person('John'); // this refers to 'john' instance\n    console.log(john.name); // John\n    ```\n\n## Arrow Functions and `this`\n\nArrow functions (`=>`) behave differently regarding `this`. They do not have their own `this` context. Instead, they lexically inherit `this` from their enclosing scope at the time they are defined. This means `this` inside an arrow function will always be the same as `this` in the code that immediately contains the arrow function. This makes them very useful for callbacks and methods where you want `this` to refer to the surrounding context, not the context of the function's invocation.\n\n```javascript\nconst counter = {\n  count: 0,\n  start: function() {\n    setInterval(() => {\n      // 'this' here refers to 'counter' due to lexical scoping\n      this.count++; \n      console.log(this.count);\n    }, 1000);\n  },\n  stop: function() {\n    setInterval(function() {\n      // 'this' here refers to the global object (or undefined in strict mode)\n      // because it's a regular function called by setInterval (default binding)\n      // console.log(this.count); // This would likely fail or log undefined/NaN\n    }, 1000);\n  }\n};\ncounter.start();\n```",
          "examples": [
            {
              "id": "example_this_keyword_1",
              "title": "Demonstrating `this` in various contexts",
              "code": "class Greeter {\n  constructor(name) {\n    this.name = name;\n  }\n\n  // Method defined on prototype, 'this' refers to instance\n  greet() {\n    console.log(`Hello, ${this.name}`);\n  }\n\n  // Arrow function method, 'this' lexically binds to instance\n  greetArrow = () => {\n    console.log(`Arrow Hello, ${this.name}`);\n  }\n\n  // Example with callback - problematic 'this'\n  delayedGreetProblem() {\n    setTimeout(function() {\n      // 'this' here is likely Window/undefined, not the Greeter instance\n      console.log(`Delayed Hello, ${this.name}`); \n    }, 100);\n  }\n\n  // Example with callback - fixed 'this' using arrow function\n  delayedGreetFixed() {\n    setTimeout(() => {\n      // 'this' here correctly refers to the Greeter instance\n      console.log(`Fixed Delayed Hello, ${this.name}`);\n    }, 100);\n  }\n}\n\nconst person = new Greeter('Alice');\nperson.greet(); // Hello, Alice\nperson.greetArrow(); // Arrow Hello, Alice\n\nperson.delayedGreetProblem(); // Delayed Hello, undefined (or error in strict mode)\nperson.delayedGreetFixed(); // Fixed Delayed Hello, Alice\n\n// Detached method call - 'this' becomes global/undefined\nconst detachedGreet = person.greet;\ndetachedGreet(); // Hello, undefined (or error in strict mode)\n",
              "explanation": "This example illustrates how `this` behaves in different scenarios: as a method on an object (`person.greet()`), as a lexically bound arrow function (`person.greetArrow()`), and in callbacks. It highlights the common pitfall of `this` losing context in regular function callbacks and how arrow functions solve this by inheriting `this` from their surrounding scope.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_this_keyword_1",
            "question_this_keyword_2",
            "question_this_keyword_3",
            "question_this_keyword_4"
          ],
          "relatedTasks": [
            "task_this_keyword_1"
          ],
          "tags": [
            "JavaScript",
            "this",
            "Context",
            "Execution",
            "Functions",
            "OOP"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "javascript_objects"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_components",
            "event_handling",
            "callback_functions"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_es6_classes_1",
          "topic": "ES6 Classes Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `constructor` method in an ES6 class?",
          "answer": "To create and initialize an object created with a class.",
          "options": [],
          "analysisPoints": [
            "Understanding the role of the constructor in class instantiation.",
            "Distinguishing it from regular methods."
          ],
          "keyConcepts": [
            "Class constructor",
            "Object initialization",
            "Instance properties"
          ],
          "evaluationCriteria": [
            "Basic knowledge of ES6 class syntax."
          ],
          "example": null,
          "tags": [
            "ES6",
            "Classes",
            "Constructor"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_es6_classes_2",
          "topic": "ES6 Classes vs. Traditional Constructors",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code snippets:\n\n**Snippet A:**\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHello() {\n    return `Hello, ${this.name}`;\n  }\n}\n```\n\n**Snippet B:**\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.sayHello = function() {\n  return `Hello, ${this.name}`;\n};\n```\n\nWhich statement accurately describes the relationship between Snippet A (ES6 Class) and Snippet B (Traditional Constructor Function)?",
          "answer": "Snippet A is syntactic sugar over Snippet B, meaning they both result in similar underlying prototypal inheritance mechanisms.",
          "options": [
            "Snippet A uses classical inheritance, while Snippet B uses prototypal inheritance.",
            "Snippet A is more performant than Snippet B due to JavaScript engine optimizations.",
            "Snippet A is syntactic sugar over Snippet B, meaning they both result in similar underlying prototypal inheritance mechanisms.",
            "Snippet B allows for private methods, which are not possible with Snippet A."
          ],
          "analysisPoints": [
            "Recognizing that ES6 classes are syntactic sugar.",
            "Understanding that JavaScript fundamentally uses prototypal inheritance.",
            "Dispelling common misconceptions about class-based vs. prototypal inheritance in JavaScript."
          ],
          "keyConcepts": [
            "ES6 Classes",
            "Prototypal Inheritance",
            "Syntactic Sugar",
            "Constructor Functions"
          ],
          "evaluationCriteria": [
            "Deep understanding of JavaScript's inheritance model.",
            "Ability to differentiate syntax from underlying mechanism."
          ],
          "example": "Both snippets produce objects where `sayHello` is found on the `Person.prototype`. This means that instances created from either will share the same `sayHello` method, demonstrating that ES6 classes are indeed a more convenient way to write the same underlying prototypal pattern.\n\n```javascript\n// Test for Snippet A\nconst personA = new Person('Alice');\nconsole.log(personA.sayHello());\n\n// Test for Snippet B\nconst personB = new Person('Bob');\nconsole.log(personB.sayHello());\n\n// Both methods are on the prototype:\nconsole.log(Object.getPrototypeOf(personA).sayHello === Person.prototype.sayHello); // true\nconsole.log(Object.getPrototypeOf(personB).sayHello === Person.prototype.sayHello); // true\n```",
          "tags": [
            "ES6",
            "Classes",
            "Prototypal Inheritance",
            "Syntactic Sugar"
          ],
          "prerequisites": [
            "theory_es6_classes",
            "theory_prototypal_inheritance"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_es6_classes_3",
          "topic": "Class Methods and Prototype",
          "level": "medium",
          "type": "open",
          "question": "Where are methods defined directly within an ES6 class body (e.g., `getFullName()` in `PersonClass`) stored, and why is this design beneficial for performance and memory usage when creating multiple instances?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Explain that methods are stored on the class's `prototype`.",
            "Discuss memory efficiency: only one copy of the method exists, shared by all instances.",
            "Explain performance: method lookup follows the prototype chain, which is efficient."
          ],
          "keyConcepts": [
            "Class methods",
            "Prototype chain",
            "Memory management",
            "Performance optimization"
          ],
          "evaluationCriteria": [
            "Ability to explain prototypal inheritance's role in ES6 classes.",
            "Understanding of memory and performance implications."
          ],
          "example": null,
          "tags": [
            "ES6",
            "Classes",
            "Prototype",
            "Performance",
            "Memory"
          ],
          "prerequisites": [
            "theory_es6_classes",
            "theory_prototypal_inheritance"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_es6_classes_4",
          "topic": "Class Declaration vs. Expression Hoisting",
          "level": "easy",
          "type": "flashcard",
          "question": "Are ES6 Class Declarations hoisted in the same way as `function` declarations?",
          "answer": "No. ES6 Class Declarations are not hoisted. You cannot access a class before it is defined, which results in a `ReferenceError`.",
          "options": [],
          "analysisPoints": [
            "Understanding the difference in hoisting behavior between functions and classes.",
            "Identifying potential `ReferenceError` scenarios."
          ],
          "keyConcepts": [
            "Hoisting",
            "Class Declaration",
            "Function Declaration",
            "Temporal Dead Zone"
          ],
          "evaluationCriteria": [
            "Basic knowledge of JavaScript hoisting rules."
          ],
          "example": null,
          "tags": [
            "ES6",
            "Classes",
            "Hoisting",
            "ReferenceError"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_prototypal_inheritance_1",
          "topic": "Prototype Chain Lookup",
          "level": "easy",
          "type": "flashcard",
          "question": "When you try to access a property on an object in JavaScript, and that property is not found directly on the object, what mechanism does JavaScript use to try and find it?",
          "answer": "It looks up the prototype chain until it finds the property or reaches the end of the chain (null).",
          "options": [],
          "analysisPoints": [
            "Understanding the fundamental lookup mechanism in prototypal inheritance."
          ],
          "keyConcepts": [
            "Prototype chain",
            "Property lookup",
            "Inheritance"
          ],
          "evaluationCriteria": [
            "Basic understanding of prototypal inheritance."
          ],
          "example": null,
          "tags": [
            "Prototypes",
            "Inheritance",
            "JavaScript Fundamentals"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_prototypal_inheritance_2",
          "topic": "Object.create() vs. new Constructor()",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following best describes the difference in how `Object.create()` and the `new` keyword (with a constructor function) create objects in terms of their `[[Prototype]]`?",
          "answer": "`Object.create(protoObject)` sets the new object's `[[Prototype]]` directly to `protoObject`, whereas `new Constructor()` sets the new object's `[[Prototype]]` to `Constructor.prototype`.",
          "options": [
            "`Object.create()` creates objects without any prototype, while `new` always assigns `Object.prototype`.",
            "`Object.create(protoObject)` sets the new object's `[[Prototype]]` directly to `protoObject`, whereas `new Constructor()` sets the new object's `[[Prototype]]` to `Constructor.prototype`.",
            "`new` always calls a constructor, while `Object.create()` does not and requires manual initialization.",
            "`Object.create()` can only create objects with `null` prototype, while `new` can create objects with any prototype."
          ],
          "analysisPoints": [
            "Distinguishing the core mechanism of `Object.create()` (direct prototype assignment) from `new` (prototype via constructor's `prototype` property).",
            "Understanding the role of `Constructor.prototype`.",
            "Recognizing that `Object.create` does not invoke a constructor function.",
            "Identifying common misconceptions about `null` prototypes."
          ],
          "keyConcepts": [
            "Object.create",
            "New keyword",
            "Prototypal Inheritance",
            "Constructor Functions",
            "[[Prototype]]"
          ],
          "evaluationCriteria": [
            "Detailed understanding of object creation patterns.",
            "Ability to explain the underlying prototype linkages."
          ],
          "example": "```javascript\n// Using new\nfunction Vehicle() {}\nVehicle.prototype.wheels = 4;\nconst car = new Vehicle();\nconsole.log(Object.getPrototypeOf(car) === Vehicle.prototype); // true\n\n// Using Object.create\nconst animalPrototype = { legs: 4 };\nconst dog = Object.create(animalPrototype);\nconsole.log(Object.getPrototypeOf(dog) === animalPrototype); // true\n```",
          "tags": [
            "Prototypes",
            "Object.create",
            "New Keyword",
            "Inheritance"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_prototypal_inheritance_3",
          "topic": "Dynamic Prototype Reassignment",
          "level": "hard",
          "type": "code",
          "question": "Analyze the following code and predict the output. Explain why `obj.protected` returns `true` even after `Main.prototype` is reassigned to `{ protected: false }`.",
          "answer": "```javascript\n// Output:\n// Object protection:  true\n\n// Explanation:\n// When `obj` is created with `const obj = new Main();`, its internal `[[Prototype]]` link (`obj.__proto__`) is set to point to the `Main.prototype` object *at that specific moment*. \n// At that time, `Main.prototype` was `{ protected: true }`. \n// When `Main.prototype` is later reassigned to a *new object* `{ protected: false }`, `obj`'s `[[Prototype]]` link does not change. It still points to the *original* prototype object. \n// Therefore, when `obj.protected` is accessed, the JavaScript engine looks up the prototype chain, finds `protected: true` on the original prototype object, and returns it.\n// Only new instances created *after* the `Main.prototype` reassignment would inherit from the new prototype.",
          "options": [],
          "analysisPoints": [
            "Understanding that an object's prototype link is established at creation time.",
            "Explaining the difference between modifying an existing prototype object and reassigning the `prototype` property to a new object.",
            "Predicting the exact output based on prototypal chain lookup."
          ],
          "keyConcepts": [
            "Prototypal Inheritance",
            "Prototype Chain",
            "Object Creation",
            "Reference vs. Value Semantics"
          ],
          "evaluationCriteria": [
            "Ability to debug and trace prototypal inheritance.",
            "Clear explanation of the underlying mechanism."
          ],
          "example": "```javascript\n// Basic prototype inheritance\nfunction Main() {}\nMain.prototype = { protected: true };\nconst obj = new Main();\nMain.prototype = { protected: false };\nconsole.log('Object protection: ', obj.protected); // true\n```",
          "tags": [
            "Prototypes",
            "Inheritance",
            "Debugging",
            "Advanced JavaScript"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_prototypal_inheritance_4",
          "topic": "Prototypal vs. Classical Inheritance",
          "level": "medium",
          "type": "open",
          "question": "JavaScript is often described as a 'prototype-based' language, contrasting with 'class-based' languages like Java or C++. Explain the fundamental difference between these two inheritance models and how JavaScript achieves inheritance using prototypes.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Define classical inheritance (blueprints, instances are copies).",
            "Define prototypal inheritance (objects inheriting from other objects).",
            "Explain how JavaScript achieves this via `[[Prototype]]` links and the prototype chain lookup.",
            "Discuss the concept of delegation vs. copying."
          ],
          "keyConcepts": [
            "Prototypal Inheritance",
            "Classical Inheritance",
            "Prototype Chain",
            "Delegation"
          ],
          "evaluationCriteria": [
            "Clear articulation of fundamental OOP concepts.",
            "Ability to compare and contrast programming paradigms."
          ],
          "example": null,
          "tags": [
            "Prototypes",
            "Inheritance",
            "OOP",
            "Concepts"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_prototypal_inheritance_5",
          "topic": "Prototype Chain and `__proto__`",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the standard way to programmatically access an object's prototype in JavaScript, and what is the difference between `obj.__proto__` and `obj.prototype`?",
          "answer": "The standard way to access an object's prototype is `Object.getPrototypeOf(obj)`. \n\n`obj.__proto__` is a non-standard (though widely supported) accessor property that exposes the internal `[[Prototype]]` of an object. It represents the actual object from which `obj` inherits.\n\n`obj.prototype` is only relevant for *constructor functions* and *classes*. It refers to the object that will become the `[[Prototype]]` of instances created by that constructor/class. Regular objects do not have a `prototype` property.",
          "options": [],
          "analysisPoints": [
            "Distinguishing between the instance's prototype (`__proto__` / `Object.getPrototypeOf`) and a constructor's `prototype` property.",
            "Highlighting the standard vs. non-standard access methods."
          ],
          "keyConcepts": [
            "Prototype",
            "[[Prototype]]",
            "Constructor.prototype",
            "Object.getPrototypeOf",
            "__proto__"
          ],
          "evaluationCriteria": [
            "Accuracy in defining core prototype concepts.",
            "Knowledge of standard API vs. legacy properties."
          ],
          "example": null,
          "tags": [
            "Prototypes",
            "JavaScript Objects",
            "API"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_inheritance_1",
          "topic": "ES6 Class Inheritance Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary keyword used in ES6 to establish an inheritance relationship between two classes?",
          "answer": "`extends`",
          "options": [],
          "analysisPoints": [
            "Basic knowledge of ES6 class inheritance syntax."
          ],
          "keyConcepts": [
            "Class Inheritance",
            "Extends Keyword"
          ],
          "evaluationCriteria": [
            "Understanding core ES6 syntax."
          ],
          "example": null,
          "tags": [
            "ES6",
            "Classes",
            "Inheritance"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_class_inheritance_2",
          "topic": "Super Keyword in Class Inheritance",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following ES6 class structure:\n\n```javascript\nclass BaseEntity {\n  constructor(id) {\n    this.id = id;\n  }\n  getInfo() {\n    return `ID: ${this.id}`;\n  }\n}\n\nclass User extends BaseEntity {\n  constructor(id, username) {\n    // Line A\n    this.username = username;\n  }\n  getUserInfo() {\n    return `${this.username} - ${this.getInfo()}`;\n  }\n}\n\nconst user = new User(1, 'jsdev');\n```\n\nWhat would happen if `Line A` is the only line missing in the `User` class constructor, and you try to create an instance of `User`? And what is the correct way to fix it?",
          "answer": "A `ReferenceError` would be thrown because `this` cannot be accessed before `super()` is called in a subclass constructor. The correct fix is to add `super(id);` as `Line A`.",
          "options": [
            "The `username` property would be undefined, but no error would be thrown.",
            "A `TypeError` would be thrown because the `BaseEntity` constructor was not called.",
            "A `ReferenceError` would be thrown because `this` cannot be accessed before `super()` is called in a subclass constructor. The correct fix is to add `super(id);` as `Line A`.",
            "The code would work fine, as ES6 classes automatically call the parent constructor."
          ],
          "analysisPoints": [
            "Understanding the mandatory call to `super()` in subclass constructors.",
            "Knowing that `this` is not available in a subclass constructor until `super()` is called.",
            "Identifying the specific type of error (`ReferenceError`)."
          ],
          "keyConcepts": [
            "Class Inheritance",
            "Super Keyword",
            "Constructor",
            "ReferenceError",
            "This Keyword"
          ],
          "evaluationCriteria": [
            "Knowledge of `super()` and its implications for `this`.",
            "Ability to identify and correct common inheritance issues."
          ],
          "example": "```javascript\nclass BaseEntity {\n  constructor(id) {\n    this.id = id;\n  }\n}\n\nclass User extends BaseEntity {\n  constructor(id, username) {\n    // Incorrect: try to use 'this' before super()\n    // this.username = username; // This line would cause ReferenceError\n    \n    // Correct way:\n    super(id); // Must call super() first to initialize 'this' from parent\n    this.username = username;\n  }\n}\n\ntry {\n  const user = new User(1, 'jsdev');\n  console.log(user.id); // 1\n  console.log(user.username); // jsdev\n} catch (e) {\n  console.error(e.message);\n}\n```",
          "tags": [
            "ES6",
            "Classes",
            "Inheritance",
            "Super",
            "Errors"
          ],
          "prerequisites": [
            "theory_class_inheritance"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_inheritance_3",
          "topic": "Method Overriding in Class Inheritance",
          "level": "medium",
          "type": "open",
          "question": "Explain how method overriding works in ES6 class inheritance. Provide an example of a child class overriding a parent method and then calling the parent's original method from within the overridden one.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Define method overriding (subclass provides its own implementation).",
            "Explain how to call the parent's method using `super.methodName()`.",
            "Provide a clear code example demonstrating both overriding and `super.methodName()`."
          ],
          "keyConcepts": [
            "Method Overriding",
            "ES6 Classes",
            "Inheritance",
            "Super Keyword"
          ],
          "evaluationCriteria": [
            "Ability to explain and demonstrate method overriding.",
            "Correct usage of `super.methodName()`."
          ],
          "example": "```javascript\nclass Shape {\n  draw() {\n    return 'Drawing a generic shape.';\n  }\n}\n\nclass Circle extends Shape {\n  draw() {\n    const parentDraw = super.draw(); // Call parent method\n    return `${parentDraw} Specifically, drawing a circle.`;\n  }\n}\n\nconst myCircle = new Circle();\nconsole.log(myCircle.draw()); // Output: Drawing a generic shape. Specifically, drawing a circle.\n```",
          "tags": [
            "ES6",
            "Classes",
            "Inheritance",
            "Method Overriding",
            "Super"
          ],
          "prerequisites": [
            "theory_class_inheritance"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_inheritance_4",
          "topic": "Class Inheritance and `instanceof`",
          "level": "easy",
          "type": "flashcard",
          "question": "If `Dog` `extends` `Animal`, and `rex` is an instance of `Dog`, what will `rex instanceof Animal` evaluate to?",
          "answer": "`true`",
          "options": [],
          "analysisPoints": [
            "Understanding how `instanceof` checks the prototype chain."
          ],
          "keyConcepts": [
            "Instanceof operator",
            "Class Inheritance",
            "Prototype Chain"
          ],
          "evaluationCriteria": [
            "Basic understanding of type checking in inheritance."
          ],
          "example": null,
          "tags": [
            "ES6",
            "Classes",
            "Instanceof"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_class_inheritance_5",
          "topic": "Static Methods in Class Inheritance",
          "level": "medium",
          "type": "open",
          "question": "Can static methods be inherited in ES6 classes? If so, how does this work under the hood?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Confirm that static methods are inherited.",
            "Explain that this works because `ChildClass.__proto__` points to `ParentClass`.",
            "Provide a simple code example."
          ],
          "keyConcepts": [
            "Static Methods",
            "Class Inheritance",
            "Prototype Chain",
            "[[Prototype]]"
          ],
          "evaluationCriteria": [
            "Understanding of static properties/methods and their inheritance.",
            "Ability to explain the underlying prototype link."
          ],
          "example": "```javascript\nclass Parent {\n  static staticMethod() {\n    return 'Parent static method';\n  }\n}\n\nclass Child extends Parent {\n  static childStaticMethod() {\n    return super.staticMethod() + ' from Child.';\n  }\n}\n\nconsole.log(Child.staticMethod()); // Parent static method\nconsole.log(Child.childStaticMethod()); // Parent static method from Child.\n```",
          "tags": [
            "ES6",
            "Classes",
            "Static",
            "Inheritance"
          ],
          "prerequisites": [
            "theory_class_inheritance",
            "theory_prototypal_inheritance"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_object_descriptors_1",
          "topic": "Property Attributes Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of the `writable` attribute for an object property?",
          "answer": "It determines whether the property's `value` can be changed (reassigned) using the assignment operator (`=`). If `writable` is `false`, the property is read-only.",
          "options": [],
          "analysisPoints": [
            "Understanding the basic function of the `writable` attribute."
          ],
          "keyConcepts": [
            "Property Attributes",
            "Writable",
            "Object.defineProperty"
          ],
          "evaluationCriteria": [
            "Basic knowledge of object property configuration."
          ],
          "example": null,
          "tags": [
            "JavaScript Objects",
            "Descriptors",
            "Writable"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_object_descriptors_2",
          "topic": "Enumerable Attribute",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following object and how properties are defined:\n\n```javascript\nconst item = {\n  name: 'Laptop',\n  price: 1200\n};\n\nObject.defineProperty(item, 'id', {\n  value: 'LPT-001',\n  enumerable: false\n});\n\nObject.defineProperty(item, 'category', {\n  value: 'Electronics',\n  enumerable: true\n});\n\nconst keys = Object.keys(item);\nlet count = 0;\nfor (let prop in item) {\n  count++;\n}\n```\n\nWhat will be the value of `keys` and `count` respectively?",
          "answer": "`keys` will be `['name', 'price', 'category']` and `count` will be `3`.",
          "options": [
            "`keys` will be `['name', 'price', 'id', 'category']` and `count` will be `4`.",
            "`keys` will be `['name', 'price', 'category']` and `count` will be `3`.",
            "`keys` will be `['Laptop', 1200, 'LPT-001', 'Electronics']` and `count` will be `4`.",
            "`keys` will be `['name', 'price']` and `count` will be `2`."
          ],
          "analysisPoints": [
            "Understanding the effect of `enumerable: false` on `Object.keys()` and `for...in` loops.",
            "Distinguishing between default `enumerable` for literal properties and `defineProperty`.",
            "Tracing property enumeration."
          ],
          "keyConcepts": [
            "Enumerable",
            "Object.keys()",
            "for...in loop",
            "Object.defineProperty"
          ],
          "evaluationCriteria": [
            "Ability to predict property enumeration behavior.",
            "Understanding of descriptor defaults."
          ],
          "example": "```javascript\nconst item = {\n  name: 'Laptop',\n  price: 1200\n};\n\nObject.defineProperty(item, 'id', {\n  value: 'LPT-001',\n  enumerable: false\n});\n\nObject.defineProperty(item, 'category', {\n  value: 'Electronics',\n  enumerable: true\n});\n\nconst keys = Object.keys(item);\nconsole.log(keys); // ['name', 'price', 'category']\nlet count = 0;\nfor (let prop in item) {\n  count++;\n}\nconsole.log(count); // 3\n```",
          "tags": [
            "JavaScript Objects",
            "Descriptors",
            "Enumerable",
            "Object.keys"
          ],
          "prerequisites": [
            "theory_object_descriptors_attributes"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_object_descriptors_3",
          "topic": "Configurable Attribute and Deletion",
          "level": "medium",
          "type": "open",
          "question": "What is the purpose of the `configurable` attribute? Provide an example demonstrating how it affects the deletion and re-configuration of a property.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Define `configurable` (allows deletion and attribute modification).",
            "Show an example where `configurable: true` allows deletion/redefinition.",
            "Show an example where `configurable: false` prevents deletion/redefinition (and potential `TypeError`)."
          ],
          "keyConcepts": [
            "Configurable",
            "Object.defineProperty",
            "Property Deletion",
            "TypeError"
          ],
          "evaluationCriteria": [
            "Ability to explain complex property attributes.",
            "Demonstration of practical impact with code."
          ],
          "example": "```javascript\nconst myObject = {};\n\n// Configurable: true (default for literal properties)\nmyObject.prop1 = 'value1';\nconsole.log('prop1 initially:', myObject.prop1);\ndelete myObject.prop1;\nconsole.log('prop1 after delete:', myObject.prop1); // undefined\n\n// Configurable: false (default for Object.defineProperty without explicit setting)\nObject.defineProperty(myObject, 'prop2', {\n  value: 'value2',\n  configurable: false\n});\nconsole.log('prop2 initially:', myObject.prop2);\n\ntry {\n  delete myObject.prop2;\n} catch (e) {\n  console.error('Error deleting prop2:', e.message); // TypeError in strict mode\n}\nconsole.log('prop2 after attempted delete:', myObject.prop2); // value2 (not deleted)\n\ntry {\n  Object.defineProperty(myObject, 'prop2', { writable: true }); // Attempt to reconfigure\n} catch (e) {\n  console.error('Error reconfiguring prop2:', e.message); // TypeError: Cannot redefine property: prop2\n}\n```",
          "tags": [
            "JavaScript Objects",
            "Descriptors",
            "Configurable",
            "Property Deletion"
          ],
          "prerequisites": [
            "theory_object_descriptors_attributes"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_object_descriptors_4",
          "topic": "Accessor vs. Data Properties",
          "level": "hard",
          "type": "mcq",
          "question": "Which of the following property descriptors is **invalid** when used with `Object.defineProperty()`?",
          "answer": "```javascript\n{\n  value: 'static value',\n  get: function() { return 'dynamic value'; }\n}\n```",
          "options": [
            "```javascript\n{\n  value: 10,\n  writable: false\n}\n```",
            "```javascript\n{\n  get: function() { return this._x; },\n  set: function(val) { this._x = val; }\n}\n```",
            "```javascript\n{\n  value: 'static value',\n  get: function() { return 'dynamic value'; }\n}\n```",
            "```javascript\n{\n  configurable: true,\n  enumerable: true\n}\n```"
          ],
          "analysisPoints": [
            "Understanding the mutual exclusivity of data property attributes (`value`, `writable`) and accessor property attributes (`get`, `set`).",
            "Identifying the correct combination of attributes for each property type.",
            "Recognizing that `configurable` and `enumerable` can be present in both types."
          ],
          "keyConcepts": [
            "Object.defineProperty",
            "Data Property",
            "Accessor Property",
            "Property Descriptors"
          ],
          "evaluationCriteria": [
            "Detailed knowledge of `Object.defineProperty` rules.",
            "Ability to identify invalid property configurations."
          ],
          "example": "If you try to use `value` or `writable` along with `get` or `set` in the same descriptor, JavaScript will throw a `TypeError` because a property cannot be both a data property (holding a value directly) and an accessor property (defined by getter/setter functions) simultaneously.\n\n```javascript\nconst obj = {};\ntry {\n  Object.defineProperty(obj, 'invalidProp', {\n    value: 10,\n    get: function() { return 20; }\n  });\n} catch (e) {\n  console.error(e.message); // TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute\n}\n```",
          "tags": [
            "JavaScript Objects",
            "Descriptors",
            "TypeError",
            "API"
          ],
          "prerequisites": [
            "theory_object_descriptors_attributes"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_object_descriptors_5",
          "topic": "Default Property Attributes",
          "level": "easy",
          "type": "flashcard",
          "question": "When you define a property using an object literal (e.g., `const obj = { prop: 'value' };`), what are the default values for its `writable`, `enumerable`, and `configurable` attributes?",
          "answer": "All are `true` by default when defined via an object literal or direct assignment.",
          "options": [],
          "analysisPoints": [
            "Understanding the difference in default attribute values based on property creation method."
          ],
          "keyConcepts": [
            "Property Attributes",
            "Default Values",
            "Object Literal"
          ],
          "evaluationCriteria": [
            "Basic recall of property attribute defaults."
          ],
          "example": null,
          "tags": [
            "JavaScript Objects",
            "Descriptors",
            "Defaults"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_this_keyword_1",
          "topic": "Implicit Binding of `this`",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following code:\n\n```javascript\nconst user = {\n  name: 'Alice',\n  greet: function() {\n    console.log(`Hello, ${this.name}`);\n  },\n  sayNameLater: function() {\n    setTimeout(function() {\n      console.log(`Later, ${this.name}`);\n    }, 100);\n  }\n};\n\nuser.greet();\nuser.sayNameLater();\n```\n\nWhat will be the output of `user.sayNameLater()` after 100ms (assuming a browser environment and non-strict mode)?",
          "answer": "`Later, undefined` (or similar, depending on the global object's `name` property or strict mode)",
          "options": [
            "`Later, Alice`",
            "`TypeError: Cannot read property 'name' of undefined`",
            "`Later, [object Window]` (if `this` refers to `window` and it has a `name` property)",
            "`Later, undefined` (or similar, depending on the global object's `name` property or strict mode)"
          ],
          "analysisPoints": [
            "Understanding that `this` in a regular function loses its context when passed as a callback (`setTimeout`).",
            "Recognizing the default binding rule in non-strict mode (global object).",
            "Predicting the value of `this.name` when `this` is the global object."
          ],
          "keyConcepts": [
            "This Keyword",
            "Implicit Binding",
            "Default Binding",
            "Callback Functions",
            "setTimeout"
          ],
          "evaluationCriteria": [
            "Ability to trace `this` context changes.",
            "Understanding common `this` pitfalls."
          ],
          "example": "In a browser, if `window.name` is not set, `this.name` would be `undefined`. In strict mode, `this` in the `setTimeout` callback would be `undefined`, leading to `TypeError: Cannot read properties of undefined (reading 'name')`.\n\n```javascript\nconst user = {\n  name: 'Alice',\n  sayNameLater: function() {\n    setTimeout(function() {\n      console.log(`Later, ${this.name}`);\n    }, 100);\n  }\n};\nuser.sayNameLater(); // After 100ms: Later, undefined (in browser, non-strict mode if window.name is not set)\n```",
          "tags": [
            "JavaScript",
            "this",
            "Callbacks",
            "setTimeout",
            "Context"
          ],
          "prerequisites": [
            "theory_this_keyword"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_keyword_2",
          "topic": "Arrow Functions and `this`",
          "level": "medium",
          "type": "open",
          "question": "How do arrow functions (`=>`) handle the `this` keyword differently from regular function expressions? When would you prefer using an arrow function for `this` binding?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Explain lexical `this` binding in arrow functions (inherits from enclosing scope).",
            "Contrast with regular functions' dynamic `this` binding (depends on invocation context).",
            "Provide scenarios where arrow functions are ideal (callbacks, class methods where `this` needs to stay bound to instance)."
          ],
          "keyConcepts": [
            "Arrow Functions",
            "This Keyword",
            "Lexical Scoping",
            "Callback Functions",
            "Class Methods"
          ],
          "evaluationCriteria": [
            "Clear explanation of `this` behavior.",
            "Ability to identify appropriate use cases for arrow functions."
          ],
          "example": "```javascript\nclass Timer {\n  constructor() {\n    this.seconds = 0;\n    setInterval(() => {\n      this.seconds++; // 'this' correctly refers to the Timer instance\n      console.log(this.seconds);\n    }, 1000);\n  }\n}\n\n// Compare to a problematic regular function:\n// class TimerProblem {\n//   constructor() {\n//     this.seconds = 0;\n//     setInterval(function() {\n//       this.seconds++; // 'this' here refers to global object/undefined\n//       console.log(this.seconds);\n//     }, 1000);\n//   }\n// }\n```",
          "tags": [
            "JavaScript",
            "this",
            "Arrow Functions",
            "Context",
            "Callbacks"
          ],
          "prerequisites": [
            "theory_this_keyword"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_keyword_3",
          "topic": "Explicit Binding (`call`, `apply`, `bind`)",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the key difference between `Function.prototype.call()`, `Function.prototype.apply()`, and `Function.prototype.bind()` in terms of how they set `this` and execute the function?",
          "answer": "`call()`: Executes the function immediately. Arguments are passed individually.\n`apply()`: Executes the function immediately. Arguments are passed as an array.\n`bind()`: Does NOT execute the function immediately. It returns a *new* function with `this` permanently bound to the specified object, which can be called later.",
          "options": [],
          "analysisPoints": [
            "Distinguishing immediate execution vs. returning a bound function.",
            "Understanding argument passing differences (`call` vs `apply`)."
          ],
          "keyConcepts": [
            "This Keyword",
            "Call",
            "Apply",
            "Bind",
            "Explicit Binding"
          ],
          "evaluationCriteria": [
            "Clear understanding of explicit binding methods.",
            "Knowledge of their differences in usage."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "this",
            "Call Apply Bind",
            "Functions"
          ],
          "prerequisites": [
            "theory_this_keyword"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_keyword_4",
          "topic": "`this` in Global Scope and Strict Mode",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the value of `this` in the global execution context (outside any function) and inside a simple function call in strict mode?",
          "answer": "In the global execution context (outside any function), `this` always refers to the global object (`window` in browsers, `global` in Node.js).\n\nInside a simple function call in strict mode, `this` is `undefined`.",
          "options": [],
          "analysisPoints": [
            "Understanding global `this`.",
            "Understanding strict mode impact on `this`."
          ],
          "keyConcepts": [
            "This Keyword",
            "Global Scope",
            "Strict Mode"
          ],
          "evaluationCriteria": [
            "Basic knowledge of `this` in different modes."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "this",
            "Strict Mode"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_es6_classes_1",
          "title": "Create a `ShoppingCart` Class",
          "description": "\nDesign and implement an ES6 `ShoppingCart` class. This class should manage a collection of products.\n\n**Requirements:**\n1.  The `ShoppingCart` class must have a `constructor` that initializes an empty array to store `items`.\n2.  Implement an `addItem(product, quantity)` method:\n    *   It should add a product (object with `id`, `name`, `price`) and its `quantity` to the `items` array.\n    *   If the product is already in the cart, update its quantity (add to existing).\n    *   Ensure `quantity` is a positive number.\n3.  Implement a `removeItem(productId)` method:\n    *   Removes the product with the given `productId` from the cart.\n    *   If the product is not found, do nothing or log a message.\n4.  Implement a `getTotalItems()` method that returns the total count of all items in the cart (sum of all quantities).\n5.  Implement a `getTotalPrice()` method that calculates and returns the total price of all items in the cart (sum of `product.price * quantity`).\n\nYour solution should demonstrate proper use of class syntax, instance properties, and methods.\n",
          "difficulty": "medium",
          "startingCode": "class ShoppingCart {\n  constructor() {\n    // TODO: Initialize items array\n  }\n\n  addItem(product, quantity) {\n    // TODO: Implement adding/updating product quantity\n    // product: { id: string, name: string, price: number }\n  }\n\n  removeItem(productId) {\n    // TODO: Implement removing product by ID\n  }\n\n  getTotalItems() {\n    // TODO: Calculate total quantity of all items\n    return 0;\n  }\n\n  getTotalPrice() {\n    // TODO: Calculate total price of all items\n    return 0;\n  }\n}\n\n// Example Usage (for testing):\n// const cart = new ShoppingCart();\n// cart.addItem({ id: 'P1', name: 'Laptop', price: 1200 }, 1);\n// cart.addItem({ id: 'P2', name: 'Mouse', price: 25 }, 2);\n// console.log('Total Items:', cart.getTotalItems()); // Expected: 3\n// console.log('Total Price:', cart.getTotalPrice()); // Expected: 1250\n// cart.addItem({ id: 'P1', name: 'Laptop', price: 1200 }, 1); // Add another Laptop\n// console.log('Total Items after adding more Laptop:', cart.getTotalItems()); // Expected: 4\n// console.log('Total Price after adding more Laptop:', cart.getTotalPrice()); // Expected: 2450\n// cart.removeItem('P2');\n// console.log('Total Items after removing Mouse:', cart.getTotalItems()); // Expected: 2\n// console.log('Total Price after removing Mouse:', cart.getTotalPrice()); // Expected: 2400\n",
          "solutionCode": "class ShoppingCart {\n  constructor() {\n    this.items = []; // Each item: { product: { id, name, price }, quantity: number }\n  }\n\n  addItem(product, quantity) {\n    if (!product || typeof quantity !== 'number' || quantity <= 0) {\n      console.warn('Invalid product or quantity provided.');\n      return;\n    }\n\n    const existingItem = this.items.find(item => item.product.id === product.id);\n\n    if (existingItem) {\n      existingItem.quantity += quantity;\n    } else {\n      this.items.push({ product, quantity });\n    }\n  }\n\n  removeItem(productId) {\n    const initialLength = this.items.length;\n    this.items = this.items.filter(item => item.product.id !== productId);\n    if (this.items.length === initialLength) {\n      console.log(`Product with ID ${productId} not found in cart.`);\n    }\n  }\n\n  getTotalItems() {\n    return this.items.reduce((total, item) => total + item.quantity, 0);\n  }\n\n  getTotalPrice() {\n    return this.items.reduce((total, item) => total + (item.product.price * item.quantity), 0);\n  }\n}\n",
          "testCases": [
            "Initialize empty cart: `new ShoppingCart().getTotalItems()` should be 0.",
            "Add a single item: `cart.addItem({id: 'A', name: 'X', price: 10}, 1); cart.getTotalItems()` should be 1, `getTotalPrice()` should be 10.",
            "Add existing item: `cart.addItem({id: 'A', name: 'X', price: 10}, 2); cart.getTotalItems()` should be 3, `getTotalPrice()` should be 30.",
            "Add multiple different items: check total items and total price.",
            "Remove an existing item: `cart.removeItem('A');` should correctly update totals.",
            "Remove a non-existing item: `cart.removeItem('Z');` should not change state, no error.",
            "Add item with zero or negative quantity: should not add/modify items, or warn.",
            "Edge case: empty cart operations (remove, get totals) should not throw errors."
          ],
          "hints": [
            "Use `Array.prototype.find()` to check if a product already exists.",
            "Use `Array.prototype.filter()` for `removeItem`.",
            "Remember to use `this` to access instance properties and methods.",
            "For totals, `Array.prototype.reduce()` is very suitable."
          ],
          "tags": [
            "ES6 Classes",
            "OOP",
            "Data Structures",
            "Arrays",
            "Frontend Interview"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_es6_classes",
            "javascript_arrays"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "object_oriented_programming",
            "array_methods",
            "data_encapsulation"
          ]
        },
        {
          "id": "task_prototypal_inheritance_1",
          "title": "Implement a Simple Logger with Prototypal Inheritance",
          "description": "\nImplement a basic logging utility using JavaScript's prototypal inheritance model. This task focuses on understanding `Object.create()` and defining shared methods on a prototype.\n\n**Requirements:**\n1.  Create a `loggerPrototype` object that contains common logging methods.\n2.  The `loggerPrototype` should have a method `log(message)` that prints `[LOG] message` to the console.\n3.  The `loggerPrototype` should have a method `warn(message)` that prints `[WARN] message` to the console.\n4.  Create a new `infoLogger` object using `Object.create()` from `loggerPrototype`.\n5.  Add a specific method `info(message)` to `infoLogger` that prints `[INFO] message` to the console. This method should *only* be available on `infoLogger` and its instances, not on `loggerPrototype`.\n6.  Create another `errorLogger` object using `Object.create()` from `loggerPrototype`.\n7.  Add a specific method `error(message)` to `errorLogger` that prints `[ERROR] message` to the console.\n\nYour solution should demonstrate how objects can inherit from a shared prototype and also define their own unique methods.\n",
          "difficulty": "medium",
          "startingCode": "const loggerPrototype = {\n  // TODO: Implement log and warn methods\n};\n\n// TODO: Create infoLogger and add info method\n\n// TODO: Create errorLogger and add error method\n\n// Example Usage:\n// infoLogger.log('This is a log message.');\n// infoLogger.warn('This is a warning!');\n// infoLogger.info('This is an info message.');\n// // errorLogger.info('Should not work'); // This should throw an error or be undefined\n\n// errorLogger.log('Another log.');\n// errorLogger.error('Critical error!');\n",
          "solutionCode": "const loggerPrototype = {\n  log: function(message) {\n    console.log(`[LOG] ${message}`);\n  },\n  warn: function(message) {\n    console.warn(`[WARN] ${message}`);\n  }\n};\n\nconst infoLogger = Object.create(loggerPrototype);\ninfoLogger.info = function(message) {\n  console.info(`[INFO] ${message}`);\n};\n\nconst errorLogger = Object.create(loggerPrototype);\nerrorLogger.error = function(message) {\n  console.error(`[ERROR] ${message}`);\n};\n",
          "testCases": [
            "`infoLogger.log('test')` should output `[LOG] test`.",
            "`infoLogger.warn('test')` should output `[WARN] test`.",
            "`infoLogger.info('test')` should output `[INFO] test`.",
            "`errorLogger.log('test')` should output `[LOG] test`.",
            "`errorLogger.warn('test')` should output `[WARN] test`.",
            "`errorLogger.error('test')` should output `[ERROR] test`.",
            "`Object.getPrototypeOf(infoLogger)` should be `loggerPrototype`.",
            "`Object.getPrototypeOf(errorLogger)` should be `loggerPrototype`.",
            "`infoLogger.hasOwnProperty('info')` should be `true`.",
            "`infoLogger.hasOwnProperty('log')` should be `false`.",
            "`errorLogger.hasOwnProperty('error')` should be `true`.",
            "`errorLogger.hasOwnProperty('log')` should be `false`.",
            "`infoLogger.error` should be `undefined`.",
            "`errorLogger.info` should be `undefined`."
          ],
          "hints": [
            "Remember that `Object.create(proto)` sets the `[[Prototype]]` of the new object to `proto`.",
            "Methods added directly to `infoLogger` or `errorLogger` will be 'own' properties of those objects, not shared via the prototype.",
            "Use `Object.getPrototypeOf()` to verify the prototype chain."
          ],
          "tags": [
            "JavaScript",
            "Prototypes",
            "Object.create",
            "Inheritance",
            "OOP"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "object_composition",
            "factory_functions"
          ]
        },
        {
          "id": "task_prototypal_inheritance_2",
          "title": "Migrate Constructor Function to `Object.create` Pattern",
          "description": "\nYou are given a set of objects and a constructor function using the traditional prototypal inheritance pattern. Your task is to refactor this setup to use the `Object.create()` pattern, demonstrating a clearer delegation model.\n\n**Given:**\n```javascript\nfunction Character(name, health) {\n  this.name = name;\n  this.health = health;\n}\n\nCharacter.prototype.attack = function(target) {\n  console.log(`${this.name} attacks ${target.name} for 10 damage.`);\n  target.health -= 10;\n};\n\nCharacter.prototype.takeDamage = function(amount) {\n  this.health -= amount;\n  console.log(`${this.name} takes ${amount} damage. Health: ${this.health}`);\n};\n```\n\n**Requirements:**\n1.  Create a `characterPrototype` object that contains the `attack` and `takeDamage` methods. This will be the base prototype for all character objects.\n2.  Create a `createCharacter(name, health)` factory function.\n    *   This function should use `Object.create(characterPrototype)` to create a new character object.\n    *   It should then initialize the `name` and `health` properties directly on the new character object (not on the prototype).\n    *   It should return the newly created and initialized character object.\n3.  Test your new factory function by creating a few character instances and demonstrating their methods.\n\nThis task highlights the flexibility of prototypal inheritance and moves away from the `new` keyword and constructor functions for object creation, favoring a more direct prototype delegation approach.\n",
          "difficulty": "medium",
          "startingCode": "// Original (for context, do not modify):\n// function Character(name, health) {\n//   this.name = name;\n//   this.health = health;\n// }\n//\n// Character.prototype.attack = function(target) {\n//   console.log(`${this.name} attacks ${target.name} for 10 damage.`);\n//   target.health -= 10;\n// };\n//\n// Character.prototype.takeDamage = function(amount) {\n//   this.health -= amount;\n//   console.log(`${this.name} takes ${amount} damage. Health: ${this.health}`);\n// };\n\n// TODO: Implement characterPrototype\nconst characterPrototype = {\n  // ... methods here\n};\n\n// TODO: Implement createCharacter factory function\nfunction createCharacter(name, health) {\n  // ... implementation here\n}\n\n// Example Usage:\n// const hero = createCharacter('Hero', 100);\n// const villain = createCharacter('Villain', 80);\n// hero.attack(villain); // Hero attacks Villain for 10 damage.\n//                       // Villain takes 10 damage. Health: 70\n// villain.takeDamage(5); // Villain takes 5 damage. Health: 65\n// console.log(hero.health); // 100\n",
          "solutionCode": "const characterPrototype = {\n  attack: function(target) {\n    console.log(`${this.name} attacks ${target.name} for 10 damage.`);\n    target.health -= 10;\n  },\n  takeDamage: function(amount) {\n    this.health -= amount;\n    console.log(`${this.name} takes ${amount} damage. Health: ${this.health}`);\n  }\n};\n\nfunction createCharacter(name, health) {\n  const character = Object.create(characterPrototype);\n  character.name = name;\n  character.health = health;\n  return character;\n}\n",
          "testCases": [
            "Create two characters: `hero = createCharacter('Hero', 100);` `villain = createCharacter('Villain', 80);`",
            "`hero.name` should be 'Hero', `hero.health` should be 100.",
            "`villain.name` should be 'Villain', `villain.health` should be 80.",
            "`hero.attack(villain)` should correctly decrease `villain.health` by 10 and log messages.",
            "`villain.takeDamage(5)` should correctly decrease `villain.health` by 5 and log messages.",
            "`hero.hasOwnProperty('attack')` should be `false` (method on prototype).",
            "`hero.hasOwnProperty('name')` should be `true` (property on instance).",
            "`Object.getPrototypeOf(hero)` should be `characterPrototype`.",
            "Check if methods are shared: `hero.attack === villain.attack` should be `true`."
          ],
          "hints": [
            "`Object.create()` creates an empty object whose prototype is the object passed as the argument.",
            "Properties like `name` and `health` that vary per instance should be assigned directly to the new object returned by `Object.create()`, not to the `characterPrototype`."
          ],
          "tags": [
            "JavaScript",
            "Prototypes",
            "Object.create",
            "Factory Functions",
            "Inheritance Refactoring"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "factory_pattern",
            "functional_programming_with_objects"
          ]
        },
        {
          "id": "task_class_inheritance_1",
          "title": "Build a Hierarchical Notification System with ES6 Classes",
          "description": "\nImplement a notification system using ES6 class inheritance. You will create a base `Notification` class and extend it to create more specific types of notifications.\n\n**Requirements:**\n1.  **`Notification` Base Class:**\n    *   Constructor takes `message` (string) and optional `timestamp` (Date, default to `new Date()`).\n    *   Method `display()`: Logs the message and timestamp to the console. E.g., `[2023-10-27 10:30:00] Message: Hello World`.\n    *   Method `getMessage()`: Returns the notification message.\n\n2.  **`UrgentNotification` Subclass:**\n    *   Extends `Notification`.\n    *   Constructor takes `message`, `priority` (number, default 5), and optional `timestamp`.\n    *   Overrides `display()`: Logs `[URGENT] [Priority: X] [TIMESTAMP] Message: Y`. Ensure it uses the parent's `timestamp` and `message`.\n\n3.  **`ErrorNotification` Subclass:**\n    *   Extends `Notification`.\n    *   Constructor takes `message`, `errorCode` (string, default 'UNKNOWN'), and optional `timestamp`.\n    *   Overrides `display()`: Logs `[ERROR] [Code: Z] [TIMESTAMP] Message: Y`. Ensure it uses the parent's `timestamp` and `message`.\n    *   Method `getErrorCode()`: Returns the error code.\n\nYour solution should demonstrate proper use of `extends`, `super()`, and method overriding.\n",
          "difficulty": "medium",
          "startingCode": "class Notification {\n  constructor(message, timestamp = new Date()) {\n    // TODO: Initialize message and timestamp\n  }\n\n  display() {\n    // TODO: Implement generic display\n  }\n\n  getMessage() {\n    // TODO: Return message\n  }\n}\n\nclass UrgentNotification extends Notification {\n  constructor(message, priority = 5, timestamp) {\n    // TODO: Call super and initialize priority\n  }\n\n  display() {\n    // TODO: Override display to include priority\n  }\n}\n\nclass ErrorNotification extends Notification {\n  constructor(message, errorCode = 'UNKNOWN', timestamp) {\n    // TODO: Call super and initialize errorCode\n  }\n\n  display() {\n    // TODO: Override display to include error code\n  }\n\n  getErrorCode() {\n    // TODO: Return error code\n  }\n}\n\n// Example Usage:\n// const notif1 = new Notification('Your order has been placed.');\n// notif1.display();\n\n// const urgentNotif = new UrgentNotification('Server going down!', 10);\n// urgentNotif.display();\n\n// const errorNotif = new ErrorNotification('Failed to fetch data.', 'HTTP_500');\n// errorNotif.display();\n// console.log(errorNotif.getErrorCode());\n\n// console.log(urgentNotif instanceof Notification); // true\n// console.log(errorNotif instanceof Notification); // true\n",
          "solutionCode": "class Notification {\n  constructor(message, timestamp = new Date()) {\n    this.message = message;\n    this.timestamp = timestamp;\n  }\n\n  display() {\n    const formattedTime = this.timestamp.toISOString().replace(/T/, ' ').replace(/\\..+/, '');\n    console.log(`[${formattedTime}] Message: ${this.message}`);\n  }\n\n  getMessage() {\n    return this.message;\n  }\n}\n\nclass UrgentNotification extends Notification {\n  constructor(message, priority = 5, timestamp) {\n    super(message, timestamp);\n    this.priority = priority;\n  }\n\n  display() {\n    const formattedTime = this.timestamp.toISOString().replace(/T/, ' ').replace(/\\..+/, '');\n    console.log(`[URGENT] [Priority: ${this.priority}] [${formattedTime}] Message: ${this.message}`);\n  }\n}\n\nclass ErrorNotification extends Notification {\n  constructor(message, errorCode = 'UNKNOWN', timestamp) {\n    super(message, timestamp);\n    this.errorCode = errorCode;\n  }\n\n  display() {\n    const formattedTime = this.timestamp.toISOString().replace(/T/, ' ').replace(/\\..+/, '');\n    console.log(`[ERROR] [Code: ${this.errorCode}] [${formattedTime}] Message: ${this.message}`);\n  }\n\n  getErrorCode() {\n    return this.errorCode;\n  }\n}\n",
          "testCases": [
            "`Notification` instance: `display()` method output matches format.",
            "`UrgentNotification` instance: `display()` method output includes priority and correct timestamp/message from superclass.",
            "`ErrorNotification` instance: `display()` method output includes error code and correct timestamp/message from superclass.",
            "`ErrorNotification` instance: `getErrorCode()` returns correct code.",
            "Check `instanceof` relationships: `urgentNotif instanceof Notification` should be `true`, `errorNotif instanceof Notification` should be `true`.",
            "Default values for `timestamp`, `priority`, `errorCode` are correctly applied when not provided.",
            "Calling `getMessage()` on subclasses returns the correct message."
          ],
          "hints": [
            "Remember to call `super()` in subclass constructors before accessing `this`.",
            "To format the `Date` object for display, consider `toISOString()` and string manipulation.",
            "When overriding `display()`, you'll likely want to re-calculate the timestamp string for consistency, or extract that logic to a shared helper.",
            "The `message` and `timestamp` are managed by the parent `Notification` class, so ensure you pass them correctly to `super()`."
          ],
          "tags": [
            "ES6 Classes",
            "Inheritance",
            "OOP",
            "Method Overriding",
            "System Design"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_class_inheritance"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "polymorphism",
            "data_encapsulation"
          ]
        },
        {
          "id": "task_object_descriptors_1",
          "title": "Create a Protected Configuration Object",
          "description": "\nYour task is to create a configuration object for a web application that has certain properties that should not be accidentally modified or enumerated. You will use `Object.defineProperty()` to achieve this.\n\n**Requirements:**\n1.  Create an empty object named `appConfig`.\n2.  Define a property `version` on `appConfig`:\n    *   Value: `'1.0.0'`\n    *   Should be **read-only** (`writable: false`).\n    *   Should be **non-enumerable** (`enumerable: false`).\n    *   Should be **non-configurable** (`configurable: false`).\n3.  Define a property `apiEndpoint` on `appConfig`:\n    *   Value: `'https://api.example.com'`\n    *   Should be **writable** (`writable: true`).\n    *   Should be **enumerable** (`enumerable: true`).\n    *   Should be **configurable** (`configurable: true`).\n4.  Define an **accessor property** `lastAccessed` on `appConfig`:\n    *   It should internally store the last access timestamp (e.g., `_lastAccessed`).\n    *   The `get` method should return the stored timestamp and *update the internal timestamp to the current time* every time it's accessed.\n    *   The `set` method should only allow setting a new timestamp if it's a valid `Date` object and greater than the current `_lastAccessed`.\n    *   Should be **enumerable** (`enumerable: true`).\n    *   Should be **non-configurable** (`configurable: false`).\n\n**Testing Scenarios:**\n*   Attempt to change `version` and observe if it fails.\n*   Check if `version` appears in `for...in` loops or `Object.keys()`.\n*   Attempt to delete `version` and observe if it fails.\n*   Change `apiEndpoint` and verify the change.\n*   Access `lastAccessed` multiple times and verify its value updates and if `_lastAccessed` is hidden from enumeration.\n*   Attempt to set `lastAccessed` with an invalid date or an older date.\n",
          "difficulty": "hard",
          "startingCode": "const appConfig = {};\n\n// TODO: Define 'version' property\n\n// TODO: Define 'apiEndpoint' property\n\n// TODO: Define 'lastAccessed' accessor property\n\n// Example Usage and Tests:\n// console.log('Initial appConfig:', appConfig);\n\n// // Test version\n// console.log('Version:', appConfig.version);\n// try {\n//   appConfig.version = '2.0.0';\n//   console.log('Attempted to change version to:', appConfig.version);\n// } catch (e) {\n//   console.error('Error changing version:', e.message);\n// }\n// console.log('Version after attempt:', appConfig.version);\n// console.log('Keys:', Object.keys(appConfig));\n// for (let key in appConfig) { console.log('Prop in loop:', key); }\n\n// // Test apiEndpoint\n// console.log('API Endpoint:', appConfig.apiEndpoint);\n// appConfig.apiEndpoint = 'https://newapi.example.com';\n// console.log('New API Endpoint:', appConfig.apiEndpoint);\n\n// // Test lastAccessed\n// console.log('First access:', appConfig.lastAccessed);\n// setTimeout(() => {\n//   console.log('Second access:', appConfig.lastAccessed);\n//   appConfig.lastAccessed = new Date(new Date().getTime() + 100000);\n//   console.log('Set future access:', appConfig.lastAccessed);\n//   appConfig.lastAccessed = new Date(new Date().getTime() - 100000); // Should fail\n//   console.log('Set past access (should not change):', appConfig.lastAccessed);\n// }, 100);\n",
          "solutionCode": "const appConfig = {};\n\n// Internal storage for lastAccessed\nlet _lastAccessedTimestamp = null;\n\n// 1. Define 'version' property\nObject.defineProperty(appConfig, 'version', {\n  value: '1.0.0',\n  writable: false,      // Read-only\n  enumerable: false,    // Hidden from enumeration\n  configurable: false   // Cannot be deleted or reconfigured\n});\n\n// 2. Define 'apiEndpoint' property\nObject.defineProperty(appConfig, 'apiEndpoint', {\n  value: 'https://api.example.com',\n  writable: true,       // Writable\n  enumerable: true,     // Enumerable\n  configurable: true    // Configurable\n});\n\n// 3. Define 'lastAccessed' accessor property\nObject.defineProperty(appConfig, 'lastAccessed', {\n  get: function() {\n    // Update timestamp on read\n    _lastAccessedTimestamp = new Date(); \n    return _lastAccessedTimestamp;\n  },\n  set: function(newTimestamp) {\n    if (newTimestamp instanceof Date && (_lastAccessedTimestamp === null || newTimestamp.getTime() > _lastAccessedTimestamp.getTime())) {\n      _lastAccessedTimestamp = newTimestamp;\n      console.log('lastAccessed updated to:', _lastAccessedTimestamp.toISOString());\n    } else {\n      console.warn('Attempted to set invalid or older lastAccessed timestamp.');\n    }\n  },\n  enumerable: true,      // Enumerable\n  configurable: false    // Non-configurable\n});\n",
          "testCases": [
            "`appConfig.version` should be '1.0.0'.",
            "Attempting `appConfig.version = '2.0.0'` should not change `appConfig.version` (remains '1.0.0'). In strict mode, it should throw `TypeError`.",
            "`Object.keys(appConfig)` should not include `version`.",
            "`for...in` loop on `appConfig` should not include `version`.",
            "Attempting `delete appConfig.version` should not delete `version`. In strict mode, it should throw `TypeError`.",
            "`appConfig.apiEndpoint` should be initially 'https://api.example.com'.",
            "`appConfig.apiEndpoint = 'new.com'` should successfully change its value.",
            "`Object.keys(appConfig)` should include `apiEndpoint`.",
            "Accessing `appConfig.lastAccessed` multiple times should show an increasing timestamp value.",
            "`Object.keys(appConfig)` should include `lastAccessed`.",
            "`_lastAccessedTimestamp` variable should not be directly accessible on `appConfig`.",
            "Attempting `appConfig.lastAccessed = new Date(oldDate)` (where `oldDate` is older than current `_lastAccessedTimestamp`) should not change `lastAccessed`.",
            "Attempting `appConfig.lastAccessed = 'invalid'` should not change `lastAccessed`."
          ],
          "hints": [
            "Remember the default values for attributes when using `Object.defineProperty()` (they are all `false` unless explicitly set to `true`).",
            "For the `lastAccessed` accessor, you'll need an external variable (closure) to store the actual timestamp, as accessor properties don't have a `value` attribute.",
            "The `Date` object's `getTime()` method can be useful for comparing timestamps.",
            "Consider strict mode behavior when testing `writable: false` and `configurable: false` properties."
          ],
          "tags": [
            "JavaScript",
            "Objects",
            "Object.defineProperty",
            "Getters Setters",
            "Property Attributes",
            "Advanced JavaScript"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "theory_object_descriptors_attributes"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "relatedConcepts": [
            "data_encapsulation",
            "closure",
            "module_pattern"
          ]
        },
        {
          "id": "task_this_keyword_1",
          "title": "Fix `this` Context in a Counter Object",
          "description": "\nYou are given a `Counter` object that attempts to increment a count at regular intervals but has issues with the `this` context. Your task is to fix the `this` binding using different methods.\n\n**Given:**\n```javascript\nconst counter = {\n  count: 0,\n  start: function() {\n    console.log('Counter starting...');\n    setInterval(function() {\n      this.count++; // Problematic 'this'\n      console.log('Current count:', this.count);\n    }, 1000);\n  }\n};\n```\n\n**Requirements:**\n1.  **Solution A (Arrow Function):** Modify the `start` method to use an arrow function for the `setInterval` callback to correctly bind `this` to the `counter` object.\n2.  **Solution B (`.bind()`):** Create a separate version of the `counter` object (`counterBind`) and fix the `start` method's `this` binding using the `.bind()` method.\n3.  **Solution C (Closure/Self):** Create a third version of the `counter` object (`counterClosure`) and fix the `start` method's `this` binding using a variable to capture `this` (e.g., `let self = this;`).\n\n**Constraints:**\n*   Each solution should demonstrate a different valid technique to ensure `this.count` correctly increments.\n*   Do not use ES6 Classes for this specific task; focus on object literals and functions.\n\n**Expected Output (for any solution):**\n```\nCounter starting...\nCurrent count: 1\nCurrent count: 2\nCurrent count: 3\n...\n```\n",
          "difficulty": "medium",
          "startingCode": "console.log('--- Solution A: Arrow Function ---');\nconst counterArrow = {\n  count: 0,\n  start: function() {\n    console.log('Counter starting...');\n    setInterval(function() {\n      // TODO: Fix 'this' using an arrow function\n      this.count++; \n      console.log('Current count:', this.count);\n    }, 1000);\n  }\n};\n// counterArrow.start(); // Uncomment to test\n\nconsole.log('\\n--- Solution B: .bind() ---');\nconst counterBind = {\n  count: 0,\n  start: function() {\n    console.log('Counter starting...');\n    // TODO: Fix 'this' using .bind()\n    setInterval(function() {\n      this.count++;\n      console.log('Current count:', this.count);\n    }, 1000);\n  }\n};\n// counterBind.start(); // Uncomment to test\n\nconsole.log('\\n--- Solution C: Closure/Self ---');\nconst counterClosure = {\n  count: 0,\n  start: function() {\n    console.log('Counter starting...');\n    // TODO: Fix 'this' using a closure (e.g., 'self = this')\n    setInterval(function() {\n      this.count++;\n      console.log('Current count:', this.count);\n    }, 1000);\n  }\n};\n// counterClosure.start(); // Uncomment to test\n",
          "solutionCode": "console.log('--- Solution A: Arrow Function ---');\nconst counterArrow = {\n  count: 0,\n  start: function() {\n    console.log('Counter starting...');\n    setInterval(() => { // Using arrow function\n      this.count++; \n      console.log('Current count:', this.count);\n    }, 1000);\n  }\n};\n// counterArrow.start(); \n\nconsole.log('\\n--- Solution B: .bind() ---');\nconst counterBind = {\n  count: 0,\n  start: function() {\n    console.log('Counter starting...');\n    setInterval(function() {\n      this.count++;\n      console.log('Current count:', this.count);\n    }.bind(this), 1000); // Using .bind(this)\n  }\n};\n// counterBind.start(); \n\nconsole.log('\\n--- Solution C: Closure/Self ---');\nconst counterClosure = {\n  count: 0,\n  start: function() {\n    console.log('Counter starting...');\n    const self = this; // Capture 'this' in a closure\n    setInterval(function() {\n      self.count++; // Use 'self' instead of 'this'\n      console.log('Current count:', self.count);\n    }, 1000);\n  }\n};\n// counterClosure.start(); \n",
          "testCases": [
            "Run `counterArrow.start()` for 3-5 seconds and verify `Current count:` increments correctly (1, 2, 3...).",
            "Run `counterBind.start()` for 3-5 seconds and verify `Current count:` increments correctly.",
            "Run `counterClosure.start()` for 3-5 seconds and verify `Current count:` increments correctly.",
            "Ensure no `TypeError: Cannot read properties of undefined (reading 'count')` or similar errors occur."
          ],
          "hints": [
            "For Solution A, consider how arrow functions handle `this` lexically.",
            "For Solution B, recall which method on `Function.prototype` returns a *new* function with `this` permanently bound.",
            "For Solution C, think about how variables in an outer scope are accessible in inner functions."
          ],
          "tags": [
            "JavaScript",
            "this",
            "Context",
            "Callbacks",
            "Arrow Functions",
            "Bind",
            "Closure",
            "Frontend Interview"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "theory_this_keyword",
            "javascript_functions",
            "closures"
          ],
          "complexity": 6,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "asynchronous_javascript",
            "setinterval",
            "function_scope"
          ]
        }
      ]
    }
  },
  {
    "id": "46d67387-9346-40d4-8c93-c7a4a333d06e",
    "startLine": 2200,
    "endLine": 2299,
    "processedDate": "2025-06-17T08:15:47.063Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_object_getters_setters",
          "title": "Object Getters and Setters",
          "content": "Getters and setters are special methods defined on objects that provide controlled access to an object's properties. They allow you to define what happens when a property is accessed (getter) or modified (setter).\n\n### Getters (Accessors)\n\nA getter method is executed when you attempt to retrieve the value of a property. It's defined using the `get` keyword before the property name. Getters are useful for:\n\n*   Returning computed values based on other properties.\n*   Formatting data before it's returned.\n*   Adding side effects (though generally not recommended for pure getters).\n\n### Setters (Mutators)\n\nA setter method is executed when you attempt to assign a value to a property. It's defined using the `set` keyword before the property name. Setters are useful for:\n\n*   Validation of input data before assignment.\n*   Transforming data before it's stored.\n*   Updating other properties or triggering side effects when a property changes.\n\n### Syntax\n\nGetters and setters are defined within object literal definitions or class declarations.",
          "examples": [
            {
              "id": "example_getters_setters_1",
              "title": "Basic Getter and Setter Example",
              "code": "const person = {\n  firstName: 'John',\n  lastName: 'Doe',\n\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  },\n\n  set fullName(value) {\n    // The original markdown snippet starts here\n    [this.firstName, this.lastName] = value.split(' ');\n  }\n};\n\nconsole.log(person.fullName); // John Doe\nperson.fullName = 'Jane Smith';\nconsole.log(person.firstName); // Jane\nconsole.log(person.lastName);  // Smith\nconsole.log(person.fullName);  // Jane Smith",
              "explanation": "This example demonstrates a `fullName` property that is accessed via a getter and modified via a setter. When `person.fullName` is read, the `get fullName()` method concatenates `firstName` and `lastName`. When `person.fullName` is assigned a new string, the `set fullName(value)` method splits the string by space and assigns the parts to `firstName` and `lastName` respectively, showcasing how setters can deconstruct and update underlying properties.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_getters_setters_1",
            "question_getters_setters_2",
            "question_getters_setters_3",
            "question_getters_setters_4"
          ],
          "relatedTasks": [
            "task_object_getters_setters_1"
          ],
          "tags": [
            "objects",
            "properties",
            "getters",
            "setters",
            "javascript_basics"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_objects",
            "functions"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_state_management",
            "vue_reactivity",
            "data_encapsulation"
          ]
        },
        {
          "id": "theory_equality_comparison",
          "title": "Equality and Comparison in JavaScript",
          "content": "JavaScript provides two primary operators for checking equality: the loose equality operator (`==`) and the strict equality operator (`===`). Understanding the difference between them, especially concerning type coercion and object comparison, is crucial.\n\n### Loose Equality (`==`)\n\nThe loose equality operator `==` compares two values for equality *after* converting them to a common type (type coercion). This can lead to unexpected results because values that appear different might evaluate to `true` after coercion.\n\nCommon coercion rules include:\n*   Numbers and numeric strings: Strings are converted to numbers.\n*   Booleans and non-booleans: Non-booleans are converted to booleans.\n*   `null` and `undefined`: Considered equal to each other.\n\n### Strict Equality (`===`)\n\nThe strict equality operator `===` compares two values for equality *without* performing any type conversion. If the values have different types, they are considered unequal. This operator is generally recommended for most comparisons as it prevents unexpected coercions.\n\n### Object Equality\n\nObjects in JavaScript (including arrays and functions) are compared by *reference*, not by *value*. This means two distinct objects, even if they have the same properties and values, will not be considered equal by either `==` or `===` unless they refer to the exact same object in memory.\n\nTo compare object *values*, you typically need to iterate through their properties or use methods like `JSON.stringify()` (with caveats) or deep comparison libraries.",
          "examples": [
            {
              "id": "example_equality_comparison_1",
              "title": "Loose vs. Strict Equality Examples",
              "code": "// == checks for equality with type conversion\n1 == '1';      // true (string '1' coerced to number 1)\n0 == false;    // true (false coerced to 0)\nnull == undefined; // true (special rule for null and undefined)\n\n// === checks for equality without type conversion (strict equality)\n1 === '1';      // false (number vs string, no coercion)\n0 === false;    // false (number vs boolean)\nnull === undefined; // false (different types)",
              "explanation": "These examples highlight the fundamental difference. `==` attempts to make types compatible, leading to `true` in the first three cases. `===` requires both value and type to be identical, resulting in `false` for the same comparisons.",
              "language": "javascript"
            },
            {
              "id": "example_equality_comparison_2",
              "title": "Object Reference Comparison",
              "code": "// Object equality - objects are compared by reference, not value\nconst obj1 = { a: 1 };\nconst obj2 = { a: 1 };\nconst obj3 = obj1;\n\nobj1 == obj2;  // false (different objects in memory)\nobj1 === obj2; // false (different objects in memory)\nobj1 == obj3;  // true (same object reference)\nobj1 === obj3; // true (same object reference)\n\n// Comparing object values (workaround, not recommended for complex objects)\nJSON.stringify(obj1) === JSON.stringify(obj2); // true (based on string representation)",
              "explanation": "This example clearly shows that `obj1` and `obj2`, despite having identical content, are distinct objects in memory, hence `==` and `===` return `false`. `obj3` points to the same memory location as `obj1`, so they are considered strictly equal. `JSON.stringify` provides a way to compare the *serialized* values, but it's limited for objects with `undefined`, `Symbol`, or functions, and doesn't handle property order.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_equality_1",
            "question_equality_2",
            "question_equality_3",
            "question_equality_4",
            "question_equality_5",
            "question_equality_6"
          ],
          "relatedTasks": [
            "task_equality_1"
          ],
          "tags": [
            "equality",
            "comparison",
            "type_coercion",
            "strict_equality",
            "loose_equality",
            "javascript_basics"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_datatypes",
            "operators"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "beginner",
          "requiredFor": [
            "conditional_logic",
            "debugging",
            "data_comparison"
          ]
        },
        {
          "id": "theory_strict_vs_loose_equality_deep_dive",
          "title": "Strict vs. Loose Equality: A Deeper Dive",
          "content": "The `==` operator performs type coercion before comparison, meaning it attempts to convert the operands to the same type before checking their values. In contrast, the `===` operator performs a strict comparison, meaning it will return `true` only if both the value and the type of the operands are identical. The `===` operator is almost always preferred to avoid unexpected behavior due to implicit type conversions.\n\n### Common Coercion Scenarios with `==`\n\n*   **`undefined` and `null`**: `null == undefined` is `true`. They are special cases in the specification.\n*   **Boolean conversion**: `0`, `''` (empty string), `null`, `undefined`, `NaN` are all 'falsy' values. When compared with `false` using `==`, they can be coerced to `false`.\n*   **Objects vs Primitives**: Objects are generally converted to primitives for `==` comparison, often by calling their `valueOf()` or `toString()` methods.\n\n### The `Number` Object\n\nWhen `new Number(5)` is used, it creates an *object* wrapper around the primitive number `5`. While this object *represents* the value `5`, it is not the primitive `5` itself. Therefore, when compared strictly (`===`), it will be different from the primitive. However, with loose equality (`==`), the `Number` object might be coerced to its primitive value for comparison.",
          "examples": [
            {
              "id": "example_strict_vs_loose_equality_1",
              "title": "Specific Cases of Strict vs. Loose Equality",
              "code": "let abc = undefined;\nabc == undefined; // true, as undefined == undefined\nabc === undefined; // true - only if abc is strictly undefined\n\nabc = null;\nabc == undefined; // true, as null == undefined\nabc === undefined; // false, as null !== undefined\n\nabc = false;\nabc == false;    // true\nabc === false;   // true, only if abc is strictly false\n\nabc = 0;\nabc == false;    // true (0 is falsy, coerced to false)\nabc === false;   // false (number vs boolean)\n\nabc = '';\nabc == false;    // true (empty string is falsy, coerced to false)\nabc === false;   // false (string vs boolean)\n\nabc = []; // an empty array is a truthy object, but its primitive value can be 0 or '' in some contexts\nabc == false;    // true ([] is coerced to '' (empty string), then '' is coerced to false)\nababc === false;   // false (array object vs boolean)\n\n5 == 5;           // true\n5 === 5;          // true\nnew Number(5) == 5; // true (new Number(5) object is coerced to primitive 5)\nnew Number(5) === 5; // false! (new Number(5) is an object, 5 is a primitive number)",
              "explanation": "This example demonstrates various type coercion behaviors of `==` versus the strictness of `===`. Notice how `null == undefined` is a special case. `0`, `''`, `[]` (after coercion to primitive) are all considered `true` when loosely compared to `false` because they are falsy values. Crucially, `new Number(5)` creates an object, which, despite representing the value 5, is not strictly identical to the primitive 5. This distinction is vital for understanding object wrappers.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_equality_7",
            "question_equality_8",
            "question_equality_9",
            "question_equality_10",
            "question_equality_11"
          ],
          "relatedTasks": [
            "task_strict_loose_equality_1"
          ],
          "tags": [
            "strict_equality",
            "loose_equality",
            "type_coercion",
            "falsy_values",
            "javascript_operators",
            "primitives_objects"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_datatypes",
            "equality_comparison"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "robust_comparisons",
            "avoiding_bugs",
            "understanding_js_quirks"
          ]
        },
        {
          "id": "theory_closures_basics",
          "title": "Closures: Concept and Basics",
          "content": "A closure is a fundamental concept in JavaScript that refers to the combination of a function and the lexical environment within which that function was declared. In simpler terms, a closure gives you access to an outer function's scope from an inner function.\n\n### Lexical Scoping\n\nJavaScript uses *lexical scoping* (also known as static scoping), which means that the scope of variables is determined by where they are *declared* in the source code, not where they are *called*.\n\nWhen an inner function is defined, it 'remembers' the environment it was created in. This environment includes all local variables that were in-scope at the time the closure was created, even if the outer function has already finished executing.\n\n### How Closures Work\n\n1.  **Outer Function Execution**: An outer function is called and completes its execution.\n2.  **Inner Function Creation**: The outer function returns an inner function.\n3.  **Lexical Environment Retention**: Even though the outer function has finished, its local variables (from its lexical environment) are not garbage collected if the returned inner function still references them. The inner function 'closes over' these variables.\n4.  **Access**: The inner function can then access and manipulate these variables from its lexical environment, even much later when it is called.",
          "examples": [
            {
              "id": "example_closures_basics_1",
              "title": "Basic Closure Example: `makeAdder`",
              "code": "// Basic closure example\nfunction makeAdder(x) {\n  // 'x' is part of the lexical environment of the returned function\n  return function(y) {\n    return x + y;\n  };\n}\n\nconst add5 = makeAdder(5);  // 'add5' is a closure. It 'remembers' x = 5.\nconst add10 = makeAdder(10); // 'add10' is another closure. It 'remembers' x = 10.\n\nconsole.log(add5(2));  // 7 (x=5, y=2)\nconsole.log(add10(2)); // 12 (x=10, y=2)",
              "explanation": "In this example, `makeAdder` is the outer function. It takes an argument `x` and returns an anonymous inner function. When `makeAdder(5)` is called, the inner function is created and 'closes over' the value of `x` (which is `5`). This closure is then assigned to `add5`. Even after `makeAdder` finishes executing, `add5` can still access `x`. The same applies to `add10` with its own `x` value of `10`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_closures_1",
            "question_closures_2",
            "question_closures_3",
            "question_closures_4",
            "question_closures_5"
          ],
          "relatedTasks": [
            "task_closures_basic_1"
          ],
          "tags": [
            "closures",
            "lexical_scoping",
            "scope",
            "functions",
            "javascript_fundamentals"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "scope_chains"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "module_patterns",
            "data_privacy",
            "currying",
            "memoization"
          ]
        },
        {
          "id": "theory_practical_closures",
          "title": "Practical Uses of Closures: Data Privacy and Encapsulation",
          "content": "Closures are incredibly powerful for creating private variables and implementing module patterns, offering a way to encapsulate data and methods within a function scope, making them accessible only through specific privileged methods. This is a core concept for achieving data privacy and managing state.\n\n### Data Encapsulation\n\nBy using closures, you can create variables that are 'private' to an outer function's scope. Inner functions returned by the outer function can access and modify these variables, but the variables themselves are not directly accessible from outside the outer function. This effectively creates an encapsulated 'object' where internal state is protected, and interactions are managed through public methods.\n\n### Module Pattern\n\nThe Module Pattern is a widely used design pattern in JavaScript that leverages closures to encapsulate 'private' members (variables, functions) and expose 'public' members through a returned object. This helps avoid polluting the global namespace and promotes modular, organized code.",
          "examples": [
            {
              "id": "example_practical_closures_1",
              "title": "Counter with Private Variable using Closure",
              "code": "function createCounter() {\n  let privateCounter = 0; // This variable is 'private' to createCounter's scope\n  \n  return {\n    increment: function() {\n      privateCounter++; // Can access and modify privateCounter\n    },\n    decrement: function() {\n      privateCounter--; // Can access and modify privateCounter\n    },\n    getValue: function() {\n      return privateCounter; // Can access privateCounter\n    }\n  };\n}\n\nconst counter = createCounter();\ncounter.increment();\ncounter.increment();\nconsole.log(counter.getValue()); // 2\n\n// console.log(counter.privateCounter); // Undefined! privateCounter is not directly accessible",
              "explanation": "This `createCounter` function demonstrates encapsulation. `privateCounter` is a local variable within `createCounter`. The returned object contains three methods (`increment`, `decrement`, `getValue`), all of which form closures over the `privateCounter` variable. This means they can access and modify `privateCounter`, but `privateCounter` itself is not exposed directly to the outside world, effectively making it a private variable. This pattern is fundamental for building robust and maintainable JavaScript modules.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_practical_closures_1",
            "question_practical_closures_2",
            "question_practical_closures_3",
            "question_practical_closures_4"
          ],
          "relatedTasks": [
            "task_closures_advanced_1"
          ],
          "tags": [
            "closures",
            "encapsulation",
            "data_privacy",
            "module_pattern",
            "design_patterns",
            "javascript_advanced"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "closures_basics",
            "object_literals"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "framework_architecture",
            "custom_modules",
            "state_management"
          ]
        },
        {
          "id": "theory_advanced_closure_patterns_conceptual",
          "title": "Advanced Closure Patterns (Conceptual Overview)",
          "content": "While the provided content only lists 'Advanced Closure Patterns' as a heading without specific examples, it's important to understand that closures form the basis for several powerful and common JavaScript programming patterns. These patterns leverage the ability of inner functions to 'remember' and access variables from their outer lexical environment even after the outer function has completed.\n\nCommon advanced closure patterns and their applications include:\n\n*   **Memoization**: Caching the results of expensive function calls to improve performance. A closure can store the cache.\n*   **Currying**: Transforming a function that takes multiple arguments into a sequence of functions, each taking a single argument. Each step in the sequence is a closure.\n*   **Module Pattern (IIFE-based)**: As seen in practical uses, closures are fundamental to creating self-contained modules with private state and public interfaces, preventing global scope pollution. This is a common design pattern for organizing JavaScript code.\n*   **Iterators and Generators**: While modern JavaScript has built-in `Iterator` and `Generator` protocols, the underlying concept of maintaining state across multiple invocations often involves closure-like mechanisms.\n*   **Event Handlers**: When an event listener function is defined within another function, it often forms a closure over variables from its surrounding scope, allowing it to access context-specific data when the event fires.\n*   **Higher-Order Functions**: Functions that return other functions, or take functions as arguments, frequently rely on closures to maintain context and state.",
          "examples": [],
          "relatedQuestions": [
            "question_advanced_closures_1",
            "question_advanced_closures_2"
          ],
          "relatedTasks": [],
          "tags": [
            "closures",
            "advanced_patterns",
            "memoization",
            "currying",
            "module_pattern",
            "design_patterns"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "closures_basics",
            "practical_closures"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "requiredFor": [
            "functional_programming",
            "performance_optimization",
            "complex_system_design"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_getters_setters_1",
          "topic": "Object Getters and Setters",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of a getter in JavaScript?",
          "answer": "To define a method that is executed when a property is accessed (read), often for returning computed values or formatting data.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "getters",
            "object_properties",
            "computed_properties"
          ],
          "evaluationCriteria": [
            "Understanding of basic getter function"
          ],
          "example": "",
          "tags": [
            "getters",
            "objects",
            "javascript_basics"
          ],
          "prerequisites": [
            "javascript_objects"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_getters_setters_2",
          "topic": "Object Getters and Setters",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of a setter in JavaScript?",
          "answer": "To define a method that is executed when a property is assigned a value (written), often for validation or transforming input data.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "setters",
            "object_properties",
            "data_validation"
          ],
          "evaluationCriteria": [
            "Understanding of basic setter function"
          ],
          "example": "",
          "tags": [
            "setters",
            "objects",
            "javascript_basics"
          ],
          "prerequisites": [
            "javascript_objects"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_getters_setters_3",
          "topic": "Object Getters and Setters",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript object:\n\n```javascript\nconst product = {\n  _price: 100,\n  get price() {\n    return this._price;\n  },\n  set price(value) {\n    if (value > 0) {\n      this._price = value;\n    } else {\n      console.log('Price must be positive');\n    }\n  }\n};\n\nproduct.price = -50;\nconsole.log(product.price);\n```\n\nWhat will be logged to the console by the last `console.log` statement?",
          "answer": "100",
          "options": [
            "-50",
            "0",
            "100",
            "undefined"
          ],
          "analysisPoints": [
            "The setter `price` includes a validation check `if (value > 0)`.",
            "When `product.price = -50` is executed, the `set price(value)` method is called.",
            "Since `-50` is not `> 0`, the `if` condition is false, and `this._price` is not updated.",
            "The `else` block logs 'Price must be positive', but this does not change `_price`.",
            "Therefore, `_price` retains its initial value of `100`.",
            "When `console.log(product.price)` is called, the `get price()` method returns the current `_price` which is `100`."
          ],
          "keyConcepts": [
            "getters",
            "setters",
            "data_validation",
            "object_properties"
          ],
          "evaluationCriteria": [
            "Ability to trace execution flow through getter/setter logic.",
            "Understanding of conditional statements within setters.",
            "Knowledge of how internal properties are accessed by getters."
          ],
          "example": "The setter prevents the `_price` from being set to a non-positive value. The `console.log` inside the `else` branch is a side effect of the setter's logic, but the property itself remains unchanged if the validation fails.",
          "tags": [
            "getters",
            "setters",
            "objects",
            "data_validation",
            "mcq"
          ],
          "prerequisites": [
            "javascript_objects",
            "conditional_statements"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_getters_setters_4",
          "topic": "Object Getters and Setters",
          "level": "medium",
          "type": "open",
          "question": "Explain a scenario where using getters and setters would be more beneficial than directly accessing or modifying an object's properties. Provide a brief code example.",
          "answer": "Getters and setters are particularly beneficial when you need to control access to properties, perform validation, or derive property values dynamically. \n\n**Scenario**: Managing a user's age with validation and calculated properties.\n\n**Benefit**: \n1.  **Validation**: A setter for `age` can ensure that only valid numeric and positive values are assigned, preventing invalid data from entering the object's state.\n2.  **Computed Properties**: A getter for `isAdult` can automatically calculate whether a user is an adult based on their `age` without needing to store this as a separate, potentially desynchronized, property.\n3.  **Encapsulation**: It allows the internal representation of data (e.g., storing `birthYear` instead of `age`) to be abstracted away from the public interface.\n\n**Code Example**:\n```javascript\nconst user = {\n  _age: null, // Internal property\n\n  set age(value) {\n    if (typeof value === 'number' && value >= 0 && value <= 120) {\n      this._age = value;\n      console.log(`Age set to ${value}`);\n    } else {\n      console.error('Invalid age value. Age must be a number between 0 and 120.');\n    }\n  },\n\n  get age() {\n    return this._age;\n  },\n\n  get isAdult() {\n    return this._age >= 18;\n  }\n};\n\nuser.age = 25;       // Age set to 25\nconsole.log(user.isAdult); // true\nuser.age = 5;        // Age set to 5\nconsole.log(user.isAdult); // false\nuser.age = 150;      // Invalid age value. Age must be a number between 0 and 120.\nconsole.log(user.age);     // 5 (age remains unchanged due to validation failure)\n```\nIn this example, the `age` setter validates input, and the `isAdult` getter computes a value on the fly, demonstrating controlled access and derived properties.",
          "options": [],
          "analysisPoints": [
            "Demonstrates understanding of validation and computed properties.",
            "Provides a clear and concise code example.",
            "Articulates the 'why' behind using getters/setters effectively."
          ],
          "keyConcepts": [
            "getters",
            "setters",
            "data_validation",
            "computed_properties",
            "encapsulation",
            "data_integrity"
          ],
          "evaluationCriteria": [
            "Clarity of explanation and example.",
            "Identification of relevant benefits.",
            "Correct implementation of getter/setter logic."
          ],
          "example": "```javascript\nconst user = {\n  _age: null,\n  set age(value) {\n    if (typeof value === 'number' && value >= 0 && value <= 120) {\n      this._age = value;\n    } else {\n      console.error('Invalid age value.');\n    }\n  },\n  get age() {\n    return this._age;\n  },\n  get isAdult() {\n    return this._age >= 18;\n  }\n};\nuser.age = 25;\nconsole.log(user.isAdult);\nuser.age = 150;\nconsole.log(user.age);\n```",
          "tags": [
            "getters",
            "setters",
            "open-ended",
            "design_patterns",
            "data_modeling"
          ],
          "prerequisites": [
            "javascript_objects",
            "functions"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_equality_1",
          "topic": "Equality and Comparison in JavaScript",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main difference between `==` and `===` operators?",
          "answer": "`==` performs type coercion before comparison, while `===` checks for both value and type without coercion.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "loose_equality",
            "strict_equality",
            "type_coercion"
          ],
          "evaluationCriteria": [
            "Ability to recall the fundamental difference."
          ],
          "example": "",
          "tags": [
            "equality",
            "operators",
            "javascript_basics"
          ],
          "prerequisites": [
            "javascript_datatypes"
          ],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_equality_2",
          "topic": "Equality and Comparison in JavaScript",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following expressions evaluates to `true`?\n\n```javascript\n// Option A\n'5' === 5;\n\n// Option B\nnull === undefined;\n\n// Option C\n0 == false;\n\n// Option D\n[1,2] == [1,2];\n```",
          "answer": "0 == false;",
          "options": [
            "'5' === 5;",
            "null === undefined;",
            "0 == false;",
            "[1,2] == [1,2];"
          ],
          "analysisPoints": [
            "Option A: `'5' === 5` is `false` because `===` checks types; string is not number.",
            "Option B: `null === undefined` is `false` because `===` checks types; `null` and `undefined` are different types.",
            "Option C: `0 == false` is `true` because `==` performs type coercion; `false` is coerced to `0`.",
            "Option D: `[1,2] == [1,2]` is `false` because objects (arrays) are compared by reference, and these are two distinct array objects."
          ],
          "keyConcepts": [
            "loose_equality",
            "strict_equality",
            "type_coercion",
            "object_equality"
          ],
          "evaluationCriteria": [
            "Understanding of type coercion with `==`.",
            "Understanding of strict equality with `===`.",
            "Knowledge of object reference comparison."
          ],
          "example": "The correct option `0 == false` is `true` because JavaScript's `==` operator will coerce `false` to `0` (a falsy value), making the comparison `0 == 0`, which is `true`.",
          "tags": [
            "equality",
            "comparison",
            "type_coercion",
            "mcq"
          ],
          "prerequisites": [
            "equality_comparison"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_equality_3",
          "topic": "Equality and Comparison in JavaScript",
          "level": "medium",
          "type": "open",
          "question": "Why do `obj1 == obj2` and `obj1 === obj2` both evaluate to `false` when `obj1 = { a: 1 };` and `obj2 = { a: 1 };`? How can you check if two objects have the same *values*?",
          "answer": "Both `obj1 == obj2` and `obj1 === obj2` evaluate to `false` because in JavaScript, objects are compared by *reference*, not by *value*. When you create `obj1` and `obj2` using object literals (`{}`), you are creating two distinct objects in memory, even if they have identical properties and values. Neither `==` nor `===` will check the content of the objects, only if they point to the exact same location in memory.\n\nTo check if two objects have the same *values* (i.e., deep equality), you typically need to implement a deep comparison logic or use a library that provides such functionality. A common, but **limited**, workaround for simple objects is to serialize them to JSON strings and compare the strings:\n\n```javascript\nconst obj1 = { a: 1, b: 'hello' };\nconst obj2 = { a: 1, b: 'hello' };\n\n// This is true for simple objects with consistent key order\nconsole.log(JSON.stringify(obj1) === JSON.stringify(obj2)); // true\n\n// Limitations: does not handle functions, undefined, Symbols, or different property order\nconst obj3 = { a: 1, func: () => {} };\nconst obj4 = { a: 1, func: () => {} };\nconsole.log(JSON.stringify(obj3) === JSON.stringify(obj4)); // false, because functions are stripped\n\nconst obj5 = { a: 1, b: 2 };\nconst obj6 = { b: 2, a: 1 };\n// This will be false if property order is not guaranteed by stringify\nconsole.log(JSON.stringify(obj5) === JSON.stringify(obj6)); // Might be false depending on engine's stringify order\n```\n\nFor robust deep comparison, one would need to write a recursive function that iterates through properties, checks their types, and compares their values, including nested objects and arrays. Libraries like Lodash's `isEqual` provide this functionality.",
          "options": [],
          "analysisPoints": [
            "Explains object comparison by reference.",
            "Highlights the limitation of `==` and `===` for value comparison.",
            "Suggests `JSON.stringify` as a workaround with caveats.",
            "Mentions the need for deep comparison logic for robust value checking."
          ],
          "keyConcepts": [
            "object_equality",
            "reference_comparison",
            "value_comparison",
            "deep_equality",
            "JSON.stringify"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation for reference vs. value.",
            "Identification of `JSON.stringify` workaround and its limitations.",
            "Understanding of the need for deep comparison."
          ],
          "example": "```javascript\nconst obj1 = { a: 1 };\nconst obj2 = { a: 1 };\nconst obj3 = obj1;\n\nconsole.log(obj1 === obj2); // false\nconsole.log(obj1 === obj3); // true\n\nconsole.log(JSON.stringify(obj1) === JSON.stringify(obj2)); // true (limited)\n```",
          "tags": [
            "equality",
            "objects",
            "reference_vs_value",
            "deep_comparison",
            "open-ended"
          ],
          "prerequisites": [
            "object_equality",
            "javascript_objects"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_equality_4",
          "topic": "Equality and Comparison in JavaScript",
          "level": "medium",
          "type": "code",
          "question": "Implement a function `areArraysEqual` that strictly compares two arrays for element-by-element equality. The function should return `true` if both arrays have the same length and all elements at corresponding positions are strictly equal (`===`), and `false` otherwise. Do not use `JSON.stringify`.",
          "answer": "```javascript\nfunction areArraysEqual(arr1, arr2) {\n  if (!Array.isArray(arr1) || !Array.isArray(arr2)) {\n    // Handle non-array inputs if necessary, or throw an error\n    return false;\n  }\n\n  if (arr1.length !== arr2.length) {\n    return false; // Arrays must have the same length\n  }\n\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false; // Elements at corresponding positions must be strictly equal\n    }\n  }\n\n  return true; // All checks passed\n}\n\n// Test cases:\nconsole.log(areArraysEqual([1, 2, 3], [1, 2, 3]));          // true\nconsole.log(areArraysEqual([1, 2, '3'], [1, 2, 3]));        // false (type mismatch for '3' vs 3)\nconsole.log(areArraysEqual([1, 2], [1, 2, 3]));             // false (different lengths)\nconsole.log(areArraysEqual([], []));                       // true\nconsole.log(areArraysEqual([null, undefined], [null, undefined])); // true\nconsole.log(areArraysEqual([NaN], [NaN]));                   // false (NaN !== NaN)\nconsole.log(areArraysEqual([1, {a:1}], [1, {a:1}]));         // false (objects by reference)\nconsole.log(areArraysEqual([1, 'a', true], [1, 'a', true])); // true\n```",
          "options": [],
          "analysisPoints": [
            "Checks for array type first (optional, but good practice).",
            "Compares lengths as the first and most efficient check.",
            "Iterates through elements, using `!==` for strict inequality.",
            "Handles edge cases like empty arrays and `NaN` (though `NaN !== NaN` is a specific JS quirk).",
            "Does not attempt deep comparison for nested objects/arrays (as per strict `===` requirement for elements)."
          ],
          "keyConcepts": [
            "array_comparison",
            "strict_equality",
            "iteration",
            "edge_cases"
          ],
          "evaluationCriteria": [
            "Correct implementation of array length check.",
            "Correct use of `===` for element comparison.",
            "Handling of empty arrays.",
            "Efficiency (early exit on mismatch)."
          ],
          "example": "```javascript\nfunction areArraysEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n```",
          "tags": [
            "code_challenge",
            "arrays",
            "equality",
            "algorithms"
          ],
          "prerequisites": [
            "arrays",
            "strict_equality",
            "loops"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_equality_5",
          "topic": "Equality and Comparison in JavaScript",
          "level": "hard",
          "type": "mcq",
          "question": "What is the result of the following comparison in JavaScript?\n\n```javascript\n[] == ![];\n```",
          "answer": "true",
          "options": [
            "true",
            "false",
            "TypeError",
            "undefined"
          ],
          "analysisPoints": [
            "**Step 1: Evaluate `![]`**\n    *   The `!` (logical NOT) operator converts its operand to a boolean. Any object, including an empty array `[]`, is considered 'truthy'.\n    *   So, `![]` evaluates to `!true`, which is `false`.\n*   **Step 2: Evaluate `[] == false`**\n    *   This is a loose equality comparison.\n    *   The spec says that if one operand is an object and the other is a primitive, the object is converted to a primitive.\n    *   `[]`'s `toString()` method returns `''` (empty string).\n    *   So the comparison becomes `'' == false`.\n*   **Step 3: Evaluate `'' == false`**\n    *   Both operands are now primitives. If one is a string and the other is a boolean, both are converted to numbers.\n    *   `''` converts to the number `0`.\n    *   `false` converts to the number `0`.\n    *   So the comparison becomes `0 == 0`, which is `true`."
          ],
          "keyConcepts": [
            "type_coercion",
            "loose_equality",
            "truthy_falsy",
            "object_to_primitive_conversion",
            "logical_operators"
          ],
          "evaluationCriteria": [
            "Understanding of the `!` operator's effect on objects.",
            "Knowledge of how `==` handles arrays when compared to booleans.",
            "Ability to trace multiple steps of type coercion."
          ],
          "example": "This is a classic JavaScript 'quirk' question. The sequence of coercions is crucial:\n1.  `![]` -> `false` (empty array is truthy, so `!truthy` is `false`)\n2.  `[] == false` -> (Array `[]` is converted to primitive string `''`)\n3.  `'' == false` -> (String `''` is converted to number `0`, Boolean `false` is converted to number `0`)\n4.  `0 == 0` -> `true`",
          "tags": [
            "equality",
            "type_coercion",
            "quirks",
            "advanced_js",
            "mcq"
          ],
          "prerequisites": [
            "equality_comparison",
            "strict_vs_loose_equality_deep_dive"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_equality_6",
          "topic": "Equality and Comparison in JavaScript",
          "level": "easy",
          "type": "flashcard",
          "question": "When comparing objects with `==` or `===`, what is actually compared?",
          "answer": "Their references (memory addresses), not their values or content.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "object_equality",
            "reference_comparison"
          ],
          "evaluationCriteria": [
            "Correctly identifying object comparison mechanism."
          ],
          "example": "",
          "tags": [
            "objects",
            "equality",
            "memory"
          ],
          "prerequisites": [
            "object_equality"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_equality_7",
          "topic": "Strict vs Loose Equality Deep Dive",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements is true regarding `null` and `undefined` in JavaScript?\n\n```javascript\n// Option A\nnull === undefined;\n\n// Option B\nnull == undefined;\n\n// Option C\ntypeof null === 'undefined';\n\n// Option D\nnull + undefined === NaN;\n```",
          "answer": "null == undefined;",
          "options": [
            "null === undefined;",
            "null == undefined;",
            "typeof null === 'undefined';",
            "null + undefined === NaN;"
          ],
          "analysisPoints": [
            "Option A: `null === undefined` is `false` because they are of different types, and `===` does not perform type coercion.",
            "Option B: `null == undefined` is `true` because, according to JavaScript's specification, `null` and `undefined` are special cases considered loosely equal to each other.",
            "Option C: `typeof null` returns `'object'`, which is a historical quirk in JavaScript. So, `'object' === 'undefined'` is `false`.",
            "Option D: `null` converts to `0` in numeric contexts, and `undefined` converts to `NaN`. So `0 + NaN` results in `NaN`. Thus, `NaN === NaN` is `false` (NaN is never strictly equal to anything, including itself). The expression `null + undefined` *is* `NaN`, but `NaN === NaN` is `false`. So this statement `null + undefined === NaN` evaluates to `false`."
          ],
          "keyConcepts": [
            "null_undefined",
            "type_coercion",
            "strict_equality",
            "loose_equality",
            "typeof_operator",
            "NaN_comparison"
          ],
          "evaluationCriteria": [
            "Understanding of loose equality rule for `null` and `undefined`.",
            "Knowledge of `typeof null` quirk.",
            "Understanding of `NaN` behavior in comparisons."
          ],
          "example": "The key here is that `null` and `undefined` are *loosely* equal but not *strictly* equal because they are distinct types. The `typeof null` returning 'object' is a well-known JavaScript oddity.",
          "tags": [
            "equality",
            "datatypes",
            "null",
            "undefined",
            "type_coercion",
            "mcq"
          ],
          "prerequisites": [
            "strict_vs_loose_equality_deep_dive"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_equality_8",
          "topic": "Strict vs Loose Equality Deep Dive",
          "level": "hard",
          "type": "open",
          "question": "Why does `new Number(5) === 5` evaluate to `false`, while `new Number(5) == 5` evaluates to `true`? Explain the underlying mechanism.",
          "answer": "`new Number(5) === 5` evaluates to `false` because `new Number(5)` creates an **object wrapper** around the primitive number `5`, whereas `5` is a **primitive number** itself. The strict equality operator (`===`) checks both the value and the *type* (and for objects, the reference). Since one operand is an object (`Number` object) and the other is a primitive (`number`), their types are different, hence the strict comparison returns `false`.\n\n`new Number(5) == 5` evaluates to `true` because the loose equality operator (`==`) performs **type coercion**. When comparing an object with a primitive, JavaScript attempts to convert the object to a primitive value. For `Number` objects, this conversion happens by calling the object's `valueOf()` method. The `valueOf()` method of a `Number` object returns the primitive numeric value it wraps. So, `new Number(5).valueOf()` returns the primitive `5`. The comparison then becomes `5 == 5`, which evaluates to `true`.",
          "options": [],
          "analysisPoints": [
            "Explains the difference between primitive values and object wrappers.",
            "Details how `===` considers type differences for `Number` object vs. primitive.",
            "Explains type coercion for `==`, specifically the `valueOf()` method for objects.",
            "Clearly differentiates between the behavior of `==` and `===` in this specific scenario."
          ],
          "keyConcepts": [
            "primitive_vs_object",
            "object_wrappers",
            "type_coercion",
            "valueOf_method",
            "strict_equality",
            "loose_equality"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation for both `===` and `==`.",
            "Correct understanding of `Number` object and `valueOf()`.",
            "Clarity and completeness of the explanation."
          ],
          "example": "```javascript\nconsole.log(typeof new Number(5)); // object\nconsole.log(typeof 5);           // number\n\nconsole.log(new Number(5) === 5); // false (object !== primitive)\n\nconsole.log(new Number(5).valueOf()); // 5 (primitive value)\nconsole.log(new Number(5) == 5);  // true (object coerced to primitive 5)\n```",
          "tags": [
            "equality",
            "primitives_objects",
            "type_coercion",
            "open-ended",
            "advanced_js"
          ],
          "prerequisites": [
            "strict_vs_loose_equality_deep_dive",
            "javascript_datatypes"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_equality_9",
          "topic": "Strict vs Loose Equality Deep Dive",
          "level": "medium",
          "type": "flashcard",
          "question": "Is `NaN == NaN` true or false?",
          "answer": "False. `NaN` is the only value in JavaScript that is not equal to itself, even with loose or strict equality. You must use `Number.isNaN()` or `isNaN()` to check for `NaN`.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "NaN",
            "equality",
            "Number.isNaN"
          ],
          "evaluationCriteria": [
            "Correctly identifies `NaN` comparison behavior."
          ],
          "example": "",
          "tags": [
            "NaN",
            "equality",
            "javascript_quirks"
          ],
          "prerequisites": [
            "strict_vs_loose_equality_deep_dive"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_equality_10",
          "topic": "Strict vs Loose Equality Deep Dive",
          "level": "medium",
          "type": "mcq",
          "question": "What is the output of the following JavaScript code?\n\n```javascript\nconsole.log([] == 0);\nconsole.log([] == '');\nconsole.log(0 == '');\n```",
          "answer": "true\ntrue\ntrue",
          "options": [
            "true\ntrue\ntrue",
            "false\nfalse\nfalse",
            "true\nfalse\ntrue",
            "false\ntrue\nfalse"
          ],
          "analysisPoints": [
            "**`[] == 0`**:\n    *   `[]` (object) is converted to a primitive. `[].toString()` is `''`.\n    *   So, it becomes `'' == 0`.\n    *   `''` (string) is converted to `0` (number).\n    *   So, it becomes `0 == 0`, which is `true`.\n*   **`[] == ''`**:\n    *   `[]` (object) is converted to a primitive. `[].toString()` is `''`.\n    *   So, it becomes `'' == ''`, which is `true`.\n*   **`0 == ''`**:\n    *   `''` (string) is converted to `0` (number).\n    *   So, it becomes `0 == 0`, which is `true`."
          ],
          "keyConcepts": [
            "type_coercion",
            "loose_equality",
            "object_to_primitive_conversion",
            "falsy_values"
          ],
          "evaluationCriteria": [
            "Understanding of how empty arrays are coerced to primitive strings.",
            "Understanding of how empty strings are coerced to numbers.",
            "Ability to follow chain of type coercions."
          ],
          "example": "These demonstrate common implicit type coercions with the loose equality operator. The empty array `[]` often coerces to an empty string `''` when compared in a loose context, and both `''` and `0` are considered loosely equal to `false` and each other.",
          "tags": [
            "equality",
            "type_coercion",
            "javascript_quirks",
            "mcq"
          ],
          "prerequisites": [
            "strict_vs_loose_equality_deep_dive"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_equality_11",
          "topic": "Strict vs Loose Equality Deep Dive",
          "level": "hard",
          "type": "code",
          "question": "Write a JavaScript function `areStrictlyEqual` that takes two arguments, `a` and `b`, and returns `true` if they are strictly equal (`a === b`), and `false` otherwise. Additionally, include comments explaining why each of the following test cases produces its result.\n\n```javascript\nconsole.log(areStrictlyEqual(5, '5'));        // Expected: false\nconsole.log(areStrictlyEqual(null, undefined)); // Expected: false\nconsole.log(areStrictlyEqual(0, false));      // Expected: false\nconsole.log(areStrictlyEqual(new Number(10), 10)); // Expected: false\nconsole.log(areStrictlyEqual({}, {}));        // Expected: false\nconsole.log(areStrictlyEqual(NaN, NaN));      // Expected: false\nconsole.log(areStrictlyEqual('hello', 'hello')); // Expected: true\nlet obj = { x: 1 };\nconsole.log(areStrictlyEqual(obj, obj));      // Expected: true\n```",
          "answer": "```javascript\nfunction areStrictlyEqual(a, b) {\n  return a === b;\n}\n\n// Test cases with explanations:\n\n// Expected: false\n// Explanation: '5' is a string, 5 is a number. Strict equality checks both value AND type.\nconsole.log(areStrictlyEqual(5, '5'));\n\n// Expected: false\n// Explanation: null and undefined are different types, even though they are loosely equal (null == undefined).\n// Strict equality does not perform type coercion.\nconsole.log(areStrictlyEqual(null, undefined));\n\n// Expected: false\n// Explanation: 0 is a number, false is a boolean. Strict equality checks both value AND type.\nconsole.log(areStrictlyEqual(0, false));\n\n// Expected: false\n// Explanation: new Number(10) creates a Number OBJECT, while 10 is a primitive number.\n// Strict equality checks object references for objects, and types for primitives.\nconsole.log(areStrictlyEqual(new Number(10), 10));\n\n// Expected: false\n// Explanation: {} creates a new, distinct object in memory each time.\n// Strict equality compares object references, and these are two different references.\nconsole.log(areStrictlyEqual({}, {}));\n\n// Expected: false\n// Explanation: NaN is a special numeric value that is never strictly equal to itself, nor any other value.\n// You must use Number.isNaN() or isNaN() to check for NaN.\nconsole.log(areStrictlyEqual(NaN, NaN));\n\n// Expected: true\n// Explanation: Both are primitive strings with the same value and same type.\nconsole.log(areStrictlyEqual('hello', 'hello'));\n\nlet obj = { x: 1 };\n// Expected: true\n// Explanation: Both arguments refer to the exact same object in memory.\n// Strict equality for objects checks if the references are identical.\nconsole.log(areStrictlyEqual(obj, obj));\n```",
          "options": [],
          "analysisPoints": [
            "Correctly implements the `===` operator.",
            "Provides accurate and concise explanations for each test case.",
            "Demonstrates understanding of `===` behavior with different data types, object references, and special values like `null`, `undefined`, and `NaN`."
          ],
          "keyConcepts": [
            "strict_equality",
            "type_coercion",
            "object_reference",
            "NaN",
            "primitive_types",
            "object_wrappers"
          ],
          "evaluationCriteria": [
            "Correctness of the function.",
            "Accuracy and completeness of explanations for test cases.",
            "Demonstrated understanding of `===` nuances."
          ],
          "example": "The task focuses on explaining why `===` behaves the way it does across various data types and scenarios, highlighting that it never performs type coercion and always checks identity for objects.",
          "tags": [
            "code_challenge",
            "equality",
            "strict_equality",
            "javascript_fundamentals"
          ],
          "prerequisites": [
            "strict_vs_loose_equality_deep_dive"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_closures_1",
          "topic": "Closures: Concept and Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a closure in JavaScript?",
          "answer": "A closure is the combination of a function and the lexical environment within which that function was declared, allowing the function to access variables from its outer scope even after the outer function has finished executing.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "closures",
            "lexical_environment",
            "scope"
          ],
          "evaluationCriteria": [
            "Correct definition of closure."
          ],
          "example": "",
          "tags": [
            "closures",
            "javascript_fundamentals"
          ],
          "prerequisites": [
            "javascript_functions",
            "scope_chains"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_closures_2",
          "topic": "Closures: Concept and Basics",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following code:\n\n```javascript\nfunction outer() {\n  let counter = 0;\n  return function inner() {\n    counter++;\n    return counter;\n  };\n}\n\nconst fn1 = outer();\nconst fn2 = outer();\n\nconsole.log(fn1());\nconsole.log(fn1());\nconsole.log(fn2());\n```\n\nWhat will be the output?",
          "answer": "1\n2\n1",
          "options": [
            "1\n2\n3",
            "1\n1\n1",
            "1\n2\n1",
            "Error"
          ],
          "analysisPoints": [
            "Each call to `outer()` creates a *new* lexical environment and a *new* `counter` variable.",
            "`fn1` is a closure that 'remembers' its own `counter` (initialized to 0 when `fn1` was created).",
            "`fn2` is a *separate* closure that 'remembers' its own `counter` (also initialized to 0 when `fn2` was created).",
            "When `fn1()` is called, its `counter` increments to 1, then to 2.",
            "When `fn2()` is called, its *own* `counter` increments to 1, independently of `fn1`'s counter."
          ],
          "keyConcepts": [
            "closures",
            "lexical_scoping",
            "function_scope",
            "independent_closures"
          ],
          "evaluationCriteria": [
            "Understanding that each call to `outer()` creates a new, independent closure.",
            "Ability to trace the state of `counter` for each closure instance."
          ],
          "example": "```javascript\nfunction outer() {\n  let counter = 0;\n  return function inner() {\n    counter++;\n    return counter;\n  };\n}\n\nconst fn1 = outer(); // fn1 has its own 'counter' state\nconst fn2 = outer(); // fn2 has its own 'counter' state, separate from fn1\n\nconsole.log(fn1()); // 1 (fn1's counter becomes 1)\nconsole.log(fn1()); // 2 (fn1's counter becomes 2)\nconsole.log(fn2()); // 1 (fn2's counter becomes 1)\n```",
          "tags": [
            "closures",
            "scope",
            "mcq",
            "state_management"
          ],
          "prerequisites": [
            "closures_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_closures_3",
          "topic": "Closures: Concept and Basics",
          "level": "medium",
          "type": "open",
          "question": "What is 'lexical environment' in the context of closures, and how does it relate to 'lexical scoping'?",
          "answer": "The **lexical environment** is a conceptual structure that holds identifier-variable mappings. It's essentially a record of all local variables, arguments, and other identifiers that are accessible within a particular scope. Each time a function is called, a new lexical environment is created for that invocation.\n\n**Lexical scoping** (or static scoping) is the rule that JavaScript uses to determine the scope of a variable. It means that the scope of variables is defined by their position within the source code *at the time of definition*, not by where they are called. When a function is defined, it 'remembers' its lexical environment—the environment in which it was *created*.\n\n**Relation to Closures**: A closure arises when an inner function 'closes over' or retains access to the variables of its outer function's lexical environment, even after the outer function has finished executing. The inner function maintains a reference to the lexical environment of its parent scope. This allows it to access and modify those variables, effectively 'carrying' that environment with it, forming the closure.",
          "options": [],
          "analysisPoints": [
            "Defines lexical environment accurately.",
            "Explains lexical scoping and how it determines variable access.",
            "Connects these concepts to how closures enable access to outer scope variables."
          ],
          "keyConcepts": [
            "lexical_environment",
            "lexical_scoping",
            "scope_chain",
            "closures"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of definitions.",
            "Correctly explaining the relationship between the concepts.",
            "Demonstrated understanding of fundamental JS scope rules."
          ],
          "example": "```javascript\nfunction outer() {\n  let outerVar = 'I am outer';\n  function inner() {\n    // inner 'closes over' outerVar from outer's lexical environment\n    console.log(outerVar);\n  }\n  return inner;\n}\nconst myFunction = outer();\nmyFunction(); // Logs: I am outer (even though outer() has finished)\n```\nHere, `outerVar` is part of `outer`'s lexical environment. `inner` is defined within this environment and 'closes over' it. When `outer()` returns `inner`, `inner` carries a reference to `outer`'s lexical environment, allowing it to access `outerVar` later.",
          "tags": [
            "closures",
            "scope",
            "lexical_scoping",
            "open-ended"
          ],
          "prerequisites": [
            "closures_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_closures_4",
          "topic": "Closures: Concept and Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "Does a closure allow an inner function to access variables from its outer function's scope even after the outer function has completed execution?",
          "answer": "Yes, this is precisely what a closure enables.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "closures",
            "scope",
            "lexical_environment"
          ],
          "evaluationCriteria": [
            "Understanding the persistence of outer scope variables."
          ],
          "example": "",
          "tags": [
            "closures",
            "fundamentals"
          ],
          "prerequisites": [
            "closures_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_closures_5",
          "topic": "Closures: Concept and Basics",
          "level": "medium",
          "type": "code",
          "question": "Create a function `createMultiplier(factor)` that returns a new function. The returned function should take one argument `number` and return `number * factor`. Demonstrate its use to create functions `multiplyBy2` and `multiplyBy5`, then use them.",
          "answer": "```javascript\nfunction createMultiplier(factor) {\n  return function(number) {\n    return number * factor;\n  };\n}\n\n// Create closures\nconst multiplyBy2 = createMultiplier(2);\nconst multiplyBy5 = createMultiplier(5);\n\n// Demonstrate usage\nconsole.log(multiplyBy2(10)); // Expected: 20\nconsole.log(multiplyBy5(10)); // Expected: 50\nconsole.log(multiplyBy2(3));  // Expected: 6\n```",
          "options": [],
          "analysisPoints": [
            "Correctly defines an outer function `createMultiplier`.",
            "Correctly returns an inner function.",
            "The inner function correctly 'closes over' the `factor` parameter from its lexical environment.",
            "Demonstrates the creation of multiple independent closures.",
            "Uses the created closures effectively."
          ],
          "keyConcepts": [
            "closures",
            "higher_order_functions",
            "lexical_scope",
            "function_factories"
          ],
          "evaluationCriteria": [
            "Correct implementation of the closure pattern.",
            "Clarity of the example and demonstration.",
            "Understanding of how `factor` is retained."
          ],
          "example": "This task directly applies the basic closure concept, similar to `makeAdder`, but for multiplication. It shows how closures can be used to 'configure' functions with specific parameters.",
          "tags": [
            "closures",
            "code_challenge",
            "functions"
          ],
          "prerequisites": [
            "closures_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_practical_closures_1",
          "topic": "Practical Uses of Closures: Data Privacy and Encapsulation",
          "level": "medium",
          "type": "flashcard",
          "question": "How can closures be used to achieve data privacy or encapsulation in JavaScript?",
          "answer": "By defining variables within an outer function's scope and returning inner functions that have access to these variables. The inner functions act as privileged methods, providing controlled access to the 'private' variables which are not directly accessible from outside.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "data_privacy",
            "encapsulation",
            "module_pattern",
            "closures"
          ],
          "evaluationCriteria": [
            "Understanding of data privacy through closures."
          ],
          "example": "",
          "tags": [
            "closures",
            "encapsulation",
            "data_privacy"
          ],
          "prerequisites": [
            "practical_closures"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_practical_closures_2",
          "topic": "Practical Uses of Closures: Data Privacy and Encapsulation",
          "level": "medium",
          "type": "mcq",
          "question": "Given the `createCounter` example:\n\n```javascript\nfunction createCounter() {\n  let privateCounter = 0;\n  return {\n    increment: function() { privateCounter++; },\n    decrement: function() { privateCounter--; },\n    getValue: function() { return privateCounter; }\n  };\n}\n\nconst counter1 = createCounter();\nconst counter2 = createCounter();\n\ncounter1.increment();\ncounter1.increment();\ncounter2.decrement();\n\nconsole.log(counter1.getValue());\nconsole.log(counter2.getValue());\n```\n\nWhat will be the output?",
          "answer": "2\n-1",
          "options": [
            "2\n2",
            "2\n-1",
            "1\n0",
            "Error"
          ],
          "analysisPoints": [
            "Each call to `createCounter()` creates a separate instance of the counter, each with its own `privateCounter` variable.",
            "`counter1` operates on its own `privateCounter`, which increments from 0 to 1, then to 2.",
            "`counter2` operates on its *separate* `privateCounter`, which decrements from 0 to -1.",
            "The `getValue` method correctly returns the state of the `privateCounter` specific to its instance."
          ],
          "keyConcepts": [
            "closures",
            "encapsulation",
            "private_variables",
            "independent_instances"
          ],
          "evaluationCriteria": [
            "Understanding of how closures create independent instances with separate states.",
            "Ability to track the state of multiple encapsulated counters."
          ],
          "example": "The example shows how `createCounter` acts like a factory for counter objects, each maintaining its own private state (`privateCounter`) thanks to closures.",
          "tags": [
            "closures",
            "encapsulation",
            "state",
            "mcq"
          ],
          "prerequisites": [
            "practical_closures"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_practical_closures_3",
          "topic": "Practical Uses of Closures: Data Privacy and Encapsulation",
          "level": "hard",
          "type": "open",
          "question": "Discuss the 'Module Pattern' in JavaScript and how closures are integral to its implementation. What are the advantages of using this pattern?",
          "answer": "The **Module Pattern** is a widely used design pattern in JavaScript for organizing code into self-contained units, often leveraging Immediately Invoked Function Expressions (IIFEs) and closures. It allows for the creation of 'private' variables and functions while exposing a public interface.\n\n**How Closures are Integral**: The core of the Module Pattern is typically an outer function (often an IIFE) that returns an object containing public methods. Inside this outer function, variables and functions are declared that are not part of the returned object. These variables and functions become 'private' to that module's scope. The public methods, because they are defined within the outer function's scope, form closures over these private members, giving them access. This means the private data and logic are encapsulated and cannot be directly accessed or modified from outside the module.\n\n**Example Structure (IIFE Module Pattern)**:\n```javascript\nconst MyModule = (function() {\n  let privateVar = 'I am private data';\n\n  function privateMethod() {\n    console.log('This is a private method accessing:', privateVar);\n  }\n\n  return { // Public interface exposed via an object\n    publicMethod: function() {\n      console.log('This is a public method.');\n      privateMethod(); // Can access private methods/vars\n    },\n    getPrivateVar: function() {\n      return privateVar; // Provides controlled access to private data\n    }\n  };\n})();\n\nMyModule.publicMethod();      // Logs: This is a public method. \n                              //       This is a private method accessing: I am private data\nconsole.log(MyModule.getPrivateVar()); // Logs: I am private data\n// console.log(MyModule.privateVar); // Undefined (not accessible directly)\n// MyModule.privateMethod();      // TypeError: MyModule.privateMethod is not a function\n```\n\n**Advantages of Using the Module Pattern**:\n\n1.  **Data Privacy/Encapsulation**: It allows you to create truly private variables and methods, protecting internal state from external tampering. This leads to more robust and predictable code.\n2.  **Avoids Global Namespace Pollution**: By encapsulating all module-related variables and functions within a single returned object, it keeps the global scope clean, reducing the risk of naming collisions.\n3.  **Modular Organization**: It promotes a clear separation of concerns, making code easier to understand, maintain, and refactor. Each module can focus on a specific piece of functionality.\n4.  **Reusability**: Modules can be designed to be self-contained and easily reusable across different parts of an application or even in different projects.\n5.  **State Management**: It's an effective way to manage encapsulated state for specific components or functionalities, similar to how classes manage instance state.",
          "options": [],
          "analysisPoints": [
            "Defines the Module Pattern and its typical structure (IIFE).",
            "Clearly explains the role of closures in maintaining private scope.",
            "Lists and explains multiple advantages of the pattern.",
            "Provides a concise and illustrative code example."
          ],
          "keyConcepts": [
            "module_pattern",
            "closures",
            "IIFE",
            "data_privacy",
            "encapsulation",
            "global_namespace_pollution",
            "design_patterns"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of the Module Pattern.",
            "Accurate description of closure's role.",
            "Thorough articulation of benefits.",
            "Clear example showcasing the pattern."
          ],
          "example": "```javascript\nconst MyModule = (function() {\n  let privateVar = 'secret';\n  function privateMethod() {\n    console.log(privateVar);\n  }\n  return {\n    publicMethod: function() {\n      privateMethod();\n    }\n  };\n})();\nMyModule.publicMethod();\n```",
          "tags": [
            "closures",
            "design_patterns",
            "architecture",
            "encapsulation",
            "open-ended"
          ],
          "prerequisites": [
            "practical_closures",
            "IIFE"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_practical_closures_4",
          "topic": "Practical Uses of Closures: Data Privacy and Encapsulation",
          "level": "medium",
          "type": "code",
          "question": "Implement a `ShoppingCart` module using closures. It should have:\n*   A private array `items` to store products.\n*   A public method `addItem(productName, price)` that adds an item to `items`.\n*   A public method `getTotal()` that calculates and returns the total price of all items.\n*   A public method `getCartItems()` that returns a *copy* of the `items` array to prevent external modification.\n\nDemonstrate its usage.",
          "answer": "```javascript\nfunction createShoppingCart() {\n  let items = []; // Private array\n\n  return {\n    addItem: function(productName, price) {\n      if (typeof productName === 'string' && productName.length > 0 && typeof price === 'number' && price > 0) {\n        items.push({ name: productName, price: price });\n        console.log(`${productName} added to cart.`);\n      } else {\n        console.error('Invalid product name or price.');\n      }\n    },\n    getTotal: function() {\n      return items.reduce((total, item) => total + item.price, 0);\n    },\n    getCartItems: function() {\n      // Return a shallow copy to prevent external modification of the private array\n      return [...items]; \n      // Or: return items.slice();\n    },\n    removeItem: function(productName) {\n        const initialLength = items.length;\n        items = items.filter(item => item.name !== productName);\n        if (items.length < initialLength) {\n            console.log(`${productName} removed from cart.`);\n        } else {\n            console.log(`${productName} not found in cart.`);\n        }\n    }\n  };\n}\n\n// Demonstrate usage:\nconst myCart = createShoppingCart();\n\nmyCart.addItem('Laptop', 1200);\nmyCart.addItem('Mouse', 25);\nmyCart.addItem('Keyboard', 75);\n\nconsole.log('Current items:', myCart.getCartItems()); // Should show Laptop, Mouse, Keyboard\nconsole.log('Total:', myCart.getTotal()); // Expected: 1300\n\n// Attempt to modify the 'private' array externally (should not work on the original)\nconst cartItems = myCart.getCartItems();\ncartItems.push({ name: 'Fake Item', price: 0 });\nconsole.log('Items after external push attempt:', myCart.getCartItems()); // Should NOT show Fake Item\n\nmyCart.removeItem('Mouse');\nconsole.log('Items after removing Mouse:', myCart.getCartItems()); // Should show Laptop, Keyboard\nconsole.log('New Total:', myCart.getTotal()); // Expected: 1275\n\n// Invalid item\nmyCart.addItem('', -10);\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses a `let` variable for `items` to create a private state.",
            "All public methods (`addItem`, `getTotal`, `getCartItems`, `removeItem`) are closures that access this `items` variable.",
            "The `getCartItems` method returns a *copy* of the array, demonstrating proper encapsulation (preventing direct external modification).",
            "Includes basic validation within `addItem`.",
            "Demonstrates the module's usage and verifies data privacy."
          ],
          "keyConcepts": [
            "closures",
            "encapsulation",
            "data_privacy",
            "module_pattern",
            "private_variables",
            "array_methods",
            "shallow_copy"
          ],
          "evaluationCriteria": [
            "Successful implementation of private state.",
            "Correct functionality of all public methods.",
            "Proper handling of data privacy (copying arrays).",
            "Clear demonstration of usage."
          ],
          "example": "This task is a practical application of the module pattern using closures to manage a shopping cart's state, preventing external direct manipulation of its internal `items` array.",
          "tags": [
            "closures",
            "code_challenge",
            "encapsulation",
            "design_patterns",
            "frontend_interview"
          ],
          "prerequisites": [
            "practical_closures",
            "arrays",
            "object_literals"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_advanced_closures_1",
          "topic": "Advanced Closure Patterns (Conceptual Overview)",
          "level": "medium",
          "type": "flashcard",
          "question": "Name two common advanced closure patterns or applications of closures beyond simple data privacy.",
          "answer": "Two common advanced closure patterns are **Memoization** (for caching function results) and **Currying** (for transforming functions into a sequence of functions). Other applications include implementing event handlers and higher-order functions.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "memoization",
            "currying",
            "advanced_closures",
            "higher_order_functions"
          ],
          "evaluationCriteria": [
            "Correct identification of advanced closure patterns."
          ],
          "example": "",
          "tags": [
            "closures",
            "advanced_js",
            "design_patterns"
          ],
          "prerequisites": [
            "advanced_closure_patterns_conceptual"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_advanced_closures_2",
          "topic": "Advanced Closure Patterns (Conceptual Overview)",
          "level": "hard",
          "type": "open",
          "question": "Briefly explain how closures can be used to implement a memoization function. What are the benefits of memoization?",
          "answer": "**How Closures Implement Memoization**: A memoization function uses a closure to maintain a cache (often an object or a Map) of previously computed results. When the memoized function is called with arguments, it first checks this cache. If the result for those arguments is already present, it returns the cached result. If not, it computes the result, stores it in the cache, and then returns it.\n\nThe closure ensures that the cache variable (e.g., `cache` or `memo`) persists across multiple calls to the returned memoized function, making the cached data accessible and mutable only by the memoized function itself.\n\n**Example Sketch (conceptual)**:\n```javascript\nfunction memoize(func) {\n  const cache = {}; // This 'cache' is closed over by the returned function\n\n  return function(...args) {\n    const key = JSON.stringify(args); // Simple key for demonstration\n    if (cache[key]) {\n      console.log('Returning from cache for:', args);\n      return cache[key];\n    } else {\n      console.log('Calculating and caching for:', args);\n      const result = func.apply(this, args);\n      cache[key] = result;\n      return result;\n    }\n  };\n}\n\n// Example usage:\nconst expensiveCalc = (num) => { /* Simulate heavy computation */ return num * num; };\nconst memoizedCalc = memoize(expensiveCalc);\n\nmemoizedCalc(5); // Calculates, caches, returns 25\nmemoizedCalc(5); // Returns 25 from cache\nmemoizedCalc(10); // Calculates, caches, returns 100\nmemoizedCalc(10); // Returns 100 from cache\n```\n\n**Benefits of Memoization**:\n\n1.  **Performance Optimization**: Significantly improves performance for 'pure' functions (functions that produce the same output for the same input and have no side effects) by avoiding redundant and computationally expensive calculations.\n2.  **Reduced Resource Usage**: Can reduce CPU cycles and sometimes memory usage (if the original computation involves heavy data manipulation) by reusing previous results.\n3.  **Predictability**: For idempotent functions, memoization ensures consistent results and behavior.\n\nIt's commonly used in dynamic programming, recursive algorithms, and rendering optimizations in UI frameworks (like React's `useMemo` hook, which uses a similar principle).",
          "options": [],
          "analysisPoints": [
            "Explains the role of the cache within the closure.",
            "Outlines the memoization logic (check cache, compute, store).",
            "Provides a conceptual code sketch.",
            "Lists and explains key benefits of memoization."
          ],
          "keyConcepts": [
            "memoization",
            "closures",
            "performance_optimization",
            "caching",
            "pure_functions",
            "higher_order_functions"
          ],
          "evaluationCriteria": [
            "Clear explanation of how closures enable memoization.",
            "Identification of `cache` as the closed-over variable.",
            "Accurate description of memoization benefits.",
            "Conceptual code example is helpful."
          ],
          "example": "```javascript\nfunction memoize(func) {\n  const cache = {};\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache[key]) return cache[key];\n    const result = func.apply(this, args);\n    cache[key] = result;\n    return result;\n  };\n}\n```",
          "tags": [
            "closures",
            "memoization",
            "performance",
            "optimization",
            "open-ended",
            "advanced_js"
          ],
          "prerequisites": [
            "advanced_closure_patterns_conceptual",
            "closures_basics",
            "higher_order_functions"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_object_getters_setters_1",
          "title": "Implement a `TemperatureConverter` Object with Getters and Setters",
          "description": "\nCreate a JavaScript object `temperatureConverter` that manages temperature in both Celsius and Fahrenheit.\n\nRequirements:\n1.  It should have an internal private-like property (e.g., `_celsius`) to store the temperature in Celsius.\n2.  Implement a `celsius` getter that returns the current temperature in Celsius.\n3.  Implement a `celsius` setter that takes a Celsius value, updates `_celsius`, and validates that the input is a number.\n4.  Implement a `fahrenheit` getter that calculates and returns the temperature in Fahrenheit based on `_celsius`.\n5.  Implement a `fahrenheit` setter that takes a Fahrenheit value, converts it to Celsius, and updates `_celsius`, also validating the input.\n\nConversion formulas:\n*   Celsius to Fahrenheit: `F = C * 9/5 + 32`\n*   Fahrenheit to Celsius: `C = (F - 32) * 5/9`\n",
          "difficulty": "medium",
          "startingCode": "const temperatureConverter = {\n  _celsius: 0, // Internal storage for Celsius\n\n  // Getter for Celsius\n  get celsius() {\n    // TODO: Implement getter for _celsius\n  },\n\n  // Setter for Celsius\n  set celsius(value) {\n    // TODO: Implement setter with number validation\n  },\n\n  // Getter for Fahrenheit\n  get fahrenheit() {\n    // TODO: Calculate and return Fahrenheit from _celsius\n  },\n\n  // Setter for Fahrenheit\n  set fahrenheit(value) {\n    // TODO: Convert Fahrenheit to Celsius and update _celsius, with validation\n  }\n};\n\n// --- Test Cases (You can uncomment and use these) ---\n// temperatureConverter.celsius = 25;\n// console.log(`Celsius: ${temperatureConverter.celsius}`);     // Expected: Celsius: 25\n// console.log(`Fahrenheit: ${temperatureConverter.fahrenheit}`); // Expected: Fahrenheit: 77\n\n// temperatureConverter.fahrenheit = 32;\n// console.log(`Celsius: ${temperatureConverter.celsius}`);     // Expected: Celsius: 0\n// console.log(`Fahrenheit: ${temperatureConverter.fahrenheit}`); // Expected: Fahrenheit: 32\n\n// temperatureConverter.celsius = 'abc'; // Should log validation error or handle gracefully\n// console.log(`Celsius after invalid set: ${temperatureConverter.celsius}`); // Should remain previous valid value\n",
          "solutionCode": "const temperatureConverter = {\n  _celsius: 0, // Internal storage for Celsius\n\n  get celsius() {\n    return this._celsius;\n  },\n\n  set celsius(value) {\n    if (typeof value === 'number') {\n      this._celsius = value;\n    } else {\n      console.error('Invalid input: Celsius value must be a number.');\n    }\n  },\n\n  get fahrenheit() {\n    return (this._celsius * 9/5) + 32;\n  },\n\n  set fahrenheit(value) {\n    if (typeof value === 'number') {\n      this._celsius = (value - 32) * 5/9;\n    } else {\n      console.error('Invalid input: Fahrenheit value must be a number.');\n    }\n  }\n};\n\n// Test Cases:\nconsole.log('--- Initial State ---');\nconsole.log(`Celsius: ${temperatureConverter.celsius}`);     // Expected: Celsius: 0\nconsole.log(`Fahrenheit: ${temperatureConverter.fahrenheit}`); // Expected: Fahrenheit: 32\n\nconsole.log('\\n--- Setting Celsius to 25 ---');\ntemperatureConverter.celsius = 25;\nconsole.log(`Celsius: ${temperatureConverter.celsius}`);     // Expected: Celsius: 25\nconsole.log(`Fahrenheit: ${temperatureConverter.fahrenheit}`); // Expected: Fahrenheit: 77\n\nconsole.log('\\n--- Setting Fahrenheit to 32 (freezing point) ---');\ntemperatureConverter.fahrenheit = 32;\nconsole.log(`Celsius: ${temperatureConverter.celsius}`);     // Expected: Celsius: 0\nconsole.log(`Fahrenheit: ${temperatureConverter.fahrenheit}`); // Expected: Fahrenheit: 32\n\nconsole.log('\\n--- Setting Celsius to 100 (boiling point) ---');\ntemperatureConverter.celsius = 100;\nconsole.log(`Celsius: ${temperatureConverter.celsius}`);     // Expected: Celsius: 100\nconsole.log(`Fahrenheit: ${temperatureConverter.fahrenheit}`); // Expected: Fahrenheit: 212\n\nconsole.log('\\n--- Attempting invalid Celsius set ---');\ntemperatureConverter.celsius = 'abc'; // Should log validation error\nconsole.log(`Celsius after invalid set: ${temperatureConverter.celsius}`); // Should remain 100\n\nconsole.log('\\n--- Attempting invalid Fahrenheit set ---');\ntemperatureConverter.fahrenheit = null; // Should log validation error\nconsole.log(`Fahrenheit after invalid set: ${temperatureConverter.fahrenheit}`); // Should calculate from 100C -> 212F\n",
          "testCases": [
            "Initial state: `celsius` should be 0, `fahrenheit` should be 32.",
            "Set `celsius` to 25: `celsius` should be 25, `fahrenheit` should be 77.",
            "Set `fahrenheit` to 32: `celsius` should be 0, `fahrenheit` should be 32.",
            "Set `celsius` to 100: `celsius` should be 100, `fahrenheit` should be 212.",
            "Attempt to set `celsius` with a non-numeric value (e.g., `'abc'`): It should handle gracefully (e.g., log an error) and `_celsius` should not change.",
            "Attempt to set `fahrenheit` with a non-numeric value (e.g., `null`): It should handle gracefully and `_celsius` should not change."
          ],
          "hints": [
            "Remember that `this` inside a getter/setter refers to the object itself.",
            "The internal `_celsius` property is a convention for indicating it's not meant for direct external manipulation, but it's still publicly accessible. This is the closest you get to 'private' properties in standard JS objects without closures or private class fields.",
            "For Fahrenheit conversion, ensure you perform the operation correctly `(F - 32) * 5 / 9` for Celsius conversion and `C * 9 / 5 + 32` for Fahrenheit conversion.",
            "Use `typeof` to validate if the input `value` is a `number`."
          ],
          "tags": [
            "getters",
            "setters",
            "objects",
            "data_transformation",
            "validation"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "object_getters_setters",
            "javascript_operators"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "data_encapsulation",
            "computed_properties",
            "object_modeling"
          ]
        },
        {
          "id": "task_equality_1",
          "title": "Implement a Flexible Equality Checker",
          "description": "\nCreate a JavaScript function `areEqual(a, b, strict)` that compares two values `a` and `b`.\n\nRequirements:\n1.  If the `strict` argument is `true`, it should use strict equality (`===`).\n2.  If the `strict` argument is `false`, it should use loose equality (`==`).\n3.  If `a` or `b` are objects (excluding `null`), and `strict` is `true`, special handling is required:\n    *   For arrays, perform a deep comparison (same length, all elements strictly equal). Handle nested arrays recursively.\n    *   For plain objects, perform a deep comparison (same keys, same values strictly equal for primitives, recursively for nested objects/arrays). Order of keys does not matter.\n4.  If `a` or `b` are `NaN`, it should correctly return `true` if both are `NaN` (as `NaN === NaN` is false, you'll need `Number.isNaN`).\n\nThis task requires you to build a more robust equality checker that goes beyond simple `==` and `===` for complex types, especially in strict mode.\n",
          "difficulty": "hard",
          "startingCode": "function areEqual(a, b, strict) {\n  if (strict) {\n    // TODO: Implement strict equality with deep comparison for objects/arrays and NaN handling\n  } else {\n    // TODO: Implement loose equality\n  }\n}\n\n// --- Test Cases (You can uncomment and use these) ---\n// console.log(areEqual(1, '1', false));          // Expected: true\n// console.log(areEqual(1, '1', true));           // Expected: false\n// console.log(areEqual(null, undefined, false)); // Expected: true\n// console.log(areEqual(null, undefined, true));  // Expected: false\n// console.log(areEqual(0, false, false));        // Expected: true\n// console.log(areEqual(0, false, true));         // Expected: false\n\n// console.log(areEqual([1, 2], [1, 2], true));            // Expected: true\n// console.log(areEqual([1, 2, [3, 4]], [1, 2, [3, 4]], true)); // Expected: true\n// console.log(areEqual([1, 2, [3, 4]], [1, 2, [3, '4']], true)); // Expected: false (due to '4')\n\n// console.log(areEqual({ a: 1, b: 2 }, { a: 1, b: 2 }, true)); // Expected: true\n// console.log(areEqual({ a: 1, b: { c: 3 } }, { a: 1, b: { c: 3 } }, true)); // Expected: true\n// console.log(areEqual({ b: 2, a: 1 }, { a: 1, b: 2 }, true)); // Expected: true (order doesn't matter)\n\n// console.log(areEqual(NaN, NaN, true));           // Expected: true\n// console.log(areEqual(NaN, 5, true));             // Expected: false\n",
          "solutionCode": "function areEqual(a, b, strict) {\n  // Handle NaN case first for strict comparison\n  if (Number.isNaN(a) && Number.isNaN(b)) {\n    return true;\n  }\n\n  if (strict) {\n    // Strict comparison for primitives and simple types\n    if (a === b) {\n      return true;\n    }\n\n    // Handle null explicitly, as typeof null is 'object'\n    if (a === null || b === null) {\n        return false; // Already handled null === null by a === b\n    }\n\n    // Deep comparison for objects and arrays\n    if (typeof a === 'object' && typeof b === 'object') {\n      // Array comparison\n      if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n          return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n          // Recursively call areEqual for elements (deep comparison)\n          if (!areEqual(a[i], b[i], true)) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      // Plain object comparison\n      if (!Array.isArray(a) && !Array.isArray(b)) {\n        const keysA = Object.keys(a);\n        const keysB = Object.keys(b);\n\n        if (keysA.length !== keysB.length) {\n          return false;\n        }\n\n        for (let key of keysA) {\n          if (!keysB.includes(key) || !areEqual(a[key], b[key], true)) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    \n    return false; // Default for strict if types or values don't match after specific checks\n\n  } else {\n    // Loose comparison for all types\n    return a == b;\n  }\n}\n\n// Test Cases:\nconsole.log('--- Loose Equality ---');\nconsole.log(`1 == '1' (false): ${areEqual(1, '1', false)}`);           // Expected: true\nconsole.log(`null == undefined (false): ${areEqual(null, undefined, false)}`); // Expected: true\nconsole.log(`0 == false (false): ${areEqual(0, false, false)}`);         // Expected: true\nconsole.log(`[] == 0 (false): ${areEqual([], 0, false)}`);             // Expected: true\nconsole.log(`{} == {} (false): ${areEqual({}, {}, false)}`);          // Expected: false (reference)\n\nconsole.log('\\n--- Strict Equality ---');\nconsole.log(`1 === '1' (true): ${areEqual(1, '1', true)}`);           // Expected: false\nconsole.log(`null === undefined (true): ${areEqual(null, undefined, true)}`); // Expected: false\nconsole.log(`0 === false (true): ${areEqual(0, false, true)}`);         // Expected: false\nconsole.log(`[] === [] (true): ${areEqual([], [], true)}`);             // Expected: true (deep, array)\nconsole.log(`{} === {} (true): ${areEqual({}, {}, true)}`);             // Expected: true (deep, object)\nconsole.log(`NaN === NaN (true): ${areEqual(NaN, NaN, true)}`);           // Expected: true (special NaN handling)\n\nconsole.log('\\n--- Strict Deep Array Equality ---');\nconsole.log(`[1, 2] vs [1, 2]: ${areEqual([1, 2], [1, 2], true)}`);           // Expected: true\nconsole.log(`[1, 2, [3, 4]] vs [1, 2, [3, 4]]: ${areEqual([1, 2, [3, 4]], [1, 2, [3, 4]], true)}`); // Expected: true\nconsole.log(`[1, 2, [3, 4]] vs [1, 2, [3, '4']]: ${areEqual([1, 2, [3, 4]], [1, 2, [3, '4']], true)}`); // Expected: false (type mismatch '4' vs 4)\nconsole.log(`[1, 2] vs [1, '2']: ${areEqual([1, 2], [1, '2'], true)}`);       // Expected: false (type mismatch '2' vs 2)\n\nconsole.log('\\n--- Strict Deep Object Equality ---');\nconsole.log(`{ a: 1, b: 2 } vs { a: 1, b: 2 }: ${areEqual({ a: 1, b: 2 }, { a: 1, b: 2 }, true)}`); // Expected: true\nconsole.log(`{ a: 1, b: { c: 3 } } vs { a: 1, b: { c: 3 } }: ${areEqual({ a: 1, b: { c: 3 } }, { a: 1, b: { c: 3 } }, true)}`); // Expected: true\nconsole.log(`{ b: 2, a: 1 } vs { a: 1, b: 2 }: ${areEqual({ b: 2, a: 1 }, { a: 1, b: 2 }, true)}`); // Expected: true (key order doesn't matter)\nconsole.log(`{ a: 1 } vs { a: '1' }: ${areEqual({ a: 1 }, { a: '1' }, true)}`); // Expected: false (type mismatch)\nconsole.log(`{ a: 1, b: [2] } vs { a: 1, b: [2] }: ${areEqual({ a: 1, b: [2] }, { a: 1, b: [2] }, true)}`); // Expected: true (nested array)\n",
          "testCases": [
            "Loose equality: `areEqual(1, '1', false)` should be `true`.",
            "Strict equality: `areEqual(1, '1', true)` should be `false`.",
            "Loose equality: `areEqual(null, undefined, false)` should be `true`.",
            "Strict equality: `areEqual(null, undefined, true)` should be `false`.",
            "Loose equality: `areEqual(0, false, false)` should be `true`.",
            "Strict equality: `areEqual(0, false, true)` should be `false`.",
            "`NaN` handling: `areEqual(NaN, NaN, true)` should be `true`.",
            "Deep array equality: `areEqual([1, 2, [3, 4]], [1, 2, [3, 4]], true)` should be `true`.",
            "Deep array inequality (different value type): `areEqual([1, 2, [3, 4]], [1, 2, [3, '4']], true)` should be `false`.",
            "Deep object equality: `areEqual({ a: 1, b: { c: 3 } }, { a: 1, b: { c: 3 } }, true)` should be `true`.",
            "Deep object equality (different key order): `areEqual({ b: 2, a: 1 }, { a: 1, b: 2 }, true)` should be `true`.",
            "Deep object inequality (different value type): `areEqual({ a: 1 }, { a: '1' }, true)` should be `false`."
          ],
          "hints": [
            "For `NaN` comparison, remember `Number.isNaN()`.",
            "For deep comparison of arrays and objects, you will need to use recursion.",
            "For object deep comparison, iterate over keys using `Object.keys()` and check if all keys exist in both objects and if their corresponding values are equal (recursively).",
            "Be careful with `typeof null` returning 'object'. Check for `null` explicitly before proceeding with object/array checks.",
            "Remember that `Object.keys()` doesn't guarantee order, so check for key existence in both directions or rely on `keysA.length === keysB.length` and then `keysB.includes(key)` for each key in `keysA`."
          ],
          "tags": [
            "equality",
            "deep_comparison",
            "recursion",
            "algorithms",
            "data_structures",
            "frontend_interview"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "equality_comparison",
            "strict_vs_loose_equality_deep_dive",
            "recursion",
            "arrays",
            "objects"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "utility_functions",
            "immutable_data",
            "testing"
          ]
        },
        {
          "id": "task_closures_basic_1",
          "title": "Create a Simple Logger Factory",
          "description": "\nImplement a JavaScript function `createLogger(prefix)` that acts as a factory for logger functions. The returned logger function should take a `message` and log it to the console, prefixed by the `prefix` provided when the logger was created.\n\nRequirements:\n1.  `createLogger` should accept a `prefix` string.\n2.  It should return a new function (the logger).\n3.  The returned logger function should take a `message` string.\n4.  The logger function should use the `prefix` (closed over) and the `message` to log `[PREFIX] message` to the console.\n\nDemonstrate by creating two different loggers, `infoLogger` (prefix 'INFO') and `errorLogger` (prefix 'ERROR'), and use them to log various messages.\n",
          "difficulty": "easy",
          "startingCode": "function createLogger(prefix) {\n  // TODO: Implement the logger factory using a closure\n  return function(message) {\n    // Log the message with the prefix\n  };\n}\n\n// --- Test Cases (You can uncomment and use these) ---\n// const infoLogger = createLogger('INFO');\n// const errorLogger = createLogger('ERROR');\n\n// infoLogger('Application started successfully.'); // Expected: [INFO] Application started successfully.\n// errorLogger('Failed to connect to database.'); // Expected: [ERROR] Failed to connect to database.\n",
          "solutionCode": "function createLogger(prefix) {\n  // The 'prefix' variable is part of the lexical environment\n  // that the returned function will close over.\n  return function(message) {\n    console.log(`[${prefix}] ${message}`);\n  };\n}\n\n// Demonstrate by creating two different loggers:\nconst infoLogger = createLogger('INFO');\nconst errorLogger = createLogger('ERROR');\nconst debugLogger = createLogger('DEBUG');\n\n// Use the loggers to log various messages:\nconsole.log('--- Info Messages ---');\ninfoLogger('User logged in successfully.');\ninfoLogger('Data fetched from API.');\n\nconsole.log('\\n--- Error Messages ---');\nerrorLogger('Failed to parse configuration file.');\nerrorLogger('Network timeout occurred.');\n\nconsole.log('\\n--- Debug Messages ---');\ndebugLogger('Variable x: 10');\ndebugLogger('Function foo called with arg: bar');\n",
          "testCases": [
            "Create `infoLogger` with prefix 'INFO' and log 'System ready.'. Expected: `[INFO] System ready.`",
            "Create `errorLogger` with prefix 'ERROR' and log 'Data corruption detected.'. Expected: `[ERROR] Data corruption detected.`",
            "Verify that `infoLogger` and `errorLogger` maintain independent prefixes.",
            "Log a message with an empty prefix string: `createLogger('')('Test')` should log `[] Test`."
          ],
          "hints": [
            "The inner function needs to 'remember' the `prefix` value passed to the `createLogger` function.",
            "Use template literals (backticks `` ` ``) for easy string interpolation."
          ],
          "tags": [
            "closures",
            "function_factory",
            "logging",
            "javascript_basics"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "closures_basics",
            "javascript_functions"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "higher_order_functions",
            "functional_programming"
          ]
        },
        {
          "id": "task_closures_advanced_1",
          "title": "Build a Simple EventEmitter with Closures",
          "description": "\nImplement a `createEventEmitter` function that returns an object acting as a simple event emitter. This emitter should allow functions to 'subscribe' to events and 'publish' events.\n\nRequirements:\n1.  The `createEventEmitter` function should have a private data structure (e.g., a `Map` or an object) to store event listeners. This structure should be accessible only via closures.\n2.  The returned object should expose two public methods:\n    *   `on(eventName, listener)`: Registers a `listener` function for a given `eventName`.\n    *   `emit(eventName, ...args)`: Calls all `listener` functions registered for the `eventName`, passing any additional arguments.\n3.  Ensure that `listener` functions are called with the correct `this` context (if applicable, though typically not strictly required for simple event emitters, `null` or `undefined` is fine, or explicitly bind). For this task, `this` context for listeners is not critical, just ensure arguments are passed.\n\nDemonstrate its usage by creating an emitter, registering listeners for different events, and then emitting those events.\n",
          "difficulty": "hard",
          "startingCode": "function createEventEmitter() {\n  const listeners = {}; // Private store for listeners. Example: { 'eventName': [func1, func2] }\n\n  return {\n    on: function(eventName, listener) {\n      // TODO: Implement event registration\n    },\n    emit: function(eventName, ...args) {\n      // TODO: Implement event publishing\n    }\n  };\n}\n\n// --- Test Cases (You can uncomment and use these) ---\n// const emitter = createEventEmitter();\n\n// emitter.on('userLoggedIn', (username) => {\n//   console.log(`User ${username} logged in!`);\n// });\n\n// emitter.on('dataReceived', (data) => {\n//   console.log('Received data:', data);\n// });\n\n// emitter.emit('userLoggedIn', 'Alice'); // Expected: User Alice logged in!\n// emitter.emit('dataReceived', { id: 1, value: 'test' }); // Expected: Received data: { id: 1, value: 'test' }\n// emitter.emit('unknownEvent'); // Should do nothing or handle gracefully\n",
          "solutionCode": "function createEventEmitter() {\n  // `listeners` is a private variable, encapsulated by the closure.\n  // It stores events as keys and arrays of listener functions as values.\n  const listeners = {}; \n\n  return {\n    /**\n     * Registers a listener function for a specific event.\n     * @param {string} eventName - The name of the event.\n     * @param {Function} listener - The function to call when the event is emitted.\n     */\n    on: function(eventName, listener) {\n      if (typeof listener !== 'function') {\n        console.error('Listener must be a function.');\n        return;\n      }\n      if (!listeners[eventName]) {\n        listeners[eventName] = [];\n      }\n      listeners[eventName].push(listener);\n      console.log(`Listener added for event: ${eventName}`);\n    },\n\n    /**\n     * Emits an event, calling all registered listeners with provided arguments.\n     * @param {string} eventName - The name of the event to emit.\n     * @param {...any} args - Arguments to pass to the listeners.\n     */\n    emit: function(eventName, ...args) {\n      const eventListeners = listeners[eventName];\n      if (eventListeners) {\n        console.log(`Emitting event: ${eventName} with args:`, args);\n        eventListeners.forEach(listener => {\n          listener(...args);\n        });\n      } else {\n        console.log(`No listeners registered for event: ${eventName}`);\n      }\n    },\n\n    /**\n     * (Optional, but good for completeness): Removes a specific listener for an event.\n     * @param {string} eventName - The name of the event.\n     * @param {Function} listenerToRemove - The specific listener function to remove.\n     */\n    off: function(eventName, listenerToRemove) {\n        if (listeners[eventName]) {\n            listeners[eventName] = listeners[eventName].filter(listener => listener !== listenerToRemove);\n            console.log(`Listener removed for event: ${eventName}`);\n        }\n    }\n  };\n}\n\n// Demonstrate usage:\nconst myEmitter = createEventEmitter();\n\n// Register listeners\nconst welcomeListener = (username) => {\n  console.log(`Welcome, ${username}!`);\n};\n\nconst notifyAdminListener = (username) => {\n  console.log(`Admin notified: ${username} logged in.`);\n};\n\nmyEmitter.on('userLoggedIn', welcomeListener);\nmyEmitter.on('userLoggedIn', notifyAdminListener);\n\nmyEmitter.on('paymentSuccessful', (amount, user) => {\n  console.log(`Payment of $${amount} successful for ${user}.`);\n});\n\n// Emit events\nconsole.log('\\n--- Emitting userLoggedIn ---');\nmyEmitter.emit('userLoggedIn', 'Alice');\n\nconsole.log('\\n--- Emitting paymentSuccessful ---');\nmyEmitter.emit('paymentSuccessful', 99.99, 'Bob');\n\nconsole.log('\\n--- Emitting unknown event ---');\nmyEmitter.emit('orderPlaced'); // No listeners, should log accordingly\n\nconsole.log('\\n--- Removing a listener ---');\nmyEmitter.off('userLoggedIn', notifyAdminListener);\n\nconsole.log('\\n--- Emitting userLoggedIn again after removal ---');\nmyEmitter.emit('userLoggedIn', 'Charlie'); // Only Welcome, Charlie! should be logged\n",
          "testCases": [
            "Register a listener for 'testEvent' and emit it with a message. Verify the listener is called with the message.",
            "Register multiple listeners for the same event and ensure all are called.",
            "Emit an event for which no listeners are registered. Ensure it handles gracefully (e.g., no errors, optional console message).",
            "Test with different types of arguments for `emit` (numbers, objects).",
            "Optional: Implement an `off` method to unsubscribe listeners and test it."
          ],
          "hints": [
            "Use an object or a `Map` to store listeners where keys are event names and values are arrays of functions.",
            "When `emit` is called, iterate through the array of listeners for that event and call each function.",
            "The rest parameter `...args` can be very useful for `emit` to pass variable arguments to listeners.",
            "Consider edge cases: what if no listeners for an event? What if `listener` is not a function?"
          ],
          "tags": [
            "closures",
            "event_emitter",
            "design_patterns",
            "data_privacy",
            "frontend_interview",
            "event_handling"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "practical_closures",
            "arrays",
            "objects",
            "functions",
            "rest_parameters"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "pub_sub_pattern",
            "observers",
            "custom_events",
            "asynchronous_javascript"
          ]
        }
      ]
    }
  }
]