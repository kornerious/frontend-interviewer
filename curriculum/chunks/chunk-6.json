[
  {
    "id": "df8fca82-8fab-48c2-853c-a851712f7495",
    "startLine": 1200,
    "endLine": 1299,
    "processedDate": "2025-06-17T07:40:48.629Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_array_modification_methods",
          "title": "Array Modification Methods: Adding and Removing Elements",
          "content": "This section covers fundamental JavaScript array methods used for adding and removing elements. These methods allow for manipulation of array contents at the beginning, end, or specific positions.\n\n## Key Concepts\n- **`push(...items)`**: Adds one or more elements to the end of an array and returns the new length of the array. It modifies the original array.\n- **`pop()`**: Removes the last element from an array and returns that element. If the array is empty, it returns `undefined`. It modifies the original array.\n- **`shift()`**: Removes the first element from an array and returns that element. If the array is empty, it returns `undefined`. It modifies the original array.\n- **`unshift(...items)`**: Adds one or more elements to the beginning of an array and returns the new length of the array. It modifies the original array.\n- **`splice(pos, deleteCount, ...items)`**: A highly versatile method that changes the contents of an array by removing existing elements and/or adding new elements. It modifies the original array.\n  - `pos`: The index at which to start changing the array.\n  - `deleteCount`: An integer indicating the number of elements to remove from `pos`.\n  - `...items`: The elements to add to the array, starting at `pos`.\n  - Returns an array containing the deleted elements.\n- **`slice(start, end)`**: Returns a shallow copy of a portion of an array into a new array object selected from `start` to `end` (end not included). The original array will not be modified.\n  - `start`: Zero-based index at which to begin extraction. If negative, it specifies an offset from the end of the sequence.\n  - `end`: Zero-based index before which to end extraction. `slice` extracts up to (but not including) `end`. If `end` is omitted, `slice` extracts to the end of the sequence.\n- **`concat(...items)`**: Used to merge two or more arrays. This method does not change the existing arrays, but instead returns a new array. It can take an arbitrary number of array arguments or non-array values.",
          "examples": [
            {
              "id": "example_array_modification_1",
              "title": "Basic Push, Pop, Shift, Unshift Operations",
              "code": "const animals = ['cat', 'dog'];\n\n// push(): Adds to the end, returns new length\nconst newLengthPush = animals.push('elephant'); // animals is now ['cat', 'dog', 'elephant'], newLengthPush is 3\nconsole.log('After push:', animals, 'Length:', newLengthPush);\n\n// pop(): Removes from the end, returns removed element\nconst removedPop = animals.pop(); // animals is now ['cat', 'dog'], removedPop is 'elephant'\nconsole.log('After pop:', animals, 'Removed:', removedPop);\n\n// unshift(): Adds to the beginning, returns new length\nconst newLengthUnshift = animals.unshift('horse'); // animals is now ['horse', 'cat', 'dog'], newLengthUnshift is 3\nconsole.log('After unshift:', animals, 'Length:', newLengthUnshift);\n\n// shift(): Removes from the beginning, returns removed element\nconst removedShift = animals.shift(); // animals is now ['cat', 'dog'], removedShift is 'horse'\nconsole.log('After shift:', animals, 'Removed:', removedShift);",
              "explanation": "This example demonstrates the basic usage of `push`, `pop`, `unshift`, and `shift`. Note how these methods directly modify the `animals` array in place and return either the new length or the removed element.",
              "language": "typescript"
            },
            {
              "id": "example_array_modification_2",
              "title": "Splice, Slice, and Concat Operations",
              "code": "const animals = ['cat', 'dog', 'elephant', 'fox'];\n\n// splice() examples:\n// 1. Insert without removing: add 'bird' at index 1\nconst noRemovedSplice = animals.splice(1, 0, 'bird'); // animals is ['cat', 'bird', 'dog', 'elephant', 'fox'], noRemovedSplice is []\nconsole.log('Splice (insert only):', animals, 'Removed:', noRemovedSplice);\n\n// 2. Remove without inserting: remove 2 elements starting at index 2\nconst removedSplice = animals.splice(2, 2); // animals is ['cat', 'bird', 'fox'], removedSplice is ['dog', 'elephant']\nconsole.log('Splice (remove only):', animals, 'Removed:', removedSplice);\n\n// 3. Insert and remove simultaneously (replace): replace 1 element at index 0\nconst replacedSplice = animals.splice(0, 1, 'lion', 'tiger'); // animals is ['lion', 'tiger', 'bird', 'fox'], replacedSplice is ['cat']\nconsole.log('Splice (replace):', animals, 'Removed:', replacedSplice);\n\nconst originalNumbers = [10, 20, 30, 40, 50];\n\n// slice() example: creates a new array\nconst slicedNumbers = originalNumbers.slice(1, 4); // slicedNumbers is [20, 30, 40]\nconsole.log('Original after slice:', originalNumbers); // [10, 20, 30, 40, 50] - remains unchanged\nconsole.log('Sliced array:', slicedNumbers);\n\nconst arr1 = [1, 2];\nconst arr2 = [3, 4];\nconst arr3 = [5, 6];\n\n// concat() example: creates a new array\nconst combinedArray = arr1.concat(arr2, arr3, 7, 8); // [1, 2, 3, 4, 5, 6, 7, 8]\nconsole.log('Combined array:', combinedArray);\nconsole.log('Original arr1 after concat:', arr1); // [1, 2] - remains unchanged",
              "explanation": "This example showcases `splice`'s flexibility for insertion, deletion, and replacement, all of which modify the original array. It also demonstrates `slice` creating a new array without affecting the original and `concat` merging arrays into a new one.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_array_modification_1",
            "question_array_modification_2",
            "question_array_modification_3",
            "question_array_modification_4",
            "question_array_modification_5",
            "question_array_modification_6",
            "question_array_modification_7"
          ],
          "relatedTasks": [
            "task_array_modification_1",
            "task_array_modification_2"
          ],
          "tags": [
            "Array Methods",
            "Mutation",
            "Non-Mutation",
            "Data Manipulation",
            "JavaScript Basics"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "javascript_functions"
          ],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "beginner",
          "requiredFor": [
            "data_structures",
            "algorithm_implementation",
            "frontend_data_handling"
          ]
        },
        {
          "id": "theory_array_searching_methods",
          "title": "Array Searching Methods: Finding Elements",
          "content": "This section details array methods primarily used for searching and filtering elements based on specific criteria or values. These methods provide efficient ways to locate data within an array.\n\n## Key Concepts\n- **`indexOf(item, pos)`**: Returns the first index at which a given `item` can be found in the array, or -1 if it is not present. The search starts from `pos` (optional, default 0).\n- **`lastIndexOf(item, pos)`**: Returns the last index at which a given `item` can be found in the array, or -1 if it is not present. The array is searched backwards, starting from `pos` (optional, default `array.length - 1`).\n- **`includes(value)`**: Determines whether an array includes a certain `value` among its entries, returning `true` or `false` as appropriate. This method handles `NaN` correctly, unlike `indexOf`.\n- **`find(func)`**: Returns the **first** element in the array that satisfies the provided testing `func`. If no elements satisfy the testing function, `undefined` is returned.\n  - The callback `func` is executed for each element in the array until it returns a `truthy` value.\n- **`filter(func)`**: Creates a **new array** with all elements that pass the test implemented by the provided testing `func`. It iterates over the entire array.\n- **`findIndex(func)`**: Returns the **index** of the first element in the array that satisfies the provided testing `func`. Otherwise, it returns -1. It is similar to `find`, but returns the index instead of the value.",
          "examples": [
            {
              "id": "example_array_searching_1",
              "title": "Basic Searching with indexOf, lastIndexOf, includes",
              "code": "const fruits = ['apple', 'banana', 'orange', 'apple', 'grape', NaN];\n\n// indexOf()\nconsole.log('Index of first apple:', fruits.indexOf('apple')); // 0\nconsole.log('Index of first orange from index 2:', fruits.indexOf('orange', 2)); // 2\nconsole.log('Index of non-existent item:', fruits.indexOf('kiwi')); // -1\nconsole.log('indexOf NaN (issue):', fruits.indexOf(NaN)); // -1 (does not find NaN)\n\n// lastIndexOf()\nconsole.log('Last index of apple:', fruits.lastIndexOf('apple')); // 3\nconsole.log('Last index of apple before index 2:', fruits.lastIndexOf('apple', 2)); // 0\n\n// includes()\nconsole.log('Includes banana:', fruits.includes('banana')); // true\nconsole.log('Includes mango:', fruits.includes('mango')); // false\nconsole.log('Includes NaN (correctly):', fruits.includes(NaN)); // true (handles NaN)",
              "explanation": "This example illustrates how `indexOf` and `lastIndexOf` find element positions, with `pos` allowing for specific starting points. It highlights `includes` as a simpler way to check for presence, especially useful for `NaN`.",
              "language": "typescript"
            },
            {
              "id": "example_array_searching_2",
              "title": "Advanced Searching with find, filter, findIndex",
              "code": "const products = [\n  { id: 1, name: 'Laptop', price: 1200 },\n  { id: 2, name: 'Mouse', price: 25 },\n  { id: 3, name: 'Keyboard', price: 75 },\n  { id: 4, name: 'Monitor', price: 300 },\n  { id: 5, name: 'Webcam', price: 75 }\n];\n\n// find(): Returns the first matching object\nconst expensiveProduct = products.find(product => product.price > 100); // { id: 1, name: 'Laptop', price: 1200 }\nconsole.log('First expensive product:', expensiveProduct);\n\nconst nonExistentProduct = products.find(product => product.price > 2000);\nconsole.log('Non-existent product:', nonExistentProduct); // undefined\n\n// filter(): Returns a new array with all matching objects\nconst affordableProducts = products.filter(product => product.price <= 100);\n/*\n[\n  { id: 2, name: 'Mouse', price: 25 },\n  { id: 3, name: 'Keyboard', price: 75 },\n  { id: 5, name: 'Webcam', price: 75 }\n]\n*/\nconsole.log('Affordable products:', affordableProducts);\n\n// findIndex(): Returns the index of the first matching object\nconst keyboardIndex = products.findIndex(product => product.name === 'Keyboard'); // 2\nconsole.log('Index of Keyboard:', keyboardIndex);\n\nconst tabletIndex = products.findIndex(product => product.name === 'Tablet');\nconsole.log('Index of Tablet:', tabletIndex); // -1",
              "explanation": "`find` is useful when you need the first element that meets a condition. `filter` is used when you need a new array containing all elements that meet the condition. `findIndex` is similar to `find` but provides the index instead of the element itself, useful for modifying elements or understanding their position.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_array_searching_1",
            "question_array_searching_2",
            "question_array_searching_3",
            "question_array_searching_4",
            "question_array_searching_5",
            "question_array_searching_6"
          ],
          "relatedTasks": [
            "task_array_searching_1",
            "task_array_searching_2"
          ],
          "tags": [
            "Array Methods",
            "Searching",
            "Filtering",
            "Higher-Order Functions",
            "Data Retrieval"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "callback_functions"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_manipulation",
            "api_response_processing",
            "ui_filtering"
          ]
        },
        {
          "id": "theory_array_iteration_transformation_methods",
          "title": "Array Iteration and Transformation Methods",
          "content": "This section delves into array methods that facilitate iteration over elements and transformation of arrays into new ones or a single value.\n\n## Key Concepts\n- **`forEach(func)`**: Executes a provided `func` once for each array element. It does not return a new array and returns `undefined`. It's primarily used for side effects (e.g., logging, updating DOM).\n  - The callback `func` typically takes `(element, index, array)` as arguments.\n- **`map(func)`**: Creates a **new array** populated with the results of calling a provided `func` on every element in the calling array. It does not modify the original array.\n  - Ideal for transforming each element in an array into a new form.\n- **`sort(func)`**: Sorts the elements of an array **in-place** and returns the reference to the same array. The default sort order is ascending, built upon converting elements into strings, then comparing their sequences of UTF-16 code units.\n  - For numeric or custom sorting, a comparison `func` must be provided: `(a, b) => a - b` for ascending numbers, `(a, b) => b - a` for descending numbers.\n- **`reverse()`**: Reverses the order of the elements in an array **in-place** and returns the reference to the same array.\n- **`split(separator)` (String method)**: Splits a `String` object into an array of strings by separating the string into substrings, using a specified `separator` string to determine where to make each split. Returns a new array.\n- **`join(separator)` (Array method)**: Creates and returns a new string by concatenating all of the elements in an array (or an array-like object), separated by commas or a specified `separator` string.\n- **`reduce(func, initial)`**: Executes a `reducer` callback `func` on each element of the array, `accumulating` a single `value` from left to right. It is often used to sum, flatten, or transform data into a single result.\n  - `func`: A callback function that takes four arguments: `accumulator`, `currentValue`, `currentIndex`, `array`.\n  - `initial`: An optional value to use as the first argument to the first call of the `func`.\n  - If `initial` is not provided, the first element of the array is used as the initial `accumulator` value and `currentValue` starts from the second element. If the array is empty and no initial value is provided, a `TypeError` is thrown.",
          "examples": [
            {
              "id": "example_array_iteration_transformation_1",
              "title": "forEach, map, sort, reverse",
              "code": "const numbers = [10, 5, 20, 15];\n\n// forEach(): Iterates, no return value\nlet sum = 0;\nnumbers.forEach(num => {\n  sum += num;\n});\nconsole.log('Sum using forEach:', sum); // 50\n\n// map(): Transforms into a new array\nconst doubledNumbers = numbers.map(num => num * 2); // [20, 10, 40, 30]\nconsole.log('Original array after map (unchanged):', numbers);\nconsole.log('Doubled numbers:', doubledNumbers);\n\n// sort(): Sorts in-place\nconst words = ['banana', 'apple', 'cherry'];\nwords.sort(); // ['apple', 'banana', 'cherry']\nconsole.log('Sorted words (in-place):', words);\n\nconst unsortedNumbers = [10, 2, 8, 1, 15];\n// Default sort converts to string: [1, 10, 15, 2, 8]\nunsortedNumbers.sort();\nconsole.log('Default string sort:', unsortedNumbers);\n\n// Numeric sort:\nunsortedNumbers.sort((a, b) => a - b); // [1, 2, 8, 10, 15]\nconsole.log('Numeric sort (ascending):', unsortedNumbers);\n\n// reverse(): Reverses in-place\nunsortedNumbers.reverse(); // [15, 10, 8, 2, 1]\nconsole.log('Reversed numbers (in-place):', unsortedNumbers);",
              "explanation": "`forEach` is for iteration without modifying or creating a new array. `map` is for creating a new array where each element is transformed. `sort` and `reverse` modify the array in place; `sort` requires a custom comparison function for correct numeric sorting.",
              "language": "typescript"
            },
            {
              "id": "example_array_iteration_transformation_2",
              "title": "split, join, reduce",
              "code": "const sentence = \"Hello world, how are you?\";\n\n// split(): String to Array\nconst wordsArray = sentence.split(' '); // ['Hello', 'world,', 'how', 'are', 'you?']\nconsole.log('Words array:', wordsArray);\n\nconst charsArray = sentence.split(''); // ['H', 'e', 'l', 'l', 'o', ..., '?']\nconsole.log('Characters array (first 5):', charsArray.slice(0,5));\n\nconst commaSeparated = \"apple,banana,orange\";\nconst fruits = commaSeparated.split(','); // ['apple', 'banana', 'orange']\nconsole.log('Fruits array:', fruits);\n\n// join(): Array to String\nconst rejoinedSentence = wordsArray.join('-'); // 'Hello-world,-how-are-you?'\nconsole.log('Rejoined sentence:', rejoinedSentence);\n\nconst csvString = fruits.join(';'); // 'apple;banana;orange'\nconsole.log('CSV string:', csvString);\n\nconst numbersToReduce = [1, 2, 3, 4, 5];\n\n// reduce(): Summing elements\nconst sumOfNumbers = numbersToReduce.reduce((accumulator, currentValue) => accumulator + currentValue, 0); // 15\nconsole.log('Sum using reduce:', sumOfNumbers);\n\n// reduce(): Flattening an array of arrays\nconst arrayOfArrays = [[1, 2], [3, 4], [5]];\nconst flattenedArray = arrayOfArrays.reduce((acc, curr) => acc.concat(curr), []); // [1, 2, 3, 4, 5]\nconsole.log('Flattened array:', flattenedArray);\n\n// reduce(): Counting occurrences\nconst fruitBasket = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple'];\nconst fruitCount = fruitBasket.reduce((count, fruit) => {\n  count[fruit] = (count[fruit] || 0) + 1;\n  return count;\n}, {}); // { apple: 3, banana: 2, orange: 1 }\nconsole.log('Fruit counts:', fruitCount);",
              "explanation": "`split` and `join` are essential for string-array conversions. `reduce` is a powerful method for aggregating array elements into a single value or object. It's highly versatile, capable of performing sums, transforming arrays into objects, or flattening arrays.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_array_iteration_transformation_1",
            "question_array_iteration_transformation_2",
            "question_array_iteration_transformation_3",
            "question_array_iteration_transformation_4",
            "question_array_iteration_transformation_5",
            "question_array_iteration_transformation_6",
            "question_array_iteration_transformation_7",
            "question_array_iteration_transformation_8"
          ],
          "relatedTasks": [
            "task_array_iteration_transformation_1",
            "task_array_iteration_transformation_2"
          ],
          "tags": [
            "Array Methods",
            "Iteration",
            "Transformation",
            "Higher-Order Functions",
            "String Conversion"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "callback_functions",
            "javascript_strings"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_aggregation",
            "complex_data_processing",
            "functional_programming"
          ]
        },
        {
          "id": "theory_additional_array_methods",
          "title": "Additional Array Utility Methods",
          "content": "This section covers several utility methods that provide additional functionalities for working with arrays, including type checking, conditional checks, and in-place content manipulation.\n\n## Key Concepts\n- **`Array.isArray(arr)`**: A static method of the `Array` object that determines whether the passed value is an `Array`. It returns `true` if the value is an array, `false` otherwise. This is the most reliable way to check if a variable is an array, especially when dealing with multiple frames or contexts.\n- **`arr.some(fn)`**: Tests whether at least one element in the array passes the test implemented by the provided `fn` (callback function). It returns `true` if it finds an element for which the callback returns `truthy` value; otherwise, it returns `false`. It stops iterating as soon as the callback returns `true`.\n- **`arr.every(fn)`**: Tests whether all elements in the array pass the test implemented by the provided `fn` (callback function). It returns `true` if the callback returns `truthy` for all elements; otherwise, it returns `false`. It stops iterating as soon as the callback returns `false`.\n- **`arr.fill(value, start, end)`**: Fills all the elements of an array from a `start` index to an `end` index with a static `value`. It modifies the original array.\n  - `value`: Value to fill the array with.\n  - `start`: Start index (inclusive). Default is 0.\n  - `end`: End index (exclusive). Default is `array.length`.\n- **`arr.copyWithin(target, start, end)`**: Copies part of an array to another location in the same array and returns it, without modifying its length. It modifies the original array.\n  - `target`: Zero-based index at which to copy the sequence to.\n  - `start`: Zero-based index at which to start copying elements from (inclusive).\n  - `end`: Zero-based index at which to end copying elements from (exclusive).",
          "examples": [
            {
              "id": "example_additional_array_1",
              "title": "Array.isArray, some, every",
              "code": "const numbers = [1, 2, 3, 4, 5];\nconst mixed = [1, 'two', 3];\nconst notAnArray = {};\n\n// Array.isArray()\nconsole.log('Is numbers an Array?', Array.isArray(numbers)); // true\nconsole.log('Is notAnArray an Array?', Array.isArray(notAnArray)); // false\nconsole.log('Is a string an Array?', Array.isArray('hello')); // false\n\n// some()\nconst hasEven = numbers.some(num => num % 2 === 0); // true (because 2, 4 are even)\nconsole.log('Does numbers have an even number?', hasEven);\n\nconst hasNegative = numbers.some(num => num < 0); // false\nconsole.log('Does numbers have a negative number?', hasNegative);\n\n// every()\nconst allEven = numbers.every(num => num % 2 === 0); // false (because 1, 3, 5 are odd)\nconsole.log('Are all numbers even?', allEven);\n\nconst allPositive = numbers.every(num => num > 0); // true\nconsole.log('Are all numbers positive?', allPositive);",
              "explanation": "`Array.isArray` is the robust way to check for array types. `some` is useful for checking if at least one element meets a condition, while `every` checks if all elements meet it. Both are short-circuiting.",
              "language": "typescript"
            },
            {
              "id": "example_additional_array_2",
              "title": "fill, copyWithin",
              "code": "const arrayToFill = [1, 2, 3, 4, 5];\n\n// fill(value, start, end)\narrayToFill.fill(0, 2, 4); // Fills with 0 from index 2 (inclusive) to 4 (exclusive)\n// arrayToFill is now [1, 2, 0, 0, 5]\nconsole.log('After fill(0, 2, 4):', arrayToFill);\n\nconst arrayToFillFull = [1, 2, 3];\narrayToFillFull.fill(7); // Fills the entire array with 7\n// arrayToFillFull is now [7, 7, 7]\nconsole.log('After fill(7):', arrayToFillFull);\n\nconst arrCopy = ['a', 'b', 'c', 'd', 'e'];\n\n// copyWithin(target, start, end)\narrCopy.copyWithin(0, 3, 5); // Copies elements from index 3 (inclusive) to 5 (exclusive) to index 0\n// Elements 'd', 'e' are copied to index 0, 1 respectively.\n// arrCopy is now ['d', 'e', 'c', 'd', 'e']\nconsole.log('After copyWithin(0, 3, 5):', arrCopy);\n\nconst anotherArr = [1, 2, 3, 4, 5, 6, 7];\nanotherArr.copyWithin(3, 0, 3); // Copies [1, 2, 3] to index 3\n// anotherArr is now [1, 2, 3, 1, 2, 3, 7]\nconsole.log('After copyWithin(3, 0, 3):', anotherArr);",
              "explanation": "`fill` is used for mass assignment of a static value to a portion or the entirety of an array. `copyWithin` is a more niche method for in-place internal copying of array segments, useful for specific memory-efficient operations or buffer management scenarios. Both mutate the original array.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_additional_array_1",
            "question_additional_array_2",
            "question_additional_array_3",
            "question_additional_array_4",
            "question_additional_array_5",
            "question_additional_array_6"
          ],
          "relatedTasks": [
            "task_additional_array_1",
            "task_additional_array_2"
          ],
          "tags": [
            "Array Methods",
            "Type Checking",
            "Conditional Logic",
            "In-place Modification"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "javascript_booleans",
            "callback_functions"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "validation",
            "data_integrity",
            "array_optimization"
          ]
        },
        {
          "id": "theory_mutating_vs_non_mutating_methods",
          "title": "Mutating vs. Non-Mutating Array Methods",
          "content": "A crucial distinction in JavaScript array methods is whether they modify (mutate) the original array or return a new array, leaving the original untouched. Understanding this difference is vital for writing predictable and bug-free code, especially in functional programming contexts or when working with immutable state (e.g., in React).\n\n## Key Concepts\n- **Mutating Methods (Modify in-place)**: These methods directly alter the original array. Changes are visible on the original array reference.\n  - `push()`: Adds to the end.\n  - `pop()`: Removes from the end.\n  - `shift()`: Removes from the beginning.\n  - `unshift()`: Adds to the beginning.\n  - `splice()`: Adds/removes elements at any position.\n  - `sort()`: Sorts the array.\n  - `reverse()`: Reverses the array.\n  - `fill()`: Fills elements with a static value.\n  - `copyWithin()`: Copies elements within the array.\n\n- **Non-Mutating Methods (Return new array)**: These methods do not modify the original array. Instead, they create and return a brand new array with the results of the operation.\n  - `slice()`: Creates a shallow copy of a portion of an array.\n  - `concat()`: Merges arrays into a new array.\n  - `map()`: Creates a new array with the results of a function call on every element.\n  - `filter()`: Creates a new array with all elements that pass a test.\n  - `reduce()`: Reduces the array to a single value (or object/array), not directly mutating the array it operates on (though the accumulator can be modified).\n  - `indexOf()`, `lastIndexOf()`, `includes()`, `find()`, `findIndex()`, `forEach()`, `some()`, `every()`: These methods generally do not modify the array; they either return a value (index, boolean, element) or perform a side effect without altering the array's structure.",
          "examples": [
            {
              "id": "example_mutating_vs_non_mutating_1",
              "title": "Demonstrating Mutation",
              "code": "let originalArray = [1, 2, 3];\n\n// Mutating method: push()\nconst pushedResult = originalArray.push(4);\nconsole.log('After push():', originalArray); // [1, 2, 3, 4]\nconsole.log('Returned from push():', pushedResult); // 4 (new length)\n\nlet anotherArray = ['a', 'b', 'c'];\n\n// Mutating method: sort()\nanotherArray.sort();\nconsole.log('After sort():', anotherArray); // ['a', 'b', 'c'] (already sorted)\n\nlet numbersToSort = [3, 1, 2];\nnumbersToSort.sort((a, b) => a - b);\nconsole.log('After numeric sort():', numbersToSort); // [1, 2, 3]\n\nlet yetAnotherArray = [10, 20, 30];\nconst removedElement = yetAnotherArray.pop();\nconsole.log('After pop():', yetAnotherArray); // [10, 20]\nconsole.log('Removed element:', removedElement); // 30",
              "explanation": "This example clearly shows that after calling `push()`, `sort()`, or `pop()`, the `originalArray`, `anotherArray`, `numbersToSort`, and `yetAnotherArray` variables now refer to the modified arrays. The changes are applied directly to the array instance.",
              "language": "typescript"
            },
            {
              "id": "example_mutating_vs_non_mutating_2",
              "title": "Demonstrating Non-Mutation",
              "code": "const initialArray = [1, 2, 3, 4, 5];\n\n// Non-mutating method: slice()\nconst slicedArray = initialArray.slice(1, 4);\nconsole.log('Initial array after slice():', initialArray); // [1, 2, 3, 4, 5] (unchanged)\nconsole.log('New sliced array:', slicedArray); // [2, 3, 4]\n\n// Non-mutating method: map()\nconst mappedArray = initialArray.map(num => num * 2);\nconsole.log('Initial array after map():', initialArray); // [1, 2, 3, 4, 5] (unchanged)\nconsole.log('New mapped array:', mappedArray); // [2, 4, 6, 8, 10]\n\n// Non-mutating method: concat()\nconst newCombinedArray = initialArray.concat([6, 7]);\nconsole.log('Initial array after concat():', initialArray); // [1, 2, 3, 4, 5] (unchanged)\nconsole.log('New combined array:', newCombinedArray); // [1, 2, 3, 4, 5, 6, 7]\n\n// Non-mutating (returns a value, doesn't modify array): find()\nconst foundElement = initialArray.find(num => num === 3);\nconsole.log('Initial array after find():', initialArray); // [1, 2, 3, 4, 5] (unchanged)\nconsole.log('Found element:', foundElement); // 3",
              "explanation": "This example illustrates that `slice()`, `map()`, and `concat()` create new arrays and return them, leaving the `initialArray` completely unmodified. `find()` also does not modify the array; it simply returns a value based on its contents.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_mutating_vs_non_mutating_1",
            "question_mutating_vs_non_mutating_2",
            "question_mutating_vs_non_mutating_3",
            "question_mutating_vs_non_mutating_4",
            "question_mutating_vs_non_mutating_5"
          ],
          "relatedTasks": [
            "task_mutating_vs_non_mutating_1"
          ],
          "tags": [
            "Array Methods",
            "Mutation",
            "Immutability",
            "Side Effects",
            "Functional Programming"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_variables",
            "javascript_references"
          ],
          "complexity": 7,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_state_management",
            "redux_fundamentals",
            "predictable_code"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_array_modification_1",
          "topic": "Array Modification: push/pop/shift/unshift",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference in behavior between `push()` and `unshift()` array methods?",
          "answer": "`push()` adds elements to the end of an array, while `unshift()` adds elements to the beginning of an array. Both methods modify the original array.",
          "analysisPoints": [
            "Understanding of array endpoints.",
            "Recall of specific method names and their actions.",
            "Recognition that both mutate the original array."
          ],
          "keyConcepts": [
            "push",
            "unshift",
            "array mutation",
            "array elements"
          ],
          "evaluationCriteria": [
            "Correctly identifies insertion point.",
            "Mentions array modification."
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Mutation",
            "Easy"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_modification_2",
          "topic": "Array Modification: splice() vs slice()",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements accurately describes the difference between `Array.prototype.splice()` and `Array.prototype.slice()` in JavaScript?",
          "answer": "`splice()` modifies the original array by adding, removing, or replacing elements, while `slice()` returns a new array containing a portion of the original array without modifying it.",
          "options": [
            "`splice()` returns a new array with elements removed, while `slice()` modifies the original array by inserting elements.",
            "`splice()` is used to merge multiple arrays, while `slice()` extracts a single element.",
            "`splice()` modifies the original array by adding, removing, or replacing elements, while `slice()` returns a new array containing a portion of the original array without modifying it.",
            "Both `splice()` and `slice()` modify the original array, but `splice()` only removes elements while `slice()` only adds them."
          ],
          "analysisPoints": [
            "Distinguishing between mutating and non-mutating methods.",
            "Understanding the primary purpose of each method.",
            "Correctly identifying parameters and return values (implicit in behavior)."
          ],
          "keyConcepts": [
            "splice",
            "slice",
            "array mutation",
            "new array",
            "shallow copy"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles",
            "Ability to distinguish between similar concepts",
            "Recognition of edge cases",
            "Application of best practices"
          ],
          "example": "```typescript\nconst originalArr = [1, 2, 3, 4, 5];\n\n// Using splice()\nconst removed = originalArr.splice(2, 1, 6, 7); // Removes 3, inserts 6, 7\nconsole.log(originalArr); // [1, 2, 6, 7, 4, 5] (original array modified)\nconsole.log(removed);     // [3] (returns removed elements)\n\n// Using slice()\nconst newArr = originalArr.slice(1, 3); // Copies elements from index 1 up to (but not including) 3\nconsole.log(originalArr); // [1, 2, 6, 7, 4, 5] (original array unchanged)\nconsole.log(newArr);      // [2, 6] (returns a new array)\n```\nThe example illustrates that `splice` directly changes `originalArr` and returns the removed items, whereas `slice` creates `newArr` leaving `originalArr` intact.",
          "tags": [
            "Array Methods",
            "Mutation",
            "Non-Mutation",
            "MCQ",
            "Medium"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_modification_3",
          "topic": "Array Modification: splice() parameters",
          "level": "medium",
          "type": "open",
          "question": "Explain the three main parameters of the `splice()` method: `start`, `deleteCount`, and `items`. Provide an example for each of the following scenarios using `splice()`:\n1. Removing elements only.\n2. Inserting elements only.\n3. Replacing existing elements.",
          "answer": null,
          "analysisPoints": [
            "Correctly defines each parameter of `splice`.",
            "Provides accurate code examples for removal, insertion, and replacement.",
            "Demonstrates understanding of how `splice` mutates the array."
          ],
          "keyConcepts": [
            "splice",
            "array mutation",
            "deleteCount",
            "start index",
            "insert items"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation",
            "Accurate code examples",
            "Correct application of parameters"
          ],
          "example": "```typescript\n// Initial array\nlet fruits = ['apple', 'banana', 'cherry', 'date', 'elderberry'];\n\n// 1. Removing elements only: Remove 2 elements starting from index 2 ('cherry', 'date')\nlet removedFruits = fruits.splice(2, 2);\nconsole.log('After removing:', fruits);        // Output: ['apple', 'banana', 'elderberry']\nconsole.log('Removed elements:', removedFruits); // Output: ['cherry', 'date']\n\n// 2. Inserting elements only: Insert 'grape' and 'fig' at index 1\nlet originalFruits = ['apple', 'banana', 'cherry'];\nlet insertedFruits = originalFruits.splice(1, 0, 'grape', 'fig');\nconsole.log('After inserting:', originalFruits); // Output: ['apple', 'grape', 'fig', 'banana', 'cherry']\nconsole.log('Removed elements (none):', insertedFruits); // Output: []\n\n// 3. Replacing existing elements: Replace 1 element at index 0 ('apple') with 'avocado'\nlet replaceFruits = ['apple', 'banana', 'cherry'];\nlet replacedElement = replaceFruits.splice(0, 1, 'avocado');\nconsole.log('After replacing:', replaceFruits);  // Output: ['avocado', 'banana', 'cherry']\nconsole.log('Replaced element:', replacedElement); // Output: ['apple']\n```",
          "tags": [
            "Array Methods",
            "Splice",
            "Mutation",
            "Open-Ended",
            "Medium"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_modification_4",
          "topic": "Array Modification: concat()",
          "level": "easy",
          "type": "flashcard",
          "question": "Does `concat()` modify the original array, and what does it return?",
          "answer": "No, `concat()` does not modify the original array. It returns a *new* array containing the combined elements of the original array and any arrays/values passed as arguments.",
          "analysisPoints": [
            "Understanding `concat`'s non-mutating nature.",
            "Recall of `concat`'s return value."
          ],
          "keyConcepts": [
            "concat",
            "non-mutation",
            "new array"
          ],
          "evaluationCriteria": [
            "Correctly identifies non-mutating behavior.",
            "Correctly identifies return type."
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Non-Mutation",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_modification_5",
          "topic": "Array Modification: Array length property",
          "level": "easy",
          "type": "mcq",
          "question": "After executing the following code, what will be the value of `arr` and `result`?\n```javascript\nconst arr = [1, 2, 3];\nconst result = arr.push(4, 5);\n```",
          "answer": "`arr` will be `[1, 2, 3, 4, 5]` and `result` will be `5`.",
          "options": [
            "`arr` will be `[1, 2, 3]` and `result` will be `[4, 5]`.",
            "`arr` will be `[1, 2, 3, 4, 5]` and `result` will be `5`.",
            "`arr` will be `[1, 2, 3, 4, 5]` and `result` will be `undefined`.",
            "`arr` will be `[1, 2, 3]` and `result` will be `[1, 2, 3, 4, 5]`."
          ],
          "analysisPoints": [
            "Understanding that `push()` modifies the array in-place.",
            "Knowing that `push()` returns the new length of the array."
          ],
          "keyConcepts": [
            "push",
            "array mutation",
            "return value"
          ],
          "evaluationCriteria": [
            "Correctly predicts array state",
            "Correctly identifies return value",
            "Understanding of `push` side effects"
          ],
          "example": "The `push()` method adds one or more elements to the end of an array and returns the new length of the array. Therefore, `arr` is modified to include `4` and `5`, and its new length is `5`, which is assigned to `result`.",
          "tags": [
            "Array Methods",
            "Mutation",
            "MCQ",
            "Easy"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_modification_6",
          "topic": "Array Modification: Chaining non-mutating methods",
          "level": "medium",
          "type": "code",
          "question": "Given an array of numbers, use chaining of non-mutating array methods (`slice`, `concat`, etc.) to create a new array that contains:\n1. The first three elements of the original array.\n2. Followed by the number `100`.\n3. Followed by the last two elements of the original array.\n\nYour solution should *not* modify the original array.",
          "answer": "```typescript\nfunction processArray(arr) {\n  if (!Array.isArray(arr) || arr.length < 5) {\n    // Handle cases where array is too short for slice(0,3) and slice(-2)\n    // Or simply define expected behavior for short arrays.\n    return arr.slice(0, Math.min(arr.length, 3)).concat(100, arr.slice(Math.max(0, arr.length - 2)));\n  }\n  return arr.slice(0, 3).concat(100, arr.slice(-2));\n}\n\nconst originalArray = [1, 2, 3, 4, 5, 6, 7];\nconst newArray = processArray(originalArray);\n\nconsole.log('Original array:', originalArray); // Expected: [1, 2, 3, 4, 5, 6, 7]\nconsole.log('New array:', newArray);         // Expected: [1, 2, 3, 100, 6, 7]\n\nconst shortArray = [1, 2, 3];\nconst newShortArray = processArray(shortArray);\nconsole.log('Short original array:', shortArray); // Expected: [1, 2, 3]\nconsole.log('New short array:', newShortArray);   // Expected: [1, 2, 3, 100] (since slice(-2) returns [] if too short)\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `slice()` to extract parts of the array.",
            "Correctly uses `concat()` to combine segments and new elements.",
            "Ensures the original array is not mutated.",
            "Handles edge cases like arrays shorter than expected segments."
          ],
          "keyConcepts": [
            "slice",
            "concat",
            "non-mutation",
            "array chaining"
          ],
          "evaluationCriteria": [
            "Correct functionality",
            "Adherence to non-mutating constraint",
            "Efficiency (method chaining)",
            "Edge case handling"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Non-Mutation",
            "Chaining",
            "Code Challenge",
            "Medium"
          ],
          "prerequisites": [
            "javascript_arrays",
            "javascript_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_modification_7",
          "topic": "Array Modification: Performance Considerations",
          "level": "hard",
          "type": "open",
          "question": "When frequently adding or removing elements from the beginning of a large array, `shift()` or `unshift()` can be inefficient. Why is this the case, and what alternative data structure or approach might be more suitable in JavaScript for such operations?",
          "answer": null,
          "analysisPoints": [
            "Explains the underlying reason for `shift`/`unshift` inefficiency (re-indexing).",
            "Suggests alternative data structures (e.g., linked list, `Deque` if available/simulated) or approaches (e.g., using `push`/`pop` with `reverse`, or maintaining two arrays for front/back).",
            "Demonstrates awareness of performance implications of array operations."
          ],
          "keyConcepts": [
            "shift",
            "unshift",
            "performance",
            "array re-indexing",
            "data structures"
          ],
          "evaluationCriteria": [
            "Depth of explanation",
            "Creativity and relevance of alternative solutions",
            "Understanding of performance trade-offs"
          ],
          "example": "When `shift()` or `unshift()` are used, JavaScript needs to re-index all subsequent elements in the array. For example, if you `shift()` an element from an array of 10,000 items, all 9,999 remaining elements need their indices updated, which is an O(N) operation. Similarly, `unshift()` requires shifting all existing elements to make space at the beginning.\n\nFor frequent operations at both ends, a **doubly linked list** would be more efficient, as adding/removing from ends would be O(1). In JavaScript, you'd typically implement a linked list yourself using objects. Alternatively, for queue-like behavior (FIFO), one might consider a fixed-size buffer or a system where `push` and `pop` are favored, perhaps by reversing the array conceptually or splitting it into two arrays (one for the head, one for the tail) and managing them, though this adds complexity. For many common frontend tasks, array sizes are small enough that the performance impact is negligible, but it's a critical consideration for large datasets or high-frequency operations.",
          "tags": [
            "Array Methods",
            "Performance",
            "Data Structures",
            "Open-Ended",
            "Hard"
          ],
          "prerequisites": [
            "javascript_arrays",
            "data_structures_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_array_searching_1",
          "topic": "Array Searching: indexOf vs includes vs find",
          "level": "medium",
          "type": "open",
          "question": "Describe the main use case for `indexOf()`, `includes()`, and `find()` methods. When would you choose one over the others, especially considering strict equality and custom comparison logic?",
          "answer": null,
          "analysisPoints": [
            "Explains `indexOf()` for finding the first index of a primitive value (strict equality, no custom logic).",
            "Explains `includes()` for simply checking existence of a primitive value (strict equality, handles NaN).",
            "Explains `find()` for finding the first element (object or primitive) that satisfies a custom condition (callback function).",
            "Provides scenarios where each method is most appropriate."
          ],
          "keyConcepts": [
            "indexOf",
            "includes",
            "find",
            "strict equality",
            "callback function",
            "primitive vs object"
          ],
          "evaluationCriteria": [
            "Clear differentiation of use cases",
            "Accuracy regarding comparison logic",
            "Practical applicability"
          ],
          "example": "1. **`indexOf(item, pos)`**: Use when you need the *index* of a specific primitive value. It uses strict equality (`===`) but doesn't handle `NaN` correctly (returns -1 for `NaN`).\n   *Example*: Finding the position of a specific string in an array of strings: `const idx = colors.indexOf('blue');`\n\n2. **`includes(value)`**: Use when you simply need to check if an array *contains* a specific primitive value. It's concise and handles `NaN` correctly. It also uses strict equality (`===`).\n   *Example*: Checking if a user's permissions array includes 'admin': `if (permissions.includes('admin')) { ... }`\n\n3. **`find(func)`**: Use when you need to find the *first element* that satisfies a *custom condition* defined by a callback function. This is essential for searching arrays of objects or when the search logic is more complex than simple equality.\n   *Example*: Finding the first product in an array of product objects that costs more than $100: `const expensiveProduct = products.find(p => p.price > 100);`\n\nChoose `find()` when you need complex logic or are dealing with objects. Choose `includes()` for simple existence checks of primitive values, especially if `NaN` might be involved. Choose `indexOf()` when you need the specific index of a primitive value and `NaN` is not a concern.",
          "tags": [
            "Array Methods",
            "Searching",
            "Higher-Order Functions",
            "Open-Ended",
            "Medium"
          ],
          "prerequisites": [
            "javascript_functions",
            "callback_functions"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_searching_2",
          "topic": "Array Searching: find vs filter",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following array of users:\n```javascript\nconst users = [\n  { id: 1, name: 'Alice', active: true },\n  { id: 2, name: 'Bob', active: false },\n  { id: 3, name: 'Charlie', active: true }\n];\n```\nWhich method would you use if you want to get *all* active users, and what would be the expected output?",
          "answer": "`filter()`: `[{ id: 1, name: 'Alice', active: true }, { id: 3, name: 'Charlie', active: true }]`",
          "options": [
            "`find()`: `{ id: 1, name: 'Alice', active: true }`",
            "`map()`: `[true, false, true]`",
            "`filter()`: `[{ id: 1, name: 'Alice', active: true }, { id: 3, name: 'Charlie', active: true }]`",
            "`forEach()`: `undefined`"
          ],
          "analysisPoints": [
            "Understanding `filter()`'s purpose to return a new array of *all* matching elements.",
            "Distinguishing `filter()` from `find()` (which returns only the first).",
            "Understanding `map()`'s role in transformation, not filtering.",
            "Understanding `forEach()`'s role in iteration without returning a new array."
          ],
          "keyConcepts": [
            "filter",
            "find",
            "map",
            "forEach",
            "higher-order functions"
          ],
          "evaluationCriteria": [
            "Correct method selection",
            "Accurate prediction of output",
            "Understanding of method return values"
          ],
          "example": "The `filter()` method creates a new array with all elements that pass the test implemented by the provided function. Since the question asks for *all* active users, `filter()` is the appropriate method. `find()` would only return the *first* active user. `map()` transforms each element but doesn't filter them, and `forEach()` doesn't return a new array.",
          "tags": [
            "Array Methods",
            "Filtering",
            "Higher-Order Functions",
            "MCQ",
            "Medium"
          ],
          "prerequisites": [
            "javascript_functions",
            "callback_functions"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_searching_3",
          "topic": "Array Searching: findIndex",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary use of `findIndex()` and what does it return if no element satisfies the condition?",
          "answer": "`findIndex()` is used to find the *index* of the first element in an array that satisfies a provided testing function. If no elements satisfy the condition, it returns `-1`.",
          "analysisPoints": [
            "Recall of `findIndex` purpose.",
            "Knowledge of its return value for non-matching elements."
          ],
          "keyConcepts": [
            "findIndex",
            "index",
            "callback function",
            "-1 return"
          ],
          "evaluationCriteria": [
            "Correctly identifies purpose.",
            "Correctly identifies return value on failure."
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Searching",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_searching_4",
          "topic": "Array Searching: indexOf vs includes for NaN",
          "level": "medium",
          "type": "code",
          "question": "Demonstrate the behavior of `indexOf()` versus `includes()` when searching for `NaN` in an array. Explain why their behaviors differ.",
          "answer": "```typescript\nconst values = [1, 2, NaN, 4, 5];\n\nconsole.log('indexOf(NaN):', values.indexOf(NaN));   // Output: -1\nconsole.log('includes(NaN):', values.includes(NaN)); // Output: true\n\n/*\nExplanation:\n\n`indexOf()` uses strict equality (===) for comparison. In JavaScript, NaN is the only value that is not equal to itself (NaN !== NaN). Therefore, `indexOf()` cannot find NaN using strict equality, resulting in -1.\n\n`includes()` uses a different comparison algorithm, specifically the SameValueZero algorithm. This algorithm treats NaN as equal to NaN. Hence, `includes()` can correctly find NaN in an array and returns true if it exists.\n*/\n```",
          "options": [],
          "analysisPoints": [
            "Correctly demonstrates `indexOf(NaN)` returning -1.",
            "Correctly demonstrates `includes(NaN)` returning true.",
            "Explains the underlying comparison mechanisms (`===` vs. SameValueZero)."
          ],
          "keyConcepts": [
            "indexOf",
            "includes",
            "NaN",
            "strict equality",
            "SameValueZero",
            "comparison"
          ],
          "evaluationCriteria": [
            "Accurate code demonstration",
            "Clear and correct explanation of underlying principles",
            "Understanding of JavaScript's `NaN` behavior"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Searching",
            "NaN",
            "Code Challenge",
            "Medium"
          ],
          "prerequisites": [
            "javascript_data_types",
            "javascript_equality"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_searching_5",
          "topic": "Array Searching: find vs filter return types",
          "level": "easy",
          "type": "mcq",
          "question": "What is the return type of `Array.prototype.find()` and `Array.prototype.filter()` respectively?",
          "answer": "`find()` returns the first matching element or `undefined`; `filter()` returns a new array of all matching elements.",
          "options": [
            "`find()` returns a new array; `filter()` returns a single element.",
            "`find()` returns the first matching element or `undefined`; `filter()` returns a new array of all matching elements.",
            "Both `find()` and `filter()` return a new array.",
            "Both `find()` and `filter()` return the first matching element."
          ],
          "analysisPoints": [
            "Knowledge of `find()`'s return value (element or undefined).",
            "Knowledge of `filter()`'s return value (new array).",
            "Understanding that `filter()` always returns an array, even if empty."
          ],
          "keyConcepts": [
            "find",
            "filter",
            "return type",
            "array vs element"
          ],
          "evaluationCriteria": [
            "Accurate return type identification",
            "Distinction between single element and array return"
          ],
          "example": "```typescript\nconst numbers = [10, 20, 30];\nconst found = numbers.find(n => n > 15); // found is 20 (a number)\nconst filtered = numbers.filter(n => n > 15); // filtered is [20, 30] (an array)\nconst notFound = numbers.find(n => n > 50); // notFound is undefined\nconst notFiltered = numbers.filter(n => n > 50); // notFiltered is [] (an empty array)\n```",
          "tags": [
            "Array Methods",
            "Searching",
            "Filtering",
            "MCQ",
            "Easy"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_searching_6",
          "topic": "Array Searching: Using callback functions",
          "level": "medium",
          "type": "code",
          "question": "Given an array of objects representing books, write a JavaScript function that uses a suitable array method to find the first book published after the year 2000. If no such book exists, it should return `null`.\n\n```typescript\nconst books = [\n  { title: 'The Lord of the Rings', author: 'J.R.R. Tolkien', year: 1954 },\n  { title: 'Sapiens', author: 'Yuval Noah Harari', year: 2011 },\n  { title: 'Dune', author: 'Frank Herbert', year: 1965 },\n  { title: 'Educated', author: 'Tara Westover', year: 2018 }\n];\n```",
          "answer": "```typescript\nfunction findFirstModernBook(books) {\n  const modernBook = books.find(book => book.year > 2000);\n  return modernBook !== undefined ? modernBook : null;\n}\n\nconst books = [\n  { title: 'The Lord of the Rings', author: 'J.R.R. Tolkien', year: 1954 },\n  { title: 'Sapiens', author: 'Yuval Noah Harari', year: 2011 },\n  { title: 'Dune', author: 'Frank Herbert', year: 1965 },\n  { title: 'Educated', author: 'Tara Westover', year: 2018 }\n];\n\nconst firstModernBook = findFirstModernBook(books);\nconsole.log(firstModernBook); // Expected: { title: 'Sapiens', author: 'Yuval Noah Harari', year: 2011 }\n\nconst oldBooks = [\n  { title: '1984', author: 'George Orwell', year: 1949 },\n  { title: 'Brave New World', author: 'Aldous Huxley', year: 1932 }\n];\nconst noModernBook = findFirstModernBook(oldBooks);\nconsole.log(noModernBook); // Expected: null\n```",
          "options": [],
          "analysisPoints": [
            "Correct selection of `find()` for finding a single matching element.",
            "Proper implementation of the callback function with the condition.",
            "Correct handling of the `undefined` return from `find()` when no match is found, converting it to `null` as per requirements."
          ],
          "keyConcepts": [
            "find",
            "callback function",
            "object property access",
            "conditional logic"
          ],
          "evaluationCriteria": [
            "Correct array method usage",
            "Accurate conditional logic",
            "Correct return value for all cases"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Searching",
            "Code Challenge",
            "Medium"
          ],
          "prerequisites": [
            "javascript_objects",
            "javascript_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_iteration_transformation_1",
          "topic": "Array Iteration: forEach()",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the return value of `forEach()`, and when is it typically used?",
          "answer": "`forEach()` returns `undefined`. It's typically used when you need to iterate over an array and perform side effects (e.g., logging, DOM manipulation) for each element, without creating a new array or returning a value from the iteration itself.",
          "analysisPoints": [
            "Knowledge of `forEach`'s `undefined` return.",
            "Understanding of its primary use case (side effects)."
          ],
          "keyConcepts": [
            "forEach",
            "undefined",
            "side effects",
            "iteration"
          ],
          "evaluationCriteria": [
            "Accurate return value",
            "Correct use case explanation."
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Iteration",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_iteration_transformation_2",
          "topic": "Array Transformation: map()",
          "level": "medium",
          "type": "mcq",
          "question": "Given the array `const numbers = [1, 2, 3];`, what will be the output of `numbers.map(num => num * 2);` and what will `numbers` itself be after this operation?",
          "answer": "Output: `[2, 4, 6]`; `numbers` will be `[1, 2, 3]`",
          "options": [
            "Output: `[1, 2, 3, 2, 4, 6]`; `numbers` will be `[1, 2, 3, 2, 4, 6]`",
            "Output: `[2, 4, 6]`; `numbers` will be `[2, 4, 6]`",
            "Output: `[2, 4, 6]`; `numbers` will be `[1, 2, 3]`",
            "Output: `undefined`; `numbers` will be `[1, 2, 3]`"
          ],
          "analysisPoints": [
            "Understanding that `map()` returns a *new* array.",
            "Knowing that `map()` does *not* mutate the original array.",
            "Correctly applying the transformation function to each element."
          ],
          "keyConcepts": [
            "map",
            "non-mutation",
            "new array",
            "transformation"
          ],
          "evaluationCriteria": [
            "Correctly identifies transformation result",
            "Accurately assesses original array state",
            "Understands non-mutating behavior"
          ],
          "example": "The `map()` method creates a *new array* populated with the results of calling a provided function on every element in the calling array. It does not modify the original array. So, `numbers` remains `[1, 2, 3]`, and a new array `[2, 4, 6]` is returned.",
          "tags": [
            "Array Methods",
            "Transformation",
            "Non-Mutation",
            "MCQ",
            "Medium"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_iteration_transformation_3",
          "topic": "Array Transformation: sort()",
          "level": "medium",
          "type": "open",
          "question": "Explain how `sort()` works by default on an array of numbers (e.g., `[10, 2, 1, 20]`). Then, provide the correct way to numerically sort this array in ascending order.",
          "answer": null,
          "analysisPoints": [
            "Explains default `sort()` behavior (string conversion, UTF-16 comparison).",
            "Provides the correct comparison function `(a, b) => a - b` for numeric ascending sort.",
            "Demonstrates the correct code example and expected output."
          ],
          "keyConcepts": [
            "sort",
            "in-place mutation",
            "comparison function",
            "string comparison",
            "numeric sort"
          ],
          "evaluationCriteria": [
            "Accurate explanation of default sort",
            "Correct comparison function for numeric sort",
            "Clear code example"
          ],
          "example": "By default, the `sort()` method sorts elements as strings in ascending order. This means that numbers are converted to strings and then compared based on their Unicode code points. For example, `[10, 2, 1, 20]` would be sorted as `[1, 10, 2, 20]` because '1' comes before '2' and '10' comes before '20' lexicographically.\n\nTo sort numerically in ascending order, you must provide a comparison function. This function takes two arguments (`a` and `b`) and should return:\n- A negative value if `a` should come before `b`\n- A positive value if `b` should come before `a`\n- `0` if `a` and `b` are considered equal.\n\nFor ascending numeric sort, `(a, b) => a - b` is used:\n```typescript\nconst numbers = [10, 2, 1, 20];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers); // Output: [1, 2, 10, 20]\n```",
          "tags": [
            "Array Methods",
            "Sorting",
            "Mutation",
            "Comparison Function",
            "Open-Ended",
            "Medium"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_iteration_transformation_4",
          "topic": "String-Array Conversion: split() and join()",
          "level": "easy",
          "type": "flashcard",
          "question": "How do `split()` and `join()` methods facilitate conversion between strings and arrays?",
          "answer": "`split()` (a String method) converts a string into an array of substrings based on a specified separator. `join()` (an Array method) converts an array of elements into a string, using a specified separator to concatenate them.",
          "analysisPoints": [
            "Understanding of `split` (string to array).",
            "Understanding of `join` (array to string).",
            "Recognition of the role of the separator argument."
          ],
          "keyConcepts": [
            "split",
            "join",
            "string to array",
            "array to string",
            "separator"
          ],
          "evaluationCriteria": [
            "Correctly describes conversion direction",
            "Mentions separator use"
          ],
          "example": null,
          "tags": [
            "String Methods",
            "Array Methods",
            "Conversion",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "javascript_strings"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_iteration_transformation_5",
          "topic": "Array Transformation: reduce()",
          "level": "hard",
          "type": "code",
          "question": "Using the `reduce()` method, write a function `groupObjectsByProperty(arr, propName)` that takes an array of objects and a property name (string), and returns an object where keys are unique values of `propName` and values are arrays of objects that share that `propName` value.\n\nExample Input:\n```typescript\nconst products = [\n  { id: 1, category: 'Electronics', name: 'Laptop' },\n  { id: 2, category: 'Books', name: 'Sapiens' },\n  { id: 3, category: 'Electronics', name: 'Mouse' },\n  { id: 4, category: 'Books', name: 'Dune' },\n  { id: 5, category: 'Home', name: 'Lamp' }\n];\n```\nExpected Output for `groupObjectsByProperty(products, 'category')`:\n```json\n{\n  \"Electronics\": [\n    { \"id\": 1, \"category\": \"Electronics\", \"name\": \"Laptop\" },\n    { \"id\": 3, \"category\": \"Electronics\", \"name\": \"Mouse\" }\n  ],\n  \"Books\": [\n    { \"id\": 2, \"category\": \"Books\", \"name\": \"Sapiens\" },\n    { \"id\": 4, \"category\": \"Books\", \"name\": \"Dune\" }\n  ],\n  \"Home\": [\n    { \"id\": 5, \"category\": \"Home\", \"name\": \"Lamp\" }\n  ]\n}\n```",
          "answer": "```typescript\nfunction groupObjectsByProperty(arr, propName) {\n  if (!Array.isArray(arr) || typeof propName !== 'string') {\n    throw new Error('Invalid input: arr must be an array, propName a string.');\n  }\n\n  return arr.reduce((accumulator, currentObject) => {\n    const key = currentObject[propName];\n    if (key === undefined) {\n      // Handle objects missing the property or null/undefined values\n      // For this problem, we'll just skip them or group under a special key\n      // For simplicity, let's just skip for now, or you could group them under 'other' or similar\n      return accumulator; \n    }\n\n    if (!accumulator[key]) {\n      accumulator[key] = []; // Initialize array for this category if it doesn't exist\n    }\n    accumulator[key].push(currentObject); // Add the current object to its category's array\n    return accumulator;\n  }, {}); // Initial accumulator is an empty object\n}\n\nconst products = [\n  { id: 1, category: 'Electronics', name: 'Laptop' },\n  { id: 2, category: 'Books', name: 'Sapiens' },\n  { id: 3, category: 'Electronics', name: 'Mouse' },\n  { id: 4, category: 'Books', name: 'Dune' },\n  { id: 5, category: 'Home', name: 'Lamp' }\n];\n\nconst groupedByCategory = groupObjectsByProperty(products, 'category');\nconsole.log(JSON.stringify(groupedByCategory, null, 2));\n\nconst groupedById = groupObjectsByProperty(products, 'id');\nconsole.log(JSON.stringify(groupedById, null, 2));\n\nconst invalidProducts = [\n  { id: 1, category: 'Electronics', name: 'Laptop' },\n  { id: 2, name: 'Sapiens' } // Missing category\n];\n// console.log(groupObjectsByProperty(invalidProducts, 'category')); // This would skip the second item due to 'undefined' key handling\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `reduce()` to build an object.",
            "Initializes the accumulator as an empty object (`{}`).",
            "Accesses object properties dynamically using bracket notation (`currentObject[propName]`).",
            "Checks if the category array exists (`!accumulator[key]`) before pushing, creating it if necessary.",
            "Adds the `currentObject` to the correct category array.",
            "Returns the `accumulator` in each iteration."
          ],
          "keyConcepts": [
            "reduce",
            "object grouping",
            "dynamic property access",
            "accumulator",
            "callback function"
          ],
          "evaluationCriteria": [
            "Correct algorithm for grouping",
            "Effective use of `reduce`",
            "Handling of object properties",
            "Robustness (e.g., input validation/missing property handling)"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Reduce",
            "Object Transformation",
            "Code Challenge",
            "Hard",
            "Data Structures"
          ],
          "prerequisites": [
            "javascript_objects",
            "javascript_functions"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_array_iteration_transformation_6",
          "topic": "Array Transformation: Chaining methods",
          "level": "hard",
          "type": "code",
          "question": "Given an array of numbers, write a JavaScript function `processNumbers(numbers)` that uses chaining of `filter()`, `map()`, and `reduce()` to perform the following operations:\n1. Filter out all numbers less than or equal to `50`.\n2. Double the remaining numbers.\n3. Calculate the sum of the doubled numbers.",
          "answer": "```typescript\nfunction processNumbers(numbers) {\n  if (!Array.isArray(numbers)) {\n    throw new Error('Input must be an array of numbers.');\n  }\n\n  return numbers\n    .filter(num => num > 50)  // Step 1: Filter numbers > 50\n    .map(num => num * 2)     // Step 2: Double the remaining numbers\n    .reduce((sum, num) => sum + num, 0); // Step 3: Sum the doubled numbers\n}\n\nconst inputNumbers = [10, 60, 30, 80, 40, 90, 50, 70];\nconst result = processNumbers(inputNumbers);\nconsole.log('Processed sum:', result); // Expected: (60*2 + 80*2 + 90*2 + 70*2) = (120 + 160 + 180 + 140) = 600\n\nconst emptyArray = [];\nconsole.log('Empty array sum:', processNumbers(emptyArray)); // Expected: 0\n\nconst allSmallNumbers = [1, 2, 3];\nconsole.log('All small numbers sum:', processNumbers(allSmallNumbers)); // Expected: 0\n```",
          "options": [],
          "analysisPoints": [
            "Correctly chains `filter`, `map`, and `reduce` in the specified order.",
            "Implements the correct callback for each method (`num > 50`, `num * 2`, `sum + num`).",
            "Provides an initial value for `reduce` to handle empty arrays correctly.",
            "Ensures input validation."
          ],
          "keyConcepts": [
            "filter",
            "map",
            "reduce",
            "chaining",
            "higher-order functions",
            "functional programming"
          ],
          "evaluationCriteria": [
            "Correct method chaining",
            "Accurate implementation of steps",
            "Robustness (empty/edge cases)",
            "Functional approach"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Chaining",
            "Filter",
            "Map",
            "Reduce",
            "Code Challenge",
            "Hard"
          ],
          "prerequisites": [
            "javascript_functions",
            "callback_functions"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_array_iteration_transformation_7",
          "topic": "Array Transformation: reverse() behavior",
          "level": "easy",
          "type": "mcq",
          "question": "What is the result of the following code snippet?\n```javascript\nconst arr = ['a', 'b', 'c'];\nconst reversedArr = arr.reverse();\nconsole.log(arr);\nconsole.log(reversedArr);\n```",
          "answer": "Both `arr` and `reversedArr` will be `['c', 'b', 'a']`.",
          "options": [
            "`arr` will be `['a', 'b', 'c']` and `reversedArr` will be `['c', 'b', 'a']`.",
            "`arr` will be `['c', 'b', 'a']` and `reversedArr` will be `['a', 'b', 'c']`.",
            "Both `arr` and `reversedArr` will be `['c', 'b', 'a']`.",
            "An error will occur because `reverse()` cannot be assigned to a new variable."
          ],
          "analysisPoints": [
            "Understanding that `reverse()` mutates the original array.",
            "Knowing that `reverse()` returns a reference to the *same* mutated array."
          ],
          "keyConcepts": [
            "reverse",
            "array mutation",
            "return value",
            "reference"
          ],
          "evaluationCriteria": [
            "Correctly identifies mutation",
            "Correctly identifies return value as reference"
          ],
          "example": "The `reverse()` method reverses the array in-place, meaning it modifies the original array directly. It also returns a reference to the *same* array that was reversed. Therefore, both `arr` and `reversedArr` will point to the same array object, which has been modified to `['c', 'b', 'a']`.",
          "tags": [
            "Array Methods",
            "Mutation",
            "MCQ",
            "Easy"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_iteration_transformation_8",
          "topic": "Array Transformation: Difference between map and forEach",
          "level": "medium",
          "type": "open",
          "question": "When would you prefer to use `map()` over `forEach()` for iterating over an array, and vice versa? Provide examples.",
          "answer": null,
          "analysisPoints": [
            "Clearly distinguishes `map` for transformation (returning new array) vs. `forEach` for side effects (no return value).",
            "Provides suitable examples for each scenario.",
            "Discusses impact on immutability/functional programming paradigms."
          ],
          "keyConcepts": [
            "map",
            "forEach",
            "transformation",
            "side effects",
            "immutability",
            "return value"
          ],
          "evaluationCriteria": [
            "Clear explanation of distinction",
            "Appropriate examples for each method",
            "Understanding of functional programming implications"
          ],
          "example": "**Use `map()` when you need to transform each element in an array and get a *new array* containing the transformed elements.** It's ideal for scenarios where you want to produce a new array based on the existing one without altering the original.\n\n*Example for `map()`: Doubling numbers*\n```typescript\nconst numbers = [1, 2, 3];\nconst doubledNumbers = numbers.map(num => num * 2);\nconsole.log(doubledNumbers); // [2, 4, 6]\nconsole.log(numbers);       // [1, 2, 3] (original remains unchanged)\n```\n\n**Use `forEach()` when you need to iterate over an array and perform a *side effect* for each element, and you don't need a new array as a result.** It returns `undefined`, so it's not suitable for chaining transformations.\n\n*Example for `forEach()`: Logging elements or updating UI*\n```typescript\nconst names = ['Alice', 'Bob', 'Charlie'];\nnames.forEach(name => {\n  console.log(`Hello, ${name}!`); // Side effect: logs to console\n});\n// No return value, names array is not modified\n```",
          "tags": [
            "Array Methods",
            "Map",
            "ForEach",
            "Transformation",
            "Iteration",
            "Open-Ended",
            "Medium"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_additional_array_1",
          "topic": "Array Utilities: Array.isArray()",
          "level": "easy",
          "type": "flashcard",
          "question": "Why is `Array.isArray()` generally preferred over `typeof arr === 'object' && arr !== null` or `arr instanceof Array` for checking if a variable is an array?",
          "answer": "`Array.isArray()` is preferred because `typeof []` returns 'object', and `instanceof Array` might fail across different JavaScript realms (e.g., iframes) where arrays are created in different global contexts. `Array.isArray()` provides a robust and reliable check.",
          "analysisPoints": [
            "Understanding limitations of `typeof` for arrays.",
            "Understanding limitations of `instanceof` across realms.",
            "Knowing `Array.isArray`'s reliability."
          ],
          "keyConcepts": [
            "Array.isArray",
            "typeof",
            "instanceof",
            "array type checking",
            "javascript realms"
          ],
          "evaluationCriteria": [
            "Correctly identifies `typeof` and `instanceof` issues",
            "Explains `Array.isArray` robustness"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Type Checking",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "javascript_operators",
            "javascript_context"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_additional_array_2",
          "topic": "Array Utilities: some() vs every()",
          "level": "medium",
          "type": "mcq",
          "question": "Given the array `const temperatures = [22, 25, 18, 20, 23];` which of the following expressions would return `true`?\n\nI. `temperatures.some(temp => temp > 25)`\nII. `temperatures.every(temp => temp >= 18)`\nIII. `temperatures.every(temp => temp < 20)`\nIV. `temperatures.some(temp => temp === 18)`",
          "answer": "II and IV",
          "options": [
            "I and III",
            "II and IV",
            "I, II and IV",
            "All of them"
          ],
          "analysisPoints": [
            "Understanding `some()`'s 'at least one' condition.",
            "Understanding `every()`'s 'all' condition.",
            "Applying the conditions correctly to the given array elements."
          ],
          "keyConcepts": [
            "some",
            "every",
            "callback function",
            "conditional logic"
          ],
          "evaluationCriteria": [
            "Correctly applies boolean logic of `some` and `every`",
            "Accurate evaluation of expressions"
          ],
          "example": "I. `temperatures.some(temp => temp > 25)`: `false` (no temperature is strictly greater than 25)\nII. `temperatures.every(temp => temp >= 18)`: `true` (all temperatures are greater than or equal to 18)\nIII. `temperatures.every(temp => temp < 20)`: `false` (22, 25, 20, 23 are not less than 20)\nIV. `temperatures.some(temp => temp === 18)`: `true` (18 exists in the array)\n\nTherefore, II and IV are the correct expressions that return `true`.",
          "tags": [
            "Array Methods",
            "Conditional Logic",
            "MCQ",
            "Medium"
          ],
          "prerequisites": [
            "javascript_booleans",
            "javascript_functions"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_additional_array_3",
          "topic": "Array Utilities: fill()",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of the `fill()` method, and does it modify the original array?",
          "answer": "The `fill()` method fills all the elements of an array from a start index to an end index with a static value. Yes, it modifies the original array in-place.",
          "analysisPoints": [
            "Knowledge of `fill`'s purpose (mass assignment).",
            "Recognition of its mutating behavior."
          ],
          "keyConcepts": [
            "fill",
            "array mutation",
            "in-place",
            "range"
          ],
          "evaluationCriteria": [
            "Correctly states purpose",
            "Correctly identifies mutation"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Mutation",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_additional_array_4",
          "topic": "Array Utilities: copyWithin()",
          "level": "medium",
          "type": "open",
          "question": "Describe a scenario where `copyWithin()` might be a useful method. Explain its parameters (`target`, `start`, `end`) and provide a code example that demonstrates its use in your scenario.",
          "answer": null,
          "analysisPoints": [
            "Provides a realistic use case for `copyWithin` (e.g., circular buffers, shifting elements efficiently).",
            "Clearly explains each parameter.",
            "Demonstrates a functional code example for the described scenario."
          ],
          "keyConcepts": [
            "copyWithin",
            "in-place mutation",
            "target index",
            "start index",
            "end index",
            "array segments"
          ],
          "evaluationCriteria": [
            "Plausible scenario",
            "Accurate parameter explanation",
            "Correct and illustrative code example"
          ],
          "example": "Scenario: Implementing a simple circular buffer or a fixed-size queue where old elements are overwritten by new ones in a cyclical manner, or efficiently shifting a segment of an array without creating a new one.\n\nLet's say you have an array representing slots in a game, and you want to 'shift' elements to the left, effectively removing the first few elements and filling their space with subsequent elements, much like a memory compacting operation for a fixed-size buffer.\n\nParameters:\n- **`target`**: The zero-based index at which to copy the sequence to. This is where the copied elements will start being placed.\n- **`start`**: The zero-based index at which to start copying elements from (inclusive). This marks the beginning of the segment you want to copy.\n- **`end`**: The zero-based index at which to end copying elements from (exclusive). This marks the end of the segment you want to copy. If omitted, it copies to the end of the array.\n\nCode Example: Simulating a shift of elements to the left within a fixed-size array.\n```typescript\nlet buffer = ['A', 'B', 'C', 'D', 'E', 'F'];\n\n// Imagine 'A' and 'B' are processed and we want to shift 'C', 'D', 'E', 'F' to the beginning\n// and mark the last two positions as empty.\n\n// We want to copy elements from index 2 ('C') to index 6 (end of array, 'F')\n// and place them starting at index 0.\nbuffer.copyWithin(0, 2, 6); // copies ['C', 'D', 'E', 'F'] to indices 0, 1, 2, 3\n\nconsole.log(buffer); // Output: ['C', 'D', 'E', 'F', 'E', 'F']\n\n// Now, to truly 'remove' the last elements (make them empty or null), we could fill them:\nbuffer.fill(null, 4); // Fills from index 4 to end with null\nconsole.log(buffer); // Output: ['C', 'D', 'E', 'F', null, null]\n```\nThis demonstrates how `copyWithin` efficiently shifts data blocks in-place.",
          "tags": [
            "Array Methods",
            "copyWithin",
            "Mutation",
            "In-place",
            "Open-Ended",
            "Medium"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 7,
          "interviewFrequency": 5,
          "learningPath": "advanced"
        },
        {
          "id": "question_additional_array_5",
          "topic": "Array Utilities: Chaining some() and every()",
          "level": "hard",
          "type": "code",
          "question": "Write a function `validateFormFields(fields)` that takes an array of objects, where each object represents a form field and has `name` (string) and `value` (string) properties. The function should return `true` if *all* fields have a non-empty `name` AND *at least one* field has a non-empty `value`. Otherwise, it should return `false`.\n\n```typescript\nconst validFields = [\n  { name: 'username', value: 'john_doe' },\n  { name: 'email', value: '' },\n  { name: 'password', value: 'secure123' }\n];\n\nconst invalidName = [\n  { name: '', value: 'test' }\n];\n\nconst noValue = [\n  { name: 'username', value: '' },\n  { name: 'email', value: '' }\n];\n```",
          "answer": "```typescript\nfunction validateFormFields(fields) {\n  if (!Array.isArray(fields) || fields.length === 0) {\n    return false; // An empty array or non-array input is invalid\n  }\n\n  // Check if all fields have a non-empty name\n  const allNamesValid = fields.every(field => \n    typeof field.name === 'string' && field.name.trim() !== ''\n  );\n\n  // Check if at least one field has a non-empty value\n  const atLeastOneValueValid = fields.some(field => \n    typeof field.value === 'string' && field.value.trim() !== ''\n  );\n\n  return allNamesValid && atLeastOneValueValid;\n}\n\nconst validFields = [\n  { name: 'username', value: 'john_doe' },\n  { name: 'email', value: '' },\n  { name: 'password', value: 'secure123' }\n];\nconsole.log('Valid fields (expected true):', validateFormFields(validFields)); // true\n\nconst invalidName = [\n  { name: '', value: 'test' }\n];\nconsole.log('Invalid name (expected false):', validateFormFields(invalidName)); // false\n\nconst noValue = [\n  { name: 'username', value: '' },\n  { name: 'email', value: '' }\n];\nconsole.log('No value (expected false):', validateFormFields(noValue)); // false\n\nconst emptyInput = [];\nconsole.log('Empty input (expected false):', validateFormFields(emptyInput)); // false\n\nconst allValid = [\n  { name: 'name1', value: 'val1' },\n  { name: 'name2', value: 'val2' }\n];\nconsole.log('All valid (expected true):', validateFormFields(allValid)); // true\n```",
          "options": [],
          "analysisPoints": [
            "Correctly identifies and uses `every()` for the 'all fields have a non-empty name' condition.",
            "Correctly identifies and uses `some()` for the 'at least one field has a non-empty value' condition.",
            "Combines the two boolean results with a logical AND (`&&`).",
            "Handles edge cases like empty arrays and checks for string type and `trim()` for empty strings.",
            "Demonstrates understanding of higher-order function composition."
          ],
          "keyConcepts": [
            "some",
            "every",
            "callback function",
            "logical operators",
            "string methods",
            "validation"
          ],
          "evaluationCriteria": [
            "Correct logical implementation",
            "Appropriate use of `some` and `every`",
            "Robustness with edge cases",
            "Clarity of code"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Conditional Logic",
            "Code Challenge",
            "Hard",
            "Validation"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_strings"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_additional_array_6",
          "topic": "Array Utilities: Mutating methods summary",
          "level": "medium",
          "type": "flashcard",
          "question": "List at least five common array methods that modify the original array (mutate it) in JavaScript.",
          "answer": "Common array methods that mutate the original array include: `push()`, `pop()`, `shift()`, `unshift()`, `splice()`, `sort()`, `reverse()`, `fill()`, `copyWithin()`.",
          "analysisPoints": [
            "Recall of mutating methods.",
            "Distinction between mutating and non-mutating methods."
          ],
          "keyConcepts": [
            "mutation",
            "in-place",
            "array methods"
          ],
          "evaluationCriteria": [
            "Correctly identifies at least five mutating methods."
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Mutation",
            "Flashcard",
            "Medium"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_mutating_vs_non_mutating_1",
          "topic": "Mutating vs. Non-Mutating Methods: Core Concept",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the fundamental difference between a 'mutating' and a 'non-mutating' array method?",
          "answer": "A 'mutating' method directly changes the original array on which it is called, while a 'non-mutating' method does not change the original array; instead, it returns a new array with the results of the operation.",
          "analysisPoints": [
            "Definition of mutation.",
            "Definition of non-mutation (immutability).",
            "Impact on the original array."
          ],
          "keyConcepts": [
            "mutation",
            "non-mutation",
            "immutability",
            "side effects"
          ],
          "evaluationCriteria": [
            "Clear and concise definition of both types."
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Mutation",
            "Immutability",
            "Flashcard",
            "Easy"
          ],
          "prerequisites": [
            "javascript_variables",
            "javascript_references"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_mutating_vs_non_mutating_2",
          "topic": "Mutating vs. Non-Mutating Methods: Practical Impact",
          "level": "medium",
          "type": "open",
          "question": "Why is it important for a frontend developer to understand the distinction between mutating and non-mutating array methods, especially in the context of state management in libraries like React?",
          "answer": null,
          "analysisPoints": [
            "Connects mutation to unexpected side effects and debugging difficulties.",
            "Explains how immutable updates are crucial for React's reconciliation process (shallow comparison).",
            "Discusses how direct mutation can prevent components from re-rendering when state changes, leading to UI bugs.",
            "Mentions the concept of predictable state changes."
          ],
          "keyConcepts": [
            "mutation",
            "immutability",
            "react state",
            "reconciliation",
            "side effects",
            "debugging",
            "predictable state"
          ],
          "evaluationCriteria": [
            "Demonstrates understanding of React's state update mechanism",
            "Explains the impact on component re-renders",
            "Connects to broader software engineering principles (predictability)"
          ],
          "example": "In libraries like React, state updates are often managed with the expectation that state objects and arrays are treated immutably. When you mutate an array directly (e.g., using `push` or `splice`) instead of creating a new one (e.g., using `map` or `slice` with spread syntax), React's shallow comparison in its reconciliation process might not detect a change because the reference to the array object remains the same. This can lead to:\n\n1.  **Missed Rerenders**: Components depending on that array state won't re-render, leading to a stale UI.\n2.  **Unpredictable Bugs**: It becomes harder to track when and where state was modified, leading to harder-to-debug issues.\n3.  **Performance Issues**: If manual re-renders are forced, it bypasses React's optimized update flow.\n\nBy consistently using non-mutating methods, developers ensure that a new reference is created whenever the array data changes, allowing React to efficiently detect the change and trigger necessary re-renders. This promotes predictable state management and easier debugging.",
          "tags": [
            "Array Methods",
            "Mutation",
            "Immutability",
            "React",
            "State Management",
            "Open-Ended",
            "Medium"
          ],
          "prerequisites": [
            "react_basics",
            "state_management_concepts"
          ],
          "complexity": 8,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_mutating_vs_non_mutating_3",
          "topic": "Mutating vs. Non-Mutating Methods: Identifying Mutating Methods",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following array methods modifies the original array directly?",
          "answer": "`splice()`",
          "options": [
            "`map()`",
            "`filter()`",
            "`slice()`",
            "`splice()`"
          ],
          "analysisPoints": [
            "Identifies `splice()` as a mutating method.",
            "Differentiates it from non-mutating methods like `map`, `filter`, and `slice`."
          ],
          "keyConcepts": [
            "mutation",
            "non-mutation",
            "splice",
            "map",
            "filter",
            "slice"
          ],
          "evaluationCriteria": [
            "Correctly identifies the mutating method."
          ],
          "example": "The `splice()` method is designed to change the contents of an array by removing or replacing existing elements and/or adding new elements *in place*. `map()`, `filter()`, and `slice()` all return new arrays, leaving the original array unchanged.",
          "tags": [
            "Array Methods",
            "Mutation",
            "MCQ",
            "Easy"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_mutating_vs_non_mutating_4",
          "topic": "Mutating vs. Non-Mutating Methods: Safe Array Update",
          "level": "medium",
          "type": "code",
          "question": "You have an array of user objects. You need to update the `age` of a user with a specific `id` without mutating the original `users` array. Write a function `updateUserAge(users, userId, newAge)` that returns a *new* array with the updated user, or the original array if the user is not found. Use non-mutating methods.\n\n```typescript\nconst users = [\n  { id: 1, name: 'Alice', age: 30 },\n  { id: 2, name: 'Bob', age: 25 },\n  { id: 3, name: 'Charlie', age: 35 }\n];\n```",
          "answer": "```typescript\nfunction updateUserAge(users, userId, newAge) {\n  const userIndex = users.findIndex(user => user.id === userId);\n\n  if (userIndex === -1) {\n    return users; // User not found, return original array\n  }\n\n  // Create a new array and update the specific user object immutably\n  return users.map((user, index) => {\n    if (index === userIndex) {\n      return { ...user, age: newAge }; // Create new user object with updated age\n    } else {\n      return user; // Return original user object for others\n    }\n  });\n}\n\nconst users = [\n  { id: 1, name: 'Alice', age: 30 },\n  { id: 2, name: 'Bob', age: 25 },\n  { id: 3, name: 'Charlie', age: 35 }\n];\n\nconst updatedUsers1 = updateUserAge(users, 2, 26);\nconsole.log('Original users:', users); // Expected: [{ id: 1, name: 'Alice', age: 30 }, { id: 2, name: 'Bob', age: 25 }, { id: 3, name: 'Charlie', age: 35 }]\nconsole.log('Updated users 1:', updatedUsers1); // Expected: [{ id: 1, name: 'Alice', age: 30 }, { id: 2, name: 'Bob', age: 26 }, { id: 3, name: 'Charlie', age: 35 }]\nconsole.log('Are arrays same reference?', users === updatedUsers1); // Expected: false\n\nconst updatedUsers2 = updateUserAge(users, 99, 40); // User not found\nconsole.log('Updated users 2 (user not found):', updatedUsers2); // Expected: original users array\nconsole.log('Are arrays same reference (user not found)?', users === updatedUsers2); // Expected: true\n```",
          "options": [],
          "analysisPoints": [
            "Uses `findIndex` to locate the user's index.",
            "Uses `map` to create a *new* array, ensuring non-mutation.",
            "Uses object spread syntax (`...user`) to create a *new* user object for the updated item, ensuring that individual objects within the array are also updated immutably.",
            "Handles the case where the user is not found by returning the original array reference.",
            "Demonstrates understanding of both array and object immutability."
          ],
          "keyConcepts": [
            "map",
            "findIndex",
            "immutability",
            "object spread",
            "array iteration",
            "functional programming"
          ],
          "evaluationCriteria": [
            "Adherence to non-mutation",
            "Correct functional implementation",
            "Handling of found/not-found scenarios",
            "Efficiency of chosen methods"
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Immutability",
            "State Management",
            "Code Challenge",
            "Medium"
          ],
          "prerequisites": [
            "javascript_objects",
            "javascript_functions"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_mutating_vs_non_mutating_5",
          "topic": "Mutating vs. Non-Mutating Methods: Identify Non-Mutating Methods",
          "level": "medium",
          "type": "flashcard",
          "question": "List at least five common array methods that do *not* modify the original array (are non-mutating) in JavaScript.",
          "answer": "Common non-mutating array methods include: `slice()`, `concat()`, `map()`, `filter()`, `reduce()`, `indexOf()`, `lastIndexOf()`, `includes()`, `find()`, `findIndex()`, `forEach()`, `some()`, `every()`.",
          "analysisPoints": [
            "Recall of non-mutating methods.",
            "Distinction between mutating and non-mutating methods."
          ],
          "keyConcepts": [
            "non-mutation",
            "new array",
            "array methods"
          ],
          "evaluationCriteria": [
            "Correctly identifies at least five non-mutating methods."
          ],
          "example": null,
          "tags": [
            "Array Methods",
            "Non-Mutation",
            "Immutability",
            "Flashcard",
            "Medium"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_array_modification_1",
          "title": "Implement a Basic Todo List Manager",
          "description": "\nImplement a `TodoList` class with methods to manage tasks. You must use appropriate array modification methods for adding and removing tasks. The tasks are simple strings.\n\n**Requirements:**\n1.  `constructor()`: Initializes an empty array for tasks.\n2.  `addTask(task)`: Adds a new task to the end of the list. Returns the new total number of tasks.\n3.  `removeTask(task)`: Removes the first occurrence of a specific task from the list. Returns `true` if the task was found and removed, `false` otherwise.\n4.  `getTasks()`: Returns a *copy* of the current task list to prevent external modification.\n5.  `clearTasks()`: Removes all tasks from the list.\n",
          "difficulty": "medium",
          "startingCode": "class TodoList {\n  constructor() {\n    // TODO: Initialize tasks array\n  }\n\n  addTask(task) {\n    // TODO: Add task to the end, return new length\n  }\n\n  removeTask(task) {\n    // TODO: Find and remove the first occurrence of the task\n    // Hint: Consider indexOf and splice\n  }\n\n  getTasks() {\n    // TODO: Return a copy of the tasks array\n  }\n\n  clearTasks() {\n    // TODO: Remove all tasks\n  }\n}\n",
          "solutionCode": "class TodoList {\n  constructor() {\n    this.tasks = [];\n  }\n\n  addTask(task) {\n    return this.tasks.push(task);\n  }\n\n  removeTask(task) {\n    const index = this.tasks.indexOf(task);\n    if (index > -1) {\n      this.tasks.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  getTasks() {\n    // Return a shallow copy to prevent direct mutation of the internal array\n    return this.tasks.slice(); \n  }\n\n  clearTasks() {\n    // Option 1: Reassigning an empty array (common, effectively non-mutating for the *reference* but clears contents)\n    // this.tasks = []; \n    \n    // Option 2: Mutating the array to empty it in-place (if the reference must remain the same)\n    this.tasks.splice(0, this.tasks.length); \n  }\n}\n\n// Example Usage:\nconst myTodoList = new TodoList();\nconsole.log(\"Add task 'Buy groceries':\", myTodoList.addTask('Buy groceries')); // 1\nconsole.log(\"Add task 'Do laundry':\", myTodoList.addTask('Do laundry'));   // 2\nconsole.log(\"Current tasks:\", myTodoList.getTasks()); // ['Buy groceries', 'Do laundry']\n\nconsole.log(\"Remove 'Buy groceries':\", myTodoList.removeTask('Buy groceries')); // true\nconsole.log(\"Current tasks:\", myTodoList.getTasks()); // ['Do laundry']\n\nconsole.log(\"Remove non-existent task 'Walk dog':\", myTodoList.removeTask('Walk dog')); // false\nconsole.log(\"Current tasks:\", myTodoList.getTasks()); // ['Do laundry']\n\nmyTodoList.addTask('Pay bills');\nconsole.log(\"Tasks before clear:\", myTodoList.getTasks());\nmyTodoList.clearTasks();\nconsole.log(\"Tasks after clear:\", myTodoList.getTasks()); // []\n\nmyTodoList.addTask('Study Arrays');\nconsole.log(\"After re-add:\", myTodoList.getTasks());\n",
          "testCases": [
            "TodoList should initialize with an empty tasks array.",
            "addTask should correctly add tasks and return the new length.",
            "removeTask should remove the first occurrence and return true, and false for non-existent tasks.",
            "getTasks should return a new array (copy) and not the internal reference.",
            "clearTasks should empty the tasks array.",
            "Adding and removing tasks multiple times should maintain correct state."
          ],
          "hints": [
            "For `addTask`, `push()` is the most straightforward method.",
            "For `removeTask`, you'll likely need `indexOf()` to find the task's position and `splice()` to remove it.",
            "Remember that `slice()` without arguments creates a shallow copy of an array.",
            "To clear an array, `splice(0, array.length)` is one effective in-place method."
          ],
          "tags": [
            "Array Methods",
            "Classes",
            "Data Structure",
            "Mutation",
            "Frontend Interview",
            "Basic"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "javascript_classes",
            "javascript_arrays"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "push",
            "pop",
            "splice",
            "slice",
            "indexOf"
          ]
        },
        {
          "id": "task_array_modification_2",
          "title": "Implement an Immutable Array Manipulator",
          "description": "\nCreate a set of utility functions to perform common array manipulations, ensuring that all functions return *new arrays* and never modify the original input array. This is crucial for applications that rely on immutability.\n\n**Requirements:**\n1.  `prepend(arr, element)`: Returns a new array with `element` added to the beginning of `arr`.\n2.  `append(arr, element)`: Returns a new array with `element` added to the end of `arr`.\n3.  `removeAtIndex(arr, index)`: Returns a new array with the element at `index` removed. Should handle invalid indices gracefully (e.g., return original array).\n4.  `insertAtIndex(arr, index, element)`: Returns a new array with `element` inserted at `index`. Should handle invalid indices gracefully (e.g., insert at end if index too large, beginning if index too small).\n",
          "difficulty": "medium",
          "startingCode": "function prepend(arr, element) {\n  // TODO: Implement using non-mutating methods\n}\n\nfunction append(arr, element) {\n  // TODO: Implement using non-mutating methods\n}\n\nfunction removeAtIndex(arr, index) {\n  // TODO: Implement using non-mutating methods\n}\n\nfunction insertAtIndex(arr, index, element) {\n  // TODO: Implement using non-mutating methods\n}\n",
          "solutionCode": "function prepend(arr, element) {\n  // Use concat or spread syntax\n  return [element].concat(arr);\n  // return [element, ...arr];\n}\n\nfunction append(arr, element) {\n  // Use concat or spread syntax\n  return arr.concat(element);\n  // return [...arr, element];\n}\n\nfunction removeAtIndex(arr, index) {\n  if (!Array.isArray(arr) || index < 0 || index >= arr.length) {\n    return arr; // Return original array if index is out of bounds or invalid input\n  }\n  // Use slice to get parts before and after the removed element, then concat\n  return arr.slice(0, index).concat(arr.slice(index + 1));\n}\n\nfunction insertAtIndex(arr, index, element) {\n  if (!Array.isArray(arr)) {\n    return arr; // Return original array if invalid input\n  }\n  // Normalize index for inserting at beginning or end if out of bounds\n  const normalizedIndex = Math.max(0, Math.min(index, arr.length));\n  \n  // Use slice to get parts, then concat with the new element in between\n  return arr.slice(0, normalizedIndex).concat(element, arr.slice(normalizedIndex));\n}\n\n// Test Cases:\nconst original = [1, 2, 3, 4, 5];\n\nconsole.log('Original:', original); // [1, 2, 3, 4, 5]\n\nconst prepended = prepend(original, 0);\nconsole.log('Prepended:', prepended); // [0, 1, 2, 3, 4, 5]\nconsole.log('Original still:', original); // [1, 2, 3, 4, 5]\n\nconst appended = append(original, 6);\nconsole.log('Appended:', appended);   // [1, 2, 3, 4, 5, 6]\nconsole.log('Original still:', original); // [1, 2, 3, 4, 5]\n\nconst removed = removeAtIndex(original, 2); // Remove 3\nconsole.log('Removed at index 2:', removed); // [1, 2, 4, 5]\nconsole.log('Original still:', original); // [1, 2, 3, 4, 5]\n\nconst removedInvalid = removeAtIndex(original, 10);\nconsole.log('Removed invalid index:', removedInvalid === original); // true\n\nconst inserted = insertAtIndex(original, 2, 99);\nconsole.log('Inserted at index 2:', inserted); // [1, 2, 99, 3, 4, 5]\nconsole.log('Original still:', original); // [1, 2, 3, 4, 5]\n\nconst insertedAtEnd = insertAtIndex(original, 10, 100);\nconsole.log('Inserted at end:', insertedAtEnd); // [1, 2, 3, 4, 5, 100]\n\nconst insertedAtBeginning = insertAtIndex(original, -5, -1);\nconsole.log('Inserted at beginning:', insertedAtBeginning); // [-1, 1, 2, 3, 4, 5]\n",
          "testCases": [
            "All functions must return a *new* array, not modify the original.",
            "`prepend` should correctly add an element to the beginning.",
            "`append` should correctly add an element to the end.",
            "`removeAtIndex` should correctly remove an element at a given index and handle out-of-bounds indices by returning the original array.",
            "`insertAtIndex` should correctly insert an element at a given index and handle out-of-bounds indices (inserting at the closest valid boundary).",
            "Test with empty arrays.",
            "Test with single-element arrays."
          ],
          "hints": [
            "For `prepend` and `append`, consider using `concat()` or the spread syntax (`...`).",
            "For `removeAtIndex` and `insertAtIndex`, `slice()` will be essential to break the array into parts, and `concat()` to reassemble it with modifications.",
            "Remember `Math.max(0, ...)` and `Math.min(index, arr.length)` can help normalize indices."
          ],
          "tags": [
            "Array Methods",
            "Immutability",
            "Functional Programming",
            "Higher-Order Functions",
            "Frontend Interview",
            "Medium"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "javascript_arrays",
            "javascript_functions",
            "object_spread_syntax"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "slice",
            "concat",
            "spread syntax",
            "immutability"
          ]
        },
        {
          "id": "task_array_searching_1",
          "title": "Implement a Flexible Search and Filter API",
          "description": "\nCreate a set of functions that provide flexible search and filter capabilities for an array of product objects. Each function should be implemented using the most appropriate array searching method.\n\n**Product Object Structure:**\n```typescript\ninterface Product {\n  id: number;\n  name: string;\n  category: string;\n  price: number;\n  inStock: boolean;\n}\n```\n\n**Requirements:**\n1.  `findProductById(products, id)`: Returns the product object with the matching `id`, or `undefined` if not found.\n2.  `filterProductsByCategory(products, category)`: Returns a *new array* of all products belonging to the specified `category`.\n3.  `checkProductAvailability(products, productName)`: Returns `true` if a product with the given `productName` exists and is `inStock`, otherwise `false`. (Case-insensitive name comparison).\n4.  `getIndexOfExpensiveProduct(products, minPrice)`: Returns the index of the *first* product found whose `price` is greater than or equal to `minPrice`. Returns -1 if no such product exists.\n",
          "difficulty": "medium",
          "startingCode": "interface Product {\n  id: number;\n  name: string;\n  category: string;\n  price: number;\n  inStock: boolean;\n}\n\nfunction findProductById(products: Product[], id: number): Product | undefined {\n  // TODO: Implement using an appropriate searching method\n}\n\nfunction filterProductsByCategory(products: Product[], category: string): Product[] {\n  // TODO: Implement using an appropriate filtering method\n}\n\nfunction checkProductAvailability(products: Product[], productName: string): boolean {\n  // TODO: Implement, considering case-insensitivity and inStock status\n}\n\nfunction getIndexOfExpensiveProduct(products: Product[], minPrice: number): number {\n  // TODO: Implement using an appropriate searching method for index\n}\n",
          "solutionCode": "interface Product {\n  id: number;\n  name: string;\n  category: string;\n  price: number;\n  inStock: boolean;\n}\n\nfunction findProductById(products: Product[], id: number): Product | undefined {\n  return products.find(product => product.id === id);\n}\n\nfunction filterProductsByCategory(products: Product[], category: string): Product[] {\n  return products.filter(product => product.category === category);\n}\n\nfunction checkProductAvailability(products: Product[], productName: string): boolean {\n  const lowerCaseProductName = productName.toLowerCase();\n  return products.some(product => \n    product.name.toLowerCase() === lowerCaseProductName && product.inStock\n  );\n}\n\nfunction getIndexOfExpensiveProduct(products: Product[], minPrice: number): number {\n  return products.findIndex(product => product.price >= minPrice);\n}\n\n// Test Data:\nconst sampleProducts: Product[] = [\n  { id: 1, name: 'Laptop', category: 'Electronics', price: 1200, inStock: true },\n  { id: 2, name: 'Mouse', category: 'Electronics', price: 25, inStock: false },\n  { id: 3, name: 'Keyboard', category: 'Electronics', price: 75, inStock: true },\n  { id: 4, name: 'Novel', category: 'Books', price: 15, inStock: true },\n  { id: 5, name: 'Headphones', category: 'Audio', price: 150, inStock: true },\n  { id: 6, name: 'Charger', category: 'Electronics', price: 30, inStock: true },\n  { id: 7, name: 'Book', category: 'Books', price: 20, inStock: false }\n];\n\n// Test findProductById\nconsole.log('Find Product by ID 3:', findProductById(sampleProducts, 3)); // Keyboard\nconsole.log('Find Product by ID 99:', findProductById(sampleProducts, 99)); // undefined\n\n// Test filterProductsByCategory\nconsole.log('Filter by Electronics:', filterProductsByCategory(sampleProducts, 'Electronics')); // Laptop, Mouse, Keyboard, Charger\nconsole.log('Filter by Clothes:', filterProductsByCategory(sampleProducts, 'Clothes')); // []\n\n// Test checkProductAvailability\nconsole.log('Check Laptop availability:', checkProductAvailability(sampleProducts, 'laptop')); // true\nconsole.log('Check Mouse availability:', checkProductAvailability(sampleProducts, 'Mouse')); // false (not in stock)\nconsole.log('Check nonexistent product availability:', checkProductAvailability(sampleProducts, 'Monitor')); // false\nconsole.log('Check Book (id 7) availability:', checkProductAvailability(sampleProducts, 'Book')); // false (not in stock)\nconsole.log('Check Novel (id 4) availability:', checkProductAvailability(sampleProducts, 'Novel')); // true (in stock)\n\n// Test getIndexOfExpensiveProduct\nconsole.log('Index of first product >= 100:', getIndexOfExpensiveProduct(sampleProducts, 100)); // 0 (Laptop)\nconsole.log('Index of first product >= 500:', getIndexOfExpensiveProduct(sampleProducts, 500)); // 0 (Laptop) still the first one > 50\nconsole.log('Index of first product >= 2000:', getIndexOfExpensiveProduct(sampleProducts, 2000)); // -1\n",
          "testCases": [
            "`findProductById` should return the correct object or `undefined` for non-existent IDs.",
            "`filterProductsByCategory` should return a new array with only matching categories, or an empty array if no matches.",
            "`checkProductAvailability` should return `true` only if both name matches (case-insensitively) AND `inStock` is `true`. It should return `false` otherwise.",
            "`getIndexOfExpensiveProduct` should return the correct index or `-1` for no matches.",
            "Ensure no functions mutate the original `products` array.",
            "Test with empty input arrays."
          ],
          "hints": [
            "Think about whether you need a single item, an index, or multiple items.",
            "`find()` is great for single object searches.",
            "`filter()` is perfect for subsets.",
            "`some()` can efficiently check for existence based on multiple conditions.",
            "`findIndex()` is for getting the index based on a condition."
          ],
          "tags": [
            "Array Methods",
            "Searching",
            "Filtering",
            "Higher-Order Functions",
            "Data Retrieval",
            "Frontend Interview"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "javascript_functions",
            "javascript_objects",
            "callback_functions"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "find",
            "filter",
            "some",
            "findIndex",
            "case-insensitivity"
          ]
        },
        {
          "id": "task_array_searching_2",
          "title": "Validate User Input with Array Methods",
          "description": "\nWrite a function `validateOrderItems(availableItems, orderItems)` that validates an array of `orderItems` against a list of `availableItems`. Both `availableItems` and `orderItems` are arrays of strings (item names).\n\n**Requirements:**\n1.  Return `true` if *all* `orderItems` are present in `availableItems`.\n2.  Return `false` if *any* `orderItems` are not found in `availableItems`.\n3.  The comparison should be case-insensitive (e.g., 'Apple' should match 'apple').\n4.  Consider performance for potentially large lists.\n",
          "difficulty": "medium",
          "startingCode": "function validateOrderItems(availableItems: string[], orderItems: string[]): boolean {\n  // TODO: Implement validation logic using array methods\n}\n",
          "solutionCode": "function validateOrderItems(availableItems: string[], orderItems: string[]): boolean {\n  if (!Array.isArray(availableItems) || !Array.isArray(orderItems)) {\n    throw new Error('Inputs must be arrays.');\n  }\n\n  // Convert availableItems to a Set of lowercase names for efficient lookup\n  // Using a Set provides O(1) average time complexity for lookups, better than O(N) for indexOf/includes on arrays\n  const availableItemsLowerCaseSet = new Set(availableItems.map(item => item.toLowerCase()));\n\n  // Check if every ordered item is present in the available items (case-insensitive)\n  return orderItems.every(orderItem => \n    availableItemsLowerCaseSet.has(orderItem.toLowerCase())\n  );\n}\n\n// Test Cases:\nconst available = ['Apple', 'Banana', 'Orange', 'Grape'];\n\nconsole.log('Valid order:', validateOrderItems(available, ['apple', 'Orange'])); // true\nconsole.log('Invalid order (Pear not available):', validateOrderItems(available, ['apple', 'Pear'])); // false\nconsole.log('Empty order:', validateOrderItems(available, [])); // true (all 0 items are available)\nconsole.log('Empty available:', validateOrderItems([], ['apple'])); // false\nconsole.log('Case-insensitive match:', validateOrderItems(available, ['APPLE', 'Grape'])); // true\nconsole.log('Order with duplicate:', validateOrderItems(available, ['Apple', 'Apple'])); // true\n",
          "testCases": [
            "Should return `true` for valid orders (all items available, case-insensitive).",
            "Should return `false` for invalid orders (at least one item not available).",
            "Should handle empty `orderItems` array gracefully (return `true`).",
            "Should handle empty `availableItems` array gracefully (return `false` for non-empty `orderItems`).",
            "Should be case-insensitive.",
            "Should handle duplicate items in `orderItems` correctly."
          ],
          "hints": [
            "To check if *all* items satisfy a condition, consider `every()`.",
            "For case-insensitive comparison, convert both items to the same case (e.g., lowercase) before comparing.",
            "For efficient lookups in a large `availableItems` list, converting it to a `Set` or an object for `O(1)` average time complexity lookups might be beneficial, especially within a loop or `every()` callback."
          ],
          "tags": [
            "Array Methods",
            "Validation",
            "Searching",
            "Performance",
            "Frontend Interview",
            "Medium"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "javascript_functions",
            "javascript_strings",
            "javascript_sets"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "every",
            "includes",
            "toLowerCase",
            "Set Data Structure",
            "performance optimization"
          ]
        },
        {
          "id": "task_array_iteration_transformation_1",
          "title": "Process and Summarize Sales Data",
          "description": "\nYou are given an array of sales records. Each record is an object with `product` (string), `quantity` (number), and `price` (number).\n\n**Requirements:**\n1.  **`calculateTotalSales(sales)`**: Calculate the total revenue from all sales. (Use `reduce()`)\n2.  **`getExpensiveProducts(sales, minPrice)`**: Return a *new array* of products (just their names) that have a price greater than or equal to `minPrice`. (Use `filter()` and `map()`)\n3.  **`summarizeSalesByCategory(sales)`**: Return an object where keys are product categories (from `sales.product` - for simplicity, assume 'Electronics' if product name contains 'Laptop' or 'Mouse', 'Books' if 'Book' or 'Novel', otherwise 'Other'), and values are the total revenue for that category. (Use `reduce()`)\n\nExample Sales Record:\n```typescript\ninterface Sale {\n  product: string;\n  quantity: number;\n  price: number;\n}\n```",
          "difficulty": "hard",
          "startingCode": "interface Sale {\n  product: string;\n  quantity: number;\n  price: number;\n}\n\nfunction calculateTotalSales(sales: Sale[]): number {\n  // TODO: Implement using reduce\n}\n\nfunction getExpensiveProducts(sales: Sale[], minPrice: number): string[] {\n  // TODO: Implement using filter and map\n}\n\nfunction summarizeSalesByCategory(sales: Sale[]): { [category: string]: number } {\n  // TODO: Implement using reduce. Assume simple categorization logic.\n  // 'Laptop' or 'Mouse' -> 'Electronics'\n  // 'Book' or 'Novel' -> 'Books'\n  // Else -> 'Other'\n}\n",
          "solutionCode": "interface Sale {\n  product: string;\n  quantity: number;\n  price: number;\n}\n\nfunction calculateTotalSales(sales: Sale[]): number {\n  if (!Array.isArray(sales)) {\n    return 0;\n  }\n  return sales.reduce((total, sale) => total + (sale.quantity * sale.price), 0);\n}\n\nfunction getExpensiveProducts(sales: Sale[], minPrice: number): string[] {\n  if (!Array.isArray(sales)) {\n    return [];\n  }\n  return sales\n    .filter(sale => sale.price * sale.quantity >= minPrice) // Filter by total sale value\n    .map(sale => sale.product); // Map to just product names\n}\n\nfunction summarizeSalesByCategory(sales: Sale[]): { [category: string]: number } {\n  if (!Array.isArray(sales)) {\n    return {};\n  }\n  return sales.reduce((acc, sale) => {\n    let category = 'Other';\n    const productNameLower = sale.product.toLowerCase();\n    if (productNameLower.includes('laptop') || productNameLower.includes('mouse')) {\n      category = 'Electronics';\n    } else if (productNameLower.includes('book') || productNameLower.includes('novel')) {\n      category = 'Books';\n    }\n\n    const revenue = sale.quantity * sale.price;\n    acc[category] = (acc[category] || 0) + revenue;\n    return acc;\n  }, {});\n}\n\n// Test Data:\nconst dailySales: Sale[] = [\n  { product: 'Laptop Pro', quantity: 1, price: 1500 },\n  { product: 'Wireless Mouse', quantity: 3, price: 25 },\n  { product: 'The Great Novel', quantity: 2, price: 20 },\n  { product: 'USB Hub', quantity: 5, price: 10 },\n  { product: 'Gaming Keyboard', quantity: 1, price: 80 },\n  { product: 'Science Book', quantity: 1, price: 30 }\n];\n\n// Test calculateTotalSales\nconsole.log('Total Sales:', calculateTotalSales(dailySales)); // Expected: 1500 + 75 + 40 + 50 + 80 + 30 = 1775\n\n// Test getExpensiveProducts\nconsole.log('Expensive Products (>= $100):', getExpensiveProducts(dailySales, 100)); // ['Laptop Pro']\nconsole.log('Expensive Products (>= $50):', getExpensiveProducts(dailySales, 50));   // ['Laptop Pro', 'Wireless Mouse', 'USB Hub', 'Gaming Keyboard']\n\n// Test summarizeSalesByCategory\nconsole.log('Sales Summary by Category:', summarizeSalesByCategory(dailySales));\n/* Expected:\n{\n  'Electronics': 1500 + 75 + 80 = 1655,\n  'Books': 40 + 30 = 70,\n  'Other': 50\n}\n*/\n",
          "testCases": [
            "`calculateTotalSales` should correctly sum up total revenue for various sales arrays, including empty ones.",
            "`getExpensiveProducts` should filter and map correctly, returning only names of products meeting price criteria.",
            "`summarizeSalesByCategory` should correctly group sales by calculated category and sum their revenues.",
            "All functions should handle empty input arrays gracefully (return 0, empty array, or empty object respectively).",
            "Ensure no functions mutate the original `sales` array.",
            "Test `summarizeSalesByCategory` with products fitting different categories, including 'Other'."
          ],
          "hints": [
            "For total sum, `reduce()` is the ideal choice.",
            "For filtering and then transforming, `filter().map()` is a common chain.",
            "For `summarizeSalesByCategory`, `reduce()` can build an object (the accumulator) where keys are categories and values are sums. Remember to initialize `acc[category]` if it doesn't exist (`acc[category] = (acc[category] || 0) + value`).",
            "Make sure to handle string comparisons for categories (e.g., `toLowerCase()`)."
          ],
          "tags": [
            "Array Methods",
            "Reduce",
            "Map",
            "Filter",
            "Data Aggregation",
            "Object Transformation",
            "Frontend Interview",
            "Complex"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "javascript_functions",
            "javascript_objects",
            "callback_functions"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "reduce",
            "map",
            "filter",
            "chaining",
            "data aggregation",
            "object grouping"
          ]
        },
        {
          "id": "task_array_iteration_transformation_2",
          "title": "Implement Custom Array Sort and Reverse",
          "description": "\nWrite a function `sortAndReverseUsers(users)` that takes an array of user objects and performs a specific sorting and then reverses the result. Importantly, the function must *not* mutate the original `users` array.\n\n**User Object Structure:**\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  age: number;\n}\n```\n\n**Requirements:**\n1.  Sort the users by `age` in ascending order.\n2.  If two users have the same `age`, sort them by `name` alphabetically (ascending).\n3.  After sorting, reverse the entire array.\n4.  Return a *new array* at each step, ensuring the original `users` array remains untouched.\n",
          "difficulty": "hard",
          "startingCode": "interface User {\n  id: number;\n  name: string;\n  age: number;\n}\n\nfunction sortAndReverseUsers(users: User[]): User[] {\n  // TODO: Implement sorting and reversing without mutating the original array\n  // Hint: Consider slice() before sort() to create a copy.\n}\n",
          "solutionCode": "interface User {\n  id: number;\n  name: string;\n  age: number;\n}\n\nfunction sortAndReverseUsers(users: User[]): User[] {\n  if (!Array.isArray(users)) {\n    return [];\n  }\n\n  // 1. Create a shallow copy of the array BEFORE sorting to avoid mutation\n  const sortedUsers = users.slice().sort((a, b) => {\n    // Sort by age ascending\n    if (a.age !== b.age) {\n      return a.age - b.age;\n    }\n    // If ages are the same, sort by name alphabetically ascending\n    return a.name.localeCompare(b.name);\n  });\n\n  // 2. Reverse the *sorted copy* to avoid mutating the original array or the freshly sorted one\n  const reversedSortedUsers = sortedUsers.reverse();\n\n  return reversedSortedUsers;\n}\n\n// Test Data:\nconst originalUsers: User[] = [\n  { id: 1, name: 'Charlie', age: 30 },\n  { id: 2, name: 'Alice', age: 25 },\n  { id: 3, name: 'Bob', age: 30 },\n  { id: 4, name: 'David', age: 25 }\n];\n\nconst processedUsers = sortAndReverseUsers(originalUsers);\n\nconsole.log('Original Users:', originalUsers); // Should be untouched\n/* Expected Original:\n[\n  { id: 1, name: 'Charlie', age: 30 },\n  { id: 2, name: 'Alice', age: 25 },\n  { id: 3, name: 'Bob', age: 30 },\n  { id: 4, name: 'David', age: 25 }\n]\n*/\n\nconsole.log('Processed Users:', processedUsers);\n/* Expected Processed:\n   Initial sort (age asc, then name asc):\n   [ { id: 2, name: 'Alice', age: 25 },\n     { id: 4, name: 'David', age: 25 },\n     { id: 3, name: 'Bob', age: 30 },\n     { id: 1, name: 'Charlie', age: 30 } ]\n\n   Then reverse:\n   [ { id: 1, name: 'Charlie', age: 30 },\n     { id: 3, name: 'Bob', age: 30 },\n     { id: 4, name: 'David', age: 25 },\n     { id: 2, name: 'Alice', age: 25 } ]\n*/\n\nconst emptyUsers: User[] = [];\nconsole.log('Empty users processed:', sortAndReverseUsers(emptyUsers)); // []\n\nconst singleUser: User[] = [{ id: 5, name: 'Solo', age: 40 }];\nconsole.log('Single user processed:', sortAndReverseUsers(singleUser)); // [{ id: 5, name: 'Solo', age: 40 }]\n",
          "testCases": [
            "The original `users` array must remain unchanged.",
            "The returned array should be a new array.",
            "Sorting by age ascending must be correct.",
            "Secondary sort by name ascending for same ages must be correct.",
            "The final array must be the reverse of the fully sorted array.",
            "Test with empty array and single-element array."
          ],
          "hints": [
            "To ensure non-mutation, always start by creating a shallow copy of the array using `slice()` or the spread operator (`...arr`) before applying mutating methods like `sort()` or `reverse()`.",
            "The `sort()` method's comparison function can handle multiple sorting criteria by chaining `if` statements or using logical operators.",
            "`String.prototype.localeCompare()` is useful for string comparison."
          ],
          "tags": [
            "Array Methods",
            "Sorting",
            "Reversing",
            "Immutability",
            "Functional Programming",
            "Frontend Interview",
            "Complex"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "javascript_functions",
            "javascript_objects",
            "callback_functions"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "sort",
            "reverse",
            "slice",
            "immutability",
            "comparison function",
            "localeCompare"
          ]
        },
        {
          "id": "task_additional_array_1",
          "title": "Data Integrity Check for User Profiles",
          "description": "\nImplement a function `checkUserProfileIntegrity(profiles)` that performs several integrity checks on an array of user profile objects.\n\n**Profile Object Structure:**\n```typescript\ninterface Profile {\n  id: number;\n  username: string;\n  email: string;\n  isActive: boolean;\n  permissions: string[];\n}\n```\n\n**Requirements:**\n1.  Return `true` if *all* profiles have a non-empty `username`.\n2.  Return `true` if *at least one* profile is `isActive`.\n3.  Return `true` if *all* profiles have the 'user' permission in their `permissions` array.\n4.  The function should return `true` only if **ALL THREE** conditions above are met, otherwise `false`.\n",
          "difficulty": "hard",
          "startingCode": "interface Profile {\n  id: number;\n  username: string;\n  email: string;\n  isActive: boolean;\n  permissions: string[];\n}\n\nfunction checkUserProfileIntegrity(profiles: Profile[]): boolean {\n  // TODO: Implement all three checks using array methods\n  // and combine their results.\n}\n",
          "solutionCode": "interface Profile {\n  id: number;\n  username: string;\n  email: string;\n  isActive: boolean;\n  permissions: string[];\n}\n\nfunction checkUserProfileIntegrity(profiles: Profile[]): boolean {\n  if (!Array.isArray(profiles) || profiles.length === 0) {\n    return false; // No profiles to check, or invalid input\n  }\n\n  // Condition 1: All profiles have a non-empty username\n  const allUsernamesValid = profiles.every(profile => \n    typeof profile.username === 'string' && profile.username.trim() !== ''\n  );\n\n  // Condition 2: At least one profile is isActive\n  const atLeastOneActive = profiles.some(profile => profile.isActive);\n\n  // Condition 3: All profiles have 'user' permission\n  const allHaveUserPermission = profiles.every(profile => \n    Array.isArray(profile.permissions) && profile.permissions.includes('user')\n  );\n\n  // Return true only if all three conditions are met\n  return allUsernamesValid && atLeastOneActive && allHaveUserPermission;\n}\n\n// Test Cases:\nconst profiles1: Profile[] = [\n  { id: 1, username: 'user1', email: 'u1@example.com', isActive: true, permissions: ['user', 'editor'] },\n  { id: 2, username: 'user2', email: 'u2@example.com', isActive: false, permissions: ['user'] },\n  { id: 3, username: 'user3', email: 'u3@example.com', isActive: true, permissions: ['user', 'admin'] }\n];\nconsole.log('Profiles 1 (Expected: true):', checkUserProfileIntegrity(profiles1)); // true\n\nconst profiles2: Profile[] = [\n  { id: 1, username: '', email: 'u1@example.com', isActive: true, permissions: ['user'] }, // Invalid username\n  { id: 2, username: 'user2', email: 'u2@example.com', isActive: false, permissions: ['user'] }\n];\nconsole.log('Profiles 2 (Invalid username - Expected: false):', checkUserProfileIntegrity(profiles2)); // false\n\nconst profiles3: Profile[] = [\n  { id: 1, username: 'user1', email: 'u1@example.com', isActive: false, permissions: ['user'] },\n  { id: 2, username: 'user2', email: 'u2@example.com', isActive: false, permissions: ['user'] } // No active user\n];\nconsole.log('Profiles 3 (No active user - Expected: false):', checkUserProfileIntegrity(profiles3)); // false\n\nconst profiles4: Profile[] = [\n  { id: 1, username: 'user1', email: 'u1@example.com', isActive: true, permissions: ['guest'] }, // Missing 'user' permission\n  { id: 2, username: 'user2', email: 'u2@example.com', isActive: true, permissions: ['user'] }\n];\nconsole.log('Profiles 4 (Missing user permission - Expected: false):', checkUserProfileIntegrity(profiles4)); // false\n\nconst emptyProfiles: Profile[] = [];\nconsole.log('Empty profiles (Expected: false):', checkUserProfileIntegrity(emptyProfiles)); // false\n",
          "testCases": [
            "Returns `true` when all conditions are met.",
            "Returns `false` if `allUsernamesValid` fails (empty string or non-string username).",
            "Returns `false` if `atLeastOneActive` fails (no active profiles).",
            "Returns `false` if `allHaveUserPermission` fails (at least one profile lacks 'user' permission).",
            "Handles an empty input array (should return `false`).",
            "Handles profiles with `permissions` array missing or not an array."
          ],
          "hints": [
            "For 'all' conditions, `every()` is suitable.",
            "For 'at least one' conditions, `some()` is suitable.",
            "Remember to use `trim()` when checking for non-empty strings to account for whitespace.",
            "Combine the results of the individual checks using logical AND (`&&`).",
            "For the permissions check, ensure `profile.permissions` is an array before calling `includes()`."
          ],
          "tags": [
            "Array Methods",
            "Validation",
            "Conditional Logic",
            "Higher-Order Functions",
            "Frontend Interview",
            "Complex"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "javascript_functions",
            "javascript_objects",
            "callback_functions"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "every",
            "some",
            "includes",
            "string methods",
            "boolean logic",
            "data validation"
          ]
        },
        {
          "id": "task_additional_array_2",
          "title": "Circular Buffer Implementation",
          "description": "\nImplement a basic `CircularBuffer` class of a fixed size. A circular buffer (or ring buffer) is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. When the buffer is full and a new element is added, it overwrites the oldest element.\n\n**Requirements:**\n1.  `constructor(capacity)`: Initializes the buffer with a given `capacity`, an empty array, and internal pointers/indices.\n2.  `add(element)`: Adds an `element` to the buffer. If the buffer is full, it overwrites the oldest element. Use `push()` and `shift()` *conceptually* for adding/removing, but for efficiency or direct indexing, consider `fill()` or `copyWithin()` for managing the internal array if elements are strictly overwritten.\n3.  `getElements()`: Returns a *new array* containing the elements currently in the buffer, in the correct order (from oldest to newest without nulls/undefined if it hasn't filled yet).\n4.  `isFull()`: Returns `true` if the buffer is at its capacity, `false` otherwise.\n5.  `isEmpty()`: Returns `true` if the buffer contains no elements, `false` otherwise.\n\n**Constraint:** Use `Array.prototype.fill()` and/or `Array.prototype.copyWithin()` where appropriate to manage the internal array, especially for the `add` operation if you are avoiding `shift()` for performance reasons in a fixed-size array.",
          "difficulty": "hard",
          "startingCode": "class CircularBuffer<T> {\n  private buffer: T[];\n  private capacity: number;\n  private head: number;\n  private tail: number;\n  private currentSize: number;\n\n  constructor(capacity: number) {\n    // TODO: Initialize buffer, capacity, pointers\n  }\n\n  add(element: T): void {\n    // TODO: Add element, handle overflow (overwrite oldest)\n  }\n\n  getElements(): T[] {\n    // TODO: Return elements in correct order (oldest to newest)\n  }\n\n  isFull(): boolean {\n    // TODO: Check if buffer is full\n  }\n\n  isEmpty(): boolean {\n    // TODO: Check if buffer is empty\n  }\n}\n",
          "solutionCode": "class CircularBuffer<T> {\n  private buffer: T[];\n  private capacity: number;\n  private head: number; // Points to the first (oldest) element\n  private tail: number; // Points to the next available slot for a new element\n  private currentSize: number;\n\n  constructor(capacity: number) {\n    if (capacity <= 0) {\n      throw new Error('Capacity must be a positive integer.');\n    }\n    this.capacity = capacity;\n    this.buffer = new Array<T>(capacity);\n    this.head = 0;\n    this.tail = 0;\n    this.currentSize = 0;\n  }\n\n  add(element: T): void {\n    this.buffer[this.tail] = element; // Place new element at tail\n    this.tail = (this.tail + 1) % this.capacity; // Move tail pointer\n\n    if (this.isFull()) {\n      // If buffer was full before adding, the head pointer also moves\n      // because the new element overwrote the old head.\n      this.head = this.tail; \n    } else {\n      // If buffer was not full, increment size\n      this.currentSize++;\n    }\n  }\n\n  getElements(): T[] {\n    if (this.isEmpty()) {\n      return [];\n    }\n\n    const result: T[] = [];\n    if (this.tail > this.head) {\n      // No wrap-around yet: elements are head to tail-1\n      for (let i = this.head; i < this.tail; i++) {\n        result.push(this.buffer[i]);\n      }\n    } else if (this.currentSize > 0) {\n      // Wrapped around: elements are from head to end, then from start to tail-1\n      for (let i = this.head; i < this.capacity; i++) {\n        result.push(this.buffer[i]);\n      }\n      for (let i = 0; i < this.tail; i++) {\n        result.push(this.buffer[i]);\n      }\n    }\n    return result;\n    \n    // Alternative for getElements using slice and concat (more functional, potentially less efficient for very large buffers):\n    // if (this.isEmpty()) return [];\n    // if (this.tail > this.head) {\n    //   return this.buffer.slice(this.head, this.tail);\n    // } else if (this.currentSize > 0) {\n    //   return this.buffer.slice(this.head).concat(this.buffer.slice(0, this.tail));\n    // } \n    // return [];\n  }\n\n  isFull(): boolean {\n    return this.currentSize === this.capacity;\n  }\n\n  isEmpty(): boolean {\n    return this.currentSize === 0;\n  }\n}\n\n// Test Cases:\nconsole.log('--- Test CircularBuffer of capacity 3 ---');\nconst buffer3 = new CircularBuffer<string>(3);\nconsole.log('Initial empty:', buffer3.getElements(), 'Size:', buffer3.currentSize, 'Full:', buffer3.isFull(), 'Empty:', buffer3.isEmpty());\n\nbuffer3.add('A'); // [A, _, _]\nconsole.log('Add A:', buffer3.getElements(), 'Size:', buffer3.currentSize);\nbuffer3.add('B'); // [A, B, _]\nconsole.log('Add B:', buffer3.getElements(), 'Size:', buffer3.currentSize);\nbuffer3.add('C'); // [A, B, C] -> Full\nconsole.log('Add C:', buffer3.getElements(), 'Size:', buffer3.currentSize, 'Full:', buffer3.isFull());\n\nbuffer3.add('D'); // [D, B, C] -> Overwrites A, head moves to B's position conceptually (tail is D's next slot)\nconsole.log('Add D (overwrite A):', buffer3.getElements(), 'Size:', buffer3.currentSize);\n\nbuffer3.add('E'); // [D, E, C] -> Overwrites B\nconsole.log('Add E (overwrite B):', buffer3.getElements(), 'Size:', buffer3.currentSize);\n\nconsole.log('Is Full:', buffer3.isFull()); // true\nconsole.log('Is Empty:', buffer3.isEmpty()); // false\n\nconsole.log('\\n--- Test CircularBuffer of capacity 1 ---');\nconst buffer1 = new CircularBuffer<number>(1);\nconsole.log('Initial empty:', buffer1.getElements());\nbuffer1.add(10);\nconsole.log('Add 10:', buffer1.getElements()); // [10]\nbuffer1.add(20);\nconsole.log('Add 20 (overwrite 10):', buffer1.getElements()); // [20]\n\nconsole.log('\\n--- Test Edge Case: Capacity 0/Negative ---');\ntry {\n  new CircularBuffer<any>(0);\n} catch (e) {\n  console.error(e.message); // Should throw error\n}\n",
          "testCases": [
            "Constructor should initialize correctly with given capacity.",
            "`add` should add elements sequentially until full.",
            "`add` should overwrite the oldest element when full.",
            "`getElements` should return elements in correct order, handling wrap-around.",
            "`isFull` should correctly reflect buffer fullness.",
            "`isEmpty` should correctly reflect buffer emptiness.",
            "Test with capacity 1 (edge case).",
            "Test with adding more elements than capacity.",
            "Test `getElements` when not full.",
            "Test `getElements` when full and after overwrites.",
            "Ensure `getElements` returns a copy, not the internal array reference."
          ],
          "hints": [
            "You'll need `head`, `tail` (or `writePointer`), and `size` (or `currentLength`) pointers/variables to manage the buffer.",
            "Use the modulo operator (`%`) for circular indexing: `(pointer + 1) % capacity`.",
            "When the buffer is full and you add a new element, the `head` pointer conceptually advances (or gets overwritten directly by `tail` if `head` was `tail`).",
            "`getElements` might require combining two `slice` operations if the buffer has wrapped around (i.e., `tail` is less than `head`). Or, a manual loop from `head` to `tail` (with modulo arithmetic) can build the array.",
            "Directly using `this.buffer[this.tail] = element;` and `this.tail = (this.tail + 1) % this.capacity;` is the most common and efficient approach for `add()`, along with managing `head` and `currentSize`."
          ],
          "tags": [
            "Data Structure",
            "Array Methods",
            "Circular Buffer",
            "Algorithm",
            "Frontend Interview",
            "Complex"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "javascript_classes",
            "javascript_arrays",
            "modulo_operator",
            "data_structures_basics"
          ],
          "complexity": 9,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "relatedConcepts": [
            "fill",
            "copyWithin",
            "queue",
            "data structures",
            "memory management"
          ]
        },
        {
          "id": "task_mutating_vs_non_mutating_1",
          "title": "Migrate Mutating Operations to Immutable Ones",
          "description": "\nYou are given a JavaScript component that directly modifies arrays, leading to unpredictable behavior in a UI framework (e.g., React) that relies on immutable state. Your task is to refactor the provided functions to be **fully immutable**, meaning they must always return new arrays/objects and never modify the original inputs.\n\n**Requirements:**\n1.  `addTag(items, newTag)`: Adds a `newTag` to an array of `items`.\n2.  `removeFirstItem(items)`: Removes the first item from an array.\n3.  `updateItemAtIndex(items, index, newItem)`: Replaces an item at a specific `index` with `newItem`.\n\n**Constraint:** For each function, the original `items` array must remain unchanged. Each function must return a new array reflecting the change.\n",
          "difficulty": "medium",
          "startingCode": "function addTag(items, newTag) {\n  // CURRENTLY MUTATING! Needs refactoring.\n  items.push(newTag);\n  return items; \n}\n\nfunction removeFirstItem(items) {\n  // CURRENTLY MUTATING! Needs refactoring.\n  items.shift();\n  return items;\n}\n\nfunction updateItemAtIndex(items, index, newItem) {\n  // CURRENTLY MUTATING! Needs refactoring.\n  if (index >= 0 && index < items.length) {\n    items[index] = newItem;\n  }\n  return items;\n}\n",
          "solutionCode": "function addTag(items, newTag) {\n  // Immutable alternative using concat() or spread syntax\n  return items.concat(newTag);\n  // return [...items, newTag];\n}\n\nfunction removeFirstItem(items) {\n  // Immutable alternative using slice()\n  if (!Array.isArray(items) || items.length === 0) {\n    return []; // Return an empty array for empty or invalid input\n  }\n  return items.slice(1);\n}\n\nfunction updateItemAtIndex(items, index, newItem) {\n  // Immutable alternative using map() or slice() with spread syntax\n  if (!Array.isArray(items) || index < 0 || index >= items.length) {\n    return [...items]; // Return a shallow copy if index is out of bounds or invalid, or original if immutable return is desired for no change\n  }\n\n  // Option 1: Using map() for clarity for item-by-item transformation\n  return items.map((item, idx) => (idx === index ? newItem : item));\n\n  // Option 2: Using slice() and spread syntax for direct construction\n  // return [...items.slice(0, index), newItem, ...items.slice(index + 1)];\n}\n\n// Test Cases:\nconst initialItems = ['apple', 'banana', 'cherry'];\n\n// Test addTag\nconst newItemsAdd = addTag(initialItems, 'grape');\nconsole.log('Original after addTag:', initialItems); // Expected: ['apple', 'banana', 'cherry']\nconsole.log('New array after addTag:', newItemsAdd);   // Expected: ['apple', 'banana', 'cherry', 'grape']\n\n// Test removeFirstItem\nconst newItemsRemove = removeFirstItem(initialItems);\nconsole.log('Original after removeFirstItem:', initialItems); // Expected: ['apple', 'banana', 'cherry']\nconsole.log('New array after removeFirstItem:', newItemsRemove); // Expected: ['banana', 'cherry']\n\nconst emptyArray = [];\nconsole.log('Remove from empty:', removeFirstItem(emptyArray)); // Expected: []\n\n// Test updateItemAtIndex\nconst newItemsUpdate = updateItemAtIndex(initialItems, 1, 'blueberry');\nconsole.log('Original after updateItemAtIndex:', initialItems); // Expected: ['apple', 'banana', 'cherry']\nconsole.log('New array after updateItemAtIndex:', newItemsUpdate); // Expected: ['apple', 'blueberry', 'cherry']\n\nconst newItemsUpdateInvalid = updateItemAtIndex(initialItems, 99, 'invalid');\nconsole.log('Update invalid index (should be a copy of original):', newItemsUpdateInvalid); // Expected: ['apple', 'banana', 'cherry'] (copy)\nconsole.log('Are references same for invalid update?', initialItems === newItemsUpdateInvalid); // Expected: false (if using map/slice method which always makes a copy)\n\n// Another test case for update with object elements (important for immutability)\nconst users = [{id: 1, name: 'A'}, {id: 2, name: 'B'}];\nconst updatedUsers = updateItemAtIndex(users, 0, {id: 1, name: 'Z'});\nconsole.log('Original users:', users);\nconsole.log('Updated users:', updatedUsers);\nconsole.log('User references:', users[0] === updatedUsers[0]); // false (for updated item)\nconsole.log('User references:', users[1] === updatedUsers[1]); // true (for unchanged item)\n",
          "testCases": [
            "All refactored functions must return a *new* array.",
            "The original `items` array must remain unchanged after each function call.",
            "`addTag` should correctly add an element to the end of the new array.",
            "`removeFirstItem` should correctly remove the first element from the new array and handle empty arrays.",
            "`updateItemAtIndex` should correctly replace an element at a given index in the new array, and handle out-of-bounds indices by returning a copy of the original array (or original array itself if no change is desired and reference parity is key).",
            "Test with empty arrays.",
            "Test with single-element arrays.",
            "Test with arrays containing objects, ensuring nested immutability (if updating an object, return a *new* object, not just a new array)."
          ],
          "hints": [
            "For adding elements immutably, `concat()` or the spread syntax (`...`) are your best friends.",
            "For removing from the beginning or updating at an index, `slice()` combined with the spread syntax, or `map()` with conditional logic, are good choices.",
            "Remember that `map()` always returns a new array, making it ideal for transformations that preserve immutability.",
            "For `updateItemAtIndex`, ensure that if the element itself is an object, you also create a *new object* for the updated element, using object spread (`{ ...oldObject, newProperty: value }`)."
          ],
          "tags": [
            "Array Methods",
            "Immutability",
            "Refactoring",
            "Functional Programming",
            "Frontend Interview",
            "Medium"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "javascript_arrays",
            "javascript_functions",
            "object_spread_syntax"
          ],
          "complexity": 7,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "concat",
            "slice",
            "map",
            "spread syntax",
            "immutability",
            "state management"
          ]
        }
      ]
    }
  },
  {
    "id": "3cec5d31-0f91-45c6-9896-a858df622bf6",
    "startLine": 1300,
    "endLine": 1399,
    "processedDate": "2025-06-17T07:46:48.065Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_array_mutating_methods",
          "title": "Mutating Array Methods",
          "content": "Mutating array methods are functions that modify the original array directly (in-place) when they are called. Understanding which methods mutate and which do not is crucial for preventing unexpected side effects in your code, especially when working with references to arrays.\n\n## Key Mutating Methods\n\n### `splice()`\nThe `splice()` method changes the contents of an array by removing or replacing existing elements and/or adding new elements in place. It returns an array containing the deleted elements (if any).\n\n**Syntax:** `array.splice(start, deleteCount, item1, item2, ...)`\n*   `start`: Index at which to start changing the array.\n*   `deleteCount`: An integer indicating the number of elements to remove.\n*   `item1, item2, ...`: The elements to add to the array, starting at the `start` position. If no elements are specified, `splice()` only removes elements.\n\n### `sort()`\nThe `sort()` method sorts the elements of an array in place and returns the reference to the same array, now sorted. The default sort order is ascending, built upon converting the elements into strings, then comparing their sequences of UTF-16 code units. For numeric sorting, a compare function is necessary.\n\n**Syntax:** `array.sort([compareFunction])`\n*   `compareFunction`: A function that defines the sort order. It takes two arguments, `a` and `b`. If `compareFunction(a, b)` returns a value:\n    *   Less than 0: `a` comes before `b`.\n    *   Greater than 0: `b` comes before `a`.\n    *   Equal to 0: `a` and `b` remain unchanged with respect to each other, but are sorted with respect to all other elements.\n\n### `reverse()`\nThe `reverse()` method reverses the order of the elements in an array in place. The first array element becomes the last, and the last array element becomes the first. It returns a reference to the same array.\n\n**Syntax:** `array.reverse()`\n\n### `fill()`\nThe `fill()` method changes all elements in an array to a static value, from a start index (default 0) to an end index (default `array.length`). It modifies the original array and returns it.\n\n**Syntax:** `array.fill(value, [start], [end])`\n*   `value`: Value to fill the array with.\n*   `start` (optional): Start index, default 0.\n*   `end` (optional): End index (exclusive), default `array.length`.\n\n### `copyWithin()`\nThe `copyWithin()` method shallow copies part of an array to another location in the same array and returns it without modifying its length. It's useful for shifting elements within an array.\n\n**Syntax:** `array.copyWithin(target, start, [end])`\n*   `target`: Zero-based index at which to copy the sequence to.\n*   `start`: Zero-based index at which to start copying elements from.\n*   `end` (optional): Zero-based index at which to end copying elements from (exclusive). Defaults to `array.length`.\n",
          "examples": [
            {
              "id": "example_splice_1",
              "title": "Using `splice()` to Remove and Add Elements",
              "code": "const myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];\nconst removed = myFish.splice(2, 1, 'trumpet');\n// myFish is now ['angel', 'clown', 'trumpet', 'sturgeon']\n// removed contains ['mandarin'] - the element that was removed",
              "explanation": "This example demonstrates how `splice()` can remove 'mandarin' at index 2 and insert 'trumpet' in its place. The original `myFish` array is modified, and the removed element is returned.",
              "language": "javascript"
            },
            {
              "id": "example_sort_1",
              "title": "Basic `sort()` and Custom Numeric `sort()`",
              "code": "const fruits = ['banana', 'apple', 'orange'];\nfruits.sort(); // ['apple', 'banana', 'orange']\n\nconst numbers = [10, 5, 8, 1, 7];\nnumbers.sort((a, b) => a - b); // [1, 5, 7, 8, 10] (ascending)\nnumbers.sort((a, b) => b - a); // [10, 8, 7, 5, 1] (descending)",
              "explanation": "The first part shows default lexicographical string sorting. The second part illustrates how to sort numbers correctly using a compare function: `a - b` for ascending and `b - a` for descending order.",
              "language": "javascript"
            },
            {
              "id": "example_reverse_1",
              "title": "Using `reverse()`",
              "code": "const numbers = [1, 5, 7, 8, 10];\nnumbers.reverse(); // numbers is now [10, 8, 7, 5, 1]",
              "explanation": "This shows `reverse()` modifying the array `numbers` in place, changing the order of its elements.",
              "language": "javascript"
            },
            {
              "id": "example_fill_1",
              "title": "Using `fill()`",
              "code": "const filledFull = [1, 2, 3, 4, 5].fill(0); // [0, 0, 0, 0, 0]\nconst partiallyFilled = [1, 2, 3, 4, 5].fill(0, 2, 4); // [1, 2, 0, 0, 5]",
              "explanation": "The first example fills the entire array with zeros. The second example fills elements from index 2 (inclusive) up to index 4 (exclusive) with zeros, leaving other elements untouched.",
              "language": "javascript"
            },
            {
              "id": "example_copywithin_1",
              "title": "Using `copyWithin()`",
              "code": "const originalArray = [1, 2, 3, 4, 5];\noriginalArray.copyWithin(0, 3); // originalArray is now [4, 5, 3, 4, 5]",
              "explanation": "This demonstrates copying elements starting from index 3 (which are 4 and 5) to the beginning of the array, effectively overwriting elements at index 0 and 1. The length of the array remains unchanged.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "array methods",
            "mutation",
            "in-place",
            "splice",
            "sort",
            "reverse",
            "fill",
            "copyWithin"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "data manipulation",
            "algorithm implementation"
          ]
        },
        {
          "id": "theory_array_non_mutating_methods",
          "title": "Non-Mutating Array Methods (Return New Arrays)",
          "content": "Non-mutating array methods do not modify the original array. Instead, they return a new array containing the results of the operation. This characteristic makes them safer for functional programming paradigms and when you need to preserve the original data integrity.\n\n## Key Non-Mutating Methods\n\n### `concat()`\nThe `concat()` method is used to merge two or more arrays. This method does not change the existing arrays, but instead returns a new array.\n\n**Syntax:** `array1.concat(array2, array3, ...)`\n\n### `slice()`\nThe `slice()` method returns a shallow copy of a portion of an array into a new array object selected from `start` to `end` (end not included). The original array will not be modified.\n\n**Syntax:** `array.slice([start], [end])`\n*   `start` (optional): Zero-based index at which to begin extraction. Default is 0.\n*   `end` (optional): Zero-based index before which to end extraction. `slice` extracts up to (but not including) `end`. Default is `array.length`.\n\n### `map()`\nThe `map()` method creates a new array populated with the results of calling a provided function on every element in the calling array. It's excellent for transforming data.\n\n**Syntax:** `array.map(callback(currentValue, index, array), [thisArg])`\n*   `callback`: Function that is called for every element of `array`. It takes `currentValue`, `index`, and the `array` itself as arguments.\n\n### `filter()`\nThe `filter()` method creates a new array with all elements that pass the test implemented by the provided function. It's used for selective inclusion of elements.\n\n**Syntax:** `array.filter(callback(currentValue, index, array), [thisArg])`\n*   `callback`: Function that is called for every element of `array`. It should return a truthy value to keep the element, or a falsy value otherwise.\n\n### `reduce()`\nThe `reduce()` method executes a user-supplied 'reducer' callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements is a single value. This method is incredibly versatile for accumulating data.\n\n**Syntax:** `array.reduce(callback(accumulator, currentValue, index, array), [initialValue])`\n*   `callback`: A function that is called for each element. It takes `accumulator` (the value accumulated so far), `currentValue`, `index`, and `array` as arguments.\n*   `initialValue` (optional): A value to use as the first argument to the first call of the `callback`. If `initialValue` is not provided, the first element of the array is used as the `initialValue` and `currentValue` starts from the second element. If `initialValue` is not provided and the array is empty, `reduce` will throw a `TypeError`.\n\n### `flatMap()`\nThe `flatMap()` method returns a new array formed by applying a given callback function to each element of the array, and then flattening the result by one level. It is identical to `map()` followed by `flat(1)`.\n\n**Syntax:** `array.flatMap(callback(currentValue, index, array), [thisArg])`\n\n### `flat()`\nThe `flat()` method creates a new array with all sub-array elements concatenated into it recursively up to the specified depth. It's useful for flattening nested array structures.\n\n**Syntax:** `array.flat([depth])`\n*   `depth` (optional): The depth level specifying how deep a nested array structure should be flattened. Defaults to 1. `Infinity` can be used to flatten all nested arrays.",
          "examples": [
            {
              "id": "example_concat_1",
              "title": "Merging Arrays with `concat()`",
              "code": "const array1 = [1, 2];\nconst array2 = [3, 4];\nconst array3 = array1.concat(array2); // [1, 2, 3, 4]\n// array1 and array2 remain unchanged",
              "explanation": "This demonstrates how `concat()` creates a new array `array3` by joining `array1` and `array2` without altering the originals.",
              "language": "javascript"
            },
            {
              "id": "example_slice_1",
              "title": "Extracting a Portion with `slice()`",
              "code": "const original = [1, 2, 3, 4, 5];\nconst slice = original.slice(1, 4); // [2, 3, 4]\n// original remains [1, 2, 3, 4, 5]",
              "explanation": "`slice(1, 4)` extracts elements from index 1 (inclusive) up to index 4 (exclusive), resulting in a new array `[2, 3, 4]`. The `original` array is not modified.",
              "language": "javascript"
            },
            {
              "id": "example_map_1",
              "title": "Transforming Elements with `map()`",
              "code": "const numbers = [1, 2, 3];\nconst doubled = numbers.map(x => x * 2); // [2, 4, 6]\n// numbers remains [1, 2, 3]",
              "explanation": "Each element in `numbers` is multiplied by 2, and the results form a new array `doubled`. The `numbers` array is unaffected.",
              "language": "javascript"
            },
            {
              "id": "example_filter_1",
              "title": "Filtering Elements with `filter()`",
              "code": "const numbers = [1, 2, 3, 4, 5];\nconst filtered = numbers.filter(x => x > 3); // [4, 5]\n// numbers remains [1, 2, 3, 4, 5]",
              "explanation": "Only elements greater than 3 pass the test and are included in the new `filtered` array. The original `numbers` array is not changed.",
              "language": "javascript"
            },
            {
              "id": "example_reduce_1",
              "title": "Aggregating Data with `reduce()`",
              "code": "// Sum with initial value of 0\nconst sumWithInitial = [1, 2, 3, 4, 5].reduce((acc, current) => acc + current, 0); // 15\n\n// Sum without initial value (first element becomes initial accumulator)\nconst array1 = [1, 2, 3, 4];\nconst sumNoInitial = array1.reduce((accumulator, currentValue) => accumulator + currentValue); // 10\n\n// Type coercion in reduce (be careful!)\nconst concatenatedString = ['1', 2, 3, 4].reduce((accumulator, currentValue) => accumulator + currentValue); // '1234'",
              "explanation": "These examples showcase `reduce()`'s power. The first calculates a sum starting from 0. The second sums an array where the first element initializes the accumulator. The third demonstrates a common pitfall: type coercion. If the initial accumulator or first element is a string, subsequent additions might result in string concatenation instead of numeric sum.",
              "language": "javascript"
            },
            {
              "id": "example_flatmap_1",
              "title": "Mapping and Flattening with `flatMap()`",
              "code": "const nestedArrays = [[1], [2], [3]];\nconst flatMapped = nestedArrays.flatMap(x => x); // [1, 2, 3]\n\nconst sentences = ['hello world', 'goodbye moon'];\nconst words = sentences.flatMap(s => s.split(' ')); // ['hello', 'world', 'goodbye', 'moon']",
              "explanation": "The first example demonstrates `flatMap` applying the identity function (`x => x`) to each element, which are arrays, and then flattening them by one level. The second example shows a practical use case: splitting sentences into words and getting a single flat array of all words.",
              "language": "javascript"
            },
            {
              "id": "example_flat_1",
              "title": "Flattening Nested Arrays with `flat()`",
              "code": "const arrayToFlat = [[1, 2], [3, 4]];\nconst flattened = arrayToFlat.flat(); // [1, 2, 3, 4]\n\nconst deeplyNested = [1, [2, [3, [4]]]];\nconst flattenedDeep = deeplyNested.flat(Infinity); // [1, 2, 3, 4]",
              "explanation": "The first example flattens a simple 2-level nested array by one level (default). The second example uses `Infinity` to flatten a deeply nested array completely, extracting all elements into a single-level array.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "array methods",
            "non-mutating",
            "functional programming",
            "concat",
            "slice",
            "map",
            "filter",
            "reduce",
            "flatMap",
            "flat"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "javascript_callbacks"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "requiredFor": [
            "data transformation",
            "immutable data patterns"
          ]
        },
        {
          "id": "theory_array_search_inspection_methods",
          "title": "Array Search and Inspection Methods",
          "content": "These methods are used to search for elements within an array, check for their existence, or test if elements meet certain conditions. They typically return a boolean, an index, or the element itself, without modifying the original array.\n\n## Key Search and Inspection Methods\n\n### `includes()`\nThe `includes()` method determines whether an array includes a certain value among its entries, returning `true` or `false` as appropriate. It performs a strict equality comparison (like `===`).\n\n**Syntax:** `array.includes(valueToFind, [fromIndex])`\n*   `valueToFind`: The value to search for.\n*   `fromIndex` (optional): The position in this array at which to begin searching for `valueToFind`. Defaults to 0.\n\n### `indexOf()`\nThe `indexOf()` method returns the first index at which a given element can be found in the array, or -1 if it is not present. It uses strict equality comparison.\n\n**Syntax:** `array.indexOf(searchElement, [fromIndex])`\n*   `searchElement`: Element to locate in the array.\n*   `fromIndex` (optional): The index to start the search from. Defaults to 0.\n\n### `lastIndexOf()`\nThe `lastIndexOf()` method returns the last index at which a given element can be found in the array, or -1 if it is not present. The array is searched backwards, starting from `fromIndex`.\n\n**Syntax:** `array.lastIndexOf(searchElement, [fromIndex])`\n*   `searchElement`: Element to locate in the array.\n*   `fromIndex` (optional): The index to start the search from. Defaults to `array.length - 1`.\n\n### `find()`\nThe `find()` method returns the first element in the provided array that satisfies the provided testing function. If no elements satisfy the testing function, `undefined` is returned.\n\n**Syntax:** `array.find(callback(element, index, array), [thisArg])`\n*   `callback`: A function that is executed for each element. It should return a truthy value to indicate a match.\n\n### `findIndex()`\nThe `findIndex()` method returns the index of the first element in the array that satisfies the provided testing function. Otherwise, it returns -1.\n\n**Syntax:** `array.findIndex(callback(element, index, array), [thisArg])`\n*   `callback`: A function that is executed for each element. It should return a truthy value to indicate a match.\n\n### `some()`\nThe `some()` method tests whether at least one element in the array passes the test implemented by the provided function. It returns `true` if, in the array, it finds an element for which the provided function returns `true`; otherwise it returns `false`. It stops iterating as soon as the callback returns a truthy value.\n\n**Syntax:** `array.some(callback(element, index, array), [thisArg])`\n\n### `every()`\nThe `every()` method tests whether all elements in the array pass the test implemented by the provided function. It returns `true` if the callback function returns a truthy value for every array element; otherwise, `false`. It stops iterating as soon as the callback returns a falsy value.\n\n**Syntax:** `array.every(callback(element, index, array), [thisArg])`\n",
          "examples": [
            {
              "id": "example_includes_1",
              "title": "Checking for Value Existence with `includes()`",
              "code": "[1, 2, 3].includes(2); // true\n[1, 2, 3].includes(4); // false",
              "explanation": "Demonstrates simple checks for element existence within an array.",
              "language": "javascript"
            },
            {
              "id": "example_indexOf_1",
              "title": "Finding Element Index with `indexOf()`",
              "code": "['apple', 'banana', 'orange'].indexOf('banana'); // 1\n['apple', 'banana', 'orange'].indexOf('grape'); // -1",
              "explanation": "Shows how `indexOf()` returns the index of the first occurrence of an element, or -1 if not found.",
              "language": "javascript"
            },
            {
              "id": "example_lastIndexOf_1",
              "title": "Finding Last Element Index with `lastIndexOf()`",
              "code": "['apple', 'banana', 'apple'].lastIndexOf('apple'); // 2",
              "explanation": "Illustrates finding the index of the last occurrence of an element.",
              "language": "javascript"
            },
            {
              "id": "example_find_1",
              "title": "Finding First Matching Element with `find()`",
              "code": "[5, 12, 8, 130, 44].find(x => x > 10); // 12",
              "explanation": "Returns the first number in the array that is greater than 10.",
              "language": "javascript"
            },
            {
              "id": "example_findIndex_1",
              "title": "Finding Index of First Matching Element with `findIndex()`",
              "code": "[5, 12, 8, 130, 44].findIndex(x => x > 10); // 1",
              "explanation": "Returns the index of the first number in the array that is greater than 10.",
              "language": "javascript"
            },
            {
              "id": "example_some_1",
              "title": "Checking if Any Element Passes Test with `some()`",
              "code": "[5, 12, 8, 130, 44].some(x => x > 10); // true",
              "explanation": "Checks if at least one element is greater than 10. Since 12, 130, and 44 are, it returns true.",
              "language": "javascript"
            },
            {
              "id": "example_every_1",
              "title": "Checking if All Elements Pass Test with `every()`",
              "code": "[12, 54, 18, 130, 44].every(x => x > 10); // true\n[10, 54, 18].every(x => x > 10); // false (because 10 is not > 10)",
              "explanation": "The first example returns true because all elements are greater than 10. The second example returns false because 10 is not strictly greater than 10, failing the test.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "array methods",
            "search",
            "inspection",
            "includes",
            "indexOf",
            "lastIndexOf",
            "find",
            "findIndex",
            "some",
            "every"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "javascript_callbacks"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "data validation",
            "conditional logic"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_mutating_non_mutating_diff_1",
          "topic": "Mutating vs. Non-Mutating Array Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference between mutating and non-mutating array methods in JavaScript?",
          "answer": "Mutating methods modify the original array in place, while non-mutating methods return a new array without altering the original.",
          "options": [],
          "analysisPoints": [
            "Understanding of side effects in programming.",
            "Importance of immutability in certain programming paradigms."
          ],
          "keyConcepts": [
            "mutability",
            "immutability",
            "side effects",
            "array methods"
          ],
          "evaluationCriteria": [
            "Ability to define key difference",
            "Understanding of implications"
          ],
          "example": "",
          "tags": [
            "array methods",
            "mutability",
            "immutability"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_splice_output_1",
          "topic": "`splice()` Method",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code:\n```javascript\nconst animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];\nconst removedAnimals = animals.splice(2, 2, 'cat', 'dog');\n\nconsole.log(animals);\nconsole.log(removedAnimals);\n```\nWhat will be the output for `animals` and `removedAnimals`?",
          "answer": "animals: ['ant', 'bison', 'cat', 'dog', 'elephant'], removedAnimals: ['camel', 'duck']",
          "options": [
            "animals: ['ant', 'bison', 'camel', 'duck', 'elephant'], removedAnimals: ['cat', 'dog']",
            "animals: ['ant', 'bison', 'cat', 'dog', 'elephant'], removedAnimals: ['camel', 'duck']",
            "animals: ['ant', 'bison', 'camel', 'duck'], removedAnimals: ['cat', 'dog', 'elephant']",
            "animals: ['ant', 'bison', 'cat', 'dog'], removedAnimals: ['camel', 'duck', 'elephant']"
          ],
          "analysisPoints": [
            "Understanding `splice()`'s ability to remove and add elements simultaneously.",
            "Knowing that `splice()` returns the *removed* elements.",
            "Recognizing that `splice()` modifies the original array in place."
          ],
          "keyConcepts": [
            "splice",
            "mutating methods",
            "return value"
          ],
          "evaluationCriteria": [
            "Correctly identifying modified array state",
            "Correctly identifying returned array content"
          ],
          "example": "The `splice(2, 2, 'cat', 'dog')` call starts at index 2 ('camel'), removes 2 elements ('camel', 'duck'), and inserts 'cat' and 'dog'. The removed elements ('camel', 'duck') are returned in a new array.",
          "tags": [
            "splice",
            "array methods",
            "mutating",
            "mcq"
          ],
          "prerequisites": [
            "theory_array_mutating_methods"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_sort_numeric_1",
          "topic": "`sort()` Method",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you sort an array of numbers `[20, 1, 100, 5]` in ascending order using JavaScript's `sort()` method?",
          "answer": "You must provide a custom compare function: `numbers.sort((a, b) => a - b);`",
          "options": [],
          "analysisPoints": [
            "Understanding the default string-based sorting of `sort()`.",
            "Knowledge of providing a custom compare function for numeric sorting."
          ],
          "keyConcepts": [
            "sort",
            "compare function",
            "numeric sort",
            "mutating methods"
          ],
          "evaluationCriteria": [
            "Providing correct syntax for numeric sort",
            "Understanding the necessity of custom comparator"
          ],
          "example": "```javascript\nconst numbers = [20, 1, 100, 5];\nnumbers.sort((a, b) => a - b); // [1, 5, 20, 100]\n```",
          "tags": [
            "sort",
            "array methods",
            "mutating",
            "numeric sort"
          ],
          "prerequisites": [
            "theory_array_mutating_methods"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_fill_copywithin_1",
          "topic": "`fill()` and `copyWithin()` Methods",
          "level": "medium",
          "type": "mcq",
          "question": "What will be the value of `arr` after the following operations?\n```javascript\nlet arr = [1, 2, 3, 4, 5, 6, 7];\narr.fill(0, 3, 5);\narr.copyWithin(0, 5);\n```",
          "answer": "[6, 7, 3, 0, 0, 6, 7]",
          "options": [
            "[6, 7, 3, 4, 5, 6, 7]",
            "[1, 2, 3, 0, 0, 6, 7]",
            "[6, 7, 3, 4, 0, 0, 7]",
            "[6, 7, 3, 0, 0, 6, 7]"
          ],
          "analysisPoints": [
            "Understanding the `fill()` method's parameters (value, start, end).",
            "Understanding the `copyWithin()` method's parameters (target, start, end).",
            "Tracking in-place modifications for consecutive mutating operations."
          ],
          "keyConcepts": [
            "fill",
            "copyWithin",
            "mutating methods"
          ],
          "evaluationCriteria": [
            "Accurate tracking of array state changes",
            "Correct application of method parameters"
          ],
          "example": "1. `arr = [1, 2, 3, 4, 5, 6, 7]`\n2. `arr.fill(0, 3, 5);`\n   - Fills from index 3 (inclusive) up to (but not including) 5 with 0.\n   - `arr` becomes `[1, 2, 3, 0, 0, 6, 7]`\n3. `arr.copyWithin(0, 5);`\n   - Copies elements starting from index 5 (which are 6, 7) to index 0.\n   - `arr` becomes `[6, 7, 3, 0, 0, 6, 7]` (The original elements at indices 5 and 6 remain if not overwritten by the copy operation's target range.)",
          "tags": [
            "fill",
            "copyWithin",
            "array methods",
            "mutating"
          ],
          "prerequisites": [
            "theory_array_mutating_methods"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_map_filter_diff_1",
          "topic": "`map()` vs. `filter()`",
          "level": "medium",
          "type": "open",
          "question": "Explain the primary difference between `Array.prototype.map()` and `Array.prototype.filter()` methods. Provide a scenario where each would be more appropriate.",
          "answer": "Both `map()` and `filter()` are non-mutating array methods that return new arrays. However, their primary purposes differ:\n\n*   **`map()`**: Used for **transformation**. It creates a new array by applying a callback function to each element of the original array. The new array will always have the same length as the original array, but its elements will be the results of the callback function.\n    *   **Scenario**: Doubling all numbers in an array: `const numbers = [1, 2, 3]; const doubled = numbers.map(n => n * 2); // [2, 4, 6]`\n\n*   **`filter()`**: Used for **selection/subsetting**. It creates a new array containing only the elements from the original array for which the provided callback function returns `true` (or a truthy value). The new array's length can be less than or equal to the original array's length.\n    *   **Scenario**: Getting all even numbers from an array: `const numbers = [1, 2, 3, 4, 5]; const evens = numbers.filter(n => n % 2 === 0); // [2, 4]`",
          "options": [],
          "analysisPoints": [
            "Clarity in defining the purpose of each method.",
            "Accuracy in describing their return values and impact on array length.",
            "Ability to provide relevant and distinct use cases for each."
          ],
          "keyConcepts": [
            "map",
            "filter",
            "non-mutating methods",
            "transformation",
            "selection"
          ],
          "evaluationCriteria": [
            "Accuracy of definitions",
            "Quality of examples",
            "Completeness of explanation"
          ],
          "example": "",
          "tags": [
            "map",
            "filter",
            "array methods",
            "non-mutating",
            "open-ended"
          ],
          "prerequisites": [
            "theory_array_non_mutating_methods"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_reduce_initial_value_1",
          "topic": "`reduce()` Method",
          "level": "medium",
          "type": "mcq",
          "question": "What is the output of the following JavaScript code?\n```javascript\nconst data = [10, 20, 30];\nconst result1 = data.reduce((acc, val) => acc + val);\nconst result2 = data.reduce((acc, val) => acc + val, 5);\nconst result3 = [].reduce((acc, val) => acc + val, 0);\nconst result4 = [].reduce((acc, val) => acc + val);\n\nconsole.log(result1);\nconsole.log(result2);\nconsole.log(result3);\nconsole.log(result4);\n```",
          "answer": "60, 65, 0, TypeError",
          "options": [
            "60, 65, 0, 0",
            "60, 65, 0, TypeError",
            "60, 60, 0, undefined",
            "10, 15, 0, TypeError"
          ],
          "analysisPoints": [
            "Understanding the behavior of `reduce()` with and without `initialValue`.",
            "Knowing how `initialValue` affects the starting point of the accumulation.",
            "Recognizing the `TypeError` when `reduce()` is called on an empty array without an `initialValue`."
          ],
          "keyConcepts": [
            "reduce",
            "initialValue",
            "accumulator",
            "type coercion",
            "error handling"
          ],
          "evaluationCriteria": [
            "Correctly predicting `reduce` behavior",
            "Identifying edge cases (empty array)"
          ],
          "example": "1. `result1`: `reduce` without `initialValue`. `acc` starts at `10`, `val` at `20`. `10+20=30`, then `30+30=60`. Output: `60`.\n2. `result2`: `reduce` with `initialValue` of `5`. `acc` starts at `5`, `val` at `10`. `5+10=15`, then `15+20=35`, then `35+30=65`. Output: `65`.\n3. `result3`: `reduce` on empty array with `initialValue` of `0`. The callback is never executed. `initialValue` is returned. Output: `0`.\n4. `result4`: `reduce` on empty array without `initialValue`. This throws a `TypeError` because there's no initial value for the accumulator and no first element to use as one.",
          "tags": [
            "reduce",
            "array methods",
            "non-mutating",
            "initialValue",
            "error handling",
            "mcq"
          ],
          "prerequisites": [
            "theory_array_non_mutating_methods"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_flat_flatMap_1",
          "topic": "`flat()` and `flatMap()` Methods",
          "level": "medium",
          "type": "open",
          "question": "Describe the main difference between `Array.prototype.flat()` and `Array.prototype.flatMap()`. When would you choose one over the other?",
          "answer": "`flat()` and `flatMap()` both deal with flattening nested arrays, but `flatMap()` combines flattening with mapping.\n\n*   **`flat()`**: Its primary purpose is to **flatten a multi-dimensional array** into a single-dimensional array (or fewer dimensions). It takes an optional `depth` argument, which specifies how many levels of nested arrays should be flattened. It's useful when you already have nested arrays and just need to reduce their dimensionality.\n    *   **Example**: `[[1, 2], [3, [4, 5]]].flat(1)` results in `[1, 2, 3, [4, 5]]`. `flat(Infinity)` would flatten all levels.\n\n*   **`flatMap()`**: This method is conceptually equivalent to calling `map()` followed by `flat()` with a depth of 1. It first **maps each element** of the array using a provided callback function, and then **flattens the result by one level**. It's ideal when your mapping operation itself returns an array (or iterable) and you want to consolidate those results into a single flat array.\n    *   **Example**: `['a b', 'c d'].flatMap(s => s.split(' '))` results in `['a', 'b', 'c', 'd']`. Here, `split(' ')` returns an array, and `flatMap` flattens these into a single array.\n\n**When to choose:**\n*   Choose `flat()` when you *already have* a nested array and you just need to reduce its nesting depth.\n*   Choose `flatMap()` when you want to *transform* each element into an array (or iterable) and then immediately flatten those resulting arrays into a single, combined array. It's a convenient shorthand for `map().flat(1)`.",
          "options": [],
          "analysisPoints": [
            "Understanding the `map` and `flat` combination in `flatMap`.",
            "Ability to differentiate their core functionalities (flattening vs. mapping + flattening).",
            "Providing clear examples for each and a practical comparison."
          ],
          "keyConcepts": [
            "flat",
            "flatMap",
            "array methods",
            "non-mutating",
            "nesting"
          ],
          "evaluationCriteria": [
            "Accuracy of definitions",
            "Clarity of explanation",
            "Relevance of examples"
          ],
          "example": "",
          "tags": [
            "flat",
            "flatMap",
            "array methods",
            "non-mutating",
            "open-ended"
          ],
          "prerequisites": [
            "theory_array_non_mutating_methods"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_search_methods_selection_1",
          "topic": "Array Search and Inspection Methods",
          "level": "medium",
          "type": "mcq",
          "question": "You have an array of objects representing users: `[{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }, { id: 3, name: 'Alice' }]`.\nWhich method would you use to find the *first* user object with `name: 'Alice'`?",
          "answer": "`find()`",
          "options": [
            "`filter()`",
            "`includes()`",
            "`indexOf()`",
            "`find()`"
          ],
          "analysisPoints": [
            "Understanding that `find()` returns the *element* itself (or `undefined`).",
            "Differentiating `find()` from `filter()` (which returns an array of all matches).",
            "Recognizing that `includes()` and `indexOf()` are for primitive values or direct object references, not properties of objects."
          ],
          "keyConcepts": [
            "find",
            "filter",
            "includes",
            "indexOf",
            "array search",
            "object comparison"
          ],
          "evaluationCriteria": [
            "Correct selection of method for object search",
            "Understanding method return types"
          ],
          "example": "```javascript\nconst users = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }, { id: 3, name: 'Alice' }];\nconst alice = users.find(user => user.name === 'Alice');\nconsole.log(alice); // { id: 1, name: 'Alice' }\n```",
          "tags": [
            "find",
            "array methods",
            "search",
            "mcq"
          ],
          "prerequisites": [
            "theory_array_search_inspection_methods"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_some_every_diff_1",
          "topic": "`some()` vs. `every()`",
          "level": "medium",
          "type": "open",
          "question": "Explain the difference between `Array.prototype.some()` and `Array.prototype.every()`. Provide an example for each.",
          "answer": "Both `some()` and `every()` are iteration methods that test elements of an array against a provided condition, returning a boolean value. They are both short-circuiting.\n\n*   **`some()`**: Tests whether **at least one** element in the array passes the provided test. It returns `true` as soon as the callback function returns a truthy value for *any* element; otherwise, it returns `false` if no element passes the test or the array is empty.\n    *   **Example**: `const numbers = [1, 5, 8, 10]; numbers.some(num => num > 7); // true (because 8 and 10 are > 7)`\n\n*   **`every()`**: Tests whether **all** elements in the array pass the provided test. It returns `true` only if the callback function returns a truthy value for *every single* element; otherwise, it returns `false` as soon as the callback returns a falsy value for any element. If the array is empty, `every()` returns `true` (vacuously true).\n    *   **Example**: `const numbers = [2, 4, 6, 8]; numbers.every(num => num % 2 === 0); // true (all are even)`\n    *   `[2, 3, 4].every(num => num % 2 === 0); // false (because 3 is not even)`",
          "options": [],
          "analysisPoints": [
            "Clearly defining the 'at least one' vs. 'all' distinction.",
            "Explaining the short-circuiting behavior.",
            "Addressing the empty array case for `every()`.",
            "Providing clear, distinct examples."
          ],
          "keyConcepts": [
            "some",
            "every",
            "array iteration",
            "boolean return",
            "short-circuiting"
          ],
          "evaluationCriteria": [
            "Accuracy of definitions",
            "Clarity of examples",
            "Completeness of explanation"
          ],
          "example": "",
          "tags": [
            "some",
            "every",
            "array methods",
            "search",
            "open-ended"
          ],
          "prerequisites": [
            "theory_array_search_inspection_methods"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_chaining_methods_1",
          "topic": "Chaining Array Methods",
          "level": "hard",
          "type": "code",
          "question": "Given an array of objects representing sales transactions:\n`const transactions = [\n  { id: 1, item: 'Laptop', price: 1200, quantity: 1, category: 'Electronics' },\n  { id: 2, item: 'Mouse', price: 25, quantity: 2, category: 'Electronics' },\n  { id: 3, item: 'Keyboard', price: 75, quantity: 1, category: 'Electronics' },\n  { id: 4, item: 'T-Shirt', price: 20, quantity: 3, category: 'Apparel' },\n  { id: 5, item: 'Jeans', price: 60, quantity: 1, category: 'Apparel' },\n  { id: 6, item: 'Monitor', price: 300, quantity: 1, category: 'Electronics' }\n];`\n\nWrite JavaScript code using a chain of non-mutating array methods (`filter`, `map`, `reduce`) to calculate the total revenue generated *only from 'Electronics'* category items that have a total item value (price * quantity) *greater than $100*.\n\nThe final result should be a single number.",
          "answer": "```javascript\nconst transactions = [\n  { id: 1, item: 'Laptop', price: 1200, quantity: 1, category: 'Electronics' },\n  { id: 2, item: 'Mouse', price: 25, quantity: 2, category: 'Electronics' },\n  { id: 3, item: 'Keyboard', price: 75, quantity: 1, category: 'Electronics' },\n  { id: 4, item: 'T-Shirt', price: 20, quantity: 3, category: 'Apparel' },\n  { id: 5, item: 'Jeans', price: 60, quantity: 1, category: 'Apparel' },\n  { id: 6, item: 'Monitor', price: 300, quantity: 1, category: 'Electronics' }\n];\n\nconst totalRevenue = transactions\n  .filter(transaction => transaction.category === 'Electronics') // Filter for Electronics\n  .filter(transaction => (transaction.price * transaction.quantity) > 100) // Filter for value > $100\n  .reduce((total, transaction) => total + (transaction.price * transaction.quantity), 0); // Sum up total values\n\nconsole.log(totalRevenue); // Expected: 1200 + 300 = 1500\n```",
          "options": [],
          "analysisPoints": [
            "Ability to combine multiple array methods (`filter`, `map`, `reduce`) in a chain.",
            "Correct application of filtering conditions.",
            "Accurate calculation of intermediate values (`price * quantity`).",
            "Proper use of `reduce()` for aggregation with an `initialValue`."
          ],
          "keyConcepts": [
            "filter",
            "map",
            "reduce",
            "chaining methods",
            "non-mutating",
            "data aggregation"
          ],
          "evaluationCriteria": [
            "Correctness of the final output",
            "Efficiency of the chain",
            "Adherence to non-mutating requirement"
          ],
          "example": "",
          "tags": [
            "filter",
            "map",
            "reduce",
            "array methods",
            "chaining",
            "code challenge"
          ],
          "prerequisites": [
            "theory_array_non_mutating_methods"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_array_method_return_types_1",
          "topic": "Array Method Return Types",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following array methods *modifies the original array and returns the modified array itself*?",
          "answer": "`reverse()`",
          "options": [
            "`slice()`",
            "`map()`",
            "`concat()`",
            "`reverse()`"
          ],
          "analysisPoints": [
            "Distinguishing between methods that return a new array vs. modifying in place.",
            "Knowledge of the specific return values of various array methods."
          ],
          "keyConcepts": [
            "mutating methods",
            "non-mutating methods",
            "return values"
          ],
          "evaluationCriteria": [
            "Correctly identifying a mutating method",
            "Understanding method side effects"
          ],
          "example": "```javascript\nconst arr1 = [1, 2, 3];\nconst sliced = arr1.slice(1); // [2, 3], arr1 is still [1, 2, 3]\n\nconst arr2 = [1, 2, 3];\nconst mapped = arr2.map(x => x * 2); // [2, 4, 6], arr2 is still [1, 2, 3]\n\nconst arr3 = [1, 2];\nconst concated = arr3.concat([3]); // [1, 2, 3], arr3 is still [1, 2]\n\nconst arr4 = [1, 2, 3];\nconst reversed = arr4.reverse(); // [3, 2, 1], arr4 is now [3, 2, 1] AND reversed is also [3, 2, 1]\n```",
          "tags": [
            "mutating",
            "non-mutating",
            "array methods",
            "mcq"
          ],
          "prerequisites": [
            "theory_array_mutating_methods",
            "theory_array_non_mutating_methods"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_find_findIndex_diff_1",
          "topic": "`find()` vs `findIndex()`",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference in the return value of `find()` versus `findIndex()`?",
          "answer": "`find()` returns the first element that satisfies the condition (or `undefined`), while `findIndex()` returns the index of the first element that satisfies the condition (or -1).",
          "options": [],
          "analysisPoints": [
            "Understanding return types for search methods.",
            "Knowing the difference between an element and its index."
          ],
          "keyConcepts": [
            "find",
            "findIndex",
            "return value",
            "search methods"
          ],
          "evaluationCriteria": [
            "Accuracy of comparison",
            "Clarity of definition"
          ],
          "example": "",
          "tags": [
            "find",
            "findIndex",
            "array methods",
            "search",
            "flashcard"
          ],
          "prerequisites": [
            "theory_array_search_inspection_methods"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_manage_inventory_mutating",
          "title": "Inventory Management with Mutating Methods",
          "description": "\nImplement a JavaScript function `manageInventory` that simulates inventory operations on an array of product IDs. The function should perform the following operations in sequence using *mutating* array methods:\n\n1.  **Restock**: Add new product IDs to a specific position in the inventory.\n    *   If `newProducts` is provided, insert them starting at `startIndex`.\n2.  **Discontinue**: Remove a certain number of products from a given index.\n    *   If `discontinueCount` is greater than 0, remove that many items starting at `discontinueIndex`.\n3.  **Sort Inventory**: Sort the remaining product IDs numerically in ascending order.\n4.  **Fill Placeholders**: Replace the first `n` elements (where `n` is `fillCount`) of the array with a placeholder value (e.g., `null`), representing unavailable items, without changing the array length.\n\nYour function should return the final modified inventory array.\n",
          "difficulty": "medium",
          "startingCode": "function manageInventory(inventory, newProducts, startIndex, discontinueIndex, discontinueCount, fillCount) {\n  // 1. Restock (using splice)\n  if (newProducts && newProducts.length > 0) {\n    // TODO: Implement restock\n  }\n\n  // 2. Discontinue (using splice)\n  if (discontinueCount > 0) {\n    // TODO: Implement discontinue\n  }\n\n  // 3. Sort Inventory (using sort)\n  // TODO: Implement sort\n\n  // 4. Fill Placeholders (using fill)\n  if (fillCount > 0) {\n    // TODO: Implement fill\n  }\n\n  return inventory;\n}",
          "solutionCode": "function manageInventory(inventory, newProducts, startIndex, discontinueIndex, discontinueCount, fillCount) {\n  // Ensure inventory is an array\n  if (!Array.isArray(inventory)) {\n    throw new Error('Inventory must be an array.');\n  }\n\n  // 1. Restock (using splice)\n  if (newProducts && newProducts.length > 0) {\n    inventory.splice(startIndex, 0, ...newProducts);\n  }\n\n  // 2. Discontinue (using splice)\n  if (discontinueCount > 0) {\n    inventory.splice(discontinueIndex, discontinueCount);\n  }\n\n  // 3. Sort Inventory (using sort)\n  inventory.sort((a, b) => a - b);\n\n  // 4. Fill Placeholders (using fill)\n  if (fillCount > 0) {\n    inventory.fill(null, 0, fillCount);\n  }\n\n  return inventory;\n}",
          "testCases": [
            "manageInventory([10, 20, 30], [5, 15], 1, 0, 0, 0) should return [5, 10, 15, 20, 30]",
            "manageInventory([10, 20, 30, 40, 50], null, 0, 1, 2, 0) should return [10, 40, 50]",
            "manageInventory([1, 20, 5, 15, 10], null, 0, 0, 0, 0) should return [1, 5, 10, 15, 20]",
            "manageInventory([10, 20, 30, 40, 50], null, 0, 0, 0, 2) should return [null, null, 30, 40, 50]",
            "manageInventory([1, 2, 3, 4, 5], [100, 200], 2, 0, 1, 1) should return [null, 2, 100, 200, 3, 4, 5] (Sequence: initial [1,2,3,4,5] -> splice(2,0,100,200): [1,2,100,200,3,4,5] -> splice(0,1): [2,100,200,3,4,5] -> sort: [2,3,4,5,100,200] -> fill(null,0,1): [null,3,4,5,100,200])",
            "manageInventory([], [1, 2], 0, 0, 0, 0) should return [1, 2]"
          ],
          "hints": [
            "Remember that `splice()` can be used to insert elements by setting `deleteCount` to 0.",
            "For numeric sorting, `sort()` requires a compare function.",
            "Pay close attention to the `start` and `end` parameters for `fill()` to target the correct range."
          ],
          "tags": [
            "splice",
            "sort",
            "fill",
            "mutating methods",
            "array manipulation",
            "inventory"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_array_mutating_methods"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "side effects",
            "data integrity"
          ]
        },
        {
          "id": "task_analyze_sales_data_non_mutating",
          "title": "Analyze Sales Data with Non-Mutating Methods",
          "description": "\nImplement a JavaScript function `analyzeSales` that takes an array of sales records and returns a new object containing aggregated data. The function should utilize *non-mutating* array methods to achieve the following:\n\n1.  **Filter High-Value Sales**: Select only sales records where the `amount` is greater than or equal to `$500`.\n2.  **Transform Data**: For each selected sale, create a new object containing only `transactionId`, `itemName`, and `totalPrice` (calculated as `amount * quantity`).\n3.  **Calculate Total Revenue**: Compute the sum of `totalPrice` for all the transformed high-value sales.\n4.  **List Unique Items**: Create an array of unique `itemName`s from the high-value sales.\n5.  **Output Structure**: The function should return an object like `{ totalRevenue: number, uniqueItemsSold: string[] }`.\n\nUse chaining where appropriate for efficiency and readability.\n",
          "difficulty": "hard",
          "startingCode": "function analyzeSales(salesRecords) {\n  // Sample salesRecords format:\n  // [{ transactionId: 'T101', itemName: 'Laptop', amount: 1200, quantity: 1 }, ...]\n\n  // TODO: Implement filtering, mapping, reducing, and identifying unique items\n\n  return {\n    totalRevenue: 0, // Placeholder\n    uniqueItemsSold: [] // Placeholder\n  };\n}",
          "solutionCode": "function analyzeSales(salesRecords) {\n  if (!Array.isArray(salesRecords)) {\n    throw new Error('Input must be an array of sales records.');\n  }\n\n  const highValueSales = salesRecords.filter(sale => sale.amount * sale.quantity >= 500);\n\n  const transformedSales = highValueSales.map(sale => ({\n    transactionId: sale.transactionId,\n    itemName: sale.itemName,\n    totalPrice: sale.amount * sale.quantity\n  }));\n\n  const totalRevenue = transformedSales.reduce((acc, sale) => acc + sale.totalPrice, 0);\n\n  // To get unique items, map to item names and then use Set to filter duplicates\n  const uniqueItemsSold = [...new Set(highValueSales.map(sale => sale.itemName))];\n\n  return {\n    totalRevenue,\n    uniqueItemsSold\n  };\n}",
          "testCases": [
            "analyzeSales([\n  { transactionId: 'T001', itemName: 'Keyboard', amount: 75, quantity: 2 },\n  { transactionId: 'T002', itemName: 'Monitor', amount: 500, quantity: 1 },\n  { transactionId: 'T003', itemName: 'Laptop', amount: 1200, quantity: 1 },\n  { transactionId: 'T004', itemName: 'Mouse', amount: 20, quantity: 5 },\n  { transactionId: 'T005', itemName: 'Monitor', amount: 600, quantity: 1 }\n]) should return { totalRevenue: 2300, uniqueItemsSold: ['Monitor', 'Laptop'] }",
            "analyzeSales([]) should return { totalRevenue: 0, uniqueItemsSold: [] }",
            "analyzeSales([\n  { transactionId: 'T001', itemName: 'Keyboard', amount: 75, quantity: 2 },\n  { transactionId: 'T002', itemName: 'Mouse', amount: 20, quantity: 5 }\n]) should return { totalRevenue: 0, uniqueItemsSold: [] } (no high-value sales)",
            "analyzeSales([\n  { transactionId: 'T001', itemName: 'Laptop', amount: 1000, quantity: 1 },\n  { transactionId: 'T002', itemName: 'Laptop', amount: 1500, quantity: 1 }\n]) should return { totalRevenue: 2500, uniqueItemsSold: ['Laptop'] }"
          ],
          "hints": [
            "Chain `filter()` first to narrow down the data.",
            "Use `map()` to transform the filtered data into the desired structure.",
            "Employ `reduce()` for summing the calculated `totalPrice`.",
            "For unique items, consider mapping to the item names first, then using a `Set` to get unique values, and finally spreading the Set back into an array."
          ],
          "tags": [
            "filter",
            "map",
            "reduce",
            "chaining",
            "non-mutating",
            "data aggregation",
            "object manipulation"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_array_non_mutating_methods",
            "javascript_objects"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "functional programming",
            "immutability",
            "data processing"
          ]
        },
        {
          "id": "task_validate_and_search_users",
          "title": "User Validation and Search System",
          "description": "\nImplement a JavaScript function `processUsers` that takes an array of user objects and performs validation and search operations using *search and inspection* array methods.\n\nEach user object has `id` (number), `username` (string), and `isActive` (boolean).\n\nYour function should return an object with the following properties:\n\n1.  **`hasAdmins`**: A boolean indicating if *any* user in the array has the `username` 'admin'.\n2.  **`allActive`**: A boolean indicating if *all* users in the array are `isActive`.\n3.  **`firstInactiveUser`**: The first user object found that is `isActive: false`. If no inactive user is found, this should be `null`.\n4.  **`indexOfSpecificUser`**: The index of the user with `username: 'guest'` and `id: 99`. If not found, it should be `-1`.\n5.  **`isGuestPresent`**: A boolean indicating if *any* user has the `username` 'guest'.\n",
          "difficulty": "medium",
          "startingCode": "function processUsers(users) {\n  // Sample user object format:\n  // [{ id: 1, username: 'user1', isActive: true }, ...]\n\n  return {\n    hasAdmins: false,           // Use `some()`\n    allActive: false,           // Use `every()`\n    firstInactiveUser: null,    // Use `find()`\n    indexOfSpecificUser: -1,    // Use `findIndex()` or `indexOf()` with helper\n    isGuestPresent: false       // Use `includes()` or `some()`\n  };\n}",
          "solutionCode": "function processUsers(users) {\n  if (!Array.isArray(users)) {\n    throw new Error('Input must be an array of user objects.');\n  }\n\n  const hasAdmins = users.some(user => user.username === 'admin');\n\n  const allActive = users.every(user => user.isActive);\n\n  const firstInactiveUser = users.find(user => !user.isActive) || null;\n\n  // For indexOfSpecificUser, we need to find an object matching two criteria.\n  // findIndex is suitable here.\n  const indexOfSpecificUser = users.findIndex(user => user.username === 'guest' && user.id === 99);\n\n  // isGuestPresent can be done with some() as well, for consistency with hasAdmins\n  const isGuestPresent = users.some(user => user.username === 'guest');\n\n  return {\n    hasAdmins,\n    allActive,\n    firstInactiveUser,\n    indexOfSpecificUser,\n    isGuestPresent\n  };\n}",
          "testCases": [
            "processUsers([]) should return { hasAdmins: false, allActive: true, firstInactiveUser: null, indexOfSpecificUser: -1, isGuestPresent: false } (Note: `every()` on empty array is `true`)",
            "processUsers([\n  { id: 1, username: 'user1', isActive: true },\n  { id: 2, username: 'admin', isActive: true },\n  { id: 3, username: 'user3', isActive: false }\n]) should return { hasAdmins: true, allActive: false, firstInactiveUser: { id: 3, username: 'user3', isActive: false }, indexOfSpecificUser: -1, isGuestPresent: false }",
            "processUsers([\n  { id: 10, username: 'guest', isActive: true },\n  { id: 99, username: 'guest', isActive: false },\n  { id: 3, username: 'user3', isActive: true }\n]) should return { hasAdmins: false, allActive: false, firstInactiveUser: { id: 99, username: 'guest', isActive: false }, indexOfSpecificUser: 1, isGuestPresent: true }",
            "processUsers([\n  { id: 1, username: 'user1', isActive: true },\n  { id: 2, username: 'user2', isActive: true }\n]) should return { hasAdmins: false, allActive: true, firstInactiveUser: null, indexOfSpecificUser: -1, isGuestPresent: false }"
          ],
          "hints": [
            "Remember `some()` returns true if *any* element passes, and `every()` returns true only if *all* elements pass.",
            "`find()` returns the element itself, while `findIndex()` returns its its index.",
            "Be careful with default values for `find()` (it returns `undefined` if no match, so you might need `|| null`)."
          ],
          "tags": [
            "some",
            "every",
            "find",
            "findIndex",
            "includes",
            "search methods",
            "validation"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_array_search_inspection_methods",
            "javascript_objects",
            "boolean logic"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "data lookup",
            "conditional logic",
            "short-circuiting"
          ]
        }
      ]
    }
  }
]