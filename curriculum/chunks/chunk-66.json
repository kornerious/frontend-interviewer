[
  {
    "id": "f1e636d4-59e1-42c6-8b6c-85e3bafe5480",
    "startLine": 13500,
    "endLine": 13599,
    "processedDate": "2025-06-17T13:29:16.284Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_class_method_binding",
          "title": "Class Method Binding in React",
          "content": "In React class components, the `this` keyword inside a method does not automatically refer to the component instance when the method is passed as an event handler (e.g., to an `onClick` prop). This is because JavaScript's `this` context depends on how the function is called, not where it's defined. When a class method is called as an event handler, `this` typically becomes `undefined` in strict mode (which React uses internally), leading to errors like `TypeError: Cannot read property 'setState' of undefined`.\n\nTo ensure `this` correctly refers to the component instance within class methods, binding is necessary. There are several common approaches:\n\n## Binding Approaches\n\n1.  **Binding in the Constructor:** This is a traditional and widely accepted method. Binding once in the constructor ensures that the method's `this` context is permanently bound to the component instance for all future calls. It's performant as the binding only happens once when the component is created.\n2.  **Using Arrow Functions as Class Properties (Class Fields Syntax):** This modern syntax leverages ES6 arrow functions, which lexically bind `this`. This means the `this` inside an arrow function automatically refers to the `this` of the enclosing context (the class instance). This approach is often preferred for its cleaner syntax and automatic binding, eliminating the need for explicit constructor binding. It requires transpilation (e.g., with Babel).\n3.  **Arrow Function in the `render` Method (Inline Binding):** This approach involves defining an arrow function directly within the `render` method and calling the class method inside it. While seemingly convenient, this method creates a *new function* on every render. If the component re-renders frequently, this can lead to performance issues as React's reconciliation process might see a new function prop each time, potentially causing re-renders of child components that receive this function as a prop, even if their state hasn't fundamentally changed. This method is generally discouraged for performance-critical scenarios or when passing the function down to child components as props, but can be acceptable for very simple, isolated cases.\n\n## Why Binding is Important\n\n*   **Correct `this` context:** Ensures `this` inside your event handlers correctly points to the component instance, allowing access to `this.state`, `this.props`, and `this.setState()`.\n*   **Preventing Errors:** Avoids `TypeError` due to `this` being `undefined`.\n*   **Maintaining Component State:** Allows methods to interact with and update the component's internal state reliably.",
          "examples": [
            {
              "id": "example_class_method_binding_1",
              "title": "Option 1: Bind in Constructor",
              "code": "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    // Bind 'this' to handleClick once in the constructor\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        Clicked {this.state.count} times\n      </button>\n    );\n  }\n}",
              "explanation": "In this example, `this.handleClick` is explicitly bound to the component instance (`this`) inside the constructor. This ensures that whenever `handleClick` is invoked as an event listener, its `this` context will correctly refer to `MyComponent`'s instance. This is efficient as the binding happens only once.",
              "language": "javascript"
            },
            {
              "id": "example_class_method_binding_2",
              "title": "Option 2: Use Arrow Functions for Class Methods (Class Fields)",
              "code": "class MyComponent extends React.Component {\n  state = { count: 0 };\n\n  // Use an arrow function as a class property\n  handleClick = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        Clicked {this.state.count} times\n      </button>\n    );\n  }\n}",
              "explanation": "Here, `handleClick` is defined as a class property using an arrow function. Arrow functions automatically bind `this` to the lexical scope in which they are defined. In this case, `this` inside `handleClick` will always refer to the `MyComponent` instance, eliminating the need for explicit binding in the constructor. This is a popular and concise approach.",
              "language": "javascript"
            },
            {
              "id": "example_class_method_binding_3",
              "title": "Option 3: Arrow Function in Render (Inline Binding)",
              "code": "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  handleClick() {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      // A new function is created on every render\n      <button onClick={() => this.handleClick()}>\n        Clicked {this.state.count} times\n      </button>\n    );\n  }\n}",
              "explanation": "This approach defines a new arrow function `() => this.handleClick()` directly within the `render` method. While it works, a new function instance is created on *every* re-render of `MyComponent`. If this component re-renders frequently or passes this function down to optimized child components (e.g., PureComponent or `memo`), it can negatively impact performance due to unnecessary re-renders of children. It's generally less preferred than the first two options.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_class_method_binding_1",
            "question_class_method_binding_2",
            "question_class_method_binding_3",
            "question_class_method_binding_4",
            "question_class_method_binding_5"
          ],
          "relatedTasks": [
            "task_class_method_binding_1"
          ],
          "tags": [
            "React",
            "Class Components",
            "ES6",
            "Binding",
            "this context",
            "Performance"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_this_keyword",
            "javascript_arrow_functions",
            "react_class_components",
            "react_state"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_event_handling",
            "react_performance_optimization"
          ]
        },
        {
          "id": "theory_api_calls_lifecycle",
          "title": "Making API Calls in React Lifecycle",
          "content": "Making network requests (API calls) is a common operation in React applications to fetch data from a server. The timing of these calls is crucial to ensure data is available when needed without causing errors or performance issues.\n\n## Class Components: `componentDidMount()`\n\nThe recommended lifecycle method for making API calls in React class components is `componentDidMount()`. Here's why:\n\n*   **Runs Once After Initial Render:** `componentDidMount()` is invoked immediately after a component is mounted (inserted into the DOM) for the first time. This ensures that the component's DOM elements are available if needed for the API call or subsequent rendering based on the fetched data.\n*   **Safe to Use `setState()`:** At this point, the component is fully mounted, so calling `this.setState()` inside `componentDidMount()` will trigger a re-render with the fetched data without causing an infinite loop. Calling `setState` in `render` would cause an infinite loop, and in the `constructor` state should only be initialized, not updated based on async operations.\n*   **Recommended Practice:** React documentation explicitly recommends `componentDidMount()` for data fetching.\n\n## Functional Components: `useEffect()`\n\nFor functional components, the `useEffect` hook is the equivalent and preferred way to perform side effects, including data fetching. To mimic `componentDidMount` behavior (running only once after initial render), `useEffect` should be used with an empty dependency array (`[]`).\n\n*   **Empty Dependency Array:** When `useEffect` has an empty dependency array, it tells React to run the effect only once after the initial render and clean it up (if a cleanup function is returned) when the component unmounts.\n*   **Asynchronous Nature:** Inside `useEffect`, you should typically define and immediately call an `async` function (or use `.then()`/`.catch()`) to handle the asynchronous API call.\n\n## Why not other lifecycle methods?\n\n*   **`constructor`:** Only for initial state setup and binding. Side effects are not allowed.\n*   **`render()`:** Calling `setState` here leads to an infinite loop because `setState` triggers a re-render, which calls `render` again.\n*   **`componentDidUpdate()`:** While `componentDidUpdate` can be used for data fetching, it runs on *every* update. If used for initial fetching, it would need careful conditional checks to prevent re-fetching on every state/prop change, which is more complex than `componentDidMount`.\n*   **`componentWillMount()` (Deprecated):** This method was deprecated due to potential issues with asynchronous calls and inconsistent behavior when server-side rendering is involved. It's best avoided.",
          "examples": [
            {
              "id": "example_api_call_class",
              "title": "API Call in Class Component (`componentDidMount`)",
              "code": "import React from 'react';\n\nclass DataFetcher extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null, loading: true, error: null };\n  }\n\n  componentDidMount() {\n    // This method runs once after the component mounts\n    fetch('https://jsonplaceholder.typicode.com/todos/1')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error('Network response was not ok');\n        }\n        return response.json();\n      })\n      .then(data => {\n        this.setState({ data, loading: false });\n      })\n      .catch(error => {\n        this.setState({ error, loading: false });\n      });\n  }\n\n  render() {\n    const { data, loading, error } = this.state;\n\n    if (loading) return <div>Loading data...</div>;\n    if (error) return <div>Error: {error.message}</div>;\n\n    return (\n      <div>\n        <h2>Fetched Data:</h2>\n        <p>Title: {data.title}</p>\n        <p>Completed: {data.completed ? 'Yes' : 'No'}</p>\n      </div>\n    );\n  }\n}",
              "explanation": "This class component fetches data from a public API when it first mounts. The `fetch` call is placed inside `componentDidMount`, and `setState` is used to update the component's state with the fetched data or any errors. This ensures the component is ready before fetching, and the state updates safely trigger re-renders.",
              "language": "javascript"
            },
            {
              "id": "example_api_call_functional",
              "title": "API Call in Functional Component (`useEffect`)",
              "code": "import React, { useState, useEffect } from 'react';\n\nfunction DataFetcherHook() {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // Define an async function inside useEffect\n    const fetchData = async () => {\n      try {\n        const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');\n        if (!response.ok) {\n          throw new Error('Network response was not ok');\n        }\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData(); // Call the async function\n\n    // Empty dependency array ensures this effect runs only once after initial render\n  }, []); \n\n  if (loading) return <div>Loading data...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n\n  return (\n    <div>\n      <h2>Fetched Data:</h2>\n      <p>Title: {data.title}</p>\n      <p>Completed: {data.completed ? 'Yes' : 'No'}</p>\n    </div>\n  );\n}",
              "explanation": "This functional component uses the `useEffect` hook to fetch data. The `fetchData` async function is defined inside `useEffect` and immediately called. The empty dependency array `[]` ensures that this effect runs only once, similar to `componentDidMount` in class components. State is managed using `useState` hooks.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_api_calls_lifecycle_1",
            "question_api_calls_lifecycle_2",
            "question_api_calls_lifecycle_3",
            "question_api_calls_lifecycle_4"
          ],
          "relatedTasks": [
            "task_api_calls_lifecycle_1"
          ],
          "tags": [
            "React",
            "Lifecycle Methods",
            "Hooks",
            "API Calls",
            "Data Fetching",
            "componentDidMount",
            "useEffect"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "react_functional_components",
            "react_hooks",
            "javascript_promises",
            "javascript_async_await"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_state_management",
            "react_data_flow"
          ]
        },
        {
          "id": "theory_setState_in_render",
          "title": "Consequences of Calling `setState()` in the `render` Method",
          "content": "Calling `setState()` directly within the `render` method of a React component is a critical anti-pattern and will inevitably lead to an infinite loop, causing your application to crash or become unresponsive. This is a fundamental concept related to React's rendering lifecycle.\n\n## The Infinite Loop Mechanism\n\n1.  **`setState()` is called:** When `setState()` is invoked, it schedules an update to the component's state.\n2.  **State Update Triggers Re-render:** React detects the state change and initiates a re-render of the component.\n3.  **`render()` Method is Executed:** As part of the re-render cycle, the component's `render()` method is called again.\n4.  **`setState()` is Called Again:** Inside this re-executed `render()` method, `setState()` is encountered and called *again*.\n5.  **Cycle Repeats:** This immediately triggers another re-render, leading back to step 1, creating an unending cycle of updates and renders.\n\nThis continuous loop consumes excessive CPU and memory, quickly overwhelming the browser and leading to a stack overflow error or a frozen tab.\n\n## Why `render` Should Be Pure\n\nThe `render` method in React components is expected to be a **pure function**. A pure function:\n\n*   Given the same inputs (props and state), always returns the same output (JSX).\n*   Has no side effects. This means it should not modify component state, directly interact with the DOM (outside of returning JSX), perform network requests, or change external variables.\n\nModifying state inside `render` violates this purity principle by introducing a side effect that directly interferes with the rendering process itself.",
          "examples": [
            {
              "id": "example_setState_in_render_bad",
              "title": "BAD PRACTICE: Calling setState in render (Causes Infinite Loop)",
              "code": "import React from 'react';\n\nclass InfiniteLoopComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  render() {\n    // DO NOT DO THIS! This will cause an infinite loop.\n    // this.setState({ count: this.state.count + 1 }); \n\n    // If uncommented, this component will crash your browser.\n    // The logic inside render must be pure and not cause side effects.\n\n    console.log('Rendering...');\n    return (\n      <div>\n        <h1>Count: {this.state.count}</h1>\n        <p>This component would crash if setState was called directly in render.</p>\n      </div>\n    );\n  }\n}",
              "explanation": "This example shows the conceptual location where `setState` *should not* be called. If the commented line `this.setState({ count: this.state.count + 1 });` were uncommented, every time `render()` is called, it would immediately trigger another `setState()`, leading to an infinite loop and browser crash. The `render` method must be pure and declarative, only returning JSX based on current props and state, without altering them.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_setState_in_render_1",
            "question_setState_in_render_2",
            "question_setState_in_render_3"
          ],
          "relatedTasks": [
            "task_setState_in_render_1"
          ],
          "tags": [
            "React",
            "Lifecycle Methods",
            "State Management",
            "Performance",
            "Anti-patterns",
            "Infinite Loop"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "react_state",
            "react_lifecycle"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_debugging",
            "react_performance_optimization"
          ]
        },
        {
          "id": "theory_componentWillUnmount",
          "title": "Purpose of `componentWillUnmount()` in React",
          "content": "`componentWillUnmount()` is a lifecycle method in React class components that is invoked immediately before a component is unmounted and destroyed (removed from the DOM). It is the ideal place to perform any necessary cleanup associated with the component to prevent memory leaks and ensure your application remains stable.\n\n## Common Cleanup Operations\n\n*   **Removing Event Listeners:** If you added event listeners (e.g., `window.addEventListener`, `document.addEventListener`) in `componentDidMount`, you must remove them in `componentWillUnmount`. Failing to do so can lead to listeners still referencing the unmounted component, causing memory leaks and potential errors if the callback tries to interact with a non-existent component.\n*   **Cancelling Network Requests:** For ongoing `fetch` or `axios` requests, you should cancel them if the component unmounts before the request completes. This prevents `setState` calls on an unmounted component, which React warns about and can lead to bugs. Modern APIs like `AbortController` or library-specific cancellation tokens are useful here.\n*   **Cleaning Up Subscriptions:** If your component subscribes to external data sources (e.g., WebSockets, Redux store, custom observable patterns), `componentWillUnmount` is where you should unsubscribe to prevent memory leaks and ensure the component doesn't receive updates after it's gone.\n*   **Invalidating Timers:** Any `setTimeout` or `setInterval` timers started in `componentDidMount` or other methods should be cleared (`clearTimeout`, `clearInterval`) in `componentWillUnmount` to prevent them from firing after the component is removed.\n*   **Resetting Global State/DOM Changes:** If your component made global changes (e.g., manipulating `document.title`, adding/removing CSS classes to `<body>`), `componentWillUnmount` is the place to revert those changes.\n\n## Functional Components Equivalent: `useEffect` Cleanup\n\nIn functional components, the cleanup logic typically found in `componentWillUnmount` is handled by the return function of the `useEffect` hook. If `useEffect` returns a function, React will execute that function right before the component unmounts, or before the effect re-runs if its dependencies change.\n\nThis ensures that resources are properly released, and the application remains efficient and free of unintended side effects.",
          "examples": [
            {
              "id": "example_componentWillUnmount_class",
              "title": "Cleanup in Class Component (`componentWillUnmount`)",
              "code": "import React from 'react';\n\nclass TimerComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { seconds: 0 };\n    this.timerId = null;\n  }\n\n  componentDidMount() {\n    // Start a timer when the component mounts\n    this.timerId = setInterval(() => {\n      this.setState(prevState => ({ seconds: prevState.seconds + 1 }));\n    }, 1000);\n    console.log('Timer started');\n  }\n\n  componentWillUnmount() {\n    // Clear the timer when the component unmounts to prevent memory leaks\n    clearInterval(this.timerId);\n    console.log('Timer cleared');\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>Timer: {this.state.seconds} seconds</h2>\n        <p>Open console to see lifecycle logs.</p>\n      </div>\n    );\n  }\n}",
              "explanation": "This component starts a timer in `componentDidMount` to update its state every second. Crucially, in `componentWillUnmount`, it clears the `setInterval` using `clearInterval`. If this cleanup wasn't done, the timer would continue to run even after the `TimerComponent` is removed from the DOM, potentially attempting to `setState` on an unmounted component and leading to errors and memory leaks.",
              "language": "javascript"
            },
            {
              "id": "example_componentWillUnmount_functional",
              "title": "Cleanup in Functional Component (`useEffect` return)",
              "code": "import React, { useState, useEffect } from 'react';\n\nfunction TimerHookComponent() {\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    // Effect runs once on mount (empty dependency array)\n    const intervalId = setInterval(() => {\n      setSeconds(prevSeconds => prevSeconds + 1);\n    }, 1000);\n    console.log('Timer started');\n\n    // This return function is the cleanup phase, runs on unmount or re-render\n    return () => {\n      clearInterval(intervalId);\n      console.log('Timer cleared');\n    };\n  }, []); // Empty dependency array means effect runs once, cleanup runs once on unmount\n\n  return (\n    <div>\n      <h2>Timer: {seconds} seconds</h2>\n      <p>Open console to see lifecycle logs.</p>\n    </div>\n  );\n}",
              "explanation": "In functional components, the cleanup logic is part of `useEffect`. The function returned by `useEffect` is executed when the component unmounts or before the effect re-runs (if dependencies change). Here, `clearInterval` is called in the cleanup function, ensuring the timer is stopped when the component is removed from the DOM, preventing leaks.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_componentWillUnmount_1",
            "question_componentWillUnmount_2",
            "question_componentWillUnmount_3",
            "question_componentWillUnmount_4"
          ],
          "relatedTasks": [
            "task_componentWillUnmount_1"
          ],
          "tags": [
            "React",
            "Lifecycle Methods",
            "Hooks",
            "Cleanup",
            "Memory Leaks",
            "componentWillUnmount",
            "useEffect"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "react_functional_components",
            "react_hooks"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_performance_optimization",
            "react_robust_applications"
          ]
        },
        {
          "id": "theory_controlled_uncontrolled_components",
          "title": "Controlled vs. Uncontrolled Components in React Forms",
          "content": "When dealing with form elements (like `input`, `textarea`, `select`) in React, there are two primary approaches to managing their data and user input: controlled components and uncontrolled components. The choice depends on the level of control and complexity required.\n\n## Controlled Components\n\n*   **Definition:** A controlled component is a form input element whose value is controlled by React state. The state acts as the \"single source of truth\" for the input's value.\n*   **Mechanism:**\n    *   You pass the component's state variable as the `value` prop to the input element.\n    *   You attach an `onChange` event handler to the input. This handler updates the React state with the input's new value (typically from `event.target.value`).\n    *   React re-renders the input with the updated state, making the input's display value always reflect the state.\n*   **Advantages:**\n    *   **Predictable Data Flow:** Input values are always tied to state, making it easy to validate, modify, or format input as the user types.\n    *   **Instant Feedback:** Ideal for inputs that need real-time validation, character limits, or dynamic enabling/disabling of buttons.\n    *   **Centralized Control:** Simplifies form submission, as all input values are readily available in the component's state.\n*   **Disadvantages:**\n    *   **More Boilerplate:** Requires writing `value` and `onChange` for every controlled input.\n    *   **Performance for Many Inputs:** Can lead to minor performance overhead for very large forms with many frequently updated inputs, as each keypress triggers a state update and re-render.\n\n## Uncontrolled Components\n\n*   **Definition:** An uncontrolled component is a form input element that maintains its own internal state (like a traditional HTML input). React does not control its value directly.\n*   **Mechanism:**\n    *   You typically use a `ref` to access the DOM element directly.\n    *   When you need the input's value (e.g., on form submission), you read it directly from the DOM using the ref (e.g., `myRef.current.value`).\n*   **Advantages:**\n    *   **Less Boilerplate:** No need for `onChange` handlers or explicit state management for each input.\n    *   **Simpler for Simple Forms:** Good for forms where you only need the value once (e.g., on submit) and don't require real-time validation or manipulation.\n    *   **Potentially Better Performance:** No re-renders on every keystroke, as React isn't managing its value.\n*   **Disadvantages:**\n    *   **Less Control:** Difficult to implement real-time input validation, formatting, or dynamic UI changes based on input.\n    *   **Harder to Debug:** Debugging can be more challenging as the source of truth is the DOM, not React state.\n    *   **Mixed Paradigms:** Blends React's declarative nature with imperative DOM manipulation.\n\n## When to Choose Which\n\n*   **Controlled Components:** Recommended for most cases, especially when you need dynamic, interactive forms with validation, conditional logic, or when data needs to be pre-filled or manipulated programmatically.\n*   **Uncontrolled Components:** Consider for simple forms where you just need to get the final value on submission, or for integrating with non-React code that expects to manage its own DOM elements.",
          "examples": [
            {
              "id": "example_controlled_component",
              "title": "Controlled Component Example",
              "code": "import React, { useState } from 'react';\n\nfunction ControlledForm() {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    alert(`Name: ${name}, Email: ${email}`);\n    console.log({ name, email });\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Name:\n        <input\n          type=\"text\"\n          value={name} // Value is controlled by React state\n          onChange={(e) => setName(e.target.value)} // State updates on change\n        />\n      </label>\n      <br />\n      <label>\n        Email:\n        <input\n          type=\"email\"\n          value={email}\n          onChange={(e) => setEmail(e.target.value)}\n        />\n      </label>\n      <br />\n      <button type=\"submit\">Submit</button>\n      <p>Current Name: {name}</p>\n    </form>\n  );\n}",
              "explanation": "In this example, both the `name` and `email` input fields are controlled. Their `value` props are bound to state variables (`name`, `email`), and their `onChange` handlers update those state variables. This means React's state is the single source of truth for the input values, allowing for immediate display of current value and easy access for submission or validation.",
              "language": "javascript"
            },
            {
              "id": "example_uncontrolled_component",
              "title": "Uncontrolled Component Example",
              "code": "import React, { useRef } from 'react';\n\nfunction UncontrolledForm() {\n  const nameInputRef = useRef(null);\n  const emailInputRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    // Access input values directly via refs on submission\n    const name = nameInputRef.current.value;\n    const email = emailInputRef.current.value;\n    alert(`Name: ${name}, Email: ${email}`);\n    console.log({ name, email });\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Name:\n        <input\n          type=\"text\"\n          defaultValue=\"John Doe\" // Optional initial value\n          ref={nameInputRef} // Attach ref to access DOM element\n        />\n      </label>\n      <br />\n      <label>\n        Email:\n        <input\n          type=\"email\"\n          ref={emailInputRef}\n        />\n      </label>\n      <br />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}",
              "explanation": "Here, `name` and `email` inputs are uncontrolled. They manage their own internal state. We use `useRef` to create references that attach to the DOM input elements. When the form is submitted, we access `nameInputRef.current.value` and `emailInputRef.current.value` directly to retrieve the current input values. `defaultValue` is used for providing an initial value, unlike `value` in controlled components.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_controlled_uncontrolled_components_1",
            "question_controlled_uncontrolled_components_2",
            "question_controlled_uncontrolled_components_3",
            "question_controlled_uncontrolled_components_4"
          ],
          "relatedTasks": [
            "task_controlled_uncontrolled_components_1"
          ],
          "tags": [
            "React",
            "Forms",
            "State Management",
            "Refs",
            "Controlled Components",
            "Uncontrolled Components"
          ],
          "technology": "React",
          "prerequisites": [
            "react_state",
            "react_props",
            "react_refs"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_forms_handling",
            "react_user_input"
          ]
        },
        {
          "id": "theory_propTypes",
          "title": "Understanding PropTypes in React",
          "content": "PropTypes are a mechanism in React for type-checking the props passed to components. They serve as a form of runtime validation and documentation, helping developers catch bugs early in the development process by generating warnings if incorrect types of props are provided.\n\n## Purpose and Usefulness\n\n*   **Documentation:** PropTypes explicitly define the expected types, shapes, and requiredness of a component's props. This makes components easier to understand and use for other developers (or your future self).\n*   **Runtime Validation:** During development, if a component receives a prop that doesn't match its specified `PropTypes`, React will issue a warning in the console. This helps identify and fix prop-related errors quickly.\n*   **Debugging Aid:** Warnings about incorrect prop types can point directly to issues where data is being passed incorrectly or component assumptions are violated.\n*   **Development-Only:** PropTypes are automatically stripped out in production builds through tools like Webpack or Rollup (using `process.env.NODE_ENV === 'production'` checks), so they don't add overhead to your production application's performance.\n\n## How to Use PropTypes\n\nPropTypes are imported from the `prop-types` package. You define them as a static property `propTypes` on your component class or functional component.\n\n## Common PropType Validations\n\n*   `PropTypes.any`: Any data type.\n*   `PropTypes.array`: An array.\n*   `PropTypes.bool`: A boolean.\n*   `PropTypes.func`: A function.\n*   `PropTypes.number`: A number.\n*   `PropTypes.object`: An object.\n*   `PropTypes.string`: A string.\n*   `PropTypes.symbol`: A symbol.\n*   `PropTypes.node`: Anything that can be rendered (numbers, strings, elements, arrays, fragments).\n*   `PropTypes.element`: A React element.\n*   `PropTypes.instanceOf(MyClass)`: An instance of a specific class.\n*   `PropTypes.oneOf(['option1', 'option2'])`: Value must be one of a given list.\n*   `PropTypes.arrayOf(PropTypes.number)`: An array of numbers.\n*   `PropTypes.objectOf(PropTypes.number)`: An object with property values of a certain type.\n*   `PropTypes.shape({ color: PropTypes.string, fontSize: PropTypes.number })`: An object with a specific shape.\n*   `PropTypes.exact({ color: PropTypes.string, fontSize: PropTypes.number })`: An object with a specific shape and no additional properties.\n*   `propType.isRequired`: Appends to any of the above to make the prop mandatory.\n\n## Alternatives to PropTypes\n\nWhile PropTypes are useful, for more robust and compile-time type checking, many modern React projects opt for static type checkers:\n\n*   **TypeScript:** The most popular choice, providing static typing across your entire JavaScript codebase. It offers excellent tooling, autocompletion, and catches type errors before runtime.\n*   **Flow:** Facebook's own static type checker, similar to TypeScript. While less widely adopted than TypeScript, it provides similar benefits for type safety.",
          "examples": [
            {
              "id": "example_propTypes_basic",
              "title": "Basic PropTypes Usage",
              "code": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction Greeting(props) {\n  return (\n    <div>\n      <h1>Hello, {props.name}!</h1>\n      {props.age && <p>You are {props.age} years old.</p>}\n      <p>Is Admin: {props.isAdmin ? 'Yes' : 'No'}</p>\n      <button onClick={props.onGreet}>Greet Me</button>\n    </div>\n  );\n}\n\n// Define propTypes for the Greeting component\nGreeting.propTypes = {\n  name: PropTypes.string.isRequired, // 'name' must be a string and is required\n  age: PropTypes.number,             // 'age' is an optional number\n  isAdmin: PropTypes.bool.isRequired, // 'isAdmin' must be a boolean and is required\n  onGreet: PropTypes.func.isRequired // 'onGreet' must be a function and is required\n};\n\n// Example of usage (assuming rendered elsewhere):\n// <Greeting name=\"Alice\" age={30} isAdmin={true} onGreet={() => console.log('Hi!')} />\n// <Greeting name={123} isAdmin=\"false\" /> // This would cause console warnings\n",
              "explanation": "This example shows how to define `propTypes` for a functional component. `Greeting.propTypes` is an object where keys are prop names and values are `PropTypes` validators. `isRequired` makes a prop mandatory. If `Greeting` receives a non-string `name` or missing `isAdmin` (in development mode), a warning will appear in the browser console, guiding the developer to fix the prop types.",
              "language": "javascript"
            },
            {
              "id": "example_propTypes_complex",
              "title": "Complex PropTypes: Shape and ArrayOf",
              "code": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction UserProfile({ user, hobbies }) {\n  return (\n    <div>\n      <h2>User Profile</h2>\n      <p>Name: {user.firstName} {user.lastName}</p>\n      <p>Age: {user.age}</p>\n      <p>Email: {user.contact.email}</p>\n      <p>Phone: {user.contact.phone}</p>\n      <h3>Hobbies:</h3>\n      <ul>\n        {hobbies.map((hobby, index) => <li key={index}>{hobby}</li>)}\n      </ul>\n    </div>\n  );\n}\n\nUserProfile.propTypes = {\n  user: PropTypes.shape({\n    firstName: PropTypes.string.isRequired,\n    lastName: PropTypes.string.isRequired,\n    age: PropTypes.number.isRequired,\n    contact: PropTypes.shape({\n      email: PropTypes.string.isRequired,\n      phone: PropTypes.string\n    }).isRequired\n  }).isRequired,\n  hobbies: PropTypes.arrayOf(PropTypes.string).isRequired\n};\n\n// Example usage:\n// const userData = {\n//   firstName: 'Jane',\n//   lastName: 'Doe',\n//   age: 28,\n//   contact: { email: 'jane@example.com', phone: '123-456-7890' }\n// };\n// const userHobbies = ['reading', 'hiking', 'cooking'];\n// <UserProfile user={userData} hobbies={userHobbies} />\n",
              "explanation": "This example demonstrates more complex `PropTypes` usage, specifically `PropTypes.shape` for defining the structure of an object prop (`user`) and `PropTypes.arrayOf` for validating an array of specific types (`hobbies`). This allows for detailed validation of nested data structures, ensuring that complex objects or arrays passed as props conform to expected schemas.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_propTypes_1",
            "question_propTypes_2",
            "question_propTypes_3",
            "question_propTypes_4"
          ],
          "relatedTasks": [
            "task_propTypes_1"
          ],
          "tags": [
            "React",
            "Type Checking",
            "Props",
            "Validation",
            "Documentation",
            "TypeScript",
            "Flow"
          ],
          "technology": "React",
          "prerequisites": [
            "react_props",
            "javascript_objects_arrays"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_component_design",
            "react_team_collaboration"
          ]
        },
        {
          "id": "theory_react_routing",
          "title": "Implementing Routing in React Applications with React Router",
          "content": "Most single-page applications (SPAs) built with React require client-side routing to navigate between different views or \"pages\" without full page reloads. The most popular and widely adopted library for this purpose is React Router.\n\nReact Router provides a declarative way to define routes and map them to components. It keeps the UI in sync with the URL, allowing for bookmarkable URLs, browser back/forward button support, and dynamic routing.\n\n## Core Components of React Router DOM\n\n`react-router-dom` is the package for web applications and provides several key components:\n\n*   **`BrowserRouter`:** This is the recommended router for web applications. It uses the HTML5 history API (`pushState`, `replaceState`, and the `popstate` event) to keep your UI in sync with the URL. It should wrap your entire application where routing is needed.\n*   **`Route`:** The `Route` component is responsible for rendering UI when a specific path matches the current URL. It takes a `path` prop to define the URL pattern.\n    *   `exact` prop: When added to a `Route`, it ensures that the component is rendered only when the path *exactly* matches the current URL. Without `exact`, a `Route` will render if the path is a *prefix* of the URL.\n    *   `component` prop: Specifies the component to render when the path matches. (In modern React Router, `element` is preferred over `component`).\n    *   **Dynamic Routes:** Routes can include dynamic segments using a colon (`:`), like `/users/:id`. These segments become accessible as parameters in the matched component's `props.match.params` (or via `useParams` hook).\n*   **`Switch` (Legacy, now `Routes` in v6):** In `react-router-dom` v5 and earlier, `Switch` was used to render *only the first* `Route` that matches the current location. This was crucial for handling 404 (Not Found) pages or ensuring only one route component renders. In v6, `Routes` replaces `Switch` and behaves similarly by rendering the first matching `Route` or `Outlet`.\n*   **`Link` / `NavLink`:** These components are used for navigation. `Link` is a basic link, while `NavLink` adds styling capabilities to active links.\n*   **`useNavigate`, `useParams`, `useLocation` (Hooks):** For functional components, React Router v5+ (and especially v6) provides hooks to access routing functionalities and information, replacing `withRouter` HOC and `props.match`, `props.location`, `props.history`.\n\n## Basic Implementation Flow\n\n1.  Install `react-router-dom` (`npm install react-router-dom`).\n2.  Wrap your application's root component or the section that needs routing with `BrowserRouter`.\n3.  Define individual `Route` components within a `Switch` (or `Routes` in v6) component.\n4.  Use `Link` or `NavLink` components for declarative navigation.",
          "examples": [
            {
              "id": "example_react_routing_basic",
              "title": "Basic React Router v5 Implementation",
              "code": "import React from 'react';\nimport { BrowserRouter, Route, Switch, Link } from 'react-router-dom';\n\n// Dummy Components\nconst Home = () => <h2>Home Page</h2>;\nconst About = () => <h2>About Us</h2>;\nconst User = ({ match }) => <h2>User ID: {match.params.id}</h2>;\nconst NotFound = () => <h2>404 - Page Not Found</h2>;\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <nav>\n        <Link to=\"/\">Home</Link> |\n        <Link to=\"/about\">About</Link> |\n        <Link to=\"/users/123\">User 123</Link>\n      </nav>\n      <hr />\n      <Switch>\n        <Route exact path=\"/\" component={Home} />\n        <Route path=\"/about\" component={About} />\n        <Route path=\"/users/:id\" component={User} />\n        {/* This route acts as a 404 handler if no other route matches */}\n        <Route component={NotFound} />\n      </Switch>\n    </BrowserRouter>\n  );\n}",
              "explanation": "This example demonstrates a basic setup using `react-router-dom` v5. `BrowserRouter` wraps the entire application. `Switch` ensures only one `Route` matches and renders. `exact` is used for the home route to prevent it from matching `/about` or `/users`. A dynamic route `/users/:id` captures a user ID. The last `Route` without a `path` acts as a fallback for 404 pages. `Link` components are used for navigation.",
              "language": "javascript"
            },
            {
              "id": "example_react_routing_v6_concept",
              "title": "React Router v6 `Routes` and `element` (Conceptual)",
              "code": "import React from 'react';\nimport { BrowserRouter, Routes, Route, Link } from 'react-router-dom';\n\n// Dummy Components\nconst Home = () => <h2>Home Page (v6)</h2>;\nconst About = () => <h2>About Us (v6)</h2>;\nconst User = () => {\n  // In v6, use `useParams` hook for dynamic segments\n  const { id } = useParams();\n  return <h2>User ID: {id} (v6)</h2>;\n};\nconst NotFound = () => <h2>404 - Page Not Found (v6)</h2>;\n\nfunction AppV6() {\n  return (\n    <BrowserRouter>\n      <nav>\n        <Link to=\"/\">Home</Link> |\n        <Link to=\"/about\">About</Link> |\n        <Link to=\"/users/456\">User 456</Link>\n      </nav>\n      <hr />\n      {/* 'Routes' replaces 'Switch' in v6 */}\n      <Routes>\n        {/* 'element' prop replaces 'component' */}\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n        <Route path=\"/users/:id\" element={<User />} />\n        {/* No 'exact' prop needed for parent routes by default in v6 */}\n        {/* Wildcard path for 404 */}\n        <Route path=\"*\" element={<NotFound />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}",
              "explanation": "This is a conceptual example for React Router v6. `Routes` replaces `Switch`, and the `element` prop now takes JSX directly instead of a component reference. The `exact` prop is no longer explicitly needed for parent routes because v6's routing matching is more intelligent by default. Dynamic parameters are accessed via the `useParams` hook. A `path=\"*\"` route is used for 404 handling.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_react_routing_1",
            "question_react_routing_2",
            "question_react_routing_3",
            "question_react_routing_4"
          ],
          "relatedTasks": [
            "task_react_routing_1"
          ],
          "tags": [
            "React",
            "Routing",
            "React Router",
            "SPA",
            "Navigation",
            "UX"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "javascript_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "single_page_applications",
            "react_ecosystem"
          ]
        },
        {
          "id": "theory_react_portals",
          "title": "React Portals: Rendering Children Outside Parent Hierarchy",
          "content": "React Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component. Normally, a component's render method returns JSX that React then renders as a child of the current component's DOM node. However, sometimes it's necessary for a child to break out of its parent's DOM structure.\n\n## Why and When to Use Portals\n\nPortals are particularly useful for components that need to visually \"escape\" their parent's styling, `overflow: hidden` properties, or `z-index` stacking contexts. Common use cases include:\n\n*   **Modal Dialogs:** A modal needs to overlay the entire page, often requiring a high `z-index` and not being affected by parent `overflow` styles.\n*   **Tooltips and Popovers:** These often need to appear directly next to a trigger element but overlay other content, which can be tricky if the trigger is inside a constrained container.\n*   **Floating Menus/Context Menus:** Similar to tooltips, these need to appear above other content.\n*   **Widgets that Break Out of Containers:** Any component that needs to render its UI independently of its parent's clipping or positioning.\n\nWithout portals, achieving these effects often requires complex CSS (e.g., `position: fixed` with explicit `top`, `left`, `z-index`) or imperative DOM manipulation, which goes against React's declarative nature.\n\n## How Portals Work\n\nA portal is created using `ReactDOM.createPortal()`. It takes two arguments:\n\n1.  `child`: Any renderable React child (e.g., a React element, string, fragment).\n2.  `container`: A DOM element (a reference to an existing DOM node) where the `child` will be mounted.\n\nDespite being rendered into a different DOM node, the portal's content still behaves like a normal React child. It remains part of the *React component tree*, meaning:\n\n*   **Event Bubbling:** Events from inside the portal will bubble up to ancestor components in the *React component tree*, not necessarily the DOM tree. This is a powerful feature, as it means you can still use React's event system as usual.\n*   **Context API:** Context will still flow down from providers in the parent React tree to consumers within the portal.\n\nThis behavior makes portals a powerful tool for solving specific layout and layering problems while maintaining the benefits of React's component model.",
          "examples": [
            {
              "id": "example_react_portal_modal",
              "title": "Implementing a Modal using React Portal",
              "code": "import React, { useState, useEffect, useRef } from 'react';\nimport ReactDOM from 'react-dom';\n\n// Create a dedicated DOM node for modals outside the root app element in public/index.html\n// <div id=\"modal-root\"></div>\n\nconst Modal = ({ children, isOpen, onClose }) => {\n  const modalRootRef = useRef(null);\n\n  // Ensure the modal root element exists and cache it\n  useEffect(() => {\n    modalRootRef.current = document.getElementById('modal-root') || document.createElement('div');\n    if (!document.getElementById('modal-root')) {\n      modalRootRef.current.id = 'modal-root';\n      document.body.appendChild(modalRootRef.current);\n    }\n  }, []);\n\n  if (!isOpen || !modalRootRef.current) return null;\n\n  return ReactDOM.createPortal(\n    <div style={{\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0,\n      backgroundColor: 'rgba(0,0,0,0.5)',\n      display: 'flex',\n      justifyContent: 'center',\n      alignItems: 'center',\n      zIndex: 1000 // High z-index to overlay everything\n    }} onClick={onClose}>\n      <div style={{\n        backgroundColor: 'white',\n        padding: '20px',\n        borderRadius: '8px',\n        minWidth: '300px',\n        boxShadow: '0 4px 8px rgba(0,0,0,0.2)',\n        zIndex: 1001 // Higher z-index for modal content\n      }} onClick={e => e.stopPropagation()}>\n        {children}\n        <button onClick={onClose} style={{ marginTop: '20px' }}>Close Modal</button>\n      </div>\n    </div>,\n    modalRootRef.current // The DOM node where the modal content will be rendered\n  );\n};\n\nfunction AppWithModal() {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  return (\n    <div style={{ padding: '20px', height: '150vh', overflow: 'hidden', border: '1px solid gray' }}>\n      <h1>My Application Content</h1>\n      <p>This is some content that might be hidden by overflow rules.</p>\n      <button onClick={() => setIsModalOpen(true)}>Open Modal</button>\n\n      <Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}>\n        <h2>This is a Portal Modal</h2>\n        <p>This content is rendered outside the main app DOM hierarchy.</p>\n      </Modal>\n\n      <p>More content below the fold...</p>\n    </div>\n  );\n}",
              "explanation": "This example shows a `Modal` component implemented using `ReactDOM.createPortal`. The `Modal` component receives `children`, `isOpen`, and `onClose` props. Inside the `Modal`, `ReactDOM.createPortal` renders its children into a specific DOM node (`modal-root`), which is typically a `div` element placed directly under the `<body>` tag in `public/index.html`. This allows the modal to appear above all other content, unaffected by its parent's styling properties like `overflow: hidden`, while still participating in React's event bubbling and context systems.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_react_portals_1",
            "question_react_portals_2",
            "question_react_portals_3",
            "question_react_portals_4"
          ],
          "relatedTasks": [
            "task_react_portals_1"
          ],
          "tags": [
            "React",
            "DOM",
            "Rendering",
            "Modals",
            "Tooltips",
            "UX",
            "Advanced React"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "dom_manipulation"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "react_component_patterns",
            "complex_ui_development"
          ]
        },
        {
          "id": "theory_react_keys",
          "title": "The Importance of Keys in React Lists",
          "content": "When rendering lists of elements in React (e.g., using `map()` on an array), it's crucial to assign a special `key` prop to each list item. Keys are not passed as props to your component; rather, they are an internal mechanism used by React to efficiently identify and track elements within a list.\n\n## Why Keys are Important\n\nReact uses keys to optimize its reconciliation process (also known as the 'diffing' algorithm). When a list is updated (items are added, removed, reordered, or their content changes), React needs a way to determine precisely which specific items have changed. Without stable keys, React might re-render or re-mount components unnecessarily, or even apply incorrect state to components.\n\nSpecifically, keys help React:\n\n*   **Identify Items:** Keys provide a stable identity to each list item. When the list changes, React uses the keys to match up items from the old list with items in the new list.\n*   **Optimize Performance:** By identifying which specific items have been added, removed, or reordered, React can perform the minimal necessary DOM manipulations. This leads to better performance, especially for large or frequently changing lists.\n*   **Maintain Component State:** When an item's position changes in a list, a stable key ensures that React can move the *entire component instance* (including its internal state and DOM elements) rather than unmounting and re-mounting it. This prevents state loss and preserves the component's internal logic.\n*   **Prevent Bugs:** Without keys, or with unstable keys, React might reuse existing DOM elements for different data items, leading to strange UI behavior, incorrect state, or unexpected bugs, especially in forms or interactive lists.\n\n## Rules for Keys\n\n1.  **Unique Among Siblings:** Keys must be unique among the items in the *same list* (i.e., among sibling elements). They do not need to be globally unique across the entire application.\n2.  **Stable Across Renders:** The key for a particular item should remain the same across re-renders. This is the most critical rule. If keys change for the same logical item, React will treat it as a *new* component and destroy the old one, losing its state.\n\n## What to Use as Keys\n\n*   **Stable IDs from Data:** The best practice is to use a unique and stable ID that comes from your data source (e.g., a database ID). This is ideal because it naturally fulfills both uniqueness among siblings and stability across renders.\n*   **Array Index (with Caution):** Using an item's index in the array (`map((item, index) => <li key={index}>...</li>)`) is generally discouraged, *unless* the list is static and will never change (i.e., items are never added, removed, or reordered). If the list can change, using the index as a key will lead to performance issues and potential bugs, as reordering items would cause React to mistakenly update wrong components or reset their state.\n*   **Generated IDs (with Caution):** Generating keys dynamically (e.g., using `Math.random()` or a UUID library) on each render is an anti-pattern. This creates *unstable* keys, effectively telling React that every item is new on every render, negating the performance benefits and causing state loss.",
          "examples": [
            {
              "id": "example_react_keys_good",
              "title": "Correct Key Usage with Stable IDs",
              "code": "import React from 'react';\n\nconst itemsWithIds = [\n  { id: 1, text: 'Item A' },\n  { id: 2, text: 'Item B' },\n  { id: 3, text: 'Item C' }\n];\n\nfunction ListItem({ item }) {\n  return <li>{item.text}</li>;\n}\n\nfunction GoodListExample() {\n  return (\n    <div>\n      <h2>Good List Example (Stable IDs)</h2>\n      <ul>\n        {itemsWithIds.map(item => (\n          <ListItem key={item.id} item={item} /> // Using a stable, unique ID as key\n        ))}\n      </ul>\n    </div>\n  );\n}",
              "explanation": "This is the correct and recommended way to use keys. Each `item` object has a stable, unique `id`. This `id` is used as the `key` prop for the `ListItem` component. If `itemsWithIds` array were to change (e.g., `Item B` is removed, or a new item is inserted), React would efficiently identify exactly which DOM elements need to be updated, removed, or reordered, preserving the state of unchanged components.",
              "language": "javascript"
            },
            {
              "id": "example_react_keys_bad_index",
              "title": "Bad Key Usage with Array Index (When List Changes)",
              "code": "import React, { useState } from 'react';\n\nfunction BadListExample() {\n  const [items, setItems] = useState([\n    'Apple', 'Banana', 'Cherry'\n  ]);\n\n  const removeItem = (indexToRemove) => {\n    setItems(items.filter((_, index) => index !== indexToRemove));\n  };\n\n  const addItem = () => {\n    setItems([...items, `New Fruit ${items.length + 1}`]);\n  };\n\n  return (\n    <div>\n      <h2>Bad List Example (Using Index as Key with Changing List)</h2>\n      <button onClick={addItem}>Add Item</button>\n      <ul>\n        {items.map((item, index) => (\n          <li key={index}> {/* DANGER: Using index as key in a mutable list */}\n            {item}\n            <button onClick={() => removeItem(index)}>Remove</button>\n          </li>\n        ))}\n      </ul>\n      <p>Try adding an item, then removing an item from the middle. You might see unexpected behavior or input focus issues if these were inputs.</p>\n    </div>\n  );\n}",
              "explanation": "This example illustrates why using the array index as a key is problematic for lists that change (additions, removals, reordering). When an item is removed from the middle, the indices of subsequent items shift. React, using these unstable indices as keys, might erroneously re-use an existing DOM element (and its internal state) for a different data item, leading to visual glitches or incorrect behavior, particularly with input fields or stateful child components.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_react_keys_1",
            "question_react_keys_2",
            "question_react_keys_3",
            "question_react_keys_4"
          ],
          "relatedTasks": [
            "task_react_keys_1"
          ],
          "tags": [
            "React",
            "Lists",
            "Performance",
            "Reconciliation",
            "Keys",
            "Optimization",
            "Debugging"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "javascript_arrays_map"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_performance_optimization",
            "react_component_rendering"
          ]
        },
        {
          "id": "theory_redux_problem_solved",
          "title": "The Problem Redux Solves: Predictable State Management",
          "content": "In complex frontend applications, managing application state can become challenging. As applications grow, components need to share data, communicate with each other, and respond to various events (user input, API responses). This often leads to issues like:\n\n*   **Prop Drilling:** Passing data down through many layers of nested components, even if intermediate components don't directly use the data. This makes code harder to read, maintain, and refactor.\n*   **Inconsistent State:** Multiple sources of truth for the same piece of data, leading to synchronization issues and bugs.\n*   **Difficult Debugging:** Understanding how data flows and changes across a large application can be very complex, making it hard to track down the cause of bugs.\n*   **Side Effects and Unpredictability:** State changes can be triggered from many places, making the application's behavior hard to predict and test.\n\nRedux is a predictable state container for JavaScript apps that addresses these problems by centralizing application state and enforcing strict rules for updating it. It is built around three core principles:\n\n1.  **Single Source of Truth:** The entire application's state is stored in a single, plain JavaScript object within a single store. This eliminates inconsistencies and makes it easy to inspect the current state.\n2.  **State is Read-Only:** The only way to change the state is by emitting an action, an object describing what happened. This ensures that views or network callbacks never write directly to the state, making changes explicit and traceable.\n3.  **Changes are Made with Pure Functions (Reducers):** To specify how the state tree is transformed by actions, you write pure reducers. Reducers are functions that take the current state and an action as arguments, and return a *new* state. They must not have side effects.\n\n## How Redux Solves the Problem\n\nBy adhering to these principles, Redux provides:\n\n*   **Centralized State:** A single global store holds all application state, eliminating prop drilling for shared data.\n*   **Predictability:** State changes are explicit (via actions) and handled by pure functions (reducers), making the application's behavior predictable and easier to reason about.\n*   **Debuggability:** The strict data flow and immutability of state make it straightforward to track state changes over time. Tools like Redux DevTools allow time-travel debugging, replaying actions, and inspecting state at any point.\n*   **Maintainability:** A clear pattern for state updates simplifies understanding how the application works and facilitates team collaboration.\n*   **Easier Testing:** Pure reducers and actions are inherently easy to test in isolation.\n\nWhile Redux introduces some boilerplate, its benefits in managing complex, shared state often outweigh the overhead for larger applications. For simpler applications or localized state, React's Context API or `useState`/`useReducer` hooks might be sufficient.",
          "examples": [
            {
              "id": "example_redux_problem_prop_drilling",
              "title": "Problem Example: Prop Drilling",
              "code": "import React from 'react';\n\n// Grandparent component has data that Grandchild needs\nfunction Grandparent() {\n  const userData = { name: 'Alice', role: 'Admin' };\n  return <Parent user={userData} />;\n}\n\n// Parent component passes data through to Grandchild, even though Parent doesn't use it\nfunction Parent({ user }) {\n  return <Child user={user} />;\n}\n\n// Child component passes data through to Grandchild, even though Child doesn't use it\nfunction Child({ user }) {\n  return <Grandchild user={user} />;\n}\n\n// Grandchild component finally uses the data\nfunction Grandchild({ user }) {\n  return (\n    <div>\n      <h3>Grandchild Component</h3>\n      <p>User Name: {user.name}</p>\n      <p>User Role: {user.role}</p>\n    </div>\n  );\n}\n\nfunction AppPropDrilling() {\n  return (\n    <div>\n      <h1>Prop Drilling Example</h1>\n      <Grandparent />\n    </div>\n  );\n}",
              "explanation": "This example demonstrates 'prop drilling'. The `userData` defined in `Grandparent` is needed by `Grandchild`. To get it there, it must be passed through `Parent` and `Child` components, even though neither of them uses the `user` prop directly. In larger applications with many nested components and more props, this can become cumbersome and make refactoring difficult. Redux (or React Context) aims to solve this by providing a global store that `Grandchild` can directly connect to.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_redux_problem_solved_1",
            "question_redux_problem_solved_2",
            "question_redux_problem_solved_3",
            "question_redux_problem_solved_4"
          ],
          "relatedTasks": [
            "task_redux_problem_solved_1"
          ],
          "tags": [
            "Redux",
            "State Management",
            "Prop Drilling",
            "Architecture",
            "Predictability",
            "Debugging"
          ],
          "technology": "Redux",
          "prerequisites": [
            "react_state",
            "react_props"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "large_scale_applications",
            "complex_state_management"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_class_method_binding_1",
          "topic": "Class Method Binding",
          "level": "medium",
          "type": "open",
          "question": "Why is it necessary to bind methods in React class components when they are used as event handlers?",
          "answer": "Binding is necessary because of how the `this` keyword works in JavaScript. When a class method is passed as an event handler (e.g., `onClick={this.handleClick}`), the context (`this`) in which the method is executed changes. By default, in strict mode (which React uses), `this` inside the event handler function will be `undefined`. Binding ensures that `this` inside the method always refers to the component instance, allowing you to access `this.state`, `this.props`, and `this.setState()` correctly.",
          "analysisPoints": [
            "Understanding of JavaScript `this` context.",
            "Knowledge of strict mode behavior.",
            "Ability to explain the problem (loss of `this` context).",
            "Ability to explain the solution's purpose (maintaining component instance reference)."
          ],
          "keyConcepts": [
            "this keyword",
            "function context",
            "strict mode",
            "event handlers",
            "class components"
          ],
          "evaluationCriteria": [
            "Clarity of explanation regarding `this` context.",
            "Correct identification of the problem caused by lack of binding.",
            "Completeness of the explanation."
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "JavaScript",
            "this",
            "Binding"
          ],
          "prerequisites": [
            "javascript_this_keyword"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_method_binding_2",
          "topic": "Class Method Binding",
          "level": "easy",
          "type": "flashcard",
          "question": "What happens if you don't bind `this` for a class method used as an event handler?",
          "answer": "`this` will be `undefined` inside the method, leading to errors like 'Cannot read property 'setState' of undefined'.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "this keyword",
            "event handlers",
            "undefined context"
          ],
          "evaluationCriteria": [
            "Quick recall of consequence"
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "this",
            "Binding"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_class_method_binding_3",
          "topic": "Class Method Binding",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following methods for binding a class method `handleClick` is generally considered the *most performant* and *least problematic* for a typical React application?",
          "answer": "Using an arrow function as a class property.",
          "options": [
            "Binding in the constructor (`this.handleClick = this.handleClick.bind(this);`)",
            "Using an arrow function as a class property (`handleClick = () => { ... }`)",
            "Binding inline in the render method (`<button onClick={() => this.handleClick()}>Click</button>`)",
            "Not binding at all, as modern React handles it automatically."
          ],
          "analysisPoints": [
            "Evaluates understanding of performance implications of different binding methods.",
            "Tests knowledge of modern JavaScript/React best practices.",
            "Distinguishes between correct and incorrect assumptions about React's behavior."
          ],
          "keyConcepts": [
            "Binding methods",
            "Class properties",
            "Arrow functions",
            "Performance optimization",
            "Render method behavior"
          ],
          "evaluationCriteria": [
            "Correct identification of the most efficient binding strategy.",
            "Understanding of why other options are less ideal (e.g., re-creation of functions)."
          ],
          "example": "Both 'Binding in the constructor' and 'Using an arrow function as a class property' are performant because they bind the method only once. However, using an arrow function as a class property (`handleClick = () => { ... }`) is often preferred due to its conciseness and automatic lexical `this` binding, which reduces boilerplate. Binding inline in the render method (`onClick={() => this.handleClick()}`) creates a new function on every render, which can lead to performance issues and unnecessary re-renders of child components.",
          "tags": [
            "React",
            "Class Components",
            "Performance",
            "Binding",
            "ES6"
          ],
          "prerequisites": [
            "javascript_arrow_functions",
            "react_class_components"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_method_binding_4",
          "topic": "Class Method Binding",
          "level": "hard",
          "type": "code",
          "question": "The following React class component aims to increment a counter, but it has a `this` binding issue. Identify the problem and fix it using two different correct binding approaches. Provide the corrected code for both solutions.",
          "answer": "// Solution 1: Bind in constructor\nclass CounterComponentA extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    this.incrementCount = this.incrementCount.bind(this); // Fix: Binding in constructor\n  }\n\n  incrementCount() {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <button onClick={this.incrementCount}>\n        Count: {this.state.count}\n      </button>\n    );\n  }\n}\n\n// Solution 2: Use arrow function as class property\nclass CounterComponentB extends React.Component {\n  state = { count: 0 };\n\n  incrementCount = () => { // Fix: Arrow function as class property\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <button onClick={this.incrementCount}>\n        Count: {this.state.count}\n      </button>\n    );\n  }\n}",
          "options": [],
          "analysisPoints": [
            "Ability to recognize `this` binding errors in class components.",
            "Knowledge of multiple correct binding strategies.",
            "Correct application of `this.setState`."
          ],
          "keyConcepts": [
            "this keyword",
            "class components",
            "binding",
            "constructor",
            "arrow functions",
            "setState"
          ],
          "evaluationCriteria": [
            "Code correctness for both solutions.",
            "Demonstration of understanding of underlying `this` context issues.",
            "Readability and adherence to React conventions."
          ],
          "example": "The original problem stems from `this.incrementCount` losing its `this` context when passed as an `onClick` handler. The two solutions address this by either explicitly binding `incrementCount` to the component instance in the constructor, or by defining `incrementCount` as an arrow function class property, which automatically binds `this` lexically.",
          "tags": [
            "React",
            "Class Components",
            "Code Challenge",
            "this",
            "Binding"
          ],
          "prerequisites": [
            "react_class_components",
            "javascript_this_keyword"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_class_method_binding_5",
          "topic": "Class Method Binding",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using an arrow function as a class property for event handlers?",
          "answer": "It automatically binds `this` to the component instance, eliminating the need for explicit binding in the constructor and making the code more concise.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "arrow functions",
            "lexical this",
            "conciseness"
          ],
          "evaluationCriteria": [
            "Quick recall of benefits"
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Arrow Functions",
            "Binding"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_api_calls_lifecycle_1",
          "topic": "API Calls in React Lifecycle",
          "level": "medium",
          "type": "open",
          "question": "In which lifecycle method should you make API calls in a React class component, and why? What is the equivalent hook for functional components?",
          "answer": "In React class components, API calls should be made in `componentDidMount()`. The reasons are:\n1.  **Runs Once:** `componentDidMount()` is invoked immediately after the component is mounted (inserted into the DOM) for the first time. This prevents unnecessary repeated calls.\n2.  **Safe `setState`:** The component is already mounted, so it's safe to call `this.setState()` with the fetched data without causing an infinite re-render loop.\n3.  **DOM Available:** If the API call depends on DOM elements (though rare), they are guaranteed to be available.\n\nFor functional components, the equivalent hook is `useEffect()` with an empty dependency array (`[]`). This tells React to run the effect only once after the initial render, mimicking `componentDidMount` behavior.",
          "analysisPoints": [
            "Correctly identifies `componentDidMount` for class components.",
            "Provides valid reasons for `componentDidMount` (once, safe `setState`).",
            "Correctly identifies `useEffect` with empty array for functional components.",
            "Demonstrates understanding of both paradigms."
          ],
          "keyConcepts": [
            "componentDidMount",
            "useEffect hook",
            "API calls",
            "lifecycle methods",
            "side effects"
          ],
          "evaluationCriteria": [
            "Completeness of the answer for both class and functional components.",
            "Accuracy of explanations for 'why'."
          ],
          "example": null,
          "tags": [
            "React",
            "Lifecycle Methods",
            "Hooks",
            "API Calls",
            "componentDidMount",
            "useEffect"
          ],
          "prerequisites": [
            "react_class_components",
            "react_functional_components"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_api_calls_lifecycle_2",
          "topic": "API Calls in React Lifecycle",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following functional component attempting to fetch data. Which line of code correctly ensures the API call runs only once after the initial render, similar to `componentDidMount`?",
          "answer": "`useEffect(() => { /* fetch logic */ }, []);`",
          "options": [
            "`useEffect(() => { /* fetch logic */ });`",
            "`useEffect(() => { /* fetch logic */ }, [data]);`",
            "`useEffect(() => { /* fetch logic */ }, []);`",
            "API calls should not be made directly in functional components."
          ],
          "analysisPoints": [
            "Tests knowledge of `useEffect` dependencies.",
            "Distinguishes between `useEffect` behaviors with different dependency arrays.",
            "Confirms understanding of how to mimic `componentDidMount` with hooks."
          ],
          "keyConcepts": [
            "useEffect",
            "dependency array",
            "componentDidMount",
            "initial render"
          ],
          "evaluationCriteria": [
            "Correct identification of the `useEffect` signature for one-time execution."
          ],
          "example": "The `useEffect` hook with an empty dependency array (`[]`) tells React to run the effect only once after the initial render and clean it up when the component unmounts. This is the direct equivalent of `componentDidMount` for fetching data. Without a dependency array, the effect runs after every render. With `[data]`, it runs whenever `data` changes.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "API Calls",
            "Functional Components"
          ],
          "prerequisites": [
            "react_hooks"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_api_calls_lifecycle_3",
          "topic": "API Calls in React Lifecycle",
          "level": "hard",
          "type": "open",
          "question": "Explain why making an API call directly in the `constructor` or `render` method of a React component is problematic. What are the potential issues?",
          "answer": "Making API calls in the `constructor` or `render` method is problematic for different reasons:\n\n*   **`constructor`:** The constructor is primarily for initializing state and binding methods. It should be a pure function that doesn't cause side effects like network requests. If an API call fails or takes time in the constructor, the component might not render correctly, or you won't have a mounted component instance to `setState` on when the data arrives. It also runs before the component is mounted, so you cannot interact with the DOM or safely update state based on async results.\n\n*   **`render`:** The `render` method is responsible for returning the JSX tree. It must be a pure function that takes props and state and returns UI, without causing side effects. If you call `setState()` (which is needed to store fetched data) inside `render`, it will trigger a re-render. Since `render` is called again during the re-render, `setState()` will be called again, creating an **infinite loop**. This loop will continuously update state and re-render, eventually crashing the browser due to stack overflow or excessive memory consumption.",
          "analysisPoints": [
            "Distinguishes between issues in `constructor` and `render`.",
            "Explains the purity principle of `render`.",
            "Clearly describes the infinite loop mechanism for `render`.",
            "Mentions lack of `setState` safety in `constructor`."
          ],
          "keyConcepts": [
            "constructor",
            "render method",
            "pure functions",
            "side effects",
            "setState",
            "infinite loop",
            "lifecycle methods"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of problems for both methods.",
            "Accuracy of technical terms and concepts."
          ],
          "example": null,
          "tags": [
            "React",
            "Lifecycle Methods",
            "API Calls",
            "Anti-patterns",
            "Infinite Loop",
            "Performance"
          ],
          "prerequisites": [
            "react_class_components",
            "react_state",
            "react_lifecycle"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_api_calls_lifecycle_4",
          "topic": "API Calls in React Lifecycle",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the `useEffect` dependency array equivalent to `componentDidMount`?",
          "answer": "An empty dependency array (`[]`).",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "useEffect",
            "dependency array",
            "componentDidMount"
          ],
          "evaluationCriteria": [
            "Quick recall of `useEffect` usage"
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useEffect"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_setState_in_render_1",
          "topic": "setState() in Render Method",
          "level": "medium",
          "type": "open",
          "question": "What exact sequence of events leads to an infinite loop if `setState()` is called directly inside the `render` method of a React component?",
          "answer": "The sequence of events is as follows:\n1.  **`setState()` Call:** The `render` method executes and calls `this.setState()`. (e.g., `this.setState({ count: this.state.count + 1 });`).\n2.  **State Update:** `this.setState()` updates the component's state.\n3.  **Re-render Triggered:** React detects the state change and automatically schedules and initiates a re-render of the component.\n4.  **`render()` Re-execution:** As part of the re-render, the component's `render()` method is called again.\n5.  **Loop Continues:** The `render()` method, once again, calls `this.setState()`, which triggers another state update and another re-render, perpetuating the infinite loop. This quickly consumes system resources and crashes the browser.",
          "analysisPoints": [
            "Accurate description of `setState`'s effect (triggers re-render).",
            "Clear explanation of the recursive nature of the loop.",
            "Understanding of React's reconciliation process."
          ],
          "keyConcepts": [
            "render method",
            "setState",
            "re-render",
            "infinite loop",
            "side effects"
          ],
          "evaluationCriteria": [
            "Step-by-step clarity of the loop mechanism.",
            "Understanding of the core principle: `render` should be pure."
          ],
          "example": null,
          "tags": [
            "React",
            "Lifecycle Methods",
            "State Management",
            "Anti-patterns",
            "Infinite Loop"
          ],
          "prerequisites": [
            "react_state",
            "react_lifecycle"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_setState_in_render_2",
          "topic": "setState() in Render Method",
          "level": "easy",
          "type": "flashcard",
          "question": "Why should the `render` method be a pure function?",
          "answer": "Because it should only calculate and return JSX based on current props and state, without causing side effects like modifying state or interacting with the DOM directly. This ensures predictability and prevents issues like infinite loops.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "render method",
            "pure function",
            "side effects"
          ],
          "evaluationCriteria": [
            "Quick recall of `render`'s purity"
          ],
          "example": null,
          "tags": [
            "React",
            "Lifecycle Methods",
            "Purity"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_setState_in_render_3",
          "topic": "setState() in Render Method",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following scenarios is MOST likely to lead to an infinite loop in a React application?",
          "answer": "Calling `this.setState()` unconditionally inside the `render()` method.",
          "options": [
            "Making an API call inside `componentDidMount()`.",
            "Calling `this.setState()` unconditionally inside the `render()` method.",
            "Using a `ref` to directly access a DOM element.",
            "Updating state using `useState` in a functional component."
          ],
          "analysisPoints": [
            "Tests understanding of common React pitfalls.",
            "Distinguishes safe lifecycle operations from problematic ones.",
            "Reinforces the concept of `render` purity."
          ],
          "keyConcepts": [
            "setState",
            "render method",
            "infinite loop",
            "lifecycle methods",
            "pure functions"
          ],
          "evaluationCriteria": [
            "Correct identification of the infinite loop cause.",
            "Ability to differentiate between correct and incorrect React practices."
          ],
          "example": "Calling `this.setState()` inside `render()` is an anti-pattern because `setState()` triggers a re-render, which in turn calls `render()` again, leading to an unending cycle. The other options describe valid and common React patterns.",
          "tags": [
            "React",
            "Anti-patterns",
            "Infinite Loop",
            "State Management"
          ],
          "prerequisites": [
            "react_lifecycle",
            "react_state"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_componentWillUnmount_1",
          "topic": "componentWillUnmount()",
          "level": "medium",
          "type": "open",
          "question": "What is the primary purpose of the `componentWillUnmount()` lifecycle method in a React class component? Provide at least three common cleanup tasks you would perform within it.",
          "answer": "The primary purpose of `componentWillUnmount()` is to perform cleanup before a component is removed from the DOM. This is crucial for preventing memory leaks and ensuring the application runs efficiently.\n\nThree common cleanup tasks are:\n1.  **Removing event listeners:** If you added `window.addEventListener` or `document.addEventListener` in `componentDidMount`, they should be removed here.\n2.  **Cancelling network requests:** If a component unmounts while an asynchronous network request is still pending, you should cancel it to prevent `setState` calls on an unmounted component.\n3.  **Clearing timers:** Any `setTimeout` or `setInterval` timers initiated by the component should be cleared using `clearTimeout` or `clearInterval`.",
          "analysisPoints": [
            "Correctly states the primary purpose (cleanup, memory leaks).",
            "Lists relevant and common cleanup tasks.",
            "Demonstrates understanding of why cleanup is needed for each task."
          ],
          "keyConcepts": [
            "componentWillUnmount",
            "lifecycle methods",
            "cleanup",
            "memory leaks",
            "event listeners",
            "timers",
            "network requests"
          ],
          "evaluationCriteria": [
            "Completeness and accuracy of purpose statement.",
            "Quality and relevance of cleanup examples."
          ],
          "example": null,
          "tags": [
            "React",
            "Lifecycle Methods",
            "Cleanup",
            "Memory Leaks",
            "Performance"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_componentWillUnmount_2",
          "topic": "componentWillUnmount()",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the functional component equivalent for `componentWillUnmount` cleanup logic?",
          "answer": "The return function of the `useEffect` hook.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "useEffect hook",
            "cleanup function",
            "componentWillUnmount"
          ],
          "evaluationCriteria": [
            "Quick recall of `useEffect` cleanup"
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Cleanup"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_componentWillUnmount_3",
          "topic": "componentWillUnmount()",
          "level": "medium",
          "type": "mcq",
          "question": "A React component starts a `setInterval` timer in its `componentDidMount` method. What is the most appropriate action to take in `componentWillUnmount` to prevent potential issues?",
          "answer": "Call `clearInterval()` to stop the timer.",
          "options": [
            "Call `clearTimeout()` to stop the timer.",
            "Set the component's state to null to release memory.",
            "Call `clearInterval()` to stop the timer.",
            "Nothing, React automatically cleans up timers."
          ],
          "analysisPoints": [
            "Tests understanding of timer management in React lifecycle.",
            "Identifies the correct function for clearing intervals.",
            "Debunks common misconceptions about automatic cleanup."
          ],
          "keyConcepts": [
            "componentWillUnmount",
            "setInterval",
            "clearInterval",
            "memory leaks",
            "cleanup"
          ],
          "evaluationCriteria": [
            "Correct selection of the cleanup method.",
            "Understanding of the necessity of manual cleanup for timers."
          ],
          "example": "If a `setInterval` is not cleared when a component unmounts, it will continue to run in the background, potentially trying to update the state of an unmounted component, leading to errors and memory leaks. `clearInterval()` is the correct function to stop an interval started with `setInterval()`.",
          "tags": [
            "React",
            "Lifecycle Methods",
            "Cleanup",
            "Timers",
            "Memory Leaks"
          ],
          "prerequisites": [
            "react_class_components",
            "javascript_timers"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_componentWillUnmount_4",
          "topic": "componentWillUnmount()",
          "level": "hard",
          "type": "code",
          "question": "You have a `ChatClient` component that subscribes to a WebSocket feed in `componentDidMount` and displays incoming messages. If this component is unmounted, it's crucial to unsubscribe to prevent memory leaks and unnecessary network activity. Implement the `ChatClient` class component, ensuring proper subscription and unsubscription.",
          "answer": "```javascript\nimport React from 'react';\n\n// Imagine a simplified WebSocket client\nconst MockWebSocket = {\n  _listeners: [],\n  connect: () => console.log('WebSocket connected'),\n  disconnect: () => console.log('WebSocket disconnected'),\n  subscribe: (callback) => {\n    MockWebSocket._listeners.push(callback);\n    console.log('Subscribed to WebSocket');\n    // Simulate incoming messages\n    MockWebSocket.interval = setInterval(() => {\n      const message = `Message from server: ${Date.now()}`;\n      MockWebSocket._listeners.forEach(cb => cb(message));\n    }, 2000);\n  },\n  unsubscribe: (callback) => {\n    MockWebSocket._listeners = MockWebSocket._listeners.filter(cb => cb !== callback);\n    console.log('Unsubscribed from WebSocket');\n    if (MockWebSocket._listeners.length === 0) {\n      clearInterval(MockWebSocket.interval);\n      console.log('No more subscribers, stopping message simulation.');\n    }\n  }\n};\n\nclass ChatClient extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { messages: [] };\n    this.handleNewMessage = this.handleNewMessage.bind(this);\n  }\n\n  handleNewMessage(message) {\n    this.setState(prevState => ({\n      messages: [...prevState.messages, message]\n    }));\n  }\n\n  componentDidMount() {\n    console.log('ChatClient Mounted');\n    // Subscribe to the WebSocket feed\n    MockWebSocket.connect();\n    MockWebSocket.subscribe(this.handleNewMessage);\n  }\n\n  componentWillUnmount() {\n    console.log('ChatClient Will Unmount');\n    // Unsubscribe from the WebSocket feed to prevent memory leaks\n    MockWebSocket.unsubscribe(this.handleNewMessage);\n    MockWebSocket.disconnect();\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Chat Messages</h3>\n        <div style={{ height: '150px', overflowY: 'scroll', border: '1px solid #ccc', padding: '10px' }}>\n          {this.state.messages.length === 0 ? (\n            <p>Waiting for messages...</p>\n          ) : (\n            <ul>\n              {this.state.messages.map((msg, index) => (\n                <li key={index}>{msg}</li>\n              ))}\n            </ul>\n          )}\n        </div>\n        <p>This component will log subscribe/unsubscribe actions to console.</p>\n      </div>\n    );\n  }\n}\n\n// To test, mount and unmount this component:\n// const App = () => {\n//   const [showChat, setShowChat] = React.useState(true);\n//   return (\n//     <div>\n//       <button onClick={() => setShowChat(!showChat)}>\n//         {showChat ? 'Hide Chat' : 'Show Chat'}\n//       </button>\n//       {showChat && <ChatClient />}\n//     </div>\n//   )\n// }\n// ReactDOM.render(<App />, document.getElementById('root'));\n```",
          "options": [],
          "analysisPoints": [
            "Correctly implements `componentDidMount` for subscription.",
            "Correctly implements `componentWillUnmount` for unsubscription.",
            "Demonstrates understanding of event/subscription management.",
            "Handles `this` context for the callback.",
            "Shows awareness of external resource management."
          ],
          "keyConcepts": [
            "componentDidMount",
            "componentWillUnmount",
            "subscriptions",
            "WebSockets",
            "cleanup",
            "memory leaks",
            "this binding"
          ],
          "evaluationCriteria": [
            "Code correctness for subscription/unsubscription logic.",
            "Proper use of lifecycle methods.",
            "Identification and mitigation of potential memory leaks."
          ],
          "example": "The `ChatClient` component subscribes to `MockWebSocket` in `componentDidMount` using `this.handleNewMessage` as the callback. Crucially, in `componentWillUnmount`, it calls `MockWebSocket.unsubscribe(this.handleNewMessage)` to remove the listener. This prevents the component from attempting to update its state or interact with `MockWebSocket` after it has been removed from the DOM, thus avoiding memory leaks and ensuring efficient resource usage.",
          "tags": [
            "React",
            "Class Components",
            "Code Challenge",
            "Lifecycle Methods",
            "Cleanup",
            "WebSockets"
          ],
          "prerequisites": [
            "react_class_components",
            "javascript_event_listeners"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_controlled_uncontrolled_components_1",
          "topic": "Controlled vs. Uncontrolled Components",
          "level": "medium",
          "type": "open",
          "question": "What is the fundamental difference between controlled and uncontrolled components in React forms? When would you choose one over the other?",
          "answer": "The fundamental difference lies in how their form data is managed:\n\n*   **Controlled Components:** Their values are controlled by React state. You pass the value via the `value` prop and update it via an `onChange` event handler that calls `setState()` (or `useState` setter). React is the 'single source of truth' for the input's value.\n*   **Uncontrolled Components:** They maintain their own internal state, similar to traditional HTML form elements. You typically use a `ref` to access their current value directly from the DOM when needed (e.g., on form submission).\n\n**When to choose:**\n*   Choose **Controlled Components** for most scenarios where you need immediate validation, transformation, conditional input enabling/disabling, or when you need to programmatically clear or pre-fill input fields. They offer more control and predictable behavior.\n*   Choose **Uncontrolled Components** for simpler forms where you only need the input value once (e.g., on form submission) and don't require real-time updates or complex validation. They might involve slightly less boilerplate for very simple use cases and can be marginally more performant for very high-frequency input if not carefully optimized, but generally offer less programmatic control.",
          "analysisPoints": [
            "Clear definition of both types based on state management.",
            "Correctly identifies `value`/`onChange` for controlled and `refs` for uncontrolled.",
            "Provides clear use cases for choosing one over the other.",
            "Discusses trade-offs (control vs. boilerplate/simplicity)."
          ],
          "keyConcepts": [
            "Controlled Components",
            "Uncontrolled Components",
            "React state",
            "Refs",
            "Form handling",
            "Data flow"
          ],
          "evaluationCriteria": [
            "Accuracy of definitions.",
            "Relevance and justification of use cases.",
            "Understanding of associated pros and cons."
          ],
          "example": null,
          "tags": [
            "React",
            "Forms",
            "State Management",
            "Refs"
          ],
          "prerequisites": [
            "react_state",
            "react_refs"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_controlled_uncontrolled_components_2",
          "topic": "Controlled vs. Uncontrolled Components",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you typically access the value of an uncontrolled input component?",
          "answer": "Using a `ref` attached to the input element.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "uncontrolled components",
            "refs"
          ],
          "evaluationCriteria": [
            "Quick recall of uncontrolled access method"
          ],
          "example": null,
          "tags": [
            "React",
            "Forms",
            "Refs"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_controlled_uncontrolled_components_3",
          "topic": "Controlled vs. Uncontrolled Components",
          "level": "medium",
          "type": "mcq",
          "question": "You need to implement a search input field that provides instant feedback to the user, showing validation errors as they type and filtering a list in real-time. Which type of form component is most suitable for this scenario in React?",
          "answer": "Controlled component",
          "options": [
            "Controlled component",
            "Uncontrolled component",
            "Both are equally suitable",
            "Neither, you should use a third-party form library"
          ],
          "analysisPoints": [
            "Tests ability to apply controlled/uncontrolled concepts to practical scenarios.",
            "Evaluates understanding of real-time interaction requirements."
          ],
          "keyConcepts": [
            "Controlled Components",
            "Uncontrolled Components",
            "Real-time validation",
            "Instant feedback",
            "User input"
          ],
          "evaluationCriteria": [
            "Correct choice based on functional requirements.",
            "Implicit understanding of the limitations of uncontrolled components for such features."
          ],
          "example": "For real-time validation, filtering, or any scenario requiring immediate programmatic control over the input's value, a controlled component is ideal. The `onChange` handler allows you to capture every keystroke, update state, and then perform any logic (validation, filtering) based on that updated state.",
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "UX",
            "Real-time"
          ],
          "prerequisites": [
            "react_state"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_controlled_uncontrolled_components_4",
          "topic": "Controlled vs. Uncontrolled Components",
          "level": "hard",
          "type": "code",
          "question": "Implement a simple form with two input fields: one for 'Username' (which should be controlled) and another for 'File Upload' (which should be uncontrolled, using a file input). The form should display the username in real-time as it's typed and log both username and selected file (if any) to the console on submission.",
          "answer": "```javascript\nimport React, { useState, useRef } from 'react';\n\nfunction FormExample() {\n  // Controlled component state for username\n  const [username, setUsername] = useState('');\n\n  // Uncontrolled component ref for file input\n  const fileInputRef = useRef(null);\n\n  const handleUsernameChange = (event) => {\n    setUsername(event.target.value);\n  };\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    \n    // Accessing controlled component value from state\n    console.log('Submitted Username:', username);\n\n    // Accessing uncontrolled component value from ref\n    if (fileInputRef.current && fileInputRef.current.files.length > 0) {\n      console.log('Submitted File:', fileInputRef.current.files[0].name);\n    } else {\n      console.log('No file selected.');\n    }\n\n    alert(`Username: ${username}\\nFile: ${fileInputRef.current?.files[0]?.name || 'None'}`);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <h2>Controlled & Uncontrolled Form</h2>\n      <div>\n        <label htmlFor=\"username\">Username (Controlled):</label>\n        <input\n          id=\"username\"\n          type=\"text\"\n          value={username}\n          onChange={handleUsernameChange}\n          placeholder=\"Type your username\"\n        />\n        <p>Current Username: {username}</p>\n      </div>\n      <br />\n      <div>\n        <label htmlFor=\"fileUpload\">Select File (Uncontrolled):</label>\n        <input\n          id=\"fileUpload\"\n          type=\"file\"\n          ref={fileInputRef} // Attach ref\n        />\n      </div>\n      <br />\n      <button type=\"submit\">Submit Form</button>\n    </form>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "Correctly implements a controlled input with `useState` and `onChange`.",
            "Correctly implements an uncontrolled file input using `useRef`.",
            "Successfully accesses values from both types of inputs on form submission.",
            "Demonstrates understanding of `input type='file'` and its `files` property."
          ],
          "keyConcepts": [
            "Controlled Components",
            "Uncontrolled Components",
            "useState hook",
            "useRef hook",
            "Form handling",
            "File input"
          ],
          "evaluationCriteria": [
            "Functional correctness for both input types.",
            "Clear distinction in implementation for controlled vs. uncontrolled.",
            "Proper handling of form submission.",
            "Code cleanliness and adherence to React patterns."
          ],
          "example": "This solution demonstrates how to combine controlled and uncontrolled inputs within a single form. The username input is `controlled` by React state, allowing its value to be displayed in real-time. The file input is `uncontrolled`, with its value accessed via a `useRef` on form submission. This highlights the practical application of both component types.",
          "tags": [
            "React",
            "Forms",
            "Code Challenge",
            "Controlled Components",
            "Uncontrolled Components",
            "Refs"
          ],
          "prerequisites": [
            "react_state",
            "react_refs",
            "react_forms_handling"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_propTypes_1",
          "topic": "PropTypes",
          "level": "medium",
          "type": "open",
          "question": "What are React PropTypes, and why are they considered useful in React development?",
          "answer": "React PropTypes are a mechanism for type-checking the props passed to a component. They allow you to define the expected data types, shapes, and requiredness of props. They are useful because:\n1.  **Documentation:** They serve as explicit documentation for a component's API, making it easier for other developers (or your future self) to understand what props a component expects.\n2.  **Runtime Validation & Warnings:** In development mode, if a component receives props that do not match the specified PropTypes, React will log a warning to the console. This helps catch bugs related to incorrect data types early.\n3.  **Debugging Aid:** The warnings provide clear guidance on prop-related issues, simplifying the debugging process.\n4.  **Performance:** PropTypes are automatically removed in production builds, so they do not add any performance overhead to your deployed application.",
          "analysisPoints": [
            "Correctly defines PropTypes.",
            "Lists at least three valid reasons for their usefulness.",
            "Mentions their development-only nature."
          ],
          "keyConcepts": [
            "PropTypes",
            "type checking",
            "props",
            "validation",
            "documentation",
            "development mode"
          ],
          "evaluationCriteria": [
            "Clarity and completeness of the definition.",
            "Quality and accuracy of the listed benefits."
          ],
          "example": null,
          "tags": [
            "React",
            "Props",
            "Validation",
            "Development Tools"
          ],
          "prerequisites": [
            "react_props"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_propTypes_2",
          "topic": "PropTypes",
          "level": "easy",
          "type": "flashcard",
          "question": "Are PropTypes active in production builds of a React application?",
          "answer": "No, PropTypes are automatically removed in production builds for performance optimization.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "PropTypes",
            "production build",
            "performance"
          ],
          "evaluationCriteria": [
            "Quick recall of production behavior"
          ],
          "example": null,
          "tags": [
            "React",
            "PropTypes",
            "Performance"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_propTypes_3",
          "topic": "PropTypes",
          "level": "medium",
          "type": "mcq",
          "question": "A component `UserCard` expects a `user` prop which is an object with `id` (number), `name` (string), and `isActive` (boolean). All these properties are required. Which of the following `propTypes` definitions is correct for `UserCard`?",
          "answer": "```javascript\nUserCard.propTypes = {\n  user: PropTypes.shape({\n    id: PropTypes.number.isRequired,\n    name: PropTypes.string.isRequired,\n    isActive: PropTypes.bool.isRequired\n  }).isRequired\n};\n```",
          "options": [
            "```javascript\nUserCard.propTypes = {\n  user: PropTypes.object({\n    id: PropTypes.number,\n    name: PropTypes.string,\n    isActive: PropTypes.bool\n  }).isRequired\n};\n```",
            "```javascript\nUserCard.propTypes = {\n  user: PropTypes.shape({\n    id: PropTypes.number.isRequired,\n    name: PropTypes.string.isRequired,\n    isActive: PropTypes.bool.isRequired\n  }).isRequired\n};\n```",
            "```javascript\nUserCard.propTypes = {\n  user: {\n    id: PropTypes.number.isRequired,\n    name: PropTypes.string.isRequired,\n    isActive: PropTypes.bool.isRequired\n  }\n};\n```",
            "```javascript\nUserCard.propTypes = {\n  user: PropTypes.object.isRequired\n};\n```"
          ],
          "analysisPoints": [
            "Tests understanding of `PropTypes.shape` for object validation.",
            "Tests correct application of `.isRequired` for nested properties and the main prop.",
            "Distinguishes correct `PropTypes` syntax from incorrect (e.g., plain object)."
          ],
          "keyConcepts": [
            "PropTypes",
            "PropTypes.shape",
            "isRequired",
            "Object validation",
            "Nested PropTypes"
          ],
          "evaluationCriteria": [
            "Correct syntax for `PropTypes.shape`.",
            "Accurate use of `isRequired` at all levels required by the question."
          ],
          "example": "The correct answer uses `PropTypes.shape` to define the exact structure of the `user` object. Each nested property (`id`, `name`, `isActive`) is then validated for its specific type and marked as `isRequired`. Finally, the `user` prop itself is also marked as `isRequired`, meaning the `UserCard` component *must* receive a `user` prop that matches the defined shape.",
          "tags": [
            "React",
            "PropTypes",
            "Validation",
            "Object Structures"
          ],
          "prerequisites": [
            "react_props"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_propTypes_4",
          "topic": "PropTypes",
          "level": "hard",
          "type": "code",
          "question": "Create a `ProductCard` functional component that displays product details. It should accept the following props:\n- `product`: an object with `id` (number, required), `name` (string, required), `price` (number, required), and `isInStock` (boolean, optional).\n- `onAddToCart`: a function (required).\n\nDefine appropriate `propTypes` for this component. Then, demonstrate its usage with a valid `product` and an `onAddToCart` function, and describe what would happen (in development mode) if you tried to render it with a missing required prop or a prop of the wrong type (e.g., `price` as a string).",
          "answer": "```javascript\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction ProductCard({ product, onAddToCart }) {\n  return (\n    <div style={{\n      border: '1px solid #ddd',\n      padding: '15px',\n      margin: '10px',\n      borderRadius: '8px',\n      backgroundColor: product.isInStock ? '#fff' : '#f8f8f8',\n      opacity: product.isInStock ? 1 : 0.7\n    }}>\n      <h3>{product.name} (ID: {product.id})</h3>\n      <p>Price: ${product.price.toFixed(2)}</p>\n      <p>Status: {product.isInStock ? 'In Stock' : 'Out of Stock'}</p>\n      <button onClick={() => onAddToCart(product.id)} disabled={!product.isInStock}>\n        {product.isInStock ? 'Add to Cart' : 'Out of Stock'}\n      </button>\n    </div>\n  );\n}\n\nProductCard.propTypes = {\n  product: PropTypes.shape({\n    id: PropTypes.number.isRequired,\n    name: PropTypes.string.isRequired,\n    price: PropTypes.number.isRequired,\n    isInStock: PropTypes.bool\n  }).isRequired,\n  onAddToCart: PropTypes.func.isRequired\n};\n\n// --- Demonstration Component ---\nfunction AppProductDisplay() {\n  const handleAddToCart = (productId) => {\n    console.log(`Product ${productId} added to cart!`);\n    alert(`Product ${productId} added to cart!`);\n  };\n\n  const validProduct = {\n    id: 101,\n    name: 'Fancy Gadget',\n    price: 99.99,\n    isInStock: true\n  };\n\n  const invalidProductMissingName = {\n    id: 102,\n    // name: 'Missing Name',\n    price: 19.99,\n    isInStock: false\n  };\n\n  const invalidProductWrongType = {\n    id: 103,\n    name: 'Broken Item',\n    price: 'twenty dollars', // Price as string, should be number\n    isInStock: true\n  };\n\n  return (\n    <div>\n      <h1>Product Listings</h1>\n      <h2>Valid Product:</h2>\n      <ProductCard product={validProduct} onAddToCart={handleAddToCart} />\n\n      <h2>Invalid Product (Missing Name - Check Console!):</h2>\n      {/* This will cause a PropTypes warning in development console */}\n      <ProductCard product={invalidProductMissingName} onAddToCart={handleAddToCart} />\n\n      <h2>Invalid Product (Wrong Price Type - Check Console!):</h2>\n      {/* This will cause a PropTypes warning in development console */}\n      <ProductCard product={invalidProductWrongType} onAddToCart={handleAddToCart} />\n    </div>\n  );\n}\n```\n\n**Explanation of what would happen with invalid props:**\nIn **development mode**, if you render `ProductCard` with `invalidProductMissingName` (missing `name` prop which is `isRequired`), React will log a console warning similar to:\n\n```\nWarning: Failed prop type: The prop `product.name` is marked as required in `ProductCard`, but its value is `undefined`.\n    at ProductCard\n```\n\nIf you render it with `invalidProductWrongType` (where `price` is a string instead of a number), React will log a warning like:\n\n```\nWarning: Failed prop type: Invalid prop `product.price` of type `string` supplied to `ProductCard`, expected `number`.\n    at ProductCard\n```\n\nThese warnings provide clear, actionable feedback, helping developers identify and correct prop type mismatches during development, preventing potential runtime errors later.",
          "options": [],
          "analysisPoints": [
            "Correctly defines PropTypes for an object (`shape`) and a function (`func`).",
            "Applies `isRequired` correctly to both top-level and nested properties.",
            "Demonstrates usage with valid props.",
            "Accurately describes the console warnings for missing and wrong-type props.",
            "Shows practical application of PropTypes for component contracts."
          ],
          "keyConcepts": [
            "PropTypes",
            "PropTypes.shape",
            "PropTypes.func",
            "isRequired",
            "Prop validation",
            "Development mode warnings",
            "Component API"
          ],
          "evaluationCriteria": [
            "Completeness and correctness of `propTypes` definition.",
            "Correct code for the component and its demonstration.",
            "Thorough explanation of development-time warnings.",
            "Practical understanding of component contracts."
          ],
          "example": null,
          "tags": [
            "React",
            "Code Challenge",
            "PropTypes",
            "Validation",
            "Component Design"
          ],
          "prerequisites": [
            "react_props"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_routing_1",
          "topic": "React Routing",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose of the `Switch` (or `Routes` in v6) component in React Router. What problem does it solve?",
          "answer": "The `Switch` component (renamed to `Routes` in React Router v6) is used to render **only the first `Route` that matches** the current URL. The problem it solves is ambiguity when multiple `Route` components might potentially match a given URL.\n\nWithout `Switch`/`Routes`, if you had routes like `<Route path=\"/\" component={Home} />` and `<Route path=\"/about\" component={About} />`, visiting `/about` would render *both* `Home` (because `/` is a prefix of `/about`) and `About`. `Switch`/`Routes` ensures that as soon as a `Route` path matches, it stops looking for other matches and renders only that single component. This is essential for:\n\n*   **Exclusive Rendering:** Ensuring only one component renders for a given path.\n*   **404 (Not Found) Pages:** It allows you to place a catch-all route (e.g., `<Route path=\"*\" component={NotFound} />`) as the last `Route` inside `Switch`/`Routes`. This route will only render if no other preceding routes have matched the URL.",
          "analysisPoints": [
            "Correctly identifies the primary function (render first match).",
            "Explains the problem (multiple matches without it).",
            "Provides concrete use cases like 404 pages.",
            "Mentions the v6 naming change."
          ],
          "keyConcepts": [
            "React Router",
            "Switch component",
            "Routes component",
            "Route matching",
            "404 page",
            "Exclusive rendering"
          ],
          "evaluationCriteria": [
            "Clarity of purpose.",
            "Accuracy of problem description.",
            "Relevant examples for application."
          ],
          "example": null,
          "tags": [
            "React",
            "React Router",
            "Routing",
            "Navigation"
          ],
          "prerequisites": [
            "react_components"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_routing_2",
          "topic": "React Routing",
          "level": "easy",
          "type": "flashcard",
          "question": "Which prop in a React Router `Route` component ensures that the component only renders when the path exactly matches the URL, not just as a prefix?",
          "answer": "`exact` (for React Router v5 and earlier, implicit in v6 for `path=\"/\"`)",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Route component",
            "exact prop",
            "path matching"
          ],
          "evaluationCriteria": [
            "Quick recall of `exact` prop"
          ],
          "example": null,
          "tags": [
            "React",
            "React Router",
            "Routing"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_routing_3",
          "topic": "React Routing",
          "level": "medium",
          "type": "mcq",
          "question": "You want to create a route for user profiles like `/users/123` where `123` is the user ID. Which `Route` path definition correctly captures this dynamic segment, and how would you access the `id` within a functional component using React Router v6?",
          "answer": "Path: `/users/:id`; Access with: `const { id } = useParams();`",
          "options": [
            "Path: `/users/id`; Access with: `props.match.params.id`",
            "Path: `/users/:id`; Access with: `const { id } = useParams();`",
            "Path: `/users?id`; Access with: `const { id } = useLocation().searchParams;`",
            "Path: `/users/*`; Access with: `const { id } = useHistory().location.state;`"
          ],
          "analysisPoints": [
            "Tests understanding of dynamic route syntax (`:`).",
            "Tests knowledge of React Router v6 hooks (`useParams`).",
            "Differentiates between path parameters and query parameters (though query params would use `URLSearchParams`)."
          ],
          "keyConcepts": [
            "React Router",
            "Dynamic routes",
            "useParams hook",
            "Route path syntax",
            "URL parameters"
          ],
          "evaluationCriteria": [
            "Correct identification of dynamic segment syntax.",
            "Correct identification of the hook for accessing dynamic parameters.",
            "Awareness of React Router v6 practices."
          ],
          "example": "In React Router, a colon (`:`) is used to define dynamic segments in a path, such as `/users/:id`. For functional components in React Router v6, the `useParams` hook provides an object containing these dynamic segments as properties, so you can destructure `id` directly from it: `const { id } = useParams();`.",
          "tags": [
            "React",
            "React Router",
            "Routing",
            "Hooks",
            "Dynamic Routes"
          ],
          "prerequisites": [
            "react_hooks"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_routing_4",
          "topic": "React Routing",
          "level": "hard",
          "type": "code",
          "question": "Create a simple React application using `react-router-dom` (assume v5 for this task's syntax unless specified). Implement the following:\n1.  A `Home` page at `/`.\n2.  An `About` page at `/about`.\n3.  A `ProductDetail` page at `/products/:productId`.\n4.  A 'Not Found' page for any unmatched routes.\n\nInclude `Link` components for navigation. Ensure only one page renders at a time.",
          "answer": "```javascript\nimport React from 'react';\nimport { BrowserRouter, Route, Switch, Link } from 'react-router-dom';\n\n// 1. Home Component\nconst HomePage = () => (\n  <div>\n    <h2>Home Page</h2>\n    <p>Welcome to our application!</p>\n  </div>\n);\n\n// 2. About Component\nconst AboutPage = () => (\n  <div>\n    <h2>About Us</h2>\n    <p>We are a company that does cool things.</p>\n  </div>\n);\n\n// 3. ProductDetail Component (accessing dynamic segment)\nconst ProductDetailPage = ({ match }) => {\n  const productId = match.params.productId; // Accessing dynamic segment in v5\n  return (\n    <div>\n      <h2>Product Detail</h2>\n      <p>Details for Product ID: <strong>{productId}</strong></p>\n    </div>\n  );\n};\n\n// 4. Not Found Component\nconst NotFoundPage = () => (\n  <div>\n    <h1>404 - Page Not Found</h1>\n    <p>The page you are looking for does not exist.</p>\n  </div>\n);\n\n// Main App Component with Routing\nfunction AppRouter() {\n  return (\n    <BrowserRouter>\n      <nav style={{ padding: '10px', borderBottom: '1px solid #ccc' }}>\n        <Link to=\"/\" style={{ margin: '0 10px' }}>Home</Link>\n        <Link to=\"/about\" style={{ margin: '0 10px' }}>About</Link>\n        <Link to=\"/products/1\" style={{ margin: '0 10px' }}>Product 1</Link>\n        <Link to=\"/products/abc\" style={{ margin: '0 10px' }}>Product ABC</Link>\n        <Link to=\"/nonexistent\" style={{ margin: '0 10px' }}>Bad Link</Link>\n      </nav>\n\n      <div style={{ padding: '20px' }}>\n        <Switch>\n          {/* Exact path for Home to avoid matching other routes */}\n          <Route exact path=\"/\" component={HomePage} />\n          <Route path=\"/about\" component={AboutPage} />\n          {/* Dynamic route for product details */}\n          <Route path=\"/products/:productId\" component={ProductDetailPage} />\n          {/* Catch-all route for 404 - must be last */}\n          <Route component={NotFoundPage} />\n        </Switch>\n      </div>\n    </BrowserRouter>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "Correctly sets up `BrowserRouter`.",
            "Uses `Switch` to ensure exclusive route rendering.",
            "Implements `exact` for the root path.",
            "Correctly defines a dynamic route (`/products/:productId`).",
            "Properly accesses route parameters (`match.params`).",
            "Includes a catch-all route for 404 handling.",
            "Uses `Link` components for navigation."
          ],
          "keyConcepts": [
            "React Router",
            "BrowserRouter",
            "Route",
            "Switch",
            "Link",
            "exact prop",
            "Dynamic routes",
            "404 handling",
            "SPA navigation"
          ],
          "evaluationCriteria": [
            "Functional correctness of routing paths.",
            "Correct usage of `BrowserRouter`, `Switch`, `Route`, `Link`.",
            "Ability to handle dynamic segments and 404 pages.",
            "Clean and readable component structure."
          ],
          "example": null,
          "tags": [
            "React",
            "Code Challenge",
            "React Router",
            "Routing",
            "SPA"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_portals_1",
          "topic": "React Portals",
          "level": "medium",
          "type": "open",
          "question": "What are React Portals, and what common UI challenges do they help solve that are difficult with standard React component rendering?",
          "answer": "React Portals provide a way to render children into a DOM node that exists *outside* the DOM hierarchy of the parent component that renders it. They allow you to 'break out' of the standard parent-child DOM relationship while still maintaining the React component tree and event bubbling behavior.\n\nThey help solve common UI challenges such as:\n1.  **Modals/Dialogs:** Modals often need to overlay the entire page, requiring a high `z-index` and not being constrained by the `overflow` or `z-index` stacking context of their parent components.\n2.  **Tooltips/Popovers:** These small, temporary UI elements need to appear directly next to a trigger but sometimes need to render outside a parent with `overflow: hidden` or other clipping styles.\n3.  **Floating Elements/Context Menus:** Similar to modals and tooltips, elements that need to break out of their parent's visual bounds to function correctly.",
          "analysisPoints": [
            "Correctly defines what a Portal is (rendering outside DOM hierarchy, but within React tree).",
            "Identifies key UI challenges they solve.",
            "Explains *why* these challenges are difficult with standard rendering (e.g., `z-index`, `overflow`)."
          ],
          "keyConcepts": [
            "React Portals",
            "DOM hierarchy",
            "Event bubbling",
            "Modals",
            "Tooltips",
            "z-index",
            "overflow"
          ],
          "evaluationCriteria": [
            "Accuracy of Portal definition.",
            "Relevance and clarity of use cases.",
            "Understanding of the underlying CSS/DOM issues."
          ],
          "example": null,
          "tags": [
            "React",
            "DOM",
            "Rendering",
            "Modals",
            "UX",
            "Advanced React"
          ],
          "prerequisites": [
            "react_basics",
            "dom_manipulation_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_portals_2",
          "topic": "React Portals",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the function used to create a React Portal?",
          "answer": "`ReactDOM.createPortal(child, containerDomNode)`",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "ReactDOM",
            "createPortal"
          ],
          "evaluationCriteria": [
            "Quick recall of Portal API"
          ],
          "example": null,
          "tags": [
            "React",
            "Portals",
            "API"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_portals_3",
          "topic": "React Portals",
          "level": "medium",
          "type": "mcq",
          "question": "You have a deeply nested component that needs to render a modal dialog on top of the entire application. The modal should respond to events from its parent components. Which of the following statements about React Portals in this scenario is TRUE?",
          "answer": "Events from inside the portal will bubble up the React component tree to the modal's parent, even if it's rendered in a different DOM node.",
          "options": [
            "Portals require manual DOM manipulation for event handling, bypassing React's event system.",
            "Events from inside the portal will only bubble up within the DOM node where the portal is rendered.",
            "Portals break the React component tree hierarchy, meaning context will not be available to components inside the portal.",
            "Events from inside the portal will bubble up the React component tree to the modal's parent, even if it's rendered in a different DOM node."
          ],
          "analysisPoints": [
            "Tests understanding of event bubbling in portals.",
            "Tests understanding of context API behavior with portals.",
            "Clarifies that portals manage DOM hierarchy, not React component tree."
          ],
          "keyConcepts": [
            "React Portals",
            "Event bubbling",
            "Context API",
            "DOM hierarchy",
            "React component tree"
          ],
          "evaluationCriteria": [
            "Correct understanding of how events and context work with portals.",
            "Ability to distinguish true statements from common misconceptions."
          ],
          "example": "Despite the DOM element being rendered elsewhere, components inside a portal are still part of the *React component tree*. This means events triggered inside the portal, like `onClick`, will bubble up through the React component hierarchy to their original parent, not just within the DOM subtree of the portal's container. Similarly, context (`React.createContext`) will flow down from providers in the parent React tree to consumers within the portal.",
          "tags": [
            "React",
            "Portals",
            "Events",
            "Context",
            "DOM",
            "Advanced React"
          ],
          "prerequisites": [
            "react_events",
            "react_context"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_portals_4",
          "topic": "React Portals",
          "level": "hard",
          "type": "code",
          "question": "Implement a custom `Tooltip` component using React Portals. The `Tooltip` should appear when hovering over a `Trigger` element. The `Tooltip` content itself should be rendered in a dedicated DOM node (`#tooltip-root`) outside the main application root, but still receive props and handle internal events from the `Trigger` component's context. Position the tooltip directly below the trigger element. (Assume `#tooltip-root` exists in `public/index.html`).",
          "answer": "```javascript\nimport React, { useState, useRef, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\n\n// Assume this div exists in public/index.html:\n// <div id=\"tooltip-root\"></div>\n\nconst Tooltip = ({ content, position, isVisible }) => {\n  if (!isVisible || !position) return null;\n\n  const tooltipRoot = document.getElementById('tooltip-root');\n  if (!tooltipRoot) {\n    console.error('Tooltip root element #tooltip-root not found!');\n    return null;\n  }\n\n  const tooltipStyle = {\n    position: 'absolute',\n    top: position.top + position.height + 5, // 5px offset below trigger\n    left: position.left,\n    backgroundColor: 'black',\n    color: 'white',\n    padding: '8px',\n    borderRadius: '4px',\n    zIndex: 9999, // Ensure it's on top\n    whiteSpace: 'nowrap'\n  };\n\n  return ReactDOM.createPortal(\n    <div style={tooltipStyle}>\n      {content}\n    </div>,\n    tooltipRoot\n  );\n};\n\nfunction TriggerWithTooltip({ children, tooltipContent }) {\n  const [showTooltip, setShowTooltip] = useState(false);\n  const [triggerRect, setTriggerRect] = useState(null);\n  const triggerRef = useRef(null);\n\n  const handleMouseEnter = () => {\n    if (triggerRef.current) {\n      // Get the bounding rectangle of the trigger element\n      setTriggerRect(triggerRef.current.getBoundingClientRect());\n    }\n    setShowTooltip(true);\n  };\n\n  const handleMouseLeave = () => {\n    setShowTooltip(false);\n  };\n\n  return (\n    <span\n      ref={triggerRef}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n      style={{ display: 'inline-block', cursor: 'pointer' }}\n    >\n      {children}\n      <Tooltip\n        content={tooltipContent}\n        position={triggerRect}\n        isVisible={showTooltip}\n      />\n    </span>\n  );\n}\n\n// Example Usage in an App component\nfunction AppPortalTooltip() {\n  return (\n    <div style={{ padding: '50px', height: '200vh' }}>\n      <h1>React Portal Tooltip Example</h1>\n      <div style={{ position: 'relative', border: '1px solid blue', padding: '20px', overflow: 'hidden', height: '100px' }}>\n        <p>This is some content inside a container with `overflow: hidden`.</p>\n        <TriggerWithTooltip tooltipContent=\"This is a tooltip for the first trigger!\">\n          <button>Hover me (1)</button>\n        </TriggerWithTooltip>\n        <p style={{ marginTop: '20px' }}>More content.</p>\n      </div>\n      <p style={{ marginTop: '50px' }}>\n        Here is another \n        <TriggerWithTooltip tooltipContent=\"And another tooltip here!\">\n          <span>text element</span>\n        </TriggerWithTooltip> \n        that also triggers a tooltip.\n      </p>\n    </div>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `ReactDOM.createPortal` to render the tooltip outside the parent's DOM hierarchy.",
            "Calculates and applies the correct positioning for the tooltip relative to the trigger using `getBoundingClientRect`.",
            "Manages tooltip visibility with state (`useState`) and mouse events (`onMouseEnter`, `onMouseLeave`).",
            "Uses `useRef` to get a reference to the trigger DOM element.",
            "Ensures proper `zIndex` for the tooltip to appear on top.",
            "Handles the case where the `tooltip-root` element might not exist gracefully."
          ],
          "keyConcepts": [
            "React Portals",
            "ReactDOM.createPortal",
            "Tooltips",
            "Modals",
            "DOM manipulation (getBoundingClientRect)",
            "Positioning (absolute)",
            "Event handling",
            "useRef",
            "useState"
          ],
          "evaluationCriteria": [
            "Functional correctness of the tooltip (shows/hides, positioned correctly).",
            "Correct use of `ReactDOM.createPortal`.",
            "Effective use of React hooks (`useState`, `useRef`, `useEffect`).",
            "Demonstrates understanding of solving `z-index`/`overflow` issues.",
            "Code organization and readability."
          ],
          "example": null,
          "tags": [
            "React",
            "Code Challenge",
            "Portals",
            "UX",
            "Advanced React",
            "DOM"
          ],
          "prerequisites": [
            "react_hooks",
            "dom_manipulation"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_keys_1",
          "topic": "Keys in React Lists",
          "level": "medium",
          "type": "open",
          "question": "Why are `keys` important when rendering lists in React? What problems can arise if keys are not used correctly or are unstable?",
          "answer": "`Keys` are important because they help React identify which items in a list have changed, been added, or removed. They provide a stable identity to each element in a collection.\n\nProblems that can arise from incorrect or unstable keys:\n1.  **Performance Issues:** Without stable keys, React's reconciliation algorithm (diffing) cannot efficiently determine minimal DOM manipulations. It might re-render or re-mount components unnecessarily, leading to poor performance, especially for large lists.\n2.  **State Loss and Bugs:** If keys are unstable (e.g., using array index when the list order changes, or `Math.random()`), React might mistakenly reuse a DOM element for a different logical item. This can lead to incorrect component state being applied to the wrong data, resulting in visual glitches, incorrect user input (e.g., text fields showing wrong values), or other hard-to-debug application errors.\n3.  **Incorrect UI Updates:** When items are reordered, without stable keys, React might simply update the content of existing elements instead of physically reordering them, leading to an inconsistent UI state.",
          "analysisPoints": [
            "Correctly explains the role of keys in reconciliation.",
            "Lists performance degradation as a key issue.",
            "Explains state loss/bugs due to incorrect element reuse.",
            "Distinguishes between correct and incorrect key strategies."
          ],
          "keyConcepts": [
            "Keys",
            "React lists",
            "Reconciliation",
            "Diffing algorithm",
            "Performance",
            "State preservation",
            "Unstable keys"
          ],
          "evaluationCriteria": [
            "Completeness of the explanation for `why`.",
            "Accuracy and relevance of the problems described."
          ],
          "example": null,
          "tags": [
            "React",
            "Lists",
            "Performance",
            "Reconciliation",
            "Keys"
          ],
          "prerequisites": [
            "react_rendering",
            "react_state"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_keys_2",
          "topic": "Keys in React Lists",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the two main rules for choosing good keys in React lists?",
          "answer": "1. Keys must be unique among siblings. 2. Keys must be stable across renders for the same logical item.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Keys",
            "uniqueness",
            "stability",
            "React lists"
          ],
          "evaluationCriteria": [
            "Quick recall of key rules"
          ],
          "example": null,
          "tags": [
            "React",
            "Keys",
            "Best Practices"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_keys_3",
          "topic": "Keys in React Lists",
          "level": "medium",
          "type": "mcq",
          "question": "You are rendering a dynamic list of user comments that can be added or deleted. Each comment object has a unique `commentId` property. Which of the following is the most appropriate and performant way to assign a `key` to each comment in the list?",
          "answer": "`<Comment key={comment.commentId} comment={comment} />`",
          "options": [
            "`<Comment key={index} comment={comment} />`",
            "`<Comment key={Math.random()} comment={comment} />`",
            "`<Comment comment={comment} />` (no key prop)",
            "`<Comment key={comment.commentId} comment={comment} />`"
          ],
          "analysisPoints": [
            "Tests understanding of using unique, stable IDs as keys.",
            "Evaluates awareness of pitfalls of `index` or `Math.random()` as keys.",
            "Reinforces performance implications of key choices."
          ],
          "keyConcepts": [
            "Keys",
            "Unique IDs",
            "Stable keys",
            "Array index as key",
            "Performance optimization"
          ],
          "evaluationCriteria": [
            "Correct identification of the best key strategy.",
            "Implicit understanding of why other options are problematic."
          ],
          "example": "Using `comment.commentId` as the key is the best practice. It is unique for each comment and remains stable even if comments are added, removed, or reordered. Using `index` as a key is problematic for dynamic lists, and `Math.random()` generates unstable keys, forcing React to re-mount components every time, leading to performance issues and potential state loss.",
          "tags": [
            "React",
            "Lists",
            "Keys",
            "Performance",
            "Best Practices"
          ],
          "prerequisites": [
            "react_rendering"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_keys_4",
          "topic": "Keys in React Lists",
          "level": "hard",
          "type": "code",
          "question": "You have a list of `Product` components, each with an input field to adjust quantity. Initially, the list displays `Product A`, `Product B`, `Product C`. Implement a functional React component that displays this list and allows:\n1.  Adding a new product (`Product D`, `Product E`, etc.) to the *beginning* of the list.\n2.  Removing a product from the *middle* of the list (e.g., remove `Product B`).\n\nCrucially, use a unique and stable `id` for each product. Explain in comments how using `id` as a key helps maintain the state of the input fields, especially when items are added to the beginning or removed from the middle, versus using array `index` as a key.",
          "answer": "```javascript\nimport React, { useState } from 'react';\n\nlet nextProductId = 1;\n\nfunction ProductItem({ product, onRemove }) {\n  const [quantity, setQuantity] = useState(0);\n\n  // Using product.id as the key is crucial here for state persistence.\n  // If `key={index}` were used instead, adding to the beginning or\n  // removing from the middle would shift indices, causing React to\n  // mistakenly re-use the wrong component instance and its 'quantity' state\n  // for a different product, leading to incorrect input values.\n  // With a stable 'id' as key, React knows exactly which component instance\n  // corresponds to which product, preserving its `quantity` state.\n\n  return (\n    <li style={{ border: '1px solid #eee', padding: '10px', margin: '5px 0', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n      <span>Product: {product.name} (ID: {product.id})</span>\n      <div>\n        <label>Qty: </label>\n        <input \n          type=\"number\" \n          value={quantity} \n          onChange={(e) => setQuantity(parseInt(e.target.value) || 0)} \n          style={{ width: '60px' }}\n        />\n        <button onClick={() => onRemove(product.id)} style={{ marginLeft: '10px' }}>Remove</button>\n      </div>\n    </li>\n  );\n}\n\nfunction ProductListManager() {\n  const [products, setProducts] = useState([\n    { id: nextProductId++, name: 'Product A' },\n    { id: nextProductId++, name: 'Product B' },\n    { id: nextProductId++, name: 'Product C' }\n  ]);\n\n  const addProductToBeginning = () => {\n    const newProduct = { id: nextProductId++, name: `New Product ${nextProductId - 1}` };\n    setProducts([newProduct, ...products]);\n  };\n\n  const removeProductById = (idToRemove) => {\n    setProducts(products.filter(product => product.id !== idToRemove));\n  };\n\n  return (\n    <div>\n      <h2>Dynamic Product List (Stable Keys)</h2>\n      <button onClick={addProductToBeginning}>Add New Product to Beginning</button>\n      <ul style={{ listStyleType: 'none', padding: 0 }}>\n        {products.map(product => (\n          <ProductItem \n            key={product.id} // CRITICAL: Using stable product.id as key\n            product={product} \n            onRemove={removeProductById} \n          />\n        ))}\n      </ul>\n      <p>Try entering quantities, then add/remove items. Observe how quantities remain tied to the correct product.</p>\n      <p>Now, try changing `key={product.id}` to `key={index}` in `ProductListManager` and repeat. You'll see quantities shift to the wrong products.</p>\n    </div>\n  );\n}\n\n// Example Usage:\n// <ProductListManager />\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses a unique, stable `id` as the key for each list item.",
            "Implements functionality to add to the beginning of the list, which highlights the need for stable keys.",
            "Implements functionality to remove from the middle of the list, another key scenario for stable keys.",
            "Clearly explains in comments the importance of `id` as a key versus `index` for state persistence.",
            "Demonstrates a stateful child component (`ProductItem`) whose state is preserved."
          ],
          "keyConcepts": [
            "Keys",
            "Stable keys",
            "Array `map`",
            "List manipulation",
            "State preservation",
            "Reconciliation",
            "Functional components",
            "useState hook"
          ],
          "evaluationCriteria": [
            "Code correctness for list operations (add/remove).",
            "Correct and deliberate use of stable `id` as key.",
            "Clear and accurate explanation of the `id` vs. `index` key problem.",
            "Demonstrates understanding of `useState` persistence with stable keys."
          ],
          "example": null,
          "tags": [
            "React",
            "Code Challenge",
            "Lists",
            "Keys",
            "Performance",
            "State Management"
          ],
          "prerequisites": [
            "react_hooks",
            "javascript_arrays"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_redux_problem_solved_1",
          "topic": "Redux Problem Solved",
          "level": "medium",
          "type": "open",
          "question": "What is 'prop drilling', and how does Redux help alleviate this problem in large React applications?",
          "answer": "**Prop drilling** (or 'props drilling') is a situation where data (props) needs to be passed down through many levels of nested components, even if the intermediate components do not directly use those props. This makes the code less readable, harder to maintain, and more brittle to refactoring, as changes to data requirements at the top level necessitate changes across many intermediate components.\n\nRedux helps alleviate this problem by providing a **single, centralized store** for the entire application's state. Instead of passing props down, components that need access to a piece of state can directly `connect` (or use `useSelector` in functional components) to the Redux store to retrieve the data they need. Similarly, components that need to update state can `dispatch` actions to the store directly (or use `useDispatch`), without needing to pass callback functions down as props. This effectively flattens the data flow, allowing components to subscribe to and update state without involving every component in between.",
          "analysisPoints": [
            "Clear definition of prop drilling.",
            "Accurate explanation of how Redux (centralized store, direct access) solves it.",
            "Mentions `connect`/`useSelector` and `dispatch`/`useDispatch` as mechanisms.",
            "Highlights improved readability and maintainability."
          ],
          "keyConcepts": [
            "Prop drilling",
            "Redux",
            "Centralized state",
            "Redux store",
            "Connect HOC",
            "useSelector hook",
            "useDispatch hook"
          ],
          "evaluationCriteria": [
            "Completeness of problem and solution explanation.",
            "Accuracy of Redux mechanisms described."
          ],
          "example": null,
          "tags": [
            "Redux",
            "State Management",
            "Prop Drilling",
            "Architecture"
          ],
          "prerequisites": [
            "react_props"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_problem_solved_2",
          "topic": "Redux Problem Solved",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the core principle of Redux regarding the source of application state?",
          "answer": "Single Source of Truth: The entire application state is stored in a single store.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Redux",
            "Single Source of Truth",
            "State Management"
          ],
          "evaluationCriteria": [
            "Quick recall of core principle"
          ],
          "example": null,
          "tags": [
            "Redux",
            "State Management"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_problem_solved_3",
          "topic": "Redux Problem Solved",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a problem that Redux primarily aims to solve?",
          "answer": "Optimizing component re-renders for individual component state updates.",
          "options": [
            "Managing complex state logic shared across many components.",
            "Avoiding 'prop drilling' in deeply nested component trees.",
            "Ensuring state changes are predictable and traceable.",
            "Optimizing component re-renders for individual component state updates."
          ],
          "analysisPoints": [
            "Tests understanding of Redux's scope and primary benefits.",
            "Differentiates Redux's role from React's internal rendering optimizations.",
            "Confirms core problems Redux targets."
          ],
          "keyConcepts": [
            "Redux",
            "State Management",
            "Prop drilling",
            "Predictable state",
            "Component re-renders",
            "Performance optimization"
          ],
          "evaluationCriteria": [
            "Correctly identifies the non-Redux problem.",
            "Demonstrates clear understanding of Redux's purpose."
          ],
          "example": "While Redux can indirectly impact performance by making state changes more predictable, its primary role is not to optimize *individual* component re-renders (that's React's job with reconciliation, `PureComponent`, `memo`, `shouldComponentUpdate`). Redux focuses on centralized, predictable state management and solving issues like prop drilling and complex shared state logic.",
          "tags": [
            "Redux",
            "State Management",
            "Scope",
            "Performance"
          ],
          "prerequisites": [
            "react_lifecycle_performance"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_problem_solved_4",
          "topic": "Redux Problem Solved",
          "level": "hard",
          "type": "open",
          "question": "Describe the three core principles of Redux and explain how each contributes to making state management predictable.",
          "answer": "Redux is built on three core principles that ensure predictable state management:\n\n1.  **Single Source of Truth:** The entire application's state is stored in a single object tree within a single store. This means there's one canonical place to find any piece of state, eliminating data inconsistencies that can arise from multiple, fragmented state locations. Predictability comes from knowing exactly where to look for state and that all parts of the application are working with the same, unified state.\n\n2.  **State is Read-Only:** The only way to change the state is by emitting an action, an object describing what happened. State cannot be directly mutated. This principle makes state changes explicit and intentional. Instead of parts of the UI or network callbacks directly altering state, they declare their intent through actions. This 'event sourcing' approach makes every state transition traceable and auditable, greatly aiding in debugging and understanding application flow.\n\n3.  **Changes are Made with Pure Functions (Reducers):** To specify how the state tree is transformed by actions, you write pure functions called reducers. Reducers take the current state and an action, and return a *new* state (they must not mutate the original state). Their purity ensures that given the same input state and action, they will always produce the same output state, without any side effects. This determinism makes state transitions highly predictable and easily testable, as the logic for state changes is isolated and self-contained.",
          "analysisPoints": [
            "Accurately lists and describes all three core principles.",
            "Explains how each principle (single source, read-only, pure reducers) contributes to predictability.",
            "Uses correct Redux terminology (store, action, reducer, pure function, immutability)."
          ],
          "keyConcepts": [
            "Redux principles",
            "Single Source of Truth",
            "Actions",
            "Reducers",
            "Pure functions",
            "Immutability",
            "Predictable state"
          ],
          "evaluationCriteria": [
            "Comprehensive and accurate explanation of each principle.",
            "Clear connection between principles and predictability.",
            "Demonstration of deep understanding of Redux's core philosophy."
          ],
          "example": null,
          "tags": [
            "Redux",
            "State Management",
            "Architecture",
            "Principles"
          ],
          "prerequisites": [
            "javascript_pure_functions"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_class_method_binding_1",
          "title": "Implement a Counter Component with Different Binding Strategies",
          "description": "\nCreate a React application that includes three identical counter components, each demonstrating a different method for binding event handlers in class components:\n\n1.  **Counter A:** Bind the `increment` method in the constructor.\n2.  **Counter B:** Use an arrow function as a class property for the `increment` method.\n3.  **Counter C:** Bind the `increment` method inline in the render method.\n\nEach counter should display its own count and have a button to increment it. Ensure all three counters function correctly and increment independently.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\n// Counter A: Bind in constructor\nclass CounterA extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    // TODO: Bind increment method here\n  }\n\n  increment() {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Counter A (Constructor Bind)</h3>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment A</button>\n      </div>\n    );\n  }\n}\n\n// Counter B: Use arrow function as class property\nclass CounterB extends React.Component {\n  state = { count: 0 };\n\n  // TODO: Define increment method as arrow function class property\n  increment() {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Counter B (Class Property Arrow Function)</h3>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment B</button>\n      </div>\n    );\n  }\n}\n\n// Counter C: Inline bind in render method\nclass CounterC extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  increment() {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Counter C (Inline Bind in Render)</h3>\n        <p>Count: {this.state.count}</p>\n        {/* TODO: Bind increment method inline here */}\n        <button onClick={this.increment}>Increment C</button>\n      </div>\n    );\n  }\n}\n\nfunction App() {\n  return (\n    <div style={{ display: 'flex', gap: '20px', padding: '20px' }}>\n      <CounterA />\n      <CounterB />\n      <CounterC />\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React from 'react';\n\n// Counter A: Bind in constructor\nclass CounterA extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    this.increment = this.increment.bind(this); // Solution: Bind in constructor\n  }\n\n  increment() {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Counter A (Constructor Bind)</h3>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment A</button>\n      </div>\n    );\n  }\n}\n\n// Counter B: Use arrow function as class property\nclass CounterB extends React.Component {\n  state = { count: 0 };\n\n  increment = () => { // Solution: Arrow function as class property\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Counter B (Class Property Arrow Function)</h3>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment B</button>\n      </div>\n    );\n  }\n}\n\n// Counter C: Inline bind in render method\nclass CounterC extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  increment() {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Counter C (Inline Bind in Render)</h3>\n        <p>Count: {this.state.count}</p>\n        <button onClick={() => this.increment()}>Increment C</button> {/* Solution: Inline bind */}\n      </div>\n    );\n  }\n}\n\nfunction App() {\n  return (\n    <div style={{ display: 'flex', gap: '20px', padding: '20px' }}>\n      <CounterA />\n      <CounterB />\n      <CounterC />\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Counter A: Clicking 'Increment A' button should increment its count correctly.",
            "Counter B: Clicking 'Increment B' button should increment its count correctly.",
            "Counter C: Clicking 'Increment C' button should increment its count correctly.",
            "All counters should maintain their independent counts without interfering with each other.",
            "Verify no `TypeError: Cannot read property 'setState' of undefined` occurs in the console for any counter."
          ],
          "hints": [
            "For Counter A, remember to use `this.methodName = this.methodName.bind(this);` inside the constructor.",
            "For Counter B, utilize the arrow function syntax directly when defining the class method: `methodName = () => { ... };`.",
            "For Counter C, wrap the method call in an arrow function directly in the `onClick` prop: `onClick={() => this.methodName()}`."
          ],
          "tags": [
            "React",
            "Class Components",
            "Binding",
            "this context",
            "Event Handling"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_class_components",
            "javascript_this_keyword",
            "javascript_arrow_functions"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_class_method_binding"
          ]
        },
        {
          "id": "task_api_calls_lifecycle_1",
          "title": "Build a User Profile Viewer with API Fetching",
          "description": "\nCreate a React application that fetches and displays user data from a public API. Your application should include:\n\n1.  A functional component `UserProfile` that takes a `userId` prop.\n2.  Inside `UserProfile`, use the `useEffect` hook to fetch data for the given `userId` from `https://jsonplaceholder.typicode.com/users/:userId`. The API call should only happen once when the component mounts.\n3.  Display a 'Loading...' message while fetching data.\n4.  Display an 'Error: [message]' if the fetch fails.\n5.  Once data is fetched, display the user's `name`, `email`, and `phone`.\n\n**Bonus:** Implement a simple `App` component that allows switching between different `userId`s to see how the `UserProfile` component re-fetches data.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\nfunction UserProfile({ userId }) {\n  const [userData, setUserData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // TODO: Implement data fetching logic here\n    // Make sure to handle loading, success, and error states\n    // The fetch should only run once on initial mount for a given userId\n  }, [userId]); // Hint: Pay attention to this dependency array\n\n  if (loading) {\n    return <div>Loading user {userId} data...</div>;\n  }\n\n  if (error) {\n    return <div>Error: {error.message}</div>;\n  }\n\n  if (!userData) {\n    return <div>No user data available.</div>;\n  }\n\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '15px', margin: '10px', borderRadius: '8px' }}>\n      <h2>User Profile: {userData.name}</h2>\n      <p>Email: {userData.email}</p>\n      <p>Phone: {userData.phone}</p>\n    </div>\n  );\n}\n\nfunction App() {\n  const [currentUserId, setCurrentUserId] = useState(1);\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h1>User Viewer</h1>\n      <div>\n        <button onClick={() => setCurrentUserId(1)}>Load User 1</button>\n        <button onClick={() => setCurrentUserId(2)}>Load User 2</button>\n        <button onClick={() => setCurrentUserId(100)}>Load Invalid User (Expect Error)</button>\n      </div>\n      <UserProfile userId={currentUserId} />\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction UserProfile({ userId }) {\n  const [userData, setUserData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // Reset states for new fetch\n    setLoading(true);\n    setError(null);\n    setUserData(null); \n\n    const fetchUser = async () => {\n      try {\n        const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);\n        if (!response.ok) {\n          // Handle 404 or other HTTP errors\n          if (response.status === 404) {\n              throw new Error(`User with ID ${userId} not found.`);\n          } else {\n              throw new Error(`HTTP error! status: ${response.status}`);\n          }\n        }\n        const data = await response.json();\n        setUserData(data);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchUser();\n\n    // Cleanup function (optional for fetch, but good practice for subscriptions/timers)\n    // For fetch, typically not needed unless you use AbortController\n    return () => {\n      // Any cleanup if necessary, e.g., cancelling ongoing requests\n    };\n  }, [userId]); // Dependency array: re-run effect if userId changes\n\n  if (loading) {\n    return <div>Loading user {userId} data...</div>;\n  }\n\n  if (error) {\n    return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n  }\n\n  if (!userData) {\n    // This case should ideally not be reached if loading/error are handled correctly\n    // but serves as a fallback for initial state or unexpected null data.\n    return <div>No user data available for user ID {userId}.</div>;\n  }\n\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '15px', margin: '10px', borderRadius: '8px' }}>\n      <h2>User Profile: {userData.name}</h2>\n      <p>Email: {userData.email}</p>\n      <p>Phone: {userData.phone}</p>\n      <p>Website: {userData.website}</p>\n    </div>\n  );\n}\n\nfunction App() {\n  const [currentUserId, setCurrentUserId] = useState(1);\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h1>User Viewer</h1>\n      <div style={{ marginBottom: '20px' }}>\n        <button onClick={() => setCurrentUserId(1)} style={{ marginRight: '10px' }}>Load User 1</button>\n        <button onClick={() => setCurrentUserId(2)} style={{ marginRight: '10px' }}>Load User 2</button>\n        <button onClick={() => setCurrentUserId(5)} style={{ marginRight: '10px' }}>Load User 5</button>\n        <button onClick={() => setCurrentUserId(100)} style={{ marginRight: '10px' }}>Load Invalid User (Expect Error)</button>\n        <button onClick={() => setCurrentUserId(11)} style={{ marginRight: '10px' }}>Load Non-existent User (Expect Error)</button>\n      </div>\n      <UserProfile userId={currentUserId} />\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Load User 1: Should display 'Loading...' then show data for 'Leanne Graham'.",
            "Load User 2: Should display 'Loading...' then show data for 'Ervin Howell'.",
            "Load User 5: Should display 'Loading...' then show data for 'Chelsey Dietrich'.",
            "Load User 11 (invalid/non-existent): Should display 'Loading...' then an error message like 'Error: User with ID 11 not found.' or 'Error: HTTP error! status: 404'.",
            "Verify that `useEffect` correctly re-runs when `userId` changes, causing a new fetch."
          ],
          "hints": [
            "Remember to use an `async` function inside `useEffect` for `await` syntax.",
            "Handle the three states of an API call: loading, success, and error.",
            "The `userId` prop needs to be in the `useEffect` dependency array to re-fetch when it changes.",
            "Use `response.ok` to check for successful HTTP status codes (200-299)."
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "API Calls",
            "Data Fetching",
            "State Management"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_hooks",
            "javascript_async_await",
            "javascript_promises"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_api_calls_lifecycle"
          ]
        },
        {
          "id": "task_setState_in_render_1",
          "title": "Debug a Component Causing Infinite Re-renders",
          "description": "\nYou are given a React class component that is causing an infinite loop and crashing the browser. Your task is to:\n\n1.  Identify the specific line of code causing the infinite loop.\n2.  Explain *why* that line causes the loop (related to React's rendering lifecycle).\n3.  Fix the component so it no longer causes an infinite loop and instead displays the count correctly upon user interaction (e.g., a button click).\n\n**Note:** Do NOT call `setState` in the `render` method.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass DebugMe extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  // This method intends to increment count\n  triggerUpdate = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  render() {\n    // PROBLEM LINE: This line is causing the infinite loop\n    // DO NOT REMOVE THIS LINE, but understand why it's bad and fix its usage\n    this.triggerUpdate(); \n\n    return (\n      <div>\n        <h1>Count: {this.state.count}</h1>\n        <p>This component is broken!</p>\n        {/* You should add a button here to trigger the update correctly */}\n      </div>\n    );\n  }\n}\n\nexport default DebugMe;\n",
          "solutionCode": "import React from 'react';\n\nclass DebugMe extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  incrementCount = () => { // Renamed for clarity, using class property for binding\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  render() {\n    // PROBLEM EXPLANATION: \n    // Calling `this.triggerUpdate()` (or `this.incrementCount()`) directly in `render` \n    // causes an infinite loop because `setState()` inside it triggers a re-render,\n    // which in turn calls `render()` again, leading to a continuous cycle.\n    // The `render` method must be a pure function that only returns JSX \n    // based on current props and state, without causing side effects like state changes.\n\n    return (\n      <div>\n        <h1>Count: {this.state.count}</h1>\n        <p>This component is now fixed!</p>\n        {/* SOLUTION: Call the method only on a user interaction, e.g., button click */}\n        <button onClick={this.incrementCount}>Increment Count</button>\n      </div>\n    );\n  }\n}\n\nexport default DebugMe;\n",
          "testCases": [
            "The component should load without crashing the browser.",
            "The count should initially be 0.",
            "Clicking the 'Increment Count' button should increase the count by 1 each time.",
            "No infinite loop warnings or errors should appear in the browser console."
          ],
          "hints": [
            "The `render` method should be a pure function. This means it should not have side effects like directly modifying state.",
            "State updates should generally be triggered by user interactions (e.g., button clicks, form submissions) or lifecycle methods/hooks (like `componentDidMount` or `useEffect` for data fetching).",
            "Consider where `this.triggerUpdate()` is being called in the provided code and how that interacts with React's rendering cycle."
          ],
          "tags": [
            "React",
            "Debugging",
            "Infinite Loop",
            "State Management",
            "Lifecycle Methods",
            "Anti-patterns"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_class_components",
            "react_state",
            "react_lifecycle"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_setState_in_render"
          ]
        },
        {
          "id": "task_componentWillUnmount_1",
          "title": "Create a `VisibilityLogger` Component with Cleanup",
          "description": "\nImplement a React functional component `VisibilityLogger` that demonstrates proper cleanup using `useEffect`.\n\nRequirements:\n1.  When `VisibilityLogger` mounts, it should add a `visibilitychange` event listener to the `document` that logs whether the tab is visible or hidden.\n2.  When `VisibilityLogger` unmounts, it must remove this event listener to prevent memory leaks.\n3.  The main `App` component should have a button to toggle the `VisibilityLogger`'s presence in the DOM.\n4.  Log messages to the console for:\n    *   `VisibilityLogger` mounting.\n    *   `VisibilityLogger` unmounting (indicating cleanup).\n    *   Tab visibility changes.\n\nVerify that the `visibilitychange` events stop being logged to the console once the `VisibilityLogger` component is unmounted.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\nfunction VisibilityLogger() {\n  useEffect(() => {\n    console.log('VisibilityLogger Mounted');\n\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        console.log('Tab is hidden');\n      } else {\n        console.log('Tab is visible');\n      }\n    };\n\n    // TODO: Add the event listener to the document\n\n    return () => {\n      // TODO: Implement cleanup: remove the event listener\n      console.log('VisibilityLogger Unmounted (Cleanup)');\n    };\n  }, []);\n\n  return (\n    <div style={{ border: '1px dashed blue', padding: '10px', margin: '10px' }}>\n      <p>VisibilityLogger is active. Check console for logs when you switch tabs.</p>\n      <p>Close this component to see cleanup message.</p>\n    </div>\n  );\n}\n\nfunction App() {\n  const [showLogger, setShowLogger] = useState(false);\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h1>Event Listener Cleanup Demo</h1>\n      <button onClick={() => setShowLogger(!showLogger)}>\n        {showLogger ? 'Hide Logger' : 'Show Logger'}\n      </button>\n      {showLogger && <VisibilityLogger />}\n      <p>Toggle the logger, then switch browser tabs to test.</p>\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction VisibilityLogger() {\n  useEffect(() => {\n    console.log('VisibilityLogger Mounted');\n\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        console.log('Tab is hidden');\n      } else {\n        console.log('Tab is visible');\n      }\n    };\n\n    // Solution: Add the event listener to the document\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    return () => {\n      // Solution: Remove the event listener in the cleanup function\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n      console.log('VisibilityLogger Unmounted (Cleanup)');\n    };\n  }, []); // Empty dependency array means effect runs once on mount, cleanup on unmount\n\n  return (\n    <div style={{ border: '1px dashed blue', padding: '10px', margin: '10px' }}>\n      <p>VisibilityLogger is active. Check console for logs when you switch tabs.</p>\n      <p>Close this component to see cleanup message.</p>\n    </div>\n  );\n}\n\nfunction App() {\n  const [showLogger, setShowLogger] = useState(false);\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h1>Event Listener Cleanup Demo</h1>\n      <button onClick={() => setShowLogger(!showLogger)}>\n        {showLogger ? 'Hide Logger' : 'Show Logger'}\n      </button>\n      {showLogger && <VisibilityLogger />}\n      <p>Toggle the logger, then switch browser tabs to test.</p>\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Initial state: The 'Show Logger' button should be visible, and `VisibilityLogger` should not be in the DOM.",
            "Clicking 'Show Logger': 'VisibilityLogger Mounted' should be logged to console. The `VisibilityLogger` component should appear.",
            "With `VisibilityLogger` visible: Switch browser tabs back and forth. You should see 'Tab is hidden' and 'Tab is visible' logs in the console.",
            "Clicking 'Hide Logger': 'VisibilityLogger Unmounted (Cleanup)' should be logged to console. The `VisibilityLogger` component should disappear.",
            "After hiding: Switch browser tabs back and forth. No 'Tab is hidden' or 'Tab is visible' logs should appear, confirming cleanup."
          ],
          "hints": [
            "Event listeners added to global objects like `document` or `window` must always be explicitly removed.",
            "The `useEffect` hook's return function is the perfect place for cleanup logic.",
            "Ensure the event listener reference (the function itself) passed to `addEventListener` is the *same* reference passed to `removeEventListener`."
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Cleanup",
            "Event Listeners",
            "Memory Leaks"
          ],
          "timeEstimate": 35,
          "prerequisites": [
            "react_hooks",
            "javascript_event_listeners"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_componentWillUnmount"
          ]
        },
        {
          "id": "task_controlled_uncontrolled_components_1",
          "title": "Implement a Contact Form with Mixed Controlled/Uncontrolled Inputs",
          "description": "\nCreate a React functional component `ContactForm` that includes a mix of controlled and uncontrolled form inputs.\n\nRequirements:\n1.  **Controlled Input:** A text input for 'Name'. Its value should be managed by React state, and it should display a character count in real-time.\n2.  **Controlled Input:** A text area for 'Message'. Its value should also be managed by React state.\n3.  **Uncontrolled Input:** A checkbox for 'Subscribe to Newsletter'. Its checked state should be accessed via a `ref` only on form submission.\n4.  **Uncontrolled Input:** A file input for 'Attach Resume'. Its selected file (name) should be accessed via a `ref` only on form submission.\n5.  On form submission, log all collected form data (Name, Message, Subscribe status, Attached File Name) to the console.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useRef } from 'react';\n\nfunction ContactForm() {\n  // TODO: Define state for controlled inputs\n  const [name, setName] = useState('');\n  const [message, setMessage] = useState('');\n\n  // TODO: Define refs for uncontrolled inputs\n  const subscribeRef = useRef(null);\n  const resumeFileRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n\n    // TODO: Access values from all inputs and log them\n    const formData = {\n      name: 'TODO',\n      message: 'TODO',\n      subscribe: 'TODO',\n      resumeFileName: 'TODO'\n    };\n    console.log('Form Submitted:', formData);\n    alert('Form submitted! Check console for details.');\n  };\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '15px', maxWidth: '400px', margin: '20px auto', padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <h2>Contact Us</h2>\n\n      <div>\n        <label htmlFor=\"name\">Name (Controlled):</label>\n        <input\n          id=\"name\"\n          type=\"text\"\n          value={name} // TODO: Bind value\n          onChange={(e) => setName(e.target.value)} // TODO: Handle change\n        />\n        <small>Characters: {name.length}</small>\n      </div>\n\n      <div>\n        <label htmlFor=\"message\">Message (Controlled):</label>\n        <textarea\n          id=\"message\"\n          value={message} // TODO: Bind value\n          onChange={(e) => setMessage(e.target.value)} // TODO: Handle change\n          rows=\"5\"\n        ></textarea>\n      </div>\n\n      <div>\n        <input\n          id=\"subscribe\"\n          type=\"checkbox\"\n          ref={subscribeRef} // TODO: Attach ref\n        />\n        <label htmlFor=\"subscribe\">Subscribe to Newsletter (Uncontrolled)</label>\n      </div>\n\n      <div>\n        <label htmlFor=\"resume\">Attach Resume (Uncontrolled):</label>\n        <input\n          id=\"resume\"\n          type=\"file\"\n          ref={resumeFileRef} // TODO: Attach ref\n        />\n      </div>\n\n      <button type=\"submit\" style={{ padding: '10px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}>\n        Submit Form\n      </button>\n    </form>\n  );\n}\n\nexport default ContactForm;\n",
          "solutionCode": "import React, { useState, useRef } from 'react';\n\nfunction ContactForm() {\n  // Controlled inputs: state manages their value\n  const [name, setName] = useState('');\n  const [message, setMessage] = useState('');\n\n  // Uncontrolled inputs: refs access their DOM value\n  const subscribeRef = useRef(null);\n  const resumeFileRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n\n    // Accessing controlled input values from state\n    const enteredName = name;\n    const enteredMessage = message;\n\n    // Accessing uncontrolled input values from refs\n    const isSubscribed = subscribeRef.current.checked; // For checkbox, use .checked\n    const resumeFileName = resumeFileRef.current.files.length > 0 \n      ? resumeFileRef.current.files[0].name \n      : 'No file selected';\n\n    const formData = {\n      name: enteredName,\n      message: enteredMessage,\n      subscribe: isSubscribed,\n      resumeFileName: resumeFileName\n    };\n    console.log('Form Submitted:', formData);\n    alert('Form submitted! Check console for details.');\n\n    // Optional: Clear controlled fields after submission\n    setName('');\n    setMessage('');\n    // Note: Cannot easily clear uncontrolled fields programmatically without direct DOM manipulation \n    // or making them controlled.\n    if (resumeFileRef.current) resumeFileRef.current.value = null; // Clears file input\n    if (subscribeRef.current) subscribeRef.current.checked = false; // Unchecks checkbox\n  };\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '15px', maxWidth: '400px', margin: '20px auto', padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <h2>Contact Us</h2>\n\n      <div>\n        <label htmlFor=\"name\">Name (Controlled):</label>\n        <input\n          id=\"name\"\n          type=\"text\"\n          value={name}\n          onChange={(e) => setName(e.target.value)}\n        />\n        <small>Characters: {name.length}</small>\n      </div>\n\n      <div>\n        <label htmlFor=\"message\">Message (Controlled):</label>\n        <textarea\n          id=\"message\"\n          value={message}\n          onChange={(e) => setMessage(e.target.value)}\n          rows=\"5\"\n        ></textarea>\n      </div>\n\n      <div>\n        <input\n          id=\"subscribe\"\n          type=\"checkbox\"\n          ref={subscribeRef}\n        />\n        <label htmlFor=\"subscribe\">Subscribe to Newsletter (Uncontrolled)</label>\n      </div>\n\n      <div>\n        <label htmlFor=\"resume\">Attach Resume (Uncontrolled):</label>\n        <input\n          id=\"resume\"\n          type=\"file\"\n          ref={resumeFileRef}\n        />\n      </div>\n\n      <button type=\"submit\" style={{ padding: '10px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}>\n        Submit Form\n      </button>\n    </form>\n  );\n}\n\nexport default ContactForm;\n",
          "testCases": [
            "Fill 'Name' and 'Message' inputs. Verify character count updates for 'Name'.",
            "Select / deselect 'Subscribe to Newsletter'.",
            "Select a file for 'Attach Resume'.",
            "Submit the form. Verify that the console log contains the correct values for name, message, subscribe status, and the selected file's name.",
            "Submit the form without selecting a file. Verify 'No file selected' or similar is logged for resume.",
            "Observe that controlled inputs clear after submission, and uncontrolled inputs reset (checkbox unchecks, file input clears) if cleared programmatically."
          ],
          "hints": [
            "Remember that for a controlled input, its `value` prop must be tied to state, and its `onChange` prop must update that state.",
            "For uncontrolled inputs, use `useRef()` to create a ref and attach it to the `ref` prop of the input element.",
            "To get the value of an input field using a ref, access `ref.current.value`. For a checkbox, use `ref.current.checked`. For a file input, use `ref.current.files[0]` (if a file is selected).",
            "Ensure `event.preventDefault()` is called in the `handleSubmit` function to prevent default browser form submission behavior."
          ],
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "Uncontrolled Components",
            "Refs",
            "State Management",
            "Hooks"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_state",
            "react_refs",
            "react_forms_handling",
            "javascript_events"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_controlled_uncontrolled_components"
          ]
        },
        {
          "id": "task_propTypes_1",
          "title": "Implement a `UserBadge` Component with PropTypes",
          "description": "\nCreate a React functional component `UserBadge` that displays user information. It should accept the following props:\n\n1.  `user`: An object with the following properties:\n    *   `id`: `number` (required)\n    *   `name`: `string` (required)\n    *   `email`: `string` (required, and must be a valid email format, though basic string validation is fine for PropTypes)\n    *   `isActive`: `boolean` (optional)\n2.  `size`: `string` (required, must be one of `'small'`, `'medium'`, `'large'`)\n3.  `onClick`: `function` (optional, for handling clicks on the badge)\n\n**Task Requirements:**\n\n*   Define `propTypes` for all listed props with their respective types and requiredness.\n*   Implement the `UserBadge` component to display the user's name and email. Show 'Active' or 'Inactive' based on `isActive`.\n*   Demonstrate rendering `UserBadge` in an `App` component with:\n    *   A perfectly valid set of props.\n    *   A set of props that is missing a required property (e.g., `name`).\n    *   A set of props with an incorrect type (e.g., `id` as a string, `size` as an invalid string).\n*   Observe the console warnings in development mode for invalid props.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction UserBadge({ user, size, onClick }) {\n  const badgeStyle = {\n    padding: '10px',\n    margin: '5px',\n    border: '1px solid #ccc',\n    borderRadius: '5px',\n    backgroundColor: user.isActive ? '#e6ffe6' : '#fff',\n    cursor: onClick ? 'pointer' : 'default',\n    width: size === 'small' ? '150px' : size === 'medium' ? '200px' : '250px'\n  };\n\n  return (\n    <div style={badgeStyle} onClick={onClick ? () => onClick(user.id) : undefined}>\n      <h4>{user.name} (ID: {user.id})</h4>\n      <p>Email: {user.email}</p>\n      <p>Status: {user.isActive ? 'Active' : 'Inactive'}</p>\n    </div>\n  );\n}\n\n// TODO: Define PropTypes for UserBadge\nUserBadge.propTypes = {\n  // user prop validation\n  // size prop validation\n  // onClick prop validation\n};\n\nfunction App() {\n  const handleBadgeClick = (userId) => {\n    console.log(`User badge with ID ${userId} clicked!`);\n  };\n\n  const validUser = {\n    id: 1,\n    name: 'Alice Johnson',\n    email: 'alice@example.com',\n    isActive: true\n  };\n\n  const missingNameUser = {\n    id: 2,\n    // name: 'Bob Smith', // Missing name\n    email: 'bob@example.com',\n    isActive: false\n  };\n\n  const invalidIdUser = {\n    id: 'three', // Invalid type for ID\n    name: 'Charlie Brown',\n    email: 'charlie@example.com',\n    isActive: true\n  };\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h1>User Badge Examples</h1>\n      <h2>Valid UserBadge:</h2>\n      <UserBadge user={validUser} size=\"medium\" onClick={handleBadgeClick} />\n\n      <h2>Invalid UserBadge (Missing Name - Check Console!):</h2>\n      {/* This should trigger a warning */}\n      <UserBadge user={missingNameUser} size=\"large\" />\n\n      <h2>Invalid UserBadge (Invalid ID Type - Check Console!):</h2>\n      {/* This should trigger a warning */}\n      <UserBadge user={invalidIdUser} size=\"small\" />\n\n      <h2>Invalid UserBadge (Invalid Size String - Check Console!):</h2>\n      {/* This should trigger a warning */}\n      <UserBadge user={validUser} size=\"extra-large\" />\n\n      <h2>UserBadge without onClick (Optional prop):</h2>\n      <UserBadge user={validUser} size=\"medium\" />\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction UserBadge({ user, size, onClick }) {\n  const badgeStyle = {\n    padding: '10px',\n    margin: '5px',\n    border: '1px solid #ccc',\n    borderRadius: '5px',\n    backgroundColor: user.isActive ? '#e6ffe6' : '#fff',\n    cursor: onClick ? 'pointer' : 'default',\n    width: size === 'small' ? '150px' : size === 'medium' ? '200px' : '250px'\n  };\n\n  return (\n    <div style={badgeStyle} onClick={onClick ? () => onClick(user.id) : undefined}>\n      <h4>{user.name} (ID: {user.id})</h4>\n      <p>Email: {user.email}</p>\n      <p>Status: {user.isActive ? 'Active' : 'Inactive'}</p>\n    </div>\n  );\n}\n\n// Solution: Define PropTypes for UserBadge\nUserBadge.propTypes = {\n  user: PropTypes.shape({\n    id: PropTypes.number.isRequired,\n    name: PropTypes.string.isRequired,\n    email: PropTypes.string.isRequired, // Basic string validation for email\n    isActive: PropTypes.bool\n  }).isRequired,\n  size: PropTypes.oneOf(['small', 'medium', 'large']).isRequired,\n  onClick: PropTypes.func\n};\n\nfunction App() {\n  const handleBadgeClick = (userId) => {\n    console.log(`User badge with ID ${userId} clicked!`);\n  };\n\n  const validUser = {\n    id: 1,\n    name: 'Alice Johnson',\n    email: 'alice@example.com',\n    isActive: true\n  };\n\n  const missingNameUser = {\n    id: 2,\n    // name: 'Bob Smith', // Intentionally missing\n    email: 'bob@example.com',\n    isActive: false\n  };\n\n  const invalidIdUser = {\n    id: 'three', // Intentionally wrong type\n    name: 'Charlie Brown',\n    email: 'charlie@example.com',\n    isActive: true\n  };\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h1>User Badge Examples</h1>\n      <h2>Valid UserBadge:</h2>\n      <UserBadge user={validUser} size=\"medium\" onClick={handleBadgeClick} />\n\n      <h2>Invalid UserBadge (Missing Name - Check Console!):</h2>\n      <UserBadge user={missingNameUser} size=\"large\" />\n\n      <h2>Invalid UserBadge (Invalid ID Type - Check Console!):</h2>\n      <UserBadge user={invalidIdUser} size=\"small\" />\n\n      <h2>Invalid UserBadge (Invalid Size String - Check Console!):</h2>\n      <UserBadge user={validUser} size=\"extra-large\" />\n\n      <h2>UserBadge without onClick (Optional prop):</h2>\n      <UserBadge user={validUser} size=\"medium\" />\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Valid props: `UserBadge` with `validUser`, `size=\"medium\"`, and `onClick` should render correctly and log on click.",
            "Missing required prop: `UserBadge` with `missingNameUser` should render, but a warning about missing `user.name` should appear in the console.",
            "Incorrect type prop: `UserBadge` with `invalidIdUser` should render, but a warning about `user.id` having `string` type instead of `number` should appear.",
            "Invalid `oneOf` prop: `UserBadge` with `size=\"extra-large\"` should render, but a warning about `size` not being one of the allowed values should appear.",
            "Optional prop: `UserBadge` with `validUser` and `size=\"medium\"` but *without* `onClick` should render correctly, and clicking it should do nothing (no error)."
          ],
          "hints": [
            "Remember to import `PropTypes` from the `prop-types` package.",
            "Use `PropTypes.shape()` for validating the structure of an object prop.",
            "Use `.isRequired` to mark required properties.",
            "For a prop that must be one of a specific set of strings, use `PropTypes.oneOf()`.",
            "Run your React application in development mode to see the console warnings."
          ],
          "tags": [
            "React",
            "PropTypes",
            "Validation",
            "Component Design",
            "Props",
            "Development Tools"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_props",
            "javascript_objects"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_propTypes"
          ]
        },
        {
          "id": "task_react_routing_1",
          "title": "Build a Multi-Page Blog App with React Router",
          "description": "\nCreate a simple React blog application using `react-router-dom` (use v5 syntax for this task). Your application should have the following pages and functionalities:\n\n1.  **Home Page (`/`)**: Displays a welcome message and links to 'About' and a list of blog posts.\n2.  **About Page (`/about`)**: Displays information about the blog.\n3.  **Blog Posts List Page (`/posts`)**: Displays a list of mock blog post titles. Each title should be a link to its respective detailed view.\n4.  **Blog Post Detail Page (`/posts/:postId`)**: Displays the full content of a specific blog post, identified by its `postId`. (Use mock data for posts).\n5.  **Not Found Page (`*`)**: A catch-all page for any routes that don't match.\n\nEnsure proper navigation between pages using `Link` components. The application structure should use `BrowserRouter` and `Switch`.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport { BrowserRouter, Route, Switch, Link } from 'react-router-dom';\n\n// Mock Data for Blog Posts\nconst blogPosts = [\n  { id: '1', title: 'First Steps with React', content: 'Lorem ipsum dolor sit amet...' },\n  { id: '2', title: 'Understanding Hooks', content: 'Consectetur adipiscing elit...' },\n  { id: '3', title: 'Styling in React', content: 'Sed do eiusmod tempor incididunt...' }\n];\n\n// 1. Home Page Component\nconst HomePage = () => (\n  <div>\n    <h2>Welcome to Our Blog!</h2>\n    <p>Explore our articles and learn something new.</p>\n    <nav>\n      <ul>\n        <li><Link to=\"/about\">About Us</Link></li>\n        <li><Link to=\"/posts\">View All Posts</Link></li>\n      </ul>\n    </nav>\n  </div>\n);\n\n// 2. About Page Component\nconst AboutPage = () => (\n  <div>\n    <h2>About This Blog</h2>\n    <p>This blog is dedicated to sharing knowledge about frontend development.</p>\n  </div>\n);\n\n// 3. Blog Posts List Page Component\nconst PostsListPage = () => (\n  <div>\n    <h2>All Blog Posts</h2>\n    <ul>\n      {/* TODO: Map over blogPosts to create links to individual posts */}\n    </ul>\n  </div>\n);\n\n// 4. Blog Post Detail Page Component\nconst PostDetailPage = ({ match }) => {\n  // TODO: Get postId from match.params\n  // TODO: Find the post from blogPosts based on postId\n  // TODO: Display post title and content, or a 'Post not found' message\n\n  return (\n    <div>\n      {/* Example: */}\n      {/* <h2>{post.title}</h2>\n      <p>{post.content}</p> */}\n    </div>\n  );\n};\n\n// 5. Not Found Page Component\nconst NotFoundPage = () => (\n  <div>\n    <h1>404 - Page Not Found</h1>\n    <p>The page you are looking for does not exist.</p>\n    <Link to=\"/\">Go to Home</Link>\n  </div>\n);\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <nav style={{ padding: '10px', backgroundColor: '#f0f0f0', borderBottom: '1px solid #ddd' }}>\n        <Link to=\"/\" style={{ margin: '0 10px' }}>Home</Link>\n        <Link to=\"/about\" style={{ margin: '0 10px' }}>About</Link>\n        <Link to=\"/posts\" style={{ margin: '0 10px' }}>Blog</Link>\n      </nav>\n      <div style={{ padding: '20px' }}>\n        <Switch>\n          {/* TODO: Define all routes here */}\n          {/* Example: */}\n          {/* <Route exact path=\"/\" component={HomePage} /> */}\n        </Switch>\n      </div>\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React from 'react';\nimport { BrowserRouter, Route, Switch, Link } from 'react-router-dom';\n\n// Mock Data for Blog Posts\nconst blogPosts = [\n  { id: '1', title: 'First Steps with React', content: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.' },\n  { id: '2', title: 'Understanding Hooks', content: 'Consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.' },\n  { id: '3', title: 'Styling in React', content: 'Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.' }\n];\n\n// 1. Home Page Component\nconst HomePage = () => (\n  <div>\n    <h2>Welcome to Our Blog!</h2>\n    <p>Explore our articles and learn something new.</p>\n    <nav>\n      <ul>\n        <li><Link to=\"/about\">About Us</Link></li>\n        <li><Link to=\"/posts\">View All Posts</Link></li>\n      </ul>\n    </nav>\n  </div>\n);\n\n// 2. About Page Component\nconst AboutPage = () => (\n  <div>\n    <h2>About This Blog</h2>\n    <p>This blog is dedicated to sharing knowledge about frontend development.</p>\n  </div>\n);\n\n// 3. Blog Posts List Page Component\nconst PostsListPage = () => (\n  <div>\n    <h2>All Blog Posts</h2>\n    <ul>\n      {blogPosts.map(post => (\n        <li key={post.id}>\n          <Link to={`/posts/${post.id}`}>{post.title}</Link>\n        </li>\n      ))}\n    </ul>\n  </div>\n);\n\n// 4. Blog Post Detail Page Component\nconst PostDetailPage = ({ match }) => {\n  const postId = match.params.postId; // Get postId from match.params\n  const post = blogPosts.find(p => p.id === postId); // Find the post\n\n  if (!post) {\n    return (\n      <div>\n        <h2>Post Not Found</h2>\n        <p>The blog post with ID \"{postId}\" does not exist.</p>\n        <Link to=\"/posts\">Back to all posts</Link>\n      </div>\n    );\n  }\n\n  return (\n    <div>\n      <h2>{post.title}</h2>\n      <p>{post.content}</p>\n      <Link to=\"/posts\">Back to all posts</Link>\n    </div>\n  );\n};\n\n// 5. Not Found Page Component\nconst NotFoundPage = () => (\n  <div>\n    <h1>404 - Page Not Found</h1>\n    <p>The page you are looking for does not exist.</p>\n    <Link to=\"/\">Go to Home</Link>\n  </div>\n);\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <nav style={{ padding: '10px', backgroundColor: '#f0f0f0', borderBottom: '1px solid #ddd' }}>\n        <Link to=\"/\" style={{ margin: '0 10px' }}>Home</Link>\n        <Link to=\"/about\" style={{ margin: '0 10px' }}>About</Link>\n        <Link to=\"/posts\" style={{ margin: '0 10px' }}>Blog</Link>\n      </nav>\n      <div style={{ padding: '20px' }}>\n        <Switch>\n          {/* Define all routes here */}\n          <Route exact path=\"/\" component={HomePage} />\n          <Route path=\"/about\" component={AboutPage} />\n          <Route exact path=\"/posts\" component={PostsListPage} />\n          <Route path=\"/posts/:postId\" component={PostDetailPage} />\n          {/* Catch-all for 404 - must be last */}\n          <Route component={NotFoundPage} />\n        </Switch>\n      </div>\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Navigate to `/`: Should display 'Welcome to Our Blog!' and links.",
            "Navigate to `/about`: Should display 'About This Blog'.",
            "Navigate to `/posts`: Should display 'All Blog Posts' with clickable titles for each mock post.",
            "Click on 'First Steps with React' link from `/posts`: Should navigate to `/posts/1` and display its content.",
            "Manually navigate to `/posts/999` (non-existent post): Should display 'Post Not Found'.",
            "Manually navigate to `/nonexistent-route`: Should display '404 - Page Not Found'.",
            "Verify browser's back/forward buttons work correctly for all navigated paths."
          ],
          "hints": [
            "Remember to use `exact` for routes that should only match the precise path (e.g., `/`).",
            "For dynamic segments like `postId`, define the `Route` path as `/posts/:postId`.",
            "Inside the component rendered by a dynamic route (e.g., `PostDetailPage`), access the parameter using `props.match.params.postId` (in v5).",
            "`Switch` ensures only one route renders. Place your 404 route last within the `Switch` to act as a fallback."
          ],
          "tags": [
            "React",
            "React Router",
            "Routing",
            "SPA",
            "Navigation",
            "Blog"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_components",
            "javascript_arrays_map"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_routing"
          ]
        },
        {
          "id": "task_react_portals_1",
          "title": "Build a Simple Confirmation Modal with React Portals",
          "description": "\nCreate a React application that features a confirmation modal implemented using React Portals. The modal should appear when a user clicks a button in the main application content.\n\nRequirements:\n\n1.  **Modal Component (`ConfirmationModal`)**: \n    *   This component should be a functional component.\n    *   It should accept `isOpen` (boolean), `onClose` (function), `onConfirm` (function), and `children` (modal content) as props.\n    *   It should use `ReactDOM.createPortal` to render its content into a dedicated DOM node outside the main React app's root (e.g., `<div id=\"modal-root\"></div>` in `public/index.html`).\n    *   The modal should have an overlay that darkens the background and closes the modal when clicked (unless the click is on the modal content itself).\n    *   The modal content should have a 'Cancel' button (calls `onClose`) and a 'Confirm' button (calls `onConfirm`).\n\n2.  **App Component**: \n    *   Contains a button that toggles the `ConfirmationModal`'s `isOpen` state.\n    *   Implement `onClose` and `onConfirm` functions that log messages to the console (e.g., 'Modal closed' and 'Action confirmed!').\n\n**Note:** Assume you have added `<div id=\"modal-root\"></div>` to your `public/index.html` file (e.g., just before the closing `</body>` tag).\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\n// Assume public/index.html has <div id=\"modal-root\"></div>\n\nconst ConfirmationModal = ({ isOpen, onClose, onConfirm, children }) => {\n  // If the modal is not open, don't render anything\n  if (!isOpen) return null;\n\n  // Find the portal root DOM node\n  const portalRoot = document.getElementById('modal-root');\n  if (!portalRoot) {\n    console.error('Modal root element #modal-root not found!');\n    return null;\n  }\n\n  return ReactDOM.createPortal(\n    <div style={{\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0,\n      backgroundColor: 'rgba(0,0,0,0.5)',\n      display: 'flex',\n      justifyContent: 'center',\n      alignItems: 'center',\n      zIndex: 1000\n    }} onClick={onClose}> {/* Clicking overlay closes modal */}\n      <div style={{\n        backgroundColor: 'white',\n        padding: '20px',\n        borderRadius: '8px',\n        minWidth: '350px',\n        boxShadow: '0 4px 8px rgba(0,0,0,0.2)',\n        zIndex: 1001\n      }} onClick={e => e.stopPropagation()}> {/* Clicking modal content does not close */}\n        {children}\n        <div style={{ marginTop: '20px', textAlign: 'right' }}>\n          {/* TODO: Add Cancel and Confirm buttons */}\n          <button style={{ marginRight: '10px' }}>Cancel</button>\n          <button>Confirm</button>\n        </div>\n      </div>\n    </div>,\n    portalRoot\n  );\n};\n\nfunction App() {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  const handleOpenModal = () => setIsModalOpen(true);\n  const handleCloseModal = () => {\n    console.log('Modal closed.');\n    setIsModalOpen(false);\n  };\n  const handleConfirmAction = () => {\n    console.log('Action confirmed!');\n    setIsModalOpen(false);\n  };\n\n  return (\n    <div style={{ padding: '20px', height: '100vh', display: 'flex', flexDirection: 'column', alignItems: 'center' }}>\n      <h1>React Portal Modal Demo</h1>\n      <p>Click the button below to open a confirmation modal.</p>\n      <button onClick={handleOpenModal}>Open Confirmation</button>\n\n      <ConfirmationModal\n        isOpen={isModalOpen}\n        onClose={handleCloseModal}\n        onConfirm={handleConfirmAction}\n      >\n        <h2>Are you sure?</h2>\n        <p>This action cannot be undone.</p>\n      </ConfirmationModal>\n\n      <div style={{ marginTop: '50px', border: '1px dashed lightgray', padding: '20px' }}>\n        <p>This is some content that the modal will appear on top of, demonstrating how it breaks out of the DOM hierarchy.</p>\n        <p>It's often hard to make modals cover the whole screen and ignore parent CSS rules without portals.</p>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\n// Assume public/index.html has <div id=\"modal-root\"></div>\n\nconst ConfirmationModal = ({ isOpen, onClose, onConfirm, children }) => {\n  // If the modal is not open, don't render anything\n  if (!isOpen) return null;\n\n  // Find the portal root DOM node\n  const portalRoot = document.getElementById('modal-root');\n  if (!portalRoot) {\n    console.error('Modal root element #modal-root not found!');\n    return null;\n  }\n\n  return ReactDOM.createPortal(\n    <div style={{\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0,\n      backgroundColor: 'rgba(0,0,0,0.5)',\n      display: 'flex',\n      justifyContent: 'center',\n      alignItems: 'center',\n      zIndex: 1000\n    }} onClick={onClose}> {/* Clicking overlay closes modal */}\n      <div style={{\n        backgroundColor: 'white',\n        padding: '20px',\n        borderRadius: '8px',\n        minWidth: '350px',\n        boxShadow: '0 4px 8px rgba(0,0,0,0.2)',\n        zIndex: 1001\n      }} onClick={e => e.stopPropagation()}> {/* Clicking modal content does not close */}\n        {children}\n        <div style={{ marginTop: '20px', textAlign: 'right' }}>\n          <button onClick={onClose} style={{ marginRight: '10px', padding: '8px 15px', borderRadius: '5px', border: '1px solid #ccc', backgroundColor: '#f0f0f0', cursor: 'pointer' }}>Cancel</button>\n          <button onClick={onConfirm} style={{ padding: '8px 15px', borderRadius: '5px', border: 'none', backgroundColor: '#007bff', color: 'white', cursor: 'pointer' }}>Confirm</button>\n        </div>\n      </div>\n    </div>,\n    portalRoot\n  );\n};\n\nfunction App() {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  const handleOpenModal = () => setIsModalOpen(true);\n  const handleCloseModal = () => {\n    console.log('Modal closed.');\n    setIsModalOpen(false);\n  };\n  const handleConfirmAction = () => {\n    console.log('Action confirmed!');\n    setIsModalOpen(false);\n  };\n\n  return (\n    <div style={{ padding: '20px', height: '100vh', display: 'flex', flexDirection: 'column', alignItems: 'center' }}>\n      <h1>React Portal Modal Demo</h1>\n      <p>Click the button below to open a confirmation modal.</p>\n      <button onClick={handleOpenModal} style={{ padding: '10px 20px', fontSize: '1.1em', cursor: 'pointer' }}>Open Confirmation</button>\n\n      <ConfirmationModal\n        isOpen={isModalOpen}\n        onClose={handleCloseModal}\n        onConfirm={handleConfirmAction}\n      >\n        <h2>Are you sure?</h2>\n        <p>This action cannot be undone.</p>\n      </ConfirmationModal>\n\n      <div style={{ marginTop: '50px', border: '1px dashed lightgray', padding: '20px' }}>\n        <p>This is some content that the modal will appear on top of, demonstrating how it breaks out of the DOM hierarchy.</p>\n        <p>It's often hard to make modals cover the whole screen and ignore parent CSS rules without portals.</p>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Initial state: Modal should not be visible.",
            "Click 'Open Confirmation': Modal should appear centered on the screen with a semi-transparent background. Console should *not* log 'Action confirmed!' or 'Modal closed'.",
            "Click 'Cancel' button inside modal: Modal should close. Console should log 'Modal closed.'.",
            "Click 'Open Confirmation' again. Click outside the modal content (on the dark overlay): Modal should close. Console should log 'Modal closed.'.",
            "Click 'Open Confirmation' again. Click 'Confirm' button inside modal: Modal should close. Console should log 'Action confirmed!'.",
            "Clicking inside the modal content (but not on buttons) should not close the modal.",
            "Inspect the DOM: Verify that the modal's `div` is rendered as a direct child of `#modal-root`, not within the `App` component's DOM structure."
          ],
          "hints": [
            "Remember that `ReactDOM.createPortal` takes two arguments: the React element to render and the DOM element to mount it into.",
            "Use `event.stopPropagation()` on the modal's content wrapper to prevent clicks inside the modal from bubbling up and closing the modal via the overlay's `onClick`.",
            "Ensure the modal's `position` is `fixed` and `zIndex` is high to cover the entire viewport."
          ],
          "tags": [
            "React",
            "Portals",
            "Modals",
            "DOM Manipulation",
            "UX",
            "Hooks"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_hooks",
            "dom_manipulation_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_react_portals"
          ]
        },
        {
          "id": "task_react_keys_1",
          "title": "Build a Dynamic Checklist with Stable Keys",
          "description": "\nCreate a React functional component `Checklist` that manages a dynamic list of items. Each item should have a unique ID, a text description, and a checkbox to mark it as complete. The component should allow:\n\n1.  **Adding a new item**: A button to add a new item (e.g., 'New Task N') to the **top** of the list.\n2.  **Toggling completion**: Each item's checkbox should toggle its `completed` status.\n3.  **Removing an item**: A button next to each item to remove it from the list.\n\n**Crucially, use a unique and stable `id` for each list item's `key` prop.** Explain in comments how this choice affects the behavior of checkboxes when items are added to the beginning or removed from the middle, versus using `index` as a key.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\nlet nextItemId = 1;\n\nfunction ChecklistItem({ item, onToggleComplete, onRemove }) {\n  return (\n    <li style={{ display: 'flex', alignItems: 'center', margin: '5px 0', border: '1px solid #eee', padding: '8px', borderRadius: '4px' }}>\n      <input\n        type=\"checkbox\"\n        checked={item.completed}\n        onChange={() => onToggleComplete(item.id)}\n        style={{ marginRight: '10px' }}\n      />\n      <span style={{ textDecoration: item.completed ? 'line-through' : 'none' }}>\n        {item.text} (ID: {item.id})\n      </span>\n      <button\n        onClick={() => onRemove(item.id)}\n        style={{ marginLeft: 'auto', backgroundColor: '#dc3545', color: 'white', border: 'none', padding: '5px 10px', borderRadius: '3px', cursor: 'pointer' }}\n      >\n        Remove\n      </button>\n    </li>\n  );\n}\n\nfunction Checklist() {\n  const [items, setItems] = useState([\n    { id: nextItemId++, text: 'Learn React Keys', completed: false },\n    { id: nextItemId++, text: 'Understand PropTypes', completed: true },\n    { id: nextItemId++, text: 'Implement a Modal', completed: false }\n  ]);\n\n  const handleAddItem = () => {\n    const newItem = { id: nextItemId++, text: `New Task ${nextItemId - 1}`, completed: false };\n    // TODO: Add new item to the beginning of the list\n  };\n\n  const handleToggleComplete = (id) => {\n    setItems(items.map(item => \n      item.id === id ? { ...item, completed: !item.completed } : item\n    ));\n  };\n\n  const handleRemoveItem = (idToRemove) => {\n    // TODO: Remove item by id\n  };\n\n  return (\n    <div style={{ padding: '20px', maxWidth: '500px', margin: 'auto' }}>\n      <h1>My Dynamic Checklist</h1>\n      <button \n        onClick={handleAddItem} \n        style={{ marginBottom: '15px', padding: '10px 15px', backgroundColor: '#28a745', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}\n      >\n        Add New Task to Top\n      </button>\n      <ul style={{ listStyleType: 'none', padding: 0 }}>\n        {items.map(item => (\n          <ChecklistItem \n            key={item.id} // TODO: Ensure correct key usage (stable ID)\n            item={item} \n            onToggleComplete={handleToggleComplete} \n            onRemove={handleRemoveItem} \n          />\n        ))}\n      </ul>\n      <p style={{ marginTop: '20px', fontSize: '0.9em', color: '#555' }}>\n        Try checking/unchecking items, then add a new item to the top or remove one from the middle.\n        Observe how the checkbox states behave. Then, try changing `key={item.id}` to `key={index}` in the map function and re-test. \n        You should see checkboxes behave unexpectedly with `key={index}` when the list changes order or size.\n      </p>\n    </div>\n  );\n}\n\nexport default Checklist;\n",
          "solutionCode": "import React, { useState } from 'react';\n\nlet nextItemId = 1;\n\nfunction ChecklistItem({ item, onToggleComplete, onRemove }) {\n  return (\n    <li style={{ display: 'flex', alignItems: 'center', margin: '5px 0', border: '1px solid #eee', padding: '8px', borderRadius: '4px' }}>\n      <input\n        type=\"checkbox\"\n        checked={item.completed}\n        onChange={() => onToggleComplete(item.id)}\n        style={{ marginRight: '10px' }}\n      />\n      <span style={{ textDecoration: item.completed ? 'line-through' : 'none' }}>\n        {item.text} (ID: {item.id})\n      </span>\n      <button\n        onClick={() => onRemove(item.id)}\n        style={{ marginLeft: 'auto', backgroundColor: '#dc3545', color: 'white', border: 'none', padding: '5px 10px', borderRadius: '3px', cursor: 'pointer' }}\n      >\n        Remove\n      </button>\n    </li>\n  );\n}\n\nfunction Checklist() {\n  const [items, setItems] = useState([\n    { id: nextItemId++, text: 'Learn React Keys', completed: false },\n    { id: nextItemId++, text: 'Understand PropTypes', completed: true },\n    { id: nextItemId++, text: 'Implement a Modal', completed: false }\n  ]);\n\n  const handleAddItem = () => {\n    const newItem = { id: nextItemId++, text: `New Task ${nextItemId - 1}`, completed: false };\n    setItems([newItem, ...items]); // Solution: Add new item to the beginning\n  };\n\n  const handleToggleComplete = (id) => {\n    setItems(items.map(item => \n      item.id === id ? { ...item, completed: !item.completed } : item\n    ));\n  };\n\n  const handleRemoveItem = (idToRemove) => {\n    setItems(items.filter(item => item.id !== idToRemove)); // Solution: Remove item by id\n  };\n\n  return (\n    <div style={{ padding: '20px', maxWidth: '500px', margin: 'auto' }}>\n      <h1>My Dynamic Checklist</h1>\n      <button \n        onClick={handleAddItem} \n        style={{ marginBottom: '15px', padding: '10px 15px', backgroundColor: '#28a745', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}\n      >\n        Add New Task to Top\n      </button>\n      <ul style={{ listStyleType: 'none', padding: 0 }}>\n        {items.map(item => (\n          <ChecklistItem \n            key={item.id} // Solution: Using stable item.id as key\n            item={item} \n            onToggleComplete={handleToggleComplete} \n            onRemove={handleRemoveItem} \n          />\n        ))}\n      </ul>\n      <p style={{ marginTop: '20px', fontSize: '0.9em', color: '#555' }}>\n        **Explanation of Key Usage:**\n        Using `item.id` as the `key` is crucial here because `id` is a stable, unique identifier for each task.\n        If a new item is added to the beginning, or an item is removed from the middle, the `id` of existing items remains unchanged.\n        React uses these stable `id`s to correctly identify and match existing `ChecklistItem` components in the new list with their previous instances.\n        This ensures that the internal state of each `ChecklistItem` (specifically, its checkbox `checked` state, which is implicitly managed by the DOM input element linked to `item.completed`) is preserved and correctly associated with the original task, even if its position in the array (and thus its `index`) changes.\n        \n        In contrast, if `key={index}` were used, when an item is added to the beginning or removed from the middle, the indices of all subsequent items would shift. React would then see that the item at `index 0` is now a different item, and try to re-use the *previous* `index 0`'s DOM element and its state for the *new* item at `index 0`, leading to incorrect checkbox states or other unexpected behavior.\n      </p>\n    </div>\n  );\n}\n\nexport default Checklist;\n",
          "testCases": [
            "Initial render: Three items should be displayed with their correct completed status.",
            "Toggle completion: Clicking a checkbox should toggle its item's completion status correctly.",
            "Add new item: Click 'Add New Task to Top'. A new item should appear at the very top of the list. Verify that existing items (below the new one) retain their original checked/unchecked states.",
            "Remove item from middle: Check 'Learn React Keys'. Then, remove 'Understand PropTypes'. Verify that 'Learn React Keys' remains checked, and the list re-orders correctly without state loss for 'Learn React Keys'.",
            "Verify that no React warnings about keys appear in the console during any operations."
          ],
          "hints": [
            "Ensure each new item object has a unique `id`. You can use `nextItemId++` for this.",
            "To add an item to the beginning of an array in state, use the spread operator: `setItems([newItem, ...currentItems])`.",
            "To remove an item by ID, use `filter()` on the `items` array to create a new array excluding the item with the matching ID.",
            "The `key` prop should be placed on the `<li>` element (or the top-level element returned by `map`) and its value should be a stable unique identifier from your data.",
            "Pay close attention to the `key` prop in the `map` function. This is the core of the task."
          ],
          "tags": [
            "React",
            "Lists",
            "Keys",
            "State Management",
            "Performance",
            "Hooks",
            "Debugging"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_hooks",
            "javascript_arrays"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_keys"
          ]
        },
        {
          "id": "task_redux_problem_solved_1",
          "title": "Simulate Prop Drilling and Discuss Redux Solution",
          "description": "\nThis task involves demonstrating the 'prop drilling' problem in a React application and conceptually explaining how Redux would solve it.\n\n**Part 1: Simulate Prop Drilling (Coding Task)**\n\n1.  Create an `App` component that holds a `user` object in its state (e.g., `{ name: 'John Doe', theme: 'dark' }`).\n2.  Create three nested components: `ParentComponent` -> `ChildComponent` -> `GrandchildComponent`.\n3.  Pass the `user` object from `App` down to `GrandchildComponent` through `ParentComponent` and `ChildComponent` as props. Neither `ParentComponent` nor `ChildComponent` should directly use the `user` prop.\n4.  `GrandchildComponent` should display the user's `name` and `theme`.\n5.  Add a button in `GrandchildComponent` that, when clicked, attempts to change the `theme` property of the `user` object. You will need to pass a callback function (`onUpdateUserTheme`) from `App` down to `GrandchildComponent` as well, to simulate how state changes would propagate without a global store.\n\n**Part 2: Conceptual Explanation (Textual)**\n\nExplain how Redux would restructure this application to avoid prop drilling for both reading and updating the `user` state. Focus on the core Redux concepts (store, actions, reducers, `useSelector`/`useDispatch` or `connect`).\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// Part 1: Simulate Prop Drilling\n\n// GrandchildComponent: Displays user info and has a button to update theme\nfunction GrandchildComponent({ user, onUpdateUserTheme }) {\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '15px', margin: '10px', backgroundColor: '#f9f9f9' }}>\n      <h3>Grandchild Component</h3>\n      <p>User Name: <strong>{user.name}</strong></p>\n      <p>Current Theme: <strong>{user.theme}</strong></p>\n      <button onClick={() => onUpdateUserTheme(user.theme === 'dark' ? 'light' : 'dark')}>\n        Toggle Theme\n      </button>\n    </div>\n  );\n}\n\n// ChildComponent: Passes props down\nfunction ChildComponent({ user, onUpdateUserTheme }) {\n  // This component doesn't use 'user' or 'onUpdateUserTheme' directly\n  // TODO: Pass props to GrandchildComponent\n  return (\n    <div style={{ border: '1px dashed blue', padding: '10px', margin: '10px' }}>\n      <h4>Child Component (Intermediate)</h4>\n      <GrandchildComponent user={user} onUpdateUserTheme={onUpdateUserTheme} />\n    </div>\n  );\n}\n\n// ParentComponent: Passes props down\nfunction ParentComponent({ user, onUpdateUserTheme }) {\n  // This component doesn't use 'user' or 'onUpdateUserTheme' directly\n  // TODO: Pass props to ChildComponent\n  return (\n    <div style={{ border: '1px solid green', padding: '10px', margin: '10px' }}>\n      <h3>Parent Component (Intermediate)</h3>\n      <ChildComponent user={user} onUpdateUserTheme={onUpdateUserTheme} />\n    </div>\n  );\n}\n\n// App Component: Holds the source state and update logic\nfunction App() {\n  const [user, setUser] = useState({ name: 'John Doe', theme: 'dark' });\n\n  const handleUpdateUserTheme = (newTheme) => {\n    setUser(prevUser => ({ ...prevUser, theme: newTheme }));\n  };\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h1>Prop Drilling Demo</h1>\n      <p>App State User Theme: <strong>{user.theme}</strong></p>\n      {/* TODO: Pass props to ParentComponent */}\n      <ParentComponent user={user} onUpdateUserTheme={handleUpdateUserTheme} />\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { useState } from 'react';\n\n// Part 1: Simulate Prop Drilling\n\n// GrandchildComponent: Displays user info and has a button to update theme\nfunction GrandchildComponent({ user, onUpdateUserTheme }) {\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '15px', margin: '10px', backgroundColor: '#f9f9f9' }}>\n      <h3>Grandchild Component</h3>\n      <p>User Name: <strong>{user.name}</strong></p>\n      <p>Current Theme: <strong>{user.theme}</strong></p>\n      <button onClick={() => onUpdateUserTheme(user.theme === 'dark' ? 'light' : 'dark')}>\n        Toggle Theme\n      </button>\n    </div>\n  );\n}\n\n// ChildComponent: Passes props down\nfunction ChildComponent({ user, onUpdateUserTheme }) {\n  // This component doesn't use 'user' or 'onUpdateUserTheme' directly\n  return (\n    <div style={{ border: '1px dashed blue', padding: '10px', margin: '10px' }}>\n      <h4>Child Component (Intermediate)</h4>\n      <GrandchildComponent user={user} onUpdateUserTheme={onUpdateUserTheme} />\n    </div>\n  );\n}\n\n// ParentComponent: Passes props down\nfunction ParentComponent({ user, onUpdateUserTheme }) {\n  // This component doesn't use 'user' or 'onUpdateUserTheme' directly\n  return (\n    <div style={{ border: '1px solid green', padding: '10px', margin: '10px' }}>\n      <h3>Parent Component (Intermediate)</h3>\n      <ChildComponent user={user} onUpdateUserTheme={onUpdateUserTheme} />\n    </div>\n  );\n}\n\n// App Component: Holds the source state and update logic\nfunction App() {\n  const [user, setUser] = useState({ name: 'John Doe', theme: 'dark' });\n\n  const handleUpdateUserTheme = (newTheme) => {\n    setUser(prevUser => ({ ...prevUser, theme: newTheme }));\n  };\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h1>Prop Drilling Demo</h1>\n      <p>App State User Theme: <strong>{user.theme}</strong></p>\n      <ParentComponent user={user} onUpdateUserTheme={handleUpdateUserTheme} />\n    </div>\n  );\n}\n\nexport default App;\n\n/*\nPart 2: Conceptual Explanation of Redux Solution\n\nTo solve the prop drilling problem using Redux, the application structure would change as follows:\n\n1.  **Redux Store:** A single Redux store would be created to hold the global application state, including the `user` object.\n\n    ```javascript\n    // store.js\n    import { createStore } from 'redux';\n\n    const initialState = { user: { name: 'John Doe', theme: 'dark' } };\n\n    function userReducer(state = initialState, action) {\n      switch (action.type) {\n        case 'TOGGLE_THEME':\n          return { ...state, user: { ...state.user, theme: action.payload } };\n        default:\n          return state;\n      }\n    }\n\n    const store = createStore(userReducer);\n    export default store;\n    ```\n\n2.  **Provider:** The Redux store would be made available to the entire React component tree by wrapping the root `App` component (or a higher-level component) with a `Provider` from `react-redux`.\n\n    ```javascript\n    // index.js (or App.js)\n    import React from 'react';\n    import ReactDOM from 'react-dom';\n    import { Provider } from 'react-redux';\n    import store from './store';\n    import App from './App';\n\n    ReactDOM.render(\n      <Provider store={store}>\n        <App />\n      </Provider>,\n      document.getElementById('root')\n    );\n    ```\n\n3.  **Accessing State (useSelector):** The `GrandchildComponent` (or any other component needing the `user` state) would directly 'select' the `user` state from the Redux store using the `useSelector` hook, without needing props to be passed down through intermediate components.\n\n    ```javascript\n    // GrandchildComponent.js (Redux version)\n    import React from 'react';\n    import { useSelector, useDispatch } from 'react-redux';\n\n    function GrandchildComponent() {\n      const user = useSelector(state => state.user); // Directly select user from store\n      const dispatch = useDispatch();\n\n      const handleToggleTheme = () => {\n        const newTheme = user.theme === 'dark' ? 'light' : 'dark';\n        dispatch({ type: 'TOGGLE_THEME', payload: newTheme }); // Dispatch an action to update state\n      };\n\n      return (\n        <div style={{ border: '1px solid #ccc', padding: '15px', margin: '10px', backgroundColor: '#f9f9f9' }}>\n          <h3>Grandchild Component (Redux)</h3>\n          <p>User Name: <strong>{user.name}</strong></p>\n          <p>Current Theme: <strong>{user.theme}</strong></p>\n          <button onClick={handleToggleTheme}>\n            Toggle Theme\n          </button>\n        </div>\n      );\n    }\n    ```\n\n4.  **Updating State (useDispatch and Actions/Reducers):** To update the `theme`, the `GrandchildComponent` would `dispatch` an action (e.g., `TOGGLE_THEME`) to the Redux store. A `reducer` function defined in the Redux store would then process this action and return a new state, making the update predictable and centralized.\n\nWith Redux, the `ParentComponent` and `ChildComponent` in this example would become 'dumb' components, not needing to receive or pass down the `user` prop. They would simply render their children. This significantly reduces boilerplate and makes the application's data flow more explicit and easier to manage, especially in larger applications with complex state trees.\n*/\n",
          "testCases": [
            "**Part 1 (Coding):**\n1.  Initial render: The `GrandchildComponent` should display 'User Name: John Doe' and 'Current Theme: dark'.\n2.  Clicking 'Toggle Theme' button in `GrandchildComponent`: The displayed theme in `GrandchildComponent` should switch from 'dark' to 'light' and vice versa. The 'App State User Theme' in the `App` component should also update simultaneously.",
            "**Part 2 (Explanation):**\n1.  The explanation should clearly define the components of a Redux setup (store, provider, actions, reducers).\n2.  It should explicitly describe how `useSelector` replaces prop drilling for reading state.\n3.  It should explicitly describe how `useDispatch` and actions replace prop-drilled callbacks for updating state.\n4.  The explanation should highlight how intermediate components (`ParentComponent`, `ChildComponent`) would no longer need to pass down the state or the updater function."
          ],
          "hints": [
            "For Part 1, you just need to ensure `user` and `onUpdateUserTheme` are passed down correctly through all intermediate components.",
            "For Part 2, think about the three core principles of Redux: Single Source of Truth, State is Read-Only, and Changes with Pure Functions (Reducers).",
            "Consider the `react-redux` hooks: `useSelector` for reading state and `useDispatch` for dispatching actions.",
            "Illustrate the `action` structure and a simple `reducer` function that handles the theme toggle."
          ],
          "tags": [
            "Redux",
            "State Management",
            "Prop Drilling",
            "Architecture",
            "Hooks",
            "Conceptual"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "react_state",
            "react_props",
            "react_hooks"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "theory_redux_problem_solved"
          ]
        }
      ]
    }
  }
]