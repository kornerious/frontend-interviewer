[
  {
    "id": "a92d8f16-1886-485d-acf5-abdb71e84f43",
    "startLine": 5600,
    "endLine": 5699,
    "processedDate": "2025-06-17T09:42:32.826Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_state_forms",
          "title": "React State Management with useState and Form Handling",
          "content": "This section covers the fundamental `useState` hook in React for managing component-level state and its application in handling user input within forms.\n\n## useState Hook\n`useState` is a React Hook that lets you add state to functional components. It returns a stateful value and a function to update it. When the setter function is called, React re-renders the component.\n\n**Syntax:** `const [state, setState] = useState(initialState);`\n*   `state`: The current state value.\n*   `setState`: A function to update the state. It can be called with a new value or a function that receives the previous state and returns the new state (useful for complex updates or when new state depends on previous state).\n*   `initialState`: The initial value of the state. This can be a primitive (number, string, boolean) or an object/array. If `initialState` is a function, it will be executed only once during the initial render to compute the initial state, which is useful for expensive initializations.\n\n## Controlled Components in Forms\nIn React, form elements like `<input>`, `<textarea>`, and `<select>` maintain their own internal state. When you want React to be the 'single source of truth' for the form data, you create 'controlled components'.\n\nFor a controlled component:\n1.  The `value` attribute of the form element is tied to a state variable.\n2.  The `onChange` event handler updates this state variable whenever the input value changes.\n\nThis pattern ensures that the component's state and the displayed input value are always synchronized, allowing React to control the form data. This approach simplifies validation, conditional rendering, and dynamic changes to the form.\n\n## Event Handling in Forms\n\n*   `onChange`: This event fires whenever the value of a form input element is changed. It's crucial for controlled components to update the state.\n*   `onSubmit`: This event fires when a form is submitted. It's typically attached to the `<form>` element. The event object provides `event.preventDefault()` which is used to stop the browser's default behavior of reloading the page upon form submission, allowing React to handle the submission logic.\n",
          "examples": [
            {
              "id": "example_react_state_forms_1",
              "title": "Basic LoginForm Example",
              "code": "import React, { useState } from 'react';\n\nfunction LoginForm() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n\n  const handleUsernameChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setUsername(event.target.value);\n  };\n\n  const handlePasswordChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setPassword(event.target.value);\n  };\n\n  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    // In a real application, you would send these credentials to a server\n    console.log('Username:', username);\n    console.log('Password:', password);\n    alert(`Submitting: Username - ${username}, Password - ${password}`);\n    // Reset form or redirect\n    setUsername('');\n    setPassword('');\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"username\">Username:</label>\n        <input \n          id=\"username\"\n          type=\"text\" \n          value={username} \n          onChange={handleUsernameChange} \n        />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password:</label>\n        <input \n          id=\"password\"\n          type=\"password\" \n          value={password} \n          onChange={handlePasswordChange} \n        />\n      </div>\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n\nexport default LoginForm;\n",
              "explanation": "This example demonstrates a typical controlled `LoginForm` component. `useState` is used to manage the `username` and `password` inputs. Each input's `value` is bound to its respective state variable, and `onChange` handlers update the state whenever the input changes. The `handleSubmit` function prevents the default form submission behavior and logs the collected credentials, then clears the form.",
              "language": "typescript"
            },
            {
              "id": "example_react_state_forms_2",
              "title": "useState with Functional Update",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    // Using functional update is safer when new state depends on previous state\n    setCount(prevCount => prevCount + 1);\n  };\n\n  const incrementTwice = () => {\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n      <button onClick={incrementTwice}>Increment Twice (Safe)</button>\n    </div>\n  );\n}\n\nexport default Counter;\n",
              "explanation": "This example illustrates the use of a functional update for `setCount`. When `setCount` is called with a function, React ensures the `prevCount` argument is the most up-to-date state, preventing stale closure issues, especially when state updates are batched or queued, as seen in `incrementTwice`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_useState_1",
            "question_form_handling_1",
            "question_controlled_components_1",
            "question_useState_functional_update_1"
          ],
          "relatedTasks": [
            "task_user_registration_form",
            "task_dynamic_form_validation"
          ],
          "tags": [
            "React",
            "Hooks",
            "State Management",
            "Forms",
            "useState",
            "Controlled Components",
            "Event Handling"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript Basics",
            "HTML Forms"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Custom Hooks",
            "Context API",
            "Redux"
          ]
        },
        {
          "id": "theory_custom_hook_use_local_storage",
          "title": "Building Custom React Hooks: useLocalStorage",
          "content": "Custom Hooks are JavaScript functions whose names start with `use` and that can call other Hooks. They allow you to reuse stateful logic across different components without sharing actual state.\n\n## useLocalStorage Hook\nThe `useLocalStorage` hook provides a way to persist React component state to the browser's `localStorage`.\n\n### Key Concepts:\n*   **State Initialization:** The `useState` hook is initialized with a function `() => { ... }`. This functional initializer is executed only once during the initial render. It attempts to retrieve the stored value from `localStorage` using `window.localStorage.getItem(key)`. If a value is found, it's parsed from JSON; otherwise, the `initialValue` provided to the hook is used. This prevents re-reading `localStorage` on every re-render and ensures efficient initial state setup.\n*   **Persistence with `useEffect`:** The `useEffect` hook is used to synchronize the component's state with `localStorage`. Whenever the `storedValue` (the state managed by `useState`) or the `key` changes, the `useEffect` callback runs. Inside the callback, `window.localStorage.setItem(key, JSON.stringify(storedValue))` is called to save the current state to `localStorage`.\n*   **Dependency Array:** The `useEffect` hook includes `[key, storedValue]` in its dependency array. This ensures that the effect re-runs only when the `key` or the `storedValue` actually changes, preventing unnecessary `localStorage` writes and optimizing performance.\n*   **Error Handling:** Both the initial read from `localStorage` and the subsequent writes are wrapped in `try...catch` blocks. This is crucial because `localStorage` operations can fail (e.g., due to security restrictions, storage quota exceeded, or malformed JSON data), preventing the application from crashing.\n\n### Benefits of Custom Hooks:\n*   **Reusability:** Share logic across multiple components without prop drilling or render props.\n*   **Readability:** Encapsulate complex logic into a single, descriptive function.\n*   **Separation of Concerns:** Keep presentation logic separate from stateful logic.\n*   **Testability:** Custom hooks are easier to test in isolation.\n",
          "examples": [
            {
              "id": "example_use_local_storage_1",
              "title": "useLocalStorage Hook Implementation",
              "code": "import { useState, useEffect } from 'react';\n\n// Custom hook for persisting state to localStorage\nfunction useLocalStorage<T>(key: string, initialValue: T): [T, (value: T | ((prev: T) => T)) => void] {\n  // Get initial value from localStorage or use initialValue\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      if (typeof window === 'undefined') { // Server-side rendering check\n        return initialValue;\n      }\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(\"Error reading from localStorage:\", error);\n      return initialValue;\n    }\n  });\n  \n  // Update localStorage when state changes\n  useEffect(() => {\n    try {\n      if (typeof window !== 'undefined') { // Client-side check\n        window.localStorage.setItem(key, JSON.stringify(storedValue));\n      }\n    } catch (error) {\n      console.error(\"Error writing to localStorage:\", error);\n    }\n  }, [key, storedValue]); // Dependencies: re-run when key or storedValue changes\n  \n  return [storedValue, setStoredValue];\n}\n\n// Usage example:\n// function PersistentCounter() {\n//   const [count, setCount] = useLocalStorage('count', 0);\n  \n//   return (\n//     <div>\n//       <p>Count: {count}</p>\n//       <button onClick={() => setCount(count + 1)}>Increment</button>\n//       <button onClick={() => setCount(0)}>Reset</button>\n//     </div>\n//   );\n// }\n\nexport default useLocalStorage;\n",
              "explanation": "This is the core implementation of `useLocalStorage`. It correctly uses `useState` with a functional initializer for lazy initial state computation and `useEffect` with a dependency array to persist state changes. Crucially, it includes `typeof window === 'undefined'` checks for server-side rendering compatibility and comprehensive `try...catch` blocks for robust error handling during `localStorage` operations. Type parameters `<T>` are added for better TypeScript support.",
              "language": "typescript"
            },
            {
              "id": "example_use_local_storage_2",
              "title": "Persistent Counter Component using useLocalStorage",
              "code": "import React from 'react';\nimport useLocalStorage from './useLocalStorage'; // Assuming useLocalStorage is in a separate file\n\nfunction PersistentCounter() {\n  const [count, setCount] = useLocalStorage('app-counter', 0);\n  const [theme, setTheme] = useLocalStorage('app-theme', 'light');\n\n  const toggleTheme = () => {\n    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));\n  };\n  \n  return (\n    <div style={{ background: theme === 'dark' ? '#333' : '#fff', color: theme === 'dark' ? '#fff' : '#333', padding: '20px', borderRadius: '8px' }}>\n      <h2>Persistent Counter & Theme</h2>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <button onClick={() => setCount(prevCount => prevCount - 1)}>Decrement</button>\n      <button onClick={() => setCount(0)}>Reset Count</button>\n      \n      <p>Current Theme: {theme}</p>\n      <button onClick={toggleTheme}>Toggle Theme</button>\n    </div>\n  );\n}\n\nexport default PersistentCounter;\n",
              "explanation": "This component demonstrates the practical usage of the `useLocalStorage` hook. It maintains a `count` and a `theme` state, both of which are automatically persisted and loaded from `localStorage`. Changes to these states are immediately reflected in the UI and saved for future sessions, showcasing the reusability and power of custom hooks for managing persistent application settings.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_custom_hooks_1",
            "question_local_storage_limitations_1",
            "question_use_state_functional_initializer_1",
            "question_use_effect_dependencies_1",
            "question_custom_hook_error_handling_1"
          ],
          "relatedTasks": [
            "task_user_settings_panel",
            "task_persistent_todo_list"
          ],
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "useState",
            "useEffect",
            "LocalStorage",
            "State Persistence",
            "Web Storage"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "useState",
            "useEffect",
            "JavaScript ES6+",
            "Web Storage API"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced React Patterns",
            "State Management Libraries"
          ]
        },
        {
          "id": "theory_custom_hook_use_fetch",
          "title": "Building Custom React Hooks: useFetch and Data Fetching Patterns",
          "content": "This section delves into creating a custom hook for asynchronous data fetching, a common requirement in most modern web applications. It highlights key considerations like managing loading and error states, and handling component unmounting.\n\n## useFetch Hook\nThe `useFetch` hook encapsulates the logic for fetching data from a given URL, managing the `data`, `loading`, and `error` states.\n\n### Key Concepts:\n*   **State Management for Async Operations:** The hook uses three `useState` variables: `data` (for the fetched content), `loading` (to indicate if the fetch is in progress), and `error` (to store any error messages).\n*   **Side Effects with `useEffect`:** Data fetching is a side effect and is therefore performed inside a `useEffect` hook. This ensures that the fetch operation runs after the component renders and can be re-triggered based on dependencies.\n*   **Asynchronous Operations (`async/await` and `fetch` API):** The `fetchData` function is `async`, allowing the use of `await` for cleaner asynchronous code. The `fetch` API is used to make the network request. It returns a `Promise` that resolves to a `Response` object. The `response.json()` method is then used to parse the response body as JSON.\n*   **Error Handling:**\n    *   **HTTP Errors:** `response.ok` is checked to determine if the HTTP response status code indicates success (2xx range). If not, an `Error` is thrown with the status.\n    *   **Network/Parse Errors:** A `try...catch` block surrounds the `fetch` and JSON parsing operations to catch network errors, JSON parsing errors, or any other exceptions during the fetch process. The `error` state is updated accordingly.\n*   **Dependency Array:** The `useEffect` hook includes `[url, options]` in its dependency array. This means the `fetchData` function will be re-executed whenever the `url` or `options` (e.g., headers, method) passed to the hook change, allowing the hook to respond to dynamic data requirements.\n*   **Cleanup and `isMounted` Flag:**\n    *   **Problem:** A common issue in React when dealing with asynchronous operations is attempting to update the state of an unmounted component. This can lead to memory leaks and React warnings (`Can't perform a React state update on an unmounted component`).\n    *   **Solution (`isMounted` Flag):** A boolean variable `isMounted` is used within the `useEffect` scope. It is initialized to `true` and set to `false` in the `return` cleanup function of `useEffect`. Before calling `setData`, `setLoading`, or `setError`, the `isMounted` flag is checked. If the component has unmounted (`isMounted` is `false`), no state updates are performed.\n    *   This pattern ensures that state updates only occur if the component is still mounted, preventing potential issues.\n",
          "examples": [
            {
              "id": "example_use_fetch_1",
              "title": "useFetch Hook Implementation",
              "code": "import { useState, useEffect } from 'react';\n\ninterface FetchOptions extends RequestInit {}\n\ninterface FetchResult<T> {\n  data: T | null;\n  loading: boolean;\n  error: string | null;\n}\n\n// Custom hook for fetching data\nfunction useFetch<T>(url: string, options?: FetchOptions): FetchResult<T> {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n  \n  useEffect(() => {\n    let isMounted = true; // Flag to track if the component is mounted\n    setLoading(true); // Set loading to true at the start of fetch\n    setError(null); // Clear previous errors\n    \n    const fetchData = async () => {\n      try {\n        const response = await fetch(url, options); // Perform fetch request\n        if (!response.ok) { // Check for HTTP errors (e.g., 404, 500)\n          throw new Error(`HTTP error! Status: ${response.status} - ${response.statusText}`);\n        }\n        \n        const json: T = await response.json(); // Parse response as JSON\n        if (isMounted) { // Only update state if component is still mounted\n          setData(json);\n          setError(null);\n        }\n      } catch (e) {\n        const errorMessage = (e instanceof Error) ? e.message : String(e);\n        if (isMounted) { // Only update state if component is still mounted\n          setError(errorMessage);\n          setData(null);\n        }\n      } finally {\n        if (isMounted) { // Only update state if component is still mounted\n          setLoading(false);\n        }\n      }\n    };\n    \n    fetchData(); // Execute the fetch operation\n\n    // Cleanup function: runs when component unmounts or before effect re-runs\n    return () => {\n      isMounted = false;\n    };\n  }, [url, options]); // Dependencies: re-run when url or options change\n  \n  return { data, loading, error };\n}\n\n// Usage example:\n// interface Post {\n//   userId: number;\n//   id: number;\n//   title: string;\n//   body: string;\n// }\n\n// function PostViewer() {\n//   const { data: post, loading, error } = useFetch<Post>('https://jsonplaceholder.typicode.com/posts/1');\n\n//   if (loading) return <p>Loading post...</p>;\n//   if (error) return <p>Error: {error}</p>;\n//   if (!post) return <p>No post found.</p>;\n\n//   return (\n//     <div>\n//       <h2>{post.title}</h2>\n//       <p>{post.body}</p>\n//     </div>\n//   );\n// }\n\nexport default useFetch;\n",
              "explanation": "This comprehensive `useFetch` hook demonstrates how to manage different states (`data`, `loading`, `error`) during an asynchronous operation. It correctly uses `useEffect` for side effects, handles HTTP and network errors, and implements the `isMounted` flag as part of the effect's cleanup function to prevent updating state on unmounted components. TypeScript interfaces are added for better type safety.",
              "language": "typescript"
            },
            {
              "id": "example_use_fetch_2",
              "title": "Displaying Data with useFetch Component",
              "code": "import React from 'react';\nimport useFetch from './useFetch'; // Assuming useFetch is in a separate file\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nfunction UserList() {\n  const { data: users, loading, error } = useFetch<User[]>('https://jsonplaceholder.typicode.com/users');\n\n  if (loading) {\n    return <p>Loading users...</p>;\n  }\n\n  if (error) {\n    return <p style={{ color: 'red' }}>Error fetching users: {error}</p>;\n  }\n\n  if (!users || users.length === 0) {\n    return <p>No users found.</p>;\n  }\n\n  return (\n    <div>\n      <h1>Users</h1>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>\n            <strong>{user.name}</strong> ({user.email})\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default UserList;\n",
              "explanation": "This component showcases how to consume the `useFetch` hook to display a list of users. It gracefully handles the `loading` and `error` states by displaying appropriate messages to the user. Once data is successfully fetched, it maps over the `users` array and renders them in a list, illustrating a common pattern for displaying API data in React applications.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_use_fetch_states_1",
            "question_is_mounted_pattern_1",
            "question_fetch_api_error_handling_1",
            "question_use_effect_cleanup_1",
            "question_custom_hooks_data_fetching_1"
          ],
          "relatedTasks": [
            "task_fetch_display_posts",
            "task_searchable_api_data",
            "task_pagination_with_use_fetch"
          ],
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "useEffect",
            "useState",
            "Data Fetching",
            "Fetch API",
            "Async/Await",
            "Error Handling",
            "Cleanup",
            "Memory Leaks"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "useState",
            "useEffect",
            "JavaScript Async/Await",
            "Fetch API"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "Building Complex UIs",
            "Performance Optimization",
            "State Management in Large Apps"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_useState_1",
          "topic": "React useState Hook",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of the `useState` hook in React functional components?",
          "answer": "To add state to functional components.",
          "options": [
            "To perform side effects like data fetching.",
            "To manage component lifecycle methods.",
            "To add state to functional components.",
            "To provide a context for deeply nested components."
          ],
          "analysisPoints": [
            "`useState` is specifically designed for managing mutable state within functional components.",
            "Side effects are managed by `useEffect`.",
            "Lifecycle methods are a concept from class components, replaced by hooks in functional components.",
            "Context is managed by `useContext`."
          ],
          "keyConcepts": [
            "useState",
            "Functional Components",
            "State Management"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental React hooks",
            "Ability to distinguish hook purposes"
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction ExampleComponent() {\n  const [count, setCount] = useState(0); // Here, useState adds state.\n  return <p>Count: {count}</p>;\n}\n```",
          "tags": [
            "React",
            "useState",
            "Hooks",
            "Fundamentals"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_form_handling_1",
          "topic": "React Form Handling (Controlled Components)",
          "level": "medium",
          "type": "open",
          "question": "Explain the concept of 'controlled components' in React forms and why `event.preventDefault()` is typically used with form submissions.",
          "answer": "A 'controlled component' in React forms is an input element (like `<input>`, `<textarea>`, `<select>`) whose value is controlled by React state. The input's `value` attribute is bound to a state variable, and its `onChange` event handler updates that state. This makes React the single source of truth for the input's data, allowing for easy validation, manipulation, and conditional rendering of form data.\n\n`event.preventDefault()` is used with form submissions to stop the browser's default behavior, which is to reload the page when a form is submitted. In a Single Page Application (SPA) built with React, we want to handle the form data with JavaScript without a full page refresh. `event.preventDefault()` allows React to take full control of the submission process, enabling AJAX requests, local state updates, or client-side routing without disrupting the user's experience.",
          "analysisPoints": [
            "Definition of controlled component (state controls value, `onChange` updates state).",
            "Benefits of controlled components (validation, single source of truth).",
            "Purpose of `event.preventDefault()` (stop default browser refresh).",
            "Context of `event.preventDefault()` in SPAs."
          ],
          "keyConcepts": [
            "Controlled Components",
            "Forms",
            "Event Handling",
            "event.preventDefault()",
            "React State"
          ],
          "evaluationCriteria": [
            "Understanding of React form patterns",
            "Knowledge of browser default behaviors",
            "Ability to explain common React practices"
          ],
          "example": "See `LoginForm` example in theory `theory_react_state_forms` for practical implementation.",
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "Event Handling"
          ],
          "prerequisites": [
            "React Basics",
            "JavaScript Event Loop"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_useState_functional_update_1",
          "topic": "useState Functional Update",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React component:\n\n```typescript\nimport React, { useState } from 'react';\n\nfunction MultiClickCounter() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    setCount(count + 1);\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Click Me</button>\n    </div>\n  );\n}\n```\nIf the user clicks the 'Click Me' button once, what will be the final value of `count` displayed?",
          "answer": "1",
          "options": [
            "0",
            "1",
            "2",
            "It depends on React's batching behavior."
          ],
          "analysisPoints": [
            "React batches state updates within the same event loop for performance.",
            "When `setCount(count + 1)` is called twice with a direct value, both calls use the `count` value from the *beginning* of the render/event cycle.",
            "If `count` was 0, both `setCount(0 + 1)` calls effectively try to set `count` to 1.",
            "The second call overwrites the first within the same batch, resulting in a final `count` of 1.",
            "To get 2, one would need to use the functional update form: `setCount(prevCount => prevCount + 1);`"
          ],
          "keyConcepts": [
            "useState",
            "Functional Update",
            "State Batching",
            "Stale Closures"
          ],
          "evaluationCriteria": [
            "Understanding of `useState` behavior",
            "Knowledge of React's state update mechanisms",
            "Ability to identify potential pitfalls"
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction MultiClickCounterFixed() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    // Using functional updates ensures the latest state is used\n    setCount(prevCount => prevCount + 1);\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Click Me (Fixed)</button>\n    </div>\n  );\n}\n// In this fixed version, clicking once would result in count: 2.\n```",
          "tags": [
            "React",
            "useState",
            "Hooks",
            "Advanced",
            "Performance"
          ],
          "prerequisites": [
            "React Basics",
            "useState"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_custom_hooks_1",
          "topic": "Custom Hooks",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using custom hooks in React?",
          "answer": "Reusing stateful logic across multiple components.",
          "analysisPoints": [
            "Custom hooks allow developers to extract and share stateful logic, like managing component state or side effects, without resorting to prop drilling or render props patterns.",
            "They promote code organization, readability, and testability."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "Code Reusability",
            "Stateful Logic"
          ],
          "evaluationCriteria": [
            "Basic understanding of custom hook purpose"
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "Fundamentals"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_local_storage_limitations_1",
          "topic": "localStorage Limitations",
          "level": "medium",
          "type": "open",
          "question": "What are some limitations or potential issues when using `localStorage` for persisting application state in a React application?",
          "answer": "While `localStorage` is useful for simple state persistence, it has several limitations:\n\n1.  **Synchronous Nature:** `localStorage` operations are synchronous, meaning they block the main thread. Frequent or large reads/writes can lead to performance issues and a janky UI, especially on low-power devices.\n2.  **String-only Storage:** `localStorage` can only store strings. Objects and arrays must be serialized to JSON (`JSON.stringify()`) before saving and deserialized (`JSON.parse()`) when retrieved, adding overhead and potential for parsing errors.\n3.  **Limited Storage Capacity:** Typically, `localStorage` has a limit of around 5-10 MB per origin, which is sufficient for small data but insufficient for large datasets or media.\n4.  **Security Concerns:** Data stored in `localStorage` is accessible via JavaScript (XSS attacks) and is not encrypted. Sensitive information like user credentials should never be stored here. It's also domain-specific, meaning `http://example.com` cannot access data stored by `https://example.com`.\n5.  **No Type Support:** Values retrieved from `localStorage` are always strings, requiring manual type conversion back to numbers, booleans, etc.\n6.  **No Expiration:** Data stored in `localStorage` persists indefinitely until explicitly cleared by the user or script, or by the browser. There's no built-in mechanism for setting an expiration time.\n7.  **Client-Side Only:** `localStorage` is a browser API, meaning it's not available during server-side rendering (SSR), which requires careful handling (e.g., `typeof window !== 'undefined'` checks in hooks like `useLocalStorage`).",
          "analysisPoints": [
            "Synchronous I/O.",
            "String-only storage, requiring serialization/deserialization.",
            "Storage capacity limits.",
            "Security risks (XSS, no encryption).",
            "Lack of built-in expiration.",
            "Client-side only nature (SSR incompatibility)."
          ],
          "keyConcepts": [
            "localStorage",
            "Web Storage API",
            "Limitations",
            "Security",
            "Performance",
            "SSR"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of `localStorage` caveats",
            "Awareness of practical implications for React apps"
          ],
          "example": "```typescript\n// Example of the synchronous nature and string-only storage\ntry {\n  localStorage.setItem('myLargeKey', JSON.stringify({ data: Array(100000).fill('some_data') })); // Can block UI\n  const item = localStorage.getItem('myLargeKey');\n  const parsed = JSON.parse(item); // Needs parsing\n} catch (error) {\n  console.error('LocalStorage error:', error); // Catches quota exceeded or parse errors\n}\n```",
          "tags": [
            "Web Storage",
            "localStorage",
            "Performance",
            "Security",
            "Frontend Architecture"
          ],
          "prerequisites": [
            "JavaScript Basics",
            "Web APIs"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_state_functional_initializer_1",
          "topic": "useState Initializer Function",
          "level": "medium",
          "type": "mcq",
          "question": "Why is it recommended to pass a function to `useState` for its `initialState` argument when the initial state calculation is expensive?",
          "answer": "To ensure the initialization logic runs only once during the initial render.",
          "options": [
            "To enable asynchronous state updates.",
            "To ensure the initialization logic runs only once during the initial render.",
            "To make the state immutable.",
            "To automatically recompute the initial state on every re-render."
          ],
          "analysisPoints": [
            "When `useState` receives a function as `initialState`, React calls that function *only once* during the very first render of the component.",
            "If `initialState` is a direct value (e.g., `useState(someExpensiveCalculation())`), `someExpensiveCalculation()` would run on *every* re-render, even though its result is only used for the initial render, leading to unnecessary computations.",
            "This optimization is crucial for performance when the initial state derivation involves heavy computation, like parsing a large JSON string from `localStorage` or fetching data."
          ],
          "keyConcepts": [
            "useState",
            "Initial State",
            "Functional Initializer",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Understanding of `useState` initialization patterns",
            "Knowledge of performance best practices"
          ],
          "example": "```typescript\nimport { useState } from 'react';\n\nfunction MyComponent() {\n  // Expensive calculation that should only run once\n  const getInitialValue = () => {\n    console.log('Calculating initial value...');\n    return JSON.parse(localStorage.getItem('mySetting') || '\"default\"');\n  };\n\n  // Correct usage: function is passed, executed once\n  const [setting, setSetting] = useState(getInitialValue);\n\n  // Incorrect usage: function is called directly, executes on every re-render\n  // const [setting, setSetting] = useState(getInitialValue());\n\n  return <div>Setting: {setting}</div>;\n}\n```",
          "tags": [
            "React",
            "useState",
            "Performance",
            "Optimization"
          ],
          "prerequisites": [
            "React Basics",
            "useState"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_effect_dependencies_1",
          "topic": "useEffect Dependency Array",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `useEffect` hook:\n\n```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction Timer() {\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setSeconds(seconds + 1);\n    }, 1000);\n\n    return () => clearInterval(intervalId);\n  }, []); // Dependency array\n\n  return <p>Seconds: {seconds}</p>;\n}\n```\n\nWhat is the expected behavior of this `Timer` component when rendered?",
          "answer": "The timer will increment to 1 and then stop, as `seconds` is captured at its initial value.",
          "options": [
            "The timer will increment correctly every second (0, 1, 2, 3...).",
            "The timer will increment to 1 and then stop, as `seconds` is captured at its initial value.",
            "The component will re-render infinitely due to `useEffect` loop.",
            "An error will occur because `seconds` is not in the dependency array."
          ],
          "analysisPoints": [
            "The `useEffect` hook has an empty dependency array `[]`, meaning the effect runs only once after the initial render.",
            "When `setInterval` is set up, `seconds` is captured in the closure with its initial value (0).",
            "Therefore, `setSeconds(seconds + 1)` effectively becomes `setSeconds(0 + 1)`, repeatedly setting `seconds` to 1.",
            "This is a common 'stale closure' problem when `useEffect` dependencies are incorrect.",
            "To fix this, `setSeconds(prevSeconds => prevSeconds + 1)` should be used, or `seconds` should be included in the dependency array (though the functional update is generally preferred for timers)."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Stale Closures",
            "Closures",
            "setInterval"
          ],
          "evaluationCriteria": [
            "Deep understanding of `useEffect` dependencies and closures",
            "Ability to diagnose common React hook issues"
          ],
          "example": "```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction TimerFixed() {\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      // Using functional update to avoid stale closure\n      setSeconds(prevSeconds => prevSeconds + 1);\n    }, 1000);\n\n    return () => clearInterval(intervalId);\n  }, []); // Still empty dependency array, as functional update doesn't depend on 'seconds'\n\n  return <p>Seconds: {seconds}</p>;\n}\n```",
          "tags": [
            "React",
            "useEffect",
            "Hooks",
            "Bugs",
            "Performance",
            "Intermediate"
          ],
          "prerequisites": [
            "React Hooks",
            "JavaScript Closures"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_custom_hook_error_handling_1",
          "topic": "Custom Hook Error Handling",
          "level": "medium",
          "type": "open",
          "question": "Why is it important to include `try...catch` blocks within a custom hook like `useLocalStorage` or `useFetch`, and what kinds of errors are you typically trying to catch?",
          "answer": "It is crucial to include `try...catch` blocks within custom hooks like `useLocalStorage` or `useFetch` to handle potential runtime errors gracefully, preventing the application from crashing and providing a better user experience.\n\nFor `useLocalStorage`, `try...catch` is important for:\n*   **`localStorage` access errors:** Browsers might block `localStorage` access in certain sandboxed environments (e.g., cross-origin iframes, private browsing mode with strict settings) or if the storage quota is exceeded. Attempting to `getItem` or `setItem` in such scenarios can throw a `SecurityError` or `QuotaExceededError`.\n*   **`JSON.parse()` errors:** If data stored in `localStorage` is corrupted or not valid JSON (e.g., manually edited, or an error during `JSON.stringify` on save), `JSON.parse()` will throw a `SyntaxError`.\n\nFor `useFetch`, `try...catch` is important for:\n*   **Network errors:** `fetch` promises will reject with a `TypeError` for network-related issues (e.g., no internet connection, DNS lookup failure, CORS issues, request timeout). These are errors that prevent the request from completing.\n*   **HTTP errors (non-2xx responses):** While `fetch` itself doesn't reject for HTTP status codes like 404 or 500, the `response.ok` property will be `false`. It's good practice to `throw new Error()` explicitly in this case within the `try` block, so the `catch` block can handle it consistently.\n*   **JSON parsing errors:** If the server response is not valid JSON, `response.json()` will throw an error.\n\nBy catching these errors, the hook can set an `error` state, display a fallback UI, or log the issue, instead of causing the entire application to fail.",
          "analysisPoints": [
            "Importance of `try...catch` for robustness.",
            "Specific error types for `useLocalStorage` (security, quota, JSON parsing).",
            "Specific error types for `useFetch` (network, HTTP non-2xx, JSON parsing).",
            "Benefits of error handling (graceful degradation, UX, debugging)."
          ],
          "keyConcepts": [
            "Error Handling",
            "Custom Hooks",
            "useLocalStorage",
            "useFetch",
            "try...catch",
            "Network Errors",
            "HTTP Status Codes",
            "JSON Parsing"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of error types in web development",
            "Ability to apply robust coding practices"
          ],
          "example": "See `useLocalStorage` and `useFetch` theory blocks for `try...catch` implementations.",
          "tags": [
            "Error Handling",
            "React",
            "Hooks",
            "Best Practices",
            "Robustness"
          ],
          "prerequisites": [
            "JavaScript Error Handling",
            "Web APIs"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_fetch_states_1",
          "topic": "useFetch Hook State Management",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the three main state variables typically managed by a `useFetch` custom hook?",
          "answer": "`data`, `loading`, and `error`.",
          "analysisPoints": [
            "These three states cover the complete lifecycle of an asynchronous data fetching operation: the result, the status of the operation, and any issues encountered."
          ],
          "keyConcepts": [
            "useFetch",
            "State Management",
            "Data Fetching",
            "Loading State",
            "Error State"
          ],
          "evaluationCriteria": [
            "Basic recall of `useFetch` pattern"
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "Data Fetching"
          ],
          "prerequisites": [
            "React Hooks"
          ],
          "complexity": 2,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_is_mounted_pattern_1",
          "topic": "useEffect Cleanup and isMounted Flag",
          "level": "hard",
          "type": "mcq",
          "question": "In a `useFetch` hook, why is the `isMounted` flag used, and what problem does it solve?\n\n```typescript\n// Inside useFetch useEffect\nuseEffect(() => {\n  let isMounted = true;\n  // ... async fetchData ...\n  if (isMounted) {\n    setData(json);\n    setLoading(false);\n  }\n  return () => {\n    isMounted = false;\n  };\n}, [url]);\n```",
          "answer": "It prevents state updates on an unmounted component, which can lead to memory leaks and React warnings.",
          "options": [
            "It optimizes network requests by canceling them if the component unmounts.",
            "It ensures data is always fetched from the server and not from cache.",
            "It prevents state updates on an unmounted component, which can lead to memory leaks and React warnings.",
            "It controls how many times the `fetchData` function is executed."
          ],
          "analysisPoints": [
            "The `isMounted` flag addresses a common issue where an asynchronous operation (like `fetch`) completes *after* the component that initiated it has unmounted.",
            "Attempting to call `setState` on an unmounted component is a memory leak (the state update is queued but never applied) and causes React to issue a warning.",
            "By setting `isMounted = false` in the `useEffect` cleanup function (which runs when the component unmounts or before the effect re-runs), subsequent state updates are conditionally skipped if the component is no longer in the DOM.",
            "It does *not* cancel the network request itself, only prevents state updates. Cancelling requests would require `AbortController`."
          ],
          "keyConcepts": [
            "useEffect",
            "Cleanup Function",
            "Memory Leaks",
            "Component Lifecycle",
            "isMounted Pattern",
            "Asynchronous Operations"
          ],
          "evaluationCriteria": [
            "Deep understanding of React `useEffect` lifecycle",
            "Ability to identify and solve memory leak issues",
            "Knowledge of best practices for async operations in React"
          ],
          "example": "See `useFetch` theory block for full implementation.",
          "tags": [
            "React",
            "useEffect",
            "Hooks",
            "Memory Leaks",
            "Performance",
            "Advanced"
          ],
          "prerequisites": [
            "React Hooks",
            "JavaScript Closures",
            "Asynchronous JavaScript"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_fetch_api_error_handling_1",
          "topic": "Fetch API Error Handling",
          "level": "medium",
          "type": "open",
          "question": "When using the Fetch API, why is it necessary to explicitly check `response.ok` even if the `fetch` call itself doesn't throw an error, and how would you typically handle different types of errors (network vs. HTTP) in a `useFetch` hook?",
          "answer": "The Fetch API's `fetch()` method only throws an error (rejects its promise) for network errors (e.g., no internet connection, DNS error, CORS issues, or a malformed request that prevents it from even being sent). It *does not* reject for HTTP error status codes (like 404 Not Found, 500 Internal Server Error, 401 Unauthorized), which are still successful network responses from the server, just with an error status. For these HTTP errors, `response.ok` will be `false`.\n\nTherefore, it's necessary to explicitly check `response.ok` (which is `true` for 2xx status codes) to handle server-side errors that result in a non-2xx status code. If `response.ok` is `false`, you should manually `throw new Error()` to propagate the error into your `catch` block.\n\n**Handling different error types in `useFetch`:**\n\n1.  **Network Errors:** These are caught by the `try...catch` block surrounding the `fetch` call. The `catch` block receives the `TypeError` directly. The hook would then update its `error` state with a message like 'Network error' or the `error.message`.\n\n    ```typescript\n    try {\n      const response = await fetch(url, options);\n      // ... check response.ok and parse json\n    } catch (e) {\n      // This 'catch' handles network errors or errors from response.json()\n      setError(e.message || 'Network error occurred');\n      setData(null);\n    }\n    ```\n\n2.  **HTTP Errors (non-2xx):** After the `fetch` call, check `response.ok`. If `false`, throw a custom error to be caught by the same `try...catch` block. This allows centralized error handling.\n\n    ```typescript\n    const response = await fetch(url, options);\n    if (!response.ok) {\n      // Manually throw for HTTP error statuses\n      throw new Error(`HTTP error! Status: ${response.status} - ${response.statusText}`);\n    }\n    const json = await response.json();\n    ```\n\nThis pattern allows a single `catch` block to handle both network-level failures and application-level (HTTP status) failures originating from the server, providing a consistent error handling mechanism within the hook.",
          "analysisPoints": [
            "Difference in `fetch` promise rejection behavior for network vs. HTTP errors.",
            "Importance of `response.ok` check.",
            "How to unify error handling with `try...catch` and manual `throw`.",
            "Specific examples of error messages for each type."
          ],
          "keyConcepts": [
            "Fetch API",
            "Error Handling",
            "HTTP Status Codes",
            "Network Errors",
            "try...catch",
            "useFetch"
          ],
          "evaluationCriteria": [
            "Detailed understanding of Fetch API nuances",
            "Ability to implement robust error handling strategies"
          ],
          "example": "See `useFetch` theory block for full implementation.",
          "tags": [
            "Fetch API",
            "JavaScript",
            "Asynchronous",
            "Error Handling",
            "HTTP"
          ],
          "prerequisites": [
            "JavaScript Async/Await",
            "Fetch API"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_custom_hooks_data_fetching_1",
          "topic": "Custom Hooks for Data Fetching",
          "level": "hard",
          "type": "code",
          "question": "Implement a simplified version of `useFetch` that supports fetching data and exposing `data`, `loading`, and `error` states. It should take a URL and an optional `options` object. Ensure proper cleanup to prevent setting state on an unmounted component. You do not need to implement full TypeScript interfaces, simple `any` or no types are fine for this task.",
          "answer": "```javascript\nimport { useState, useEffect } from 'react';\n\nfunction useFetch(url, options) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    let isMounted = true; // Flag to prevent state updates on unmounted component\n    setLoading(true); // Always set loading to true when starting a fetch\n    setError(null);   // Clear any previous errors\n    setData(null);    // Clear previous data\n\n    const fetchData = async () => {\n      try {\n        const response = await fetch(url, options);\n        if (!response.ok) {\n          throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        \n        const json = await response.json();\n        if (isMounted) {\n          setData(json);\n        }\n      } catch (err) {\n        if (isMounted) {\n          setError(err.message);\n        }\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n    \n    fetchData();\n\n    // Cleanup function: set isMounted to false when component unmounts\n    return () => {\n      isMounted = false;\n    };\n  }, [url, options]); // Re-run effect if url or options change\n  \n  return { data, loading, error };\n}\n\n// Example Usage:\n/*\nfunction MyComponent() {\n  const { data, loading, error } = useFetch('https://jsonplaceholder.typicode.com/todos/1');\n\n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error: {error}</p>;\n\n  return (\n    <div>\n      <h1>Todo: {data?.title}</h1>\n      <p>Completed: {data?.completed ? 'Yes' : 'No'}</p>\n    </div>\n  );\n}\n*/\n```",
          "analysisPoints": [
            "Correct use of `useState` for `data`, `loading`, `error`.",
            "Correct use of `useEffect` to initiate fetching.",
            "Proper use of `async/await` with `fetch`.",
            "Handling `response.ok` for HTTP errors.",
            "Implementing `try...catch` for network and parsing errors.",
            "Correct implementation of the `isMounted` flag for cleanup to prevent memory leaks/warnings.",
            "Correct dependency array for `useEffect`."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "useEffect",
            "useState",
            "Data Fetching",
            "Fetch API",
            "Async/Await",
            "Error Handling",
            "Cleanup"
          ],
          "evaluationCriteria": [
            "Ability to create a custom hook",
            "Understanding of asynchronous patterns in React",
            "Correct use of `useEffect` cleanup"
          ],
          "example": "The provided code serves as the solution example.",
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "Data Fetching",
            "Coding Challenge"
          ],
          "prerequisites": [
            "React Hooks",
            "JavaScript Async/Await",
            "Fetch API"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_custom_hook_vs_hoc_rp_1",
          "topic": "Custom Hooks vs. HOCs/Render Props",
          "level": "hard",
          "type": "open",
          "question": "How do custom React hooks (`use...`) compare to Higher-Order Components (HOCs) and Render Props in terms of reusing stateful logic? Discuss their advantages and disadvantages.",
          "answer": "All three patterns (Custom Hooks, HOCs, Render Props) aim to reuse stateful logic in React. However, custom hooks generally offer a simpler and more intuitive approach.\n\n**1. Custom Hooks (`use...` functions):**\n*   **Concept:** Plain JavaScript functions that allow you to encapsulate and reuse stateful logic (e.g., `useState`, `useEffect`) directly within functional components.\n*   **Advantages:**\n    *   **Simplicity & Readability:** No wrapper components or deeply nested JSX. The logic is directly integrated into the component where it's needed.\n    *   **No Component Tree Changes:** They don't introduce extra layers into the component tree, avoiding issues like wrapper hell or prop collision.\n    *   **Flexible:** Can return any type of data (values, functions, objects) and can be combined easily.\n    *   **Easier Debugging:** Clearer flow of data compared to HOCs.\n*   **Disadvantages:**\n    *   **Rules of Hooks:** Must follow specific rules (call only at top level, only from React functions).\n    *   **Limited for UI Rendering:** Primarily for logic, not for injecting JSX or layout directly (though the logic they provide can drive UI).\n\n**2. Higher-Order Components (HOCs):**\n*   **Concept:** A function that takes a component as an argument and returns a new component with enhanced props or behavior.\n    ```javascript\n    const withAuth = (WrappedComponent) => {\n      return (props) => { /* logic */ return <WrappedComponent {...props} /> };\n    };\n    ```\n*   **Advantages:**\n    *   **Legacy Support:** Well-established pattern before hooks.\n    *   **Inject Props:** Can easily inject additional props into the wrapped component.\n*   **Disadvantages:**\n    *   **Wrapper Hell:** Can lead to a deeply nested component tree, making debugging harder.\n    *   **Name Collisions:** Can cause prop name clashes if the injected props have the same name as existing props.\n    *   **Implicit Props:** Props added by the HOC are not immediately visible in the component's signature, making it harder to understand what props a component expects.\n    *   **Non-standard Composition:** Not a standard React pattern, can feel less intuitive.\n\n**3. Render Props:**\n*   **Concept:** A pattern where a component takes a function as a prop, and that function (the 'render prop') is responsible for rendering the component's children, often with shared state or logic.\n    ```javascript\n    <DataSource render={({ data }) => <MyComponent data={data} />} />\n    ```\n*   **Advantages:**\n    *   **Explicit Data Flow:** Very clear about what data is being shared.\n    *   **Avoids Name Collisions:** No risk of prop name clashes.\n*   **Disadvantages:**\n    *   **Nested JSX:** Can lead to deeply nested JSX, making the render method harder to read (similar to callback hell).\n    *   **Performance:** Can sometimes lead to unnecessary re-renders if the render prop function is defined inline in the `render` method.\n\n**Conclusion:**\nCustom Hooks are generally preferred for reusing stateful logic due to their simplicity, flexibility, and the way they align with functional component paradigms. They solve many of the problems associated with HOCs (wrapper hell, prop collisions) and Render Props (nested JSX) while providing a cleaner API for logic reuse. HOCs and Render Props still have their use cases but are less common for general-purpose logic sharing since the introduction of Hooks.",
          "analysisPoints": [
            "Define each pattern (Custom Hooks, HOCs, Render Props).",
            "List specific advantages of Custom Hooks (simplicity, no wrapper hell, flexible).",
            "List specific disadvantages of Custom Hooks (Rules of Hooks).",
            "List specific advantages of HOCs (legacy).",
            "List specific disadvantages of HOCs (wrapper hell, prop collisions, implicit props).",
            "List specific advantages of Render Props (explicit data flow).",
            "List specific disadvantages of Render Props (nested JSX, performance).",
            "Provide a clear concluding statement on preference and why."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "HOCs",
            "Render Props",
            "Code Reusability",
            "Stateful Logic",
            "React Patterns",
            "Component Composition"
          ],
          "evaluationCriteria": [
            "Comprehensive knowledge of React's advanced patterns",
            "Ability to compare and contrast architectural choices",
            "Understanding of their respective trade-offs"
          ],
          "example": "See text for code examples of each pattern.",
          "tags": [
            "React",
            "Architecture",
            "Design Patterns",
            "Hooks",
            "HOC",
            "Render Props"
          ],
          "prerequisites": [
            "Advanced React",
            "Component Lifecycle"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "expert"
        }
      ],
      "tasks": [
        {
          "id": "task_user_registration_form",
          "title": "Build a Controlled User Registration Form with Validation",
          "description": "\nCreate a React component `RegistrationForm` that allows a user to register with a username, email, and password. This form should:\n\n1.  Be a **controlled component**, managing input values using `useState` hooks.\n2.  Implement **client-side validation** for the following rules:\n    *   **Username:** Must be at least 3 characters long.\n    *   **Email:** Must be a valid email format (e.g., contains '@' and '.').\n    *   **Password:** Must be at least 6 characters long and contain at least one uppercase letter, one lowercase letter, and one number.\n    *   All fields are **required**.\n3.  Display **real-time error messages** below each input field if validation fails.\n4.  The submit button should be **disabled** if any field is invalid or empty.\n5.  On successful submission, log the form data to the console and display a success message. Prevent default form submission behavior.\n\nYour solution should demonstrate understanding of basic state management, controlled components, and event handling in React.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\nfunction RegistrationForm() {\n  const [username, setUsername] = useState('');\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n\n  // State for errors\n  const [usernameError, setUsernameError] = useState('');\n  const [emailError, setEmailError] = useState('');\n  const [passwordError, setPasswordError] = useState('');\n\n  // Handlers for input changes\n  const handleUsernameChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setUsername(e.target.value);\n    // TODO: Add validation logic here or in a separate validate function\n  };\n\n  const handleEmailChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setEmail(e.target.value);\n    // TODO: Add validation logic\n  };\n\n  const handlePasswordChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setPassword(e.target.value);\n    // TODO: Add validation logic\n  };\n\n  // TODO: Add a general validation function that checks all fields\n  const validateForm = () => {\n    let isValid = true;\n    // Example: username validation\n    if (username.length < 3) {\n      setUsernameError('Username must be at least 3 characters.');\n      isValid = false;\n    } else {\n      setUsernameError('');\n    }\n\n    // TODO: Implement email and password validation\n    \n    return isValid;\n  };\n\n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    if (validateForm()) {\n      console.log('Form Submitted:', { username, email, password });\n      alert('Registration successful!');\n      // Reset form\n      setUsername('');\n      setEmail('');\n      setPassword('');\n    } else {\n      console.log('Form has errors.');\n    }\n  };\n\n  // Determine if submit button should be disabled\n  const isFormValid = username && email && password && !usernameError && !emailError && !passwordError;\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '15px', maxWidth: '400px', margin: 'auto', padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <h2>Register</h2>\n      <div>\n        <label htmlFor=\"reg-username\">Username:</label>\n        <input \n          type=\"text\" \n          id=\"reg-username\"\n          value={username} \n          onChange={handleUsernameChange} \n        />\n        {usernameError && <p style={{ color: 'red', fontSize: '0.8em' }}>{usernameError}</p>}\n      </div>\n      <div>\n        <label htmlFor=\"reg-email\">Email:</label>\n        <input \n          type=\"email\" \n          id=\"reg-email\"\n          value={email} \n          onChange={handleEmailChange} \n        />\n        {emailError && <p style={{ color: 'red', fontSize: '0.8em' }}>{emailError}</p>}\n      </div>\n      <div>\n        <label htmlFor=\"reg-password\">Password:</label>\n        <input \n          type=\"password\" \n          id=\"reg-password\"\n          value={password} \n          onChange={handlePasswordChange} \n        />\n        {passwordError && <p style={{ color: 'red', fontSize: '0.8em' }}>{passwordError}</p>}\n      </div>\n      <button type=\"submit\" disabled={!isFormValid}>Register</button>\n    </form>\n  );\n}\n\nexport default RegistrationForm;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction RegistrationForm() {\n  const [username, setUsername] = useState('');\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n\n  const [usernameError, setUsernameError] = useState('');\n  const [emailError, setEmailError] = useState('');\n  const [passwordError, setPasswordError] = useState('');\n\n  // Effect to validate username whenever it changes\n  useEffect(() => {\n    if (username.length > 0 && username.length < 3) {\n      setUsernameError('Username must be at least 3 characters.');\n    } else {\n      setUsernameError('');\n    }\n  }, [username]);\n\n  // Effect to validate email whenever it changes\n  useEffect(() => {\n    const emailRegex = /^[\\w-.]+@([\\w-]+\\.)+[\\w-]{2,4}$/;\n    if (email.length > 0 && !emailRegex.test(email)) {\n      setEmailError('Please enter a valid email address.');\n    } else {\n      setEmailError('');\n    }\n  }, [email]);\n\n  // Effect to validate password whenever it changes\n  useEffect(() => {\n    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{6,}$/;\n    if (password.length > 0 && !passwordRegex.test(password)) {\n      setPasswordError('Password must be at least 6 characters, contain one uppercase, one lowercase, and one number.');\n    } else {\n      setPasswordError('');\n    }\n  }, [password]);\n\n  const validateAllFields = () => {\n    let isValid = true;\n\n    if (username.length < 3) { setUsernameError('Username must be at least 3 characters.'); isValid = false; }\n    else { setUsernameError(''); }\n\n    const emailRegex = /^[\\w-.]+@([\\w-]+\\.)+[\\w-]{2,4}$/;\n    if (!emailRegex.test(email)) { setEmailError('Please enter a valid email address.'); isValid = false; }\n    else { setEmailError(''); }\n\n    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{6,}$/;\n    if (!passwordRegex.test(password)) { setPasswordError('Password must be at least 6 characters, contain one uppercase, one lowercase, and one number.'); isValid = false; }\n    else { setPasswordError(''); }\n\n    return isValid;\n  };\n\n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    // Validate all fields on submit, in case user didn't trigger all 'onChange' validations\n    if (validateAllFields()) {\n      console.log('Form Submitted:', { username, email, password });\n      alert('Registration successful!');\n      // Reset form\n      setUsername('');\n      setEmail('');\n      setPassword('');\n    } else {\n      console.log('Form has errors. Please fix them.');\n    }\n  };\n\n  // Check if all fields have non-empty values AND no current errors\n  const isFormValid = username.length > 0 && email.length > 0 && password.length > 0 &&\n                      !usernameError && !emailError && !passwordError;\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '15px', maxWidth: '400px', margin: 'auto', padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <h2>Register</h2>\n      <div>\n        <label htmlFor=\"reg-username\">Username:</label>\n        <input \n          type=\"text\" \n          id=\"reg-username\"\n          value={username} \n          onChange={(e) => setUsername(e.target.value)} \n          onBlur={validateAllFields} // Validate on blur for immediate feedback\n        />\n        {usernameError && <p style={{ color: 'red', fontSize: '0.8em' }}>{usernameError}</p>}\n      </div>\n      <div>\n        <label htmlFor=\"reg-email\">Email:</label>\n        <input \n          type=\"email\" \n          id=\"reg-email\"\n          value={email} \n          onChange={(e) => setEmail(e.target.value)} \n          onBlur={validateAllFields}\n        />\n        {emailError && <p style={{ color: 'red', fontSize: '0.8em' }}>{emailError}</p>}\n      </div>\n      <div>\n        <label htmlFor=\"reg-password\">Password:</label>\n        <input \n          type=\"password\" \n          id=\"reg-password\"\n          value={password} \n          onChange={(e) => setPassword(e.target.value)} \n          onBlur={validateAllFields}\n        />\n        {passwordError && <p style={{ color: 'red', fontSize: '0.8em' }}>{passwordError}</p>}\n      </div>\n      <button type=\"submit\" disabled={!isFormValid}>Register</button>\n    </form>\n  );\n}\n\nexport default RegistrationForm;\n",
          "testCases": [
            "Empty form submission: Button should be disabled initially. Submitting empty form should display all required field errors.",
            "Valid inputs: Username 'testuser', Email 'test@example.com', Password 'Password123' should enable submit button and show success on submit.",
            "Invalid username: 'ab' should show 'Username must be at least 3 characters.' error.",
            "Invalid email: 'invalid-email' should show 'Please enter a valid email address.' error.",
            "Invalid password: 'abc' should show password complexity error. 'Abcdef' should show numeric complexity error. '123456' should show uppercase/lowercase complexity error.",
            "Mixing valid and invalid: Ensure only relevant error messages are displayed.",
            "Form reset: After successful submission, fields should clear.",
            "Dynamic button state: Button's disabled state should accurately reflect form validity in real-time."
          ],
          "hints": [
            "Use regular expressions for email and password validation.",
            "Consider using `useEffect` hooks to run validation logic whenever a specific input's state changes, providing real-time feedback.",
            "Ensure the `disabled` state of the submit button is a computed value based on all current input values and their respective validation states.",
            "A single `validateForm` function can be called on `onSubmit` to perform final validation before submission."
          ],
          "tags": [
            "React",
            "Forms",
            "useState",
            "Validation",
            "Controlled Components",
            "UX"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React State Management",
            "JavaScript Regular Expressions"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_state_forms"
          ]
        },
        {
          "id": "task_user_settings_panel",
          "title": "Create a User Settings Panel with Persistent Preferences",
          "description": "\nBuild a React component `UserSettings` that allows a user to configure a few preferences. These preferences should persist across browser sessions using the `useLocalStorage` custom hook provided in the theory.\n\n1.  **Integrate `useLocalStorage`:** Use the `useLocalStorage` hook to manage the state of at least three different user settings (e.g., `theme` (light/dark), `notificationsEnabled` (boolean), `itemsPerPage` (number)).\n2.  **UI Elements:** Provide appropriate UI elements for each setting (e.g., radio buttons or a toggle for theme, a checkbox for notifications, a select dropdown or number input for items per page).\n3.  **Display Current Settings:** Clearly display the currently selected settings.\n4.  **Real-time Updates:** Ensure that changing a setting immediately updates the UI and persists the new value to `localStorage`.\n5.  **Initial Load:** When the component mounts, it should load the last saved settings from `localStorage`.\n6.  **Reset Button:** Include a 'Reset to Defaults' button that clears `localStorage` for these specific settings and reverts them to their initial default values.\n\nYour solution should demonstrate proper usage of a custom hook for state persistence and basic UI interaction.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport useLocalStorage from './useLocalStorage'; // Assume useLocalStorage is imported\n\nfunction UserSettings() {\n  // TODO: Use useLocalStorage for theme, notificationsEnabled, itemsPerPage\n  const [theme, setTheme] = useLocalStorage('user-theme', 'light'); // Example\n  const [notificationsEnabled, setNotificationsEnabled] = useLocalStorage('user-notifications', true);\n  const [itemsPerPage, setItemsPerPage] = useLocalStorage('user-items-per-page', 10);\n\n  const handleThemeChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setTheme(e.target.value);\n  };\n\n  const handleNotificationsToggle = () => {\n    setNotificationsEnabled(prev => !prev);\n  };\n\n  const handleItemsPerPageChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    setItemsPerPage(Number(e.target.value));\n  };\n\n  const handleResetDefaults = () => {\n    // TODO: Reset all settings to their initial values\n    setTheme('light');\n    setNotificationsEnabled(true);\n    setItemsPerPage(10);\n    // Note: useLocalStorage itself handles saving the new defaults\n    // If you wanted to *remove* from localStorage, you'd call localStorage.removeItem(key)\n  };\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '8px', maxWidth: '500px', margin: '20px auto' }}>\n      <h2>User Settings</h2>\n      \n      <div>\n        <h3>Theme: {theme}</h3>\n        <label>\n          <input \n            type=\"radio\" \n            value=\"light\" \n            checked={theme === 'light'} \n            onChange={handleThemeChange} \n          /> Light\n        </label>\n        <label style={{ marginLeft: '10px' }}>\n          <input \n            type=\"radio\" \n            value=\"dark\" \n            checked={theme === 'dark'} \n            onChange={handleThemeChange} \n          /> Dark\n        </label>\n      </div>\n\n      <div style={{ marginTop: '15px' }}>\n        <h3>Notifications: {notificationsEnabled ? 'Enabled' : 'Disabled'}</h3>\n        <label>\n          <input \n            type=\"checkbox\" \n            checked={notificationsEnabled} \n            onChange={handleNotificationsToggle} \n          /> Enable Notifications\n        </label>\n      </div>\n\n      <div style={{ marginTop: '15px' }}>\n        <h3>Items Per Page: {itemsPerPage}</h3>\n        <select value={itemsPerPage} onChange={handleItemsPerPageChange}>\n          <option value={5}>5</option>\n          <option value={10}>10</option>\n          <option value={20}>20</option>\n        </select>\n      </div>\n\n      <button onClick={handleResetDefaults} style={{ marginTop: '20px', padding: '10px 15px', cursor: 'pointer' }}>\n        Reset to Defaults\n      </button>\n      \n      <p style={{ marginTop: '20px', fontSize: '0.9em', color: '#666' }}>\n        Try changing settings, then close and reopen your browser tab to see persistence!\n      </p>\n    </div>\n  );\n}\n\nexport default UserSettings;\n\n// Make sure you have useLocalStorage.ts (or .js) available in the same directory\n// from the theory section:\n// import { useState, useEffect } from 'react';\n// function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T | ((prev: T) => T)) => void] {\n//   const [storedValue, setStoredValue] = useState<T>(() => {\n//     try { if (typeof window === 'undefined') { return initialValue; } const item = window.localStorage.getItem(key); return item ? JSON.parse(item) : initialValue; } catch (error) { console.error(\"Error reading from localStorage:\", error); return initialValue; }\n//   });\n//   useEffect(() => { try { if (typeof window !== 'undefined') { window.localStorage.setItem(key, JSON.stringify(storedValue)); } } catch (error) { console.error(\"Error writing to localStorage:\", error); } }, [key, storedValue]);\n//   return [storedValue, setStoredValue];\n// }\n",
          "solutionCode": "import React from 'react';\nimport useLocalStorage from './useLocalStorage'; // Assuming useLocalStorage.ts is in the same directory\n\n// Placeholder for useLocalStorage if not available directly\n// import { useState, useEffect } from 'react';\n// function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T | ((prev: T) => T)) => void] {\n//   const [storedValue, setStoredValue] = useState<T>(() => {\n//     try { \n//       if (typeof window === 'undefined') { return initialValue; }\n//       const item = window.localStorage.getItem(key);\n//       return item ? JSON.parse(item) : initialValue;\n//     } catch (error) {\n//       console.error(\"Error reading from localStorage:\", error);\n//       return initialValue;\n//     }\n//   });\n//   useEffect(() => {\n//     try {\n//       if (typeof window !== 'undefined') {\n//         window.localStorage.setItem(key, JSON.stringify(storedValue));\n//       }\n//     } catch (error) {\n//       console.error(\"Error writing to localStorage:\", error);\n//     }\n//   }, [key, storedValue]);\n//   return [storedValue, setStoredValue];\n// }\n\nfunction UserSettings() {\n  // Define default values explicitly\n  const DEFAULT_THEME = 'light';\n  const DEFAULT_NOTIFICATIONS_ENABLED = true;\n  const DEFAULT_ITEMS_PER_PAGE = 10;\n\n  // Use useLocalStorage for each setting\n  const [theme, setTheme] = useLocalStorage('user-theme', DEFAULT_THEME);\n  const [notificationsEnabled, setNotificationsEnabled] = useLocalStorage('user-notifications', DEFAULT_NOTIFICATIONS_ENABLED);\n  const [itemsPerPage, setItemsPerPage] = useLocalStorage('user-items-per-page', DEFAULT_ITEMS_PER_PAGE);\n\n  const handleThemeChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setTheme(e.target.value);\n    // The useLocalStorage hook handles the persistence automatically\n  };\n\n  const handleNotificationsToggle = () => {\n    setNotificationsEnabled(prev => !prev);\n  };\n\n  const handleItemsPerPageChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    // Ensure the value is parsed as a number\n    setItemsPerPage(Number(e.target.value));\n  };\n\n  const handleResetDefaults = () => {\n    // Simply set the state back to default values\n    // The useLocalStorage hook will automatically persist these new defaults\n    setTheme(DEFAULT_THEME);\n    setNotificationsEnabled(DEFAULT_NOTIFICATIONS_ENABLED);\n    setItemsPerPage(DEFAULT_ITEMS_PER_PAGE);\n\n    // Optional: If you wanted to explicitly clear from localStorage first for a true 'reset'\n    // window.localStorage.removeItem('user-theme');\n    // window.localStorage.removeItem('user-notifications');\n    // window.localStorage.removeItem('user-items-per-page');\n    // Then the next render cycle would pick up initial values, or you set them manually as above.\n  };\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '8px', maxWidth: '500px', margin: '20px auto', background: theme === 'dark' ? '#333' : '#fff', color: theme === 'dark' ? '#fff' : '#333' }}>\n      <h2>User Settings</h2>\n      \n      <div>\n        <h3>Theme: {theme}</h3>\n        <label>\n          <input \n            type=\"radio\" \n            value=\"light\" \n            checked={theme === 'light'} \n            onChange={handleThemeChange} \n          /> Light\n        </label>\n        <label style={{ marginLeft: '10px' }}>\n          <input \n            type=\"radio\" \n            value=\"dark\" \n            checked={theme === 'dark'} \n            onChange={handleThemeChange} \n          /> Dark\n        </label>\n      </div>\n\n      <div style={{ marginTop: '15px' }}>\n        <h3>Notifications: {notificationsEnabled ? 'Enabled' : 'Disabled'}</h3>\n        <label>\n          <input \n            type=\"checkbox\" \n            checked={notificationsEnabled} \n            onChange={handleNotificationsToggle} \n          /> Enable Notifications\n        </label>\n      </div>\n\n      <div style={{ marginTop: '15px' }}>\n        <h3>Items Per Page: {itemsPerPage}</h3>\n        <select value={itemsPerPage} onChange={handleItemsPerPageChange}>\n          <option value={5}>5</option>\n          <option value={10}>10</option>\n          <option value={20}>20</option>\n          <option value={50}>50</option>\n        </select>\n      </div>\n\n      <button onClick={handleResetDefaults} style={{ marginTop: '20px', padding: '10px 15px', cursor: 'pointer', backgroundColor: theme === 'dark' ? '#555' : '#eee', color: theme === 'dark' ? '#fff' : '#333', border: '1px solid #777', borderRadius: '4px' }}>\n        Reset to Defaults\n      </button>\n      \n      <p style={{ marginTop: '20px', fontSize: '0.9em', color: theme === 'dark' ? '#bbb' : '#666' }}>\n        Try changing settings, then close and reopen your browser tab to see persistence!\n      </p>\n    </div>\n  );\n}\n\nexport default UserSettings;\n",
          "testCases": [
            "Initial load: Verify that refreshing the page or closing/reopening the tab correctly loads the last saved settings from `localStorage`.",
            "Theme change: Change theme to 'dark', refresh, verify it's still 'dark'.",
            "Notifications toggle: Toggle notifications off, refresh, verify they are off.",
            "Items per page change: Set to 20, refresh, verify it's 20.",
            "Mixed changes: Change all settings, refresh, verify all persist correctly.",
            "Reset defaults: Click 'Reset to Defaults', verify settings revert to initial values ('light', true, 10) and persist after refresh.",
            "Error handling (manual test): If possible, simulate `localStorage` quota exceeded (e.g., by filling it manually with large data in browser dev tools) and observe error logging in console without app crash."
          ],
          "hints": [
            "Remember that `useLocalStorage` itself handles the saving and loading. Your component just needs to use the returned `state` and `setState`.",
            "For the 'Reset to Defaults' button, simply call the `setState` functions returned by `useLocalStorage` with their respective default values.",
            "Ensure number inputs or select dropdowns correctly parse their `event.target.value` to a `number` if your initial state is a number, as `input.value` is always a string."
          ],
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "LocalStorage",
            "State Persistence",
            "UI/UX"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_custom_hook_use_local_storage",
            "React State Management"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "useLocalStorage",
            "useState",
            "useEffect",
            "LocalStorage API"
          ]
        },
        {
          "id": "task_fetch_display_posts",
          "title": "Display Blog Posts from an API using useFetch",
          "description": "\nCreate a React component `BlogPostViewer` that fetches and displays a list of blog posts from a public API. Utilize the `useFetch` custom hook provided in the theory to handle data fetching logic.\n\n1.  **Integrate `useFetch`:** Use the `useFetch` hook to fetch data from `https://jsonplaceholder.typicode.com/posts`.\n2.  **Handle Loading State:** Display a 'Loading...' message while the data is being fetched.\n3.  **Handle Error State:** Display an appropriate error message if the fetch request fails.\n4.  **Display Data:** Once data is successfully fetched, render a list of blog post titles and bodies.\n5.  **No Data State:** Display a 'No posts found.' message if the API returns an empty array or `null`.\n6.  **Refresh Button:** Add a button that re-fetches the data when clicked (hint: consider how to make `useFetch` re-run).\n\nYour solution should demonstrate proper consumption of a custom data fetching hook and robust UI handling for asynchronous operations.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\nimport useFetch from './useFetch'; // Assume useFetch is imported\n\n// Define a type for a single Post if using TypeScript\ninterface Post {\n  userId: number;\n  id: number;\n  title: string;\n  body: string;\n}\n\nfunction BlogPostViewer() {\n  const [refreshKey, setRefreshKey] = useState(0);\n  const apiUrl = 'https://jsonplaceholder.typicode.com/posts';\n  \n  // TODO: Use useFetch hook here, ensuring it re-runs when refreshKey changes\n  // const { data: posts, loading, error } = useFetch<Post[]>(apiUrl);\n  const { data: posts, loading, error } = useFetch<Post[]>(apiUrl + `?refresh=${refreshKey}`); // Example of making URL dynamic\n\n  const handleRefresh = () => {\n    // TODO: Implement logic to trigger a re-fetch.\n    setRefreshKey(prev => prev + 1);\n  };\n\n  if (loading) {\n    return <p>Loading posts...</p>;\n  }\n\n  if (error) {\n    return <p style={{ color: 'red' }}>Error: {error}</p>;\n  }\n\n  if (!posts || posts.length === 0) {\n    return <p>No posts found.</p>;\n  }\n\n  return (\n    <div style={{ maxWidth: '800px', margin: 'auto', padding: '20px' }}>\n      <h1>Blog Posts</h1>\n      <button onClick={handleRefresh} style={{ marginBottom: '20px', padding: '10px 15px', cursor: 'pointer' }}>\n        Refresh Posts\n      </button>\n      {\n        // TODO: Map over posts and display them\n      }\n      <ul>\n        {posts.map(post => (\n          <li key={post.id} style={{ marginBottom: '20px', borderBottom: '1px solid #eee', paddingBottom: '15px' }}>\n            <h3>{post.title}</h3>\n            <p>{post.body}</p>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default BlogPostViewer;\n\n// Make sure you have useFetch.ts (or .js) available in the same directory\n// from the theory section:\n// import { useState, useEffect } from 'react';\n// function useFetch<T>(url: string, options?: RequestInit): { data: T | null; loading: boolean; error: string | null; } {\n//   const [data, setData] = useState<T | null>(null);\n//   const [loading, setLoading] = useState<boolean>(true);\n//   const [error, setError] = useState<string | null>(null);\n//   useEffect(() => { let isMounted = true; setLoading(true); setError(null); const fetchData = async () => { try { const response = await fetch(url, options); if (!response.ok) { throw new Error(`HTTP error! Status: ${response.status}`); } const json: T = await response.json(); if (isMounted) { setData(json); setError(null); } } catch (e) { const errorMessage = (e instanceof Error) ? e.message : String(e); if (isMounted) { setError(errorMessage); setData(null); } } finally { if (isMounted) { setLoading(false); } } }; fetchData(); return () => { isMounted = false; }; }, [url, options]); return { data, loading, error };\n// }\n",
          "solutionCode": "import React, { useState } from 'react';\nimport useFetch from './useFetch'; // Assuming useFetch.ts is in the same directory\n\n// Placeholder for useFetch if not available directly\n// import { useState, useEffect } from 'react';\n// interface FetchOptions extends RequestInit {}\n// interface FetchResult<T> {\n//   data: T | null;\n//   loading: boolean;\n//   error: string | null;\n// }\n// function useFetch<T>(url: string, options?: FetchOptions): FetchResult<T> {\n//   const [data, setData] = useState<T | null>(null);\n//   const [loading, setLoading] = useState<boolean>(true);\n//   const [error, setError] = useState<string | null>(null);\n  \n//   useEffect(() => {\n//     let isMounted = true;\n//     setLoading(true);\n//     setError(null);\n//     setData(null); // Clear previous data on re-fetch\n    \n//     const fetchData = async () => {\n//       try {\n//         const response = await fetch(url, options);\n//         if (!response.ok) {\n//           throw new Error(`HTTP error! Status: ${response.status} - ${response.statusText}`);\n//         }\n        \n//         const json: T = await response.json();\n//         if (isMounted) {\n//           setData(json);\n//           setError(null);\n//         }\n//       } catch (e) {\n//         const errorMessage = (e instanceof Error) ? e.message : String(e);\n//         if (isMounted) {\n//           setError(errorMessage);\n//           setData(null);\n//         }\n//       } finally {\n//         if (isMounted) {\n//           setLoading(false);\n//         }\n//       }\n//     };\n    \n//     fetchData();\n//     return () => {\n//       isMounted = false;\n//     };\n//   }, [url, options]);\n  \n//   return { data, loading, error };\n// }\n\ninterface Post {\n  userId: number;\n  id: number;\n  title: string;\n  body: string;\n}\n\nfunction BlogPostViewer() {\n  const [refreshKey, setRefreshKey] = useState(0); // State to trigger re-fetch\n  \n  // Append refreshKey to URL to make it a dependency of useFetch,\n  // causing it to re-run when refreshKey changes.\n  const apiUrl = `https://jsonplaceholder.typicode.com/posts?_t=${refreshKey}`;\n  \n  const { data: posts, loading, error } = useFetch<Post[]>(apiUrl);\n\n  const handleRefresh = () => {\n    setRefreshKey(prevKey => prevKey + 1);\n  };\n\n  if (loading) {\n    return (\n      <div style={{ maxWidth: '800px', margin: 'auto', padding: '20px' }}>\n        <h1>Blog Posts</h1>\n        <p>Loading posts...</p>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div style={{ maxWidth: '800px', margin: 'auto', padding: '20px' }}>\n        <h1>Blog Posts</h1>\n        <p style={{ color: 'red' }}>Error fetching posts: {error}</p>\n        <button onClick={handleRefresh} style={{ marginTop: '20px', padding: '10px 15px', cursor: 'pointer' }}>\n          Try Again\n        </button>\n      </div>\n    );\n  }\n\n  if (!posts || posts.length === 0) {\n    return (\n      <div style={{ maxWidth: '800px', margin: 'auto', padding: '20px' }}>\n        <h1>Blog Posts</h1>\n        <p>No posts found.</p>\n        <button onClick={handleRefresh} style={{ marginTop: '20px', padding: '10px 15px', cursor: 'pointer' }}>\n          Fetch Posts\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <div style={{ maxWidth: '800px', margin: 'auto', padding: '20px' }}>\n      <h1>Blog Posts</h1>\n      <button onClick={handleRefresh} style={{ marginBottom: '20px', padding: '10px 15px', cursor: 'pointer' }}>\n        Refresh Posts\n      </button>\n      <ul>\n        {posts.map(post => (\n          <li key={post.id} style={{ marginBottom: '20px', borderBottom: '1px solid #eee', paddingBottom: '15px' }}>\n            <h3>{post.title}</h3>\n            <p>{post.body}</p>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default BlogPostViewer;\n",
          "testCases": [
            "Initial load: Verify 'Loading...' message appears, then posts are displayed.",
            "Successful fetch: Ensure all post titles and bodies are rendered correctly (check browser console for network requests).",
            "Refresh functionality: Click 'Refresh Posts', verify the UI shows 'Loading...' briefly and then re-displays posts. Check network tab for new request.",
            "Simulate network error: (e.g., go offline in browser dev tools, or provide an invalid URL like `https://jsonplaceholder.typicode.com/invalid-url`) Verify 'Error: ...' message is displayed.",
            "Simulate empty data: (e.g., modify the API response in dev tools to an empty array `[]`) Verify 'No posts found.' message.",
            "Component unmount/mount: (e.g., render/unrender `BlogPostViewer` quickly using a parent component's state) Verify no console warnings about setting state on unmounted components."
          ],
          "hints": [
            "To force `useFetch` to re-run, its `url` dependency (or `options`) needs to change. You can achieve this by adding a dummy query parameter to the URL that changes when the refresh button is clicked (e.g., `?_t=${timestamp}` or `?refresh=${refreshCounter}`).",
            "Ensure your `useFetch` hook clears previous `data` and `error` states and sets `loading` to `true` at the beginning of each fetch cycle to properly reflect UI status."
          ],
          "tags": [
            "React",
            "Hooks",
            "Custom Hooks",
            "Data Fetching",
            "Fetch API",
            "UI States"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_custom_hook_use_fetch",
            "React State Management"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "useFetch",
            "useState",
            "useEffect",
            "Error Handling",
            "Async/Await"
          ]
        }
      ]
    }
  },
  {
    "id": "2f957036-eb34-437c-bcd0-a40628a380f4",
    "startLine": 5700,
    "endLine": 5799,
    "processedDate": "2025-06-17T09:44:34.311Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_use_fetch_hook",
          "title": "Understanding the useFetch Hook for Asynchronous Data",
          "content": "The `useFetch` custom hook is designed to simplify data fetching logic within React components, abstracting away the complexities of `useState` and `useEffect` for managing loading, error, and data states. This hook encapsulates the common pattern of making API requests, providing a reusable and clean interface.\n\n## Key Concepts\n*   **State Management:** It internally uses `useState` to manage three crucial pieces of state: `data` (for the fetched payload), `loading` (a boolean indicating if a request is in progress), and `error` (for any errors encountered during the fetch).\n*   **Side Effects with `useEffect`:** The actual data fetching logic is housed within a `useEffect` hook. This ensures the fetch operation runs when the component mounts and re-runs if any of its dependencies (`url`, `options`) change.\n*   **Dependency Array:** The `useEffect`'s dependency array `[url, options]` ensures that the fetch operation is re-triggered only when the URL or fetch options change. It's crucial to correctly manage dependencies to prevent unnecessary re-fetches or stale data.\n*   **Asynchronous Operations:** The `fetchData` function is asynchronous (`async/await`) to handle the promise-based nature of the `fetch` API. It wraps the `fetch` call in a `try-catch` block to gracefully handle network errors or invalid responses.\n*   **Preventing Memory Leaks (`isMounted`):** A critical aspect of this `useFetch` implementation is the `isMounted` flag. This boolean variable, initialized to `true` and set to `false` in the `useEffect`'s cleanup function, prevents state updates on an unmounted component. This avoids the common React warning: \"Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application.\" This is particularly important for slow network requests where the component might unmount before the fetch promise resolves.\n*   **Abstraction and Reusability:** By encapsulating the fetching logic into a custom hook, components using `useFetch` become cleaner and more focused on rendering data rather than managing fetch lifecycle.\n\n## Implementation Details\nThe hook returns an object `{ data, loading, error }`, making it easy for consuming components to access the current state of the data fetching operation. The `options` parameter allows for flexibility in configuring the `fetch` request, such as setting HTTP methods, headers, or body for POST/PUT requests.\n\nWhen `options` is an object, it's important to memoize it (e.g., using `useMemo` in the calling component) if it's not a primitive, to prevent the `useEffect` from re-running on every render due to reference equality changes, even if the content of the options object is conceptually the same.\n\n",
          "examples": [
            {
              "id": "example_use_fetch_basic",
              "title": "Basic useFetch Hook Implementation",
              "code": "import { useState, useEffect } from 'react';\n\nfunction useFetch(url, options) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let isMounted = true; // Flag to prevent state updates on unmounted component\n\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      try {\n        const response = await fetch(url, options);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const result = await response.json();\n        if (isMounted) {\n          setData(result);\n        }\n      } catch (e) {\n        if (isMounted) {\n          setError(e.message);\n        }\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    fetchData();\n\n    return () => {\n      isMounted = false; // Set to false on unmount\n    };\n  }, [url, options]); // Re-run effect when url or options change\n\n  return { data, loading, error };\n}",
              "explanation": "This code defines the `useFetch` hook. It initializes `data`, `loading`, and `error` states. The `useEffect` hook performs the asynchronous data fetch. The `isMounted` flag is a crucial pattern to prevent memory leaks and 'Can't perform a React state update on an unmounted component' warnings, ensuring state is only updated if the component is still mounted. The `finally` block ensures `setLoading(false)` is called whether the fetch succeeds or fails. The hook returns an object with the current data, loading status, and any error.",
              "language": "typescript"
            },
            {
              "id": "example_use_fetch_usage",
              "title": "Usage of useFetch Hook",
              "code": "import React from 'react';\n// Assume useFetch is imported from the file above\n\nfunction UserProfile({ userId }) {\n  const { data, loading, error } = useFetch(\n    `https://api.example.com/users/${userId}`\n  );\n\n  if (loading) return <div>Loading user profile...</div>;\n  if (error) return <div>Error loading user: {error}</div>;\n  if (!data) return <div>No user data found.</div>; // Handle case where data is null initially or after error\n\n  return (\n    <div>\n      <h2>{data.name}</h2>\n      <p>Email: {data.email}</p>\n      <p>ID: {userId}</p>\n    </div>\n  );\n}",
              "explanation": "This `UserProfile` component demonstrates how to consume the `useFetch` hook. It destructurizes `data`, `loading`, and `error` from the hook's return value. Based on the `loading` and `error` states, it renders different UI feedback. Once data is successfully fetched and available, it renders the user's name and email.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_use_fetch_1",
            "question_use_fetch_2",
            "question_use_fetch_3",
            "question_use_fetch_4",
            "question_use_fetch_5",
            "question_use_fetch_6",
            "question_use_fetch_7",
            "question_use_fetch_8",
            "question_use_fetch_9",
            "question_use_fetch_10"
          ],
          "relatedTasks": [
            "task_use_fetch_1",
            "task_use_fetch_2"
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "useState",
            "Data Fetching",
            "Asynchronous",
            "API Integration",
            "Custom Hooks",
            "Error Handling",
            "Loading States",
            "Memory Leaks"
          ],
          "technology": "React",
          "prerequisites": [
            "useState",
            "useEffect",
            "Asynchronous JavaScript (Promises, async/await)",
            "Fetch API"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Building custom data hooks",
            "Complex form submissions",
            "Real-time data updates"
          ]
        },
        {
          "id": "theory_use_media_query_hook",
          "title": "Implementing the useMediaQuery Hook for Responsive Design",
          "content": "The `useMediaQuery` custom hook provides a declarative way to incorporate responsive design logic directly into React components. Instead of relying solely on CSS media queries, this hook allows components to dynamically adjust their rendering based on viewport characteristics, enabling more complex layout adaptations or feature toggles.\n\n## Key Concepts\n*   **CSS Media Queries in JavaScript:** It leverages the `window.matchMedia()` Web API. This API allows JavaScript to programmatically test and monitor CSS media queries. `window.matchMedia(query)` returns a `MediaQueryList` object.\n*   **`MediaQueryList` Object:** The `MediaQueryList` object has a `matches` property (a boolean indicating if the document currently matches the media query) and methods (`addEventListener`, `removeEventListener`) to listen for changes in the media query status.\n*   **State Management:** The hook uses `useState` to store the `matches` boolean, which reflects whether the provided media query currently applies.\n*   **Event Listeners and Cleanup:** A `useEffect` hook is used to set up and tear down an event listener. When the component mounts, it attaches a `change` event listener to the `MediaQueryList` object. This listener updates the `matches` state whenever the media query status changes (e.g., when the viewport crosses a breakpoint). The cleanup function returned by `useEffect` is crucial for performance and preventing memory leaks; it removes the event listener when the component unmounts or before the effect re-runs if the `query` dependency changes.\n*   **Dynamic UI:** By returning the `matches` boolean, the consuming component can use conditional rendering to display different layouts or components based on the current screen size or other media features.\n\n## Implementation Details\nThe `useEffect` hook runs once when the component mounts (due to initial empty dependency array or when `query` changes). It initializes the `matches` state with the current status of the media query. The `listener` function is simple: it directly updates the state based on the `e.matches` property from the event object. This hook is highly efficient as it only re-renders the component when the `matches` status actually changes.\n",
          "examples": [
            {
              "id": "example_use_media_query_basic",
              "title": "Basic useMediaQuery Hook Implementation",
              "code": "import { useState, useEffect } from 'react';\n\nfunction useMediaQuery(query) {\n  const [matches, setMatches] = useState(false);\n  \n  useEffect(() => {\n    // Check if window is defined (for SSR compatibility)\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    const mediaQuery = window.matchMedia(query);\n    setMatches(mediaQuery.matches); // Initialize state with current match status\n    \n    // Define the listener function\n    const listener = (e) => setMatches(e.matches);\n    \n    // Add event listener for changes\n    mediaQuery.addEventListener('change', listener);\n    \n    // Cleanup function: remove event listener on unmount or query change\n    return () => mediaQuery.removeEventListener('change', listener);\n  }, [query]); // Re-run effect if the media query string changes\n  \n  return matches;\n}",
              "explanation": "This code defines the `useMediaQuery` hook. It initializes `matches` state to `false`. Inside `useEffect`, it uses `window.matchMedia` to create a `MediaQueryList` object. It sets the initial `matches` state and then adds a `change` event listener to `mediaQuery`. The listener updates the `matches` state whenever the media query condition changes. The cleanup function ensures the event listener is removed when the component unmounts or the `query` changes, preventing memory leaks.",
              "language": "typescript"
            },
            {
              "id": "example_use_media_query_usage",
              "title": "Usage of useMediaQuery Hook for Responsive Layouts",
              "code": "import React from 'react';\n// Assume useMediaQuery is imported from the file above\nimport MobileLayout from './MobileLayout';\nimport DesktopLayout from './DesktopLayout';\n\nfunction ResponsiveComponent() {\n  // Check for mobile screens (e.g., width up to 768px)\n  const isMobile = useMediaQuery('(max-width: 768px)');\n  \n  // Check for print media\n  const isPrint = useMediaQuery('print');\n\n  return (\n    <div>\n      <h1>Responsive Content</h1>\n      {isMobile ? (\n        <MobileLayout />\n      ) : (\n        <DesktopLayout />\n      )}\n      {isPrint && <p>This content is optimized for printing.</p>}\n    </div>\n  );\n}",
              "explanation": "This `ResponsiveComponent` uses the `useMediaQuery` hook to dynamically render either a `MobileLayout` or `DesktopLayout` based on the screen width. It also demonstrates checking for `print` media, showing how flexible the hook is for various media query types. This allows for fine-grained control over UI rendering based on specific environmental factors.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_use_media_query_1",
            "question_use_media_query_2",
            "question_use_media_query_3",
            "question_media_query_performance",
            "question_media_query_server_side",
            "question_use_media_query_4",
            "question_use_media_query_5"
          ],
          "relatedTasks": [
            "task_use_media_query_1",
            "task_use_media_query_2"
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "useState",
            "Responsive Design",
            "Media Queries",
            "Web API",
            "Custom Hooks",
            "UI/UX",
            "Performance"
          ],
          "technology": "React",
          "prerequisites": [
            "useState",
            "useEffect",
            "CSS Media Queries",
            "JavaScript Event Listeners"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Building adaptive UIs",
            "Component-level responsive logic",
            "Accessibility enhancements"
          ]
        },
        {
          "id": "theory_use_debounce_hook",
          "title": "Mastering the useDebounce Hook for Performance Optimization",
          "content": "The `useDebounce` custom hook is an essential tool for optimizing performance in React applications, particularly when dealing with frequently firing events like typing in a search input, resizing a window, or scrolling. Debouncing ensures that a function is not called until a certain amount of time has passed since the last time it was invoked.\n\n## Key Concepts\n*   **Debouncing Principle:** The core idea of debouncing is to delay an action until a specified `delay` has passed without any further triggers. If the action is triggered again before the delay expires, the timer is reset.\n*   **`setTimeout` and `clearTimeout`:** The hook relies heavily on JavaScript's `setTimeout` for scheduling the delayed update and `clearTimeout` for canceling any pending timers. This cancellation is crucial for the debouncing effect.\n*   **State Management:** It uses `useState` to hold the `debouncedValue`, which is the value that will eventually be returned after the debounce `delay` has passed.\n*   **`useEffect` for Lifecycle Management:** The `useEffect` hook is responsible for managing the `setTimeout` timer. It runs whenever the `value` or `delay` dependencies change.\n*   **Cleanup Function:** The cleanup function returned by `useEffect` is vital: `return () => { clearTimeout(handler); }`. It ensures that if the `value` changes again *before* the `delay` expires, the previous timeout is cleared, preventing the old, outdated `debouncedValue` from being set. It also clears the timeout when the component unmounts, preventing potential errors or unnecessary operations.\n*   **Common Use Cases:**\n    *   **Search Bars:** Prevents sending an API request on every keystroke, instead waiting for the user to pause typing.\n    *   **Window Resizing:** Avoids frequent re-renders or recalculations during continuous window resizing.\n    *   **Input Validation:** Delays validation checks until the user stops typing, improving responsiveness.\n\n## Implementation Details\nThe `useDebounce` hook takes two arguments: the `value` to be debounced and the `delay` in milliseconds. The `useEffect` sets a timeout to update the `debouncedValue` after `delay`. If `value` changes before `delay` runs out, the previous timeout is cleared, and a new one is set. This effectively delays the `debouncedValue` update until the `value` has been stable for the specified `delay`.\n",
          "examples": [
            {
              "id": "example_use_debounce_basic",
              "title": "Basic useDebounce Hook Implementation",
              "code": "import { useState, useEffect } from 'react';\n\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  \n  useEffect(() => {\n    // Set up a timeout to update the debounced value after the delay\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    \n    // Cleanup function: cancel the timeout if value or delay changes, or on unmount\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]); // Re-run effect if value or delay changes\n  \n  return debouncedValue;\n}",
              "explanation": "This code defines the `useDebounce` hook. It maintains `debouncedValue` state. Inside `useEffect`, it sets a `setTimeout` to update `debouncedValue` after `delay` milliseconds. Crucially, the cleanup function `clearTimeout(handler)` ensures that if the `value` changes before the `delay` is over, the previous timeout is cancelled, and a new one is started. This prevents intermediate values from triggering effects.",
              "language": "typescript"
            },
            {
              "id": "example_use_debounce_usage",
              "title": "Usage of useDebounce Hook for a Search Input",
              "code": "import React, { useState, useEffect } from 'react';\n// Assume useDebounce is imported from the file above\n\nfunction SearchComponent() {\n  const [searchTerm, setSearchTerm] = useState('');\n  // Debounce the search term by 500ms\n  const debouncedSearchTerm = useDebounce(searchTerm, 500);\n\n  // Effect to perform actual search when debouncedSearchTerm changes\n  useEffect(() => {\n    if (debouncedSearchTerm) {\n      console.log(`Performing search for: \"${debouncedSearchTerm}\"...`);\n      // Here you would typically make an API call using debouncedSearchTerm\n      // For example: fetch(`/api/search?q=${debouncedSearchTerm}`);\n    } else {\n      console.log('Search term cleared.');\n    }\n  }, [debouncedSearchTerm]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Type to search...\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        style={{ padding: '10px', width: '300px', fontSize: '16px' }}\n      />\n      <p>Current input: {searchTerm}</p>\n      <p>Debounced search: {debouncedSearchTerm}</p>\n    </div>\n  );\n}",
              "explanation": "This `SearchComponent` demonstrates a common use case for `useDebounce`. The `searchTerm` state updates immediately as the user types. However, the `useEffect` that simulates an API call only triggers when `debouncedSearchTerm` changes, which happens only after the user has paused typing for 500 milliseconds. This significantly reduces the number of API calls, improving performance and reducing server load.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_use_debounce_1",
            "question_use_debounce_2",
            "question_use_debounce_3",
            "question_use_debounce_4",
            "question_debounce_throttle_diff",
            "question_debounce_real_world"
          ],
          "relatedTasks": [
            "task_use_debounce_1",
            "task_use_debounce_2"
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "useState",
            "Debounce",
            "Performance Optimization",
            "Custom Hooks",
            "Timers",
            "Search Input",
            "Event Handling"
          ],
          "technology": "React",
          "prerequisites": [
            "useState",
            "useEffect",
            "setTimeout",
            "clearTimeout",
            "Event Handling"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Building high-performance UIs",
            "Optimizing API calls",
            "Responsive event handling"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_use_fetch_1",
          "topic": "useFetch Hook - Fundamentals",
          "level": "easy",
          "type": "flashcard",
          "question": "What primary React hooks are typically used internally when creating a `useFetch` custom hook?",
          "answer": "`useState` to manage data, loading, and error states; and `useEffect` to perform the side effect of fetching data.",
          "options": [],
          "analysisPoints": [
            "Identifies core React hooks for state and side effects.",
            "Understands the role of each hook in data fetching."
          ],
          "keyConcepts": [
            "useState",
            "useEffect",
            "Custom Hooks"
          ],
          "evaluationCriteria": [
            "Recall of fundamental React hook usage.",
            "Understanding of state management and side effects."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Fundamentals",
            "useFetch"
          ],
          "prerequisites": [
            "useState",
            "useEffect"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_fetch_2",
          "topic": "useFetch Hook - Cleanup and Memory Leaks",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `useFetch` hook's `useEffect` cleanup function. What is the main purpose of `isMounted = false;` in the return function?\n\n```javascript\n  useEffect(() => {\n    let isMounted = true;\n    const fetchData = async () => {\n      // ... fetch logic ...\n      if (isMounted) {\n        setData(result);\n      }\n      // ...\n    };\n    fetchData();\n    return () => {\n      isMounted = false;\n    };\n  }, [url, options]);\n```",
          "answer": "To prevent state updates on an unmounted component, which would otherwise lead to memory leak warnings.",
          "options": [
            "To reset the `isMounted` flag for the next fetch request.",
            "To signal that the data fetching process has completed successfully.",
            "To prevent state updates on an unmounted component, which would otherwise lead to memory leak warnings.",
            "To cancel the ongoing fetch request if the component unmounts."
          ],
          "analysisPoints": [
            "Tests understanding of `useEffect` cleanup.",
            "Highlights the common 'memory leak' warning in React.",
            "Distinguishes between preventing state updates and cancelling network requests (which requires `AbortController`)."
          ],
          "keyConcepts": [
            "useEffect",
            "Cleanup Function",
            "Memory Leaks",
            "Component Lifecycle",
            "useFetch"
          ],
          "evaluationCriteria": [
            "Knowledge of `useEffect` cleanup mechanisms.",
            "Ability to identify and address common React warnings/issues.",
            "Differentiation between `isMounted` flag and `AbortController`."
          ],
          "example": "The `isMounted` flag is a standard pattern in older React codebases (before React 18's automatic batching and `useSyncExternalStore` for external state) to prevent attempts to update state on a component that has already been removed from the DOM. If a fetch request finishes after the component unmounts, calling `setData` or `setError` on an unmounted component will cause React to issue a warning about potential memory leaks.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Memory Leaks",
            "Best Practices",
            "MCQ"
          ],
          "prerequisites": [
            "useEffect",
            "Component Lifecycle"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_fetch_3",
          "topic": "useFetch Hook - Dependency Array",
          "level": "medium",
          "type": "open",
          "question": "Explain the significance of the `[url, options]` dependency array in the `useFetch` hook's `useEffect`. What happens if `options` is an object literal created inline within the component that calls `useFetch`?",
          "answer": "The `[url, options]` dependency array tells `useEffect` to re-run the `fetchData` function whenever the `url` string or the `options` object reference changes. This ensures that new data is fetched when the source or the request configuration changes.\n\nIf `options` is an object literal created inline (e.g., `const { data } = useFetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' } });`), a *new* object reference is created on every re-render of the calling component. Since JavaScript compares objects by reference, this new object, even if its contents are identical to the previous one, will be considered a 'change' by `useEffect`. Consequently, the `useFetch` hook's effect will re-run on every render, leading to an infinite loop of data fetches or excessive, unnecessary API calls. To prevent this, the `options` object should be memoized using `useMemo` in the consuming component, or defined outside the component if it's static.",
          "analysisPoints": [
            "Understanding of `useEffect` dependency array mechanics.",
            "Knowledge of JavaScript object reference equality.",
            "Ability to identify and troubleshoot infinite re-renders/unnecessary API calls.",
            "Proposing solutions like `useMemo` for memoization."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Object Equality",
            "Memoization",
            "useMemo",
            "Performance"
          ],
          "evaluationCriteria": [
            "Thorough explanation of `useEffect` dependencies.",
            "Demonstrates understanding of JS object comparison.",
            "Identifies and solves a common React performance pitfall."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Performance",
            "Interview Question"
          ],
          "prerequisites": [
            "useEffect",
            "JavaScript Object References"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_fetch_4",
          "topic": "useFetch Hook - Error Handling",
          "level": "easy",
          "type": "flashcard",
          "question": "How does the `useFetch` hook handle HTTP errors (e.g., 404 Not Found or 500 Internal Server Error)?",
          "answer": "It checks `response.ok`. If `false`, it throws an `Error` which is then caught by the `try-catch` block, setting the `error` state.",
          "options": [],
          "analysisPoints": [
            "Recognizes the `response.ok` property of the `Fetch` API.",
            "Understands `try-catch` block for error propagation and state update."
          ],
          "keyConcepts": [
            "Fetch API",
            "Error Handling",
            "Async/Await",
            "useFetch"
          ],
          "evaluationCriteria": [
            "Knowledge of `fetch` response properties.",
            "Basic understanding of `try-catch`."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Error Handling",
            "Flashcard"
          ],
          "prerequisites": [
            "Fetch API",
            "Async/Await"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_fetch_5",
          "topic": "useFetch Hook - Advanced Features",
          "level": "hard",
          "type": "code",
          "question": "Modify the `useFetch` hook to include a `refetch` function that can be called externally to re-run the fetch operation. Additionally, implement an `AbortController` to cancel the ongoing fetch request if the component unmounts or a new fetch request is initiated.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Ability to extend existing custom hooks.",
            "Correctly implementing `useCallback` for stable function references.",
            "Proper usage of `AbortController` for request cancellation.",
            "Managing `useEffect` dependencies with the new `refetch` mechanism."
          ],
          "keyConcepts": [
            "useCallback",
            "AbortController",
            "Data Fetching",
            "Custom Hooks",
            "Performance"
          ],
          "evaluationCriteria": [
            "Practical application of `useCallback` and `AbortController`.",
            "Demonstrates advanced React hook patterns.",
            "Handles complex side effect scenarios (cancellation, manual re-trigger)."
          ],
          "example": "```typescript\nimport { useState, useEffect, useCallback, useRef } from 'react';\n\nfunction useFetchWithRefetchAndAbort(url, options) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const controllerRef = useRef(null); // To store AbortController\n\n  const fetchData = useCallback(async () => {\n    // Abort any previous request if active\n    if (controllerRef.current) {\n      controllerRef.current.abort();\n    }\n    const controller = new AbortController();\n    controllerRef.current = controller;\n    const signal = controller.signal;\n\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await fetch(url, { ...options, signal });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const result = await response.json();\n      setData(result);\n    } catch (e) {\n      if (e.name === 'AbortError') {\n        console.log('Fetch aborted');\n        return; // Don't set error for aborted requests\n      }\n      setError(e.message);\n    } finally {\n      setLoading(false);\n      controllerRef.current = null; // Clear controller once request is done/aborted\n    }\n  }, [url, options]); // fetchData itself is memoized\n\n  useEffect(() => {\n    fetchData(); // Initial fetch and re-fetch on url/options change\n\n    return () => {\n      // Abort request on component unmount or when effect re-runs\n      if (controllerRef.current) {\n        controllerRef.current.abort();\n      }\n    };\n  }, [fetchData]); // Dependency on memoized fetchData\n\n  return { data, loading, error, refetch: fetchData };\n}\n\n// Usage Example:\n// function UserProfile({ userId }) {\n//   const { data, loading, error, refetch } = useFetchWithRefetchAndAbort(\n//     `https://api.example.com/users/${userId}`\n//   );\n\n//   if (loading) return <div>Loading user profile...</div>;\n//   if (error) return <div>Error loading user: {error}</div>;\n//   if (!data) return <div>No user data found.</div>;\n\n//   return (\n//     <div>\n//       <h2>{data.name}</h2>\n//       <p>Email: {data.email}</p>\n//       <button onClick={refetch}>Refresh User Data</button>\n//     </div>\n//   );\n// }\n```",
          "tags": [
            "React",
            "Hooks",
            "useFetch",
            "AbortController",
            "useCallback",
            "Advanced",
            "Code Challenge"
          ],
          "prerequisites": [
            "useCallback",
            "Fetch API",
            "Promises",
            "Error Handling"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_fetch_6",
          "topic": "useFetch Hook - Comparison",
          "level": "medium",
          "type": "open",
          "question": "What are the advantages of using a custom `useFetch` hook over performing data fetching directly inside a `useEffect` hook in each component?",
          "answer": "Using a custom `useFetch` hook offers several advantages:\n1.  **Reusability:** The fetching logic is centralized and can be reused across multiple components, reducing code duplication.\n2.  **Abstraction:** It abstracts away the complexity of managing loading, error, and data states, as well as the `useEffect` cleanup for `isMounted` or `AbortController`.\n3.  **Readability:** Components that consume the hook become cleaner and easier to understand, focusing on rendering logic rather than data fetching boilerplate.\n4.  **Maintainability:** Changes or improvements to the data fetching mechanism (e.g., adding caching, retry logic, or different error handling) can be made in one place within the custom hook, affecting all consumers.\n5.  **Testability:** The custom hook can be tested independently of any specific component.",
          "analysisPoints": [
            "Compares custom hooks to inline `useEffect`.",
            "Highlights benefits like reusability, abstraction, maintainability, testability.",
            "Demonstrates understanding of 'Don't Repeat Yourself' (DRY) principle in React."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "Reusability",
            "Abstraction",
            "Maintainability",
            "DRY Principle"
          ],
          "evaluationCriteria": [
            "Ability to articulate the benefits of custom hooks.",
            "Understanding of software design principles applied to React."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Best Practices",
            "Software Design"
          ],
          "prerequisites": [
            "Custom Hooks",
            "useEffect"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_fetch_7",
          "topic": "useFetch Hook - Initial State",
          "level": "easy",
          "type": "mcq",
          "question": "What is the initial `loading` state typically set to in a `useFetch` hook, and why?",
          "answer": "True, because data fetching starts immediately when the component mounts.",
          "options": [
            "False, it becomes true only after the fetch request is initiated.",
            "True, because data fetching starts immediately when the component mounts.",
            "Null, indicating no loading status until the first render.",
            "Undefined, as its value is determined by the `fetchData` function."
          ],
          "analysisPoints": [
            "Tests understanding of initial state management in hooks.",
            "Connects initial state to component lifecycle."
          ],
          "keyConcepts": [
            "useState",
            "Initial State",
            "Loading States",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Correctly identifies initial state for a loading indicator.",
            "Understands the timing of initial data fetch."
          ],
          "example": "```typescript\nfunction useFetch(url, options) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true); // Initial state is true\n  const [error, setError] = useState(null);\n  // ... rest of the hook\n}\n```\nThe `loading` state is set to `true` initially because as soon as the component renders and the `useEffect` runs, the `fetchData` function will be called, meaning a fetch operation is immediately in progress.",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "MCQ"
          ],
          "prerequisites": [
            "useState"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_fetch_8",
          "topic": "useFetch Hook - Flashcard: `isMounted` vs `AbortController`",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the conceptual difference between using an `isMounted` flag and `AbortController` for handling side effects in `useEffect` when a component unmounts?",
          "answer": "`isMounted` prevents *state updates* on an unmounted component (avoiding warnings), while `AbortController` *cancels the ongoing network request* itself, saving bandwidth and resources.",
          "options": [],
          "analysisPoints": [
            "Distinguishes between preventing state updates and cancelling network requests.",
            "Highlights the resource management aspect of `AbortController`.",
            "Understands the limitations of `isMounted` (doesn't stop the actual request)."
          ],
          "keyConcepts": [
            "isMounted",
            "AbortController",
            "useEffect Cleanup",
            "Resource Management",
            "Memory Leaks"
          ],
          "evaluationCriteria": [
            "Clear understanding of two common cleanup strategies.",
            "Ability to explain their distinct purposes and benefits."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Performance",
            "Best Practices",
            "Flashcard"
          ],
          "prerequisites": [
            "useEffect",
            "Fetch API",
            "Component Lifecycle"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_fetch_9",
          "topic": "useFetch Hook - Edge Cases",
          "level": "medium",
          "type": "open",
          "question": "Describe a scenario where using the `useFetch` hook without proper memoization of its `options` argument could lead to performance issues or unexpected behavior. How would you mitigate this?",
          "answer": "Scenario: A component uses `useFetch` to post data, and its `options` object includes a `body` property that is an object. If this `options` object (or the `body` object within it) is created as a new literal on every render of the consuming component, the `useEffect` in `useFetch` will detect a new reference for `options` in its dependency array on every render. This will cause the `fetchData` function to run repeatedly, leading to an infinite loop of POST requests or excessive network activity.\n\nMitigation: The `options` object should be memoized using `useMemo`. For example:\n\n```typescript\nimport React, { useMemo } from 'react';\n// ... assume useFetch is imported\n\nfunction MyPostComponent({ dataToPost }) {\n  const memoizedOptions = useMemo(() => ({\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(dataToPost),\n  }), [dataToPost]); // Re-create only if dataToPost changes\n\n  const { data, loading, error } = useFetch('/api/submit', memoizedOptions);\n\n  // ... rest of component\n}\n```\n\nThis ensures that `memoizedOptions` only changes when `dataToPost` changes, preventing unnecessary re-fetches.",
          "analysisPoints": [
            "Identifies the problem of object reference equality in dependency arrays.",
            "Explains the cascading effect of unnecessary re-renders leading to API calls.",
            "Provides a concrete solution using `useMemo`.",
            "Demonstrates understanding of performance optimization in React hooks."
          ],
          "keyConcepts": [
            "useMemo",
            "Dependency Array",
            "Object Reference Equality",
            "Performance Optimization",
            "Infinite Loop",
            "Data Fetching"
          ],
          "evaluationCriteria": [
            "Diagnoses a common React performance bug.",
            "Applies `useMemo` correctly for object memoization.",
            "Explains the 'why' behind the solution."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Performance",
            "useMemo",
            "Interview Question"
          ],
          "prerequisites": [
            "useEffect",
            "useMemo",
            "JavaScript Object References"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_fetch_10",
          "topic": "useFetch Hook - Conditional Fetching",
          "level": "medium",
          "type": "code",
          "question": "Modify the `useFetch` hook or its usage to allow conditional fetching. The fetch request should only be made if the `url` provided is not null or an empty string. If the `url` is invalid, the hook should return `data: null`, `loading: false`, and `error: null`.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Ability to implement conditional logic within a hook's effect.",
            "Correctly managing initial state for un-fetched scenarios.",
            "Ensuring the hook still behaves correctly when `url` becomes valid later."
          ],
          "keyConcepts": [
            "Conditional Logic",
            "useEffect",
            "Custom Hooks",
            "State Management"
          ],
          "evaluationCriteria": [
            "Adds robust input validation to the hook's behavior.",
            "Maintains correct state transitions for loading/error.",
            "Handles the 'no fetch' scenario gracefully."
          ],
          "example": "```typescript\nimport { useState, useEffect } from 'react';\n\nfunction useConditionalFetch(url, options) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false); // Changed to false initially\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // Condition to prevent fetching if url is invalid\n    if (!url) {\n      setData(null);\n      setLoading(false);\n      setError(null); // Ensure error is cleared if url becomes invalid\n      return; // Do not proceed with fetch\n    }\n\n    let isMounted = true;\n\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      try {\n        const response = await fetch(url, options);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const result = await response.json();\n        if (isMounted) {\n          setData(result);\n        }\n      } catch (e) {\n        if (isMounted) {\n          setError(e.message);\n        }\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    fetchData();\n\n    return () => {\n      isMounted = false;\n    };\n  }, [url, options]);\n\n  return { data, loading, error };\n}\n\n// Usage Example:\n// function PostDetail({ postId }) {\n//   const url = postId ? `https://api.example.com/posts/${postId}` : null;\n//   const { data, loading, error } = useConditionalFetch(url);\n\n//   if (!postId) return <div>Select a post to view details.</div>; // Early exit for no postId\n//   if (loading) return <div>Loading post...</div>;\n//   if (error) return <div>Error: {error}</div>;\n//   if (!data) return <div>No post found.</div>;\n\n//   return (\n//     <div>\n//       <h3>{data.title}</h3>\n//       <p>{data.body}</p>\n//     </div>\n//   );\n// }\n```",
          "tags": [
            "React",
            "Hooks",
            "Conditional Logic",
            "Code Challenge"
          ],
          "prerequisites": [
            "useEffect",
            "Conditional Rendering"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_media_query_1",
          "topic": "useMediaQuery Hook - Fundamentals",
          "level": "easy",
          "type": "flashcard",
          "question": "What Web API is at the core of the `useMediaQuery` hook?",
          "answer": "`window.matchMedia()`",
          "options": [],
          "analysisPoints": [
            "Identifies the key Web API used for media query detection in JavaScript."
          ],
          "keyConcepts": [
            "Web API",
            "window.matchMedia",
            "useMediaQuery"
          ],
          "evaluationCriteria": [
            "Recall of essential Web APIs.",
            "Basic understanding of media query interaction with JavaScript."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Web API",
            "Flashcard"
          ],
          "prerequisites": [
            "JavaScript DOM"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_media_query_2",
          "topic": "useMediaQuery Hook - Event Handling",
          "level": "medium",
          "type": "mcq",
          "question": "The `useMediaQuery` hook uses `mediaQuery.addEventListener('change', listener)`. What is the significance of the `'change'` event here?\n\n```javascript\nfunction useMediaQuery(query) {\n  const [matches, setMatches] = useState(false);\n  useEffect(() => {\n    const mediaQuery = window.matchMedia(query);\n    setMatches(mediaQuery.matches);\n    const listener = (e) => setMatches(e.matches);\n    mediaQuery.addEventListener('change', listener);\n    return () => mediaQuery.removeEventListener('change', listener);\n  }, [query]);\n  return matches;\n}\n```",
          "answer": "It allows the hook to react dynamically when the media query condition (e.g., screen width) changes, updating the `matches` state.",
          "options": [
            "It triggers once when the component mounts to set the initial `matches` state.",
            "It is deprecated and should be replaced by a polling mechanism.",
            "It allows the hook to react dynamically when the media query condition (e.g., screen width) changes, updating the `matches` state.",
            "It fires whenever any CSS property related to the media query is modified."
          ],
          "analysisPoints": [
            "Tests understanding of event listeners and their purpose.",
            "Highlights the dynamic nature of responsive hooks.",
            "Distinguishes `change` event from initial evaluation."
          ],
          "keyConcepts": [
            "Event Listeners",
            "window.matchMedia",
            "Responsive Design",
            "useEffect"
          ],
          "evaluationCriteria": [
            "Correctly identifies the purpose of the `change` event for media queries.",
            "Understands how `useEffect` and event listeners enable dynamic behavior."
          ],
          "example": "The `'change'` event on a `MediaQueryList` object is specifically designed to fire when the evaluation result of the media query changes from `true` to `false` or vice-versa. This is essential for responsive designs where components need to react in real-time as the user resizes their browser window or rotates their device.",
          "tags": [
            "React",
            "Hooks",
            "Event Handling",
            "Responsive Design",
            "MCQ"
          ],
          "prerequisites": [
            "JavaScript Event Listeners",
            "CSS Media Queries"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_media_query_3",
          "topic": "useMediaQuery Hook - Cleanup",
          "level": "medium",
          "type": "open",
          "question": "Why is it important to include `mediaQuery.removeEventListener('change', listener);` in the cleanup function of the `useMediaQuery` hook's `useEffect`?",
          "answer": "Including `mediaQuery.removeEventListener` in the cleanup function is crucial for:\n1.  **Preventing Memory Leaks:** If the event listener is not removed when the component unmounts, the listener function (`listener`) will continue to exist in memory, potentially holding references to the component's scope. This can prevent garbage collection of the unmounted component, leading to a memory leak.\n2.  **Avoiding Unnecessary Updates:** If the component has unmounted, there's no UI to update. Continuing to listen for changes and attempting `setMatches` would be a no-op at best and could lead to warnings.\n3.  **Correct Behavior on `query` Change:** If the `query` string changes (and thus the `useEffect` re-runs), the old listener for the previous query must be removed before a new one is attached for the updated query. This ensures only one active listener per `useMediaQuery` instance.",
          "analysisPoints": [
            "Explains memory leak prevention.",
            "Highlights preventing unnecessary work on unmounted components.",
            "Addresses correct behavior when `useEffect` dependencies change."
          ],
          "keyConcepts": [
            "useEffect Cleanup",
            "Memory Leaks",
            "Event Listeners",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Thorough explanation of cleanup importance.",
            "Demonstrates understanding of `useEffect` lifecycle."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Memory Leaks",
            "Best Practices"
          ],
          "prerequisites": [
            "useEffect",
            "JavaScript Event Listeners"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_media_query_performance",
          "topic": "useMediaQuery Hook - Performance",
          "level": "medium",
          "type": "flashcard",
          "question": "Does `useMediaQuery` cause frequent re-renders? Why or why not?",
          "answer": "No, it typically does not cause *frequent* re-renders. It only triggers a re-render when the `matches` state actually changes (i.e., the media query condition transitions from true to false or vice versa), not on every pixel change during a resize.",
          "options": [],
          "analysisPoints": [
            "Understands how `useState` updates trigger re-renders.",
            "Connects this to the specific behavior of `MediaQueryList` `change` events."
          ],
          "keyConcepts": [
            "Performance",
            "Re-renders",
            "useState",
            "MediaQueryList"
          ],
          "evaluationCriteria": [
            "Evaluates performance implications of the hook.",
            "Accurate understanding of state updates and re-renders."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Performance",
            "Flashcard"
          ],
          "prerequisites": [
            "React Re-renders"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_media_query_server_side",
          "topic": "useMediaQuery Hook - SSR",
          "level": "hard",
          "type": "open",
          "question": "How would you ensure that the `useMediaQuery` hook works correctly in an application that uses Server-Side Rendering (SSR)? What potential issues might arise without special handling?",
          "answer": "On the server, `window` and `window.matchMedia` are not defined, so directly accessing them would cause runtime errors during SSR. To ensure `useMediaQuery` works correctly:\n\n**Potential Issues:**\n*   `ReferenceError: window is not defined` when the server attempts to execute the hook during the build or server render.\n*   Hydration mismatches if the initial render on the server assumes a certain media query state (e.g., desktop layout) while the client quickly evaluates to a different state (e.g., mobile layout) before hydration completes.\n\n**Mitigation:**\n1.  **Client-Side Only Execution:** The simplest approach is to check for the `window` object's existence before accessing `window.matchMedia`. If `window` is `undefined` (indicating server environment), return a default value (e.g., `false` or `true` based on a common breakpoint) or `null` and handle it in the component.\n\n    ```typescript\n    function useMediaQuery(query) {\n      const [matches, setMatches] = useState(false);\n\n      useEffect(() => {\n        if (typeof window === 'undefined') {\n          return; // Skip execution on server\n        }\n        const mediaQuery = window.matchMedia(query);\n        setMatches(mediaQuery.matches);\n        const listener = (e) => setMatches(e.matches);\n        mediaQuery.addEventListener('change', listener);\n        return () => mediaQuery.removeEventListener('change', listener);\n      }, [query]);\n\n      // For SSR, you might need a safe initial state, or null\n      // It's often paired with a separate 'isClient' state or hydration check.\n      return matches; // This initial 'false' might cause a flash of incorrect content\n    }\n    ```\n\n2.  **`useState` with a lazy initializer and `useEffect` for client-only logic:** A more robust approach sets an initial state that is SSR-safe, then updates it on the client side.\n\n    ```typescript\n    import { useState, useEffect } from 'react';\n\n    function useMediaQuerySSR(query) {\n      const [matches, setMatches] = useState(() => {\n        // Lazy initializer for initial state, runs once on server and client\n        if (typeof window === 'undefined') {\n          return false; // Default for server, e.g., assume mobile or desktop based on query\n        }\n        return window.matchMedia(query).matches;\n      });\n\n      useEffect(() => {\n        if (typeof window === 'undefined') {\n          return; // Effect only runs on client\n        }\n\n        const mediaQuery = window.matchMedia(query);\n        // We already set initial state via lazy initializer, now add listener\n        const listener = (e) => setMatches(e.matches);\n        mediaQuery.addEventListener('change', listener);\n        return () => mediaQuery.removeEventListener('change', listener);\n      }, [query]);\n\n      return matches;\n    }\n    ```\n\nThis approach avoids errors on the server and ensures that the client-side evaluation takes over after hydration. For more complex scenarios, you might use a pattern with `useEffect` that explicitly checks if the component has 'hydrated' on the client.",
          "analysisPoints": [
            "Identifies the core SSR challenge: `window` object absence.",
            "Explains `ReferenceError` and hydration mismatches.",
            "Proposes solutions using `typeof window` check.",
            "Suggests `useState` lazy initializer for initial SSR-safe state."
          ],
          "keyConcepts": [
            "SSR",
            "Hydration",
            "window object",
            "useEffect",
            "useState Lazy Initializer",
            "Cross-Platform Compatibility"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of SSR challenges with browser APIs.",
            "Ability to implement robust, cross-environment solutions.",
            "Knowledge of `useState` lazy initialization for initial render optimization."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "SSR",
            "Client-Side Rendering",
            "Performance",
            "Code Architecture"
          ],
          "prerequisites": [
            "SSR Concepts",
            "React Hydration",
            "useEffect",
            "useState"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "expert"
        },
        {
          "id": "question_use_media_query_4",
          "topic": "useMediaQuery Hook - General",
          "level": "medium",
          "type": "open",
          "question": "Beyond simple `(max-width: Xpx)` queries, what other types of media queries can be effectively used with the `useMediaQuery` hook, and for what purposes?",
          "answer": "The `useMediaQuery` hook can utilize any valid CSS media query string, opening up possibilities beyond just screen width. Examples include:\n\n*   **`'(prefers-color-scheme: dark)'`**: To detect if the user has a dark mode preference set in their OS. Useful for automatically switching themes.\n*   **`'print'`**: To apply styles or render specific content only when the page is being printed.\n*   **`'(orientation: landscape)'` or `'(orientation: portrait)'`**: To detect device orientation. Useful for adjusting layouts on tablets or phones.\n*   **`'(min-resolution: 2dppx)'` or `'(min-resolution: 192dpi)'`**: To detect high-resolution (Retina) screens. Useful for serving higher-quality images.\n*   **`'(prefers-reduced-motion)'`**: To detect if the user has requested reduced motion in their OS settings. Important for accessibility to disable animations.\n*   **`'(hover: hover)'` and `'(pointer: fine)'`**: To detect if the primary input mechanism can hover and is precise. Useful for optimizing touch vs. mouse interactions.",
          "analysisPoints": [
            "Demonstrates broad knowledge of CSS media queries.",
            "Connects media query types to practical use cases.",
            "Emphasizes accessibility and user experience."
          ],
          "keyConcepts": [
            "CSS Media Queries",
            "Responsive Design",
            "Accessibility",
            "User Experience",
            "Browser Features"
          ],
          "evaluationCriteria": [
            "Expansive knowledge of media query capabilities.",
            "Ability to relate technical features to practical applications.",
            "Awareness of modern web development best practices (e.g., accessibility)."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Responsive Design",
            "Accessibility",
            "UI/UX"
          ],
          "prerequisites": [
            "CSS Media Queries"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_media_query_5",
          "topic": "useMediaQuery Hook - Hook Return Value",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the return type of the `useMediaQuery` hook, and what does it represent?",
          "answer": "It returns a boolean (`matches`), which indicates whether the provided media query currently evaluates to true.",
          "options": [],
          "analysisPoints": [
            "Identifies the simple and intuitive return value.",
            "Understands what the boolean represents."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "Return Value",
            "Boolean Logic",
            "MediaQueryList"
          ],
          "evaluationCriteria": [
            "Recall of hook's output.",
            "Understanding of the core logic."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Flashcard"
          ],
          "prerequisites": [
            "Basic JavaScript"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_debounce_1",
          "topic": "useDebounce Hook - Purpose",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `useDebounce` hook in a React application?",
          "answer": "To delay the execution of a function or the update of a value until a certain amount of time has passed without any further triggering events.",
          "options": [],
          "analysisPoints": [
            "Defines debouncing correctly.",
            "Understands its role in event handling."
          ],
          "keyConcepts": [
            "Debounce",
            "Performance Optimization",
            "Event Handling"
          ],
          "evaluationCriteria": [
            "Recall of debouncing definition.",
            "Understanding of its application."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Debounce",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_debounce_2",
          "topic": "useDebounce Hook - Core Logic",
          "level": "medium",
          "type": "mcq",
          "question": "In the `useDebounce` hook, why is `clearTimeout(handler);` called in the `useEffect`'s cleanup function?\n\n```javascript\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  return debouncedValue;\n}\n```",
          "answer": "To cancel the previous timeout if the `value` changes before the `delay` expires, ensuring only the latest `value` is debounced.",
          "options": [
            "To prevent memory leaks from the `setTimeout` function.",
            "To reset the `debouncedValue` to its initial state.",
            "To ensure the timeout handler is correctly garbage collected.",
            "To cancel the previous timeout if the `value` changes before the `delay` expires, ensuring only the latest `value` is debounced."
          ],
          "analysisPoints": [
            "Tests understanding of `setTimeout`/`clearTimeout` interaction.",
            "Explains the core debouncing mechanism.",
            "Distinguishes `clearTimeout` from general memory leak prevention."
          ],
          "keyConcepts": [
            "Debounce",
            "setTimeout",
            "clearTimeout",
            "useEffect Cleanup",
            "Performance"
          ],
          "evaluationCriteria": [
            "Accurately describes the role of `clearTimeout` in debouncing logic.",
            "Understands the interplay between `useEffect` and timers."
          ],
          "example": "If a user types 'a', a timeout starts. If they then type 'b' before the 'a' timeout finishes, without `clearTimeout`, both 'a' and 'b' would eventually trigger an update. By calling `clearTimeout(handler)`, the 'a' timeout is cancelled, and a *new* timeout for 'ab' starts. This ensures that the action only fires after the user has truly finished typing for the specified delay.",
          "tags": [
            "React",
            "Hooks",
            "Debounce",
            "Performance",
            "MCQ"
          ],
          "prerequisites": [
            "useEffect",
            "setTimeout"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_debounce_3",
          "topic": "useDebounce Hook - Usage Example",
          "level": "medium",
          "type": "open",
          "question": "Describe a practical scenario where `useDebounce` is highly beneficial. Provide a brief conceptual outline of how you would integrate it into that scenario.",
          "answer": "A highly beneficial scenario for `useDebounce` is an **auto-suggest search bar** that fetches suggestions from an API.\n\n**Problem:** Without debouncing, every keystroke in the search input would trigger an immediate API call. This leads to an excessive number of requests, unnecessary network traffic, potential rate limiting, and a poor user experience (flickering suggestions).\n\n**Integration Outline:**\n1.  **Input State:** Use `useState` to manage the immediate `searchTerm` from the input field (e.g., `const [searchTerm, setSearchTerm] = useState('');`).\n2.  **Debounced Value:** Use `const debouncedSearchTerm = useDebounce(searchTerm, 300);` (300ms is a common delay) to get the debounced version of the search term.\n3.  **API Call Effect:** Use a `useEffect` hook that has `debouncedSearchTerm` in its dependency array. This `useEffect` will contain the logic to make the API call to fetch suggestions.\n    ```typescript\n    useEffect(() => {\n      if (debouncedSearchTerm) {\n        // Make API call using debouncedSearchTerm\n        console.log(`Fetching suggestions for: ${debouncedSearchTerm}`);\n      } else {\n        // Clear suggestions if input is empty\n        console.log('Clearing suggestions');\n      }\n    }, [debouncedSearchTerm]);\n    ```\n\n**Benefit:** The API call will only be triggered after the user pauses typing for 300ms. If they type quickly, intermediate keystrokes will not trigger new requests, saving resources and providing a smoother experience.",
          "analysisPoints": [
            "Identifies a clear and common use case (search bar).",
            "Explains the problem solved by debouncing.",
            "Outlines the integration steps with specific React hooks.",
            "Articulates the practical benefits for performance and UX."
          ],
          "keyConcepts": [
            "Debounce",
            "Search Bar",
            "API Integration",
            "Performance Optimization",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Provides a relevant and detailed example.",
            "Demonstrates practical application of the hook.",
            "Clearly explains the 'before' and 'after' scenario."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Performance",
            "Real-world",
            "Interview Question"
          ],
          "prerequisites": [
            "useState",
            "useEffect",
            "API Concepts"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_debounce_4",
          "topic": "useDebounce Hook - Dependencies",
          "level": "easy",
          "type": "flashcard",
          "question": "Why are `value` and `delay` included in the dependency array of the `useDebounce` hook's `useEffect`?",
          "answer": "`value` is included so that the debounced value is updated whenever the input value changes. `delay` is included so that the debounce timer is reset if the delay duration itself changes.",
          "options": [],
          "analysisPoints": [
            "Understands how `useEffect` dependencies control re-execution.",
            "Recognizes the importance of both arguments to the debouncing logic."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Debounce"
          ],
          "evaluationCriteria": [
            "Correctly identifies the purpose of each dependency.",
            "Shows understanding of `useEffect` re-run conditions."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Flashcard"
          ],
          "prerequisites": [
            "useEffect"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_debounce_throttle_diff",
          "topic": "Debounce vs. Throttling",
          "level": "hard",
          "type": "open",
          "question": "Explain the difference between debouncing and throttling, and provide a scenario where each would be more appropriate.",
          "answer": "**Debouncing** delays the execution of a function until a certain amount of time has passed without any further calls. It ensures that a function is only called *after* a period of inactivity. If the function is called again within the delay, the timer is reset.\n*   **Scenario for Debouncing:** A search input field. You want to send an API request to fetch suggestions only after the user has stopped typing for, say, 300ms. This prevents an API call on every keystroke, reducing server load and unnecessary rendering.\n\n**Throttling** limits the execution of a function to at most once in a given time period. It ensures that a function is called regularly, but not more often than a specified frequency.\n*   **Scenario for Throttling:** A window resize event handler. You want to recalculate layout or perform heavy DOM manipulations during a window resize, but only every 100ms. This prevents the function from firing hundreds of times per second during a continuous resize, improving performance without missing too many intermediate states.\n\n**Key Difference:**\n*   **Debounce:** \"Wait until I'm done typing, then do something.\" (Executes *after* inactivity)\n*   **Throttle:** \"Do something, but no more than once every X milliseconds.\" (Executes *at most* every X milliseconds)",
          "analysisPoints": [
            "Clearly defines both debouncing and throttling.",
            "Provides distinct and appropriate real-world scenarios for each.",
            "Highlights the fundamental difference in their execution patterns.",
            "Demonstrates understanding of performance optimization strategies."
          ],
          "keyConcepts": [
            "Debounce",
            "Throttling",
            "Performance Optimization",
            "Event Handling",
            "Timers"
          ],
          "evaluationCriteria": [
            "Accurate and concise definitions.",
            "Relevant and illustrative examples.",
            "Clear articulation of the core distinction."
          ],
          "example": "",
          "tags": [
            "JavaScript",
            "Performance",
            "Algorithms",
            "Interview Question"
          ],
          "prerequisites": [
            "setTimeout",
            "Event Handling"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_debounce_real_world",
          "topic": "useDebounce Hook - Real-world Applications",
          "level": "medium",
          "type": "open",
          "question": "Beyond a search bar, name two other real-world scenarios where `useDebounce` or debouncing logic would be beneficial and explain why.",
          "answer": "1.  **Saving Form Data/Auto-saving Drafts:**\n    *   **Scenario:** A text editor or a complex form where data needs to be saved to a backend API frequently, but you don't want to save on every keystroke or every minor change.\n    *   **Why Debounce:** Debouncing the save function (e.g., by 1-2 seconds) ensures that the save operation only triggers after the user has paused typing or modifying content for that duration. This prevents a flood of save requests, reduces server load, and improves responsiveness by not constantly interrupting the user's input with save operations.\n\n2.  **Validating Input Fields (Client-side):**\n    *   **Scenario:** An email input field that needs to validate the email format or check for availability against a database.\n    *   **Why Debounce:** Instead of validating on every keystroke, debouncing the validation logic (e.g., by 500ms) allows the user to finish typing their email address before the validation function is called. This avoids showing premature error messages (e.g., 'Invalid email format' after just typing 'a') and reduces the number of database/API calls for availability checks, making the UI feel smoother and less intrusive.",
          "analysisPoints": [
            "Provides diverse real-world examples.",
            "Explains the specific problem solved by debouncing in each scenario.",
            "Connects to UX improvements and resource optimization."
          ],
          "keyConcepts": [
            "Debounce",
            "Form Validation",
            "Auto-save",
            "Performance",
            "User Experience"
          ],
          "evaluationCriteria": [
            "Creative and relevant application of debouncing.",
            "Clear justification for its use in each scenario."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Performance",
            "Real-world",
            "UX"
          ],
          "prerequisites": [],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_use_fetch_1",
          "title": "Build a useFetch Hook with Caching and Retry Logic",
          "description": "\nImplement an enhanced `useFetch` hook that includes:\n\n1.  **Basic Fetching:** Retain the core functionality to fetch `data`, `loading`, and `error` states.\n2.  **In-Memory Caching:** Implement a simple in-memory cache for GET requests. If a request for the same URL has been made recently (e.g., within the last 5 minutes), return the cached data instantly. The cache should be cleared after a configurable time.\n3.  **Retry Mechanism:** If a fetch request fails due to a network error (e.g., `TypeError: Failed to fetch` or a 5xx status code), implement a retry mechanism that attempts the request up to 3 times with a delay (e.g., 500ms, 1000ms, 2000ms) between retries.\n4.  **AbortController Integration:** Ensure ongoing requests can be safely aborted if the component unmounts or a new request is initiated (e.g., URL changes). You can combine this with the `isMounted` flag for state updates.\n\nYour solution should be robust and handle various network conditions gracefully.\n",
          "difficulty": "hard",
          "startingCode": "import { useState, useEffect, useRef, useCallback } from 'react';\n\n// A simple in-memory cache map\nconst cache = new Map();\n\nfunction useFetchEnhanced(url, options = {}, cacheDuration = 300000) { // cacheDuration in ms (5 minutes default)\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const abortControllerRef = useRef(null);\n\n  const fetchData = useCallback(async (retries = 0) => {\n    if (!url) {\n      setData(null);\n      setLoading(false);\n      setError(null);\n      return;\n    }\n\n    // 1. Abort any ongoing request\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    const controller = new AbortController();\n    abortControllerRef.current = controller;\n    const signal = controller.signal;\n\n    // 2. Check cache for GET requests\n    if (options.method === 'GET' || !options.method) {\n      const cached = cache.get(url);\n      if (cached && (Date.now() - cached.timestamp < cacheDuration)) {\n        setData(cached.data);\n        setLoading(false);\n        setError(null);\n        console.log(`Cache hit for ${url}`);\n        return; // Return cached data instantly\n      }\n    }\n\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const response = await fetch(url, { ...options, signal });\n\n      if (!response.ok) {\n        // Handle HTTP errors for retry\n        if (response.status >= 500 && retries < 3) {\n          const retryDelay = [500, 1000, 2000][retries];\n          console.warn(`Fetch failed for ${url}, retrying in ${retryDelay}ms... (Attempt ${retries + 1})`);\n          await new Promise(resolve => setTimeout(resolve, retryDelay));\n          return fetchData(retries + 1); // Retry recursively\n        }\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const result = await response.json();\n      setData(result);\n      \n      // Cache successful GET requests\n      if (options.method === 'GET' || !options.method) {\n        cache.set(url, { data: result, timestamp: Date.now() });\n        setTimeout(() => cache.delete(url), cacheDuration); // Clear cache after duration\n      }\n\n    } catch (e) {\n      if (e.name === 'AbortError') {\n        console.log('Fetch aborted');\n        return; // Do not set error for aborted requests\n      }\n      // Handle network errors for retry\n      if (e instanceof TypeError && e.message === 'Failed to fetch' && retries < 3) {\n        const retryDelay = [500, 1000, 2000][retries];\n        console.warn(`Network error for ${url}, retrying in ${retryDelay}ms... (Attempt ${retries + 1})`);\n        await new Promise(resolve => setTimeout(resolve, retryDelay));\n        return fetchData(retries + 1); // Retry recursively\n      }\n      setError(e.message);\n    } finally {\n      setLoading(false);\n      abortControllerRef.current = null; // Clear controller once request is done/aborted\n    }\n  }, [url, options, cacheDuration]); // Dependencies for fetchData\n\n  useEffect(() => {\n    let isMounted = true;\n    // Helper function to call fetchData and ensure state updates only on mounted component\n    const safeFetch = async () => {\n      await fetchData();\n      // No explicit isMounted checks needed for setData/setError/setLoading\n      // because fetchData itself directly sets state only if not aborted.\n      // However, for the initial state transition (loading=true), we do it outside.\n    }\n\n    safeFetch();\n\n    return () => {\n      isMounted = false;\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort(); // Abort on unmount\n      }\n    };\n  }, [fetchData]); // Dependency on memoized fetchData\n\n  return { data, loading, error };\n}\n\n// Example Usage (for testing):\n// function TestComponent() {\n//   const [userId, setUserId] = useState(1);\n//   const { data, loading, error } = useFetchEnhanced(`https://jsonplaceholder.typicode.com/users/${userId}`);\n\n//   return (\n//     <div>\n//       <button onClick={() => setUserId(prev => prev + 1)}>Next User</button>\n//       {loading && <p>Loading user {userId}...</p>}\n//       {error && <p style={{ color: 'red' }}>Error: {error}</p>}\n//       {data && (\n//         <div>\n//           <h3>User: {data.name}</h3>\n//           <p>Email: {data.email}</p>\n//         </div>\n//       )}\n//     </div>\n//   );\n// }\n",
          "solutionCode": "import { useState, useEffect, useRef, useCallback } from 'react';\n\n// A simple in-memory cache map\nconst cache = new Map();\n\nfunction useFetchEnhanced(url, options = {}, cacheDuration = 300000) { // cacheDuration in ms (5 minutes default)\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const abortControllerRef = useRef(null); // Ref to store AbortController instance\n\n  // Using useCallback to memoize fetchData to prevent infinite loops in useEffect dependencies\n  const fetchData = useCallback(async (retries = 0) => {\n    // If URL is invalid, reset state and exit\n    if (!url) {\n      setData(null);\n      setLoading(false);\n      setError(null);\n      return;\n    }\n\n    // Abort any ongoing request before starting a new one\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    const controller = new AbortController();\n    abortControllerRef.current = controller;\n    const signal = controller.signal;\n\n    // Implement in-memory caching for GET requests\n    if (options.method === 'GET' || !options.method) {\n      const cached = cache.get(url);\n      if (cached && (Date.now() - cached.timestamp < cacheDuration)) {\n        setData(cached.data);\n        setLoading(false);\n        setError(null);\n        console.log(`useFetchEnhanced: Cache hit for ${url}`);\n        return; // Return cached data instantly\n      }\n    }\n\n    setLoading(true); // Start loading\n    setError(null); // Clear previous errors\n    \n    try {\n      const response = await fetch(url, { ...options, signal });\n\n      // Check for HTTP errors (e.g., 5xx for retries, others for immediate error)\n      if (!response.ok) {\n        // Retry mechanism for server errors (5xx) and network errors\n        if (response.status >= 500 && retries < 3) {\n          const retryDelay = [500, 1000, 2000][retries];\n          console.warn(`useFetchEnhanced: HTTP Error ${response.status} for ${url}, retrying in ${retryDelay}ms... (Attempt ${retries + 1})`);\n          await new Promise(resolve => setTimeout(resolve, retryDelay));\n          return fetchData(retries + 1); // Recursive retry\n        }\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const result = await response.json();\n      setData(result);\n      \n      // Cache successful GET requests with a timestamp and auto-clear\n      if (options.method === 'GET' || !options.method) {\n        cache.set(url, { data: result, timestamp: Date.now() });\n        // Set a timeout to clear this specific cache entry after cacheDuration\n        setTimeout(() => {\n          if (cache.get(url) && cache.get(url).timestamp === cache.get(url).timestamp) { // Only clear if it's the same entry\n            cache.delete(url);\n            console.log(`useFetchEnhanced: Cache cleared for ${url}`);\n          }\n        }, cacheDuration);\n      }\n\n    } catch (e) {\n      if (e.name === 'AbortError') {\n        console.log('useFetchEnhanced: Fetch aborted');\n        return; // Do not set error or loading state for aborted requests\n      }\n      \n      // Retry mechanism for network errors (e.g., 'Failed to fetch')\n      if (e instanceof TypeError && (e.message === 'Failed to fetch' || e.message.includes('network')) && retries < 3) {\n        const retryDelay = [500, 1000, 2000][retries];\n        console.warn(`useFetchEnhanced: Network error for ${url}, retrying in ${retryDelay}ms... (Attempt ${retries + 1})`);\n        await new Promise(resolve => setTimeout(resolve, retryDelay));\n        return fetchData(retries + 1); // Recursive retry\n      }\n      setError(e.message);\n    } finally {\n      setLoading(false); // Stop loading regardless of success or failure\n      abortControllerRef.current = null; // Clear controller ref as request is complete or aborted\n    }\n  }, [url, options, cacheDuration]); // Dependencies for useCallback\n\n  // useEffect to trigger fetch on mount and when dependencies (url, options) change\n  useEffect(() => {\n    // No `isMounted` flag needed with AbortController if state updates are always guarded by `if (!signal.aborted) { ... }`\n    // However, the `isMounted` pattern is safer if you're not fully certain all async paths respect `signal.aborted`.\n    // In this specific implementation, all state updates are within the `fetchData` function,\n    // which is guarded by `if (e.name === 'AbortError') return;`, so it's implicitly handled.\n    \n    fetchData(); // Execute fetch logic\n\n    // Cleanup function: Abort ongoing request if component unmounts or dependencies change\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, [fetchData]); // Dependency on the memoized fetchData function\n\n  return { data, loading, error };\n}\n\n// Example Usage:\n// function UserProfileWithCacheAndRetry({ userId }) {\n//   const url = userId ? `https://jsonplaceholder.typicode.com/users/${userId}` : null;\n//   const { data, loading, error } = useFetchEnhanced(url);\n\n//   if (!userId) return <div>Enter a user ID.</div>;\n//   if (loading) return <div>Loading user {userId}...</div>;\n//   if (error) return <div style={{ color: 'red' }}>Error: {error}</div>;\n//   if (!data) return <div>No user data found.</div>;\n\n//   return (\n//     <div>\n//       <h2>{data.name}</h2>\n//       <p>Email: {data.email}</p>\n//       <p>Phone: {data.phone}</p>\n//     </div>\n//   );\n// }\n\n// function App() {\n//   const [currentUserId, setCurrentUserId] = useState(1);\n\n//   return (\n//     <div>\n//       <h1>Enhanced Fetch Example</h1>\n//       <button onClick={() => setCurrentUserId(prev => (prev % 10) + 1)}>Next User</button>\n//       <button onClick={() => setCurrentUserId(999)}>Fetch Non-existent User (for error/retry test)</button>\n//       <UserProfileWithCacheAndRetry userId={currentUserId} />\n//     </div>\n//   );\n// }\n",
          "testCases": [
            "Test with valid URL: Should fetch data and set `loading` to `false`, `error` to `null`.",
            "Test with invalid URL (e.g., 404): Should set `error` and `loading` to `false`.",
            "Test cache hit: Fetch the same URL twice within `cacheDuration`. The second call should return data instantly without `loading` state transition.",
            "Test cache miss: Fetch the same URL after `cacheDuration`. Should re-fetch data.",
            "Test retry mechanism (simulate 500 error): Mock `fetch` to return 500 for first 2 calls, then 200. Should show loading, retry messages, then success.",
            "Test retry mechanism (simulate network error): Mock `fetch` to throw `TypeError` for first 2 calls, then success. Should show loading, retry messages, then success.",
            "Test component unmount during fetch: Ensure no state updates are attempted on unmounted component (no React warnings).",
            "Test URL change during fetch: Ensure previous request is aborted and new one initiated correctly.",
            "Test with null URL: Should return `data: null`, `loading: false`, `error: null`.",
            "Test with POST request (should not cache): Ensure POST requests are never cached."
          ],
          "hints": [
            "Use a `Map` object for the in-memory cache. Store `data` and `timestamp`.",
            "The `AbortController` should be created and referenced for each `fetch` call.",
            "For retry logic, you can make `fetchData` a `useCallback` that accepts a `retries` parameter and calls itself recursively.",
            "Remember to clear the `setTimeout` for cache expiration if the data is re-fetched or component unmounts before the timer runs out.",
            "Carefully manage `loading` and `error` states in all fetch outcomes (success, error, abort, cache hit)."
          ],
          "tags": [
            "React",
            "Hooks",
            "Data Fetching",
            "Caching",
            "Retry Logic",
            "AbortController",
            "Performance",
            "Advanced"
          ],
          "timeEstimate": 120,
          "prerequisites": [
            "useFetch Hook (basic)",
            "Promises",
            "Async/Await",
            "Fetch API",
            "AbortController",
            "useCallback",
            "Error Handling"
          ],
          "complexity": 9,
          "interviewRelevance": 9,
          "learningPath": "expert",
          "relatedConcepts": [
            "useFetch Hook",
            "Fetch API",
            "AbortController",
            "Cache Management",
            "Error Handling Patterns",
            "Retry Patterns"
          ]
        },
        {
          "id": "task_use_media_query_1",
          "title": "Build a useBreakpoints Hook for Themed Responsive Design",
          "description": "\nCreate a custom hook `useBreakpoints` that simplifies responsive design by allowing components to query against a predefined set of named breakpoints (similar to design systems like Material-UI or Bootstrap).\n\n**Requirements:**\n1.  The hook should accept an object of named breakpoints (e.g., `{ xs: 0, sm: 600, md: 960, lg: 1280, xl: 1920 }`).\n2.  It should return an object with boolean flags for each breakpoint, indicating whether the current viewport width is at or above that breakpoint. For example, ` { sm: true, md: false, lg: false }` if the screen is between `sm` and `md`.\n3.  It should also return the `currentBreakpoint` as a string (e.g., 'sm', 'md'), representing the *largest* breakpoint that is currently matched.\n4.  The hook must react dynamically to window resizing.\n5.  Handle Server-Side Rendering (SSR) safely by providing a default initial state or handling `window` object absence.\n",
          "difficulty": "medium",
          "startingCode": "import { useState, useEffect } from 'react';\n\nconst defaultBreakpoints = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1280,\n  xl: 1920,\n};\n\nfunction useBreakpoints(breakpoints = defaultBreakpoints) {\n  const sortedBreakpoints = Object.entries(breakpoints)\n    .sort(([, valA], [, valB]) => valA - valB);\n\n  const getMatches = () => {\n    if (typeof window === 'undefined') {\n      // Provide a default for SSR, e.g., assume 'xs' or 'md'\n      return {\n        matches: Object.fromEntries(sortedBreakpoints.map(([key]) => [key, false])),\n        current: 'xs' // Default to smallest for SSR or specific initial assumption\n      };\n    }\n\n    const currentWidth = window.innerWidth;\n    let currentBreakpoint = 'xs'; // Default to smallest\n    const matches = {};\n\n    for (let i = 0; i < sortedBreakpoints.length; i++) {\n      const [name, value] = sortedBreakpoints[i];\n      if (currentWidth >= value) {\n        matches[name] = true;\n        currentBreakpoint = name;\n      } else {\n        matches[name] = false;\n      }\n    }\n    return { matches, current: currentBreakpoint };\n  };\n\n  const [state, setState] = useState(getMatches);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    const handleResize = () => {\n      setState(getMatches());\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, [breakpoints]); // Re-run effect if breakpoints object changes\n\n  return { ...state.matches, current: state.current };\n}\n\n// Usage Example:\n// function ResponsiveDisplay() {\n//   const { xs, sm, md, lg, xl, current } = useBreakpoints();\n\n//   return (\n//     <div>\n//       <p>Current Breakpoint: {current}</p>\n//       {xs && <p>I am on an extra small screen or larger.</p>}\n//       {sm && <p>I am on a small screen or larger.</p>}\n//       {md && <p>I am on a medium screen or larger.</p>}\n//       {lg && <p>I am on a large screen or larger.</p>}\n//       {xl && <p>I am on an extra large screen or larger.</p>}\n//       {current === 'sm' && <p style={{ fontWeight: 'bold' }}>Specifically small screen!</p>}\n//     </div>\n//   );\n// }\n",
          "solutionCode": "import { useState, useEffect, useMemo } from 'react';\n\nconst defaultBreakpoints = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1280,\n  xl: 1920,\n};\n\nfunction useBreakpoints(breakpoints = defaultBreakpoints) {\n  // Memoize sorted breakpoints to avoid re-sorting on every render\n  const sortedBreakpoints = useMemo(() => \n    Object.entries(breakpoints)\n      .sort(([, valA], [, valB]) => valA - valB)\n  , [breakpoints]);\n\n  const getBreakpointState = useCallback(() => {\n    if (typeof window === 'undefined') {\n      // Default state for SSR: assume 'xs' matched, all others false.\n      // This provides a consistent initial render that can then hydrate.\n      const initialMatches = {};\n      sortedBreakpoints.forEach(([key]) => {\n        initialMatches[key] = (key === 'xs'); // Assuming 'xs' is 0 or smallest\n      });\n      return {\n        matches: initialMatches,\n        current: 'xs' \n      };\n    }\n\n    const currentWidth = window.innerWidth;\n    let currentBreakpoint = 'xs'; // Initialize with the smallest breakpoint name\n    const matches = {};\n\n    // Iterate through sorted breakpoints to determine matches and the largest matched breakpoint\n    for (let i = 0; i < sortedBreakpoints.length; i++) {\n      const [name, value] = sortedBreakpoints[i];\n      if (currentWidth >= value) {\n        matches[name] = true;\n        currentBreakpoint = name; // Update currentBreakpoint if this one matches\n      } else {\n        matches[name] = false;\n      }\n    }\n    return { matches, current: currentBreakpoint };\n  }, [sortedBreakpoints]); // getBreakpointState depends on sortedBreakpoints\n\n  // Use lazy initializer for initial state, and then update via effect\n  const [state, setState] = useState(getBreakpointState);\n\n  useEffect(() => {\n    // Only run event listener logic on the client-side\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    const handleResize = () => {\n      setState(getBreakpointState());\n    };\n\n    // Add event listener for window resize\n    window.addEventListener('resize', handleResize);\n    \n    // Initial state update on client-side might be needed if SSR default was wrong\n    // or for clients where JS is enabled before hydration.\n    // setState(getBreakpointState()); // Can cause hydration mismatch if not carefully handled with specific SSR patterns\n                                    // Better to rely on initial lazy state and event listener for subsequent changes.\n\n    // Cleanup function: remove event listener\n    return () => window.removeEventListener('resize', handleResize);\n  }, [getBreakpointState]); // Effect depends on memoized getBreakpointState\n\n  // Return individual breakpoint flags and the current breakpoint name\n  return { ...state.matches, current: state.current };\n}\n\n// Usage Example:\n// function ResponsiveHeader() {\n//   const { sm, md, lg, current } = useBreakpoints({\n//     phone: 0,\n//     tablet: 768,\n//     desktop: 1024,\n//   });\n\n//   const HeaderContent = () => {\n//     if (lg) return <h1>Desktop Header</h1>;\n//     if (md) return <h2>Tablet Header</h2>;\n//     if (sm) return <h3>Phone Header (Landscape)</h3>;\n//     return <h4>Phone Header (Portrait)</h4>;\n//   };\n\n//   return (\n//     <header style={{ padding: '20px', background: '#eee' }}>\n//       {HeaderContent()}\n//       <p>Current active breakpoint: {current}</p>\n//     </header>\n//   );\n// }\n",
          "testCases": [
            "Test with various window widths: Verify correct boolean flags for `sm`, `md`, `lg`, etc. (e.g., if width is 700px, `sm` should be true, `md` false).",
            "Test `currentBreakpoint`: Verify `current` correctly returns the largest matched breakpoint name.",
            "Test resizing window: Ensure the hook dynamically updates `matches` and `current` properties.",
            "Test with custom breakpoints: Provide a different breakpoint object and ensure it works correctly.",
            "Test SSR safety: Run in a Node.js environment (e.g., Jest with `window` undefined) and confirm no errors occur, and initial values are as expected for `xs`.",
            "Test `useMemo` and `useCallback` efficiency: Ensure `getBreakpointState` and `sortedBreakpoints` are not re-created unnecessarily.",
            "Test with window width exactly at a breakpoint (e.g., 600px): Ensure it matches that breakpoint and above.",
            "Test with very small width (e.g., 300px): Should match only 'xs'."
          ],
          "hints": [
            "Sort the breakpoints from smallest to largest to correctly determine the `currentBreakpoint`.",
            "Use `window.innerWidth` to get the current viewport width.",
            "Remember to use `useCallback` for `getBreakpointState` and `useMemo` for `sortedBreakpoints` to optimize performance and prevent unnecessary re-runs of `useEffect`.",
            "For SSR, check `typeof window === 'undefined'` at the beginning of your effect and state initializer to avoid errors.",
            "The `currentBreakpoint` should be the largest breakpoint whose value is less than or equal to `window.innerWidth`."
          ],
          "tags": [
            "React",
            "Hooks",
            "Responsive Design",
            "Media Queries",
            "SSR",
            "Performance",
            "Theming"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "useMediaQuery Hook (basic)",
            "useEffect",
            "useState",
            "useMemo",
            "useCallback",
            "SSR Concepts",
            "JavaScript Object Manipulation"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "CSS Media Queries",
            "Responsive Web Design",
            "SSR Hydration",
            "React Performance Optimization"
          ]
        },
        {
          "id": "task_use_debounce_1",
          "title": "Implement a Debounced Search Input with API Integration",
          "description": "\nCreate a React component that features a search input. When the user types, it should use the `useDebounce` hook to delay fetching search results from a mock API until the user has paused typing for a specified duration.\n\n**Requirements:**\n1.  **Search Input:** A basic text input where users can type their search query.\n2.  **Debounced Search Term:** Use the provided `useDebounce` hook (or re-implement it) with a configurable delay (e.g., 500ms).\n3.  **Mock API Call:** Simulate an API call using `setTimeout` (e.g., 300ms) that returns mock search results based on the debounced search term. The mock API should simulate fetching data and can return an empty array if no matches.\n4.  **Loading State:** Display a 'Loading...' indicator while the mock API call is in progress.\n5.  **Display Results:** Render the search results below the input. If no results, display 'No results found.'\n6.  **Clear Search:** Implement a way to clear the search input and results.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// --- useDebounce Hook (Provided for convenience or re-implement) ---\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  return debouncedValue;\n}\n// ------------------------------------------------------------------\n\n// Mock API data\nconst MOCK_DATA = [\n  'Apple', 'Banana', 'Cherry', 'Date', 'Elderberry',\n  'Fig', 'Grape', 'Honeydew', 'Kiwi', 'Lemon',\n  'Mango', 'Nectarine', 'Orange', 'Papaya', 'Quince'\n];\n\n// Mock API function\nconst searchApi = (query) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      const results = MOCK_DATA.filter(item =>\n        item.toLowerCase().includes(query.toLowerCase())\n      );\n      resolve(results);\n    }, 300); // Simulate network delay\n  });\n};\n\nfunction DebouncedSearchComponent() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const debouncedSearchTerm = useDebounce(searchTerm, 500);\n  const [searchResults, setSearchResults] = useState([]);\n  const [loading, setLoading] = useState(false);\n\n  // TODO: Implement useEffect to call searchApi when debouncedSearchTerm changes\n  // Handle loading state and set searchResults\n\n  const handleClear = () => {\n    setSearchTerm('');\n    setSearchResults([]);\n    setLoading(false);\n  };\n\n  return (\n    <div style={{ padding: '20px', maxWidth: '500px', margin: '0 auto' }}>\n      <h2>Fruit Search</h2>\n      <input\n        type=\"text\"\n        placeholder=\"Search fruits...\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        style={{ width: '100%', padding: '10px', fontSize: '16px' }}\n      />\n      <button onClick={handleClear} style={{ marginTop: '10px' }}>\n        Clear Search\n      </button>\n\n      {loading && <p>Loading results...</p>}\n\n      {!loading && searchResults.length > 0 && (\n        <ul style={{ listStyleType: 'none', padding: 0 }}>\n          {searchResults.map((result, index) => (\n            <li key={index} style={{ padding: '8px 0', borderBottom: '1px solid #eee' }}>\n              {result}\n            </li>\n          ))}\n        </ul>\n      )}\n\n      {!loading && searchTerm && searchResults.length === 0 && (\n        <p>No results found for \"{searchTerm}\".</p>\n      )}\n      \n      {!searchTerm && !loading && searchResults.length === 0 && (\n        <p>Start typing to search.</p>\n      )}\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// --- useDebounce Hook ---\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  \n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    \n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  \n  return debouncedValue;\n}\n// ------------------------\n\n// Mock API data\nconst MOCK_DATA = [\n  'Apple', 'Banana', 'Cherry', 'Date', 'Elderberry',\n  'Fig', 'Grape', 'Honeydew', 'Kiwi', 'Lemon',\n  'Mango', 'Nectarine', 'Orange', 'Papaya', 'Quince'\n];\n\n// Mock API function\nconst searchApi = (query) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      if (!query) {\n        resolve([]); // If query is empty, return no results\n        return;\n      }\n      const results = MOCK_DATA.filter(item =>\n        item.toLowerCase().includes(query.toLowerCase())\n      );\n      resolve(results);\n    }, 300); // Simulate network delay\n  });\n};\n\nfunction DebouncedSearchComponent() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const debouncedSearchTerm = useDebounce(searchTerm, 500); // 500ms debounce delay\n  const [searchResults, setSearchResults] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null); // Added error state for robustness\n\n  useEffect(() => {\n    // Only perform search if debouncedSearchTerm is not empty\n    if (debouncedSearchTerm) {\n      setLoading(true);\n      setError(null);\n      searchApi(debouncedSearchTerm)\n        .then(results => {\n          setSearchResults(results);\n        })\n        .catch(err => {\n          console.error(\"Search API error:\", err);\n          setError(\"Failed to fetch search results.\");\n          setSearchResults([]);\n        })\n        .finally(() => {\n          setLoading(false);\n        });\n    } else {\n      setSearchResults([]); // Clear results if search term is empty\n      setLoading(false); // Ensure loading is false\n      setError(null); // Clear errors\n    }\n  }, [debouncedSearchTerm]); // Effect runs only when debouncedSearchTerm changes\n\n  const handleClear = () => {\n    setSearchTerm('');\n    setSearchResults([]);\n    setLoading(false);\n    setError(null);\n  };\n\n  return (\n    <div style={{ padding: '20px', maxWidth: '500px', margin: '0 auto', fontFamily: 'Arial, sans-serif' }}>\n      <h2>Fruit Search</h2>\n      <input\n        type=\"text\"\n        placeholder=\"Search fruits...\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        style={{ width: '100%', padding: '10px', fontSize: '16px', border: '1px solid #ccc', borderRadius: '4px' }}\n      />\n      <button \n        onClick={handleClear} \n        style={{ marginTop: '10px', padding: '8px 15px', fontSize: '14px', cursor: 'pointer', background: '#f0f0f0', border: '1px solid #ddd', borderRadius: '4px' }}\n      >\n        Clear Search\n      </button>\n\n      {loading && searchTerm && <p style={{ color: '#007bff' }}>Loading results for \"{debouncedSearchTerm}\"...</p>}\n      {error && <p style={{ color: 'red' }}>Error: {error}</p>}\n\n      {!loading && !error && searchResults.length > 0 && (\n        <ul style={{ listStyleType: 'none', padding: 0, borderTop: '1px solid #eee', marginTop: '15px' }}>\n          {searchResults.map((result, index) => (\n            <li key={index} style={{ padding: '10px 0', borderBottom: '1px solid #eee' }}>\n              {result}\n            </li>\n          ))}\n        </ul>\n      )}\n\n      {!loading && !error && debouncedSearchTerm && searchResults.length === 0 && (\n        <p style={{ color: '#555' }}>No results found for \"{debouncedSearchTerm}\".</p>\n      )}\n      \n      {!searchTerm && !loading && !error && searchResults.length === 0 && (\n        <p style={{ color: '#777' }}>Start typing to search.</p>\n      )}\n    </div>\n  );\n}\n\nexport default DebouncedSearchComponent;\n",
          "testCases": [
            "Test typing quickly: Observe that the mock API call (console log) is delayed until typing pauses, and only the final term triggers the fetch.",
            "Test typing slowly: Observe that each pause triggers a fetch for the current term.",
            "Test empty input: Clear the input and ensure results are cleared and no API call is made.",
            "Test specific search terms: 'Apple', 'Orange', 'berry' (should return 'Elderberry' and 'Cherry').",
            "Test for non-existent terms: 'xyz' (should return 'No results found').",
            "Test loading indicator: Ensure 'Loading...' appears only when an API call is active.",
            "Test clearing search: Click 'Clear Search' button and ensure input and results reset.",
            "Test `useDebounce` delay: Change delay to 1000ms and observe longer pauses required."
          ],
          "hints": [
            "The `useEffect` that calls `searchApi` should have `debouncedSearchTerm` in its dependency array.",
            "Make sure to set `loading` to `true` before the API call and `false` in the `finally` block of the promise.",
            "Handle the case where `debouncedSearchTerm` is empty (e.g., when the input is cleared) by not making an API call and clearing previous results."
          ],
          "tags": [
            "React",
            "Hooks",
            "Debounce",
            "Performance",
            "API Integration",
            "UI/UX",
            "Search"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "useDebounce Hook",
            "useState",
            "useEffect",
            "Promises"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Debouncing",
            "Throttling",
            "Asynchronous Operations",
            "Search Filtering"
          ]
        },
        {
          "id": "task_use_debounce_2",
          "title": "Build a Debounced Window Resize Listener",
          "description": "\nCreate a React component that displays the current window width and height, but updates these values only after the user stops resizing the window for a short period.\n\n**Requirements:**\n1.  **Display Dimensions:** Show `window.innerWidth` and `window.innerHeight` in a component.\n2.  **Debounced Update:** Use the `useDebounce` hook (or re-implement it) to debounce the window's `resize` event. The dimensions should update only after a configurable `delay` (e.g., 200ms) of no further resizing activity.\n3.  **Initial Display:** The component should show the current window dimensions immediately on mount, before any resize events.\n4.  **Cleanup:** Ensure the event listener is properly removed when the component unmounts.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// --- useDebounce Hook (Provided for convenience or re-implement) ---\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  return debouncedValue;\n}\n// ------------------------------------------------------------------\n\nfunction DebouncedResizeDisplay() {\n  const [windowDimensions, setWindowDimensions] = useState(() => ({\n    width: typeof window !== 'undefined' ? window.innerWidth : 0,\n    height: typeof window !== 'undefined' ? window.innerHeight : 0,\n  }));\n\n  // TODO: Implement useEffect to listen to window 'resize' events\n  // Update a 'raw' dimension state immediately on resize\n  // Use useDebounce on this raw state to get debounced dimensions\n  // Display the debounced dimensions\n\n  return (\n    <div style={{ padding: '20px', fontFamily: 'Arial, sans-serif' }}>\n      <h2>Debounced Window Resizer</h2>\n      <p>Raw Window Width: {windowDimensions.width}px</p>\n      <p>Raw Window Height: {windowDimensions.height}px</p>\n      <hr />\n      {/* Display debounced dimensions here */}\n      <p>Debounced Window Width: {windowDimensions.width}px</p>\n      <p>Debounced Window Height: {windowDimensions.height}px</p>\n      <p style={{ color: '#888' }}>Resize your browser window to see the effect.</p>\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// --- useDebounce Hook ---\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  \n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    \n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  \n  return debouncedValue;\n}\n// ------------------------\n\nfunction DebouncedResizeDisplay() {\n  // State to hold the *raw*, immediate window dimensions\n  const [rawWindowDimensions, setRawWindowDimensions] = useState(() => ({\n    width: typeof window !== 'undefined' ? window.innerWidth : 0,\n    height: typeof window !== 'undefined' ? window.innerHeight : 0,\n  }));\n\n  // Debounce the raw dimensions\n  const debouncedWindowDimensions = useDebounce(rawWindowDimensions, 200); // 200ms debounce delay\n\n  useEffect(() => {\n    // Ensure this runs only in browser environment\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    const handleResize = () => {\n      setRawWindowDimensions({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    };\n\n    // Add event listener for window resize\n    window.addEventListener('resize', handleResize);\n\n    // Cleanup function: remove event listener on component unmount\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []); // Empty dependency array means this effect runs once on mount and cleans up on unmount\n\n  return (\n    <div style={{ padding: '20px', fontFamily: 'Arial, sans-serif', border: '1px solid #ddd', borderRadius: '8px', maxWidth: '400px', margin: '20px auto', boxShadow: '0 4px 8px rgba(0,0,0,0.1)' }}>\n      <h2 style={{ color: '#333' }}>Debounced Window Resizer</h2>\n      <p><strong>Raw Window Dimensions (updates instantly):</strong></p>\n      <p>Width: <span style={{ color: '#007bff', fontWeight: 'bold' }}>{rawWindowDimensions.width}px</span></p>\n      <p>Height: <span style={{ color: '#007bff', fontWeight: 'bold' }}>{rawWindowDimensions.height}px</span></p>\n      <hr style={{ margin: '15px 0', borderColor: '#eee' }} />\n      <p><strong>Debounced Window Dimensions (updates after 200ms pause):</strong></p>\n      <p>Width: <span style={{ color: '#28a745', fontWeight: 'bold' }}>{debouncedWindowDimensions.width}px</span></p>\n      <p>Height: <span style={{ color: '#28a745', fontWeight: 'bold' }}>{debouncedWindowDimensions.height}px</span></p>\n      <p style={{ color: '#888', fontSize: '0.9em', marginTop: '15px' }}>Resize your browser window to see the debouncing effect.</p>\n    </div>\n  );\n}\n\nexport default DebouncedResizeDisplay;\n",
          "testCases": [
            "Test initial render: Dimensions should be displayed immediately on load.",
            "Test quick resize: Drag window rapidly. 'Raw' dimensions should change instantly, while 'Debounced' dimensions should lag and update only after you stop resizing.",
            "Test slow resize: Drag window slowly with pauses. 'Debounced' dimensions should update after each pause.",
            "Test unmount: Simulate component unmount (e.g., toggle visibility) and ensure no errors related to event listeners occur.",
            "Test with different debounce delays: Change the `delay` in `useDebounce` (e.g., 500ms, 1000ms) and observe the difference in update responsiveness."
          ],
          "hints": [
            "You'll need two sets of states: one for the `raw` window dimensions (updated on every resize event) and one for the `debounced` dimensions.",
            "The `useEffect` for the resize listener should only have an empty dependency array (`[]`) to run once on mount and clean up on unmount.",
            "Remember to use the `useState` functional update form or a lazy initializer if you need to calculate initial state based on `window` object to avoid SSR issues.",
            "Pass the `rawWindowDimensions` to `useDebounce`."
          ],
          "tags": [
            "React",
            "Hooks",
            "Debounce",
            "Performance",
            "Event Handling",
            "Window Events"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "useDebounce Hook",
            "useState",
            "useEffect",
            "JavaScript Event Listeners"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Throttling",
            "Responsive Layouts",
            "Event Optimization"
          ]
        }
      ]
    }
  }
]