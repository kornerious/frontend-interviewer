[
  {
    "id": "b8bb88ed-5083-46df-9253-27cb03f023b5",
    "startLine": 7300,
    "endLine": 7399,
    "processedDate": "2025-06-17T10:17:27.087Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_provider_pattern_context_api",
          "title": "React Provider Pattern with Context API",
          "content": "The Provider Pattern, when implemented with React's Context API, is a fundamental approach to managing global state within specific sections of a React application. It offers a centralized mechanism for sharing data across multiple components without resorting to 'prop drilling' â€“ the tedious process of passing props down through many nested components.\n\n## Key Concepts\n\n### 1. The Problem: Prop Drilling\nProp drilling occurs when data needs to be passed from a parent component to a deeply nested child component, requiring intermediate components in the tree to receive and re-pass the prop even if they don't directly use it. This can make code harder to maintain, less readable, and more prone to errors.\n\n### 2. React Context API\nReact's Context API provides a way to pass data through the component tree without having to pass props down manually at every level. It's designed to share 'global' data (like authenticated user, theme, or preferred language) to a tree of React components.\n\n*   **`React.createContext()`**: Creates a Context object. When React renders a component that subscribes to this Context object, it will read the current context value from the closest matching `Provider` above it in the tree.\n    *   `const MyContext = React.createContext(defaultValue);`\n    *   The `defaultValue` is used when a component consumes the context but there is no matching `Provider` above it in the tree. This can be useful for testing components in isolation without wrapping them.\n\n*   **`Context.Provider`**: A React component that allows consuming components to subscribe to context changes. It accepts a `value` prop to be passed to consuming components that are descendants of this Provider.\n    *   ` <MyContext.Provider value={/* some value */}>`\n\n*   **`useContext(Context)` Hook**: A React Hook that lets you read context. It takes a Context object (the value returned from `React.createContext`) and returns the current context value for that context.\n    *   `const value = useContext(MyContext);`\n    *   When the context `value` changes, the component using `useContext` will re-render.\n\n### 3. The Provider Pattern\nThe Provider Pattern wraps the Context API to encapsulate state management logic and make it reusable. A typical implementation involves:\n\n1.  **Creating a Context**: Define a Context object using `React.createContext()`.\n2.  **Creating a Provider Component**: This component (e.g., `UserProvider`) holds the shared state (e.g., `user`, `loading`) and methods to update it (e.g., `login`, `logout`). It renders the `Context.Provider` component, passing the state and methods as its `value` prop. This component typically accepts `children` as props, allowing it to wrap other components.\n3.  **Creating a Custom Hook**: A custom hook (e.g., `useUser`) abstracts the `useContext` call. This provides a cleaner API for consumers, allows for type safety, and ensures that the context is consumed within its respective Provider, throwing an error if not.\n4.  **Placing the Provider**: The Provider component is placed high up in the component tree, ideally at the root or at a level where all components that need access to the shared state are descendants.\n5.  **Consuming the Context**: Any child component can use the custom hook to access the shared state and methods without prop drilling.\n\n## Advantages of Provider Pattern with Context API\n\n*   **Centralized State Management**: Specific sections or the entire application can have their state managed centrally, avoiding scattering state logic.\n*   **Improved Code Organization**: Separates state management logic from UI components, adhering to the principle of separation of concerns. The provider handles the business logic, while consumers focus on rendering.\n*   **Eliminates Prop Drilling**: Data is directly accessible to any descendant component without intermediate components needing to pass it down.\n*   **Reusability**: The Provider component and its custom hook can be reused across different parts of the application or even in different projects.\n*   **Type Safety**: Custom hooks can be strongly typed using TypeScript, providing autocompletion and compile-time error checking for the context value.\n*   **Testability**: Components that consume context can be easily tested by wrapping them with a mock Provider during unit tests, providing controlled context values.\n\nWhile powerful, Context API is not a replacement for full-fledged state management libraries like Redux or Zustand for very complex applications with global, highly interconnected state. It is best suited for sharing 'global' data that does not change very frequently, or for domain-specific state within certain subtrees of the application.",
          "examples": [
            {
              "id": "example_provider_pattern_1",
              "title": "Basic User Authentication Provider",
              "code": "import React, { createContext, useContext, useState } from 'react';\n\n// 1. Create a context\nconst UserContext = createContext(undefined); // Use undefined as default to enforce provider presence\n\n// Mock authentication service\nconst authService = {\n  login: async (credentials) => {\n    // Simulate API call\n    return new Promise(resolve => {\n      setTimeout(() => {\n        if (credentials.username === 'test' && credentials.password === 'password') {\n          resolve({ id: 1, name: 'John Doe', email: 'john@example.com' });\n        } else {\n          throw new Error('Invalid credentials');\n        }\n      }, 500);\n    });\n  },\n  logout: async () => {\n    // Simulate API call\n    return new Promise(resolve => setTimeout(() => resolve(true), 200));\n  }\n};\n\n// 2. Create a provider component that manages shared state\nfunction UserProvider({ children }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(false);\n  \n  const login = async (credentials) => {\n    setLoading(true);\n    try {\n      const userData = await authService.login(credentials);\n      setUser(userData);\n      return { success: true };\n    } catch (error) {\n      return { success: false, error: error.message };\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  const logout = async () => {\n    await authService.logout(); // Simulate logout API call\n    setUser(null);\n  };\n  \n  const value = {\n    user,\n    loading,\n    login,\n    logout\n  };\n  \n  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;\n}\n\n// 3. Create a custom hook for consuming the context\nfunction useUser() {\n  const context = useContext(UserContext);\n  if (context === undefined) {\n    throw new Error('useUser must be used within a UserProvider');\n  }\n  return context;\n}\n\nexport { UserProvider, useUser };",
              "explanation": "This example demonstrates the core components of the Provider Pattern: `UserContext` for creation, `UserProvider` for managing and providing state, and `useUser` for consuming it. The `UserProvider` encapsulates the authentication logic, including asynchronous login and logout operations, and makes the current user state and functions to modify it available to any descendant component. The `useUser` hook provides a convenient and safe way to access this context, ensuring it's used within a `UserProvider`.",
              "language": "typescript"
            },
            {
              "id": "example_provider_pattern_2",
              "title": "Consuming the User Context in Components",
              "code": "import React from 'react';\nimport { UserProvider, useUser } from './UserContext'; // Assuming UserContext.js contains the provider and hook\n\n// Mock Redirect component for demonstration\nconst Redirect = ({ to }) => <p>Redirecting to: {to}</p>;\n\nfunction LoginPage() {\n  const { login, loading, user } = useUser();\n  const [username, setUsername] = React.useState('');\n  const [password, setPassword] = React.useState('');\n  const [error, setError] = React.useState('');\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    setError('');\n    const result = await login({ username, password });\n    if (!result.success) {\n      setError(result.error);\n    }\n  };\n\n  if (user) return <Redirect to=\"/profile\" />;\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <h2>Login</h2>\n      {error && <p style={{ color: 'red' }}>{error}</p>}\n      <input type=\"text\" placeholder=\"Username\" value={username} onChange={e => setUsername(e.target.value)} disabled={loading} />\n      <input type=\"password\" placeholder=\"Password\" value={password} onChange={e => setPassword(e.target.value)} disabled={loading} />\n      <button type=\"submit\" disabled={loading}> \n        {loading ? 'Logging in...' : 'Login'}\n      </button>\n    </form>\n  );\n}\n\nfunction ProfilePage() {\n  const { user, logout } = useUser();\n  \n  if (!user) return <Redirect to=\"/login\" />;\n  \n  return (\n    <div>\n      <h1>Welcome, {user.name}!</h1>\n      <p>Email: {user.email}</p>\n      <button onClick={logout}>Log Out</button>\n    </div>\n  );\n}\n\n// Main App component where the Provider is used\nfunction App() {\n  // In a real app, you'd have React Router here for navigation\n  const [currentPage, setCurrentPage] = React.useState('login');\n\n  return (\n    <UserProvider>\n      <nav>\n        <button onClick={() => setCurrentPage('login')}>Login</button>\n        <button onClick={() => setCurrentPage('profile')}>Profile</button>\n      </nav>\n      <hr />\n      {currentPage === 'login' ? <LoginPage /> : <ProfilePage />}\n    </UserProvider>\n  );\n}\n\nexport default App;\n",
              "explanation": "This example showcases how `UserProvider` wraps the application (or a part of it) and how child components like `LoginPage` and `ProfilePage` consume the shared `user` state and `login`/`logout` functions via the `useUser` custom hook. Notice how neither `App` nor any hypothetical intermediate component needs to explicitly pass the `user` prop down. This directly addresses the prop drilling problem.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_context_api_1",
            "question_context_api_2",
            "question_context_api_3",
            "question_context_api_4",
            "question_context_api_5",
            "question_context_api_6",
            "question_context_api_7",
            "question_context_api_8",
            "question_context_api_9",
            "question_context_api_10",
            "question_context_api_11",
            "question_context_api_12"
          ],
          "relatedTasks": [
            "task_theme_provider",
            "task_user_auth_provider"
          ],
          "tags": [
            "React",
            "Context API",
            "Provider Pattern",
            "State Management",
            "Hooks",
            "Frontend Architecture",
            "Prop Drilling"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "Functional Components",
            "useState Hook",
            "useContext Hook",
            "JavaScript ES6+"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced React Development",
            "State Management Design",
            "Building Scalable React Apps"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_context_api_1",
          "topic": "React Context API Fundamentals",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of React's Context API?",
          "answer": "To provide a way to pass data through the component tree without having to pass props down manually at every level (avoiding prop drilling).",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Context API",
            "Prop Drilling"
          ],
          "evaluationCriteria": [
            "Basic understanding of Context API's core use case."
          ],
          "example": "",
          "tags": [
            "React",
            "Context API",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_context_api_2",
          "topic": "Provider Pattern with Context API",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a direct advantage of using the Provider Pattern with React Context API?",
          "answer": "Significantly reducing bundle size for large applications",
          "options": [
            "Eliminating prop drilling for shared state",
            "Improving code organization by centralizing state logic",
            "Providing built-in type safety for context values with custom hooks",
            "Simplifying testing of components by mocking providers",
            "Significantly reducing bundle size for large applications"
          ],
          "analysisPoints": [
            "The Provider Pattern focuses on state management, organization, reusability, and testability, not primarily on bundle size optimization.",
            "While good architecture can indirectly lead to more optimized code, Context API itself doesn't offer specific bundle size reductions like code splitting."
          ],
          "keyConcepts": [
            "Provider Pattern",
            "Context API Advantages",
            "Bundle Size"
          ],
          "evaluationCriteria": [
            "Understanding of Context API's benefits",
            "Ability to distinguish actual benefits from irrelevant ones."
          ],
          "example": "The Provider Pattern aims to solve issues related to state management and component communication, like prop drilling and separation of concerns. Bundle size is typically addressed through techniques like code splitting, tree shaking, and optimizing build configurations, not directly by choosing Context API over other state management patterns.",
          "tags": [
            "React",
            "Context API",
            "Provider Pattern",
            "MCQ"
          ],
          "prerequisites": [
            "React Context API",
            "Provider Pattern Concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_api_3",
          "topic": "Implementing Provider Pattern",
          "level": "medium",
          "type": "code",
          "question": "Implement a simple `ThemeContext` and `ThemeProvider` that allows components to toggle between 'light' and 'dark' themes. Provide a custom hook `useTheme`.",
          "answer": "```typescript\nimport React, { createContext, useContext, useState, useMemo } from 'react';\n\nconst ThemeContext = createContext(undefined);\n\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));\n  };\n\n  // Memoize the value to prevent unnecessary re-renders of consumers\n  const value = useMemo(() => ({\n    theme,\n    toggleTheme\n  }), [theme]);\n\n  return (\n    <ThemeContext.Provider value={value}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n}\n\n// Example usage (for verification):\n/*\nfunction MyComponent() {\n  const { theme, toggleTheme } = useTheme();\n  return (\n    <div style={{ background: theme === 'light' ? '#fff' : '#333', color: theme === 'light' ? '#333' : '#fff' }}>\n      <p>Current theme: {theme}</p>\n      <button onClick={toggleTheme}>Toggle Theme</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <ThemeProvider>\n      <MyComponent />\n    </ThemeProvider>\n  );\n}\n*/\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `createContext`, `useState`, and `useContext`.",
            "Proper structure of the `ThemeProvider` accepting `children`.",
            "Inclusion of a custom hook with an error check for `undefined` context.",
            "Memoization of the context `value` using `useMemo` for performance optimization.",
            "Demonstrates encapsulation of state and logic within the provider."
          ],
          "keyConcepts": [
            "Context API",
            "Provider Pattern",
            "useState",
            "useContext",
            "useMemo",
            "Custom Hooks",
            "State Management"
          ],
          "evaluationCriteria": [
            "Correct implementation of Context API.",
            "Adherence to Provider Pattern best practices.",
            "Error handling for context consumption.",
            "Performance considerations (e.g., `useMemo`)."
          ],
          "example": "This solution effectively sets up a theme context, provider, and consumer hook. The `useMemo` hook is crucial here to prevent unnecessary re-renders of components consuming the context if the `toggleTheme` function reference changes on every render of `ThemeProvider`, even if `theme` hasn't changed (though in this simple case, `toggleTheme` is stable, but for more complex objects, `useMemo` is vital).",
          "tags": [
            "React",
            "Context API",
            "Provider Pattern",
            "Coding Challenge",
            "State Management"
          ],
          "prerequisites": [
            "React Hooks",
            "JavaScript Closures"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_api_4",
          "topic": "When to Use Context API",
          "level": "medium",
          "type": "open",
          "question": "When is React's Context API a good choice for state management, and when might a dedicated state management library (like Redux or Zustand) be more appropriate?",
          "answer": "React's Context API is a good choice for:\n*   **Global data that doesn't change frequently**: Like user authentication status, theme preferences, language settings.\n*   **Domain-specific state**: When a particular sub-tree of the application needs shared state that doesn't affect the entire application.\n*   **Simple to medium complexity applications**: Where the overhead of a larger library isn't justified.\n*   **Avoiding prop drilling**: For data that needs to be accessible to many nested components without passing props explicitly at every level.\n\nA dedicated state management library (Redux, Zustand, MobX, etc.) might be more appropriate for:\n*   **Large, complex applications**: With a vast amount of global state that interacts in complex ways.\n*   **Highly interconnected state**: Where many parts of the application need to react to changes in common state variables.\n*   **Predictable state updates**: Libraries like Redux enforce strict patterns (reducers, actions) which can make state changes more predictable and easier to debug.\n*   **Middleware and advanced features**: When you need features like logging, crash reporting, asynchronous side effects management (e.g., Redux Thunk/Saga), time-travel debugging, and persistence out-of-the-box.\n*   **Performance optimization**: While Context API can cause re-renders if not optimized (`useMemo`, `React.memo`), dedicated libraries often have more sophisticated mechanisms for granular updates and performance optimization for large state trees.",
          "options": [],
          "analysisPoints": [
            "Ability to articulate the strengths and weaknesses of Context API.",
            "Understanding the trade-offs between built-in React features and external libraries.",
            "Knowledge of scenarios where each approach excels."
          ],
          "keyConcepts": [
            "Context API vs Redux",
            "State Management Decisions",
            "Application Complexity"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of state management patterns.",
            "Ability to make informed architectural decisions."
          ],
          "example": "",
          "tags": [
            "React",
            "Context API",
            "State Management",
            "Architecture",
            "Open-Ended"
          ],
          "prerequisites": [
            "React Context API",
            "Familiarity with state management libraries"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_context_api_5",
          "topic": "Performance Considerations with Context API",
          "level": "hard",
          "type": "mcq",
          "question": "Consider the following `DataProvider`:\n\n```typescript\nimport React, { createContext, useContext, useState } from 'react';\n\nconst DataContext = createContext(null);\n\nfunction DataProvider({ children }) {\n  const [count, setCount] = useState(0);\n  const [data, setData] = useState({ name: 'Test', value: 100 });\n\n  const updateCount = () => setCount(prev => prev + 1);\n  const updateDataName = (newName) => setData(prev => ({ ...prev, name: newName }));\n\n  // Problematic line for performance\n  const contextValue = {\n    count,\n    data,\n    updateCount,\n    updateDataName\n  };\n\n  return (\n    <DataContext.Provider value={contextValue}>\n      {children}\n    </DataContext.Provider>\n  );\n}\n\nfunction useData() {\n  const context = useContext(DataContext);\n  if (context === undefined) {\n    throw new Error('useData must be used within a DataProvider');\n  }\n  return context;\n}\n\n// A component that only uses updateCount\nfunction CounterComponent() {\n  const { count, updateCount } = useData();\n  console.log('CounterComponent rendered');\n  return <button onClick={updateCount}>Count: {count}</button>;\n}\n\n// A component that only uses data.name\nfunction NameDisplayComponent() {\n  const { data } = useData();\n  console.log('NameDisplayComponent rendered');\n  return <p>Data Name: {data.name}</p>;\n}\n\nfunction App() {\n  return (\n    <DataProvider>\n      <CounterComponent />\n      <NameDisplayComponent />\n    </DataProvider>\n  );\n}\n```\n\nIf `updateDataName` is called, what happens to `CounterComponent` and `NameDisplayComponent`?\n\nA) Only `NameDisplayComponent` re-renders because `CounterComponent`'s state (`count`) didn't change.\nB) Both `CounterComponent` and `NameDisplayComponent` re-render because the `contextValue` object reference changes on every `DataProvider` render.\nC) Neither component re-renders if `React.memo` is applied to them.\nD) Only `CounterComponent` re-renders because its `updateCount` function reference changes.",
          "answer": "B) Both `CounterComponent` and `NameDisplayComponent` re-render because the `contextValue` object reference changes on every `DataProvider` render.",
          "options": [
            "A) Only `NameDisplayComponent` re-renders because `CounterComponent`'s state (`count`) didn't change.",
            "B) Both `CounterComponent` and `NameDisplayComponent` re-render because the `contextValue` object reference changes on every `DataProvider` render.",
            "C) Neither component re-renders if `React.memo` is applied to them.",
            "D) Only `CounterComponent` re-renders because its `updateCount` function reference changes."
          ],
          "analysisPoints": [
            "Understanding that `useContext` re-renders the consuming component whenever the *value* passed to the `Provider` changes by reference.",
            "Recognizing that `contextValue` is a new object on every render of `DataProvider`, regardless of whether its individual properties (`count`, `data`) have changed.",
            "Understanding that `React.memo` only prevents re-renders based on prop changes, not context changes, unless the context value itself is memoized."
          ],
          "keyConcepts": [
            "Context API Performance",
            "Object Reference Equality",
            "useMemo",
            "useCallback",
            "React.memo",
            "Re-renders"
          ],
          "evaluationCriteria": [
            "Deep understanding of React rendering mechanisms and Context API's impact.",
            "Ability to identify performance pitfalls in Context API usage."
          ],
          "example": "When `updateDataName` is called, `setData` updates `data` state, which causes `DataProvider` to re-render. On each render, a `new` `contextValue` object is created:\n\n```typescript\n  const contextValue = {\n    count, // even if count hasn't changed\n    data, // this will be a new object because setData updates it\n    updateCount,\n    updateDataName\n  };\n```\n\nSince `contextValue` is a new object reference on every `DataProvider` render (even if only `data` changes, or even if nothing changes on a parent re-render), `DataContext.Provider` receives a new `value` prop. Any component consuming `DataContext` (both `CounterComponent` and `NameDisplayComponent`) will re-render, regardless of whether they only use a subset of the context values or if their specific parts of the context haven't semantically changed. To optimize, `contextValue` should be memoized using `useMemo`.",
          "tags": [
            "React",
            "Context API",
            "Performance",
            "Optimization",
            "Hooks",
            "MCQ"
          ],
          "prerequisites": [
            "React Rendering",
            "useMemo Hook",
            "useCallback Hook"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_context_api_6",
          "topic": "Custom Hooks for Context",
          "level": "easy",
          "type": "flashcard",
          "question": "Why is it a good practice to create a custom hook (e.g., `useUser`) instead of directly calling `useContext(UserContext)` in components?",
          "answer": "It provides a cleaner API for consumers, allows for type safety, and enables throwing an error if the context is consumed outside its Provider, making debugging easier.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Custom Hooks",
            "Context API Best Practices",
            "Type Safety"
          ],
          "evaluationCriteria": [
            "Understanding of best practices for Context API."
          ],
          "example": "",
          "tags": [
            "React",
            "Context API",
            "Custom Hooks",
            "Flashcard"
          ],
          "prerequisites": [
            "React Custom Hooks"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_api_7",
          "topic": "Context API vs. Prop Drilling",
          "level": "medium",
          "type": "open",
          "question": "Explain the concept of 'prop drilling' and how the Provider Pattern with Context API effectively solves it. Provide a small conceptual code example demonstrating the problem and solution.",
          "answer": "Prop drilling is the process of passing data from a parent component down to deeply nested child components through intermediate components that don't actually need the data themselves. This leads to boilerplate code, reduces readability, and makes refactoring difficult.\n\n**Problem: Prop Drilling Example**\n\n```typescript\n// App.js\nfunction App() {\n  const user = { name: 'Alice', email: 'alice@example.com' };\n  return <ParentComponent user={user} />;\n}\n\n// ParentComponent.js\nfunction ParentComponent({ user }) {\n  return <MiddleComponent user={user} />;\n}\n\n// MiddleComponent.js\n// This component doesn't use 'user', but passes it down\nfunction MiddleComponent({ user }) {\n  return <ChildComponent user={user} />;\n}\n\n// ChildComponent.js\nfunction ChildComponent({ user }) {\n  return <p>Welcome, {user.name}!</p>; // Only ChildComponent needs 'user'\n}\n```\n\nIn this example, `user` is passed through `ParentComponent` and `MiddleComponent` just to reach `ChildComponent`, even though `ParentComponent` and `MiddleComponent` don't use the `user` prop.\n\n**Solution: Provider Pattern with Context API Example**\n\n```typescript\n// UserContext.js\nimport React, { createContext, useContext } from 'react';\n\nconst UserContext = createContext(null);\n\nexport function UserProvider({ children }) {\n  const user = { name: 'Alice', email: 'alice@example.com' };\n  return <UserContext.Provider value={user}>{children}</UserContext.Provider>;\n}\n\nexport function useUser() {\n  return useContext(UserContext);\n}\n\n// App.js\nfunction App() {\n  return (\n    <UserProvider>\n      <ParentComponent />\n    </UserProvider>\n  );\n}\n\n// ParentComponent.js\n// No 'user' prop needed here\nfunction ParentComponent() {\n  return <MiddleComponent />;\n}\n\n// MiddleComponent.js\n// No 'user' prop needed here\nfunction MiddleComponent() {\n  return <ChildComponent />;\n}\n\n// ChildComponent.js\nimport { useUser } from './UserContext';\n\nfunction ChildComponent() {\n  const user = useUser(); // Direct access from context\n  return <p>Welcome, {user.name}!</p>;\n}\n```\n\n**How it solves prop drilling:**\nThe `UserProvider` makes the `user` object available to *any* component within its subtree, regardless of depth. Components like `ChildComponent` can directly `useContext(UserContext)` (or `useUser()`) to access the `user` object without intermediate components receiving it as props. This centralizes the data provisioning and decouples consumers from the exact depth in the component tree.",
          "options": [],
          "analysisPoints": [
            "Clear definition of prop drilling.",
            "Demonstration of prop drilling with code.",
            "Explanation of Provider Pattern and Context API components.",
            "Demonstration of solution with code.",
            "Concise explanation of how the solution works."
          ],
          "keyConcepts": [
            "Prop Drilling",
            "Context API",
            "Provider Pattern",
            "Problem Solving"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of explanation.",
            "Effectiveness of code examples in illustrating the concepts.",
            "Understanding of the core problem and its solution."
          ],
          "example": "",
          "tags": [
            "React",
            "Context API",
            "Prop Drilling",
            "Coding Example",
            "Open-Ended"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_api_8",
          "topic": "Context API Multiple Consumers",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following setup:\n\n```typescript\nconst MyContext = React.createContext('default');\n\nfunction Parent() {\n  return (\n    <MyContext.Provider value=\"value A\">\n      <Child1 />\n      <MyContext.Provider value=\"value B\">\n        <Child2 />\n      </MyContext.Provider>\n      <Child3 />\n    </MyContext.Provider>\n  );\n}\n\nfunction Child1() {\n  const val = React.useContext(MyContext);\n  return <p>Child1: {val}</p>;\n}\n\nfunction Child2() {\n  const val = React.useContext(MyContext);\n  return <p>Child2: {val}</p>;\n}\n\nfunction Child3() {\n  const val = React.useContext(MyContext);\n  return <p>Child3: {val}</p>;\n}\n```\n\nWhat will be the output rendered by `Child1`, `Child2`, and `Child3` respectively?",
          "answer": "Child1: value A, Child2: value B, Child3: value A",
          "options": [
            "Child1: default, Child2: default, Child3: default",
            "Child1: value A, Child2: value B, Child3: value A",
            "Child1: value A, Child2: value B, Child3: value B",
            "Child1: default, Child2: value A, Child3: value B"
          ],
          "analysisPoints": [
            "Understanding that `useContext` reads from the *closest* matching `Provider` above it in the component tree.",
            "Tracing the component hierarchy to identify which `Provider` each `Child` component falls under."
          ],
          "keyConcepts": [
            "Context API",
            "Provider Nesting",
            "Component Tree",
            "useContext"
          ],
          "evaluationCriteria": [
            "Ability to predict context values based on component hierarchy."
          ],
          "example": "The `Child1` component is a direct child of the first `MyContext.Provider` with `value=\"value A\"`. The `Child2` component is a child of the second, nested `MyContext.Provider` with `value=\"value B\"`. The `Child3` component is a child of the first `MyContext.Provider` (at the same level as `Child1`) and thus accesses `value=\"value A\"`. Nested `Provider`s override the context value for their descendants.",
          "tags": [
            "React",
            "Context API",
            "MCQ",
            "Component Hierarchy"
          ],
          "prerequisites": [
            "React Context API"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_api_9",
          "topic": "Context API Default Value",
          "level": "easy",
          "type": "flashcard",
          "question": "When does the `defaultValue` passed to `React.createContext(defaultValue)` get used?",
          "answer": "It gets used when a component consumes the context (e.g., using `useContext`) but there is no matching `Provider` above it in the component tree.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Context API",
            "createContext",
            "Default Value"
          ],
          "evaluationCriteria": [
            "Basic understanding of `createContext` parameter."
          ],
          "example": "",
          "tags": [
            "React",
            "Context API",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_context_api_10",
          "topic": "Testing Context Consumers",
          "level": "medium",
          "type": "open",
          "question": "How can you effectively test a React component that consumes a context (e.g., `ProfilePage` consuming `UserContext`) without mounting the entire application?",
          "answer": "To effectively test a React component that consumes a context, you should wrap the component being tested with a mock version of its `Provider`. This allows you to control the exact context value that the component receives during the test, isolating its behavior.\n\n**Steps:**\n\n1.  **Import the Provider**: Import the actual `Provider` component (e.g., `UserProvider` from `UserContext.js`).\n2.  **Render with Mock Data**: When rendering the component for your test (e.g., using React Testing Library's `render` function), wrap it inside the `Provider` component.\n3.  **Provide Test-Specific Values**: Pass the desired mock `value` prop to the `Provider` for that specific test case.\n\n**Example using React Testing Library and Jest:**\n\n```typescript\nimport React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport { UserProvider, useUser } from './UserContext'; // Assuming this path\nimport ProfilePage from './ProfilePage'; // Assuming this path\n\n// Mocking the useUser hook is also an option for deeper isolation\n// but often testing with the actual provider is more integration-like.\n\ndescribe('ProfilePage', () => {\n  const mockUser = { id: 1, name: 'Test User', email: 'test@example.com' };\n  const mockLogout = jest.fn();\n\n  it('renders user information when authenticated', () => {\n    render(\n      <UserProvider value={{ user: mockUser, loading: false, login: jest.fn(), logout: mockLogout }}>\n        <ProfilePage />\n      </UserProvider>\n    );\n    \n    expect(screen.getByText(/Welcome, Test User!/i)).toBeInTheDocument();\n    expect(screen.getByText(/Email: test@example.com/i)).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: /Log Out/i })).toBeInTheDocument();\n  });\n\n  it('redirects to login if user is not authenticated', () => {\n    // In a real app, Redirect might be a React Router component.\n    // Here, we'll mock it for simplicity or check for specific text.\n    render(\n      <UserProvider value={{ user: null, loading: false, login: jest.fn(), logout: mockLogout }}>\n        <ProfilePage />\n      </UserProvider>\n    );\n    \n    // Assuming Redirect renders specific text or changes route\n    expect(screen.getByText(/Redirecting to: \\/login/i)).toBeInTheDocument();\n  });\n\n  it('calls logout when the logout button is clicked', () => {\n    render(\n      <UserProvider value={{ user: mockUser, loading: false, login: jest.fn(), logout: mockLogout }}>\n        <ProfilePage />\n      </UserProvider>\n    );\n\n    const logoutButton = screen.getByRole('button', { name: /Log Out/i });\n    fireEvent.click(logoutButton);\n    expect(mockLogout).toHaveBeenCalledTimes(1);\n  });\n});\n```\n\nThis approach ensures that `ProfilePage` behaves correctly given different `UserContext` states, allowing for isolated and reliable unit/integration testing of the component.",
          "options": [],
          "analysisPoints": [
            "Understanding of testing principles for components relying on external state.",
            "Knowledge of how to provide mock context values.",
            "Familiarity with testing utilities like React Testing Library."
          ],
          "keyConcepts": [
            "Context API Testing",
            "Unit Testing",
            "Mocking",
            "React Testing Library"
          ],
          "evaluationCriteria": [
            "Ability to design effective tests for Context-consuming components.",
            "Knowledge of testing best practices."
          ],
          "example": "",
          "tags": [
            "React",
            "Context API",
            "Testing",
            "Open-Ended"
          ],
          "prerequisites": [
            "React Testing Library",
            "Jest"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_context_api_11",
          "topic": "Combining Multiple Contexts",
          "level": "hard",
          "type": "code",
          "question": "Imagine you have a `ThemeContext` and a `UserContext`. How would you structure your `App` component to provide both contexts, and how would a component consume both? Write the relevant `App` and consumer components.",
          "answer": "```typescript\nimport React, { createContext, useContext, useState, useMemo } from 'react';\n\n// --- Theme Context Setup ---\nconst ThemeContext = createContext(undefined);\n\nexport function ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  const toggleTheme = () => setTheme(prev => (prev === 'light' ? 'dark' : 'light'));\n  const themeValue = useMemo(() => ({ theme, toggleTheme }), [theme]);\n\n  return (\n    <ThemeContext.Provider value={themeValue}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\nexport function useTheme() {\n  const context = useContext(ThemeContext);\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n}\n\n// --- User Context Setup ---\nconst UserContext = createContext(undefined);\n\nexport function UserProvider({ children }) {\n  const [user, setUser] = useState(null); // Simplified for example\n  const login = (username) => setUser({ name: username });\n  const logout = () => setUser(null);\n  const userValue = useMemo(() => ({ user, login, logout }), [user]);\n\n  return (\n    <UserContext.Provider value={userValue}>\n      {children}\n    </UserContext.Provider>\n  );\n}\n\nexport function useUser() {\n  const context = useContext(UserContext);\n  if (context === undefined) {\n    throw new Error('useUser must be used within a UserProvider');\n  }\n  return context;\n}\n\n// --- App Component (Providing multiple contexts) ---\nfunction App() {\n  return (\n    <ThemeProvider>\n      <UserProvider>\n        <MainContent />\n      </UserProvider>\n    </ThemeProvider>\n  );\n}\n\n// --- Consumer Component (Using multiple contexts) ---\nfunction MainContent() {\n  const { theme, toggleTheme } = useTheme();\n  const { user, logout } = useUser();\n\n  return (\n    <div style={{ padding: '20px', background: theme === 'light' ? '#eee' : '#333', color: theme === 'light' ? '#333' : '#eee' }}>\n      <h1>Welcome, {user ? user.name : 'Guest'}!</h1>\n      <p>Current Theme: {theme}</p>\n      <button onClick={toggleTheme}>Toggle Theme</button>\n      {user && <button onClick={logout}>Logout</button>}\n    </div>\n  );\n}\n\nexport default App;\n```",
          "options": [],
          "analysisPoints": [
            "Correct nesting of `Provider` components.",
            "Demonstrates how consumers use multiple custom hooks.",
            "Emphasizes the modularity of context providers."
          ],
          "keyConcepts": [
            "Multiple Contexts",
            "Context Nesting",
            "Provider Pattern",
            "Custom Hooks"
          ],
          "evaluationCriteria": [
            "Ability to integrate multiple independent contexts.",
            "Correct usage of `Provider` and `useContext` for multi-context scenarios."
          ],
          "example": "To provide multiple contexts, you simply nest their `Provider` components. The order generally doesn't matter unless one context's value depends on another. Any component rendered within these nested providers can then consume any of the provided contexts using their respective custom hooks. This keeps the contexts independent while allowing co-located state access.",
          "tags": [
            "React",
            "Context API",
            "Architecture",
            "Coding Challenge"
          ],
          "prerequisites": [
            "React Context API",
            "Provider Pattern"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_context_api_12",
          "topic": "Context API Limitations",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is considered a potential limitation or drawback of using React's Context API for global state management in very large and complex applications, compared to dedicated libraries like Redux?",
          "answer": "Lack of built-in tooling for debugging, middleware, or time-travel debugging out of the box.",
          "options": [
            "It always leads to excessive re-renders that cannot be optimized.",
            "It cannot be used with functional components and hooks.",
            "It forces all components to re-render even if they only consume a small part of the context.",
            "It is fundamentally slower than passing props manually.",
            "Lack of built-in tooling for debugging, middleware, or time-travel debugging out of the box."
          ],
          "analysisPoints": [
            "Context API can be optimized with `useMemo` and `useCallback` to mitigate re-renders, so 'always leads to excessive re-renders' is false.",
            "Context API is designed to work seamlessly with functional components and hooks.",
            "While a single `Provider` update can re-render all consumers, strategies like splitting context or using selectors (custom hooks returning specific values) can mitigate this. The key is that it *can* cause re-renders, but not that it *forces* them in an unoptimizable way.",
            "Performance difference from prop drilling is usually negligible for typical use cases, and Context API solves an architectural problem, not a raw performance bottleneck.",
            "Dedicated libraries often come with extensive ecosystems, including development tools (debuggers, devtools), middleware for side effects, and strict patterns that facilitate complex state management and debugging. Context API, by itself, does not provide these out-of-the-box."
          ],
          "keyConcepts": [
            "Context API Limitations",
            "State Management Trade-offs",
            "Debugging Tools",
            "Middleware"
          ],
          "evaluationCriteria": [
            "Nuanced understanding of Context API's capabilities and shortcomings.",
            "Awareness of the features offered by alternative state management solutions."
          ],
          "example": "While Context API is powerful for simpler state needs, its 'global' nature (all consumers re-render when value changes unless memoized specifically) and lack of advanced features like built-in state history or a robust middleware system often make dedicated libraries more suitable for enterprise-level applications with highly complex and interconnected state requirements. These libraries provide structure and tools that Context API does not inherently offer.",
          "tags": [
            "React",
            "Context API",
            "State Management",
            "Limitations",
            "MCQ"
          ],
          "prerequisites": [
            "React Context API",
            "Understanding of Redux/Zustand concepts"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_theme_provider",
          "title": "Implement a Theme Management System using Provider Pattern",
          "description": "\nCreate a theme management system for a React application using the Provider Pattern with Context API. Your system should allow components to:\n\n1.  Access the current theme ('light' or 'dark').\n2.  Toggle the theme between 'light' and 'dark'.\n3.  Demonstrate usage in a sample component that changes its background/text color based on the theme.\n\n**Requirements:**\n*   Create a `ThemeContext`.\n*   Implement a `ThemeProvider` component that manages the theme state.\n*   Provide a custom hook `useTheme` for consuming the context.\n*   Ensure the `useTheme` hook throws an error if used outside `ThemeProvider`.\n*   Optimize the context value to prevent unnecessary re-renders of consumers.\n*   Create a simple `ThemeToggler` component that uses `useTheme` to display the current theme and a button to toggle it.\n*   Create a simple `StyledDiv` component that changes its styles based on the current theme.",
          "difficulty": "medium",
          "startingCode": "import React, { createContext, useContext, useState, useMemo } from 'react';\n\n// 1. Create ThemeContext\nconst ThemeContext = createContext(undefined); \n\n// 2. Create ThemeProvider component\nfunction ThemeProvider({ children }) {\n  // TODO: Manage theme state ('light' | 'dark')\n  // TODO: Create a function to toggle theme\n  // TODO: Memoize the context value\n  // TODO: Provide the value to children\n  return null; \n}\n\n// 3. Create useTheme custom hook\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  // TODO: Add error handling for undefined context\n  return context;\n}\n\n// 4. Create ThemeToggler component\nfunction ThemeToggler() {\n  // TODO: Consume theme and toggleTheme from useTheme\n  // TODO: Display current theme and a button to toggle it\n  return (\n    <div>\n      <p>Current Theme: </p>\n      <button>Toggle Theme</button>\n    </div>\n  );\n}\n\n// 5. Create StyledDiv component\nfunction StyledDiv({ children }) {\n  // TODO: Consume theme from useTheme\n  // TODO: Apply styles based on theme\n  return (\n    <div style={{ padding: '20px', border: '1px solid black' }}>\n      {children}\n    </div>\n  );\n}\n\n// Root App component for demonstration\nfunction App() {\n  return (\n    <ThemeProvider>\n      <StyledDiv>\n        <h2>Theme Showcase</h2>\n        <ThemeToggler />\n        <p>This text color and background should change with the theme.</p>\n      </StyledDiv>\n    </ThemeProvider>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { createContext, useContext, useState, useMemo } from 'react';\n\n// 1. Create ThemeContext\nconst ThemeContext = createContext(undefined); \n\n// 2. Create ThemeProvider component\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));\n  };\n\n  // Memoize the value to prevent unnecessary re-renders of consumers\n  const value = useMemo(() => ({\n    theme,\n    toggleTheme\n  }), [theme]);\n\n  return (\n    <ThemeContext.Provider value={value}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// 3. Create useTheme custom hook\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n}\n\n// 4. Create ThemeToggler component\nfunction ThemeToggler() {\n  const { theme, toggleTheme } = useTheme();\n\n  return (\n    <div>\n      <p>Current Theme: **{theme}**</p>\n      <button onClick={toggleTheme}>Toggle Theme</button>\n    </div>\n  );\n}\n\n// 5. Create StyledDiv component\nfunction StyledDiv({ children }) {\n  const { theme } = useTheme();\n  const isLight = theme === 'light';\n\n  const divStyle = {\n    padding: '20px',\n    border: '1px solid black',\n    backgroundColor: isLight ? '#f0f0f0' : '#333',\n    color: isLight ? '#333' : '#f0f0f0',\n    transition: 'background-color 0.3s ease, color 0.3s ease'\n  };\n\n  return (\n    <div style={divStyle}>\n      {children}\n    </div>\n  );\n}\n\n// Root App component for demonstration\nfunction App() {\n  return (\n    <ThemeProvider>\n      <StyledDiv>\n        <h2>Theme Showcase</h2>\n        <ThemeToggler />\n        <p>This text color and background should change with the theme.</p>\n      </StyledDiv>\n    </ThemeProvider>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "The `ThemeToggler` component should correctly display 'light' initially.",
            "Clicking the 'Toggle Theme' button should switch the theme to 'dark'.",
            "Subsequent clicks should toggle between 'light' and 'dark'.",
            "The `StyledDiv`'s background and text color should dynamically change with the theme.",
            "Using `useTheme` outside of `ThemeProvider` should throw an error (e.g., wrap a test component without `ThemeProvider` and expect an error)."
          ],
          "hints": [
            "Remember to use `useState` in `ThemeProvider` to manage the theme string ('light' or 'dark').",
            "The `value` prop of `ThemeContext.Provider` should be an object containing both the current `theme` and the `toggleTheme` function.",
            "Consider using `useMemo` for the `value` object passed to the Provider to optimize performance and prevent unnecessary re-renders of consuming components.",
            "The `useTheme` hook needs to check if `useContext(ThemeContext)` returns `undefined` to handle cases where it's used outside the Provider."
          ],
          "tags": [
            "React",
            "Context API",
            "State Management",
            "Hooks",
            "Theming",
            "Frontend Interview"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Basics",
            "useState Hook",
            "useContext Hook",
            "useMemo Hook"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Provider Pattern",
            "Prop Drilling",
            "Custom Hooks",
            "Performance Optimization"
          ]
        },
        {
          "id": "task_user_auth_provider",
          "title": "Build a Simplified User Authentication Context",
          "description": "\nImplement a simplified user authentication system using the Provider Pattern. This system should manage user login/logout status and provide basic user information.\n\n**Requirements:**\n*   Create a `UserContext`.\n*   Implement a `UserProvider` component that manages the user state (e.g., `user: null | { name: string, id: string }`) and a `loading` state for auth operations.\n*   The `UserProvider` should include a `login` function (simulated async, e.g., using `setTimeout`) that sets a mock user, and a `logout` function that clears the user.\n*   Provide a custom hook `useAuth` for consuming the context. It should throw an error if used outside the `UserProvider`.\n*   Create a `LoginComponent` that uses `useAuth` to trigger login and display loading status.\n*   Create a `ProfileComponent` that uses `useAuth` to display user info (if logged in) and a logout button.\n*   In your main `App` component, conditionally render `LoginComponent` or `ProfileComponent` based on the `user` status from `useAuth`.\n",
          "difficulty": "medium",
          "startingCode": "import React, { createContext, useContext, useState, useMemo } from 'react';\n\n// 1. Create UserContext\nconst UserContext = createContext(undefined);\n\n// Mock authentication service (for async simulation)\nconst authService = {\n  login: async (credentials) => {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        if (credentials.username === 'test') {\n          resolve({ id: '123', name: 'Test User' });\n        } else {\n          resolve(null); // Simulate failed login\n        }\n      }, 500);\n    });\n  },\n  logout: async () => {\n    return new Promise(resolve => setTimeout(() => resolve(true), 200));\n  }\n};\n\n// 2. Create UserProvider component\nfunction UserProvider({ children }) {\n  // TODO: Manage 'user' state (null initially) and 'loading' state\n  // TODO: Implement async login function using authService\n  // TODO: Implement logout function using authService\n  // TODO: Memoize the context value containing user, loading, login, logout\n  return null;\n}\n\n// 3. Create useAuth custom hook\nfunction useAuth() {\n  const context = useContext(UserContext);\n  // TODO: Add error handling\n  return context;\n}\n\n// 4. LoginComponent\nfunction LoginComponent() {\n  // TODO: Consume useAuth\n  // TODO: Implement form for username, call login on submit\n  // TODO: Show loading state\n  // TODO: Redirect/display message if logged in\n  return (\n    <div>\n      <h2>Login</h2>\n      <p>Current user: (Not logged in)</p>\n      <button>Log In (test)</button>\n    </div>\n  );\n}\n\n// 5. ProfileComponent\nfunction ProfileComponent() {\n  // TODO: Consume useAuth\n  // TODO: Display user info if logged in\n  // TODO: Show logout button\n  // TODO: Redirect/display message if not logged in\n  return (\n    <div>\n      <h2>Profile</h2>\n      <p>Welcome, User!</p>\n      <button>Log Out</button>\n    </div>\n  );\n}\n\n// Root App component\nfunction App() {\n  // TODO: Wrap components with UserProvider\n  // TODO: Conditionally render LoginComponent or ProfileComponent based on user state\n  return (\n    <UserProvider>\n      <LoginComponent />\n    </UserProvider>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { createContext, useContext, useState, useMemo, useEffect } from 'react';\n\n// 1. Create UserContext\nconst UserContext = createContext(undefined);\n\n// Mock authentication service (for async simulation)\nconst authService = {\n  login: async (credentials) => {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        if (credentials.username === 'test' && credentials.password === 'password') {\n          resolve({ id: '123', name: 'Test User' });\n        } else {\n          throw new Error('Invalid credentials');\n        }\n      }, 500);\n    });\n  },\n  logout: async () => {\n    return new Promise(resolve => setTimeout(() => resolve(true), 200));\n  }\n};\n\n// 2. Create UserProvider component\nfunction UserProvider({ children }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const login = async (credentials) => {\n    setLoading(true);\n    setError(null);\n    try {\n      const userData = await authService.login(credentials);\n      setUser(userData);\n      return { success: true };\n    } catch (err) {\n      setError(err.message);\n      return { success: false, error: err.message };\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const logout = async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      await authService.logout();\n      setUser(null);\n      return { success: true };\n    } catch (err) {\n      setError(err.message);\n      return { success: false, error: err.message };\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const value = useMemo(() => ({\n    user,\n    loading,\n    error,\n    login,\n    logout\n  }), [user, loading, error]);\n\n  return (\n    <UserContext.Provider value={value}>\n      {children}\n    </UserContext.Provider>\n  );\n}\n\n// 3. Create useAuth custom hook\nfunction useAuth() {\n  const context = useContext(UserContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within a UserProvider');\n  }\n  return context;\n}\n\n// 4. LoginComponent\nfunction LoginComponent() {\n  const { user, login, loading, error } = useAuth();\n  const [username, setUsername] = useState('test');\n  const [password, setPassword] = useState('password');\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    await login({ username, password });\n  };\n\n  if (user) {\n    return <p>Logged in as: {user.name} - Go to Profile</p>;\n  }\n\n  return (\n    <div>\n      <h2>Login</h2>\n      <form onSubmit={handleSubmit}>\n        {error && <p style={{ color: 'red' }}>Error: {error}</p>}\n        <div>\n          <label>Username:</label>\n          <input type=\"text\" value={username} onChange={(e) => setUsername(e.target.value)} disabled={loading} />\n        </div>\n        <div>\n          <label>Password:</label>\n          <input type=\"password\" value={password} onChange={(e) => setPassword(e.target.value)} disabled={loading} />\n        </div>\n        <button type=\"submit\" disabled={loading}>\n          {loading ? 'Logging in...' : 'Log In'}\n        </button>\n      </form>\n    </div>\n  );\n}\n\n// 5. ProfileComponent\nfunction ProfileComponent() {\n  const { user, logout, loading } = useAuth();\n\n  if (!user) {\n    return <p>Not logged in. Please log in.</p>;\n  }\n\n  return (\n    <div>\n      <h2>Profile</h2>\n      <p>Welcome, {user.name} (ID: {user.id})!</p>\n      <button onClick={logout} disabled={loading}>\n        {loading ? 'Logging out...' : 'Log Out'}\n      </button>\n    </div>\n  );\n}\n\n// Root App component\nfunction App() {\n  const { user, loading } = useAuth();\n\n  // This useEffect and the logic below makes it simpler to switch between components for demonstration\n  // In a real app, you'd use React Router or similar.\n  const [showLogin, setShowLogin] = useState(true);\n\n  useEffect(() => {\n    if (user) {\n      setShowLogin(false);\n    } else {\n      setShowLogin(true);\n    }\n  }, [user]);\n\n  return (\n    <UserProvider>\n      <h1>My Auth App</h1>\n      {showLogin ? <LoginComponent /> : <ProfileComponent />}\n    </UserProvider>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Initially, `LoginComponent` should be displayed.",
            "After a successful login (e.g., with username 'test' and password 'password'), `ProfileComponent` should be displayed showing the mock user's name.",
            "Clicking the 'Log Out' button in `ProfileComponent` should return to `LoginComponent`.",
            "The 'Log In' and 'Log Out' buttons should be disabled while `loading` is true.",
            "Entering incorrect credentials ('bad', 'bad') should simulate a failed login and display an error message.",
            "`useAuth` used outside of `UserProvider` should throw an `Error`."
          ],
          "hints": [
            "Remember to handle the asynchronous nature of login/logout functions using `async/await` and `try/catch`.",
            "Update the `loading` state before and after `authService` calls.",
            "The `value` prop for `UserContext.Provider` should be an object containing `user`, `loading`, `login`, and `logout`.",
            "Don't forget to memoize the `value` object using `useMemo` to prevent unnecessary re-renders of consuming components.",
            "For conditional rendering in `App`, you can check the `user` status provided by `useAuth`."
          ],
          "tags": [
            "React",
            "Context API",
            "State Management",
            "Authentication",
            "Hooks",
            "Async Operations",
            "Frontend Interview"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Basics",
            "useState Hook",
            "useContext Hook",
            "useMemo Hook",
            "Asynchronous JavaScript"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Provider Pattern",
            "Custom Hooks",
            "Error Handling",
            "Conditional Rendering"
          ]
        }
      ]
    }
  },
  {
    "id": "6b8c3a34-bfe2-408a-a8b5-0adc285072a0",
    "startLine": 7400,
    "endLine": 7499,
    "processedDate": "2025-06-17T10:21:56.050Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_context_fundamentals",
          "title": "React Context API Fundamentals: Passing Data Without Prop Drilling",
          "content": "The React Context API provides a way to pass data through the component tree without having to pass props down manually at every level. This is particularly useful for 'global' data that many components in an application might need, such as themes, user authentication status, or preferred language.\n\n## Key Concepts\n\n### 1. `React.createContext`\n`React.createContext` is used to create a Context object. When React renders a component that subscribes to this Context object, it will read the current context value from the closest matching `Provider` above it in the tree. The argument passed to `createContext` (e.g., `dark` in `ThemeContext = React.createContext('dark')`) is the `defaultValue`. This `defaultValue` is used when a component consumes the context without a corresponding `Provider` in the tree. It helps with testing components in isolation without wrapping them in a Provider.\n\n### 2. `Context.Provider`\nThe `Provider` component, which is a property of the Context object (`ThemeContext.Provider`), allows consuming components to subscribe to context changes. It accepts a `value` prop that will be passed down to all consumers of this context that are descendants of this `Provider`. A `Provider` can be nested inside other `Providers` to override values for components deeper in the tree.\n\n### 3. `useContext` Hook\n`useContext` is a React Hook that allows functional components to consume the context value provided by the nearest `Context.Provider` above it. It takes the Context object itself (e.g., `ThemeContext`) as an argument and returns the current context `value`. If no `Provider` is found, it returns the `defaultValue` specified when creating the context.\n\n## Why use Context?\n*   **Avoids Prop Drilling:** Context prevents the need to pass data through many intermediate components that don't directly use the data, simplifying component APIs and making code cleaner.\n*   **Global State Management:** It's suitable for managing global application state that is infrequently updated or doesn't require complex state logic (like authentication, themes, user preferences).\n\n## Limitations\n*   **Performance:** Context is not optimized for high-frequency updates. When the `value` prop of a `Provider` changes, all consuming components re-render, even if they only use a small portion of the context value. For complex, rapidly changing state, dedicated state management libraries (like Redux, Zustand, Recoil) might be more efficient.\n*   **Complexity:** Overuse can lead to a less explicit data flow, making it harder to trace where data comes from.",
          "examples": [
            {
              "id": "example_context_basic_theme",
              "title": "Basic Theme Context Example",
              "code": "import React, { createContext, useContext } from 'react';\n\n// 1. Create a Context object\nconst ThemeContext = createContext('light'); // 'light' is the default value\n\n// Root component that provides the context value\nfunction App() {\n  return (\n    <ThemeContext.Provider value=\"dark\">\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\n// Intermediate component - doesn't need to know about theme, just passes children\nfunction Toolbar() {\n  return <ThemedButton />;\n}\n\n// Component that consumes the context value\nfunction ThemedButton() {\n  // 3. Use the useContext hook to read the context value\n  const theme = useContext(ThemeContext);\n  return (\n    <button style={{ background: theme === 'dark' ? '#333' : '#eee', color: theme === 'dark' ? '#fff' : '#000' }}>\n      {theme} mode\n    </button>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));",
              "explanation": "This example demonstrates the core usage of `createContext`, `Provider`, and `useContext`. The `App` component provides the 'dark' theme value. The `Toolbar` component doesn't receive any props related to the theme, yet `ThemedButton`, nested within it, can directly access the theme value using `useContext(ThemeContext)`. This effectively avoids 'prop drilling' the `theme` prop through `Toolbar`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_context_prop_drilling_mcq",
            "question_context_parts_flashcard",
            "question_context_when_to_use_open",
            "question_context_create_and_consume_code"
          ],
          "relatedTasks": [
            "task_multi_language_context"
          ],
          "tags": [
            "React",
            "Context API",
            "Hooks",
            "State Management",
            "Prop Drilling"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_props"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "dynamic_context",
            "global_state_management"
          ]
        },
        {
          "id": "theory_react_usestate_hook",
          "title": "React useState Hook: Managing Component Local State",
          "content": "The `useState` hook is a fundamental React Hook that allows functional components to manage their own local state. Before hooks, state was primarily managed in class components using `this.state` and `this.setState()`. `useState` simplifies state management in functional components.\n\n## Key Concepts\n\n### 1. Declaration\nThe `useState` hook returns an array with two elements:\n*   The current state value.\n*   A function to update that state value.\n\n`const [stateVariable, setStateVariable] = useState(initialValue);`\n\n`initialValue` is the initial state value. This value is only used during the initial render. For subsequent renders, `useState` returns the current state.\n\n### 2. Updating State\nTo update the state, you call the `setStateVariable` function. When the state is updated, React re-renders the component.\n\n`setStateVariable(newValue);`\n\nIf the new state depends on the previous state, it's best practice to pass a function to the setter:\n\n`setStateVariable(prev => prev + 1);`\n\nThis functional update form ensures you're working with the most up-to-date state value, especially in scenarios with asynchronous updates or multiple state updates queued.\n\n### 3. Immutability\nWhen updating state, you should always treat state as immutable. This means instead of directly modifying an object or array in state, you should create a *new* object or array with the desired changes and then pass that new one to the setter function. This helps React detect changes efficiently and avoid unexpected side effects.\n\n### 4. Asynchronous Updates\n`setState` updates can be asynchronous. React might batch multiple `setState` calls into a single update for performance reasons. This is why using the functional update form is crucial when the next state depends on the previous state.\n\n## When to use `useState`?\n`useState` is ideal for managing state that is local to a single component and doesn't need to be shared across a large part of the application tree. Examples include form input values, toggles, counters, or visibility states of UI elements.",
          "examples": [
            {
              "id": "example_usestate_counter",
              "title": "Basic Counter with useState",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  // Declare a state variable 'count' with an initial value of 0\n  // setCount is the function to update 'count'\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}> {/* Direct update, fine for simple cases */}\n        Click me\n      </button>\n      <button onClick={() => setCount(prevCount => prevCount - 1)}> {/* Functional update, safer */}\n        Decrement\n      </button>\n    </div>\n  );\n}\n\n// ReactDOM.render(<Counter />, document.getElementById('root'));",
              "explanation": "This example shows the most common use case for `useState`: managing a numerical counter. `count` holds the current value, and `setCount` is used to update it. The first button demonstrates a direct update (`count + 1`), which is simple but can have issues if multiple updates are batched. The second button demonstrates the functional update form (`prevCount => prevCount - 1`), which is generally safer as it guarantees you're working with the most recent state value.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_usestate_return_value_flashcard",
            "question_usestate_update_mcq",
            "question_usestate_vs_setstate_open",
            "question_usestate_form_input_code"
          ],
          "relatedTasks": [
            "task_todo_list_usestate"
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "State Management",
            "Functional Components"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components"
          ],
          "complexity": 4,
          "interviewRelevance": 9,
          "learningPath": "beginner",
          "requiredFor": [
            "react_component_development",
            "react_form_handling"
          ]
        },
        {
          "id": "theory_react_dynamic_context_custom_hooks",
          "title": "Dynamic React Context with useState and Custom Hooks",
          "content": "While basic Context API is great for static or rarely changing data, many real-world applications require context values to be dynamic, responding to user actions or data changes. This can be achieved by combining `React.Context` with React's `useState` hook and by encapsulating the consumption logic within custom hooks.\n\n## Key Concepts\n\n### 1. Dynamic Context Value with `useState`\nTo make a context value dynamic, the state that drives the `value` prop of `Context.Provider` should be managed by a `useState` hook (or `useReducer`) within a parent component, typically a dedicated 'Provider' component. This component will then pass both the current state and functions to update that state down through the context `value` prop.\n\nThis pattern allows descendant components to both read the current context value AND trigger changes to it by calling the functions provided by the context.\n\n### 2. Custom Hooks for Context Consumption\nEncapsulating `useContext` within a custom hook offers several benefits:\n*   **Abstraction:** Consumers don't need to directly import `useContext` or the `Context` object. They simply use the custom hook, making the component code cleaner and more readable.\n*   **Error Handling:** A custom hook is the perfect place to add checks to ensure the hook is used within its corresponding `Provider`. If `useContext` returns `undefined` (which it does if no `Provider` is found above it), the custom hook can throw a descriptive error, preventing common bugs and aiding debugging.\n*   **Centralized Logic:** Any specific logic related to the context's data (e.g., derived values, side effects related to context changes) can be managed within the custom hook, keeping components lean.\n\n## Implementation Pattern\n1.  **Create Context:** `const MyContext = React.createContext(initialValue);`\n2.  **Create Provider Component:** A functional component that uses `useState` to manage the dynamic data and wraps its children with `MyContext.Provider`, passing the state and state-modifying functions as the `value` prop.\n3.  **Create Custom Hook:** A functional hook (e.g., `useMyContext`) that calls `useContext(MyContext)`, includes validation (e.g., checking if the context value is `undefined`), and returns the context value.\n4.  **Consume:** Components use the custom hook to access the dynamic context data and functions.\n\nThis pattern is robust for managing application-wide state like authentication, user preferences, or shopping cart data where state changes are initiated by various components.\n\n## Example Flow (User Authentication)\n*   `UserContext` created.\n*   `UserProvider` uses `useState` to hold `user` object and `login`/`logout` functions. These are passed to `UserContext.Provider`.\n*   `useUser` custom hook consumes `UserContext` and checks if a `UserProvider` exists.\n*   `Dashboard` (or any component) uses `useUser` to get `user` info and `logout` function, updating UI based on authentication status and allowing logout.",
          "examples": [
            {
              "id": "example_dynamic_context_user_auth",
              "title": "Dynamic User Authentication Context",
              "code": "import React, { createContext, useContext, useState, useEffect } from 'react';\n\n// 1. Create context\nconst UserContext = createContext(null);\n\n// 2. Context provider component managing dynamic state\nfunction UserProvider({ children }) {\n  const [user, setUser] = useState(null);\n  \n  // Simulate async login\n  const login = (username) => {\n    // In a real app, this would involve API calls\n    console.log(`Attempting login for: ${username}`);\n    setTimeout(() => {\n      setUser({ username, isAdmin: username === 'admin' });\n      console.log(`User logged in: ${username}`);\n    }, 500);\n  };\n  \n  const logout = () => {\n    setUser(null);\n    console.log('User logged out');\n  };\n  \n  const contextValue = { user, login, logout };\n  \n  return (\n    <UserContext.Provider value={contextValue}>\n      {children}\n    </UserContext.Provider>\n  );\n}\n\n// 3. Custom hook for using the context\nfunction useUser() {\n  const context = useContext(UserContext);\n  if (context === null) { // Check for null as default value was null\n    throw new Error('useUser must be used within a UserProvider');\n  }\n  return context;\n}\n\n// 4. Usage example in App and Dashboard components\nfunction LoginScreen() {\n  const { login } = useUser();\n  const [usernameInput, setUsernameInput] = useState('');\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    login(usernameInput);\n  };\n\n  return (\n    <div>\n      <h2>Login</h2>\n      <form onSubmit={handleSubmit}>\n        <input \n          type=\"text\" \n          placeholder=\"Username\" \n          value={usernameInput}\n          onChange={(e) => setUsernameInput(e.target.value)}\n        />\n        <button type=\"submit\">Login</button>\n      </form>\n    </div>\n  );\n}\n\nfunction AdminPanel() {\n  return (\n    <div style={{ border: '1px solid red', padding: '10px', marginTop: '10px' }}>\n      <h3>Admin Controls</h3>\n      <p>Only administrators can see this content.</p>\n    </div>\n  );\n}\n\nfunction Dashboard() {\n  const { user, logout } = useUser();\n  \n  if (!user) return <LoginScreen />;\n  \n  return (\n    <div>\n      <h1>Welcome, {user.username}!</h1>\n      <button onClick={logout}>Logout</button>\n      {user.isAdmin && <AdminPanel />}\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <UserProvider>\n      <Dashboard />\n    </UserProvider>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));",
              "explanation": "This comprehensive example demonstrates dynamic context. `UserProvider` manages the `user` state using `useState` and provides `user`, `login`, and `logout` functions via `UserContext.Provider`. The `useUser` custom hook abstracts the `useContext` call and crucially includes error handling, ensuring `useUser` is always called within a `UserProvider`. The `Dashboard` component then consumes this dynamic context to display user-specific content and manage login/logout flow, showing the power of combining `useState` with Context API for robust state management.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_dynamic_context_benefit_mcq",
            "question_custom_hook_error_flashcard",
            "question_context_vs_redux_open",
            "question_nested_dynamic_context_code"
          ],
          "relatedTasks": [
            "task_shopping_cart_context"
          ],
          "tags": [
            "React",
            "Context API",
            "useState",
            "Custom Hooks",
            "State Management",
            "Authentication",
            "Architecture"
          ],
          "technology": "React",
          "prerequisites": [
            "theory_react_context_fundamentals",
            "theory_react_usestate_hook"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "application_architecture",
            "complex_state_management"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_context_prop_drilling_mcq",
          "topic": "React Context API Fundamentals",
          "level": "easy",
          "type": "mcq",
          "question": "What primary problem does the React Context API help to solve?",
          "answer": "Prop drilling",
          "options": [
            "Component lifecycle management",
            "Asynchronous data fetching",
            "Prop drilling",
            "Styling components"
          ],
          "analysisPoints": [
            "Prop drilling refers to the process of passing data from a parent component down to deeply nested child components through intermediate components that don't actually need the data.",
            "Context API provides a way to make data available to any component in the component tree without explicitly passing it down through props.",
            "Other options relate to different React features (hooks for lifecycle/data fetching, CSS-in-JS for styling)."
          ],
          "keyConcepts": [
            "React Context API",
            "Prop drilling",
            "Component hierarchy",
            "Global state"
          ],
          "evaluationCriteria": [
            "Understanding of the core problem Context API addresses.",
            "Ability to distinguish Context's purpose from other React features."
          ],
          "example": "Prop drilling occurs when a component receives a prop and simply passes it down to its children, even if the component itself doesn't use that prop. This can make code harder to read and maintain. React Context allows a component to 'provide' data that can be consumed by any descendant component without intermediate components needing to explicitly pass it down.",
          "tags": [
            "React",
            "Context API",
            "Prop Drilling"
          ],
          "prerequisites": [
            "react_props",
            "react_component_composition"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_context_parts_flashcard",
          "topic": "React Context API Fundamentals",
          "level": "easy",
          "type": "flashcard",
          "question": "Name the three main parts involved in using the React Context API.",
          "answer": "`React.createContext`, `Context.Provider`, and `useContext` hook.",
          "analysisPoints": [
            "`React.createContext` creates the context object itself.",
            "`Context.Provider` wraps components that need to access the context and provides the `value`.",
            "`useContext` is the hook used within functional components to consume the context `value`."
          ],
          "keyConcepts": [
            "React Context API",
            "createContext",
            "Context.Provider",
            "useContext"
          ],
          "evaluationCriteria": [
            "Recall of fundamental Context API components."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Context API",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_context_when_to_use_open",
          "topic": "React Context API Fundamentals",
          "level": "medium",
          "type": "open",
          "question": "Explain when it's appropriate to use the React Context API versus passing props directly. Provide examples for each scenario.",
          "answer": "Context API is ideal for data that is considered 'global' or 'application-wide' and is needed by many components at different nesting levels, preventing prop drilling. Examples include current authenticated user, theme settings (light/dark mode), preferred language, or global configuration settings. It's generally not suitable for frequently updated state or component-specific state.\n\nPassing props directly is appropriate for data that is directly relevant to a child component and is used only by that child (or a few immediate descendants). This keeps data flow explicit and easy to track. Examples include a `name` prop for a `UserCard` component, an `onClick` handler for a button, or a list of items for a `TodoList` component.",
          "analysisPoints": [
            "Context for 'global' or 'application-wide' concerns that affect many components across the tree.",
            "Props for component-specific data where data flow is direct and explicit.",
            "Consider performance implications for high-frequency updates with Context.",
            "Context can make data flow less explicit and harder to track if overused."
          ],
          "keyConcepts": [
            "React Context API",
            "Props",
            "Prop drilling",
            "Global state",
            "Component composition"
          ],
          "evaluationCriteria": [
            "Ability to differentiate between appropriate use cases for Context and props.",
            "Understanding of the trade-offs (explicitness vs. prop drilling avoidance).",
            "Provision of clear, relevant examples for both scenarios."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Context API",
            "Props",
            "Best Practices"
          ],
          "prerequisites": [
            "react_props",
            "theory_react_context_fundamentals"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_create_and_consume_code",
          "topic": "React Context API Fundamentals",
          "level": "medium",
          "type": "code",
          "question": "Implement a simple logging context. The context should provide a `logMessage` function that accepts a string. Any component can then use this function to log a message to the console. The `Provider` should be able to configure a `prefix` for all log messages.",
          "answer": "```typescript\nimport React, { createContext, useContext } from 'react';\n\n// Create the context with a default value (e.g., an empty function and no prefix)\nconst LogContext = createContext({\n  logMessage: (message: string) => console.log(`[DEFAULT]: ${message}`),\n  prefix: 'DEFAULT',\n});\n\n// Provider component\nfunction LogProvider({ children, prefix = 'APP' }) {\n  const logMessage = (message: string) => {\n    console.log(`[${prefix}]: ${message}`);\n  };\n\n  const value = { logMessage, prefix };\n\n  return (\n    <LogContext.Provider value={value}>\n      {children}\n    </LogContext.Provider>\n  );\n}\n\n// Custom hook to consume the context (optional, but good practice)\nfunction useLogger() {\n  const context = useContext(LogContext);\n  // Optional: Add error handling if not used within a provider\n  if (context === undefined) {\n    throw new Error('useLogger must be used within a LogProvider');\n  }\n  return context;\n}\n\n// Example usage:\nfunction ComponentA() {\n  const { logMessage } = useLogger();\n  return (\n    <button onClick={() => logMessage('Button A clicked!')}>\n      Log from A\n    </button>\n  );\n}\n\nfunction ComponentB() {\n  const { logMessage, prefix } = useLogger();\n  return (\n    <div>\n      <p>Current log prefix: {prefix}</p>\n      <button onClick={() => logMessage('Button B clicked from ' + prefix)}>\n        Log from B\n      </button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <LogProvider prefix=\"MAIN_APP\">\n      <h1>Logging App</h1>\n      <ComponentA />\n      <ComponentB />\n      <LogProvider prefix=\"SUB_SYSTEM\">\n        <ComponentA />\n        <p>This button uses the SUB_SYSTEM prefix:</p>\n        <ComponentB />\n      </LogProvider>\n    </LogProvider>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n```",
          "analysisPoints": [
            "Correct use of `createContext` to define the context shape.",
            "Implementation of a `Provider` component that accepts a prop (`prefix`) to dynamically set the context value.",
            "Demonstration of passing both data (`prefix`) and functions (`logMessage`) through context.",
            "Proper consumption of the context using `useContext` within functional components.",
            "The optional `useLogger` custom hook demonstrates best practices for abstracting context consumption and adding error handling."
          ],
          "keyConcepts": [
            "React Context API",
            "createContext",
            "Context.Provider",
            "useContext",
            "Passing functions via context",
            "Custom Hooks"
          ],
          "evaluationCriteria": [
            "Correct context creation and provision.",
            "Ability to pass dynamic values (props to context).",
            "Correct consumption of context values and functions.",
            "Understanding of context's role in global utility functions."
          ],
          "example": "```typescript\n// See solutionCode for a complete example.\n```",
          "tags": [
            "React",
            "Context API",
            "Hooks",
            "Code Challenge"
          ],
          "prerequisites": [
            "theory_react_context_fundamentals"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_usestate_return_value_flashcard",
          "topic": "useState Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What does the `useState` hook return?",
          "answer": "An array containing two elements: the current state value and a function to update that state.",
          "analysisPoints": [
            "The first element is the state variable itself.",
            "The second element is the 'setter' function for that state variable, typically named `set[StateVariable]`."
          ],
          "keyConcepts": [
            "useState",
            "React Hooks",
            "State variable",
            "Setter function"
          ],
          "evaluationCriteria": [
            "Recall of `useState`'s return signature."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_usestate_update_mcq",
          "topic": "useState Hook",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following React component, what will be the value of `count` after the button is clicked twice in quick succession?\n\n```typescript\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  const handleClick = () => {\n    setCount(count + 1); // Line A\n    setCount(count + 1); // Line B\n  };\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Increment Twice</button>\n    </div>\n  );\n}\n```",
          "answer": "1",
          "options": [
            "0",
            "1",
            "2",
            "Undefined"
          ],
          "analysisPoints": [
            "React `setState` updates are often asynchronous and batched for performance.",
            "When `handleClick` is called, `count` is `0` at the start of the function execution.",
            "Both `setCount(count + 1)` calls (Line A and Line B) will use the *stale* `count` value from the closure (which is `0`).",
            "So, `setCount(0 + 1)` happens twice. Due to batching, React performs a single re-render, and the last update for the same state variable 'wins' if not using the functional update form.",
            "However, in modern React (React 18+ and concurrent mode), `useState` updates inside event handlers are batched. If you call `setCount(0 + 1)` twice, it will result in `count` being `1` after the first click.",
            "To get `2`, you would need to use the functional update form: `setCount(prevCount => prevCount + 1);`"
          ],
          "keyConcepts": [
            "useState",
            "State updates",
            "Asynchronous updates",
            "Batching",
            "Functional updates"
          ],
          "evaluationCriteria": [
            "Understanding of `useState`'s asynchronous nature.",
            "Knowledge of state batching in React.",
            "Distinction between direct and functional state updates."
          ],
          "example": "When the button is clicked, `handleClick` executes. At this point, `count` is `0`. Both `setCount(count + 1)` calls resolve to `setCount(0 + 1)`, i.e., `setCount(1)`. Since React batches state updates within the same event loop, and both `setCount(1)` calls are effectively setting the state to the *same new value*, the component will only update `count` to `1` once. If you wanted it to be `2`, you would need to use `setCount(prevCount => prevCount + 1)` which uses the previous state value correctly.",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "State Management",
            "Concurrency"
          ],
          "prerequisites": [
            "theory_react_usestate_hook"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_usestate_vs_setstate_open",
          "topic": "useState Hook",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast `useState` in functional components with `this.state` and `this.setState` in class components. Highlight key differences in usage and behavior.",
          "answer": "`useState` and `this.state`/`this.setState` both serve to manage component-local state in React, but they differ significantly in their API and underlying behavior.\n\n**`useState` (Functional Components):**\n*   **Declaration:** Uses array destructuring: `const [state, setState] = useState(initialValue);`.\n*   **Updating State:** Replaces the state value entirely (`setState(newValue)`) unless using functional updates (`setState(prev => prev + 1)`). When updating an object, you must manually merge it (`setState({ ...prevState, newProp: 'value' })`).\n*   **Nature:** Each `useState` call manages an independent piece of state. You can have multiple `useState` calls in a single component.\n*   **Binding:** No `this` context issues; `setState` is a stable function reference.\n*   **Initial State:** `initialValue` is only used on the initial render.\n*   **Readability:** Generally leads to more concise and readable code for state management.\n\n**`this.state` / `this.setState` (Class Components):**\n*   **Declaration:** Declared as an object within the class constructor: `this.state = { key: value };`.\n*   **Updating State:** Merges the new state object with the current state object (`this.setState({ newProp: 'value' })`). It performs a shallow merge.\n*   **Nature:** All state is typically held in a single `this.state` object.\n*   **Binding:** `this.setState` automatically binds `this`, but custom methods need to be bound or use arrow functions to correctly access `this`.\n*   **Initial State:** Set in the constructor.\n*   **Readability:** Can become verbose, especially with multiple state properties or complex updates.\n\n**Key Differences:**\n1.  **State Structure:** `useState` allows multiple distinct state variables, while class components typically use a single state object.\n2.  **Merging Behavior:** `this.setState` automatically merges state objects; `useState`'s setter *replaces* the state, requiring manual merging for objects/arrays.\n3.  **`this` Context:** `useState` avoids `this` binding complexities.\n4.  **Immutability Enforcement:** `useState` naturally encourages immutable updates as it replaces the value, whereas `this.setState`'s merging behavior can sometimes lead to mutations if not careful.\n5.  **Simplicity for Simple State:** `useState` is often simpler for primitive values or isolated pieces of state.\n\nIn modern React development, `useState` is the preferred approach for local state management in functional components due to its simplicity and alignment with the React Hooks paradigm.",
          "analysisPoints": [
            "Ability to articulate the API differences.",
            "Understanding of state merging vs. replacement.",
            "Discussion of `this` context.",
            "Emphasis on immutability and functional updates."
          ],
          "keyConcepts": [
            "useState",
            "Class components",
            "Functional components",
            "State management",
            "Immutability",
            "React Hooks"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison of state management mechanisms.",
            "Clear articulation of advantages/disadvantages.",
            "Accuracy in describing behavioral differences (merging, `this` context)."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "Class Components",
            "Comparison"
          ],
          "prerequisites": [
            "react_functional_components",
            "react_class_components",
            "theory_react_usestate_hook"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_usestate_form_input_code",
          "topic": "useState Hook",
          "level": "medium",
          "type": "code",
          "question": "Create a React functional component `TextInput` that renders an `<input type=\"text\">` element. Use the `useState` hook to manage the input's value, ensuring it's a controlled component. Add a `<span>` or `<p>` tag that displays the current value of the input.",
          "answer": "```typescript\nimport React, { useState } from 'react';\n\nfunction TextInput() {\n  const [inputValue, setInputValue] = useState('');\n\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setInputValue(event.target.value);\n  };\n\n  return (\n    <div>\n      <label htmlFor=\"myInput\">Enter text:</label>\n      <input\n        id=\"myInput\"\n        type=\"text\"\n        value={inputValue} // Makes it a controlled component\n        onChange={handleChange}\n        placeholder=\"Type something...\"\n      />\n      <p>Current value: <strong>{inputValue}</strong></p>\n    </div>\n  );\n}\n\n// ReactDOM.render(<TextInput />, document.getElementById('root'));\n```",
          "analysisPoints": [
            "Correct use of `useState` to declare `inputValue` and `setInputValue`.",
            "Binding `inputValue` to the `<input>` element's `value` prop, making it a controlled component.",
            "Implementing an `onChange` handler that updates the state using `setInputValue(event.target.value)`.",
            "Displaying the current state value to confirm reactivity."
          ],
          "keyConcepts": [
            "useState",
            "Controlled components",
            "Form handling",
            "Event handlers"
          ],
          "evaluationCriteria": [
            "Ability to implement a controlled input.",
            "Correct use of `useState` for form elements.",
            "Understanding of `onChange` event and `event.target.value`."
          ],
          "example": "```typescript\n// See solutionCode for a complete example.\n```",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "Forms",
            "Controlled Components",
            "Code Challenge"
          ],
          "prerequisites": [
            "theory_react_usestate_hook"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_dynamic_context_benefit_mcq",
          "topic": "Dynamic React Context with useState and Custom Hooks",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a primary benefit of using a custom hook (like `useUser`) to consume a React Context with dynamic state?",
          "answer": "Eliminates the need for `React.createContext`",
          "options": [
            "Abstracts context consumption logic",
            "Provides centralized error handling for missing providers",
            "Allows state to be managed externally from the component tree",
            "Eliminates the need for `React.createContext`"
          ],
          "analysisPoints": [
            "A custom hook *does* abstract consumption logic, making component code cleaner.",
            "It *can* provide centralized error handling (e.g., throwing an error if context is `undefined`/`null`).",
            "The state is still managed *within* the React component tree (specifically, in the `Provider` component using `useState`), not externally. It just makes it available to *many* components.",
            "The `React.createContext` call is still absolutely necessary to define the context object itself; the custom hook merely *consumes* it, it doesn't create or replace it."
          ],
          "keyConcepts": [
            "React Context API",
            "Custom Hooks",
            "Dynamic state",
            "Abstraction",
            "Error handling"
          ],
          "evaluationCriteria": [
            "Understanding of the benefits of custom hooks in conjunction with Context.",
            "Ability to identify incorrect claims about Context API's core mechanics."
          ],
          "example": "A custom hook like `useUser` simplifies how components interact with the `UserContext`. Instead of writing `const userContext = useContext(UserContext); if (!userContext) throw new Error(...)` in every component, you just call `const { user, login } = useUser();`. However, `React.createContext` is still the fundamental building block for creating the context object itself.",
          "tags": [
            "React",
            "Context API",
            "Custom Hooks",
            "Best Practices"
          ],
          "prerequisites": [
            "theory_react_dynamic_context_custom_hooks"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_custom_hook_error_flashcard",
          "topic": "Dynamic React Context with useState and Custom Hooks",
          "level": "medium",
          "type": "flashcard",
          "question": "What common error scenario does the `if (context === undefined) { throw new Error(...) }` check inside a custom context hook (like `useUser`) prevent?",
          "answer": "It prevents runtime errors (e.g., trying to access properties of `null` or `undefined`) when a component tries to use the custom hook outside of its corresponding `Provider`.",
          "analysisPoints": [
            "`useContext` returns the `defaultValue` (or `null`/`undefined` if that was the default) if no `Provider` is found.",
            "Without this check, accessing properties like `context.user` or `context.login` would throw a TypeError.",
            "The check provides a more descriptive and actionable error message during development, guiding the developer to wrap the component in the necessary `Provider`."
          ],
          "keyConcepts": [
            "Custom Hooks",
            "useContext",
            "Error handling",
            "Context.Provider",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Understanding of `useContext` behavior when a `Provider` is missing.",
            "Recognition of the importance of robust error handling in custom hooks."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Context API",
            "Custom Hooks",
            "Error Handling",
            "Flashcard"
          ],
          "prerequisites": [
            "theory_react_dynamic_context_custom_hooks"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_vs_redux_open",
          "topic": "Dynamic React Context with useState and Custom Hooks",
          "level": "hard",
          "type": "open",
          "question": "Discuss the trade-offs between using React Context API (especially with `useState` for dynamic state) and a dedicated state management library like Redux for global application state. When might you choose one over the other?",
          "answer": "Both React Context API (especially when paired with `useState`/`useReducer` in a Provider component) and Redux (or similar libraries like Zustand, Recoil) aim to solve global state management. However, they have different philosophies and use cases.\n\n**React Context API (with `useState`/`useReducer`):**\n*   **Pros:** Simplicity, built-in to React, less boilerplate for simple global state, good for themes/user preferences/authentication where updates are less frequent.\n*   **Cons:** Re-renders all consumers when context value changes (can be a performance issue for frequently updated state), lacks developer tools for tracing state changes, no built-in middleware or explicit architecture for complex async logic.\n*   **When to Choose:** For small-to-medium applications, simpler global concerns, or when you want to avoid adding a third-party dependency. It's a great choice when prop drilling is the main issue and state updates are not extremely frequent or complex.\n\n**Redux (or similar centralized stores):**\n*   **Pros:** Centralized store for predictable state, robust ecosystem (middleware for async actions, dev tools for time-travel debugging), highly optimized re-renders with selectors (e.g., `react-redux`'s `useSelector`), scalable for large and complex applications, enforced patterns (actions, reducers) promote maintainability.\n*   **Cons:** More boilerplate, steeper learning curve, can feel over-engineered for small apps, requires additional libraries (`react-redux`, `redux-thunk`/`redux-saga`).\n*   **When to Choose:** For large-scale applications, highly interactive UIs with frequent state changes, complex asynchronous logic, strict data flow requirements, or when robust debugging and predictable state are paramount.\n\n**Trade-offs Summary:**\n*   **Complexity/Boilerplate:** Context is simpler, Redux is more verbose.\n*   **Performance:** Redux with selectors can be more performant for granular updates; Context re-renders all consumers on value change unless custom memoization is applied.\n*   **Debugging/DevTools:** Redux has excellent dev tools; Context requires manual logging.\n*   **Scalability/Architecture:** Redux provides a strong architectural pattern for large apps; Context can become less manageable if overused for complex state.\n\n**Conclusion:** Use Context for straightforward, less frequently updated global state. Opt for Redux (or a similar solution) when your application's state becomes complex, highly dynamic, or requires advanced debugging and predictable state transitions.",
          "analysisPoints": [
            "Comprehensive understanding of both technologies' strengths and weaknesses.",
            "Ability to identify appropriate use cases based on application scale and complexity.",
            "Discussion of performance, debugging, and architectural implications.",
            "Nuanced perspective on 'global state' and how each addresses it."
          ],
          "keyConcepts": [
            "React Context API",
            "Redux",
            "State Management",
            "Global State",
            "Performance",
            "Scalability",
            "Boilerplate",
            "DevTools"
          ],
          "evaluationCriteria": [
            "Depth of knowledge regarding state management solutions.",
            "Ability to articulate clear criteria for technology selection.",
            "Balanced perspective on advantages and disadvantages."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Context API",
            "Redux",
            "State Management",
            "Architecture",
            "Comparison"
          ],
          "prerequisites": [
            "theory_react_context_fundamentals",
            "theory_react_dynamic_context_custom_hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_nested_dynamic_context_code",
          "topic": "Dynamic React Context with useState and Custom Hooks",
          "level": "hard",
          "type": "code",
          "question": "Create two independent dynamic contexts: `UserContext` (providing `user` object, `login`, `logout`) and `SettingsContext` (providing `theme` string, `toggleTheme` function). \n\nImplement `UserProvider` and `SettingsProvider` components using `useState`.\n\nThen, create a custom hook `useAuth` for `UserContext` and `useSettings` for `SettingsContext`, including appropriate error handling if a provider is missing.\n\nFinally, demonstrate how to use both contexts in an `App` component that displays user status and allows toggling the theme, ensuring only authenticated users can see a 'Profile' button that respects the theme.",
          "answer": "```typescript\nimport React, { createContext, useContext, useState, useEffect } from 'react';\n\n// --- User Context --- //\nconst UserContext = createContext(null);\n\nfunction UserProvider({ children }) {\n  const [user, setUser] = useState(null);\n\n  const login = (username) => {\n    // Simulate API call\n    setTimeout(() => {\n      setUser({ username, id: '123' });\n      console.log(`${username} logged in.`);\n    }, 300);\n  };\n\n  const logout = () => {\n    setUser(null);\n    console.log('User logged out.');\n  };\n\n  const value = { user, login, logout };\n\n  return (\n    <UserContext.Provider value={value}>\n      {children}\n    </UserContext.Provider>\n  );\n}\n\nfunction useAuth() {\n  const context = useContext(UserContext);\n  if (context === null) {\n    throw new Error('useAuth must be used within a UserProvider');\n  }\n  return context;\n}\n\n// --- Settings Context --- //\nconst SettingsContext = createContext(null);\n\nfunction SettingsProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));\n  };\n\n  const value = { theme, toggleTheme };\n\n  return (\n    <SettingsContext.Provider value={value}>\n      {children}\n    </SettingsContext.Provider>\n  );\n}\n\nfunction useSettings() {\n  const context = useContext(SettingsContext);\n  if (context === null) {\n    throw new Error('useSettings must be used within a SettingsProvider');\n  }\n  return context;\n}\n\n// --- Application Components --- //\n\nfunction ProfileButton() {\n  const { user } = useAuth();\n  const { theme } = useSettings();\n\n  if (!user) return null; // Only show if authenticated\n\n  return (\n    <button style={{ \n      background: theme === 'dark' ? '#555' : '#ccc',\n      color: theme === 'dark' ? '#fff' : '#000',\n      padding: '10px',\n      margin: '5px'\n    }}>\n      View Profile ({user.username})\n    </button>\n  );\n}\n\nfunction AuthSection() {\n  const { user, login, logout } = useAuth();\n  const [usernameInput, setUsernameInput] = useState('');\n\n  const handleLogin = () => login(usernameInput || 'guest');\n\n  return (\n    <div>\n      {user ? (\n        <div>\n          <p>Logged in as: <strong>{user.username}</strong></p>\n          <button onClick={logout}>Logout</button>\n        </div>\n      ) : (\n        <div>\n          <input \n            type=\"text\" \n            placeholder=\"Username\" \n            value={usernameInput}\n            onChange={(e) => setUsernameInput(e.target.value)}\n          />\n          <button onClick={handleLogin}>Login</button>\n        </div>\n      )}\n    </div>\n  );\n}\n\nfunction ThemeToggle() {\n  const { theme, toggleTheme } = useSettings();\n  return (\n    <button onClick={toggleTheme} style={{ margin: '10px 0' }}>\n      Toggle Theme ({theme})\n    </button>\n  );\n}\n\nfunction App() {\n  return (\n    <UserProvider>\n      <SettingsProvider>\n        <div style={{ padding: '20px', border: '1px solid #ddd' }}>\n          <h1>App Header</h1>\n          <AuthSection />\n          <ThemeToggle />\n          <ProfileButton />\n        </div>\n      </SettingsProvider>\n    </UserProvider>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n```",
          "analysisPoints": [
            "Correct creation of two distinct `Context` objects.",
            "Implementation of two independent `Provider` components (`UserProvider`, `SettingsProvider`), each managing its own state with `useState` and passing both state and setter functions via context.",
            "Development of two custom hooks (`useAuth`, `useSettings`), each encapsulating its `useContext` call and including robust error handling for missing providers.",
            "Demonstration of nested `Provider` usage in the `App` component.",
            "Effective consumption of both contexts in `ProfileButton` and `AuthSection` components, showcasing conditional rendering and stylistic changes based on context values."
          ],
          "keyConcepts": [
            "React Context API",
            "Dynamic Context",
            "useState",
            "Custom Hooks",
            "Nested Providers",
            "Global State Management",
            "Authentication",
            "Theming",
            "Code Organization"
          ],
          "evaluationCriteria": [
            "Ability to create and manage multiple independent contexts.",
            "Correct implementation of custom hooks with error handling.",
            "Understanding of how to nest providers and consume multiple contexts.",
            "Practical application of context for common UI patterns (authentication, theming)."
          ],
          "example": "```typescript\n// See solutionCode for a complete example.\n```",
          "tags": [
            "React",
            "Context API",
            "Hooks",
            "useState",
            "Custom Hooks",
            "State Management",
            "Authentication",
            "Theming",
            "Architecture",
            "Code Challenge"
          ],
          "prerequisites": [
            "theory_react_context_fundamentals",
            "theory_react_usestate_hook",
            "theory_react_dynamic_context_custom_hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_multi_language_context",
          "title": "Implement a Multi-Language Context",
          "description": "\nImplement a React context for managing the application's language. Your solution should:\n\n1.  Define a `LanguageContext` using `React.createContext` with a default value (e.g., 'en').\n2.  Create a `LanguageProvider` component that wraps the application. It should manage the current language state using `useState` and provide the current language string and a `setLanguage` function through the context.\n3.  Create a custom hook `useLanguage` that consumes the `LanguageContext` and provides robust error handling if used outside the `LanguageProvider`.\n4.  Develop a `LanguageSwitcher` component that uses `useLanguage` to display the current language and offers buttons (or a dropdown) to change the language to 'en' (English) or 'es' (Spanish).\n5.  Create a `GreetingMessage` component that also uses `useLanguage` to display a greeting appropriate for the current language (e.g., 'Hello!' for 'en', 'Â¡Hola!' for 'es').\n6.  Integrate these components into an `App` component to demonstrate the language switching functionality.",
          "difficulty": "medium",
          "startingCode": "import React, { createContext, useContext, useState } from 'react';\n\n// 1. Create LanguageContext\n// TODO: Implement LanguageContext with a default value\n\n// 2. Create LanguageProvider component\n// TODO: Implement LanguageProvider to manage language state and provide it via context\n\n// 3. Create useLanguage custom hook\n// TODO: Implement useLanguage with error handling\n\n// 4. LanguageSwitcher component\nfunction LanguageSwitcher() {\n  // TODO: Use useLanguage to display current language and provide buttons to change it\n  return (\n    <div>\n      <h3>Current Language: {/* Display current language here */ }</h3>\n      <button onClick={() => {/* Change to English */}}>English</button>\n      <button onClick={() => {/* Change to Spanish */}}>EspaÃ±ol</button>\n    </div>\n  );\n}\n\n// 5. GreetingMessage component\nfunction GreetingMessage() {\n  // TODO: Use useLanguage to display a language-specific greeting\n  return (\n    <p>{/* Display greeting here */}</p>\n  );\n}\n\n// 6. App component\nfunction App() {\n  return (\n    // TODO: Wrap components with LanguageProvider\n    <div>\n      <h1>Multi-Language App</h1>\n      <LanguageSwitcher />\n      <GreetingMessage />\n    </div>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));",
          "solutionCode": "import React, { createContext, useContext, useState } from 'react';\n\n// 1. Create LanguageContext\nconst LanguageContext = createContext(null); // Using null as default to enforce provider check\n\n// 2. Create LanguageProvider component\nfunction LanguageProvider({ children }) {\n  const [language, setLanguage] = useState('en'); // Default language is English\n\n  const value = { language, setLanguage };\n\n  return (\n    <LanguageContext.Provider value={value}>\n      {children}\n    </LanguageContext.Provider>\n  );\n}\n\n// 3. Create useLanguage custom hook\nfunction useLanguage() {\n  const context = useContext(LanguageContext);\n  if (context === null) {\n    throw new Error('useLanguage must be used within a LanguageProvider');\n  }\n  return context;\n}\n\n// 4. LanguageSwitcher component\nfunction LanguageSwitcher() {\n  const { language, setLanguage } = useLanguage();\n\n  return (\n    <div>\n      <h3>Current Language: {language.toUpperCase()}</h3>\n      <button onClick={() => setLanguage('en')} disabled={language === 'en'}>\n        English\n      </button>\n      <button onClick={() => setLanguage('es')} disabled={language === 'es'}>\n        EspaÃ±ol\n      </button>\n    </div>\n  );\n}\n\n// 5. GreetingMessage component\nconst greetings = {\n  en: 'Hello! Welcome to our app!',\n  es: 'Â¡Hola! Â¡Bienvenido a nuestra aplicaciÃ³n!',\n};\n\nfunction GreetingMessage() {\n  const { language } = useLanguage();\n  const greeting = greetings[language] || greetings['en']; // Fallback to English\n  return (\n    <p style={{ fontSize: '1.2em', fontWeight: 'bold' }}>{greeting}</p>\n  );\n}\n\n// 6. App component\nfunction App() {\n  return (\n    <LanguageProvider>\n      <div style={{ fontFamily: 'Arial, sans-serif', padding: '20px', border: '1px solid #eee', borderRadius: '8px' }}>\n        <h1>Multi-Language App Demo</h1>\n        <LanguageSwitcher />\n        <GreetingMessage />\n        <hr/>\n        <p>This paragraph is always in English, demonstrating non-contextual text.</p>\n      </div>\n    </LanguageProvider>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));",
          "testCases": [
            "Initial render: `GreetingMessage` should display 'Hello!' and `LanguageSwitcher` should show 'Current Language: EN'.",
            "Click 'EspaÃ±ol' button: `GreetingMessage` should change to 'Â¡Hola!' and `LanguageSwitcher` to 'Current Language: ES'.",
            "Click 'English' button: `GreetingMessage` should change back to 'Hello!' and `LanguageSwitcher` to 'Current Language: EN'.",
            "Using `useLanguage` outside `LanguageProvider`: Should throw an error 'useLanguage must be used within a LanguageProvider'."
          ],
          "hints": [
            "Remember that `useContext` needs the Context object itself, not the Provider component.",
            "The `value` prop of `Context.Provider` can be an object containing both state and setter functions.",
            "Consider providing a default value to `createContext` or handling `null`/`undefined` in your `useContext` hook for robustness.",
            "For the `GreetingMessage`, a simple object mapping languages to greetings can be effective."
          ],
          "tags": [
            "React",
            "Context API",
            "useState",
            "Hooks",
            "Internationalization",
            "State Management"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_react_context_fundamentals",
            "theory_react_usestate_hook",
            "theory_react_dynamic_context_custom_hooks"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "prop_drilling",
            "global_state"
          ]
        },
        {
          "id": "task_todo_list_usestate",
          "title": "Build a Simple Todo List with `useState`",
          "description": "\nCreate a basic Todo List application using only the `useState` hook. Your application should:\n\n1.  Display a list of todos.\n2.  Allow users to add new todos via an input field and a button.\n3.  Allow users to delete a todo by clicking a 'Delete' button next to each item.\n4.  Each todo item should have a unique ID (you can use `Date.now()` or a simple counter for this).\n5.  Ensure that state updates are handled immutably.",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\nfunction TodoList() {\n  const [todos, setTodos] = useState([]);\n  const [newTodoText, setNewTodoText] = useState('');\n\n  const handleAddTodo = () => {\n    // TODO: Add a new todo to the 'todos' array\n    // Ensure unique ID for each todo, e.g., { id: Date.now(), text: newTodoText }\n    // Clear the input field after adding\n  };\n\n  const handleDeleteTodo = (id) => {\n    // TODO: Filter out the todo with the given ID from the 'todos' array\n  };\n\n  return (\n    <div>\n      <h1>My Todo List</h1>\n      <div>\n        <input\n          type=\"text\"\n          value={newTodoText}\n          onChange={(e) => setNewTodoText(e.target.value)}\n          placeholder=\"Add a new todo\"\n        />\n        <button onClick={handleAddTodo}>Add Todo</button>\n      </div>\n      <ul>\n        {/* TODO: Map over 'todos' to display each item with a delete button */}\n        {todos.map(todo => (\n          <li key={todo.id}>\n            {todo.text}\n            <button onClick={() => handleDeleteTodo(todo.id)} style={{ marginLeft: '10px' }}>\n              Delete\n            </button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// ReactDOM.render(<TodoList />, document.getElementById('root'));",
          "solutionCode": "import React, { useState } from 'react';\n\nfunction TodoList() {\n  const [todos, setTodos] = useState([]); // State for the list of todos\n  const [newTodoText, setNewTodoText] = useState(''); // State for the new todo input\n\n  const handleAddTodo = () => {\n    if (newTodoText.trim() === '') return; // Prevent adding empty todos\n\n    const newTodo = {\n      id: Date.now(), // Simple unique ID generation\n      text: newTodoText.trim(),\n    };\n\n    // Immutable update: Create a new array with the new todo appended\n    setTodos(prevTodos => [...prevTodos, newTodo]);\n    setNewTodoText(''); // Clear the input field\n  };\n\n  const handleDeleteTodo = (id) => {\n    // Immutable update: Filter out the todo to be deleted\n    setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id));\n  };\n\n  return (\n    <div style={{ fontFamily: 'Arial, sans-serif', maxWidth: '400px', margin: '20px auto', border: '1px solid #ddd', padding: '20px', borderRadius: '8px' }}>\n      <h1>My Todo List</h1>\n      <div style={{ marginBottom: '15px' }}>\n        <input\n          type=\"text\"\n          value={newTodoText}\n          onChange={(e) => setNewTodoText(e.target.value)}\n          onKeyPress={(e) => { // Allow adding with Enter key\n            if (e.key === 'Enter') handleAddTodo();\n          }}\n          placeholder=\"Add a new todo\"\n          style={{ padding: '8px', marginRight: '10px', border: '1px solid #ccc', borderRadius: '4px', width: 'calc(100% - 90px)' }}\n        />\n        <button onClick={handleAddTodo} style={{ padding: '8px 12px', background: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>\n          Add Todo\n        </button>\n      </div>\n      <ul style={{ listStyle: 'none', padding: 0 }}>\n        {todos.length === 0 && <p>No todos yet! Add some above.</p>}\n        {todos.map(todo => (\n          <li\n            key={todo.id}\n            style={{\n              display: 'flex',\n              justifyContent: 'space-between',\n              alignItems: 'center',\n              padding: '10px',\n              borderBottom: '1px solid #eee',\n              marginBottom: '5px',\n              backgroundColor: '#f9f9f9',\n              borderRadius: '4px'\n            }}\n          >\n            <span>{todo.text}</span>\n            <button\n              onClick={() => handleDeleteTodo(todo.id)}\n              style={{\n                padding: '6px 10px',\n                background: '#dc3545',\n                color: 'white',\n                border: 'none',\n                borderRadius: '4px',\n                cursor: 'pointer'\n              }}\n            >\n              Delete\n            </button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// ReactDOM.render(<TodoList />, document.getElementById('root'));",
          "testCases": [
            "Initial render: List should be empty, input field clear.",
            "Add todo: Type 'Learn React', click 'Add Todo'. List should show 'Learn React'. Input field should clear.",
            "Add another todo: Type 'Build projects', click 'Add Todo'. List should show both 'Learn React' and 'Build projects'.",
            "Delete todo: Click 'Delete' next to 'Learn React'. Only 'Build projects' should remain.",
            "Add empty string: Clicking 'Add Todo' with empty input should do nothing.",
            "Enter key: Pressing Enter in the input field should add the todo.",
            "Immutable updates: Verify that `setTodos` is always called with a new array reference (e.g., using `[...prevTodos, newTodo]` and `prevTodos.filter(...)`)."
          ],
          "hints": [
            "Remember that `setTodos` takes a new array, not a modified version of the old one. Use spread syntax (`...`) for adding and `filter()` for deleting.",
            "To clear the input field after adding, call `setNewTodoText('')`.",
            "You can add an `onKeyPress` event handler to the input to add todos when the Enter key is pressed."
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "CRUD",
            "Forms",
            "State Management",
            "Immutability"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_react_usestate_hook"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "controlled_components",
            "event_handling"
          ]
        },
        {
          "id": "task_shopping_cart_context",
          "title": "Implement a Shopping Cart with Dynamic Context",
          "description": "\nBuild a simplified shopping cart feature for an e-commerce application using React Context API, `useState`, and custom hooks. The core functionality should include:\n\n1.  **`CartContext`**: Create a context to hold the `cartItems` (an array of `{ id, name, price, quantity }` objects), and functions to `addItemToCart`, `removeItemFromCart`, and `clearCart`.\n2.  **`CartProvider`**: A component that manages the `cartItems` state using `useState` and provides these items and functions through `CartContext.Provider`.\n3.  **`useCart` Custom Hook**: A custom hook that consumes `CartContext`, ensuring proper error handling if used outside `CartProvider`.\n4.  **`ProductList` Component**: Display a few dummy products. Each product should have an 'Add to Cart' button that uses `addItemToCart`.\n5.  **`CartSummary` Component**: Display the current items in the cart, their quantities, total price, and a 'Remove' button for each item (using `removeItemFromCart`). Include a 'Clear Cart' button.\n6.  **`App` Component**: Integrate `CartProvider`, `ProductList`, and `CartSummary` to demonstrate the full flow.\n\n**Requirements:**\n*   When adding an item already in the cart, its `quantity` should increase, not add a duplicate entry.\n*   `removeItemFromCart` should remove the entire item from the cart, regardless of quantity.\n*   Calculate and display the total cart value in `CartSummary`.\n*   Ensure all state updates are immutable.",
          "difficulty": "hard",
          "startingCode": "import React, { createContext, useContext, useState } from 'react';\n\n// 1. Create CartContext\n// TODO: Define CartContext with initial null or empty value\n\n// 2. Create CartProvider component\nfunction CartProvider({ children }) {\n  const [cartItems, setCartItems] = useState([]);\n\n  // TODO: Implement addItemToCart, removeItemFromCart, clearCart functions\n  // addItemToCart: Should update quantity if item exists, otherwise add new item\n  // removeItemFromCart: Should remove item regardless of quantity\n  // clearCart: Should empty the cart\n\n  const value = { /* TODO: provide cartItems and functions */ };\n\n  return (\n    <CartContext.Provider value={value}>\n      {children}\n    </CartContext.Provider>\n  );\n}\n\n// 3. Create useCart custom hook\nfunction useCart() {\n  // TODO: Consume CartContext and add error handling\n  return {}; // Placeholder\n}\n\n// Dummy Products (use these)\nconst products = [\n  { id: 'p1', name: 'Laptop', price: 1200 },\n  { id: 'p2', name: 'Mouse', price: 25 },\n  { id: 'p3', name: 'Keyboard', price: 75 },\n];\n\n// 4. ProductList Component\nfunction ProductList() {\n  const { addItemToCart } = useCart();\n\n  return (\n    <div>\n      <h2>Available Products</h2>\n      {products.map(product => (\n        <div key={product.id} style={{ border: '1px solid #ccc', padding: '10px', margin: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n          <span>{product.name} - ${product.price}</span>\n          <button onClick={() => addItemToCart(product)}>Add to Cart</button>\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// 5. CartSummary Component\nfunction CartSummary() {\n  const { cartItems, removeItemFromCart, clearCart } = useCart();\n\n  // TODO: Calculate total price\n  const total = 0;\n\n  return (\n    <div>\n      <h2>Shopping Cart</h2>\n      {cartItems.length === 0 ? (\n        <p>Your cart is empty.</p>\n      ) : (\n        <div>\n          <ul>\n            {cartItems.map(item => (\n              <li key={item.id} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '5px' }}>\n                <span>{item.name} (x{item.quantity}) - ${item.price * item.quantity}</span>\n                <button onClick={() => removeItemFromCart(item.id)}>Remove</button>\n              </li>\n            ))}\n          </ul>\n          <h3>Total: ${total.toFixed(2)}</h3>\n          <button onClick={clearCart}>Clear Cart</button>\n        </div>\n      )}\n    </div>\n  );\n}\n\n// 6. App Component\nfunction App() {\n  return (\n    <CartProvider>\n      <div style={{ display: 'flex', gap: '20px', padding: '20px' }}>\n        <ProductList />\n        <CartSummary />\n      </div>\n    </CartProvider>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));",
          "solutionCode": "import React, { createContext, useContext, useState, useMemo } from 'react';\n\n// 1. Create CartContext\nconst CartContext = createContext(null);\n\n// 2. Create CartProvider component\nfunction CartProvider({ children }) {\n  const [cartItems, setCartItems] = useState([]);\n\n  const addItemToCart = (product) => {\n    setCartItems(prevItems => {\n      const existingItem = prevItems.find(item => item.id === product.id);\n\n      if (existingItem) {\n        // If item exists, increase quantity\n        return prevItems.map(item =>\n          item.id === product.id ? { ...item, quantity: item.quantity + 1 } : item\n        );\n      } else {\n        // If new item, add to cart with quantity 1\n        return [...prevItems, { ...product, quantity: 1 }];\n      }\n    });\n  };\n\n  const removeItemFromCart = (productId) => {\n    // Remove item completely, regardless of quantity\n    setCartItems(prevItems => prevItems.filter(item => item.id !== productId));\n  };\n\n  const clearCart = () => {\n    setCartItems([]);\n  };\n\n  const value = useMemo(() => ({ \n    cartItems, \n    addItemToCart, \n    removeItemFromCart, \n    clearCart \n  }), [cartItems]);\n  // useMemo memoizes the context value to prevent unnecessary re-renders\n\n  return (\n    <CartContext.Provider value={value}>\n      {children}\n    </CartContext.Provider>\n  );\n}\n\n// 3. Create useCart custom hook\nfunction useCart() {\n  const context = useContext(CartContext);\n  if (context === null) {\n    throw new Error('useCart must be used within a CartProvider');\n  }\n  return context;\n}\n\n// Dummy Products (use these)\nconst products = [\n  { id: 'p1', name: 'Laptop', price: 1200 },\n  { id: 'p2', name: 'Mouse', price: 25 },\n  { id: 'p3', name: 'Keyboard', price: 75 },\n  { id: 'p4', name: 'Monitor', price: 300 },\n];\n\n// 4. ProductList Component\nfunction ProductList() {\n  const { addItemToCart } = useCart();\n\n  return (\n    <div style={{ flex: 1, border: '1px solid #ddd', padding: '15px', borderRadius: '8px' }}>\n      <h2>Available Products</h2>\n      {products.map(product => (\n        <div key={product.id} style={{ border: '1px solid #ccc', padding: '10px', margin: '10px 0', display: 'flex', justifyContent: 'space-between', alignItems: 'center', backgroundColor: '#f9f9f9', borderRadius: '4px' }}>\n          <span>{product.name} - <strong>${product.price.toFixed(2)}</strong></span>\n          <button onClick={() => addItemToCart(product)} style={{ padding: '8px 12px', background: '#28a745', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>\n            Add to Cart\n          </button>\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// 5. CartSummary Component\nfunction CartSummary() {\n  const { cartItems, removeItemFromCart, clearCart } = useCart();\n\n  // Calculate total price using reduce\n  const total = cartItems.reduce((sum, item) => sum + item.price * item.quantity, 0);\n\n  return (\n    <div style={{ flex: 1, border: '1px solid #ddd', padding: '15px', borderRadius: '8px' }}>\n      <h2>Shopping Cart</h2>\n      {cartItems.length === 0 ? (\n        <p>Your cart is empty.</p>\n      ) : (\n        <div>\n          <ul style={{ listStyle: 'none', padding: 0 }}>\n            {cartItems.map(item => (\n              <li key={item.id} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px', paddingBottom: '10px', borderBottom: '1px dashed #eee' }}>\n                <span>{item.name} (x{item.quantity}) - <strong>${(item.price * item.quantity).toFixed(2)}</strong></span>\n                <button onClick={() => removeItemFromCart(item.id)} style={{ padding: '6px 10px', background: '#dc3545', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>\n                  Remove\n                </button>\n              </li>\n            ))}\n          </ul>\n          <h3 style={{ borderTop: '1px solid #ddd', paddingTop: '10px' }}>Total: ${total.toFixed(2)}</h3>\n          <button onClick={clearCart} style={{ padding: '8px 15px', background: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>\n            Clear Cart\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}\n\n// 6. App Component\nfunction App() {\n  return (\n    <CartProvider>\n      <div style={{ display: 'flex', gap: '20px', padding: '20px', fontFamily: 'Arial, sans-serif' }}>\n        <ProductList />\n        <CartSummary />\n      </div>\n    </CartProvider>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));",
          "testCases": [
            "Initial state: CartSummary should display 'Your cart is empty.'.",
            "Add 'Laptop': CartSummary should show 'Laptop (x1) - $1200.00', Total: $1200.00.",
            "Add 'Laptop' again: CartSummary should show 'Laptop (x2) - $2400.00', Total: $2400.00 (quantity increased, not new entry).",
            "Add 'Mouse' and 'Keyboard': CartSummary should list three items with correct quantities and sum total.",
            "Remove 'Laptop': CartSummary should no longer show Laptop, and total should update correctly.",
            "Clear Cart: Clicking 'Clear Cart' should empty the cart and reset total to $0.00.",
            "Usage outside `CartProvider`: Attempting to use `useCart` in a component not wrapped by `CartProvider` should throw an error 'useCart must be used within a CartProvider'."
          ],
          "hints": [
            "For `addItemToCart`, use `Array.prototype.find()` to check if the product already exists in the cart. If it does, use `Array.prototype.map()` to update its quantity. If not, use spread syntax (`...`) to add it to a new array.",
            "For `removeItemFromCart`, use `Array.prototype.filter()` to create a new array excluding the item to be removed.",
            "Remember that `setCartItems` should always receive a *new* array, not a mutated version of the old one.",
            "Consider using `useMemo` for the `value` prop in `CartContext.Provider` to prevent unnecessary re-renders of consuming components if the `value` object reference changes on every render, even if `cartItems` hasn't changed. Although `useState` setters are stable, the `value` object itself would be new each time."
          ],
          "tags": [
            "React",
            "Context API",
            "useState",
            "Hooks",
            "State Management",
            "E-commerce",
            "CRUD",
            "Immutability"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_react_context_fundamentals",
            "theory_react_usestate_hook",
            "theory_react_dynamic_context_custom_hooks"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "controlled_components",
            "data_normalization",
            "performance_optimization"
          ]
        }
      ]
    }
  },
  {
    "id": "d68744a5-1545-46e0-85c0-08df297781c7",
    "startLine": 7500,
    "endLine": 7599,
    "processedDate": "2025-06-17T10:23:34.139Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_use_reducer_basics",
          "title": "React useReducer Hook: Core Concepts and Usage",
          "content": "The `useReducer` hook in React is an alternative to `useState` for managing state, particularly when state logic is complex or when the next state depends on the previous one. It's especially useful for managing state that involves multiple sub-values or when the next state depends on the previous one, similar to how Redux works.\n\n## Key Concepts\n- **Reducer Function**: A pure function that takes the current `state` and an `action` as arguments and returns the new `state`. It must not modify the original state directly but instead return a new state object or value.\n- **Action**: A plain JavaScript object that describes 'what happened'. It typically has a `type` property (a string) and an optional `payload` property which contains any data needed to update the state.\n- **Dispatch Function**: The function returned by `useReducer` that you call to dispatch an `action`. When `dispatch` is called, React will re-render the component and pass the current `state` and the `action` to the reducer function to calculate the new state.\n- **Initial State**: The initial value of the state. It can be a direct value or derived from a function (lazy initialization) for performance optimization if the initial state is expensive to compute.\n\n## When to Use useReducer?\n`useReducer` is preferable over `useState` in the following scenarios:\n1.  **Complex State Logic**: When state transitions are non-trivial or involve multiple steps.\n2.  **Multiple State Updates**: When many state updates happen over time, and these updates depend on the previous state.\n3.  **Global State Management**: When combined with React's Context API to manage global application state, providing a Redux-like pattern without external libraries.\n4.  **Performance Optimization**: When passing `dispatch` down deeply nested components, it's more stable than passing `setState` from `useState` as `dispatch` reference is guaranteed to be stable (it doesn't change on re-renders, unlike `setState` when passed through Context).\n\n## Syntax\n```typescript\nconst [state, dispatch] = useReducer(reducer, initialArg, init?);\n```\n- `reducer`: Your reducer function `(state, action) => newState`.\n- `initialArg`: The initial value for the state.\n- `init?`: An optional 'initializer' function `(initialArg) => initialState` which computes the initial state lazily. If present, `initialArg` is passed to it, and its return value becomes the initial state. This is useful for expensive initial state computations.\n\n## How it Works\n1.  You define a `reducer` function that describes how the state changes in response to different actions.\n2.  You call `useReducer` with your `reducer` function and an `initialState`. It returns the current state and a `dispatch` function.\n3.  In your component, you call `dispatch` with an `action` object (e.g., `{ type: 'increment' }`) when an event occurs.\n4.  React passes the current state and the action to your `reducer` function.\n5.  The `reducer` returns the new state.\n6.  React updates the component's state with the new value and re-renders the component.",
          "examples": [
            {
              "id": "example_use_reducer_basic_counter",
              "title": "Basic Counter with useReducer",
              "code": "import React, { useReducer } from 'react';\n\n// Reducer function: defines how state changes based on actions\nfunction counterReducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    case 'reset':\n      return { count: 0 }; // Example of another action type\n    default:\n      throw new Error(`Unknown action type: ${action.type}`);\n  }\n}\n\nfunction Counter() {\n  // Initialize state with useReducer: [current_state, dispatch_function]\n  // The second argument is the initial state: { count: 0 }\n  const [state, dispatch] = useReducer(counterReducer, { count: 0 });\n  \n  return (\n    <div>\n      <h2>Count: {state.count}</h2>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>\n    </div>\n  );\n}\n\nexport default Counter;\n",
              "explanation": "This example demonstrates a simple counter using `useReducer`. The `counterReducer` function specifies how the `count` state changes for 'increment' and 'decrement' actions. The `Counter` component initializes the state to `{ count: 0 }` and uses the `dispatch` function to send actions when buttons are clicked. Notice how the state is an object `{ count: 0 }`, allowing for more complex state structures later.",
              "language": "typescript"
            },
            {
              "id": "example_use_reducer_lazy_initialization",
              "title": "Lazy Initialization with useReducer",
              "code": "import React, { useReducer } from 'react';\n\n// Reducer function (same as before)\nfunction counterReducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    default:\n      throw new Error();\n  }\n}\n\n// Initializer function: computes the initial state lazily\n// It receives the initialArg (passed as the second argument to useReducer)\n// and returns the actual initial state.\nfunction init(initialCount) {\n  console.log('Initializing state lazily...');\n  return { count: initialCount };\n}\n\nfunction LazyCounter({ initialCount = 0 }) {\n  // Using the initializer function as the third argument\n  const [state, dispatch] = useReducer(counterReducer, initialCount, init);\n  \n  return (\n    <div>\n      <h2>Lazy Initialized Count: {state.count}</h2>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n    </div>\n  );\n}\n\nexport default LazyCounter;\n",
              "explanation": "This example shows `useReducer` with lazy initialization. The `init` function is passed as the third argument to `useReducer`. This function is called only once during the initial render to compute the initial state. This is beneficial if the initial state computation is expensive, as it avoids re-running the computation on every re-render, unlike simply passing a function to `useState`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_use_reducer_difference_useState",
            "question_use_reducer_components",
            "question_use_reducer_when_to_use_mcq",
            "question_use_reducer_reducer_signature_mcq",
            "question_use_reducer_lazy_init_open",
            "question_use_reducer_pure_function_flashcard"
          ],
          "relatedTasks": [
            "task_complex_form_reducer",
            "task_shopping_cart_reducer"
          ],
          "tags": [
            "React Hooks",
            "State Management",
            "useReducer",
            "Functional Components",
            "Reducer Pattern"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_state_management",
            "javascript_functions",
            "javascript_objects"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_context_api",
            "redux_fundamentals",
            "global_state_management"
          ]
        },
        {
          "id": "theory_use_reducer_context_api",
          "title": "Global State Management with useReducer and Context API",
          "content": "Combining `useReducer` with React's `Context API` provides a powerful, built-in solution for global state management, often referred to as a 'mini-Redux' pattern. This approach allows you to manage application-wide state without resorting to external state management libraries like Redux, especially for mid-sized applications or specific global concerns.\n\n## Key Concepts\n- **Context**: `React.createContext()` creates a Context object. When React renders a component that subscribes to this Context object, it will read the current Context value from the closest `Provider` above it in the tree.\n- **Provider**: The `Context.Provider` component is used to provide the context value to its children. Any component wrapped by the `Provider` can consume the value.\n- **Consumer (or `useContext` Hook)**: Components can access the context value using the `useContext` hook. `useContext(MyContext)` returns the value passed to `MyContext.Provider` for the closest `MyContext.Provider` above the calling component in the tree.\n- **Centralized Logic**: The `useReducer` hook centralizes the state logic (reducer function) in one place, making state changes predictable and debuggable.\n- **Decoupling**: This pattern decouples state management logic from components that merely consume or dispatch actions, leading to cleaner and more maintainable code.\n\n## How it Works\n1.  **Create Context**: Define a `React.createContext()` for your specific global state (e.g., `TodoContext`).\n2.  **Define Reducer**: Create a `reducer` function that handles state transitions for this global state.\n3.  **Create Provider Component**: Build a wrapper component (e.g., `TodoProvider`) that encapsulates the `useReducer` hook. This component will initialize the state and `dispatch` function and provide them through the `Context.Provider` to its children.\n4.  **Create Custom Hook (Optional but Recommended)**: Develop a custom hook (e.g., `useTodo`) that uses `useContext` to consume the context. This abstracts away the `useContext` call and provides a clean interface for components to interact with the global state, ensuring they are used within the `Provider`'s scope.\n5.  **Consume State/Dispatch**: Components that need to access the global state or dispatch actions can simply use the custom hook (e.g., `const { todos, dispatch } = useTodo();`).\n\n## Advantages\n-   **Built-in**: No external library dependency.\n-   **Predictable State**: `useReducer` enforces a clear pattern for state changes.\n-   **Decoupled Logic**: State logic is separated from UI components.\n-   **Scalable**: Good for mid-sized applications or specific domain-level global state.\n\n## Considerations\n-   **Re-renders**: Any component consuming context will re-render when the context value changes. For very large, frequently updating global states, this might lead to performance issues if not optimized (e.g., by splitting context into smaller pieces or using `React.memo`).\n-   **Boilerplate**: Can involve more boilerplate than `useState` for simple global states.\n-   **Debugging**: Debugging can be less straightforward than with dedicated state management tools (like Redux DevTools).\n\nThis pattern is highly effective for managing themes, user authentication status, or application-wide data that needs to be accessed by many components at different levels of the component tree without prop drilling.",
          "examples": [
            {
              "id": "example_use_reducer_context_api_todo",
              "title": "Global Todo Management with useReducer & Context API",
              "code": "import React, { createContext, useReducer, useContext, useState } from 'react';\n\n// 1. Create a context for the todos\nconst TodoContext = createContext(null); // Initialize with null, will be populated by Provider\n\n// 2. Define the reducer function for todo state logic\nfunction todoReducer(state, action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [...state, { id: Date.now(), text: action.payload, completed: false }];\n    case 'TOGGLE_TODO':\n      return state.map(todo =>\n        todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo\n      );\n    case 'DELETE_TODO':\n      return state.filter(todo => todo.id !== action.payload);\n    case 'CLEAR_COMPLETED':\n      return state.filter(todo => !todo.completed); // Added for complexity\n    default:\n      return state; // It's crucial to return current state for unknown actions\n  }\n}\n\n// 3. Create a provider component that encapsulates useReducer and Context.Provider\nfunction TodoProvider({ children }) {\n  const [todos, dispatch] = useReducer(todoReducer, []); // Initialize with an empty array\n  \n  // The value object contains both state (todos) and the dispatch function\n  const contextValue = { todos, dispatch };\n  \n  return (\n    <TodoContext.Provider value={contextValue}>\n      {children}\n    </TodoContext.Provider>\n  );\n}\n\n// 4. Custom hook to use the todo context (recommended for cleaner consumption)\nfunction useTodo() {\n  const context = useContext(TodoContext);\n  if (!context) {\n    throw new Error('useTodo must be used within a TodoProvider');\n  } \n  return context;\n}\n\n// 5. Component that adds todos (consumes dispatch)\nfunction AddTodo() {\n  const { dispatch } = useTodo();\n  const [text, setText] = useState('');\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (text.trim()) {\n      dispatch({ type: 'ADD_TODO', payload: text });\n      setText('');\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        value={text}\n        onChange={(e) => setText(e.target.value)}\n        placeholder=\"Add new todo...\"\n      />\n      <button type=\"submit\">Add Todo</button>\n    </form>\n  );\n}\n\n// 6. Component that lists and interacts with todos (consumes todos and dispatch)\nfunction TodoList() {\n  const { todos, dispatch } = useTodo();\n  \n  return (\n    <ul>\n      {todos.map(todo => (\n        <li key={todo.id} style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n          <input\n            type=\"checkbox\"\n            checked={todo.completed}\n            onChange={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })}\n          />\n          {todo.text}\n          <button onClick={() => dispatch({ type: 'DELETE_TODO', payload: todo.id })}>Delete</button>\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// 7. Component to clear completed todos\nfunction ClearCompletedTodos() {\n  const { dispatch } = useTodo();\n  return (\n    <button onClick={() => dispatch({ type: 'CLEAR_COMPLETED' })}>Clear Completed</button>\n  );\n}\n\n// Main App component to demonstrate usage\nfunction App() {\n  return (\n    <TodoProvider>\n      <h1>My Todo App</h1>\n      <AddTodo />\n      <TodoList />\n      <ClearCompletedTodos />\n    </TodoProvider>\n  );\n}\n\nexport default App;\n",
              "explanation": "This comprehensive example demonstrates how `useReducer` and `Context API` are combined for global state management. \n1.  `TodoContext` is created.\n2.  `todoReducer` defines state transitions for adding, toggling, and deleting todos.\n3.  `TodoProvider` wraps `useReducer` and makes `todos` state and `dispatch` function available via `TodoContext.Provider`.\n4.  `useTodo` is a custom hook to conveniently consume the context and ensure correct usage within the provider's scope.\n5.  `AddTodo`, `TodoList`, and `ClearCompletedTodos` components then use this `useTodo` hook to interact with the global todo state without prop drilling. This pattern effectively centralizes state logic and allows disparate components to share and modify the same state.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_context_reducer_advantages_open",
            "question_context_reducer_components_mcq",
            "question_context_reducer_redux_flashcard",
            "question_context_reducer_re_renders_open",
            "question_context_reducer_error_handling_code",
            "question_context_reducer_deep_nesting_open"
          ],
          "relatedTasks": [
            "task_theme_switcher",
            "task_user_auth_context",
            "task_shopping_cart_context_reducer"
          ],
          "tags": [
            "React Hooks",
            "Context API",
            "Global State Management",
            "useReducer",
            "State Management Pattern",
            "Redux Alternative"
          ],
          "technology": "React",
          "prerequisites": [
            "react_use_state",
            "react_use_reducer",
            "react_context_api",
            "javascript_es6_features"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "large_scale_react_apps",
            "state_management_architecture",
            "custom_hooks"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_use_reducer_difference_useState",
          "topic": "useReducer vs. useState",
          "level": "medium",
          "type": "open",
          "question": "Explain the primary differences between `useState` and `useReducer` in React. When would you choose `useReducer` over `useState`?",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Identifies that useState is for simple state, useReducer for complex logic.",
            "Explains the role of a reducer function and dispatch.",
            "Mentions scenarios like multiple related state values, complex transitions, or global state.",
            "Discusses the concept of 'actions' in useReducer.",
            "Considers performance aspects like lazy initialization or stable dispatch function."
          ],
          "keyConcepts": [
            "useState",
            "useReducer",
            "Reducer function",
            "Dispatch function",
            "State complexity",
            "Predictable state updates"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of definitions.",
            "Ability to articulate suitable use cases for each hook.",
            "Understanding of the underlying mechanisms of state updates."
          ],
          "example": "```typescript\n// useState for simple toggle\nconst [isOpen, setIsOpen] = useState(false);\n\n// useReducer for complex counter\nconst [state, dispatch] = useReducer(reducer, { count: 0 });\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment': return { count: state.count + 1 };\n    case 'decrement': return { count: state.count - 1 };\n    default: return state;\n  }\n}\n```\n`useState` is simpler for single state variables or independent state. `useReducer` is better when state updates depend on the previous state, involve complex logic, or when managing multiple related state variables that change together based on actions, leading to more predictable state management.",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "useReducer",
            "State Management",
            "Comparison"
          ],
          "prerequisites": [
            "react_functional_components",
            "react_state_management"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_reducer_components",
          "topic": "useReducer Components",
          "level": "easy",
          "type": "flashcard",
          "question": "What are the three main components or parts involved when using the `useReducer` hook?",
          "answer": "Reducer function, initial state (or initializer function), and dispatch function.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "useReducer",
            "Reducer",
            "Dispatch",
            "Initial State"
          ],
          "evaluationCriteria": [
            "Recall of fundamental `useReducer` concepts."
          ],
          "example": "The `useReducer` hook is initialized with a `reducer` function and an `initialState`. It returns the current `state` and a `dispatch` function. `const [state, dispatch] = useReducer(reducer, initialState);`",
          "tags": [
            "React",
            "Hooks",
            "useReducer",
            "Flashcard"
          ],
          "prerequisites": [
            "react_use_reducer"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_reducer_when_to_use_mcq",
          "topic": "useReducer Application",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following scenarios is `useReducer` most suitable for?",
          "answer": "Managing the state of a complex multi-step form with interdependent fields and validation logic.",
          "options": [
            "Managing the toggle state of a single dropdown menu.",
            "Managing the state of a complex multi-step form with interdependent fields and validation logic.",
            "Storing whether a user is logged in (simple boolean).",
            "Handling a single counter that only increments by one."
          ],
          "analysisPoints": [
            "The correct answer represents complex state logic where `useReducer` excels.",
            "Incorrect options represent simple state that can be easily managed by `useState`.",
            "Tests understanding of when `useReducer` offers a significant advantage."
          ],
          "keyConcepts": [
            "useReducer",
            "useState",
            "Complex State Logic",
            "State Transitions"
          ],
          "evaluationCriteria": [
            "Ability to differentiate between appropriate use cases for `useState` and `useReducer`."
          ],
          "example": "While `useState` could technically manage a complex form, `useReducer` would provide a cleaner, more predictable way to handle the numerous state updates and validations required for interdependent fields, centralizing the logic in a reducer function.",
          "tags": [
            "React",
            "Hooks",
            "useReducer",
            "Use Cases",
            "MCQ"
          ],
          "prerequisites": [
            "react_use_state",
            "react_use_reducer"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_reducer_reducer_signature_mcq",
          "topic": "Reducer Function Signature",
          "level": "easy",
          "type": "mcq",
          "question": "What is the correct signature for a `reducer` function used with `useReducer`?",
          "answer": "`function reducer(state, action) { /* ... */ return newState; }`",
          "options": [
            "`function reducer(action, state) { /* ... */ return newState; }`",
            "`function reducer(state, payload) { /* ... */ return newState; }`",
            "`function reducer(action) { /* ... */ return newState; }`",
            "`function reducer(state, action) { /* ... */ return newState; }`"
          ],
          "analysisPoints": [
            "Identifies the correct order of arguments (state, then action).",
            "Recognizes that a reducer must return the new state.",
            "Understands that 'payload' is typically a property of the action, not the second argument itself."
          ],
          "keyConcepts": [
            "Reducer function",
            "useReducer",
            "State",
            "Action"
          ],
          "evaluationCriteria": [
            "Knowledge of the fundamental structure of a reducer function."
          ],
          "example": "```typescript\nfunction myReducer(state, action) {\n  switch (action.type) {\n    case 'UPDATE_NAME':\n      return { ...state, name: action.payload };\n    default:\n      return state;\n  }\n}\n```\nThe reducer function always takes the current `state` as the first argument and the `action` dispatched as the second, and it must return the `newState`.",
          "tags": [
            "React",
            "Hooks",
            "useReducer",
            "Reducer",
            "MCQ"
          ],
          "prerequisites": [
            "react_use_reducer"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_use_reducer_lazy_init_open",
          "topic": "Lazy Initialization",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose and benefit of providing an initializer function as the third argument to `useReducer`.",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Explains that the initializer function calculates the initial state.",
            "Highlights that it's called only once during the initial render.",
            "Emphasizes the performance benefit for expensive initial state computations.",
            "Compares it to `useState`'s lazy initialization pattern."
          ],
          "keyConcepts": [
            "useReducer",
            "Lazy Initialization",
            "Performance Optimization",
            "Initial State"
          ],
          "evaluationCriteria": [
            "Understanding of advanced `useReducer` features.",
            "Ability to explain performance implications.",
            "Knowledge of how `useReducer` initializes state."
          ],
          "example": "```typescript\nfunction createInitialState(initialCount) {\n  console.log('Calculating initial state (expensive operation)...');\n  return { count: initialCount + 100 };\n}\n\nfunction MyComponent({ startingCount }) {\n  const [state, dispatch] = useReducer(myReducer, startingCount, createInitialState);\n  // ... rest of component\n}\n```\nWithout the initializer function, if `createInitialState` were called directly as `useReducer(myReducer, createInitialState(startingCount))`, it would run on every re-render, even if `startingCount` doesn't change. The initializer function ensures it runs only once.",
          "tags": [
            "React",
            "Hooks",
            "useReducer",
            "Performance",
            "Optimization"
          ],
          "prerequisites": [
            "react_use_reducer"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_reducer_pure_function_flashcard",
          "topic": "Reducer Purity",
          "level": "easy",
          "type": "flashcard",
          "question": "What does it mean for a reducer function to be a 'pure' function?",
          "answer": "A pure function always produces the same output given the same inputs, and it has no side effects (it does not modify anything outside its scope, including its input arguments). For reducers, this means not mutating the original state directly.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Pure Function",
            "Reducer",
            "Side Effects",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Understanding of functional programming principles in React context."
          ],
          "example": "A pure reducer example: `return { ...state, key: newValue };` (returns new object). An impure reducer example: `state.key = newValue; return state;` (mutates original state).",
          "tags": [
            "React",
            "Hooks",
            "useReducer",
            "Functional Programming",
            "Immutability",
            "Flashcard"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_reducer_advantages_open",
          "topic": "useReducer with Context API Benefits",
          "level": "medium",
          "type": "open",
          "question": "Discuss the advantages of combining `useReducer` with the `Context API` for state management in a React application. When would this pattern be preferred over a dedicated library like Redux?",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Explains how it avoids prop drilling for global state.",
            "Highlights the built-in nature (no extra library).",
            "Discusses the predictability and testability offered by the reducer pattern.",
            "Mentions suitability for mid-sized applications or specific domain-level global state.",
            "Compares it to Redux in terms of boilerplate, learning curve, and debugging tools.",
            "Acknowledges potential downsides like re-render issues without memoization."
          ],
          "keyConcepts": [
            "Global State",
            "Context API",
            "useReducer",
            "Prop Drilling",
            "Redux",
            "Scalability",
            "Built-in Solution"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of state management patterns.",
            "Ability to articulate trade-offs between different solutions.",
            "Critical thinking about architectural choices."
          ],
          "example": "```typescript\n// Example of context and reducer in action\nconst ThemeContext = createContext();\n\nfunction themeReducer(state, action) {\n  switch (action.type) {\n    case 'TOGGLE_THEME':\n      return { theme: state.theme === 'light' ? 'dark' : 'light' };\n    default: return state;\n  }\n}\n\nfunction ThemeProvider({ children }) {\n  const [themeState, dispatch] = useReducer(themeReducer, { theme: 'light' });\n  return (\n    <ThemeContext.Provider value={{ themeState, dispatch }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n```\nThis setup allows any component within `ThemeProvider` to easily access the `themeState` and dispatch `TOGGLE_THEME` actions without passing props down manually.",
          "tags": [
            "React",
            "Context API",
            "useReducer",
            "Global State",
            "Architecture",
            "Comparison"
          ],
          "prerequisites": [
            "react_context_api",
            "react_use_reducer"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_context_reducer_components_mcq",
          "topic": "Context + useReducer Components",
          "level": "medium",
          "type": "mcq",
          "question": "When combining `useReducer` with `Context API` for global state, which of the following components or hooks are typically involved in the pattern?",
          "answer": "A Context object, a Provider component, a reducer function, and a custom hook using `useContext`.",
          "options": [
            "A Context object, a Consumer component, and `useState`.",
            "A Context object, a Provider component, a reducer function, and a custom hook using `useContext`.",
            "A Context object, a Reducer hook, and a central store.",
            "Only a `useReducer` hook and a `Provider`."
          ],
          "analysisPoints": [
            "Identifies all the correct components of the idiomatic `useReducer` + `Context` pattern.",
            "Distinguishes between `useContext` (hook) and `Consumer` (component).",
            "Excludes `useState` as the primary state manager in this pattern.",
            "Clarifies that a 'central store' isn't explicitly part of the native React pattern, unlike Redux."
          ],
          "keyConcepts": [
            "Context API",
            "useReducer",
            "Provider",
            "useContext",
            "Custom Hooks"
          ],
          "evaluationCriteria": [
            "Knowledge of the architectural components for global state with native React hooks."
          ],
          "example": "The most common and recommended pattern involves creating a `Context` (e.g., `createContext`), a `Provider` component to wrap the `useReducer` and pass state/dispatch, and a custom `useHook` (e.g., `useMyContext`) that utilizes `useContext` for components to consume the state.",
          "tags": [
            "React",
            "Context API",
            "useReducer",
            "Global State",
            "Architecture",
            "MCQ"
          ],
          "prerequisites": [
            "react_context_api",
            "react_use_reducer",
            "react_custom_hooks"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_reducer_redux_flashcard",
          "topic": "Context + useReducer vs. Redux",
          "level": "medium",
          "type": "flashcard",
          "question": "What is one key advantage of using `useReducer` with `Context API` over Redux for global state management?",
          "answer": "It is built into React, requiring no additional library dependencies, and offers a simpler setup for less complex global states.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Context API",
            "useReducer",
            "Redux",
            "Global State",
            "Dependencies"
          ],
          "evaluationCriteria": [
            "Ability to quickly recall comparison points."
          ],
          "example": "Redux requires installing `redux` and `react-redux` libraries, and typically `redux-thunk` or `redux-saga` for async operations, along with more boilerplate. `useReducer` with `Context` is entirely native.",
          "tags": [
            "React",
            "Context API",
            "useReducer",
            "Redux",
            "Comparison",
            "Flashcard"
          ],
          "prerequisites": [
            "react_context_api",
            "react_use_reducer"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_context_reducer_re_renders_open",
          "topic": "Performance Considerations",
          "level": "hard",
          "type": "open",
          "question": "Discuss the potential performance implications of using `useReducer` with `Context API` for very large or frequently updated global states. What strategies can be employed to mitigate these issues?",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Identifies that any component consuming context will re-render when the context *value* changes, even if only part of the value changes and the component doesn't use the changed part.",
            "Explains how returning a new object from the provider's `value` prop will cause re-renders.",
            "Suggests solutions like splitting context into smaller, more granular contexts (e.g., `dispatchContext` and `stateContext`).",
            "Mentions using `React.memo` on consumer components to prevent unnecessary re-renders based on props.",
            "Discusses `useCallback` and `useMemo` for stabilizing values passed down through context or to memoized components.",
            "Contrasts this with Redux's optimized subscription model."
          ],
          "keyConcepts": [
            "Context API",
            "Performance",
            "Re-renders",
            "Optimization",
            "React.memo",
            "useCallback",
            "useMemo",
            "Context Splitting"
          ],
          "evaluationCriteria": [
            "Deep understanding of React rendering behavior.",
            "Knowledge of performance optimization techniques.",
            "Ability to analyze and propose solutions for complex scenarios."
          ],
          "example": "```typescript\n// Splitting context to optimize re-renders\nconst StateContext = createContext();\nconst DispatchContext = createContext();\n\nfunction MyProvider({ children }) {\n  const [state, dispatch] = useReducer(myReducer, initialState);\n  return (\n    <StateContext.Provider value={state}>\n      <DispatchContext.Provider value={dispatch}>\n        {children}\n      </DispatchContext.Provider>\n    </StateContext.Provider>\n  );\n}\n\n// Consumer component only re-renders if state changes\nfunction MyDisplayComponent() {\n  const state = useContext(StateContext);\n  return <div>{state.data}</div>;\n}\n\n// Consumer component only re-renders if dispatch reference changes (which it doesn't)\nfunction MyButtonComponent() {\n  const dispatch = useContext(DispatchContext);\n  return <button onClick={() => dispatch({ type: 'ACTION' })}>Action</button>;\n}\n```\nBy splitting the context, components that only need `dispatch` (which is stable) will not re-render when the `state` changes.",
          "tags": [
            "React",
            "Context API",
            "useReducer",
            "Performance",
            "Optimization",
            "Advanced React"
          ],
          "prerequisites": [
            "react_rendering_behavior",
            "react_memo",
            "react_use_callback",
            "react_use_memo"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "expert"
        },
        {
          "id": "question_context_reducer_error_handling_code",
          "topic": "Error Handling with Context",
          "level": "hard",
          "type": "code",
          "question": "Consider the following `useTodo` custom hook. It includes basic error handling. Provide an example of how a component might use this hook to display an appropriate message if it's rendered outside of the `TodoProvider`'s scope.",
          "answer": "```typescript\nimport React from 'react';\nimport { TodoProvider, useTodo } from './TodoContext'; // Assume TodoContext.js exports these\n\nfunction TodoListConsumer() {\n  try {\n    const { todos } = useTodo();\n    return (\n      <div>\n        <h2>My Todos</h2>\n        {todos.length === 0 ? (\n          <p>No todos yet!</p>\n        ) : (\n          <ul>\n            {todos.map(todo => <li key={todo.id}>{todo.text}</li>)}\n          </ul>\n        )}\n      </div>\n    );\n  } catch (error) {\n    return (\n      <div style={{ color: 'red', border: '1px solid red', padding: '10px' }}>\n        Error: {error.message}\n        <p>Please ensure TodoListConsumer is rendered inside a TodoProvider.</p>\n      </div>\n    );\n  }\n}\n\nfunction App() {\n  return (\n    <div>\n      <h1>App with Error Handling Example</h1>\n      {/* This component will show the error message */}\n      <TodoListConsumer /> \n      \n      {/* To see correct behavior, wrap it like this: */}\n      {/* <TodoProvider>\n        <TodoListConsumer />\n      </TodoProvider> */}\n    </div>\n  );\n}\n\nexport default App;\n```",
          "options": [],
          "analysisPoints": [
            "Demonstrates understanding of try-catch blocks in React functional components (though typically better handled by `ErrorBoundary` for rendering errors).",
            "Shows how a user-friendly message can be rendered based on the error.",
            "Reinforces the importance of the custom hook checking for context existence.",
            "Highlights the need for components consuming context to be within a provider's hierarchy."
          ],
          "keyConcepts": [
            "Context API",
            "Custom Hooks",
            "Error Handling",
            "useContext",
            "Component Hierarchy"
          ],
          "evaluationCriteria": [
            "Ability to implement error handling in React components.",
            "Understanding of context usage constraints.",
            "Practical application of `try-catch` (or `ErrorBoundary` concept if mentioned)."
          ],
          "example": "The `useTodo` hook throws an error if `context` is `null`. A parent component, or even an `ErrorBoundary` wrapping the `TodoListConsumer`, could catch this error and render a fallback UI. The provided solution shows a direct `try-catch` for demonstration.",
          "tags": [
            "React",
            "Hooks",
            "Context API",
            "Error Handling",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_context_api",
            "react_custom_hooks",
            "javascript_error_handling"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_context_reducer_deep_nesting_open",
          "topic": "Deep Component Nesting",
          "level": "hard",
          "type": "open",
          "question": "How does `useReducer` combined with `Context API` simplify data flow in deeply nested component trees compared to traditional prop drilling?",
          "answer": "N/A",
          "options": [],
          "analysisPoints": [
            "Defines prop drilling as passing props down multiple levels unnecessarily.",
            "Explains how Context API provides a direct channel for state and dispatch to any descendant component.",
            "Highlights that intermediate components no longer need to know about or pass irrelevant props.",
            "Discusses how `dispatch` function's reference stability helps optimize re-renders in deeply nested structures.",
            "Mentions improved code readability and maintainability."
          ],
          "keyConcepts": [
            "Prop Drilling",
            "Context API",
            "useReducer",
            "Component Composition",
            "Data Flow",
            "Code Maintainability"
          ],
          "evaluationCriteria": [
            "Understanding of React data flow best practices.",
            "Ability to compare and contrast architectural patterns.",
            "Insight into the benefits of context for large applications."
          ],
          "example": "Imagine a user profile state `currentUser` deeply nested. Without Context, `App -> Header -> UserMenu -> ProfileAvatar` would all need to pass `currentUser` down. With Context, `App` provides `currentUser` via `Context.Provider`, and `ProfileAvatar` directly `useContext` to consume it, simplifying the `Header` and `UserMenu` components.",
          "tags": [
            "React",
            "Context API",
            "useReducer",
            "Architecture",
            "Prop Drilling"
          ],
          "prerequisites": [
            "react_component_props",
            "react_data_flow"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_use_reducer_action_payload_mcq",
          "topic": "Action Structure",
          "level": "easy",
          "type": "mcq",
          "question": "In the context of `useReducer`, what is the typical structure of an `action` object, particularly when data needs to be passed for state updates?",
          "answer": "{ type: 'ACTION_TYPE', payload: someData }",
          "options": [
            "{ name: 'ACTION_TYPE', data: someData }",
            "{ type: 'ACTION_TYPE', value: someData }",
            "{ type: 'ACTION_TYPE', payload: someData }",
            "Just a string like 'INCREMENT'"
          ],
          "analysisPoints": [
            "Identifies `type` as the mandatory property for an action.",
            "Recognizes `payload` as the conventional property name for associated data.",
            "Distinguishes from less conventional or incomplete action structures."
          ],
          "keyConcepts": [
            "Action object",
            "Reducer",
            "Dispatch",
            "Type",
            "Payload"
          ],
          "evaluationCriteria": [
            "Knowledge of conventional action object structure.",
            "Understanding of how data is passed to a reducer."
          ],
          "example": "```typescript\ndispatch({ type: 'ADD_ITEM', payload: { id: 1, name: 'Milk' } });\n```\nIn this example, `ADD_ITEM` is the `type` that tells the reducer what action to perform, and `{ id: 1, name: 'Milk' }` is the `payload` that provides the necessary data for that action.",
          "tags": [
            "React",
            "useReducer",
            "Action",
            "Payload",
            "MCQ"
          ],
          "prerequisites": [
            "react_use_reducer"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_complex_form_reducer",
          "title": "Implement a Multi-Step Form with useReducer",
          "description": "\nImplement a multi-step registration form using the `useReducer` hook. The form should collect user details across at least two steps.\n\n**Requirements:**\n1.  **Step 1: Personal Info** (Name, Email)\n2.  **Step 2: Address Info** (Street, City, Zip Code)\n3.  **Navigation**: \"Next\" and \"Previous\" buttons to navigate between steps.\n4.  **Reducer Logic**: All form state should be managed by a single `useReducer` hook. The reducer should handle actions for updating individual fields and for navigating between steps.\n5.  **Validation**: Implement basic client-side validation: Name and Email required in Step 1, Street and City required in Step 2. Prevent proceeding to the next step if validation fails.\n6.  **Submission**: On the final step, display a summary of all collected data.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useReducer, useState } from 'react';\n\nconst initialState = {\n  step: 1,\n  personalInfo: {\n    name: '',\n    email: ''\n  },\n  addressInfo: {\n    street: '',\n    city: '',\n    zip: ''\n  },\n  errors: {}\n};\n\nfunction formReducer(state, action) {\n  switch (action.type) {\n    // TODO: Implement 'UPDATE_FIELD' action to update a specific field within personalInfo or addressInfo\n    // HINT: You'll need to know which section (personalInfo/addressInfo) and which field to update.\n    case 'UPDATE_FIELD':\n      return { ...state, /* Your logic here */ };\n\n    // TODO: Implement 'NEXT_STEP' action to advance the step count\n    case 'NEXT_STEP':\n      return { ...state, /* Your logic here */ };\n\n    // TODO: Implement 'PREV_STEP' action to decrement the step count\n    case 'PREV_STEP':\n      return { ...state, /* Your logic here */ };\n\n    // TODO: Implement 'SET_ERRORS' action to update the errors object\n    case 'SET_ERRORS':\n      return { ...state, /* Your logic here */ };\n\n    default:\n      return state;\n  }\n}\n\nfunction MultiStepForm() {\n  const [state, dispatch] = useReducer(formReducer, initialState);\n\n  // TODO: Implement validation logic here.\n  // This function should be called before moving to the next step.\n  const validateStep = () => {\n    const newErrors = {};\n    let isValid = true;\n\n    if (state.step === 1) {\n      if (!state.personalInfo.name.trim()) {\n        newErrors.name = 'Name is required.';\n        isValid = false;\n      }\n      if (!state.personalInfo.email.trim()) {\n        newErrors.email = 'Email is required.';\n        isValid = false;\n      } else if (!/^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$/.test(state.personalInfo.email)) {\n        newErrors.email = 'Invalid email format.';\n        isValid = false;\n      }\n    } else if (state.step === 2) {\n      if (!state.addressInfo.street.trim()) {\n        newErrors.street = 'Street is required.';\n        isValid = false;\n      }\n      if (!state.addressInfo.city.trim()) {\n        newErrors.city = 'City is required.';\n        isValid = false;\n      }\n    }\n\n    dispatch({ type: 'SET_ERRORS', payload: newErrors });\n    return isValid;\n  };\n\n  const handleNext = () => {\n    if (validateStep()) {\n      dispatch({ type: 'NEXT_STEP' });\n    }\n  };\n\n  const handlePrev = () => {\n    dispatch({ type: 'PREV_STEP' });\n  };\n\n  const handleChange = (section, field) => (e) => {\n    dispatch({ type: 'UPDATE_FIELD', payload: { section, field, value: e.target.value } });\n  };\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '5px', maxWidth: '500px', margin: '20px auto' }}>\n      <h2>Multi-Step Registration Form - Step {state.step}</h2>\n\n      {state.step === 1 && (\n        <div>\n          <h3>Personal Information</h3>\n          <div>\n            <label>Name:</label>\n            <input type=\"text\" value={state.personalInfo.name} onChange={handleChange('personalInfo', 'name')} />\n            {state.errors.name && <p style={{ color: 'red' }}>{state.errors.name}</p>}\n          </div>\n          <div>\n            <label>Email:</label>\n            <input type=\"email\" value={state.personalInfo.email} onChange={handleChange('personalInfo', 'email')} />\n            {state.errors.email && <p style={{ color: 'red' }}>{state.errors.email}</p>}\n          </div>\n          <button onClick={handleNext}>Next</button>\n        </div>\n      )}\n\n      {state.step === 2 && (\n        <div>\n          <h3>Address Information</h3>\n          <div>\n            <label>Street:</label>\n            <input type=\"text\" value={state.addressInfo.street} onChange={handleChange('addressInfo', 'street')} />\n            {state.errors.street && <p style={{ color: 'red' }}>{state.errors.street}</p>}\n          </div>\n          <div>\n            <label>City:</label>\n            <input type=\"text\" value={state.addressInfo.city} onChange={handleChange('addressInfo', 'city')} />\n            {state.errors.city && <p style={{ color: 'red' }}>{state.errors.city}</p>}\n          </div>\n          <div>\n            <label>Zip Code:</label>\n            <input type=\"text\" value={state.addressInfo.zip} onChange={handleChange('addressInfo', 'zip')} />\n          </div>\n          <button onClick={handlePrev}>Previous</button>\n          <button onClick={handleNext}>Next</button>\n        </div>\n      )}\n\n      {state.step === 3 && (\n        <div>\n          <h3>Summary</h3>\n          <p><strong>Name:</strong> {state.personalInfo.name}</p>\n          <p><strong>Email:</strong> {state.personalInfo.email}</p>\n          <p><strong>Street:</strong> {state.addressInfo.street}</p>\n          <p><strong>City:</strong> {state.addressInfo.city}</p>\n          <p><strong>Zip:</strong> {state.addressInfo.zip}</p>\n          <button onClick={handlePrev}>Previous</button>\n          <button onClick={() => alert('Form Submitted!')}>Submit</button>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default MultiStepForm;\n",
          "solutionCode": "import React, { useReducer, useState } from 'react';\n\nconst initialState = {\n  step: 1,\n  personalInfo: {\n    name: '',\n    email: ''\n  },\n  addressInfo: {\n    street: '',\n    city: '',\n    zip: ''\n  },\n  errors: {}\n};\n\nfunction formReducer(state, action) {\n  switch (action.type) {\n    case 'UPDATE_FIELD':\n      const { section, field, value } = action.payload;\n      return {\n        ...state,\n        [section]: {\n          ...state[section],\n          [field]: value\n        },\n        errors: { // Clear error for the field being updated\n          ...state.errors,\n          [field]: undefined \n        }\n      };\n\n    case 'NEXT_STEP':\n      return { ...state, step: state.step + 1, errors: {} };\n\n    case 'PREV_STEP':\n      return { ...state, step: state.step - 1, errors: {} };\n\n    case 'SET_ERRORS':\n      return { ...state, errors: action.payload };\n\n    default:\n      return state;\n  }\n}\n\nfunction MultiStepForm() {\n  const [state, dispatch] = useReducer(formReducer, initialState);\n\n  const validateStep = () => {\n    const newErrors = {};\n    let isValid = true;\n\n    if (state.step === 1) {\n      if (!state.personalInfo.name.trim()) {\n        newErrors.name = 'Name is required.';\n        isValid = false;\n      }\n      if (!state.personalInfo.email.trim()) {\n        newErrors.email = 'Email is required.';\n        isValid = false;\n      } else if (!/^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$/.test(state.personalInfo.email)) {\n        newErrors.email = 'Invalid email format.';\n        isValid = false;\n      }\n    } else if (state.step === 2) {\n      if (!state.addressInfo.street.trim()) {\n        newErrors.street = 'Street is required.';\n        isValid = false;\n      }\n      if (!state.addressInfo.city.trim()) {\n        newErrors.city = 'City is required.';\n        isValid = false;\n      }\n    }\n\n    dispatch({ type: 'SET_ERRORS', payload: newErrors });\n    return isValid;\n  };\n\n  const handleNext = () => {\n    if (validateStep()) {\n      dispatch({ type: 'NEXT_STEP' });\n    }\n  };\n\n  const handlePrev = () => {\n    dispatch({ type: 'PREV_STEP' });\n  };\n\n  const handleChange = (section, field) => (e) => {\n    dispatch({ type: 'UPDATE_FIELD', payload: { section, field, value: e.target.value } });\n  };\n\n  return (\n    <div style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '5px', maxWidth: '500px', margin: '20px auto' }}>\n      <h2>Multi-Step Registration Form - Step {state.step}</h2>\n\n      {state.step === 1 && (\n        <div>\n          <h3>Personal Information</h3>\n          <div>\n            <label>Name:</label>\n            <input type=\"text\" value={state.personalInfo.name} onChange={handleChange('personalInfo', 'name')} />\n            {state.errors.name && <p style={{ color: 'red' }}>{state.errors.name}</p>}\n          </div>\n          <div>\n            <label>Email:</label>\n            <input type=\"email\" value={state.personalInfo.email} onChange={handleChange('personalInfo', 'email')} />\n            {state.errors.email && <p style={{ color: 'red' }}>{state.errors.email}</p>}\n          </div>\n          <button onClick={handleNext}>Next</button>\n        </div>\n      )}\n\n      {state.step === 2 && (\n        <div>\n          <h3>Address Information</h3>\n          <div>\n            <label>Street:</label>\n            <input type=\"text\" value={state.addressInfo.street} onChange={handleChange('addressInfo', 'street')} />\n            {state.errors.street && <p style={{ color: 'red' }}>{state.errors.street}</p>}\n          </div>\n          <div>\n            <label>City:</label>\n            <input type=\"text\" value={state.addressInfo.city} onChange={handleChange('addressInfo', 'city')} />\n            {state.errors.city && <p style={{ color: 'red' }}>{state.errors.city}</p>}\n          </div>\n          <div>\n            <label>Zip Code:</label>\n            <input type=\"text\" value={state.addressInfo.zip} onChange={handleChange('addressInfo', 'zip')} />\n          </div>\n          <button onClick={handlePrev}>Previous</button>\n          <button onClick={handleNext}>Next</button>\n        </div>\n      )}\n\n      {state.step === 3 && (\n        <div>\n          <h3>Summary</h3>\n          <p><strong>Name:</strong> {state.personalInfo.name}</p>\n          <p><strong>Email:</strong> {state.personalInfo.email}</p>\n          <p><strong>Street:</strong> {state.addressInfo.street}</p>\n          <p><strong>City:</strong> {state.addressInfo.city}</p>\n          <p><strong>Zip:</strong> {state.addressInfo.zip}</p>\n          <button onClick={handlePrev}>Previous</button>\n          <button onClick={() => alert('Form Submitted!')}>Submit</button>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default MultiStepForm;\n",
          "testCases": [
            "User fills Step 1 correctly, clicks Next -> Should advance to Step 2.",
            "User leaves Name or Email empty in Step 1, clicks Next -> Should display validation errors and stay on Step 1.",
            "User fills Step 2 correctly, clicks Next -> Should advance to Step 3 (Summary).",
            "User leaves Street or City empty in Step 2, clicks Next -> Should display validation errors and stay on Step 2.",
            "User navigates back from Step 2 to Step 1 -> Previous inputs should be preserved.",
            "User navigates back from Step 3 to Step 2 -> Previous inputs should be preserved.",
            "User fills all fields and clicks Submit in Step 3 -> Should show submission alert."
          ],
          "hints": [
            "Remember that the reducer function must be pure; always return new state objects, don't mutate the existing `state`.",
            "For `UPDATE_FIELD`, you'll need to deeply copy the `personalInfo` or `addressInfo` object before updating a specific field within it.",
            "Consider how to reset or clear errors when moving between steps or when a field is updated after an error."
          ],
          "tags": [
            "React",
            "useReducer",
            "Forms",
            "State Management",
            "Validation",
            "Multi-step"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "react_use_reducer",
            "javascript_objects",
            "form_handling"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "controlled_components",
            "form_validation",
            "reducer_pattern"
          ]
        },
        {
          "id": "task_theme_switcher",
          "title": "Build a Global Theme Switcher using useReducer and Context API",
          "description": "\nCreate a global theme switcher for a React application using `useReducer` and `Context API`. The application should support at least two themes (e.g., 'light' and 'dark').\n\n**Requirements:**\n1.  **Theme Context**: Create a `ThemeContext` using `createContext`.\n2.  **Theme Reducer**: Implement a `themeReducer` to manage the theme state (e.g., `{ theme: 'light' }`). It should handle an action (e.g., `TOGGLE_THEME`) to switch between 'light' and 'dark' themes.\n3.  **Theme Provider**: Create a `ThemeProvider` component that uses `useReducer` and wraps `ThemeContext.Provider` to expose the current theme state and the dispatch function.\n4.  **Custom Hook**: Create a `useTheme` custom hook for components to easily consume the theme context and dispatch actions.\n5.  **Theme Toggle Component**: Build a `ThemeToggle` component that uses `useTheme` to display the current theme and a button to switch themes.\n6.  **Themed Content Component**: Create a `ThemedContent` component that uses `useTheme` to apply styling based on the current theme (e.g., background color, text color). This component should be a child of `ThemeProvider` but not necessarily a direct child of `ThemeToggle`.\n7.  **Error Handling**: Ensure the `useTheme` hook throws an error if used outside of `ThemeProvider`.\n",
          "difficulty": "medium",
          "startingCode": "import React, { createContext, useReducer, useContext } from 'react';\n\n// 1. Create Theme Context\nconst ThemeContext = createContext(null);\n\n// 2. Define Theme Reducer\nfunction themeReducer(state, action) {\n  switch (action.type) {\n    // TODO: Implement TOGGLE_THEME action\n    case 'TOGGLE_THEME':\n      return { /* Your logic here */ };\n    default:\n      return state;\n  }\n}\n\n// 3. Create Theme Provider Component\nfunction ThemeProvider({ children }) {\n  // TODO: Initialize useReducer with themeReducer and an initial state of { theme: 'light' }\n  const [state, dispatch] = useReducer(/* Your arguments here */);\n\n  // TODO: Provide state and dispatch via ThemeContext.Provider\n  return (\n    <ThemeContext.Provider value={/* Your value here */}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// 4. Create useTheme Custom Hook\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  // TODO: Add error handling if context is null\n  if (!context) {\n    throw new Error(/* Your error message here */);\n  }\n  return context;\n}\n\n// 5. Theme Toggle Component\nfunction ThemeToggle() {\n  const { state, dispatch } = useTheme(); // Note: adjust based on your context value structure\n\n  const toggleTheme = () => {\n    dispatch({ type: 'TOGGLE_THEME' });\n  };\n\n  return (\n    <div>\n      <p>Current Theme: {state.theme}</p>\n      <button onClick={toggleTheme}>Toggle Theme</button>\n    </div>\n  );\n}\n\n// 6. Themed Content Component\nfunction ThemedContent() {\n  const { state } = useTheme(); // Note: adjust based on your context value structure\n\n  const themeStyles = {\n    light: { background: '#f0f0f0', color: '#333' },\n    dark: { background: '#333', color: '#f0f0f0' }\n  };\n\n  return (\n    <div style={{\n      padding: '20px',\n      margin: '20px 0',\n      border: '1px solid #ccc',\n      ...themeStyles[state.theme]\n    }}>\n      This content changes based on the theme.\n      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>\n    </div>\n  );\n}\n\n// App component to demonstrate usage\nfunction App() {\n  return (\n    <ThemeProvider>\n      <div style={{ fontFamily: 'Arial, sans-serif', padding: '20px' }}>\n        <h1>Global Theme Switcher</h1>\n        <ThemeToggle />\n        <ThemedContent />\n      </div>\n    </ThemeProvider>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { createContext, useReducer, useContext } from 'react';\n\n// 1. Create Theme Context\nconst ThemeContext = createContext(null);\n\n// 2. Define Theme Reducer\nfunction themeReducer(state, action) {\n  switch (action.type) {\n    case 'TOGGLE_THEME':\n      return { theme: state.theme === 'light' ? 'dark' : 'light' };\n    default:\n      return state; // Crucial to return current state for unknown actions\n  }\n}\n\n// 3. Create Theme Provider Component\nfunction ThemeProvider({ children }) {\n  const [state, dispatch] = useReducer(themeReducer, { theme: 'light' });\n\n  return (\n    <ThemeContext.Provider value={{ state, dispatch }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// 4. Create useTheme Custom Hook\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (context === null) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n}\n\n// 5. Theme Toggle Component\nfunction ThemeToggle() {\n  const { state, dispatch } = useTheme();\n\n  const toggleTheme = () => {\n    dispatch({ type: 'TOGGLE_THEME' });\n  };\n\n  return (\n    <div>\n      <p>Current Theme: {state.theme.charAt(0).toUpperCase() + state.theme.slice(1)}</p>\n      <button onClick={toggleTheme}>Toggle Theme</button>\n    </div>\n  );\n}\n\n// 6. Themed Content Component\nfunction ThemedContent() {\n  const { state } = useTheme();\n\n  const themeStyles = {\n    light: { background: '#f0f0f0', color: '#333', borderColor: '#ccc' },\n    dark: { background: '#333', color: '#f0f0f0', borderColor: '#555' }\n  };\n\n  return (\n    <div style={{\n      padding: '20px',\n      margin: '20px 0',\n      border: '1px solid',\n      ...themeStyles[state.theme]\n    }}>\n      This content changes based on the theme.\n      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>\n    </div>\n  );\n}\n\n// App component to demonstrate usage\nfunction App() {\n  return (\n    <ThemeProvider>\n      <div style={{ fontFamily: 'Arial, sans-serif', padding: '20px' }}>\n        <h1>Global Theme Switcher</h1>\n        <ThemeToggle />\n        <ThemedContent />\n        <hr />\n        {/* Example of a component outside the provider to test error handling */}\n        {/* <TestErrorComponent /> */}\n      </div>\n    </ThemeProvider>\n  );\n}\n\n// Component to test error handling (uncomment in App to test)\n/*\nfunction TestErrorComponent() {\n  try {\n    useTheme();\n    return <p>Should not reach here if outside provider.</p>;\n  } catch (error) {\n    return <p style={{ color: 'orange' }}>Caught error: {error.message}</p>;\n  }\n}\n*/\n\nexport default App;\n",
          "testCases": [
            "Initial render: Theme should be 'light'.",
            "Click Toggle Theme button: Theme should switch to 'dark'.",
            "Click Toggle Theme button again: Theme should switch back to 'light'.",
            "ThemedContent component's background and text color should change with the theme.",
            "Ensure `useTheme` throws an error when called outside `ThemeProvider` (by deliberately rendering a consumer component outside of `ThemeProvider` in a test setup or locally)."
          ],
          "hints": [
            "The `themeReducer` needs to return a new state object, not mutate the existing one.",
            "The `value` prop of `ThemeContext.Provider` should be an object containing both the `state` (e.g., `{ theme: 'light' }`) and the `dispatch` function.",
            "The `useContext` hook inside `useTheme` will return `null` if the component is not wrapped by the `ThemeProvider`."
          ],
          "tags": [
            "React",
            "Context API",
            "useReducer",
            "Global State",
            "Theming",
            "Custom Hooks"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_use_reducer",
            "react_context_api",
            "react_custom_hooks"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "design_systems",
            "dependency_injection",
            "prop_drilling"
          ]
        },
        {
          "id": "task_shopping_cart_context_reducer",
          "title": "Implement a Shopping Cart using useReducer and Context API",
          "description": "\nDevelop a simplified shopping cart application using `useReducer` and `Context API` to manage the cart's state globally. The application should allow users to add items, remove items, and adjust item quantities.\n\n**Requirements:**\n1.  **Cart Context**: Create a `CartContext`.\n2.  **Cart Reducer**: Implement a `cartReducer` to manage the cart state (an array of items, each with `id`, `name`, `price`, `quantity`). It should handle actions for:\n    *   `ADD_ITEM`: Adds a new item or increments quantity if item already in cart.\n    *   `REMOVE_ITEM`: Removes an item from the cart.\n    *   `UPDATE_QUANTITY`: Changes the quantity of an existing item.\n    *   `CLEAR_CART`: Empties the cart.\n3.  **Cart Provider**: Create a `CartProvider` component that uses `useReducer` and wraps `CartContext.Provider`.\n4.  **Custom Hook**: Create a `useCart` custom hook.\n5.  **Product List Component**: Display a list of predefined products, each with an \"Add to Cart\" button.\n6.  **Shopping Cart Component**: Display the items currently in the cart, showing item name, quantity, price, subtotal, and buttons to increase/decrease quantity and remove the item. Also display a total price for the entire cart.\n",
          "difficulty": "hard",
          "startingCode": "import React, { createContext, useReducer, useContext } from 'react';\n\n// Dummy product data\nconst products = [\n  { id: 'p1', name: 'Laptop', price: 1200 },\n  { id: 'p2', name: 'Mouse', price: 25 },\n  { id: 'p3', name: 'Keyboard', price: 75 },\n];\n\n// 1. Create Cart Context\nconst CartContext = createContext(null);\n\n// 2. Define Cart Reducer\nfunction cartReducer(state, action) {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      // TODO: Implement logic to add item or increment quantity if exists\n      return state;\n    case 'REMOVE_ITEM':\n      // TODO: Implement logic to remove item\n      return state;\n    case 'UPDATE_QUANTITY':\n      // TODO: Implement logic to update quantity (payload: {id, quantity})\n      return state;\n    case 'CLEAR_CART':\n      return [];\n    default:\n      return state;\n  }\n}\n\n// 3. Create Cart Provider Component\nfunction CartProvider({ children }) {\n  const [cart, dispatch] = useReducer(cartReducer, []);\n  const contextValue = { cart, dispatch };\n  return (\n    <CartContext.Provider value={contextValue}>\n      {children}\n    </CartContext.Provider>\n  );\n}\n\n// 4. Create useCart Custom Hook\nfunction useCart() {\n  const context = useContext(CartContext);\n  if (!context) {\n    throw new Error('useCart must be used within a CartProvider');\n  }\n  return context;\n}\n\n// 5. Product List Component\nfunction ProductList() {\n  const { dispatch } = useCart();\n\n  return (\n    <div>\n      <h2>Products</h2>\n      {products.map(product => (\n        <div key={product.id} style={{ border: '1px solid #eee', padding: '10px', margin: '10px 0' }}>\n          <h3>{product.name} - ${product.price}</h3>\n          <button onClick={() => dispatch({ type: 'ADD_ITEM', payload: product })}>Add to Cart</button>\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// 6. Shopping Cart Component\nfunction ShoppingCart() {\n  const { cart, dispatch } = useCart();\n\n  const total = cart.reduce((sum, item) => sum + item.price * item.quantity, 0);\n\n  return (\n    <div>\n      <h2>Shopping Cart</h2>\n      {cart.length === 0 ? (\n        <p>Your cart is empty.</p>\n      ) : (\n        <div>\n          <ul>\n            {cart.map(item => (\n              <li key={item.id} style={{ marginBottom: '10px' }}>\n                {item.name} (x{item.quantity}) - ${item.price * item.quantity}\n                <button onClick={() => dispatch({ type: 'UPDATE_QUANTITY', payload: { id: item.id, quantity: item.quantity + 1 } })}>+</button>\n                <button onClick={() => dispatch({ type: 'UPDATE_QUANTITY', payload: { id: item.id, quantity: item.quantity - 1 } })}>-</button>\n                <button onClick={() => dispatch({ type: 'REMOVE_ITEM', payload: item.id })}>Remove</button>\n              </li>\n            ))}\n          </ul>\n          <h3>Total: ${total.toFixed(2)}</h3>\n          <button onClick={() => dispatch({ type: 'CLEAR_CART' })}>Clear Cart</button>\n        </div>\n      )}\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <CartProvider>\n      <div style={{ display: 'flex', gap: '20px', padding: '20px' }}>\n        <ProductList />\n        <ShoppingCart />\n      </div>\n    </CartProvider>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { createContext, useReducer, useContext } from 'react';\n\nconst products = [\n  { id: 'p1', name: 'Laptop', price: 1200 },\n  { id: 'p2', name: 'Mouse', price: 25 },\n  { id: 'p3', name: 'Keyboard', price: 75 },\n  { id: 'p4', name: 'Monitor', price: 300 }\n];\n\nconst CartContext = createContext(null);\n\nfunction cartReducer(state, action) {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      const existingItem = state.find(item => item.id === action.payload.id);\n      if (existingItem) {\n        return state.map(item =>\n          item.id === action.payload.id\n            ? { ...item, quantity: item.quantity + 1 }\n            : item\n        );\n      } else {\n        return [...state, { ...action.payload, quantity: 1 }];\n      }\n    case 'REMOVE_ITEM':\n      return state.filter(item => item.id !== action.payload);\n    case 'UPDATE_QUANTITY':\n      const { id, quantity } = action.payload;\n      if (quantity <= 0) {\n        return state.filter(item => item.id !== id);\n      }\n      return state.map(item =>\n        item.id === id ? { ...item, quantity: quantity } : item\n      );\n    case 'CLEAR_CART':\n      return [];\n    default:\n      return state;\n  }\n}\n\nfunction CartProvider({ children }) {\n  const [cart, dispatch] = useReducer(cartReducer, []);\n  const contextValue = { cart, dispatch };\n  return (\n    <CartContext.Provider value={contextValue}>\n      {children}\n    </CartContext.Provider>\n  );\n}\n\nfunction useCart() {\n  const context = useContext(CartContext);\n  if (!context) {\n    throw new Error('useCart must be used within a CartProvider');\n  }\n  return context;\n}\n\nfunction ProductList() {\n  const { dispatch } = useCart();\n\n  return (\n    <div style={{ flex: 1, padding: '15px', border: '1px solid #ddd', borderRadius: '8px' }}>\n      <h2>Products</h2>\n      {products.map(product => (\n        <div key={product.id} style={{ border: '1px solid #eee', padding: '10px', margin: '10px 0', borderRadius: '5px' }}>\n          <h3>{product.name} - ${product.price.toFixed(2)}</h3>\n          <button onClick={() => dispatch({ type: 'ADD_ITEM', payload: product })} style={{ padding: '8px 12px', cursor: 'pointer' }}>Add to Cart</button>\n        </div>\n      ))}\n    </div>\n  );\n}\n\nfunction ShoppingCart() {\n  const { cart, dispatch } = useCart();\n\n  const total = cart.reduce((sum, item) => sum + item.price * item.quantity, 0);\n\n  return (\n    <div style={{ flex: 1, padding: '15px', border: '1px solid #ddd', borderRadius: '8px' }}>\n      <h2>Shopping Cart</h2>\n      {cart.length === 0 ? (\n        <p>Your cart is empty.</p>\n      ) : (\n        <div>\n          <ul>\n            {cart.map(item => (\n              <li key={item.id} style={{ marginBottom: '10px', display: 'flex', alignItems: 'center', gap: '10px' }}>\n                <span>{item.name} (x{item.quantity}) - ${(item.price * item.quantity).toFixed(2)}</span>\n                <button onClick={() => dispatch({ type: 'UPDATE_QUANTITY', payload: { id: item.id, quantity: item.quantity + 1 } })} style={{ padding: '5px 8px', cursor: 'pointer' }}>+</button>\n                <button onClick={() => dispatch({ type: 'UPDATE_QUANTITY', payload: { id: item.id, quantity: item.quantity - 1 } })} style={{ padding: '5px 8px', cursor: 'pointer' }}>-</button>\n                <button onClick={() => dispatch({ type: 'REMOVE_ITEM', payload: item.id })} style={{ padding: '5px 8px', cursor: 'pointer' }}>Remove</button>\n              </li>\n            ))}\n          </ul>\n          <h3 style={{ borderTop: '1px solid #eee', paddingTop: '10px', marginTop: '10px' }}>Total: ${total.toFixed(2)}</h3>\n          <button onClick={() => dispatch({ type: 'CLEAR_CART' })} style={{ padding: '8px 12px', cursor: 'pointer' }}>Clear Cart</button>\n        </div>\n      )}\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <CartProvider>\n      <div style={{ fontFamily: 'Arial, sans-serif', display: 'flex', gap: '20px', padding: '20px', maxWidth: '1000px', margin: 'auto' }}>\n        <ProductList />\n        <ShoppingCart />\n      </div>\n    </CartProvider>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Add an item to the cart: Cart should show item with quantity 1.",
            "Add the same item again: Quantity of that item should increment by 1.",
            "Add different items: Cart should show multiple distinct items.",
            "Remove an item: Item should disappear from the cart.",
            "Decrease quantity of an item: Quantity should decrement. If quantity becomes 0, item should be removed.",
            "Increase quantity of an item: Quantity should increment.",
            "Clear cart: Cart should become empty.",
            "Verify total price calculation is correct as items are added/removed/quantities changed.",
            "Ensure custom `useCart` hook throws an error if `ShoppingCart` or `ProductList` were rendered outside `CartProvider`."
          ],
          "hints": [
            "For `ADD_ITEM`: Check if the item already exists in the cart. If yes, map over the state to update its quantity. If no, add the new item with `quantity: 1`.",
            "For `UPDATE_QUANTITY`: Pay attention to the edge case where `quantity` becomes 0 or less; in such cases, the item should be removed from the cart.",
            "Remember that reducers must be pure functions. Use `map` and `filter` to return new arrays/objects instead of mutating existing ones."
          ],
          "tags": [
            "React",
            "Context API",
            "useReducer",
            "Global State",
            "E-commerce",
            "Shopping Cart"
          ],
          "timeEstimate": 120,
          "prerequisites": [
            "react_use_reducer",
            "react_context_api",
            "javascript_array_methods",
            "javascript_objects"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "state_normalization",
            "immutable_updates",
            "side_effects"
          ]
        }
      ]
    }
  }
]