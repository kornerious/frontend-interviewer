[
  {
    "id": "7de717d6-b9cc-4698-9f91-2dc19f734b4c",
    "startLine": 700,
    "endLine": 799,
    "processedDate": "2025-06-17T07:22:33.806Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_memoization",
          "title": "Memoization: Caching Function Results for Performance",
          "content": "Memoization is an optimization technique used to speed up computer programs by caching the results of expensive function calls and returning the cached result when the same inputs occur again. It's particularly useful for pure functions (functions that always produce the same output for the same input and have no side effects) and recursive functions where the same sub-problems are computed multiple times.\n\n### How Memoization Works\nAt its core, memoization involves:\n1.  **Caching**: Storing the function's output in a data structure (e.g., an object or Map) against its input arguments.\n2.  **Key Generation**: Creating a unique key from the function's arguments to store and retrieve results. For simple arguments, direct use might work, but for complex arguments (objects, arrays), serialization (like `JSON.stringify`) or custom hashing is often needed.\n3.  **Context Preservation**: Ensuring that the original function's `this` context is maintained when the function is actually executed (i.e., when a cache miss occurs).\n\n### Benefits\n-   **Performance Improvement**: Avoids redundant computations, significantly speeding up applications, especially for CPU-bound tasks.\n-   **Efficiency**: Reduces the workload on the system.\n\n### Considerations\n-   **Memory Usage**: Storing results consumes memory. For functions with many unique inputs, the cache can grow very large.\n-   **Pure Functions**: Most effective for pure functions. Memoizing functions with side effects or external dependencies can lead to stale results.\n-   **Argument Complexity**: Generating unique keys for complex arguments can be challenging and sometimes negate performance gains if the key generation itself is expensive.",
          "examples": [
            {
              "id": "example_memoization_1",
              "title": "Basic Memoization Implementation",
              "code": "function memoize(fn) {\n  const cache = {};\n  return function(...args) {\n    // Create a unique key from arguments. JSON.stringify works for simple types.\n    // For complex objects, it might not be suitable if order or non-enumerable props matter.\n    const key = JSON.stringify(args);\n    if (cache[key]) {\n      console.log(`Fetching '${key}' from cache`);\n      return cache[key];\n    }\n    console.log(`Calculating result for '${key}'`);\n    // Use apply to ensure 'this' context is correctly passed if 'fn' relies on it.\n    const result = fn.apply(this, args);\n    cache[key] = result;\n    return result;\n  };\n}\n\nconst factorial = memoize(function(n) {\n  if (n === 0 || n === 1) return 1;\n  return n * factorial(n - 1);\n});\n\nconsole.log(factorial(5)); // Calculating result, then 120\nconsole.log(factorial(5)); // Fetching from cache, then 120\nconsole.log(factorial(3)); // Calculating result, then 6\nconsole.log(factorial(3)); // Fetching from cache, then 6",
              "explanation": "This example demonstrates a `memoize` higher-order function. It takes a function `fn` and returns a new function. This new function checks a `cache` object before executing `fn`. If the result for the given arguments (`key`) is found in the cache, it's returned immediately. Otherwise, `fn` is executed, its result is stored in the cache, and then returned. `fn.apply(this, args)` is crucial here to ensure that if `fn` itself is a method of an object and relies on its `this` context, that context is correctly preserved.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_memoization_1",
            "question_memoization_2",
            "question_memoization_3",
            "question_memoization_4",
            "question_memoization_5"
          ],
          "relatedTasks": [
            "task_memoization_1"
          ],
          "tags": [
            "optimization",
            "performance",
            "caching",
            "higher-order functions",
            "closures"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "closures",
            "this_keyword",
            "function_apply_call_bind",
            "pure_functions"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "dynamic_programming",
            "performance_optimization",
            "functional_programming"
          ]
        },
        {
          "id": "theory_generator_functions",
          "title": "Generator Functions: Iteration Control with Yield",
          "content": "Generator functions are a special type of function in JavaScript that can pause their execution, yield control to the caller, and then resume execution from where they left off. They are defined using `function*` syntax and use the `yield` keyword to produce a sequence of values.\n\n### Key Concepts\n-   **`function*`**: Declares a generator function.\n-   **`yield`**: Pauses the generator function's execution and sends a value back to the caller. When `next()` is called again, the generator resumes execution immediately after the `yield` statement.\n-   **Iterator Protocol**: Generator functions, when called, do not execute their body immediately. Instead, they return an `iterator` object (a Generator object). This iterator has a `next()` method.\n-   **`next()` Method**: Calling `next()` on the generator's iterator object resumes execution until the next `yield` expression or a `return` statement is encountered. It returns an object of the form `{ value: any, done: boolean }`. `done` is `true` when the generator has finished yielding all values.\n-   **Infinite Sequences**: Generators can be used to create potentially infinite sequences of values, as they compute values on demand.\n-   **`for...of` Loop**: The `for...of` loop is specifically designed to work with iterable objects, including generator functions, consuming their yielded values sequentially until `done` is `true`.\n\n### Use Cases\n-   **Lazy Evaluation**: Generate a sequence of values only when needed, which is memory-efficient for large or infinite sequences.\n-   **Asynchronous Programming**: Can simplify asynchronous code by allowing an `async` flow to be written in a synchronous-like manner (though `async/await` is now more common for this).\n-   **Custom Iterators**: Easily create custom iterators for complex data structures.\n-   **State Management**: Maintain internal state across multiple invocations.",
          "examples": [
            {
              "id": "example_generator_1",
              "title": "Basic ID Generator",
              "code": "function* idGenerator() {\n  let id = 1;\n  while (true) {\n    yield id++;\n  }\n}\n\nconst gen = idGenerator();\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\nconsole.log(gen.next().value); // 3",
              "explanation": "This `idGenerator` function demonstrates an infinite generator. Each call to `gen.next().value` yields the next sequential ID, and the internal `id` variable retains its state across calls.",
              "language": "javascript"
            },
            {
              "id": "example_generator_2",
              "title": "Finite Range Generator",
              "code": "function* range(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}\n\nfor (const num of range(1, 5)) {\n  console.log(num); // 1, 2, 3, 4, 5\n}",
              "explanation": "This `range` generator produces a finite sequence of numbers. The `for...of` loop elegantly iterates over the yielded values, automatically handling the `next()` calls until the generator is `done`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_generator_1",
            "question_generator_2",
            "question_generator_3",
            "question_generator_4",
            "question_generator_5"
          ],
          "relatedTasks": [
            "task_generator_1"
          ],
          "tags": [
            "generators",
            "iterators",
            "yield",
            "iteration",
            "ES6"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "functions",
            "loops",
            "iterables"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "custom_iterators",
            "lazy_evaluation",
            "asynchronous_patterns"
          ]
        },
        {
          "id": "theory_async_functions",
          "title": "Async Functions: Asynchronous Programming Made Easier",
          "content": "Asynchronous functions (`async`/`await`) provide a more synchronous-like syntax for working with Promises, making asynchronous code easier to read and write. They are built on top of Promises and the JavaScript event loop.\n\n### Key Concepts\n-   **`async` Keyword**: Declares a function as asynchronous. An `async` function implicitly returns a Promise. If the function returns a non-Promise value, it will be wrapped in a resolved Promise. If it throws an error, the Promise will be rejected.\n-   **`await` Keyword**: Can only be used inside an `async` function. `await` pauses the execution of the `async` function until the Promise it's waiting on settles (either resolves or rejects). Once the Promise settles, `await` returns its resolved value. If the Promise rejects, `await` throws the error, which can then be caught by a `try...catch` block.\n-   **Non-Blocking Nature**: Despite `await` pausing the `async` function, it does *not* block the main thread of execution. When an `await` expression is encountered, the `async` function is suspended, and control is returned to the event loop, allowing other tasks to run. Once the awaited Promise resolves, the `async` function is put back in the event queue to resume execution.\n-   **Error Handling**: `try...catch` blocks are the idiomatic way to handle errors in `async` functions, just like with synchronous code.\n-   **Immediately Invoked Async Function Expression (IIAFE)**: `(async () => { /* ... */ })();` is a common pattern to create an `async` execution context at the top level of a script or module, allowing `await` to be used without defining a named `async` function.\n\n### Advantages\n-   **Readability**: Code looks more like traditional synchronous code, making it easier to follow the flow.\n-   **Error Handling**: Simple `try...catch` blocks for errors, similar to synchronous error handling.\n-   **Debugging**: Easier to debug compared to complex `.then().catch()` chains.",
          "examples": [
            {
              "id": "example_async_1",
              "title": "Basic Async Data Fetching",
              "code": "async function fetchData() {\n  try {\n    // Await pauses execution until the fetch Promise resolves\n    const response = await fetch('https://api.example.com/data');\n    if (!response.ok) {\n      // Throwing an error here will cause the catch block to execute\n      throw new Error(`Network response was not ok: ${response.status}`);\n    }\n    // Await pauses until the json() Promise resolves\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error fetching data:', error.message);\n    // Re-throw or return a default value based on desired behavior\n    throw error; \n  }\n}\n\n// Using async function (it returns a Promise)\nfetchData()\n  .then(data => console.log('Fetched data (then):', data))\n  .catch(error => console.error('Caught error (then):', error.message));\n\n// Async IIFE for immediate execution and top-level await-like behavior\n(async () => {\n  try {\n    const data = await fetchData();\n    console.log('Fetched data (IIFE):', data);\n  } catch (error) {\n    console.error('Caught error (IIFE):', error.message);\n  }\n})();",
              "explanation": "This example shows an `async` function `fetchData` that uses `await` to pause execution while fetching data and parsing the JSON response. Error handling is managed with a `try...catch` block. The example also demonstrates how to consume the Promise returned by `fetchData` using `.then()` and how to use an Immediately Invoked Async Function Expression (IIAFE) to execute `async/await` code directly.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_async_1",
            "question_async_2",
            "question_async_3",
            "question_async_4",
            "question_async_5"
          ],
          "relatedTasks": [
            "task_async_1"
          ],
          "tags": [
            "async",
            "await",
            "promises",
            "asynchronous_programming",
            "event_loop",
            "ES2017"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "promises",
            "event_loop",
            "error_handling"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "modern_web_development",
            "API_integration",
            "concurrency_control"
          ]
        },
        {
          "id": "theory_regular_vs_arrow_functions",
          "title": "Regular vs. Arrow Functions: Key Differences",
          "content": "JavaScript offers two primary ways to define functions: traditional `function` declarations/expressions (regular functions) and arrow function expressions (introduced in ES6). While both allow you to create callable units of code, they have fundamental differences, especially regarding `this` binding and their suitability for certain use cases.\n\n### Key Differences\n\n1.  **`this` Binding (Lexical `this`)**:\n    *   **Regular Functions**: Have their own `this` context. The value of `this` is dynamically determined by how the function is called. It can be the global object (in non-strict mode), `undefined` (in strict mode), the object the function is a method of, or explicitly set via `call()`, `apply()`, or `bind()`.\n    *   **Arrow Functions**: Do *not* have their own `this` context. They lexically bind `this`, meaning `this` refers to the `this` value of the *enclosing* (outer) scope where the arrow function is defined. This makes them ideal for callbacks or methods where you want to preserve the `this` context of the surrounding code.\n\n2.  **`arguments` Object**: \n    *   **Regular Functions**: Have their own `arguments` object, which is an array-like object containing all arguments passed to the function.\n    *   **Arrow Functions**: Do *not* have their own `arguments` object. If you try to access `arguments` inside an arrow function, it will refer to the `arguments` object of the nearest enclosing *regular* function. To get arguments in an arrow function, you should use [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters) (`...args`).\n\n3.  **Use as Constructors (`new` Keyword)**:\n    *   **Regular Functions**: Can be used as constructor functions with the `new` keyword to create new instances. When called with `new`, they create a new object, set `this` to that object, execute the constructor, and return the new object.\n    *   **Arrow Functions**: Cannot be used as constructors. Attempting to use `new` with an arrow function will throw a `TypeError`.\n\n4.  **`prototype` Property**: \n    *   **Regular Functions**: Have a `prototype` property, which is an object that contains properties and methods that will be inherited by instances created with that constructor function.\n    *   **Arrow Functions**: Do not have a `prototype` property. This is a direct consequence of them not being usable as constructors.\n\n5.  **`super` Keyword**: Arrow functions do not have their own `super` binding. If used in a class, `super` refers to the `super` of the nearest enclosing non-arrow function (e.g., method).\n\n6.  **Named Functions**: Regular functions can be named (e.g., `function foo() {}`), which is useful for debugging stack traces. Arrow functions are typically anonymous (e.g., `const foo = () => {}`). While you can assign them to named variables, the function itself is anonymous.\n\n### When to Use Which?\n-   **Arrow Functions**: Ideal for callbacks (especially in methods where `this` binding is important), short, concise functions, and anywhere `this` should lexically bind.\n-   **Regular Functions**: Necessary for constructors, methods that need their own `this` context, event handlers where `this` should refer to the element, and functions that might need the `arguments` object.",
          "examples": [
            {
              "id": "example_arrow_this_problem",
              "title": "Problem with `this` in Regular Functions (Pre-Arrow Functions)",
              "code": "// Problem with regular functions and this\nfunction Person() {\n  // In the Person constructor, 'this' refers to the new instance\n  this.age = 0;\n  \n  // setInterval's callback is a regular function.\n  // In non-strict mode, within growUp(), 'this' refers to the global object (window/global).\n  // In strict mode, 'this' would be undefined.\n  setInterval(function growUp() {\n    this.age++; // 'this' is not the Person instance!\n    console.log(this.age); // Will log NaN or increment global.age\n  }, 1000);\n}\n\n// To fix this with regular functions, you'd typically use a closure or .bind()\nfunction PersonFixed() {\n  this.age = 0;\n  const self = this; // Capture 'this'\n  setInterval(function growUp() {\n    self.age++;\n    console.log(`Fixed (self): ${self.age}`);\n  }, 1000);\n}\n\nfunction PersonBound() {\n  this.age = 0;\n  setInterval(function growUp() {\n    this.age++;\n    console.log(`Fixed (bind): ${this.age}`);\n  }.bind(this), 1000); // Bind 'this' explicitly\n}\n\n// var p = new Person(); // This will not work as expected\n// var pf = new PersonFixed();\n// var pb = new PersonBound();",
              "explanation": "This example illustrates a common pitfall with `this` in regular functions. Inside `setInterval`, the callback function `growUp` is called without an explicit context, so `this` defaults to the global object (or `undefined` in strict mode). This means `this.age++` doesn't increment the `age` property of the `Person` instance. The 'Fixed (self)' and 'Fixed (bind)' variants show common workarounds using a `self` variable (closure) or `Function.prototype.bind()`.",
              "language": "javascript"
            },
            {
              "id": "example_arrow_this_solution",
              "title": "Solving `this` Binding with Arrow Functions",
              "code": "// Solution with arrow functions and lexical this\nfunction PersonArrow() {\n  this.age = 0;\n  \n  // Arrow function inherits 'this' from its enclosing scope (PersonArrow constructor)\n  setInterval(() => {\n    this.age++; // 'this' correctly refers to the PersonArrow instance\n    console.log(`Arrow Function: ${this.age}`);\n  }, 1000);\n}\n\nconst pArrow = new PersonArrow();",
              "explanation": "This example demonstrates how arrow functions elegantly solve the `this` binding problem. Because arrow functions do not have their own `this`, they inherit `this` from the `PersonArrow` constructor's scope. Thus, `this.age++` correctly modifies the `age` property of the `pArrow` instance.",
              "language": "javascript"
            },
            {
              "id": "example_arrow_arguments",
              "title": "`arguments` Object vs. Rest Parameters",
              "code": "function regularFunction() {\n  console.log('Regular function arguments:', arguments); // Has its own arguments object\n  console.log('Type of arguments:', typeof arguments); // object\n}\n\nconst arrowFunction = (...args) => {\n  console.log('Arrow function rest parameters:', args); // Uses rest parameters\n  // console.log(arguments); // Error in strict mode or refers to outer arguments\n};\n\nregularFunction(1, 2, 3);\narrowFunction('a', 'b', 'c');\n\n// Example of arrow function inheriting arguments from outer regular function\nfunction outerRegular() {\n  const innerArrow = () => {\n    console.log('Inner arrow function accessing outer arguments:', arguments);\n  };\n  innerArrow();\n}\nouterRegular(10, 20);",
              "explanation": "This example highlights the difference in argument handling. Regular functions have their own `arguments` object. Arrow functions do not and should use rest parameters (`...args`) to gather arguments. If an arrow function is nested within a regular function, it will inherit the `arguments` object of that outer regular function.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_arrow_regular_1",
            "question_arrow_regular_2",
            "question_arrow_regular_3",
            "question_arrow_regular_4",
            "question_arrow_regular_5",
            "question_arrow_regular_6"
          ],
          "relatedTasks": [
            "task_arrow_regular_1"
          ],
          "tags": [
            "arrow_functions",
            "regular_functions",
            "this_binding",
            "ES6",
            "arguments_object",
            "constructors"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "functions",
            "this_keyword",
            "scope",
            "closures"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "object_oriented_programming",
            "event_handling",
            "react_components",
            "callback_patterns"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_memoization_1",
          "topic": "Memoization Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of memoization?",
          "answer": "To cache the results of expensive function calls and return the cached result when the same inputs occur again, thereby speeding up execution.",
          "options": [],
          "analysisPoints": [
            "Definition of memoization",
            "Purpose: performance optimization",
            "Mechanism: caching results"
          ],
          "keyConcepts": [
            "Memoization",
            "Caching",
            "Performance"
          ],
          "evaluationCriteria": [
            "Ability to define memoization concisely."
          ],
          "example": "",
          "tags": [
            "memoization",
            "performance",
            "flashcard"
          ],
          "prerequisites": [
            "functions"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_memoization_2",
          "topic": "Memoization Implementation Details",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `memoize` function provided:\n```javascript\nfunction memoize(fn) {\n  const cache = {};\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache[key]) {\n      return cache[key];\n    }\n    const result = fn.apply(this, args);\n    cache[key] = result;\n    return result;\n  };\n}\n```\nWhy is `fn.apply(this, args)` used instead of `fn(...args)`?",
          "answer": "To ensure the original function `fn` executes with its correct `this` context.",
          "options": [
            "To ensure the original function `fn` executes with its correct `this` context.",
            "Because `apply` is faster than the spread operator for function calls.",
            "To convert the `args` array into a list of arguments for `fn`.",
            "To prevent `fn` from accessing the `cache` object directly."
          ],
          "analysisPoints": [
            "Understanding of `this` binding in JavaScript.",
            "Knowledge of `call`, `apply`, and `bind` methods.",
            "Distinguishing between argument passing (`...args` vs `apply` with array) and context binding."
          ],
          "keyConcepts": [
            "this_keyword",
            "function_apply",
            "memoization",
            "function_context"
          ],
          "evaluationCriteria": [
            "Correct identification of `this` binding as the primary reason.",
            "Understanding the difference between `apply` and spread operator in this context."
          ],
          "example": "The `this` context inside the `memoized` function (the one returned by `memoize`) depends on how *it* is called. If `fn` is a method of an object (e.g., `obj.myMethod`), then `this` inside `myMethod` should refer to `obj`. By using `fn.apply(this, args)`, the `this` value of the *memoized* function call is explicitly passed as the `this` context for the original `fn` call, preserving its intended behavior.",
          "tags": [
            "memoization",
            "this_keyword",
            "functions",
            "mcq"
          ],
          "prerequisites": [
            "this_keyword",
            "function_apply_call_bind"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_memoization_3",
          "topic": "Limitations of Memoization",
          "level": "medium",
          "type": "open",
          "question": "What are some potential drawbacks or situations where memoization might not be the optimal solution?",
          "answer": "1.  **Memory Consumption**: Storing all computed results in a cache can lead to high memory usage, especially for functions with a large number of unique inputs.\n2.  **Overhead of Key Generation**: For functions with complex arguments (e.g., objects, arrays, functions), generating a unique and consistent cache key (e.g., using `JSON.stringify` or deep hashing) can be computationally expensive, potentially negating the benefits of memoization.\n3.  **Impure Functions**: Memoization is most effective for pure functions (functions that always produce the same output for the same input and have no side effects). For impure functions (e.g., functions that depend on global state, make network requests, or produce random numbers), memoization can lead to stale or incorrect results because the output might change even with the same inputs.\n4.  **Limited Re-computations**: If a function is called with the same inputs only a few times, the overhead of the memoization logic (cache lookup, key generation) might outweigh the benefit of avoiding re-computation.",
          "analysisPoints": [
            "Discussion of memory implications.",
            "Understanding of performance trade-offs for key generation.",
            "Distinction between pure and impure functions.",
            "Consideration of frequency of calls with same inputs."
          ],
          "keyConcepts": [
            "Memoization",
            "Performance_tradeoffs",
            "Pure_functions",
            "Memory_management"
          ],
          "evaluationCriteria": [
            "Ability to articulate multiple drawbacks.",
            "Demonstrates understanding of pure function concept.",
            "Considers practical implications like memory and key generation cost."
          ],
          "example": "",
          "tags": [
            "memoization",
            "optimization",
            "design_patterns",
            "open-ended"
          ],
          "prerequisites": [
            "pure_functions",
            "data_structures",
            "algorithm_analysis"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_memoization_4",
          "topic": "Memoization Application",
          "level": "hard",
          "type": "code",
          "question": "Implement a `memoize` function that can handle function arguments which are objects, where object key order might vary but the content is logically the same. For simplicity, assume arguments are always primitive or plain objects/arrays that can be safely deep-sorted and stringified. If the function takes multiple arguments, ensure all are considered for the key.",
          "answer": "```javascript\nfunction deepSortAndStringify(arg) {\n  if (typeof arg !== 'object' || arg === null) {\n    return JSON.stringify(arg);\n  }\n  if (Array.isArray(arg)) {\n    return '[' + arg.map(item => deepSortAndStringify(item)).join(',') + ']';\n  }\n  const sortedKeys = Object.keys(arg).sort();\n  const sortedObject = {};\n  for (const key of sortedKeys) {\n    sortedObject[key] = arg[key];\n  }\n  return '{' + sortedKeys.map(key => `\"${key}\":${deepSortAndStringify(sortedObject[key])}`).join(',') + '}';\n}\n\nfunction memoizeComplex(fn) {\n  const cache = new Map(); // Using Map for better key handling with complex types potentially\n  return function(...args) {\n    // Create a robust key for complex arguments\n    const key = deepSortAndStringify(args);\n    \n    if (cache.has(key)) {\n      console.log('Fetching from cache (complex key):', key);\n      return cache.get(key);\n    }\n\n    console.log('Calculating result (complex key):', key);\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Example usage:\nconst sumObjects = memoizeComplex(function(obj1, obj2) {\n  const sumKeys = [...new Set([...Object.keys(obj1), ...Object.keys(obj2)])];\n  const result = {};\n  for (const key of sumKeys) {\n    result[key] = (obj1[key] || 0) + (obj2[key] || 0);\n  }\n  return result;\n});\n\nconsole.log(sumObjects({a: 1, b: 2}, {b: 3, c: 4})); // Calculates\nconsole.log(sumObjects({b: 2, a: 1}, {c: 4, b: 3})); // Fetches from cache due to sorted key\nconsole.log(sumObjects({a: 5}, {b: 6})); // Calculates\n```",
          "options": [],
          "analysisPoints": [
            "Understanding of object serialization for cache keys.",
            "Ability to handle deep comparisons or canonicalization of objects.",
            "Correct usage of `this` context with `apply`.",
            "Demonstrates robustness beyond simple `JSON.stringify`."
          ],
          "keyConcepts": [
            "Memoization",
            "Deep_comparison",
            "Serialization",
            "Function_apply",
            "Caching_strategies"
          ],
          "evaluationCriteria": [
            "Correct implementation of `deepSortAndStringify`.",
            "Successful integration of the custom key generation into `memoize`.",
            "Preservation of `this` context.",
            "Handling of multiple arguments."
          ],
          "example": "",
          "tags": [
            "memoization",
            "coding_challenge",
            "optimization",
            "algorithms"
          ],
          "prerequisites": [
            "recursion",
            "object_manipulation",
            "data_structures",
            "JSON"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_memoization_5",
          "topic": "Memoization vs. Dynamic Programming",
          "level": "medium",
          "type": "open",
          "question": "How does memoization relate to Dynamic Programming (DP)? Can all DP problems be solved with memoization?",
          "answer": "Memoization is a technique used within Dynamic Programming (DP) to optimize recursive solutions. It's often referred to as 'top-down' DP.\n\n**Relationship:**\n*   **Dynamic Programming:** A method for solving complex problems by breaking them down into simpler subproblems. It solves each subproblem only once and stores the solutions to avoid redundant computations. This can be implemented in two ways: memoization (top-down, recursive with caching) or tabulation (bottom-up, iterative with a table).\n*   **Memoization:** Specifically, it's the caching aspect of DP. When a recursive function is called, it first checks if the result for the current inputs is already in the cache. If so, it returns the cached value. Otherwise, it computes the result, stores it in the cache, and then returns it.\n\n**Can all DP problems be solved with memoization?**\nYes, conceptually, any problem that can be solved with dynamic programming can also be solved using memoization. This is because both techniques rely on the principle of overlapping subproblems and optimal substructure. Memoization implicitly handles the order of computation by only computing subproblems when they are first needed. The choice between memoization (top-down) and tabulation (bottom-up) often comes down to personal preference, readability, or performance characteristics (e.g., iterative tabulation can sometimes be more memory-efficient or faster due to less recursion overhead, but memoization can be simpler to write for complex state transitions).",
          "analysisPoints": [
            "Correctly identifies memoization as a DP technique.",
            "Explains the 'top-down' nature of memoization in DP.",
            "Compares/contrasts with tabulation (bottom-up DP).",
            "Accurately states that all DP problems can be solved with memoization.",
            "Discusses the underlying principles (overlapping subproblems, optimal substructure)."
          ],
          "keyConcepts": [
            "Memoization",
            "Dynamic_Programming",
            "Recursion",
            "Top-down_DP",
            "Tabulation",
            "Overlapping_subproblems"
          ],
          "evaluationCriteria": [
            "Clear explanation of the relationship.",
            "Accuracy in stating applicability.",
            "Demonstrates deeper understanding of DP concepts."
          ],
          "example": "",
          "tags": [
            "memoization",
            "dynamic_programming",
            "algorithms",
            "open-ended"
          ],
          "prerequisites": [
            "recursion",
            "algorithms"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_generator_1",
          "topic": "Generator Function Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary keyword used to define a generator function in JavaScript?",
          "answer": "`function*`",
          "options": [],
          "analysisPoints": [
            "Recall syntax for generator functions."
          ],
          "keyConcepts": [
            "Generators",
            "Syntax",
            "JavaScript"
          ],
          "evaluationCriteria": [
            "Correctly identifies the `function*` syntax."
          ],
          "example": "",
          "tags": [
            "generators",
            "ES6",
            "flashcard"
          ],
          "prerequisites": [
            "functions"
          ],
          "complexity": 2,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_generator_2",
          "topic": "Generator Function Execution",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following generator function:\n```javascript\nfunction* countUpTo(limit) {\n  for (let i = 1; i <= limit; i++) {\n    yield i;\n  }\n}\nconst counter = countUpTo(3);\n```\nWhat will be the output of `console.log(counter.next().value); console.log(counter.next().done);` executed sequentially?",
          "answer": "1, false",
          "options": [
            "1, false",
            "undefined, true",
            "1, true",
            "3, false"
          ],
          "analysisPoints": [
            "Understanding of `yield` keyword.",
            "Knowledge of the `next()` method's return value `{ value, done }`.",
            "Ability to trace generator execution step-by-step."
          ],
          "keyConcepts": [
            "Generators",
            "Yield",
            "Next_method",
            "Iterator_protocol"
          ],
          "evaluationCriteria": [
            "Correctly identifies the first yielded value.",
            "Accurately determines the `done` status after the first yield."
          ],
          "example": "The first call to `counter.next()` executes the loop up to `yield i;` where `i` is 1. So, `value` will be 1. Since there are more values to yield (2 and 3), `done` will be `false`.",
          "tags": [
            "generators",
            "ES6",
            "mcq",
            "iteration"
          ],
          "prerequisites": [
            "loops",
            "functions"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_generator_3",
          "topic": "Generator Use Cases",
          "level": "medium",
          "type": "open",
          "question": "Describe a practical scenario where a generator function would be a more suitable choice than a regular function that returns an array.",
          "answer": "A practical scenario where a generator function is more suitable than a regular function returning an array is when dealing with **potentially very large or infinite sequences of data**, or when you need to **process data lazily (on-demand)**.\n\n**Example: Processing a large log file or a data stream.**\nImagine you have a massive log file (e.g., gigabytes in size) or a continuous data stream, and you need to filter or transform its entries one by one without loading the entire content into memory.\n\n*   **Regular Function (returning array):** You would have to read the entire file/stream, process all entries, store them in an array, and then return the array. This would consume a huge amount of memory, potentially leading to out-of-memory errors, and delay processing until the entire array is built.\n\n*   **Generator Function:** A generator function could read one line (or chunk) at a time, process it, and `yield` the result. It would then pause, waiting for the next `next()` call. This allows you to process data piece by piece, consuming minimal memory (only holding the current chunk in memory), and start processing results immediately as they become available. It's especially powerful when you might only need a few initial results or if the stream is truly infinite (like a real-time event log).\n\nThis lazy evaluation makes generators ideal for iterating over large datasets, implementing infinite sequences (like an ID generator or Fibonacci sequence), or handling asynchronous data streams.",
          "analysisPoints": [
            "Identifies scenarios with large/infinite data.",
            "Highlights memory efficiency as a key benefit.",
            "Explains lazy evaluation concept.",
            "Provides a concrete, relatable example (e.g., large file processing, data streams).",
            "Compares memory/performance implications with traditional array return."
          ],
          "keyConcepts": [
            "Generators",
            "Lazy_evaluation",
            "Memory_efficiency",
            "Infinite_sequences",
            "Data_streams",
            "Use_cases"
          ],
          "evaluationCriteria": [
            "Clear and concise explanation of the advantage.",
            "Relevant and well-explained example.",
            "Demonstrates understanding of generator's core benefits."
          ],
          "example": "",
          "tags": [
            "generators",
            "performance",
            "memory_management",
            "open-ended"
          ],
          "prerequisites": [
            "data_structures",
            "functions"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_generator_4",
          "topic": "Generator Control Flow",
          "level": "hard",
          "type": "code",
          "question": "Write a generator function `throttleGenerator(func, delay)` that takes a function `func` and a `delay` in milliseconds. The generator should yield the result of `func()` at most once every `delay` milliseconds. Subsequent calls to `next()` within the `delay` period should return the previously yielded value without re-executing `func`. After the `delay` expires, the next `next()` call should re-execute `func`.",
          "answer": "```javascript\nfunction* throttleGenerator(func, delay) {\n  let lastExecutionTime = 0;\n  let lastResult = undefined;\n\n  while (true) {\n    const currentTime = Date.now();\n\n    if (currentTime - lastExecutionTime >= delay) {\n      // Time elapsed, re-execute func\n      lastResult = func();\n      lastExecutionTime = currentTime;\n      yield lastResult;\n    } else {\n      // Within delay, yield the last result without re-execution\n      yield lastResult; \n    }\n  }\n}\n\n// Example usage:\nlet callCount = 0;\nconst throttledFunc = () => {\n  callCount++;\n  return `Called at ${Date.now()}, count: ${callCount}`;\n};\n\nconst throttler = throttleGenerator(throttledFunc, 2000); // 2-second delay\n\nconsole.log(throttler.next().value); // Should execute func\n\nsetTimeout(() => {\n  console.log(throttler.next().value); // Should return cached value\n}, 500);\n\nsetTimeout(() => {\n  console.log(throttler.next().value); // Should return cached value\n}, 1500);\n\nsetTimeout(() => {\n  console.log(throttler.next().value); // Should execute func again\n}, 2500);\n\nsetTimeout(() => {\n  console.log(throttler.next().value); // Should return cached value\n}, 3000);\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `yield` for pausing and resuming.",
            "Manages state (`lastExecutionTime`, `lastResult`) within the generator closure.",
            "Implements the throttling logic based on `delay`.",
            "Distinguishes between re-execution and cached return.",
            "Demonstrates understanding of generator's ability to maintain state across calls."
          ],
          "keyConcepts": [
            "Generators",
            "Throttling",
            "State_management",
            "Closures",
            "Time-based_logic",
            "Control_flow"
          ],
          "evaluationCriteria": [
            "Correct implementation of throttling logic.",
            "Effective use of generator features (`yield`, state persistence).",
            "Handles both re-execution and caching scenarios."
          ],
          "example": "",
          "tags": [
            "generators",
            "algorithms",
            "throttling",
            "coding_challenge"
          ],
          "prerequisites": [
            "closures",
            "Date_object",
            "setTimeout"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_generator_5",
          "topic": "Generator Advanced Usage",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a feature or direct capability of JavaScript generator functions?",
          "answer": "Automatically handling uncaught promise rejections within the generator without explicit `try...catch`.",
          "options": [
            "Pausing and resuming function execution at specific points.",
            "Generating potentially infinite sequences of values.",
            "Receiving values back from the consumer using `yield` as an expression.",
            "Automatically handling uncaught promise rejections within the generator without explicit `try...catch`."
          ],
          "analysisPoints": [
            "Understanding of `yield` as both a statement and an expression (sending values *into* a generator).",
            "Knowledge of generator's ability for infinite sequences and pausing.",
            "Distinguishing generator features from `async/await` error handling."
          ],
          "keyConcepts": [
            "Generators",
            "Yield",
            "Iteration",
            "Error_handling",
            "Promises"
          ],
          "evaluationCriteria": [
            "Correctly identifies the false statement regarding error handling.",
            "Demonstrates understanding of core generator capabilities."
          ],
          "example": "While generators can be used for asynchronous patterns (like with `co` library), they do not inherently handle promise rejections. That functionality is built into `async/await`. Generators can `yield` promises, and `next()` can resolve them, but error propagation requires explicit `try...catch` or `.catch()` on the Promise returned by `next()`.",
          "tags": [
            "generators",
            "ES6",
            "promises",
            "mcq"
          ],
          "prerequisites": [
            "promises",
            "error_handling"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_1",
          "topic": "Async/Await Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What type of value does an `async` function always return, implicitly or explicitly?",
          "answer": "A Promise.",
          "options": [],
          "analysisPoints": [
            "Fundamental understanding of `async` function return type."
          ],
          "keyConcepts": [
            "Async_functions",
            "Promises",
            "Return_values"
          ],
          "evaluationCriteria": [
            "Correctly identifies that `async` functions return Promises."
          ],
          "example": "",
          "tags": [
            "async_await",
            "promises",
            "flashcard"
          ],
          "prerequisites": [
            "promises"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_2",
          "topic": "Await Keyword Behavior",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements about the `await` keyword is TRUE?",
          "answer": "It can only be used inside an `async` function.",
          "options": [
            "It can be used anywhere in JavaScript code, including the global scope.",
            "It pauses the entire JavaScript execution thread until the Promise settles.",
            "It can only be used inside an `async` function.",
            "It automatically catches any errors thrown by the awaited Promise."
          ],
          "analysisPoints": [
            "Understanding of the scope limitation of `await`.",
            "Distinguishing between pausing an `async` function vs. blocking the thread.",
            "Knowledge of error handling mechanisms (`try...catch`)."
          ],
          "keyConcepts": [
            "Await_keyword",
            "Async_functions",
            "Event_loop",
            "Non-blocking",
            "Error_handling"
          ],
          "evaluationCriteria": [
            "Correctly identifies the scope of `await`.",
            "Distinguishes between thread blocking and `async` function suspension."
          ],
          "example": "`await` is designed to work cooperatively with the event loop. When `await` encounters a pending promise, it suspends the *async function's execution* and allows the JavaScript engine to perform other tasks. It does not block the main thread. Error handling requires `try...catch`.",
          "tags": [
            "async_await",
            "promises",
            "event_loop",
            "mcq"
          ],
          "prerequisites": [
            "promises",
            "event_loop"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_3",
          "topic": "Async Error Handling",
          "level": "medium",
          "type": "open",
          "question": "Explain how error handling is typically managed in `async` functions, providing a simple code example.",
          "answer": "Error handling in `async` functions is typically managed using `try...catch` blocks, similar to synchronous code. When a Promise awaited by `await` rejects, `await` itself will throw an error. This error can then be caught by a surrounding `try...catch` block.\n\n**Explanation:**\n1.  **`try` block**: Contains the `await` expressions and other code that might throw errors (e.g., network issues, invalid responses).\n2.  **`catch` block**: If any `await`ed Promise rejects, or any synchronous code within the `try` block throws an error, execution immediately jumps to the `catch` block. The `catch` block receives the error object, allowing you to log it, display a message, or take corrective action.\n3.  **Return/Re-throw**: Within the `catch` block, you can choose to return a default value, return a new rejected Promise (if the `async` function is consumed by `.then().catch()`), or re-throw the error to propagate it further up the call stack.\n\n**Example:**\n```javascript\nasync function safeFetchData(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      // This will cause the Promise returned by fetch to reject if status is not 2xx\n      // Or, as shown here, we can explicitly throw for non-ok responses\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Failed to fetch data:', error.message);\n    // Re-throw the error so consumers of safeFetchData can also catch it\n    throw error;\n    // Alternatively, return a default value or handle gracefully:\n    // return { error: true, message: error.message };\n  }\n}\n\n// Usage with error handling\nsafeFetchData('https://api.example.com/invalid-endpoint')\n  .then(data => console.log('Success:', data))\n  .catch(err => console.error('Caught in consumer:', err.message));\n\nsafeFetchData('https://jsonplaceholder.typicode.com/todos/1')\n  .then(data => console.log('Success:', data))\n  .catch(err => console.error('Caught in consumer:', err.message));\n```",
          "analysisPoints": [
            "Clear explanation of `try...catch` usage with `async/await`.",
            "Demonstrates how rejected Promises are handled by `await`.",
            "Provides a relevant and correct code example.",
            "Discusses options within the `catch` block (re-throw, return default)."
          ],
          "keyConcepts": [
            "Async_functions",
            "Await_keyword",
            "Error_handling",
            "Try_catch",
            "Promises"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of error handling strategy.",
            "Accurate code example demonstrating the concept.",
            "Ability to discuss error propagation."
          ],
          "example": "",
          "tags": [
            "async_await",
            "error_handling",
            "promises",
            "open-ended"
          ],
          "prerequisites": [
            "promises",
            "try_catch"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_async_4",
          "topic": "Async Parallel Execution",
          "level": "hard",
          "type": "code",
          "question": "You have two asynchronous functions, `fetchUser(id)` and `fetchPosts(userId)`, both returning Promises. Write an `async` function `getUserAndPosts(id)` that fetches the user and their posts **concurrently** (in parallel) and returns an object `{ user: ..., posts: ... }`. Ensure proper error handling if either fetch fails.",
          "answer": "```javascript\n// Mock async functions\nfunction fetchUser(id) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      if (id === 1) resolve({ id: 1, name: 'Alice' });\n      else if (id === 2) resolve({ id: 2, name: 'Bob' });\n      else reject(new Error('User not found'));\n    }, 500);\n  });\n}\n\nfunction fetchPosts(userId) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId === 1) resolve([{ postId: 101, title: 'Post A' }, { postId: 102, title: 'Post B' }]);\n      else if (userId === 2) resolve([{ postId: 201, title: 'Post C' }]);\n      else reject(new Error('Posts not found for user'));\n    }, 700);\n  });\n}\n\nasync function getUserAndPosts(id) {\n  try {\n    // Use Promise.all to run promises concurrently\n    const [user, posts] = await Promise.all([\n      fetchUser(id),\n      fetchPosts(id) \n    ]);\n    \n    return { user, posts };\n  } catch (error) {\n    console.error(`Error fetching data for user ${id}:`, error.message);\n    // Re-throw the error or return a partial result/error object\n    throw error; \n  }\n}\n\n// Example Usage:\n(async () => {\n  console.log('--- Successful Fetch ---');\n  try {\n    const data = await getUserAndPosts(1);\n    console.log('Result:', data);\n  } catch (err) {\n    console.error('Caught error in main:', err.message);\n  }\n\n  console.log('\\n--- User Not Found Error ---');\n  try {\n    const data = await getUserAndPosts(99);\n    console.log('Result:', data);\n  } catch (err) {\n    console.error('Caught error in main:', err.message);\n  }\n\n  console.log('\\n--- Posts Not Found Error ---');\n  // To simulate posts not found specifically, might need to adjust mock\n  // Or assume a generic error covers it.\n  // For this example, let's assume fetchPosts(id) can throw for certain IDs\n  // (e.g., if fetchUser succeeds but fetchPosts fails for that user)\n  // A more robust mock would be needed to test this precisely.\n  try {\n    const data = await getUserAndPosts(2); // If fetchPosts for 2 was designed to fail\n    console.log('Result:', data);\n  } catch (err) {\n    console.error('Caught error in main:', err.message);\n  }\n})();\n```",
          "options": [],
          "analysisPoints": [
            "Correct usage of `Promise.all` for parallel execution.",
            "Understanding of destructuring assignment for results.",
            "Proper `try...catch` block for error handling in `async` functions.",
            "Ability to structure and combine asynchronous operations."
          ],
          "keyConcepts": [
            "Async_await",
            "Promise.all",
            "Parallel_execution",
            "Error_handling",
            "API_integration"
          ],
          "evaluationCriteria": [
            "Successful implementation of concurrent fetching.",
            "Robust error handling.",
            "Returns the specified object structure."
          ],
          "example": "",
          "tags": [
            "async_await",
            "promises",
            "coding_challenge",
            "API_calls",
            "concurrency"
          ],
          "prerequisites": [
            "promises",
            "async_await",
            "error_handling"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_async_5",
          "topic": "Async vs. Promise Chains",
          "level": "medium",
          "type": "open",
          "question": "While `async/await` is syntactic sugar over Promises, what are the main advantages `async/await` offers over traditional Promise `.then().catch()` chains, especially for complex asynchronous flows?",
          "answer": "The main advantages of `async/await` over traditional Promise `.then().catch()` chains for complex asynchronous flows are primarily related to **readability, error handling, and debugging**.\n\n1.  **Readability and Maintainability (Synchronous-like Code)**:\n    *   `async/await` allows writing asynchronous code in a sequential, synchronous-looking style. This eliminates callback hell and makes the control flow much easier to follow, especially when multiple dependent asynchronous operations are involved. Nested `.then()` calls can quickly become difficult to read and manage.\n\n2.  **Simpler Error Handling (`try...catch`)**:\n    *   With `async/await`, error handling is done using standard `try...catch` blocks, which is familiar to developers from synchronous programming. In contrast, Promise chains require `.catch()` calls at the end of a chain or after each `.then()` for granular error handling, which can sometimes be less intuitive or lead to missed errors if not placed correctly. A single `try...catch` can wrap multiple `await` calls.\n\n3.  **Better Debugging Experience**:\n    *   Debugging `async/await` code is generally easier. When an `await` pauses execution, the debugger can step through the code line by line as if it were synchronous. Debugging deeply nested `.then()` callbacks often involves jumping between different stack frames, which can be disorienting.\n\n4.  **Conditional Asynchronous Operations**: Writing conditional logic (if/else, loops) with `await` is much more straightforward. You can use standard control flow structures directly. With `.then()`, you often need to chain promises conditionally or use auxiliary variables, which can complicate the logic.\n\n5.  **Less Verbosity**: `async/await` often results in more concise code, especially when you need to extract values from multiple promises or handle intermediate results.",
          "analysisPoints": [
            "Highlights readability and synchronous-like syntax.",
            "Emphasizes simplified `try...catch` error handling.",
            "Discusses improved debugging experience.",
            "Mentions easier conditional logic.",
            "Acknowledges `async/await` as syntactic sugar."
          ],
          "keyConcepts": [
            "Async_await",
            "Promises",
            "Readability",
            "Error_handling",
            "Debugging",
            "Syntactic_sugar"
          ],
          "evaluationCriteria": [
            "Clear articulation of the advantages.",
            "Focus on practical benefits for complex scenarios.",
            "Compares directly to Promise chains."
          ],
          "example": "",
          "tags": [
            "async_await",
            "promises",
            "architecture",
            "open-ended"
          ],
          "prerequisites": [
            "promises"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_arrow_regular_1",
          "topic": "Arrow vs. Regular Function `this`",
          "level": "easy",
          "type": "flashcard",
          "question": "Which type of function (regular or arrow) has a `this` value that is lexically bound?",
          "answer": "Arrow functions.",
          "options": [],
          "analysisPoints": [
            "Recall the core difference in `this` binding."
          ],
          "keyConcepts": [
            "Arrow_functions",
            "Regular_functions",
            "this_binding",
            "Lexical_this"
          ],
          "evaluationCriteria": [
            "Correctly identifies arrow functions for lexical `this`."
          ],
          "example": "",
          "tags": [
            "arrow_functions",
            "this_keyword",
            "flashcard"
          ],
          "prerequisites": [
            "this_keyword"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_arrow_regular_2",
          "topic": "Arrow vs. Regular Function `arguments` Object",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following code snippet:\n```javascript\nfunction outer() {\n  const arrowFunc = () => {\n    console.log(arguments);\n  };\n  arrowFunc(4, 5, 6);\n}\nouter(1, 2, 3);\n```\nWhat will be logged to the console by `arrowFunc`?",
          "answer": "An `arguments` object containing `[1, 2, 3]`.",
          "options": [
            "An `arguments` object containing `[4, 5, 6]`.",
            "An `arguments` object containing `[1, 2, 3]`.",
            "An empty object `{}`.",
            "A `ReferenceError` because arrow functions do not have an `arguments` object."
          ],
          "analysisPoints": [
            "Understanding that arrow functions do not have their own `arguments` object.",
            "Knowledge that arrow functions inherit `arguments` from the nearest *enclosing regular function*.",
            "Tracing the scope chain correctly."
          ],
          "keyConcepts": [
            "Arrow_functions",
            "Arguments_object",
            "Lexical_scope",
            "Regular_functions"
          ],
          "evaluationCriteria": [
            "Correctly identifies the source of the `arguments` object.",
            "Demonstrates understanding of lexical scope for arrow functions."
          ],
          "example": "Arrow functions do not have their own `arguments` object. When `arguments` is referenced inside an arrow function, it looks up the scope chain for the nearest enclosing *regular* function's `arguments` object. In this case, `outer` is the enclosing regular function, and it was called with `(1, 2, 3)`.",
          "tags": [
            "arrow_functions",
            "arguments_object",
            "scope",
            "mcq"
          ],
          "prerequisites": [
            "scope",
            "arguments_object"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_arrow_regular_3",
          "topic": "Function Types and `new`",
          "level": "medium",
          "type": "open",
          "question": "Can an arrow function be used as a constructor with the `new` keyword? Explain why or why not, and describe the implications.",
          "answer": "No, an arrow function cannot be used as a constructor with the `new` keyword.\n\n**Why not?**\nArrow functions fundamentally lack internal methods and properties that are essential for constructor behavior:\n1.  **No `[[Construct]]` method**: Regular functions have an internal `[[Construct]]` method that is invoked when they are called with `new`. Arrow functions do not have this internal method.\n2.  **No `prototype` property**: Constructor functions rely on their `prototype` property to set up the prototype chain for new instances. Arrow functions do not have their own `prototype` property.\n3.  **No `this` binding**: When a regular function is called with `new`, a new object is created, and `this` inside the constructor refers to this new object. Since arrow functions lexically bind `this` (they inherit `this` from their enclosing scope), they cannot bind `this` to a newly created instance.\n\n**Implications:**\n-   If you attempt to use `new` with an arrow function, it will throw a `TypeError` (e.g., `TypeError: Class constructor ArrowFunction cannot be invoked without 'new'` or `TypeError: someArrowFunction is not a constructor`).\n-   This means arrow functions are not suitable for defining classes or creating object instances in the traditional way.\n-   They are designed for functions where context binding is fixed and for concise expressions, not for object-oriented construction.",
          "analysisPoints": [
            "Clear 'No' answer.",
            "Explains the lack of `[[Construct]]` method.",
            "Mentions the absence of `prototype` property.",
            "Connects to the `this` binding behavior of arrow functions.",
            "States the resulting `TypeError` and implications for OOP."
          ],
          "keyConcepts": [
            "Arrow_functions",
            "Constructors",
            "New_keyword",
            "Prototype",
            "this_binding",
            "TypeError"
          ],
          "evaluationCriteria": [
            "Accurate explanation of why arrow functions can't be constructors.",
            "Demonstrates understanding of underlying JavaScript mechanisms.",
            "Describes practical implications."
          ],
          "example": "",
          "tags": [
            "arrow_functions",
            "constructors",
            "object_oriented_programming",
            "open-ended"
          ],
          "prerequisites": [
            "prototypal_inheritance",
            "this_keyword"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_arrow_regular_4",
          "topic": "Choosing Function Types",
          "level": "medium",
          "type": "mcq",
          "question": "You are writing a React component and need to define a class method `handleClick` that will be passed as a callback to an event listener (e.g., `onClick`). Which approach is generally recommended for `handleClick` to ensure `this` correctly refers to the component instance inside the handler?",
          "answer": "Define `handleClick` as an arrow function property of the class.",
          "options": [
            "Define `handleClick` as a regular method and bind it in the constructor (`this.handleClick = this.handleClick.bind(this);`).",
            "Define `handleClick` as a regular method and use `onClick={this.handleClick.bind(this)}` in the JSX.",
            "Define `handleClick` as an arrow function property of the class.",
            "Define `handleClick` as a regular method and call `super()` inside it."
          ],
          "analysisPoints": [
            "Understanding `this` binding in class methods and event handlers.",
            "Knowledge of arrow function's lexical `this`.",
            "Familiarity with common React patterns for event handling.",
            "Comparing different binding strategies."
          ],
          "keyConcepts": [
            "Arrow_functions",
            "this_binding",
            "React",
            "Event_handlers",
            "Class_components"
          ],
          "evaluationCriteria": [
            "Identifies the most modern and often preferred solution for `this` in React event handlers.",
            "Demonstrates practical application of arrow function `this` behavior."
          ],
          "example": "```javascript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n    // Option A: Binding in constructor (traditional)\n    // this.handleClickRegular = this.handleClickRegular.bind(this);\n  }\n\n  // Option A: Regular method\n  handleClickRegular() {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  // Option C: Arrow function as class property (recommended ESNext)\n  handleClickArrow = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        {/* Option A usage */}\n        {/* <button onClick={this.handleClickRegular}>Increment Regular</button> */}\n        {/* Option B usage */}\n        {/* <button onClick={this.handleClickRegular.bind(this)}>Increment Bound Inline</button> */}\n        {/* Option C usage */}\n        <button onClick={this.handleClickArrow}>Increment Arrow</button>\n      </div>\n    );\n  }\n}\n```\nDefining an arrow function as a class property (`handleClickArrow = () => { ... };`) ensures that `this` inside `handleClickArrow` is lexically bound to the `MyComponent` instance, avoiding the need for explicit binding in the constructor or inline binding in JSX, which can be less performant for frequent re-renders.",
          "tags": [
            "arrow_functions",
            "this_keyword",
            "react",
            "event_handling",
            "mcq"
          ],
          "prerequisites": [
            "this_keyword",
            "react_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_arrow_regular_5",
          "topic": "Function Types in Different Contexts",
          "level": "hard",
          "type": "code",
          "question": "Given the following HTML and JavaScript:\n\nHTML:\n```html\n<button id=\"myButton\">Click Me</button>\n```\n\nJavaScript:\n```javascript\nconst button = document.getElementById('myButton');\n\nconst handler1 = function() {\n  console.log('Handler 1 this:', this.id);\n};\n\nconst handler2 = () => {\n  console.log('Handler 2 this:', this);\n};\n\nbutton.addEventListener('click', handler1);\n// button.addEventListener('click', handler2); // If uncommented\n\n// What would be logged if handler2 was also attached?\n// Assume this script is run in the global context of a browser.\n```\n\nExplain what `this` refers to in `handler1` and `handler2` when they are invoked by the `click` event listener. Predict the output for both if `handler2` were uncommented.",
          "answer": "For `handler1` (regular function):\nWhen a regular function is used as an event listener, `this` inside the handler refers to the **element on which the listener was placed**.\n\nOutput for `handler1`:\n`Handler 1 this: myButton`\n\nFor `handler2` (arrow function):\nArrow functions do not have their own `this` binding; they lexically inherit `this` from their enclosing scope. In this case, `handler2` is defined in the global scope (outside any other function or class).\n\nOutput for `handler2`:\n`Handler 2 this: Window` (in a browser environment)\n\n**Explanation:**\n-   `handler1`: As a regular function, `this` is dynamically set by the event listener mechanism to the `button` element itself, because the function is called as `button.handler1()`. This is a common and useful behavior for event handlers.\n-   `handler2`: As an arrow function, it captures `this` from its definition context. Since it's defined directly in the global script scope, its `this` will always refer to the global object, which is `window` in a browser. It will *not* refer to the `button` element, making it generally unsuitable for standard `this`-dependent event listeners unless you explicitly want the global `this` or are relying on some other context management (e.g., passing `event.currentTarget`).\n\n```javascript\nconst button = document.getElementById('myButton');\n\nconst handler1 = function() {\n  console.log('Handler 1 this:', this.id);\n};\n\nconst handler2 = () => {\n  console.log('Handler 2 this:', this); // 'this' will be window\n};\n\nbutton.addEventListener('click', handler1);\nbutton.addEventListener('click', handler2); // Uncommented\n\n// When clicked, output will be:\n// Handler 1 this: myButton\n// Handler 2 this: Window { /* ... */ }\n```",
          "options": [],
          "analysisPoints": [
            "Correctly identifies `this` for regular function event handlers.",
            "Correctly identifies `this` for arrow function event handlers based on lexical scope.",
            "Understands the global `this` context in browsers.",
            "Predicts the exact output.",
            "Explains the underlying reasons for `this` binding."
          ],
          "keyConcepts": [
            "this_keyword",
            "Event_listeners",
            "Regular_functions",
            "Arrow_functions",
            "Global_object",
            "Lexical_scope"
          ],
          "evaluationCriteria": [
            "Accurate prediction and explanation for both function types.",
            "Demonstrates deep understanding of `this` in various contexts.",
            "Properly applies lexical vs. dynamic `this`."
          ],
          "example": "",
          "tags": [
            "this_keyword",
            "arrow_functions",
            "regular_functions",
            "event_handling",
            "coding_challenge"
          ],
          "prerequisites": [
            "this_keyword",
            "event_listeners",
            "browser_environment"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_arrow_regular_6",
          "topic": "Arrow vs. Regular Function Summary",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is TRUE regarding arrow functions compared to regular functions?",
          "answer": "Arrow functions do not have their own `arguments` object.",
          "options": [
            "Arrow functions can be used as constructors with the `new` keyword.",
            "Arrow functions have their own `arguments` object, similar to regular functions.",
            "Arrow functions lexically bind `this`, meaning `this` is determined by where they are defined.",
            "Arrow functions have a `prototype` property that allows for prototypal inheritance."
          ],
          "analysisPoints": [
            "Recap of key differences: `this` binding, `arguments`, `new`, `prototype`."
          ],
          "keyConcepts": [
            "Arrow_functions",
            "Regular_functions",
            "this_binding",
            "Arguments_object",
            "Constructors",
            "Prototype"
          ],
          "evaluationCriteria": [
            "Correct identification of a true statement among common misconceptions."
          ],
          "example": "Arrow functions are explicitly designed *not* to have their own `this` binding, `arguments` object, `prototype` property, or to be constructible with `new`. Their primary strength lies in their lexical `this` binding, making them excellent for callbacks where the surrounding context's `this` needs to be preserved.",
          "tags": [
            "arrow_functions",
            "regular_functions",
            "mcq"
          ],
          "prerequisites": [
            "functions"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_memoization_1",
          "title": "Implement a Memoized Fibonacci Sequence Calculator",
          "description": "\nYour task is to implement a memoized version of the Fibonacci sequence calculation. The `fibonacci(n)` function should calculate the nth Fibonacci number. Implement a generic `memoize` higher-order function that can cache the results of any single-argument function. Then, apply this `memoize` function to your `fibonacci` calculation.\n\n**Requirements:**\n1.  Create a `memoize` function that takes another function `fn` as its argument and returns a memoized version of `fn`.\n2.  The `memoize` function should use an internal cache (e.g., an object or `Map`).\n3.  For simplicity, assume the memoized function will only take a single primitive argument (like a number or string) for which `JSON.stringify` can reliably generate a key.\n4.  Implement a `fibonacci(n)` function (recursive, non-memoized initially).\n5.  Apply the `memoize` function to `fibonacci` to create `memoizedFibonacci`.\n6.  Demonstrate that `memoizedFibonacci` correctly calculates results and efficiently retrieves them from the cache for repeated calls.\n",
          "difficulty": "medium",
          "startingCode": "function memoize(fn) {\n  const cache = {};\n  return function(arg) {\n    // TODO: Implement cache logic for single argument\n    // const key = String(arg); // Simple key for primitive args\n    // if (cache.hasOwnProperty(key)) { ... }\n    // else { ... cache[key] = fn(arg); ... }\n    throw new Error(\"Not implemented\");\n  };\n}\n\n// Initial non-memoized recursive Fibonacci function\nfunction fibonacci(n) {\n  if (n <= 1) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// TODO: Apply memoize to fibonacci\n// const memoizedFibonacci = memoize(fibonacci);\n\n// console.log(\"Fib(10) (first call):\", memoizedFibonacci(10));\n// console.log(\"Fib(10) (second call):\", memoizedFibonacci(10));\n// console.log(\"Fib(5) (first call):\", memoizedFibonacci(5));\n",
          "solutionCode": "function memoize(fn) {\n  const cache = {};\n  return function(arg) {\n    // Use a simple string conversion for primitive arguments as key\n    const key = String(arg);\n\n    if (cache.hasOwnProperty(key)) {\n      console.log(`Fetching fib(${arg}) from cache`);\n      return cache[key];\n    }\n\n    console.log(`Calculating fib(${arg})`);\n    // Note: 'this' context is not critical for standalone fibonacci function,\n    // but for completeness in a generic memoize, fn.apply(this, [arg]) could be used.\n    const result = fn(arg);\n    cache[key] = result;\n    return result;\n  };\n}\n\n// Initial non-memoized recursive Fibonacci function\nfunction fibonacci(n) {\n  // console.log(`Calculating F(${n})`); // Uncomment to see many calls without memoization\n  if (n <= 1) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Apply memoize to fibonacci\nconst memoizedFibonacci = memoize(fibonacci);\n\nconsole.log(\"Calculating Fibonacci sequence with memoization:\");\nconsole.log(\"Fib(10) (first call):\", memoizedFibonacci(10)); // Should calculate all sub-problems once\nconsole.log(\"Fib(10) (second call):\", memoizedFibonacci(10)); // Should fetch from cache\nconsole.log(\"Fib(5) (first call):\", memoizedFibonacci(5));   // Should calculate, some sub-problems might be from prior F(10) calculation\nconsole.log(\"Fib(8) (first call):\", memoizedFibonacci(8));   // Should calculate, leveraging existing cached values\nconsole.log(\"Fib(5) (second call):\", memoizedFibonacci(5));  // Should fetch from cache\n\n// Demonstrating difference without memoization (will be slow for large N)\n// console.log(\"\\nCalculating Fibonacci sequence without memoization:\");\n// const startTime = Date.now();\n// console.log(\"Fib(35) (non-memoized):\", fibonacci(35)); // This will be very slow\n// console.log(\"Time taken (non-memoized):\", Date.now() - startTime, \"ms\");\n\n// const memoizedStartTime = Date.now();\n// console.log(\"Fib(35) (memoized):\", memoizedFibonacci(35)); // This will be fast\n// console.log(\"Fib(35) (memoized, again):\", memoizedFibonacci(35)); // This will be instantaneous\n// console.log(\"Time taken (memoized):\", Date.now() - memoizedStartTime, \"ms\");\n",
          "testCases": [
            "`memoizedFibonacci(0)` should return 0 (calculated).",
            "`memoizedFibonacci(1)` should return 1 (calculated).",
            "`memoizedFibonacci(5)` should return 5 (calculated).",
            "`memoizedFibonacci(10)` should return 55 (calculated).",
            "Subsequent call to `memoizedFibonacci(10)` should log 'Fetching fib(10) from cache' and return 55 without recalculation.",
            "`memoizedFibonacci(5)` after `memoizedFibonacci(10)` should still calculate for `fib(5)` initially, but leverage any already computed `fib(0), fib(1), fib(2), fib(3), fib(4)` from the `fib(10)` calculation.",
            "Performance for `memoizedFibonacci(35)` should be significantly faster on subsequent calls compared to the first call, and dramatically faster than a non-memoized `fibonacci(35)`."
          ],
          "hints": [
            "The `memoize` function will need a way to store results associated with inputs. A plain JavaScript object can work if keys are simple strings, or a `Map` for more complex keys.",
            "For a simple `fibonacci(n)`, `String(n)` is a sufficient key. For functions with multiple or complex arguments, `JSON.stringify(args)` or a more sophisticated hashing might be needed.",
            "Remember to ensure the original function `fn` is called correctly, passing its arguments and potentially preserving its `this` context (though for `fibonacci` it's not strictly necessary)."
          ],
          "tags": [
            "memoization",
            "recursion",
            "dynamic_programming",
            "higher-order_functions",
            "performance"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "closures",
            "recursion",
            "objects_maps"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "pure_functions",
            "caching",
            "time_complexity"
          ]
        },
        {
          "id": "task_generator_1",
          "title": "Build a Simple Pagination Generator",
          "description": "\nYour task is to create a generator function that simulates pagination for a large dataset. The generator should yield 'pages' of items from an input array, given a specified page size. This is useful for fetching data in chunks without loading the entire dataset into memory.\n\n**Requirements:**\n1.  Create a generator function `paginate(items, pageSize)`.\n2.  `items` will be an array of any type of data.\n3.  `pageSize` will be a positive integer specifying the number of items per page.\n4.  The generator should `yield` an array for each page. The last page might contain fewer items than `pageSize`.\n5.  If `items` is empty, or `pageSize` is invalid (e.g., non-positive), the generator should handle it gracefully (e.g., yield nothing or throw an error).\n\n**Example Usage:**\n```javascript\nconst data = Array.from({ length: 10 }, (_, i) => `Item ${i + 1}`);\nconst paginator = paginate(data, 3);\n\nconsole.log(paginator.next().value); // ['Item 1', 'Item 2', 'Item 3']\nconsole.log(paginator.next().value); // ['Item 4', 'Item 5', 'Item 6']\nconsole.log(paginator.next().value); // ['Item 7', 'Item 8', 'Item 9']\nconsole.log(paginator.next().value); // ['Item 10']\nconsole.log(paginator.next().done);  // true\n```\n",
          "difficulty": "medium",
          "startingCode": "function* paginate(items, pageSize) {\n  if (!Array.isArray(items) || pageSize <= 0) {\n    // TODO: Handle invalid input\n    return;\n  }\n\n  // TODO: Implement pagination logic using yield\n  // let startIndex = 0;\n  // while (startIndex < items.length) {\n  //   const page = items.slice(startIndex, startIndex + pageSize);\n  //   yield page;\n  //   startIndex += pageSize;\n  // }\n}\n\n// Example Usage:\n// const data = Array.from({ length: 10 }, (_, i) => `Item ${i + 1}`);\n// const paginator = paginate(data, 3);\n// console.log(paginator.next().value);\n// console.log(paginator.next().value);\n// console.log(paginator.next().value);\n// console.log(paginator.next().value);\n// console.log(paginator.next().done);\n",
          "solutionCode": "function* paginate(items, pageSize) {\n  if (!Array.isArray(items)) {\n    throw new Error('Input items must be an array.');\n  }\n  if (pageSize <= 0) {\n    throw new Error('Page size must be a positive integer.');\n  }\n  if (items.length === 0) {\n    return; // Yield nothing for empty array\n  }\n\n  let startIndex = 0;\n  while (startIndex < items.length) {\n    const page = items.slice(startIndex, startIndex + pageSize);\n    yield page;\n    startIndex += pageSize;\n  }\n}\n\n// Example Usage:\nconsole.log('--- Pagination Test 1 (Basic) ---');\nconst data1 = Array.from({ length: 10 }, (_, i) => `Item ${i + 1}`);\nconst paginator1 = paginate(data1, 3);\nconsole.log(paginator1.next().value); // ['Item 1', 'Item 2', 'Item 3']\nconsole.log(paginator1.next().value); // ['Item 4', 'Item 5', 'Item 6']\nconsole.log(paginator1.next().value); // ['Item 7', 'Item 8', 'Item 9']\nconsole.log(paginator1.next().value); // ['Item 10']\nconsole.log(paginator1.next().done);  // true\n\nconsole.log('\\n--- Pagination Test 2 (Exact Fit) ---');\nconst data2 = [1, 2, 3, 4, 5, 6];\nconst paginator2 = paginate(data2, 2);\nconsole.log(paginator2.next().value); // [1, 2]\nconsole.log(paginator2.next().value); // [3, 4]\nconsole.log(paginator2.next().value); // [5, 6]\nconsole.log(paginator2.next().done);  // true\n\nconsole.log('\\n--- Pagination Test 3 (Single Page) ---');\nconst data3 = ['A', 'B'];\nconst paginator3 = paginate(data3, 5);\nconsole.log(paginator3.next().value); // ['A', 'B']\nconsole.log(paginator3.next().done);  // true\n\nconsole.log('\\n--- Pagination Test 4 (Empty Array) ---');\nconst data4 = [];\nconst paginator4 = paginate(data4, 3);\nconsole.log(paginator4.next().value); // undefined\nconsole.log(paginator4.next().done);  // true\n\nconsole.log('\\n--- Pagination Test 5 (Invalid PageSize) ---');\ntry {\n  const paginator5 = paginate(data1, 0);\n  paginator5.next();\n} catch (e) {\n  console.error(e.message); // Page size must be a positive integer.\n}\n\nconsole.log('\\n--- Pagination Test 6 (Invalid Items) ---');\ntry {\n  const paginator6 = paginate(null, 5);\n  paginator6.next();\n} catch (e) {\n  console.error(e.message); // Input items must be an array.\n}\n",
          "testCases": [
            "Test with `paginate([1,2,3,4,5], 2)`: Should yield `[1,2]`, then `[3,4]`, then `[5]`.",
            "Test with `paginate(['a','b','c'], 1)`: Should yield `['a']`, then `['b']`, then `['c']`.",
            "Test with `paginate([], 5)`: Should yield nothing, `done` should be `true` on first `next()`.",
            "Test with `paginate([1,2,3], 3)`: Should yield `[1,2,3]` then `done` true.",
            "Test with `paginate([1,2,3], 0)`: Should throw an error for invalid page size.",
            "Test with `paginate(null, 5)`: Should throw an error for invalid items type.",
            "Test with large array (e.g., 1000 items, page size 100) to ensure efficiency (though not strictly measurable in this setup, concept applies)."
          ],
          "hints": [
            "Use a `while` loop to continue yielding pages as long as there are items left.",
            "The `Array.prototype.slice()` method is useful for extracting portions of an array.",
            "Remember to increment your starting index after each `yield` to move to the next page.",
            "Consider edge cases like an empty input array or a `pageSize` larger than the total number of items."
          ],
          "tags": [
            "generators",
            "iteration",
            "pagination",
            "arrays",
            "lazy_evaluation"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "arrays",
            "loops",
            "basic_error_handling"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "iterators",
            "data_streaming",
            "memory_optimization"
          ]
        },
        {
          "id": "task_async_1",
          "title": "Fetch and Aggregate Data from Multiple APIs with `async/await`",
          "description": "\nYour task is to write an `async` function that fetches data from multiple simulated API endpoints concurrently and then aggregates the results. You need to handle potential errors from individual API calls gracefully.\n\n**Requirements:**\n1.  Create two mock asynchronous functions, `fetchProducts(category)` and `fetchReviews(productId)`.\n    *   `fetchProducts` should return a Promise that resolves with an array of product objects or rejects with an error.\n    *   `fetchReviews` should return a Promise that resolves with an array of review objects for a given product ID or rejects with an error.\n    *   Introduce artificial delays and potential failures for realism.\n2.  Implement an `async` function `getProductsWithReviews(category)`.\n    *   This function should first call `fetchProducts(category)`.\n    *   For each product fetched, it should then call `fetchReviews(productId)` to get its reviews.\n    *   Crucially, the `fetchReviews` calls for different products should happen **in parallel**.\n    *   Aggregate the results such that each product object includes a `reviews` array.\n3.  Implement robust error handling: If `fetchProducts` fails, `getProductsWithReviews` should catch and log the error and return an empty array or throw. If individual `fetchReviews` calls fail, they should not stop the entire process; instead, the corresponding product should simply have an empty `reviews` array or an `error` property indicating the failure.\n\n**Output Structure Example:**\n```json\n[\n  {\n    \"id\": \"p1\",\n    \"name\": \"Laptop\",\n    \"reviews\": [\n      { \"id\": \"r1\", \"text\": \"Great laptop\" },\n      { \"id\": \"r2\", \"text\": \"Fast shipping\" }\n    ]\n  },\n  {\n    \"id\": \"p2\",\n    \"name\": \"Mouse\",\n    \"reviews\": [] // If reviews fetch failed or no reviews\n  }\n]\n```\n",
          "difficulty": "hard",
          "startingCode": "async function fetchProducts(category) {\n  console.log(`Fetching products for category: ${category}...`);\n  return new Promise(resolve => {\n    setTimeout(() => {\n      if (category === 'electronics') {\n        resolve([\n          { id: 'p1', name: 'Laptop', price: 1200 },\n          { id: 'p2', name: 'Mouse', price: 25 }\n        ]);\n      } else if (category === 'books') {\n        resolve([\n          { id: 'b1', name: 'The Great Gatsby', price: 15 }\n        ]);\n      } else if (category === 'fail') {\n        throw new Error('Failed to fetch products for category: fail'); // This will reject the promise\n      } else {\n        resolve([]);\n      }\n    }, 500);\n  });\n}\n\nasync function fetchReviews(productId) {\n  console.log(`Fetching reviews for product: ${productId}...`);\n  return new Promise((resolve, reject) => {\n    const delay = Math.random() * 500 + 200; // Random delay between 200-700ms\n    setTimeout(() => {\n      if (productId === 'p1') {\n        resolve([\n          { id: 'r1', text: 'Great laptop' },\n          { id: 'r2', text: 'Fast shipping' }\n        ]);\n      } else if (productId === 'p2') {\n        // Simulate a failure for a specific product's reviews\n        reject(new Error(`Failed to fetch reviews for ${productId}`));\n      } else if (productId === 'b1') {\n        resolve([]); // No reviews for books\n      } else {\n        resolve([]);\n      }\n    }, delay);\n  });\n}\n\nasync function getProductsWithReviews(category) {\n  // TODO: Implement the logic here\n  // 1. Fetch products\n  // 2. For each product, initiate parallel review fetches\n  // 3. Handle errors gracefully for both product and review fetches\n  // 4. Aggregate results\n  console.log(`Starting aggregation for category: ${category}`);\n  try {\n    const products = await fetchProducts(category);\n    \n    // TODO: Map products to promises for reviews, then use Promise.allSettled\n    // or Promise.all with individual catches\n\n    // Placeholder return\n    return products;\n\n  } catch (error) {\n    console.error(`Error in getProductsWithReviews for category '${category}':`, error.message);\n    // TODO: Return empty array or re-throw, based on requirement\n    return [];\n  }\n}\n\n// Example Usage:\n// (async () => {\n//   console.log('\\n--- Electronics Category ---');\n//   const electronicsData = await getProductsWithReviews('electronics');\n//   console.log('Electronics Data:', JSON.stringify(electronicsData, null, 2));\n\n//   console.log('\\n--- Books Category ---');\n//   const booksData = await getProductsWithReviews('books');\n//   console.log('Books Data:', JSON.stringify(booksData, null, 2));\n\n//   console.log('\\n--- Fail Category (Product Fetch) ---');\n//   const failData = await getProductsWithReviews('fail'); // This should cause an error\n//   console.log('Fail Data:', JSON.stringify(failData, null, 2));\n\n//   console.log('\\n--- Unknown Category ---');\n//   const unknownData = await getProductsWithReviews('unknown');\n//   console.log('Unknown Data:', JSON.stringify(unknownData, null, 2));\n// })();\n",
          "solutionCode": "async function fetchProducts(category) {\n  console.log(`Fetching products for category: ${category}...`);\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (category === 'electronics') {\n        resolve([\n          { id: 'p1', name: 'Laptop', price: 1200 },\n          { id: 'p2', name: 'Mouse', price: 25 },\n          { id: 'p3', name: 'Keyboard', price: 75 }\n        ]);\n      } else if (category === 'books') {\n        resolve([\n          { id: 'b1', name: 'The Great Gatsby', price: 15 }\n        ]);\n      } else if (category === 'fail-products') {\n        reject(new Error('Simulated network error fetching products.'));\n      } else {\n        resolve([]); // Empty array for unknown categories\n      }\n    }, 500);\n  });\n}\n\nasync function fetchReviews(productId) {\n  console.log(`Fetching reviews for product: ${productId}...`);\n  return new Promise((resolve, reject) => {\n    const delay = Math.random() * 300 + 100; // Random delay between 100-400ms\n    setTimeout(() => {\n      if (productId === 'p1') {\n        resolve([\n          { id: 'r1', text: 'Great laptop' },\n          { id: 'r2', text: 'Fast shipping' }\n        ]);\n      } else if (productId === 'p2') {\n        // Simulate a failure for a specific product's reviews\n        reject(new Error(`Simulated error fetching reviews for ${productId}`));\n      } else if (productId === 'b1') {\n        resolve([]); // No reviews for books\n      } else if (productId === 'p3') {\n         resolve([{ id: 'r3', text: 'Nice keyboard' }]);\n      } else {\n        resolve([]); // No reviews for other products\n      }\n    }, delay);\n  });\n}\n\nasync function getProductsWithReviews(category) {\n  console.log(`\\n--- Starting aggregation for category: ${category} ---`);\n  let products = [];\n  try {\n    products = await fetchProducts(category);\n  } catch (error) {\n    console.error(`ERROR: Failed to fetch products for category '${category}':`, error.message);\n    return []; // If products fetch fails, return empty array\n  }\n\n  // If no products, no need to fetch reviews\n  if (products.length === 0) {\n    console.log(`No products found for category: ${category}. Returning empty.`);\n    return [];\n  }\n\n  // Map each product to a promise for its reviews\n  // Use .then().catch() on individual promises to prevent Promise.all from failing fast\n  const reviewPromises = products.map(async product => {\n    try {\n      const reviews = await fetchReviews(product.id);\n      return { ...product, reviews };\n    } catch (error) {\n      console.error(`WARNING: Failed to fetch reviews for product ${product.id}:`, error.message);\n      // If review fetch fails, include product but with empty reviews array and an error flag\n      return { ...product, reviews: [], reviewError: error.message }; \n    }\n  });\n\n  // Await all review promises concurrently\n  // Promise.all is used here because individual errors are caught and handled already\n  const productsWithReviews = await Promise.all(reviewPromises);\n\n  console.log(`--- Finished aggregation for category: ${category} ---`);\n  return productsWithReviews;\n}\n\n// Example Usage:\n(async () => {\n  const electronicsData = await getProductsWithReviews('electronics');\n  console.log('Result (Electronics):', JSON.stringify(electronicsData, null, 2));\n\n  const booksData = await getProductsWithReviews('books');\n  console.log('Result (Books):', JSON.stringify(booksData, null, 2));\n\n  const failProductData = await getProductsWithReviews('fail-products');\n  console.log('Result (Failed Product Fetch):', JSON.stringify(failProductData, null, 2));\n\n  const unknownCategoryData = await getProductsWithReviews('unknown-category');\n  console.log('Result (Unknown Category):', JSON.stringify(unknownCategoryData, null, 2));\n\n  // To demonstrate a review fetch failure for a product whose category fetch succeeded:\n  // 'p2' (Mouse) reviews are set to fail in fetchReviews mock.\n  const electronicsWithErrorReviews = await getProductsWithReviews('electronics');\n  console.log('Result (Electronics with Review Errors):', JSON.stringify(electronicsWithErrorReviews, null, 2));\n})();\n",
          "testCases": [
            "Call `getProductsWithReviews('electronics')`: Should return products with reviews for 'p1' and 'p3', and 'p2' should have an empty 'reviews' array due to its simulated failure, along with a `reviewError` property.",
            "Call `getProductsWithReviews('books')`: Should return product 'b1' with an empty 'reviews' array.",
            "Call `getProductsWithReviews('fail-products')`: Should log an error for products fetch and return an empty array.",
            "Call `getProductsWithReviews('nonexistent-category')`: Should return an empty array after `fetchProducts` resolves with an empty array.",
            "Verify all review fetches for successful products (e.g., 'p1', 'p3') happen concurrently (output order might not confirm this, but `Promise.all` ensures it)."
          ],
          "hints": [
            "For concurrent fetching of reviews for multiple products, `Promise.all` is the go-to method. Remember that `Promise.all` fails fast (rejects immediately if any of its input promises reject).",
            "To prevent `Promise.all` from failing the entire process if an individual review fetch fails, you'll need to wrap each `fetchReviews` call in its own `try...catch` block (or append `.catch()` to the Promise) *before* passing it to `Promise.all`. This way, the inner `catch` handles the error, and the promise passed to `Promise.all` always resolves (e.g., with an object indicating success/failure or with empty reviews).",
            "Structure your `async` function with a top-level `try...catch` for the initial `fetchProducts` call.",
            "Consider using `Array.prototype.map` to transform your products array into an array of Promises for reviews."
          ],
          "tags": [
            "async_await",
            "promises",
            "API_integration",
            "error_handling",
            "concurrency",
            "frontend"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "promises",
            "async_await",
            "array_methods",
            "error_handling"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Promise.all",
            "Promise.allSettled",
            "network_requests",
            "data_aggregation"
          ]
        },
        {
          "id": "task_arrow_regular_1",
          "title": "Refactor a Class with `setInterval` to Use Arrow Functions for Correct `this` Binding",
          "description": "\nYour task is to refactor a JavaScript class that uses `setInterval` to update its internal state, addressing a common `this` binding issue. The original code uses a regular function for the `setInterval` callback, leading to incorrect `this` context. You need to fix this using arrow functions.\n\n**Requirements:**\n1.  Take the provided `Counter` class with a `start` method that uses `setInterval`.\n2.  Modify the `setInterval` callback function within the `start` method to be an **arrow function**.\n3.  Ensure that `this.count` is correctly incremented and `this.display()` is correctly called, referring to the `Counter` instance.\n4.  Add a `stop` method to clear the interval.\n5.  Demonstrate the corrected behavior by creating an instance of the class and observing the console output.\n",
          "difficulty": "medium",
          "startingCode": "class Counter {\n  constructor(initialCount = 0) {\n    this.count = initialCount;\n    this.intervalId = null;\n  }\n\n  display() {\n    console.log(`Current count: ${this.count}`);\n  }\n\n  start() {\n    console.log('Starting counter...');\n    this.intervalId = setInterval(function() {\n      // Problem: 'this' here refers to the global object (window) or is undefined in strict mode,\n      // NOT the Counter instance.\n      this.count++; \n      this.display(); // Will cause error or try to call method on global object\n    }, 1000);\n  }\n\n  stop() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      console.log('Counter stopped.');\n      this.intervalId = null;\n    }\n  }\n}\n\n// Example Usage (will fail as is):\n// const myCounter = new Counter();\n// myCounter.start();\n// setTimeout(() => myCounter.stop(), 5500);\n",
          "solutionCode": "class Counter {\n  constructor(initialCount = 0) {\n    this.count = initialCount;\n    this.intervalId = null;\n  }\n\n  display() {\n    console.log(`Current count: ${this.count}`);\n  }\n\n  start() {\n    console.log('Starting counter...');\n    // Fix: Use an arrow function for the setInterval callback.\n    // The arrow function lexically binds 'this' from the 'start' method's scope,\n    // which correctly refers to the Counter instance.\n    this.intervalId = setInterval(() => {\n      this.count++; \n      this.display(); \n    }, 1000);\n  }\n\n  stop() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      console.log('Counter stopped.');\n      this.intervalId = null;\n    }\n  }\n}\n\n// Example Usage:\nconsole.log('Creating and starting Counter 1...');\nconst myCounter1 = new Counter();\nmyCounter1.start();\n// Stop after 5.5 seconds to observe multiple increments\nsetTimeout(() => myCounter1.stop(), 5500);\n\nconsole.log('\\nCreating and starting Counter 2...');\nconst myCounter2 = new Counter(100);\nmyCounter2.start();\n// Stop after 3.5 seconds\nsetTimeout(() => myCounter2.stop(), 3500);\n",
          "testCases": [
            "Create a `Counter` instance and call `start()`. Observe that `Current count:` logs increment correctly (e.g., 0, 1, 2, ...).",
            "Verify that `display()` method is called successfully, indicating `this` is correctly bound to the instance.",
            "Call `stop()` after some time and ensure the counter stops, and no more logs appear.",
            "Create multiple `Counter` instances and verify they run independently without interfering with each other's `this` context."
          ],
          "hints": [
            "Recall how arrow functions handle `this` binding compared to regular functions. Which `this` do they inherit?",
            "The problem lies specifically within the `setInterval` callback. The `this` outside that callback (in the `start` method) is already correct.",
            "Consider what `this` would be if the `setInterval` callback were a regular function and how that differs from what `this` refers to when it's an arrow function."
          ],
          "tags": [
            "arrow_functions",
            "this_binding",
            "classes",
            "timers",
            "frontend"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "classes_ES6",
            "this_keyword",
            "setinterval_clearinterval"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "closures",
            "event_handling",
            "object_oriented_programming"
          ]
        }
      ]
    }
  },
  {
    "id": "b759b889-bdef-436c-8e39-9fcae28ac9b8",
    "startLine": 800,
    "endLine": 899,
    "processedDate": "2025-06-17T07:24:38.770Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_this_context_es5",
          "title": "Managing 'this' Context in ES5",
          "content": "In JavaScript, the `this` keyword refers to the context in which a function is executed. Its value is determined dynamically by how the function is called, rather than where it is declared. This dynamic behavior can often lead to confusion, especially in asynchronous callbacks or event handlers where the execution context might differ from the expected context.\n\n### Challenges with `this` in ES5\nWhen a function is used as a callback, particularly with `setInterval` or `setTimeout`, or as an event handler, its `this` context often defaults to the global object (e.g., `window` in browsers, or `undefined` in strict mode), rather than the object that owns the method. This happens because the callback function is invoked directly by the `setInterval` (or event listener) mechanism, not as a method of your object.\n\n### Solutions for Maintaining `this` Context in ES5\nTo overcome this, ES5 offers several patterns to explicitly control or preserve the `this` context.\n\n1.  **Using a 'that' / 'self' Variable (Closure)**:\n    This common pattern involves saving a reference to the desired `this` context in a variable (commonly named `that` or `self`) outside the callback function, but within the scope of the method where `this` is correct. The callback function, being a closure, then captures and retains access to this `that` variable, allowing it to correctly reference the object's properties.\n\n2.  **Using `Function.prototype.bind()`**:\n    The `bind()` method creates a new function that, when called, has its `this` keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called. It returns a *new function* with the `this` context permanently bound. This is particularly useful when you need to pass a method as a callback and ensure it always operates on a specific object instance.",
          "examples": [
            {
              "id": "example_this_es5_that_self",
              "title": "Solution 1: Using a 'that' / 'self' variable",
              "code": "function Person() {\n  var that = this; // 'this' here refers to the new Person instance\n  that.age = 0;\n  \n  setInterval(function growUp() {\n    // Inside growUp, 'this' would normally be the global object (window) or undefined (strict mode)\n    // But 'that' correctly references the Person instance due to closure\n    that.age++;\n    console.log(`Person's age (via that): ${that.age}`);\n  }, 1000);\n}\n\n// var p1 = new Person(); // Uncomment to see it in action",
              "explanation": "In this example, `var that = this;` captures the `this` context of the `Person` constructor (which is the newly created `Person` instance) into the `that` variable. The `growUp` function, being a closure, maintains access to `that`, allowing it to correctly increment the `age` property of the `Person` instance, even though `growUp` itself is called without a specific `this` context (i.e., by `setInterval`).",
              "language": "javascript"
            },
            {
              "id": "example_this_es5_bind",
              "title": "Solution 2: Using Function.prototype.bind()",
              "code": "function Person() {\n  this.age = 0;\n  \n  // setInterval expects a function. We use .bind(this) to create a new function\n  // where 'this' is permanently bound to the current Person instance.\n  setInterval(function growUp() {\n    // Inside growUp, 'this' now correctly refers to the Person instance\n    this.age++;\n    console.log(`Person's age (via bind): ${this.age}`);\n  }.bind(this), 1000); // 'this' here refers to the Person instance\n}\n\n// var p2 = new Person(); // Uncomment to see it in action",
              "explanation": "Here, `bind(this)` is called on the `growUp` function. The `this` passed to `bind` (which is the `Person` instance in this context) becomes the permanent `this` for the `growUp` function when it's eventually called by `setInterval`. This creates a new function that `setInterval` uses, ensuring `this.age++` correctly modifies the `age` of the `Person` instance.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_this_es5_1",
            "question_this_es5_2",
            "question_this_es5_3",
            "question_this_es5_4"
          ],
          "relatedTasks": [
            "task_this_context_timer"
          ],
          "tags": [
            "javascript",
            "this",
            "context",
            "es5",
            "bind",
            "closure",
            "scope",
            "function-prototype"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "javascript_scope"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "theory_this_context_es6"
          ]
        },
        {
          "id": "theory_this_context_es6_arrow",
          "title": "Lexical 'this' with ES6 Arrow Functions",
          "content": "ES6 introduced arrow functions, a new syntax for writing functions that comes with a significant difference in how they handle the `this` keyword. Unlike traditional `function` expressions, arrow functions do not create their own `this` context. Instead, they inherit `this` from their parent (enclosing) scope at the time they are defined.\n\n### Lexical `this`\nThis behavior is known as 'lexical `this` binding'. It means that an arrow function's `this` is bound to the `this` of the code where the arrow function is *defined*, not where it is *called*. This makes them particularly useful for callbacks and event handlers where maintaining the `this` context of the surrounding object is important, as it eliminates the need for `var that = this;` or `.bind(this)`.\n\n### Advantages\n*   **Readability**: Simplifies code by removing explicit `this` binding workarounds.\n*   **Predictability**: `this` behaves more intuitively, always referring to the `this` of the lexical parent.\n*   **Conciseness**: Shorter syntax for functions.",
          "examples": [
            {
              "id": "example_this_es6_arrow",
              "title": "Arrow Function Solution for 'this' Context",
              "code": "// Arrow functions don't create their own 'this' context\nfunction Person() {\n  this.age = 0; // 'this' here refers to the new Person instance\n  \n  setInterval(() => {\n    // 'this' inside the arrow function lexically inherits 'this' from the Person constructor scope.\n    // Therefore, 'this' correctly refers to the Person instance.\n    this.age++; \n    console.log(`Person's age (via arrow function): ${this.age}`);\n  }, 1000);\n}\n\n// var p3 = new Person(); // Uncomment to see it in action",
              "explanation": "In this example, the `setInterval` callback is an arrow function. The `this` inside the arrow function automatically refers to the `this` of the `Person` constructor function (the `Person` instance), because that's its lexical parent. This eliminates the need for `.bind(this)` or `var that = this;`, leading to cleaner and more intuitive code for `this` context management in callbacks.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_this_es6_1",
            "question_this_es6_2",
            "question_this_es6_3"
          ],
          "relatedTasks": [
            "task_this_context_timer"
          ],
          "tags": [
            "javascript",
            "this",
            "context",
            "es6",
            "arrow-functions",
            "lexical-scope",
            "callbacks"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "theory_this_context_es5"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_component_this",
            "event_handlers"
          ]
        },
        {
          "id": "theory_function_chaining",
          "title": "Function Chaining (Method Chaining)",
          "content": "Function chaining, also known as method chaining, is a programming technique that allows multiple methods to be called sequentially on the same object in a single statement. This is achieved by having each method return the object itself (`this`), enabling the next method in the chain to be called immediately.\n\n### Benefits of Function Chaining:\n*   **Readability**: Code becomes more concise and flows like a natural sentence, making it easier to read and understand.\n*   **Conciseness**: Reduces the need for intermediate variables.\n*   **Fluent Interface**: Creates a 'fluent' API, which is often seen in libraries like jQuery, D3.js, and modern JavaScript frameworks (e.g., in building DOM elements or promises).\n\n### Implementation:\nTo implement method chaining, each method that is part of the chain must return `this` (the current instance of the object) after performing its operation. Methods that are intended to retrieve a value (like `toString()` in the example) will typically break the chain by returning the value instead of `this`.",
          "examples": [
            {
              "id": "example_function_chaining_stringbuilder",
              "title": "StringBuilder with Method Chaining",
              "code": "class StringBuilder {\n  constructor(str = \"\") {\n    this.str = str;\n  }\n  \n  // append returns 'this' to allow chaining\n  append(s) {\n    this.str += s;\n    return this;\n  }\n  \n  // toString breaks the chain by returning the final string\n  toString() {\n    return this.str;\n  }\n}\n\nconst message = new StringBuilder().append(\"Hello\").append(\" \").append(\"World!\").toString();\nconsole.log(message); // \"Hello World!\"\n",
              "explanation": "In this `StringBuilder` class, the `append` method modifies the internal `str` property and then crucially returns `this`. This allows calls to `append` to be chained one after another on the same `StringBuilder` instance. The `toString` method then retrieves the final string, breaking the chain. This demonstrates a common pattern for building fluent APIs.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_chaining_1",
            "question_chaining_2",
            "question_chaining_3"
          ],
          "relatedTasks": [
            "task_chainable_calculator"
          ],
          "tags": [
            "javascript",
            "design-patterns",
            "method-chaining",
            "fluent-api",
            "classes",
            "oop"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_objects",
            "javascript_classes",
            "this"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "api_design",
            "library_development"
          ]
        },
        {
          "id": "theory_higher_order_functions",
          "title": "Higher-Order Functions (HOF)",
          "content": "Higher-Order Functions (HOFs) are a cornerstone of functional programming in JavaScript. A function is considered higher-order if it does at least one of the following:\n\n1.  **Takes one or more functions as arguments.** (e.g., `Array.prototype.map`, `setTimeout`)\n2.  **Returns a function as its result.** (e.g., a function factory, `Function.prototype.bind`)\n\nHOFs enable powerful abstractions, code reuse, and cleaner, more declarative code. They treat functions as 'first-class citizens', meaning functions can be assigned to variables, passed as arguments, and returned from other functions just like any other data type (numbers, strings, objects).\n\n### Common Use Cases:\n*   **Callbacks**: Functions executed after some operation completes (e.g., event handlers, asynchronous operations).\n*   **Decorators/Wrappers**: Functions that add behavior to other functions.\n*   **Currying/Partial Application**: Transforming a function that takes multiple arguments into a sequence of functions, each taking a single argument.\n*   **Composition**: Combining simple functions to build more complex ones.",
          "examples": [
            {
              "id": "example_hof_pluckdeep",
              "title": "Higher-Order Function: `pluckDeep`",
              "code": "const pluckDeep = key => obj => {\n  // `key.split('.')` splits the string 'a.b.c' into ['a', 'b', 'c']\n  // `reduce` then iteratively accesses the nested properties\n  return key.split('.').reduce((accum, currentKey) => {\n    // Ensure accum is not null/undefined before accessing its property\n    return (accum && typeof accum === 'object' && accum.hasOwnProperty(currentKey)) ? accum[currentKey] : undefined;\n  }, obj);\n}\n\nconst user = { \n  id: 1, \n  profile: { \n    name: 'Alice', \n    address: { \n      street: '123 Main St' \n    }\n  }\n};\n\nconst getStreet = pluckDeep('profile.address.street');\nconsole.log(getStreet(user)); // '123 Main St'\n\nconst getName = pluckDeep('profile.name');\nconsole.log(getName(user)); // 'Alice'\n\nconst getNonExistent = pluckDeep('profile.address.city');\nconsole.log(getNonExistent(user)); // undefined",
              "explanation": "`pluckDeep` is a higher-order function because it takes `key` and returns *another function* (`obj => ...`). The returned function then takes an `obj` and uses `reduce` to safely navigate through nested properties specified by the `key` string (e.g., 'profile.address.street'). This allows creating specialized data accessors like `getStreet` or `getName` for reuse.",
              "language": "javascript"
            },
            {
              "id": "example_hof_compose",
              "title": "Higher-Order Function: `compose`",
              "code": "const compose = (...fns) => res => {\n  // `reduce` processes functions from right-to-left\n  // `reduceRight` would achieve left-to-right if preferred for pipelines\n  return fns.reduce((accum, nextFn) => nextFn(accum), res);\n}\n\nconst add5 = x => x + 5;\nconst multiplyBy2 = x => x * 2;\nconst subtract3 = x => x - 3;\n\n// Applying functions sequentially from left to right: subtract3(multiplyBy2(add5(initialValue)))\nconst operate = compose(add5, multiplyBy2, subtract3);\n\n// If initialValue = 10:\n// 1. add5(10) -> 15\n// 2. multiplyBy2(15) -> 30\n// 3. subtract3(30) -> 27\nconsole.log(operate(10)); // 27\n\nconst toUpperCase = str => str.toUpperCase();\nconst addExclamation = str => str + '!';\nconst reverseString = str => str.split('').reverse().join('');\n\nconst transformText = compose(reverseString, toUpperCase, addExclamation);\n// If initialValue = 'hello':\n// 1. reverseString('hello') -> 'olleh'\n// 2. toUpperCase('olleh') -> 'OLLEH'\n// 3. addExclamation('OLLEH') -> 'OLLEH!'\nconsole.log(transformText('hello')); // 'OLLEH!'",
              "explanation": "`compose` is a higher-order function because it takes an arbitrary number of functions (`...fns`) as arguments and returns a *single new function*. This new function then takes an initial `res` and applies each of the composed functions to it in a sequence. The `reduce` method iterates through the functions, applying each one to the result of the previous, effectively 'pipelining' the data through a series of transformations. This pattern is fundamental in functional programming for building complex operations from simpler, reusable functions.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_hof_1",
            "question_hof_2",
            "question_hof_3",
            "question_hof_4"
          ],
          "relatedTasks": [
            "task_hof_data_transformer",
            "task_hof_event_emitter"
          ],
          "tags": [
            "javascript",
            "functional-programming",
            "hof",
            "callbacks",
            "currying",
            "compose",
            "reduce",
            "first-class-functions"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "array_methods",
            "closures"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "redux_middleware",
            "react_hooks_patterns",
            "data_transformation"
          ]
        },
        {
          "id": "theory_oop_intro",
          "title": "Introduction to Object-Oriented Programming (OOP) in JavaScript",
          "content": "Object-Oriented Programming (OOP) is a programming paradigm that organizes software design around 'objects' rather than functions and logic. An object is a self-contained unit that bundles data (attributes/properties) and the methods (functions/behaviors) that operate on that data. This approach aims to make software more modular, flexible, and understandable.\n\nJavaScript, while often described as a multi-paradigm language, supports OOP through various mechanisms. Historically, it used a unique 'prototypal inheritance' model. More recently, with ES6, `class` syntax was introduced, providing a more familiar syntactic sugar over the underlying prototypal inheritance, making OOP patterns more accessible to developers coming from class-based languages like Java or C++.",
          "examples": [],
          "relatedQuestions": [
            "question_oop_intro_1",
            "question_oop_intro_2"
          ],
          "relatedTasks": [],
          "tags": [
            "javascript",
            "oop",
            "paradigm",
            "objects",
            "classes",
            "prototypes"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_basics",
            "data_types_objects"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "requiredFor": [
            "theory_oop_principles",
            "theory_prototypal_inheritance"
          ]
        },
        {
          "id": "theory_oop_principles",
          "title": "Core Principles of Object-Oriented Programming",
          "content": "OOP is typically guided by four fundamental principles, often referred to as the four pillars of OOP. Understanding these principles is crucial for designing robust, maintainable, and scalable software systems.\n\n1.  **Encapsulation**: This principle involves bundling the data (attributes) and methods that operate on that data into a single unit or object. It also implies 'information hiding', where the internal state of an object is protected from direct external access, and access is typically provided only through public methods. This reduces complexity and helps in maintaining data integrity.\n    *   *In JavaScript*: Achieved through closures (for private variables) or ES6 classes with conventions (like prefixing private-like properties with `_`) or actual private class fields (with `#`).\n\n2.  **Inheritance**: Inheritance is a mechanism by which one class or object can acquire the properties and methods of another class or object. It promotes code reuse and establishes a hierarchical relationship between objects (parent/child, base/derived). Derived objects can extend or override the inherited behavior.\n    *   *In JavaScript*: Achieved via prototypal inheritance (ES5) or the `extends` keyword (ES6 classes) which builds upon prototypes.\n\n3.  **Polymorphism**: Meaning 'many forms', polymorphism allows objects of different classes to be treated as objects of a common type. It enables a single interface to represent different underlying forms or types. This often involves defining a common method signature in a base class that derived classes can implement in their own specific ways. When this method is called on an object, the specific implementation depends on the object's actual type.\n    *   *In JavaScript*: Achieved through method overriding in prototypal inheritance or classes, where different objects can respond to the same method call in different ways.\n\n4.  **Abstraction**: Abstraction focuses on hiding the complex implementation details and showing only the essential features of an object. It provides a simplified view of functionality, allowing users to interact with objects at a high level without needing to understand the intricate internal workings. It defines what an object does rather than how it does it.\n    *   *In JavaScript*: Achieved through interfaces (implicitly via duck typing), abstract classes (conceptually, not directly supported), or by simply designing public APIs that hide internal complexity.",
          "examples": [],
          "relatedQuestions": [
            "question_oop_principles_1",
            "question_oop_principles_2",
            "question_oop_principles_3",
            "question_oop_principles_4"
          ],
          "relatedTasks": [],
          "tags": [
            "oop",
            "principles",
            "encapsulation",
            "inheritance",
            "polymorphism",
            "abstraction",
            "javascript"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "theory_oop_intro"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "design_patterns",
            "framework_architecture"
          ]
        },
        {
          "id": "theory_prototypal_inheritance",
          "title": "Prototypal Inheritance in JavaScript",
          "content": "Unlike traditional class-based object-oriented languages (like Java or C++), JavaScript uses a prototypal inheritance model. In JavaScript, objects inherit properties and methods directly from other objects (their prototypes) rather than from classes. Every JavaScript object has an internal slot `[[Prototype]]`, which points to another object, or `null`. This object is called its prototype. When you try to access a property or method on an object, and it's not found directly on the object, JavaScript looks for it in the object's prototype, then in the prototype's prototype, and so on, forming a 'prototype chain'.\n\n### Key Concepts:\n*   **Prototype Chain**: The series of links from an object to its prototype, and that prototype's prototype, up to `null`. This chain is traversed when a property or method is looked up.\n*   **`__proto__`**: A non-standard, but widely implemented, property that references an object's prototype. It's often used for inspection, but `Object.getPrototypeOf()` and `Object.setPrototypeOf()` are the standard ways.\n*   **`prototype` property of Constructors**: Functions in JavaScript have a special `prototype` property. When a function is used as a constructor (with the `new` keyword), the newly created object's `[[Prototype]]` is set to the `prototype` property of the constructor function. This is how methods and properties defined on the constructor's `prototype` become available to all instances created by that constructor.\n*   **`Object.create()`**: Creates a new object with the specified prototype object and properties.\n*   **Constructor Borrowing (`.call()` or `.apply()`)**: To inherit properties defined in the parent's constructor, the child constructor can invoke the parent constructor using `ParentConstructor.call(this, ...args)`. This ensures that properties initialized in the parent constructor are set on the child instance's `this` context.\n\n### How Inheritance Works with Prototypes:\n1.  Define a 'parent' constructor function and add shared methods/properties to its `prototype` property.\n2.  Define a 'child' constructor function.\n3.  Inside the child constructor, 'borrow' the parent constructor using `Parent.call(this, ...args)` to initialize parent-specific properties on the child instance.\n4.  Set the child's `prototype` to an object that inherits from the parent's `prototype`. The common way is `Child.prototype = Object.create(Parent.prototype);`.\n5.  Crucially, reset the `constructor` property on the child's prototype: `Child.prototype.constructor = Child;` (because `Object.create` will set `constructor` to `Parent`). This ensures `instanceof` and `constructor` checks work correctly.\n6.  Add specific methods/properties for the child to its `prototype`.",
          "examples": [
            {
              "id": "example_prototypal_inheritance_basic",
              "title": "Basic Prototypal Inheritance with Constructor Functions",
              "code": "// Parent constructor function\nvar Person = function(firstName) {\n  this.firstName = firstName;\n};\n\n// Methods shared by all Person instances are added to Person.prototype\nPerson.prototype.sayHello = function() {\n  console.log(\"Hello, I'm \" + this.firstName);\n};\n\n// Child constructor function\nfunction Student(firstName, subject) {\n  // 1. Call parent constructor to inherit parent's properties on 'this' (the Student instance)\n  Person.call(this, firstName);\n  this.subject = subject;\n}\n\n// 2. Set Student's prototype to an object that inherits from Person's prototype\n// This establishes the prototype chain: studentInstance -> Student.prototype -> Person.prototype -> Object.prototype\nStudent.prototype = Object.create(Person.prototype);\n\n// 3. Reset the constructor property, as Object.create sets it to Person\nStudent.prototype.constructor = Student;\n\n// 4. Add methods specific to Student\nStudent.prototype.saySubject = function() {\n  console.log(\"I study \" + this.subject);\n};\n\n// Create instances\nvar person1 = new Person(\"Alice\");\nvar student1 = new Student(\"Bob\", \"Math\");\n\nperson1.sayHello(); // \"Hello, I'm Alice\"\nstudent1.sayHello(); // \"Hello, I'm Bob\" (inherited from Person.prototype)\nstudent1.saySubject(); // \"I study Math\" (specific to Student.prototype)\n\nconsole.log(student1 instanceof Student); // true\nconsole.log(student1 instanceof Person); // true\nconsole.log(student1.constructor === Student); // true\n",
              "explanation": "This example demonstrates how `Student` inherits from `Person` using prototypal inheritance in ES5. `Person.call(this, firstName)` ensures that the `firstName` property from `Person`'s constructor is set on the `Student` instance. `Student.prototype = Object.create(Person.prototype)` sets up the prototype chain, allowing `Student` instances to access methods defined on `Person.prototype`. Finally, `Student.prototype.constructor = Student` corrects the `constructor` reference. This complex setup is largely simplified by ES6 `class` syntax, which internally uses this prototypal mechanism.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_prototypal_1",
            "question_prototypal_2",
            "question_prototypal_3",
            "question_prototypal_4"
          ],
          "relatedTasks": [
            "task_prototypal_inheritance_hierarchy"
          ],
          "tags": [
            "javascript",
            "oop",
            "prototypes",
            "inheritance",
            "prototype-chain",
            "constructor-functions",
            "object-create",
            "this",
            "es5"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "theory_oop_intro",
            "theory_oop_principles"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "javascript_classes_deep_dive",
            "custom_javascript_frameworks"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_this_es5_1",
          "topic": "ES5 'this' Context",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary issue with 'this' when using traditional functions as callbacks in ES5?",
          "answer": "The 'this' context inside the callback often defaults to the global object (window/undefined) instead of the desired object instance, losing the intended context.",
          "options": [],
          "analysisPoints": [
            "Understanding of dynamic 'this' binding in JavaScript.",
            "Recognition of common pitfalls in asynchronous callbacks."
          ],
          "keyConcepts": [
            "this-context",
            "callbacks",
            "scope",
            "global-object"
          ],
          "evaluationCriteria": [
            "Ability to identify the core problem.",
            "Conciseness of explanation."
          ],
          "example": null,
          "tags": [
            "javascript",
            "this",
            "es5",
            "callbacks"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_this_es5_2",
          "topic": "ES5 'this' Context Solutions",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following ES5 code. Which line correctly binds the `this` context of the `Person` instance to the `growUp` function?\n\n```javascript\nfunction Person() {\n  this.age = 0;\n  setInterval(function growUp() {\n    this.age++;\n  } /* LINE A */, 1000);\n}\n```",
          "answer": ".bind(this)",
          "options": [
            "var self = this;",
            ".bind(this)",
            "growUp.call(this);",
            "this.growUp()"
          ],
          "analysisPoints": [
            "Understanding of `Function.prototype.bind`.",
            "Distinguishing `bind` from `call` and `apply` in terms of function invocation vs. function creation.",
            "Knowing when to use `self`/`that` vs. `bind`."
          ],
          "keyConcepts": [
            "this-context",
            "bind",
            "setInterval",
            "es5"
          ],
          "evaluationCriteria": [
            "Correct application of `bind` for persistent context.",
            "Understanding of method `bind` behavior."
          ],
          "example": "The `bind()` method creates a *new* function that, when called, has its `this` keyword set to the provided value. This is perfect for callbacks like `setInterval` because it returns a function that will be executed later, with the `this` context already fixed. `var self = this;` would typically be placed before `setInterval` and then `self.age++` would be used inside `growUp`. `call(this)` executes the function immediately, which is not suitable for a `setInterval` callback. `this.growUp()` would try to call `growUp` as a method on `this` (the `Person` instance), which is not how `setInterval` works.",
          "tags": [
            "javascript",
            "this",
            "es5",
            "bind",
            "mcq"
          ],
          "prerequisites": [
            "theory_this_context_es5"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_es5_3",
          "topic": "ES5 'this' Context Solutions",
          "level": "medium",
          "type": "code",
          "question": "Refactor the following `Game` object's `start` method to correctly increment `this.score` every second using an ES5 solution (either `that`/`self` or `bind`). Explain your chosen approach.\n\n```javascript\nvar Game = {\n  score: 0,\n  start: function() {\n    console.log('Game started! Initial score: ' + this.score);\n    setInterval(function() {\n      this.score++; // Problematic line\n      console.log('Score: ' + this.score);\n    }, 1000);\n  }\n};\n\n// Game.start(); // Uncomment to test\n```",
          "answer": "```javascript\nvar Game = {\n  score: 0,\n  start: function() {\n    console.log('Game started! Initial score: ' + this.score);\n    // Solution 1: Using 'that' variable\n    // var that = this; \n    // setInterval(function() {\n    //   that.score++;\n    //   console.log('Score: ' + that.score);\n    // }, 1000);\n\n    // Solution 2: Using .bind(this)\n    setInterval(function() {\n      this.score++;\n      console.log('Score: ' + this.score);\n    }.bind(this), 1000);\n  }\n};\n\n// Explanation for Solution 2 (.bind(this)):\n// The .bind(this) method is used to create a new function where the 'this' context is permanently bound to the 'Game' object (the 'this' value from the 'start' method's execution context). \n// When setInterval later invokes this new, bound function, 'this.score' correctly refers to the 'score' property of the 'Game' object, resolving the context issue.",
          "options": [],
          "analysisPoints": [
            "Ability to apply ES5 'this' context solutions in a practical scenario.",
            "Understanding the behavior of `setInterval` with respect to `this`.",
            "Clarity of explanation for the chosen solution."
          ],
          "keyConcepts": [
            "this-context",
            "bind",
            "closures",
            "es5",
            "setInterval",
            "refactoring"
          ],
          "evaluationCriteria": [
            "Correctness of the refactored code.",
            "Completeness and accuracy of the explanation.",
            "Identification of the problematic line."
          ],
          "example": null,
          "tags": [
            "javascript",
            "this",
            "es5",
            "code-challenge",
            "refactoring"
          ],
          "prerequisites": [
            "theory_this_context_es5"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_es5_4",
          "topic": "ES5 'this' Context",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast the `that`/`self` variable approach and the `Function.prototype.bind()` method for preserving `this` context in ES5. Discuss their use cases, advantages, and disadvantages.",
          "answer": "### 'that'/'self' Variable Approach\n*   **How it works**: A common pattern where you save a reference to the desired `this` context in a variable (e.g., `that` or `self`) outside the callback function, usually at the beginning of the enclosing function/method. The callback function, being a closure, captures this `that` variable from its lexical scope, allowing it to correctly access the intended object's properties.\n*   **Advantages**: \n    *   Very explicit and easy to understand for beginners.\n    *   Does not create a new function (unlike `bind`), which can sometimes be marginally more performant if performance is critical and many functions are involved (though often negligible).\n    *   Works in environments where `bind` might not be natively available (very old browsers, though `bind` is widely supported now).\n*   **Disadvantages**: \n    *   Can lead to repetitive `var that = this;` lines in multiple methods.\n    *   Less declarative than `bind` for `this` context. The intent of binding is clearer with `bind`.\n\n### `Function.prototype.bind()` Method\n*   **How it works**: `bind()` is a method on all functions that creates a *new function* (a 'bound function'). When this new function is called, its `this` keyword is set to the provided value (the first argument to `bind`), and it also pre-sets any leading arguments provided to `bind`.\n*   **Advantages**: \n    *   More declarative and concise than the `that`/`self` pattern, explicitly stating the `this` context.\n    *   It's a standard JavaScript feature, making code more idiomatic.\n    *   Allows partial application of arguments, in addition to binding `this`.\n*   **Disadvantages**: \n    *   Creates a new function every time `bind` is called. While usually not a performance bottleneck, in highly performance-critical loops or for very frequent event handlers, this might be a minor consideration.\n    *   The `this` context is permanently bound, meaning it cannot be changed later with `call` or `apply` (though this is often the desired behavior).\n\n### Use Cases & Comparison:\n*   **`that`/`self`**: Often preferred for simple, self-contained closures where `this` only needs to be captured once. Useful when `bind` is not strictly necessary or for maximum backward compatibility.\n*   **`bind()`**: Generally preferred for clarity and conciseness, especially when passing methods as callbacks to external APIs (like `addEventListener`, `setTimeout`, array methods like `map` where the callback `thisArg` is often the second argument). It's the more modern ES5 solution.\n\nIn modern JavaScript (ES6+), arrow functions largely supersede both for `this` binding within callbacks due to their lexical `this` behavior, offering the cleanest solution.",
          "options": [],
          "analysisPoints": [
            "Detailed understanding of both ES5 `this` binding techniques.",
            "Ability to articulate advantages and disadvantages of each.",
            "Comparison of their underlying mechanisms (closure vs. new function).",
            "Discussion of practical use cases."
          ],
          "keyConcepts": [
            "this-context",
            "bind",
            "closure",
            "es5",
            "advantages-disadvantages",
            "function-prototype"
          ],
          "evaluationCriteria": [
            "Depth of technical explanation for each method.",
            "Effectiveness of comparison (pros/cons).",
            "Clarity and structure of the response."
          ],
          "example": null,
          "tags": [
            "javascript",
            "this",
            "es5",
            "open-ended",
            "comparison"
          ],
          "prerequisites": [
            "theory_this_context_es5"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_this_es6_1",
          "topic": "ES6 Arrow Functions 'this' Context",
          "level": "easy",
          "type": "flashcard",
          "question": "How do ES6 arrow functions handle the `this` keyword differently from traditional functions?",
          "answer": "Arrow functions do not create their own `this` context; they lexically inherit `this` from their parent scope at the time of definition.",
          "options": [],
          "analysisPoints": [
            "Understanding of lexical 'this' binding.",
            "Key differentiator of arrow functions."
          ],
          "keyConcepts": [
            "arrow-functions",
            "this-context",
            "lexical-scope",
            "es6"
          ],
          "evaluationCriteria": [
            "Accuracy of definition.",
            "Conciseness."
          ],
          "example": null,
          "tags": [
            "javascript",
            "this",
            "es6",
            "arrow-functions"
          ],
          "prerequisites": [
            "theory_this_context_es6_arrow"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_this_es6_2",
          "topic": "ES6 Arrow Functions 'this' Context",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is an advantage of using an arrow function for a callback that needs to access the `this` context of its enclosing lexical scope?\n\n```javascript\nclass Counter {\n  constructor() {\n    this.count = 0;\n  }\n  start() {\n    setInterval(() => {\n      this.count++;\n      console.log(this.count);\n    }, 1000);\n  }\n}\n// new Counter().start();\n```",
          "answer": "It automatically binds `this` to the lexical scope, avoiding manual binding or `var self = this;`.",
          "options": [
            "It executes faster than traditional functions.",
            "It creates its own `this` context, ensuring isolation.",
            "It automatically binds `this` to the global object.",
            "It automatically binds `this` to the lexical scope, avoiding manual binding or `var self = this;`."
          ],
          "analysisPoints": [
            "Understanding the primary benefit of lexical `this`.",
            "Differentiating correct `this` binding from misconceptions."
          ],
          "keyConcepts": [
            "arrow-functions",
            "this-context",
            "lexical-scope",
            "es6",
            "callbacks"
          ],
          "evaluationCriteria": [
            "Correct identification of arrow function advantage.",
            "Rejection of incorrect statements."
          ],
          "example": "Arrow functions do not create their own `this` context. Instead, they capture the `this` value of their enclosing scope when they are defined. This is known as lexical `this` binding. This behavior makes them ideal for callbacks, as it means `this` inside the arrow function will always refer to the same `this` as the surrounding code, eliminating the need for `bind()` or `var self = this;` workarounds prevalent in ES5.",
          "tags": [
            "javascript",
            "this",
            "es6",
            "arrow-functions",
            "mcq"
          ],
          "prerequisites": [
            "theory_this_context_es6_arrow"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_this_es6_3",
          "topic": "ES6 Arrow Functions 'this' Context",
          "level": "hard",
          "type": "code",
          "question": "Given the following HTML and JavaScript, modify the `clickHandler` in the `App` class using an ES6 arrow function to correctly log the `message` property when the button is clicked. Explain why your solution works.\n\n```html\n<button id=\"myButton\">Click Me</button>\n```\n```javascript\nclass App {\n  constructor(message) {\n    this.message = message;\n    this.button = document.getElementById('myButton');\n    // Problematic line: this.button.addEventListener('click', this.clickHandler);\n    // How would you fix this line or the clickHandler?\n  }\n\n  clickHandler() {\n    console.log(this.message);\n  }\n}\n\n// const app = new App('Hello from App!');\n```",
          "answer": "```javascript\nclass App {\n  constructor(message) {\n    this.message = message;\n    this.button = document.getElementById('myButton');\n    \n    // Fix 1: Bind in constructor (ES5 way, still valid for non-arrow methods)\n    // this.button.addEventListener('click', this.clickHandler.bind(this));\n\n    // Fix 2: Define clickHandler as an arrow function property (preferred ES6 way)\n    this.button.addEventListener('click', this.clickHandler); // This now works because clickHandler is bound\n  }\n\n  // Using arrow function as a class property\n  clickHandler = () => {\n    console.log(this.message);\n  };\n}\n\n// const app = new App('Hello from App!');\n// app.button.click(); // Simulate click\n```\n\n**Explanation:**\n\nThe original `clickHandler` is a regular method. When `addEventListener` calls `this.clickHandler`, it invokes it as a standalone function, not as a method of the `App` instance. In such a scenario, `this` inside `clickHandler` would be the HTML button element itself (or `undefined` in strict mode if it were a direct function call), not the `App` instance.\n\nBy defining `clickHandler` as a **class property arrow function** (`clickHandler = () => { ... };`), we leverage the lexical `this` binding of arrow functions. This means `this` inside `clickHandler` is bound to the `this` of the `App` instance *at the time the `App` instance is created*. Consequently, when the event listener later invokes `clickHandler`, `this.message` correctly refers to the `message` property of the `App` instance, because the arrow function's `this` context was permanently captured from its enclosing `App` instance scope.",
          "options": [],
          "analysisPoints": [
            "Understanding of `this` context in event handlers.",
            "Correct application of arrow functions as class properties for binding.",
            "Ability to explain the 'why' behind the solution (lexical `this`)."
          ],
          "keyConcepts": [
            "this-context",
            "arrow-functions",
            "es6-classes",
            "event-listeners",
            "lexical-scope",
            "frontend-development"
          ],
          "evaluationCriteria": [
            "Correct refactoring of the class method.",
            "Clear and accurate explanation of the underlying `this` mechanism.",
            "Demonstrates knowledge of common frontend `this` pitfalls."
          ],
          "example": null,
          "tags": [
            "javascript",
            "this",
            "es6",
            "code-challenge",
            "frontend",
            "event-handling"
          ],
          "prerequisites": [
            "theory_this_context_es6_arrow"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_chaining_1",
          "topic": "Function Chaining",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary mechanism that allows methods to be chained together on an object?",
          "answer": "Each method in the chain must return the object itself (`this`) after performing its operation.",
          "options": [],
          "analysisPoints": [
            "Understanding the fundamental requirement for method chaining.",
            "Key role of `this` in chaining."
          ],
          "keyConcepts": [
            "method-chaining",
            "this",
            "fluent-api"
          ],
          "evaluationCriteria": [
            "Accuracy and conciseness."
          ],
          "example": null,
          "tags": [
            "javascript",
            "function-chaining",
            "design-patterns"
          ],
          "prerequisites": [
            "theory_function_chaining"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_chaining_2",
          "topic": "Function Chaining",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the `StringBuilder` class from the theory. If `append` did not return `this`, what would be the result of the following?\n\n```javascript\nclass StringBuilder {\n  constructor(str = \"\") {\n    this.str = str;\n  }\n  append(s) {\n    this.str += s;\n    // return this; <-- REMOVED\n  }\n  toString() {\n    return this.str;\n  }\n}\nconst builder = new StringBuilder();\nconst result = builder.append(\"Hello\").append(\" \").append(\"World!\").toString();\n```",
          "answer": "An error, because `builder.append(\"Hello\")` would return `undefined`, and `undefined` does not have an `append` method.",
          "options": [
            "\"Hello World!\"",
            "\"Hello\"",
            "An error, because `builder.append(\"Hello\")` would return `undefined`, and `undefined` does not have an `append` method.",
            "An empty string \"\"."
          ],
          "analysisPoints": [
            "Understanding the consequences of breaking the chaining contract.",
            "Knowledge of what `undefined` is and its properties.",
            "Ability to trace execution flow."
          ],
          "keyConcepts": [
            "method-chaining",
            "this",
            "fluent-api",
            "return-value"
          ],
          "evaluationCriteria": [
            "Correctly identifying the runtime error.",
            "Accurate explanation of why the error occurs."
          ],
          "example": "If `append` does not explicitly return `this`, it will implicitly return `undefined` (the default return value for functions that don't specify one). When `builder.append(\"Hello\")` is called, it correctly updates `builder.str` to \"Hello\", but then it returns `undefined`. The next call in the chain, `.append(\" \")`, would then try to call `append` on `undefined`, leading to a `TypeError: Cannot read properties of undefined (reading 'append')`.",
          "tags": [
            "javascript",
            "function-chaining",
            "mcq",
            "error-handling"
          ],
          "prerequisites": [
            "theory_function_chaining"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_chaining_3",
          "topic": "Function Chaining",
          "level": "hard",
          "type": "code",
          "question": "Implement a simple `Calculator` class that supports method chaining for arithmetic operations (add, subtract, multiply, divide). The `Calculator` should maintain a running total and include a `getResult()` method that breaks the chain.\n\nRequirements:\n1.  Initialize with a `value` of 0 (or a provided initial value).\n2.  `add(num)`: adds `num` to the current `value`.\n3.  `subtract(num)`: subtracts `num` from the current `value`.\n4.  `multiply(num)`: multiplies the current `value` by `num`.\n5.  `divide(num)`: divides the current `value` by `num`. Handle division by zero by throwing an error.\n6.  `getResult()`: returns the current `value`.",
          "answer": "```javascript\nclass Calculator {\n  constructor(initialValue = 0) {\n    this.value = initialValue;\n  }\n\n  add(num) {\n    this.value += num;\n    return this; // Enable chaining\n  }\n\n  subtract(num) {\n    this.value -= num;\n    return this; // Enable chaining\n  }\n\n  multiply(num) {\n    this.value *= num;\n    return this; // Enable chaining\n  }\n\n  divide(num) {\n    if (num === 0) {\n      throw new Error(\"Cannot divide by zero.\");\n    }\n    this.value /= num;\n    return this; // Enable chaining\n  }\n\n  getResult() {\n    return this.value; // Breaks the chain, returns the final result\n  }\n}\n\n// Example Usage:\nconst calc = new Calculator(10);\nconst result = calc.add(5).multiply(2).subtract(3).getResult(); // (10 + 5) * 2 - 3 = 15 * 2 - 3 = 30 - 3 = 27\nconsole.log(result); // 27\n\nconst anotherCalc = new Calculator();\ntry {\n  anotherCalc.add(10).divide(0);\n} catch (error) {\n  console.error(error.message); // Cannot divide by zero.\n}\n\nconst chainedResult = new Calculator(5).add(5).multiply(10).getResult(); // (5+5)*10 = 100\nconsole.log(chainedResult);\n```",
          "options": [],
          "analysisPoints": [
            "Correct implementation of method chaining by returning `this`.",
            "Appropriate handling of edge cases (division by zero).",
            "Demonstration of basic arithmetic operations within an OOP context."
          ],
          "keyConcepts": [
            "method-chaining",
            "classes",
            "oop",
            "error-handling",
            "fluent-api"
          ],
          "evaluationCriteria": [
            "Functional correctness of all methods.",
            "Proper chaining implementation.",
            "Robust error handling for division by zero.",
            "Clarity and readability of the code."
          ],
          "example": null,
          "tags": [
            "javascript",
            "function-chaining",
            "code-challenge",
            "oop"
          ],
          "prerequisites": [
            "theory_function_chaining"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hof_1",
          "topic": "Higher-Order Functions",
          "level": "easy",
          "type": "flashcard",
          "question": "What defines a function as a Higher-Order Function (HOF)?",
          "answer": "A function is a HOF if it either takes one or more functions as arguments, or returns a function as its result.",
          "options": [],
          "analysisPoints": [
            "Accurate definition of a HOF.",
            "Understanding functions as first-class citizens."
          ],
          "keyConcepts": [
            "hof",
            "functional-programming",
            "first-class-functions"
          ],
          "evaluationCriteria": [
            "Correctness and conciseness."
          ],
          "example": null,
          "tags": [
            "javascript",
            "hof",
            "functional-programming"
          ],
          "prerequisites": [
            "theory_higher_order_functions"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_hof_2",
          "topic": "Higher-Order Functions",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following built-in JavaScript array methods is an example of a Higher-Order Function?\n\n```javascript\nconst numbers = [1, 2, 3];\n// Which method below is a HOF?\nconst mapped = numbers.map(num => num * 2);\nconst filtered = numbers.filter(num => num % 2 === 0);\nconst reduced = numbers.reduce((acc, num) => acc + num, 0);\n```",
          "answer": "All of the above",
          "options": [
            "`map()`",
            "`filter()`",
            "`reduce()`",
            "All of the above"
          ],
          "analysisPoints": [
            "Identifying common HOFs in JavaScript's standard library.",
            "Understanding that array iteration methods accept functions as arguments."
          ],
          "keyConcepts": [
            "hof",
            "array-methods",
            "map",
            "filter",
            "reduce",
            "functional-programming"
          ],
          "evaluationCriteria": [
            "Correct identification.",
            "Demonstrates practical knowledge of HOFs."
          ],
          "example": "All three methods (`map`, `filter`, `reduce`) are Higher-Order Functions because they take a callback function as an argument. This callback function determines the transformation (`map`), the filtering logic (`filter`), or the aggregation logic (`reduce`).",
          "tags": [
            "javascript",
            "hof",
            "functional-programming",
            "mcq",
            "array-methods"
          ],
          "prerequisites": [
            "theory_higher_order_functions"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hof_3",
          "topic": "Higher-Order Functions",
          "level": "hard",
          "type": "code",
          "question": "Implement a `debounce` higher-order function. This function should take another function (`func`) and a `delay` (in milliseconds) as arguments. It should return a new function that, when invoked, will execute `func` only after `delay` milliseconds have passed since the last invocation. If the debounced function is called again within the `delay` period, the timer should be reset.\n\n```javascript\nfunction debounce(func, delay) {\n  // Your implementation here\n}\n\n// Example Usage:\n// const debouncedLog = debounce((message) => console.log('Logging:', message), 500);\n// debouncedLog('First call'); // Timer starts\n// setTimeout(() => debouncedLog('Second call'), 200); // Timer reset, 'First call' is cancelled\n// setTimeout(() => debouncedLog('Third call'), 700); // Timer reset, 'Second call' is cancelled\n// // 'Logging: Third call' should appear ~1200ms after initial call (700 + 500)\n```",
          "answer": "```javascript\nfunction debounce(func, delay) {\n  let timeoutId; // This variable will persist across calls due to closure\n\n  return function(...args) {\n    const context = this; // Capture the 'this' context of the invocation\n\n    clearTimeout(timeoutId); // Clear any existing timer\n\n    timeoutId = setTimeout(() => {\n      func.apply(context, args); // Execute the original function with correct 'this' and arguments\n    }, delay);\n  };\n}\n\n// Example Usage:\nconst debouncedLog = debounce((message) => console.log('Logging:', message), 500);\n\nconsole.log('--- Debounce Test ---');\ndebouncedLog('First call'); \nsetTimeout(() => debouncedLog('Second call'), 200); \nsetTimeout(() => debouncedLog('Third call'), 700); \n// Expected output after ~1200ms (700 + 500): 'Logging: Third call'\n\n// Another example with 'this' context\nconst myObject = {\n  value: 0,\n  increment: function() {\n    this.value++;\n    console.log('Incremented value:', this.value);\n  }\n};\n\nconst debouncedIncrement = debounce(myObject.increment, 300);\n\ndebouncedIncrement.call(myObject); // Call with 'myObject' as 'this'\nsetTimeout(() => debouncedIncrement.call(myObject), 100); // Reset\nsetTimeout(() => debouncedIncrement.call(myObject), 200); // Reset\n// Expected output after ~500ms (200 + 300): 'Incremented value: 1'\n```",
          "options": [],
          "analysisPoints": [
            "Correct implementation of a `debounce` function using closures and `setTimeout`/`clearTimeout`.",
            "Proper handling of `this` context within the debounced function using `apply`.",
            "Understanding of timer management in JavaScript."
          ],
          "keyConcepts": [
            "hof",
            "closures",
            "debounce",
            "timers",
            "functional-programming",
            "this-context"
          ],
          "evaluationCriteria": [
            "Functional correctness of `debounce`.",
            "Ability to manage `setTimeout` and `clearTimeout` effectively.",
            "Correct preservation of `this` and arguments.",
            "Clarity and robustness of the solution."
          ],
          "example": null,
          "tags": [
            "javascript",
            "hof",
            "code-challenge",
            "functional-programming",
            "timers"
          ],
          "prerequisites": [
            "theory_higher_order_functions",
            "closures"
          ],
          "complexity": 8,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_hof_4",
          "topic": "Higher-Order Functions",
          "level": "hard",
          "type": "open",
          "question": "Explain the concept of 'Function Composition' and how it relates to Higher-Order Functions. Provide a scenario where `compose` (or a similar composition HOF) would be beneficial, contrasting it with a non-compositional approach.",
          "answer": "### Function Composition\nFunction composition is a mathematical and functional programming concept where you combine multiple simple functions to build a more complex function. The output of one function becomes the input of the next function in the sequence. If you have functions `f`, `g`, and `h`, composing them means creating a new function `C(x)` such that `C(x) = h(g(f(x)))`. The functions are applied from right-to-left (or left-to-right, depending on the `compose`/`pipe` implementation convention).\n\n### Relation to Higher-Order Functions\nFunction composition is inherently reliant on Higher-Order Functions. A `compose` (or `pipe`) utility itself is a HOF because:\n1.  It takes multiple functions as arguments (`f`, `g`, `h`).\n2.  It returns a single new function that encapsulates the combined logic.\n\nThis ability to treat functions as arguments and return values is precisely what defines a HOF, making `compose` a prime example of its utility.\n\n### Scenario: Data Transformation Pipeline\nImagine you have a list of user names, and you need to process them by:\n1.  Trimming whitespace from each name.\n2.  Converting each name to uppercase.\n3.  Adding a prefix \"USER-\" to each name.\n\n**Non-Compositional Approach:**\n```javascript\nconst names = ['  alice  ', 'bob ', '   charlie'];\n\nconst processedNames = names.map(name => {\n  const trimmed = name.trim();\n  const upper = trimmed.toUpperCase();\n  const prefixed = 'USER-' + upper;\n  return prefixed;\n});\nconsole.log(processedNames);\n// Output: [ 'USER-ALICE', 'USER-BOB', 'USER-CHARLIE' ]\n```\nThis approach works, but the callback function can become cluttered if more transformations are added. It mixes concerns (each step of the transformation within one function).\n\n**Compositional Approach:**\nFirst, define individual, single-purpose functions:\n```javascript\nconst trim = str => str.trim();\nconst toUpper = str => str.toUpperCase();\nconst addPrefix = str => 'USER-' + str;\n\n// A compose HOF (as provided in theory, simplified for example):\nconst compose = (...fns) => res => fns.reduce((accum, next) => next(accum), res);\n\nconst transformName = compose(trim, toUpper, addPrefix);\n\nconst names = ['  alice  ', 'bob ', '   charlie'];\nconst processedNamesComposed = names.map(transformName);\nconsole.log(processedNamesComposed);\n// Output: [ 'USER-ALICE', 'USER-BOB', 'USER-CHARLIE' ]\n```\n\n**Benefits of Composition in this scenario:**\n*   **Readability & Maintainability**: Each small function (e.g., `trim`, `toUpper`) is focused on a single responsibility, making them easy to understand, test, and reuse. The `transformName` function clearly states the *sequence* of operations without revealing the internal step-by-step logic.\n*   **Reusability**: `trim`, `toUpper`, `addPrefix` can be reused independently or combined in different ways for other data processing tasks.\n*   **Declarative**: The code describes *what* is being done (compose these transformations) rather than *how* it's done (sequential assignments inside a single function).\n*   **Flexibility**: Easily add, remove, or reorder transformations by simply modifying the `compose` arguments, without changing the core mapping logic.",
          "options": [],
          "analysisPoints": [
            "Clear definition of function composition.",
            "Explanation of how HOFs facilitate composition.",
            "Detailed comparison of compositional vs. non-compositional approach for a practical scenario.",
            "Articulation of benefits (readability, reusability, maintainability)."
          ],
          "keyConcepts": [
            "function-composition",
            "hof",
            "functional-programming",
            "pipe",
            "declarative-programming",
            "code-reusability"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of composition.",
            "Ability to provide a compelling, practical example.",
            "Strong comparative analysis.",
            "Clarity and depth of explanation."
          ],
          "example": null,
          "tags": [
            "javascript",
            "hof",
            "open-ended",
            "functional-programming",
            "design-patterns"
          ],
          "prerequisites": [
            "theory_higher_order_functions"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "expert"
        },
        {
          "id": "question_oop_intro_1",
          "topic": "Introduction to OOP",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary concept around which Object-Oriented Programming (OOP) is centered?",
          "answer": "OOP is centered around 'objects' that can contain both data (properties) and code (methods) that operate on that data.",
          "options": [],
          "analysisPoints": [
            "Fundamental definition of OOP.",
            "Understanding of an 'object' in OOP."
          ],
          "keyConcepts": [
            "oop",
            "objects",
            "paradigm"
          ],
          "evaluationCriteria": [
            "Accuracy and conciseness."
          ],
          "example": null,
          "tags": [
            "oop",
            "javascript"
          ],
          "prerequisites": [
            "theory_oop_intro"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_oop_intro_2",
          "topic": "Introduction to OOP",
          "level": "medium",
          "type": "mcq",
          "question": "How does JavaScript primarily support Object-Oriented Programming?",
          "answer": "Through prototypal inheritance and ES6 class syntax (which is syntactic sugar over prototypes).",
          "options": [
            "Solely through classical inheritance with strong type checking.",
            "By enforcing strict interfaces and abstract classes.",
            "Through prototypal inheritance and ES6 class syntax (which is syntactic sugar over prototypes).",
            "It is a purely functional programming language and does not support OOP."
          ],
          "analysisPoints": [
            "Correctly identifying JavaScript's OOP mechanisms.",
            "Dispelling misconceptions about JS as a purely functional language.",
            "Understanding the relationship between ES6 classes and prototypes."
          ],
          "keyConcepts": [
            "oop",
            "javascript",
            "prototypes",
            "classes",
            "inheritance"
          ],
          "evaluationCriteria": [
            "Accuracy of JS OOP support.",
            "Distinguishing correct from incorrect paradigms."
          ],
          "example": "JavaScript is a multi-paradigm language, supporting both functional and object-oriented styles. Its unique take on OOP is centered around prototypes, where objects directly inherit from other objects. ES6 introduced the `class` keyword, which provides a more familiar syntax for developers from class-based languages, but fundamentally, it still operates on the prototypal inheritance model under the hood.",
          "tags": [
            "oop",
            "javascript",
            "mcq",
            "prototypes",
            "classes"
          ],
          "prerequisites": [
            "theory_oop_intro"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_oop_principles_1",
          "topic": "Core OOP Principles",
          "level": "easy",
          "type": "flashcard",
          "question": "What OOP principle is defined as 'bundling data and methods that operate on that data within one unit'?",
          "answer": "Encapsulation.",
          "options": [],
          "analysisPoints": [
            "Recall core OOP definitions."
          ],
          "keyConcepts": [
            "oop",
            "encapsulation",
            "principles"
          ],
          "evaluationCriteria": [
            "Direct recall of definition."
          ],
          "example": null,
          "tags": [
            "oop",
            "principles"
          ],
          "prerequisites": [
            "theory_oop_principles"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_oop_principles_2",
          "topic": "Core OOP Principles",
          "level": "medium",
          "type": "mcq",
          "question": "Which OOP principle focuses on simplifying complex reality by modeling classes appropriate to the problem, hiding internal complexity?",
          "answer": "Abstraction",
          "options": [
            "Encapsulation",
            "Inheritance",
            "Polymorphism",
            "Abstraction"
          ],
          "analysisPoints": [
            "Distinguishing between the four OOP principles.",
            "Understanding the focus of Abstraction."
          ],
          "keyConcepts": [
            "oop",
            "abstraction",
            "principles"
          ],
          "evaluationCriteria": [
            "Correct identification of the principle.",
            "Understanding the nuance between principles."
          ],
          "example": "Abstraction focuses on showing only the necessary aspects of an object and hiding the complex implementation details. For example, when you use a `console.log()` function, you don't need to know how the browser's console actually renders the text; you just use the abstracted interface `console.log()` to achieve your goal.",
          "tags": [
            "oop",
            "principles",
            "mcq"
          ],
          "prerequisites": [
            "theory_oop_principles"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_oop_principles_3",
          "topic": "Core OOP Principles",
          "level": "medium",
          "type": "open",
          "question": "Explain how JavaScript, particularly with ES6 features, supports the principle of Encapsulation. Provide a brief code example.",
          "answer": "Encapsulation, in OOP, is the bundling of data with the methods that operate on that data, and restricting direct access to some of an object's components. In JavaScript, perfect encapsulation (true private members) has historically been challenging, but modern ES6+ features offer better support.\n\n### How JavaScript Supports Encapsulation:\n1.  **Closures (ES5/ES6)**:\n    This is the traditional way to achieve private variables in JavaScript. Variables declared inside a function are not accessible from outside that function, but they remain accessible to inner functions (closures) defined within it. This allows public methods to access and modify 'private' data.\n    ```javascript\n    function Counter() {\n      let count = 0; // 'count' is private via closure\n      \n      this.increment = function() {\n        count++;\n      };\n      \n      this.getCount = function() {\n        return count;\n      };\n    }\n    const counter = new Counter();\n    // console.log(counter.count); // undefined - direct access is prevented\n    counter.increment();\n    console.log(counter.getCount()); // 1\n    ```\n\n2.  **`class` syntax with conventions (ES6)**:\n    While `class` methods and properties are public by default, developers often use conventions like prefixing properties with an underscore (`_`) to indicate that they are intended for internal use only, signaling to other developers not to access them directly. This is a form of 'soft' encapsulation.\n    ```javascript\n    class BankAccount {\n      constructor(initialBalance) {\n        this._balance = initialBalance; // Convention for 'private' or protected\n      }\n      \n      deposit(amount) {\n        if (amount > 0) {\n          this._balance += amount;\n        }\n      }\n      \n      getBalance() {\n        return this._balance;\n      }\n    }\n    const account = new BankAccount(100);\n    // console.log(account._balance); // Accessible, but convention indicates private\n    ```\n\n3.  **Private Class Fields (ES2019+)**: \n    The `#` prefix for class fields provides true private encapsulation at the language level. Private fields are only accessible from within the class body itself, making them inaccessible from outside the class instance.\n    ```javascript\n    class SecureCounter {\n      #count = 0; // Truly private field\n      \n      increment() {\n        this.#count++;\n      }\n      \n      getCount() {\n        return this.#count;\n      }\n    }\n    const secureCounter = new SecureCounter();\n    secureCounter.increment();\n    // console.log(secureCounter.#count); // SyntaxError: Private field '#count' must be declared in an enclosing class\n    console.log(secureCounter.getCount()); // 1\n    ```\n\nThese mechanisms allow JavaScript developers to control visibility and access to an object's internal state, promoting better data integrity and easier maintenance, aligning with the principle of encapsulation.",
          "options": [],
          "analysisPoints": [
            "Comprehensive explanation of encapsulation in JS.",
            "Demonstration of different mechanisms (closures, conventions, private fields).",
            "Clear and concise code examples for each method.",
            "Understanding of the progression of encapsulation support in JS."
          ],
          "keyConcepts": [
            "oop",
            "encapsulation",
            "javascript",
            "closures",
            "private-fields",
            "es6-classes"
          ],
          "evaluationCriteria": [
            "Accuracy and depth of encapsulation explanation.",
            "Correctness and relevance of code examples.",
            "Understanding of JavaScript's evolving support for the principle."
          ],
          "example": null,
          "tags": [
            "oop",
            "principles",
            "open-ended",
            "javascript",
            "es6",
            "closures"
          ],
          "prerequisites": [
            "theory_oop_principles"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_oop_principles_4",
          "topic": "Core OOP Principles",
          "level": "medium",
          "type": "flashcard",
          "question": "What is Polymorphism in the context of OOP, and how is it typically achieved in JavaScript?",
          "answer": "Polymorphism means 'many forms'. It allows objects of different types to be treated as objects of a common type, often by implementing the same method signature in their own specific ways. In JavaScript, it's typically achieved through method overriding in prototypal inheritance or classes, where different objects can respond to the same method call (e.g., a `speak()` method) with their unique implementations.",
          "options": [],
          "analysisPoints": [
            "Definition of polymorphism.",
            "How polymorphism is manifested in JavaScript."
          ],
          "keyConcepts": [
            "oop",
            "polymorphism",
            "method-overriding",
            "prototypal-inheritance"
          ],
          "evaluationCriteria": [
            "Accuracy and completeness of explanation."
          ],
          "example": null,
          "tags": [
            "oop",
            "principles",
            "javascript"
          ],
          "prerequisites": [
            "theory_oop_principles"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_prototypal_1",
          "topic": "Prototypal Inheritance",
          "level": "easy",
          "type": "flashcard",
          "question": "In JavaScript, from what do objects directly inherit properties and methods?",
          "answer": "Objects directly inherit from other objects, specifically their prototypes, forming a prototype chain.",
          "options": [],
          "analysisPoints": [
            "Understanding the fundamental concept of prototypal inheritance.",
            "Distinguishing it from classical inheritance."
          ],
          "keyConcepts": [
            "prototypal-inheritance",
            "prototype-chain",
            "objects"
          ],
          "evaluationCriteria": [
            "Accuracy and conciseness."
          ],
          "example": null,
          "tags": [
            "javascript",
            "oop",
            "prototypes"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_prototypal_2",
          "topic": "Prototypal Inheritance",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following code, what will be the output of `student1.constructor === Person`?\n\n```javascript\nvar Person = function(firstName) {\n  this.firstName = firstName;\n};\nPerson.prototype.sayHello = function() {};\n\nfunction Student(firstName, subject) {\n  Person.call(this, firstName);\n  this.subject = subject;\n}\nStudent.prototype = Object.create(Person.prototype);\n// Student.prototype.constructor = Student; <-- THIS LINE IS MISSING\n\nvar student1 = new Student(\"Alice\", \"Math\");\n\nconsole.log(student1.constructor === Person); // ?\nconsole.log(student1.constructor === Student); // ?\n```",
          "answer": "true",
          "options": [
            "true",
            "false",
            "undefined",
            "TypeError"
          ],
          "analysisPoints": [
            "Understanding the effect of `Object.create()` on the `constructor` property.",
            "Knowledge of how `constructor` property is inherited and its typical behavior.",
            "Ability to trace the prototype chain for property lookup."
          ],
          "keyConcepts": [
            "prototypal-inheritance",
            "prototype-chain",
            "constructor-property",
            "object-create"
          ],
          "evaluationCriteria": [
            "Correctly predicting the output.",
            "Understanding why the output is true (due to missing `constructor` reset).",
            "Knowledge of `constructor` property behavior."
          ],
          "example": "When `Student.prototype = Object.create(Person.prototype);` is executed, the newly created object (which becomes `Student.prototype`) inherits its properties from `Person.prototype`. One of the properties it inherits is `constructor`, which points to `Person`. Since the line `Student.prototype.constructor = Student;` is *missing*, the `constructor` property lookup on `student1` will traverse the prototype chain: `student1` -> `Student.prototype` -> `Person.prototype`, where it finds `constructor` pointing to `Person`. Thus, `student1.constructor` will evaluate to `Person`, making `student1.constructor === Person` true.",
          "tags": [
            "javascript",
            "oop",
            "prototypes",
            "mcq",
            "inheritance",
            "edge-case"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_prototypal_3",
          "topic": "Prototypal Inheritance",
          "level": "hard",
          "type": "code",
          "question": "Implement a `Vehicle` and `Car` hierarchy using ES5 constructor functions and prototypal inheritance. The `Vehicle` constructor should take `make` and `model`. It should have a `getInfo()` method on its prototype. The `Car` constructor should take `make`, `model`, and `numDoors`. It should inherit from `Vehicle` and have its own `getDoors()` method. Ensure `instanceof` and `constructor` checks work correctly for `Car` instances.\n\n```javascript\n// Implement Vehicle and Car here\n\n// Expected Usage:\n// var myCar = new Car('Toyota', 'Camry', 4);\n// console.log(myCar.getInfo());    // Expected: 'Make: Toyota, Model: Camry'\n// console.log(myCar.getDoors());   // Expected: 'Number of doors: 4'\n// console.log(myCar instanceof Car);     // Expected: true\n// console.log(myCar instanceof Vehicle); // Expected: true\n// console.log(myCar.constructor === Car); // Expected: true\n```",
          "answer": "```javascript\n// Vehicle Constructor\nvar Vehicle = function(make, model) {\n  this.make = make;\n  this.model = model;\n};\n\n// Vehicle Prototype Methods\nVehicle.prototype.getInfo = function() {\n  return 'Make: ' + this.make + ', Model: ' + this.model;\n};\n\n// Car Constructor\nfunction Car(make, model, numDoors) {\n  // 1. Constructor borrowing: Call the parent constructor to inherit properties\n  Vehicle.call(this, make, model);\n  this.numDoors = numDoors;\n}\n\n// 2. Set up the prototype chain: Car.prototype inherits from Vehicle.prototype\n// This allows Car instances to access methods defined on Vehicle.prototype\nCar.prototype = Object.create(Vehicle.prototype);\n\n// 3. Correct the constructor property for Car.prototype\n// Without this, Car.prototype.constructor would point to Vehicle\nCar.prototype.constructor = Car;\n\n// 4. Add methods specific to Car on its prototype\nCar.prototype.getDoors = function() {\n  return 'Number of doors: ' + this.numDoors;\n};\n\n// Expected Usage:\nvar myCar = new Car('Toyota', 'Camry', 4);\nconsole.log(myCar.getInfo());    // Expected: 'Make: Toyota, Model: Camry'\nconsole.log(myCar.getDoors());   // Expected: 'Number of doors: 4'\nconsole.log(myCar instanceof Car);     // Expected: true\nconsole.log(myCar instanceof Vehicle); // Expected: true\nconsole.log(myCar.constructor === Car); // Expected: true\nconsole.log(myCar.constructor === Vehicle); // Expected: false\n```",
          "options": [],
          "analysisPoints": [
            "Correct application of `Vehicle.call(this, ...)` for property inheritance.",
            "Proper use of `Object.create(Vehicle.prototype)` to establish the prototype chain.",
            "Crucial resetting of `Child.prototype.constructor`.",
            "Verification through `instanceof` and `constructor` checks."
          ],
          "keyConcepts": [
            "prototypal-inheritance",
            "constructor-functions",
            "prototype-chain",
            "object-create",
            "call",
            "instanceof"
          ],
          "evaluationCriteria": [
            "Complete and correct implementation of the hierarchy.",
            "Adherence to ES5 prototypal inheritance patterns.",
            "All expected test cases pass.",
            "Clear and readable code structure."
          ],
          "example": null,
          "tags": [
            "javascript",
            "oop",
            "prototypes",
            "code-challenge",
            "inheritance",
            "es5"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_prototypal_4",
          "topic": "Prototypal Inheritance",
          "level": "hard",
          "type": "open",
          "question": "Discuss the difference between `Object.getPrototypeOf()` and the `__proto__` property in JavaScript. When would you use one over the other, and what are the implications of directly manipulating `__proto__`?",
          "answer": "Both `Object.getPrototypeOf()` and the `__proto__` property are used to access an object's prototype. However, they differ significantly in their standardization, usage, and implications.\n\n### `Object.getPrototypeOf()`\n*   **Definition**: `Object.getPrototypeOf()` is a standard, built-in method in JavaScript, introduced in ES5. It returns the prototype (i.e., the internal `[[Prototype]]` slot) of the specified object.\n*   **Usage**: It is the **recommended and standard way** to get the prototype of an object.\n*   **Implications**: It's a read-only operation. It does not allow modification of an object's prototype directly. It's safe and predictable.\n\n### `__proto__` Property\n*   **Definition**: `__proto__` is a non-standard, legacy accessor property that was historically implemented by many JavaScript engines to expose the internal `[[Prototype]]` of an object. While it's widely supported in modern browsers and Node.js for historical reasons, it was never part of the ECMAScript standard until ES6 (as an optional feature, mainly for legacy code).\n*   **Usage**: Can be used to both get and *set* an object's prototype. \n    *   Getting: `myObject.__proto__`\n    *   Setting: `myObject.__proto__ = anotherObject` (This modifies the object's prototype chain *after* creation).\n*   **Implications**: \n    *   **Performance**: Directly manipulating `__proto__` to set an object's prototype can have significant negative performance implications, especially in older engines, as it can de-optimize the object and the code that interacts with it. Modern engines have improved, but it's still generally less efficient than setting the prototype at object creation.\n    *   **Standardization**: Although brought into ES6 for web compatibility, its use is generally discouraged for new code in favor of `Object.create()` for setting prototypes at creation and `Object.setPrototypeOf()` for changing them post-creation.\n    *   **Security/Integrity**: Modifying `__proto__` can lead to unexpected behavior and security vulnerabilities if not carefully managed, especially when dealing with untrusted input or objects.\n\n### When to use which:\n*   **`Object.getPrototypeOf()`**: **Always prefer this** when you need to simply *read* an object's prototype. It's clean, standard, and has no side effects or performance drawbacks related to prototype modification.\n*   **`__proto__`**: \n    *   **Avoid for setting prototypes in new code.** For setting prototypes at object creation, use `Object.create()`. For changing prototypes post-creation (which is rare), use `Object.setPrototypeOf()`, as it's the standard equivalent.\n    *   It might occasionally be seen in older codebases or specific niche scenarios where its direct mutability is exploited, but it's generally a red flag for modern JavaScript development.",
          "options": [],
          "analysisPoints": [
            "Clear definition and distinction between `Object.getPrototypeOf()` and `__proto__`.",
            "Discussion of standardization and historical context.",
            "Implications of direct `__proto__` manipulation (performance, security).",
            "Best practices for when to use each (or avoid `__proto__`)."
          ],
          "keyConcepts": [
            "prototypal-inheritance",
            "prototype",
            "object-getprototypeof",
            "__proto__",
            "object-setprototypeof",
            "performance",
            "standards"
          ],
          "evaluationCriteria": [
            "Comprehensive and accurate comparison.",
            "Demonstrates awareness of best practices and potential pitfalls.",
            "Depth of technical explanation.",
            "Clarity of recommendations."
          ],
          "example": null,
          "tags": [
            "javascript",
            "oop",
            "prototypes",
            "open-ended",
            "advanced"
          ],
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "expert"
        }
      ],
      "tasks": [
        {
          "id": "task_this_context_timer",
          "title": "Implement a Self-Updating Timer with Dynamic 'this' Context",
          "description": "\nCreate a `Timer` class (using ES6 `class` syntax) that displays a countdown or count-up. The timer should update its display element every second.\n\n**Requirements:**\n1.  **`Timer` Class**: It should have a `constructor` that takes an initial `count` and a DOM element `displayElement` (e.g., a `div` or `span`) where the count will be displayed.\n2.  **`start()` Method**: This method should initiate a `setInterval` that increments/decrements the internal `count` and updates the `textContent` of `displayElement` every second.\n3.  **Correct `this` Context**: Ensure that `this.count` and `this.displayElement` are correctly accessed within the `setInterval` callback.\n4.  **`stop()` Method**: This method should clear the `setInterval` to stop the timer.\n5.  **Bonus**: Make it configurable for countdown or count-up.",
          "difficulty": "medium",
          "startingCode": "<html>\n<body>\n  <div id=\"timer-display\"></div>\n  <button id=\"start-button\">Start Timer</button>\n  <button id=\"stop-button\">Stop Timer</button>\n  <script>\n    // Your Timer class implementation here\n    class Timer {\n      constructor(initialCount, displayElementId, isCountdown = false) {\n        this.count = initialCount;\n        this.displayElement = document.getElementById(displayElementId);\n        this.isCountdown = isCountdown;\n        this.intervalId = null;\n\n        // Bind event listeners (consider where 'this' refers to the Timer instance)\n        document.getElementById('start-button').addEventListener('click', () => this.start());\n        document.getElementById('stop-button').addEventListener('click', () => this.stop());\n\n        this.updateDisplay(); // Initial display\n      }\n\n      updateDisplay() {\n        this.displayElement.textContent = `Count: ${this.count}`;\n      }\n\n      start() {\n        if (this.intervalId) return; // Prevent multiple intervals\n\n        // TODO: Implement setInterval to update count and display\n        // Pay attention to 'this' context inside the callback!\n        this.intervalId = setInterval(() => {\n          // Your code here\n          // this.count = ...\n          // this.updateDisplay();\n        }, 1000);\n        console.log('Timer started.');\n      }\n\n      stop() {\n        if (this.intervalId) {\n          clearInterval(this.intervalId);\n          this.intervalId = null;\n          console.log('Timer stopped.');\n        }\n      }\n    }\n\n    // const myTimer = new Timer(0, 'timer-display');\n    // const countdownTimer = new Timer(10, 'timer-display', true); // For bonus\n  </script>\n</body>\n</html>\n",
          "solutionCode": "<html>\n<body>\n  <div id=\"timer-display\"></div>\n  <button id=\"start-button\">Start Timer</button>\n  <button id=\"stop-button\">Stop Timer</button>\n  <script>\n    class Timer {\n      constructor(initialCount, displayElementId, isCountdown = false) {\n        this.count = initialCount;\n        this.displayElement = document.getElementById(displayElementId);\n        this.isCountdown = isCountdown;\n        this.intervalId = null;\n\n        document.getElementById('start-button').addEventListener('click', () => this.start());\n        document.getElementById('stop-button').addEventListener('click', () => this.stop());\n\n        this.updateDisplay(); // Initial display\n      }\n\n      updateDisplay() {\n        this.displayElement.textContent = `Count: ${this.count}`;\n      }\n\n      start() {\n        if (this.intervalId) return; \n\n        this.intervalId = setInterval(() => {\n          if (this.isCountdown) {\n            this.count--;\n          } else {\n            this.count++;\n          }\n          this.updateDisplay();\n        }, 1000);\n        console.log('Timer started.');\n      }\n\n      stop() {\n        if (this.intervalId) {\n          clearInterval(this.intervalId);\n          this.intervalId = null;\n          console.log('Timer stopped.');\n        }\n      }\n    }\n\n    const myTimer = new Timer(0, 'timer-display');\n    // To test countdown, uncomment the line below and comment out myTimer:\n    // const countdownTimer = new Timer(10, 'timer-display', true);\n  </script>\n</body>\n</html>\n",
          "testCases": [
            "Initial display shows correct count.",
            "Clicking 'Start' starts incrementing/decrementing the count in the display.",
            "Count updates every second.",
            "Clicking 'Stop' halts the counter.",
            "Clicking 'Start' multiple times does not create multiple intervals.",
            "Verify `this` context within `setInterval` callback correctly refers to the `Timer` instance.",
            "Bonus: Verify countdown functionality if `isCountdown` is true."
          ],
          "hints": [
            "Recall how ES6 arrow functions handle `this` context. They are ideal for `setInterval` callbacks within classes.",
            "Remember to store the `setInterval` ID so you can `clearInterval` later.",
            "The `updateDisplay` helper method can simplify the logic inside `setInterval`.",
            "Make sure your event listeners for buttons also correctly bind `this` or use arrow functions."
          ],
          "tags": [
            "javascript",
            "this",
            "es6-classes",
            "setinterval",
            "frontend",
            "timers"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_this_context_es5",
            "theory_this_context_es6_arrow"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "lexical-this",
            "closures",
            "event-handling"
          ]
        },
        {
          "id": "task_chainable_calculator",
          "title": "Build a Chainable Mathematical Utility Object",
          "description": "\nCreate a JavaScript object or class, `MathUtil`, that provides several common mathematical operations. The methods should be chainable, allowing for fluent expression of calculations.\n\n**Requirements:**\n1.  **`MathUtil` Class/Object**: It should encapsulate a `currentValue` property, initialized to 0 or a given starting number.\n2.  **Chainable Methods**: Implement `add(num)`, `subtract(num)`, `multiply(num)`, `divide(num)`. Each of these methods should modify `currentValue` and return the `MathUtil` instance itself (`this`) to enable chaining.\n3.  **`equals()` Method**: This method should return the final `currentValue`, breaking the chain.\n4.  **`reset()` Method**: Resets `currentValue` to 0 and is also chainable.\n5.  **Error Handling**: For `divide(num)`, throw an error if `num` is 0.\n\n**Example Usage:**\n```javascript\nconst result = new MathUtil(10).add(5).multiply(2).subtract(3).equals(); // Should be 27\nconst anotherResult = new MathUtil().add(10).reset().add(20).equals(); // Should be 20\n```\n",
          "difficulty": "medium",
          "startingCode": "class MathUtil {\n  constructor(initialValue = 0) {\n    this.currentValue = initialValue;\n  }\n\n  add(num) {\n    // TODO: Implement addition and return 'this'\n  }\n\n  subtract(num) {\n    // TODO: Implement subtraction and return 'this'\n  }\n\n  multiply(num) {\n    // TODO: Implement multiplication and return 'this'\n  }\n\n  divide(num) {\n    // TODO: Implement division with error handling and return 'this'\n  }\n\n  reset() {\n    // TODO: Implement reset and return 'this'\n  }\n\n  equals() {\n    // TODO: Return the final value, breaking the chain\n  }\n}\n\n// Example Usage (uncomment to test):\n// const calc = new MathUtil(10);\n// const result = calc.add(5).multiply(2).subtract(3).equals();\n// console.log(result); \n\n// const anotherCalc = new MathUtil();\n// const anotherResult = anotherCalc.add(10).reset().add(20).equals();\n// console.log(anotherResult);\n\n// try {\n//   new MathUtil(5).divide(0).equals();\n// } catch (e) {\n//   console.error(e.message);\n// }\n",
          "solutionCode": "class MathUtil {\n  constructor(initialValue = 0) {\n    this.currentValue = initialValue;\n  }\n\n  add(num) {\n    this.currentValue += num;\n    return this;\n  }\n\n  subtract(num) {\n    this.currentValue -= num;\n    return this;\n  }\n\n  multiply(num) {\n    this.currentValue *= num;\n    return this;\n  }\n\n  divide(num) {\n    if (num === 0) {\n      throw new Error(\"Division by zero is not allowed.\");\n    }\n    this.currentValue /= num;\n    return this;\n  }\n\n  reset() {\n    this.currentValue = 0;\n    return this;\n  }\n\n  equals() {\n    return this.currentValue;\n  }\n}\n\n// Example Usage:\nconst calc = new MathUtil(10);\nconst result = calc.add(5).multiply(2).subtract(3).equals(); // (10 + 5) * 2 - 3 = 27\nconsole.log(result); // 27\n\nconst anotherCalc = new MathUtil();\nconst anotherResult = anotherCalc.add(10).reset().add(20).equals(); // 20\nconsole.log(anotherResult); // 20\n\ntry {\n  new MathUtil(5).divide(0).equals();\n} catch (e) {\n  console.error(e.message); // Division by zero is not allowed.\n}\n\nconst chainedReset = new MathUtil(100).reset().add(50).equals();\nconsole.log(chainedReset); // 50\n",
          "testCases": [
            "`new MathUtil(0).add(5).equals()` should return 5.",
            "`new MathUtil(10).subtract(3).equals()` should return 7.",
            "`new MathUtil(2).multiply(4).equals()` should return 8.",
            "`new MathUtil(10).divide(2).equals()` should return 5.",
            "`new MathUtil(10).add(5).multiply(2).subtract(3).equals()` should return 27.",
            "`new MathUtil().add(10).reset().add(20).equals()` should return 20.",
            "`new MathUtil(5).divide(0).equals()` should throw an error.",
            "`new MathUtil(0).add(0).equals()` should return 0."
          ],
          "hints": [
            "Remember the key to chaining: what should each chainable method return?",
            "Pay close attention to error handling for division.",
            "Consider the initial value for the calculator."
          ],
          "tags": [
            "javascript",
            "method-chaining",
            "oop",
            "classes",
            "design-patterns",
            "error-handling"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_function_chaining"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "fluent-api",
            "this-context"
          ]
        },
        {
          "id": "task_hof_data_transformer",
          "title": "Create a Configurable Data Transformer using HOFs",
          "description": "\nImplement a function `createDataTransformer` that acts as a Higher-Order Function. It should take an array of transformation functions and return a single function that applies all these transformations sequentially to an input value.\n\n**Requirements:**\n1.  **`createDataTransformer(...transforms)`**: This HOF should accept an arbitrary number of functions as arguments. Each argument `transform` will be a function that takes one input and returns one output.\n2.  **Returned Function**: The `createDataTransformer` should return a new function that accepts a single `data` argument. This new function should apply each `transform` from the `transforms` array to the `data` sequentially, passing the output of one transformation as the input to the next.\n3.  **Error Handling**: If any transformation in the pipeline returns `null` or `undefined`, subsequent transformations should not be applied, and the current `null`/`undefined` should be returned.\n\n**Example Usage:**\n```javascript\nconst capitalize = str => str ? str.charAt(0).toUpperCase() + str.slice(1) : str;\nconst addExclamation = str => str ? str + '!' : str;\nconst removeSpaces = str => str ? str.replace(/\\s/g, '') : str;\n\nconst transformString = createDataTransformer(capitalize, removeSpaces, addExclamation);\n\nconsole.log(transformString('hello world')); // Expected: 'HelloWorld!'\nconsole.log(transformString('  test  '));    // Expected: 'Test!'\nconsole.log(transformString(null));          // Expected: null\nconsole.log(transformString(undefined));     // Expected: undefined\n```\n",
          "difficulty": "hard",
          "startingCode": "function createDataTransformer(...transforms) {\n  // TODO: Implement this HOF\n  return function(data) {\n    // TODO: Apply transformations sequentially\n    // Handle null/undefined results from intermediate steps\n  };\n}\n\n// Example Transformations:\nconst capitalize = str => str ? str.charAt(0).toUpperCase() + str.slice(1) : str;\nconst addExclamation = str => str ? str + '!' : str;\nconst removeSpaces = str => str ? str.replace(/\\s/g, '') : str;\n\n// Example Usage (uncomment to test):\n// const transformString = createDataTransformer(capitalize, removeSpaces, addExclamation);\n// console.log(transformString('hello world')); \n// console.log(transformString('  test  '));    \n// console.log(transformString(null));          \n// console.log(transformString(undefined));     \n\n// const processNumber = createDataTransformer(\n//   num => num + 10, \n//   num => num * 2, \n//   num => num > 50 ? null : num \n// );\n// console.log(processNumber(10)); // (10+10)*2 = 40\n// console.log(processNumber(20)); // (20+10)*2 = 60 -> null\n",
          "solutionCode": "function createDataTransformer(...transforms) {\n  return function(data) {\n    let currentResult = data;\n\n    for (const transformFn of transforms) {\n      // If currentResult is null or undefined, stop applying further transformations\n      if (currentResult === null || typeof currentResult === 'undefined') {\n        return currentResult;\n      }\n      currentResult = transformFn(currentResult);\n    }\n    return currentResult;\n  };\n}\n\n// Example Transformations:\nconst capitalize = str => str ? str.charAt(0).toUpperCase() + str.slice(1) : str;\nconst addExclamation = str => str ? str + '!' : str;\nconst removeSpaces = str => str ? str.replace(/\\s/g, '') : str;\n\n// Main test cases\nconst transformString = createDataTransformer(capitalize, removeSpaces, addExclamation);\nconsole.log(transformString('hello world')); // Expected: 'HelloWorld!'\nconsole.log(transformString('  test  '));    // Expected: 'Test!'\nconsole.log(transformString(null));          // Expected: null\nconsole.log(transformString(undefined));     // Expected: undefined\n\n// Additional tests\nconst processNumber = createDataTransformer(\n  num => num + 10, \n  num => num * 2, \n  num => num > 50 ? null : num \n);\nconsole.log(processNumber(10)); // (10+10)*2 = 40. Expected: 40\nconsole.log(processNumber(20)); // (20+10)*2 = 60. Then 60 > 50 ? null : 60 => null. Expected: null\n\nconst identity = x => x;\nconst transformerNoOps = createDataTransformer(identity, identity);\nconsole.log(transformerNoOps('abc')); // Expected: 'abc'\n\nconst transformerEmpty = createDataTransformer();\nconsole.log(transformerEmpty('hello')); // Expected: 'hello'\n",
          "testCases": [
            "`transformString('hello world')` should return `'HelloWorld!'`.",
            "`transformString('  test  ')` should return `'Test!'`.",
            "`transformString(null)` should return `null`.",
            "`transformString(undefined)` should return `undefined`.",
            "`createDataTransformer(num => num + 1, num => num * 2)(5)` should return `12`.",
            "A transformation returning `null` in the middle of the chain should cause subsequent transformations to be skipped.",
            "An empty `transforms` array should return the original data.",
            "Test with numerical transformations including `null`/`undefined` early exit."
          ],
          "hints": [
            "This pattern is similar to functional `compose` or `pipe` functions.",
            "You can use a loop or `Array.prototype.reduce` to apply transformations sequentially.",
            "Remember to check for `null` or `undefined` after each `transformFn` application.",
            "The initial value for `reduce` would be the input `data`."
          ],
          "tags": [
            "javascript",
            "hof",
            "functional-programming",
            "data-transformation",
            "design-patterns",
            "closures"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_higher_order_functions"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "function-composition",
            "pipe-operator",
            "array-reduce"
          ]
        },
        {
          "id": "task_prototypal_inheritance_hierarchy",
          "title": "Build a Shape Hierarchy with Prototypal Inheritance",
          "description": "\nImplement a simple inheritance hierarchy for geometric shapes using ES5 constructor functions and prototypal inheritance. Create a base `Shape` constructor and a derived `Circle` constructor.\n\n**Requirements:**\n1.  **`Shape` Constructor**: Takes `color` as an argument and stores it. Add a method `getColor()` to its prototype that returns the color.\n2.  **`Circle` Constructor**: Takes `color` and `radius` as arguments. It should inherit `color` from `Shape` and store `radius` locally. Add a method `getArea()` to its prototype that calculates the area of the circle (` * radius^2`).\n3.  **Prototypal Linkage**: Ensure `Circle` correctly inherits methods from `Shape` via the prototype chain.\n4.  **`instanceof` and `constructor` Checks**: Verify that instances of `Circle` are correctly identified as `Circle` and `Shape` types, and their `constructor` property points to `Circle`.\n\n**Constants:** Use `Math.PI` for the area calculation.\n\n```javascript\n// Your implementation here for Shape and Circle\n\n// Example Usage:\n// var redCircle = new Circle('red', 5);\n// console.log(redCircle.getColor());  // Expected: 'red'\n// console.log(redCircle.getArea());   // Expected: 78.539...\n// console.log(redCircle instanceof Circle);  // Expected: true\n// console.log(redCircle instanceof Shape);   // Expected: true\n// console.log(redCircle.constructor === Circle); // Expected: true\n```",
          "difficulty": "hard",
          "startingCode": "// Shape Constructor\nvar Shape = function(color) {\n  // TODO: Initialize color\n};\n\n// Shape Prototype Method\nShape.prototype.getColor = function() {\n  // TODO: Return color\n};\n\n// Circle Constructor\nfunction Circle(color, radius) {\n  // TODO: Inherit from Shape and initialize radius\n}\n\n// TODO: Set up prototype chain and fix constructor for Circle\n\n// Circle Prototype Method\nCircle.prototype.getArea = function() {\n  // TODO: Calculate and return area\n};\n\n// Example Usage (uncomment to test):\n// var redCircle = new Circle('red', 5);\n// console.log(redCircle.getColor());\n// console.log(redCircle.getArea());\n// console.log(redCircle instanceof Circle);\n// console.log(redCircle instanceof Shape);\n// console.log(redCircle.constructor === Circle);\n// console.log(redCircle.constructor === Shape); // Should be false\n",
          "solutionCode": "// Shape Constructor\nvar Shape = function(color) {\n  this.color = color;\n};\n\n// Shape Prototype Method\nShape.prototype.getColor = function() {\n  return this.color;\n};\n\n// Circle Constructor\nfunction Circle(color, radius) {\n  // Constructor borrowing: call the parent constructor to set 'color' on this Circle instance\n  Shape.call(this, color);\n  this.radius = radius;\n}\n\n// Set up the prototype chain: Circle.prototype inherits from Shape.prototype\n// This allows Circle instances to access methods from Shape.prototype\nCircle.prototype = Object.create(Shape.prototype);\n\n// Crucial: Correct the constructor property for Circle.prototype\n// Without this, Circle instances would appear to be constructed by Shape\nCircle.prototype.constructor = Circle;\n\n// Circle Prototype Method\nCircle.prototype.getArea = function() {\n  return Math.PI * this.radius * this.radius;\n};\n\n// Example Usage:\nvar redCircle = new Circle('red', 5);\nconsole.log(redCircle.getColor());  // Expected: 'red'\nconsole.log(redCircle.getArea());   // Expected: 78.53981633974483\nconsole.log(redCircle instanceof Circle);  // Expected: true\nconsole.log(redCircle instanceof Shape);   // Expected: true\nconsole.log(redCircle.constructor === Circle); // Expected: true\n\nvar blueShape = new Shape('blue');\nconsole.log(blueShape.getColor()); // Expected: 'blue'\nconsole.log(blueShape instanceof Circle); // Expected: false\nconsole.log(blueShape instanceof Shape); // Expected: true\n",
          "testCases": [
            "`redCircle.getColor()` should return 'red'.",
            "`redCircle.getArea()` should return `Math.PI * 25`.",
            "`redCircle instanceof Circle` should be `true`.",
            "`redCircle instanceof Shape` should be `true`.",
            "`redCircle.constructor === Circle` should be `true`.",
            "`new Shape('green', 10) instanceof Circle` should be `false`.",
            "`new Shape('green')` should not have a `getArea` method."
          ],
          "hints": [
            "Remember to use `Shape.call(this, ...)` inside the `Circle` constructor for property inheritance.",
            "`Object.create()` is the key to setting up the prototype chain correctly without directly assigning `Shape.prototype`.",
            "Don't forget to explicitly set `Circle.prototype.constructor = Circle;` after `Object.create()`.",
            "`Math.PI` is your friend for area calculations."
          ],
          "tags": [
            "javascript",
            "oop",
            "prototypal-inheritance",
            "constructor-functions",
            "es5",
            "inheritance"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_prototypal_inheritance"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "prototype-chain",
            "this-context",
            "instanceof"
          ]
        }
      ]
    }
  }
]