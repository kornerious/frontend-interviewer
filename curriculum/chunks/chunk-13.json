[
  {
    "id": "b7e9d11f-9e0b-4684-8674-c025b11e7b2e",
    "startLine": 2500,
    "endLine": 2599,
    "processedDate": "2025-06-17T08:23:13.847Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_js_object_methods",
          "title": "JavaScript Object Property Checks and Manipulation Methods",
          "content": "JavaScript provides a rich set of built-in methods and operators for interacting with objects, allowing developers to check for property existence, control object mutability, and transform objects. Understanding these methods is crucial for effective object management and data manipulation.\n\n## Property Existence Checks\n\n-   **`'property' in object` Operator:** This operator checks if a specified property exists in an object or anywhere along its prototype chain. It returns `true` if the property is found, `false` otherwise. This includes both own properties and inherited properties.\n\n-   **`object.hasOwnProperty('property')` Method:** This method checks if an object has a specified property as its *own* property, meaning it's directly defined on the object itself and not inherited from its prototype chain. It returns `true` if the property is an own property, `false` otherwise.\n\n## Object Mutability Control\n\nJavaScript offers methods to control the mutability (ability to be changed) of objects, which is particularly useful for creating immutable data structures or preventing accidental modifications.\n\n-   **`Object.freeze(obj)`:** This method makes an object immutable. It prevents new properties from being added to it, existing properties from being removed, existing properties from being changed, and the prototype from being changed. The values of existing properties also become immutable (shallow freeze). If you attempt to modify a frozen object, it will silently fail in non-strict mode and throw a `TypeError` in strict mode. `Object.freeze()` is shallow; it only freezes the top-level properties. If a property is an object itself, that nested object can still be modified unless explicitly frozen.\n\n-   **`Object.seal(obj)`:** This method seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. This means you cannot delete existing properties or change their configurability (e.g., make them enumerable or writable). However, you *can* still change the values of existing writable properties. Like `Object.freeze()`, `Object.seal()` is shallow.\n\n## Object Cloning\n\nCloning objects involves creating a new object with the same properties and values as an existing one. There are two main types of cloning:\n\n-   **Shallow Clone:** Creates a new object, but any nested objects or arrays within the original object are still referenced by the new object. Changes to nested structures in the clone will affect the original, and vice-versa.\n    -   **`Object.assign({}, original)`:** Copies all enumerable own properties from one or more source objects to a target object. The first argument (`{}`) is the target, creating a new empty object to copy into.\n    -   **Spread Syntax (`{ ...original }`)**: A modern and concise way to perform a shallow clone. It copies all enumerable own properties from the `original` object into a new object.\n\n-   **Deep Clone:** Creates a new object where all nested objects and arrays are also new, distinct copies. Changes to the cloned object, including nested structures, will not affect the original.\n    -   **`JSON.parse(JSON.stringify(original))` (Basic Approach):** This is a common, simple way to achieve a deep clone for basic JSON-serializable objects. The object is first converted to a JSON string, then parsed back into a new JavaScript object. **Limitations**: This method fails for objects containing `Date` objects (converted to strings), `RegExp` objects (converted to empty objects), `Map`, `Set`, `function`, `undefined`, `Symbol`, `BigInt` (ignored or converted incorrectly), and circular references (throws an error).\n\n## Object Iteration and Transformation\n\nThese methods provide ways to extract parts of an object or construct a new object from key-value pairs.\n\n-   **`Object.keys(obj)`:** Returns an array of a given object's own enumerable string-keyed property names.\n\n-   **`Object.values(obj)`:** Returns an array of a given object's own enumerable string-keyed property values.\n\n-   **`Object.entries(obj)`:** Returns an array of a given object's own enumerable string-keyed property `[key, value]` pairs.\n\n-   **`Object.fromEntries(iterable)`:** Transforms a list of key-value pairs (an iterable, such as an array of `[key, value]` arrays) into a new object. This is essentially the inverse of `Object.entries()`.",
          "examples": [
            {
              "id": "example_object_methods_1",
              "title": "Property Existence and Immutability",
              "code": "const myObject = { a: 1, b: 2 };\nconst protoObject = { c: 3 };\nObject.setPrototypeOf(myObject, protoObject);\n\nconsole.log('a' in myObject); // true (own property)\nconsole.log('c' in myObject); // true (inherited property)\nconsole.log(myObject.hasOwnProperty('a')); // true\nconsole.log(myObject.hasOwnProperty('c')); // false\n\n// Freezing an object\nconst frozenObj = Object.freeze({ name: 'Alice', age: 25 });\n// frozenObj.name = 'Bob'; // Throws TypeError in strict mode, silent fail otherwise\n// delete frozenObj.age; // Throws TypeError in strict mode\nconsole.log(frozenObj.name); // Alice\n\n// Sealing an object\nconst sealedObj = Object.seal({ city: 'New York' });\nsealedObj.city = 'London'; // Works\n// sealedObj.country = 'USA'; // No effect (cannot add new properties)\n// delete sealedObj.city; // Throws TypeError in strict mode\nconsole.log(sealedObj.city); // London",
              "explanation": "This example demonstrates the difference between `in` operator and `hasOwnProperty` for checking property existence, including inherited properties. It also shows the effects of `Object.freeze()` and `Object.seal()` on an object's mutability, highlighting what modifications are allowed or prevented by each method.",
              "language": "javascript"
            },
            {
              "id": "example_object_methods_2",
              "title": "Object Cloning and Transformation",
              "code": "const original = { \n  id: 1,\n  details: { color: 'red', size: 'M' },\n  tags: ['new', 'sale'],\n  getFormattedName: function() { return `Item-${this.id}`; }\n};\n\n// Shallow clone using spread syntax\nconst shallowClone = { ...original };\nshallowClone.details.color = 'blue'; // Modifies original's nested object\nshallowClone.tags.push('popular'); // Modifies original's nested array\n\nconsole.log(original.details.color); // blue\nconsole.log(original.tags); // ['new', 'sale', 'popular']\n\n// Deep clone using JSON serialization (with limitations)\nconst deepCloneJSON = JSON.parse(JSON.stringify(original));\ndeepCloneJSON.details.color = 'green';\nconsole.log(original.details.color); // blue (original not affected)\nconsole.log(deepCloneJSON.getFormattedName); // undefined (function lost)\n\n// Object iteration and creation\nconst obj = { a: 1, b: 2, c: 3 };\nconsole.log(Object.keys(obj));   // ['a', 'b', 'c']\nconsole.log(Object.values(obj)); // [1, 2, 3]\nconsole.log(Object.entries(obj)); // [['a', 1], ['b', 2], ['c', 3]]\n\nconst entriesArray = [['x', 10], ['y', 20]];\nconst newObj = Object.fromEntries(entriesArray);\nconsole.log(newObj); // { x: 10, y: 20 }",
              "explanation": "This example illustrates shallow vs. deep cloning, demonstrating how changes to nested objects/arrays in a shallow clone affect the original. It also shows how `JSON.parse(JSON.stringify())` works for deep cloning but highlights its limitation by showing that the `getFormattedName` function is lost. Finally, it demonstrates how to extract keys, values, and entries from an object and reconstruct an object from entries.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "JavaScript",
            "Objects",
            "Mutability",
            "Cloning",
            "ES6"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_basics",
            "data_types"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced_js_patterns",
            "react_state_management"
          ]
        },
        {
          "id": "theory_js_object_destructuring",
          "title": "JavaScript Object Destructuring",
          "content": "Object destructuring is an ECMAScript 6 (ES6) feature that allows you to extract properties from objects and bind them to variables. It provides a cleaner and more concise way to access data from objects, especially when dealing with complex or nested data structures. Destructuring can significantly improve code readability and reduce boilerplate.\n\n## Core Concepts\n\n-   **Basic Destructuring:** Extracts properties by their names directly into variables. If a variable with the same name as the property is declared, its value will be assigned the value of that property from the object.\n\n-   **Aliasing (Renaming Properties):** Sometimes you want to extract a property but assign its value to a variable with a different name. This is achieved using a colon (`:`) followed by the desired new variable name.\n\n-   **Nested Destructuring:** Allows you to extract properties from objects that are themselves properties of another object. You can drill down into nested structures to pull out specific values.\n\n-   **Default Values:** When destructuring, you can provide default values for properties. If the property does not exist on the object (or is `undefined`), the default value will be assigned to the variable instead.\n\n-   **Rest Pattern (`...rest`):** This pattern collects the remaining enumerable properties of an object that were not explicitly destructured into a new object. It must be the last element in the destructuring assignment.\n\n-   **Destructuring in Function Parameters:** Object destructuring is commonly used in function parameters to directly extract required properties from an object passed as an argument, making function signatures clearer and data access within the function body more direct.\n\nDestructuring works with both `const`, `let`, and `var` declarations.",
          "examples": [
            {
              "id": "example_object_destructuring_1",
              "title": "Basic and Aliased Destructuring",
              "code": "const user = {\n  firstName: 'Jane',\n  lastName: 'Doe',\n  email: 'jane.doe@example.com',\n  age: 28\n};\n\n// Basic destructuring\nconst { firstName, age } = user;\nconsole.log(firstName); // Jane\nconsole.log(age);       // 28\n\n// Destructuring with aliases (renaming)\nconst { firstName: givenName, lastName: familyName } = user;\nconsole.log(givenName);  // Jane\nconsole.log(familyName); // Doe",
              "explanation": "This example demonstrates the fundamental use of object destructuring to extract `firstName` and `age` into variables with the same names. It also shows how to rename properties during destructuring, assigning `firstName` to `givenName` and `lastName` to `familyName` for clearer variable naming.",
              "language": "javascript"
            },
            {
              "id": "example_object_destructuring_2",
              "title": "Nested, Default, Rest, and Function Parameter Destructuring",
              "code": "const product = {\n  id: 'PROD001',\n  name: 'Laptop Pro',\n  specs: {\n    processor: 'Intel i7',\n    ram: '16GB',\n    storage: '512GB SSD'\n  },\n  price: 1200\n};\n\n// Nested destructuring\nconst { specs: { processor, ram } } = product;\nconsole.log(processor); // Intel i7\nconsole.log(ram);       // 16GB\n\n// Destructuring with default values\nconst { category = 'Electronics', price, weight = '2kg' } = product;\nconsole.log(category); // Electronics (default value used)\nconsole.log(price);    // 1200\nconsole.log(weight);   // 2kg (default value used)\n\n// Rest pattern\nconst { name, specs, ...otherInfo } = product;\nconsole.log(otherInfo); // { id: 'PROD001', price: 1200 }\n\n// Destructuring in function parameters\nfunction displayProductInfo({ name, price, specs: { processor } }) {\n  console.log(`Product: ${name}`);\n  console.log(`Price: $${price}`);\n  console.log(`Processor: ${processor}`);\n}\n\ndisplayProductInfo(product);\n// Output:\n// Product: Laptop Pro\n// Price: $1200\n// Processor: Intel i7",
              "explanation": "This comprehensive example showcases various advanced destructuring techniques. It demonstrates how to extract `processor` and `ram` from the nested `specs` object, apply default values for `category` and `weight` (where `category` is used as it's missing, and `price` is taken from `product`). The rest pattern (`...otherInfo`) gathers `id` and `price`. Finally, it illustrates the powerful use of destructuring directly within function parameters to cleanly access specific properties from an object passed as an argument.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "JavaScript",
            "ES6",
            "Destructuring",
            "Objects",
            "Syntax",
            "Readability"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_objects",
            "variables"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_components",
            "functional_programming"
          ]
        },
        {
          "id": "theory_react_jsx",
          "title": "React JSX (JavaScript XML)",
          "content": "JSX, which stands for JavaScript XML, is a syntax extension for JavaScript primarily used with React to describe what the UI should look like. It allows developers to write HTML-like code directly within their JavaScript files, blending JavaScript logic with declarative UI descriptions. While JSX looks like HTML, it's not HTML; it's a syntactic sugar for `React.createElement()` calls.\n\n## Key Characteristics\n\n-   **Declarative UI:** JSX allows you to declare how your UI should look based on the current state and props, making your code easier to understand and debug.\n\n-   **Looks Like HTML/XML:** The syntax closely resembles standard HTML, which makes it intuitive for web developers.\n\n-   **Embedded JavaScript Expressions:** Within JSX, you can embed any valid JavaScript expression by wrapping it in curly braces `{}`. This enables dynamic content rendering, conditional logic, and mapping over arrays directly within your UI structure.\n\n-   **Transpilation Required:** Browsers do not understand JSX directly. It must be transformed (transpiled) into regular JavaScript (specifically, `React.createElement()` calls) before it can be executed by a browser. Tools like Babel are commonly used for this transpilation process.\n\n-   **Attributes vs. HTML Attributes:** JSX uses `camelCase` for most HTML attributes (e.g., `className` instead of `class`, `htmlFor` instead of `for`) because `class` and `for` are reserved keywords in JavaScript. `style` attribute expects a JavaScript object instead of a string of CSS rules.\n\n-   **Self-Closing Tags:** Elements without children can be self-closing (e.g., `<img />`, `<input />`).\n\n-   **Root Element:** A JSX expression must have exactly one root element. To return multiple elements, you can wrap them in a single parent element (like a `<div>`) or use a `React.Fragment` (short syntax `<></>`).\n\nJSX enhances developer experience by bringing the templating logic closer to the component logic, leading to more cohesive and maintainable codebases in React applications.",
          "examples": [
            {
              "id": "example_react_jsx_1",
              "title": "Basic JSX Structure and Expressions",
              "code": "// Basic JSX element\nconst welcomeMessage = <h1>Hello, React!</h1>;\n\n// JSX with an embedded JavaScript expression\nconst userName = 'Alice';\nconst greetingElement = <h2>Welcome, {userName}!</h2>;\n\n// JSX with a numeric expression and concatenation\nconst year = 2023;\nconst footer = <p>&copy; {year} My Company. All rights reserved.</p>;\n\n// JSX with a function call expression\nfunction formatName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\nconst user = { firstName: 'Bob', lastName: 'Johnson' };\nconst userDisplay = <p>User: {formatName(user)}</p>;\n\n// Rendering a list dynamically using map\nconst items = ['Apple', 'Banana', 'Cherry'];\nconst itemList = (\n  <ul>\n    {items.map((item, index) => (\n      <li key={index}>{item}</li>\n    ))}\n  </ul>\n);\n\n// Conditional rendering using ternary operator\nconst isLoggedIn = true;\nconst authStatus = (\n  <div>\n    {isLoggedIn ? <p>You are logged in.</p> : <button>Login</button>}\n  </div>\n);\n",
              "explanation": "This example demonstrates various ways to use JSX. It shows a simple `h1` element, how to embed a JavaScript variable (`userName`) within curly braces, and how to use more complex JavaScript expressions like `year` or `formatName(user)`. It also illustrates how to render dynamic lists using the `map` array method and how to implement conditional rendering directly within JSX using a ternary operator. The `key` prop in the list is crucial for React's reconciliation process.",
              "language": "javascript"
            },
            {
              "id": "example_react_jsx_2",
              "title": "JSX Attributes and Styling",
              "code": "// JSX with className attribute\nconst infoBox = <div className=\"info-card\">This is an informational box.</div>;\n\n// JSX with inline style (object)\nconst redText = <p style={{ color: 'red', fontSize: '16px' }}>This text is red and 16px.</p>;\n\n// JSX with an array of elements (must be wrapped or use Fragment)\nconst multipleElements = (\n  <>\n    <h1>Title</h1>\n    <p>Paragraph 1</p>\n    <p>Paragraph 2</p>\n  </>\n);\n\n// JSX with event handlers (camelCase)\nfunction handleClick() {\n  console.log('Button clicked!');\n}\n\nconst myButton = <button onClick={handleClick}>Click Me</button>;\n\nconsole.log(infoBox);\nconsole.log(redText);\nconsole.log(multipleElements);\nconsole.log(myButton);\n",
              "explanation": "This example focuses on how attributes are handled in JSX. It shows the use of `className` for CSS classes (instead of `class`), how to apply inline styles using a JavaScript object, and the necessity of wrapping multiple root elements in a `React.Fragment` (`<>...</>`) or a single parent tag. It also demonstrates how to attach event handlers using `camelCase` naming conventions directly within the JSX.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "JSX",
            "Frontend",
            "UI Development",
            "Transpilation",
            "JavaScript"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_basics",
            "dom_manipulation"
          ],
          "complexity": 7,
          "interviewRelevance": 10,
          "learningPath": "beginner",
          "requiredFor": [
            "react_component_development",
            "react_hooks"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_object_methods_1",
          "topic": "Object Property Existence Checks",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference between the `'property' in object` operator and the `object.hasOwnProperty('property')` method?",
          "answer": "The `'property' in object` operator checks for properties in the object itself or anywhere in its prototype chain, while `object.hasOwnProperty('property')` checks only for properties directly owned by the object (not inherited).",
          "analysisPoints": [
            "Understanding of prototype chain.",
            "Distinction between own properties and inherited properties.",
            "Correct application of each method."
          ],
          "keyConcepts": [
            "in operator",
            "hasOwnProperty",
            "prototype chain",
            "own properties",
            "inherited properties"
          ],
          "evaluationCriteria": [
            "Accuracy of distinction",
            "Completeness of explanation"
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "Objects",
            "Methods",
            "Prototypes"
          ],
          "prerequisites": [
            "javascript_objects",
            "prototype_chain"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_object_methods_2",
          "topic": "Object Mutability Control",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code:\n\n```javascript\nconst myObj = { \n  data: { value: 10 }, \n  id: 1 \n};\n\nObject.freeze(myObj);\n\nmyObj.id = 2; \nmyObj.data.value = 20;\nmyObj.newProp = 'test';\n\nconsole.log(myObj.id);\nconsole.log(myObj.data.value);\nconsole.log(myObj.newProp);\n```\n\nAssuming strict mode is *not* enabled, what will be the output of the `console.log` statements?",
          "answer": "1\n20\nundefined",
          "options": [
            "1\n10\nundefined",
            "2\n20\nundefined",
            "1\n20\nundefined",
            "1\n10\n'test'"
          ],
          "analysisPoints": [
            "Understanding that `Object.freeze` is shallow.",
            "Knowing that `Object.freeze` prevents modification of top-level properties (like `id`) in non-strict mode.",
            "Knowing that `Object.freeze` prevents adding new properties.",
            "Understanding that nested objects are *not* frozen and their properties can still be modified."
          ],
          "keyConcepts": [
            "Object.freeze",
            "Shallow immutability",
            "Strict mode",
            "Object properties"
          ],
          "evaluationCriteria": [
            "Correctly identifying shallow nature of Object.freeze.",
            "Predicting silent failures in non-strict mode for direct property assignments.",
            "Predicting the successful modification of nested object properties."
          ],
          "example": "Explanation:\n1. `myObj.id = 2;` Fails silently because `myObj` is frozen. `id` remains `1`.\n2. `myObj.data.value = 20;` Succeeds because `Object.freeze` is shallow; only `myObj` itself is frozen, not the `data` object nested within it. So, `myObj.data` is a reference to the original object, which is still mutable.\n3. `myObj.newProp = 'test';` Fails silently because `myObj` is frozen and new properties cannot be added. `myObj.newProp` will be `undefined`.\n\nTherefore, the output is `1`, `20`, `undefined`.",
          "tags": [
            "JavaScript",
            "Objects",
            "Mutability",
            "Object.freeze"
          ],
          "prerequisites": [
            "javascript_objects",
            "object_references"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_object_methods_3",
          "topic": "Object Cloning",
          "level": "hard",
          "type": "code",
          "question": "Write a JavaScript function `isDeepEqual(obj1, obj2)` that performs a deep comparison between two JavaScript objects. The function should return `true` if the objects are deeply equal, and `false` otherwise. Consider primitive values, arrays, and nested objects. You do NOT need to handle functions, Dates, RegExp, Symbols, or circular references for this problem.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Handling primitive type comparisons.",
            "Recursively comparing nested objects.",
            "Iterating over object keys for comparison.",
            "Handling array comparisons (length and element-by-element deep comparison).",
            "Checking for same number of keys."
          ],
          "keyConcepts": [
            "Deep equality",
            "Recursion",
            "Object iteration",
            "Type checking"
          ],
          "evaluationCriteria": [
            "Correctness of recursive logic.",
            "Handling of different data types (primitives, objects, arrays).",
            "Efficiency (avoiding unnecessary iterations).",
            "Edge case handling (empty objects/arrays, null/undefined inputs)."
          ],
          "example": "```javascript\nfunction isDeepEqual(obj1, obj2) {\n  if (obj1 === obj2) return true; // Strict equality check for primitives and same object reference\n\n  if (typeof obj1 !== 'object' || obj1 === null || typeof obj2 !== 'object' || obj2 === null) {\n    return false; // If not objects or one is null, and not strictly equal, they are not deep equal\n  }\n\n  // Handle Arrays\n  if (Array.isArray(obj1) && Array.isArray(obj2)) {\n    if (obj1.length !== obj2.length) return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqual(obj1[i], obj2[i])) return false;\n    }\n    return true;\n  }\n\n  // If one is array and other is not, they are not deep equal\n  if (Array.isArray(obj1) !== Array.isArray(obj2)) return false;\n\n  // Handle Objects\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n\n  if (keys1.length !== keys2.length) return false; // Different number of properties\n\n  for (const key of keys1) {\n    if (!keys2.includes(key) || !isDeepEqual(obj1[key], obj2[key])) {\n      return false; // Key missing or values not deep equal\n    }\n  }\n\n  return true;\n}\n\n// Test cases\nconst objA = { a: 1, b: { c: 2, d: [3, 4] }, e: 'test' };\nconst objB = { a: 1, b: { c: 2, d: [3, 4] }, e: 'test' };\nconst objC = { a: 1, b: { c: 2, d: [3, 5] }, e: 'test' };\nconst objD = { a: 1, b: { c: 2 }, e: 'test' };\n\nconsole.log(isDeepEqual(objA, objB)); // true\nconsole.log(isDeepEqual(objA, objC)); // false\nconsole.log(isDeepEqual(objA, objD)); // false\nconsole.log(isDeepEqual(null, null)); // true\nconsole.log(isDeepEqual(1, 1));       // true\nconsole.log(isDeepEqual(1, '1'));     // false\nconsole.log(isDeepEqual({}, {}));     // true\nconsole.log(isDeepEqual([], []));     // true\nconsole.log(isDeepEqual([1, {a:1}], [1, {a:1}])); // true\nconsole.log(isDeepEqual([1, {a:1}], [1, {a:2}])); // false\n```",
          "tags": [
            "JavaScript",
            "Objects",
            "Comparison",
            "Algorithm",
            "Recursion"
          ],
          "prerequisites": [
            "javascript_objects",
            "recursion",
            "array_methods"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_object_methods_4",
          "topic": "Object Iteration and Transformation",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following methods would you use to get an array of `[key, value]` pairs from an object, and then transform that array back into a new object?",
          "answer": "Object.entries() followed by Object.fromEntries()",
          "options": [
            "Object.keys() followed by Array.prototype.reduce()",
            "Object.values() followed by new Map().forEach()",
            "Object.entries() followed by Object.fromEntries()",
            "Object.assign() followed by Object.keys()"
          ],
          "analysisPoints": [
            "Understanding the purpose of `Object.entries()` (key-value pairs).",
            "Understanding the purpose of `Object.fromEntries()` (creating object from entries).",
            "Recognizing other options are not directly designed for this specific transformation or are less direct."
          ],
          "keyConcepts": [
            "Object.entries",
            "Object.fromEntries",
            "Object iteration",
            "Object transformation"
          ],
          "evaluationCriteria": [
            "Correct identification of inverse methods for object-to-array and array-to-object conversion.",
            "Distinguishing between methods that return keys, values, or entries."
          ],
          "example": "```javascript\nconst myObject = { a: 1, b: 2 };\n\n// Get key-value pairs\nconst entries = Object.entries(myObject);\nconsole.log(entries); // [['a', 1], ['b', 2]]\n\n// Transform back into a new object\nconst newObject = Object.fromEntries(entries);\nconsole.log(newObject); // { a: 1, b: 2 }\n```",
          "tags": [
            "JavaScript",
            "Objects",
            "ES2019",
            "Iteration"
          ],
          "prerequisites": [
            "javascript_objects",
            "array_methods"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_object_methods_5",
          "topic": "Shallow vs. Deep Copy",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference between a shallow copy and a deep copy of an object?",
          "answer": "A shallow copy creates a new object and copies top-level properties. Nested objects are still referenced, meaning changes to nested properties in the copy will affect the original. A deep copy creates a completely independent copy, including all nested objects, so changes to the copy do not affect the original.",
          "analysisPoints": [
            "Understanding reference vs. value copy for nested structures.",
            "Impact of modification on original object for both types of copies."
          ],
          "keyConcepts": [
            "Shallow copy",
            "Deep copy",
            "Object reference",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Accuracy and clarity of distinction"
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "Objects",
            "Cloning",
            "Memory Management"
          ],
          "prerequisites": [
            "javascript_objects",
            "object_references"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_object_destructuring_1",
          "topic": "Basic Object Destructuring",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of using object destructuring in JavaScript?",
          "answer": "It provides a more concise and readable way to extract properties from objects and assign them to variables, reducing boilerplate code and making it clearer which properties are being used.",
          "analysisPoints": [
            "Conciseness.",
            "Readability.",
            "Reduction of boilerplate."
          ],
          "keyConcepts": [
            "Destructuring",
            "Readability",
            "Conciseness"
          ],
          "evaluationCriteria": [
            "Understanding of core benefit"
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "ES6",
            "Destructuring",
            "Readability"
          ],
          "prerequisites": [
            "javascript_objects"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_object_destructuring_2",
          "topic": "Object Destructuring Patterns",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following object:\n\n```javascript\nconst settings = {\n  theme: 'dark',\n  fontSize: 16,\n  user: {\n    id: 'user123',\n    name: 'Alice',\n    email: 'alice@example.com'\n  }\n};\n\nconst { \n  theme: currentTheme,\n  notifications = true,\n  user: { name: userName, status = 'active' },\n  ...restOfSettings\n} = settings;\n\nconsole.log(currentTheme);\nconsole.log(notifications);\nconsole.log(userName);\nconsole.log(status);\nconsole.log(restOfSettings);\n```\n\nWhat will be the output of the `console.log` statements?",
          "answer": "dark\ntrue\nAlice\nactive\n{ fontSize: 16 }",
          "options": [
            "dark\ntrue\nAlice\nactive\n{ fontSize: 16 }",
            "dark\nundefined\nAlice\nundefined\n{ fontSize: 16 }",
            "dark\ntrue\nundefined\nactive\n{ fontSize: 16, user: { ... } }",
            "dark\ntrue\nAlice\nundefined\n{ fontSize: 16 }"
          ],
          "analysisPoints": [
            "Correct application of aliasing (renaming) for `theme`.",
            "Correct application of default values for `notifications` and `status`.",
            "Correct application of nested destructuring for `user.name`.",
            "Correct application of the rest pattern (`...restOfSettings`).",
            "Understanding that `user` property is consumed by nested destructuring and not included in `restOfSettings`."
          ],
          "keyConcepts": [
            "Destructuring aliasing",
            "Default values",
            "Nested destructuring",
            "Rest pattern"
          ],
          "evaluationCriteria": [
            "Accuracy in applying multiple destructuring features simultaneously.",
            "Correctly identifying which properties are extracted and which remain in the rest object."
          ],
          "example": "Explanation:\n1. `theme: currentTheme`: `theme` property is destructured and assigned to `currentTheme`. Output: `dark`.\n2. `notifications = true`: `notifications` property does not exist in `settings`, so its default value `true` is used. Output: `true`.\n3. `user: { name: userName, status = 'active' }`: Nested destructuring extracts `name` from `user` and renames it to `userName`. `status` does not exist in `user`, so its default `active` is used. Output: `Alice`, `active`.\n4. `...restOfSettings`: Collects all remaining enumerable properties not explicitly destructured. `theme` and `user` were destructured. `fontSize` is the only remaining top-level property. Output: `{ fontSize: 16 }`.",
          "tags": [
            "JavaScript",
            "ES6",
            "Destructuring",
            "Syntax"
          ],
          "prerequisites": [
            "javascript_objects"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_object_destructuring_3",
          "topic": "Destructuring in Function Parameters",
          "level": "medium",
          "type": "open",
          "question": "Explain the advantages of using object destructuring in function parameters. Provide a small code example demonstrating its use for a function that expects a configuration object.",
          "answer": "Using object destructuring in function parameters provides several advantages:\n1.  **Readability:** It clearly indicates which properties the function expects from the input object, making the function's signature more expressive than just `(config)`. This acts as a form of self-documentation.\n2.  **Conciseness:** It directly assigns the object properties to variables, eliminating the need for repetitive `config.propertyName` access inside the function body.\n3.  **Flexibility with Defaults:** You can easily provide default values for optional parameters directly in the signature, simplifying error handling for missing properties.\n4.  **Order Independence:** Unlike positional arguments, the order of properties in the input object does not matter.\n\n```javascript\nfunction createUser({ id, name, email, role = 'user', isActive = true }) {\n  console.log(`Creating user:`);\n  console.log(`ID: ${id}`);\n  console.log(`Name: ${name}`);\n  console.log(`Email: ${email}`);\n  console.log(`Role: ${role}`);\n  console.log(`Active: ${isActive}`);\n}\n\n// Usage 1: All properties provided\ncreateUser({\n  id: 'u001',\n  name: 'John Doe',\n  email: 'john.doe@example.com',\n  role: 'admin'\n});\n\n// Usage 2: Some properties are missing, default values will be used\ncreateUser({\n  id: 'u002',\n  name: 'Jane Smith',\n  email: 'jane.smith@example.com'\n});\n```",
          "analysisPoints": [
            "Identification of readability as a key advantage.",
            "Explanation of conciseness and reduced boilerplate.",
            "Mention of default values for optional parameters.",
            "Discussion of order independence.",
            "Provision of a clear and correct code example."
          ],
          "keyConcepts": [
            "Destructuring",
            "Function parameters",
            "Readability",
            "Default values",
            "API design"
          ],
          "evaluationCriteria": [
            "Clarity and completeness of explanation.",
            "Correctness and relevance of code example.",
            "Demonstration of practical benefits."
          ],
          "example": null,
          "tags": [
            "JavaScript",
            "ES6",
            "Destructuring",
            "Functions",
            "Best Practices"
          ],
          "prerequisites": [
            "javascript_functions",
            "javascript_objects"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_jsx_1",
          "topic": "JSX Fundamentals",
          "level": "easy",
          "type": "flashcard",
          "question": "What does JSX stand for, and what is its primary purpose in React?",
          "answer": "JSX stands for JavaScript XML. Its primary purpose in React is to allow developers to write HTML-like code within JavaScript, providing a declarative way to describe the user interface components.",
          "analysisPoints": [
            "Correct abbreviation.",
            "Understanding of its role as a syntax extension.",
            "Purpose of declarative UI."
          ],
          "keyConcepts": [
            "JSX",
            "React",
            "Declarative UI",
            "Syntax Extension"
          ],
          "evaluationCriteria": [
            "Accuracy of definition",
            "Clarity of purpose"
          ],
          "example": null,
          "tags": [
            "React",
            "JSX",
            "Fundamentals"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 10,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_jsx_2",
          "topic": "JSX Expressions and Transpilation",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements about JSX and JavaScript expressions is true?\n\n```jsx\nconst count = 5;\nconst isValid = true;\nconst myArray = ['A', 'B'];\n\nconst element = (\n  <div>\n    <p>Count: {count}</p>\n    <p>{isValid ? 'Valid' : 'Invalid'}</p>\n    <ul>\n      {myArray.map((item, index) => (\n        <li key={index}>{item}</li>\n      ))}\n    </ul>\n  </div>\n);\n```",
          "answer": "JavaScript expressions can be embedded within JSX using curly braces `{}`.",
          "options": [
            "JSX is directly understood by web browsers without any processing.",
            "Only primitive data types (strings, numbers) can be embedded within JSX using curly braces.",
            "JavaScript expressions can be embedded within JSX using curly braces `{}`.",
            "JSX elements are standard HTML elements and do not require a transpiler."
          ],
          "analysisPoints": [
            "Understanding that JSX requires transpilation (e.g., by Babel).",
            "Knowing that any valid JavaScript expression can be embedded in JSX using `{}`.",
            "Recognizing that `map` and ternary operators are valid expressions for dynamic content."
          ],
          "keyConcepts": [
            "JSX",
            "JavaScript expressions",
            "Transpilation",
            "Babel",
            "Dynamic content"
          ],
          "evaluationCriteria": [
            "Correctly identifying the mechanism for embedding JS in JSX.",
            "Dispelling common misconceptions about JSX processing and capabilities."
          ],
          "example": "Explanation:\n1.  JSX is *not* directly understood by browsers; it must be transpiled, typically by Babel, into `React.createElement()` calls.\n2.  Any valid JavaScript expression can be embedded, including complex logic like ternary operators, function calls, and array `map` methods, not just primitives.\n3.  The example clearly shows `count` (number), `isValid ? 'Valid' : 'Invalid'` (ternary expression), and `myArray.map(...)` (array method) all embedded within `{}`. This demonstrates that arbitrary JavaScript expressions can be used.\n4.  JSX elements are not standard HTML; they are a syntactic sugar that gets converted to JavaScript calls (`React.createElement`).",
          "tags": [
            "React",
            "JSX",
            "Transpilation",
            "Expressions"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_jsx_3",
          "topic": "JSX Attributes and Fragments",
          "level": "medium",
          "type": "open",
          "question": "When working with JSX, what are `className` and `htmlFor` used for, and why are they preferred over their HTML counterparts (`class`, `for`)? Additionally, explain why a React component's `render` method (or functional component return) often needs to return a single root element or use a `React.Fragment`.",
          "answer": "`className` and `htmlFor` are JSX attributes used in React to correspond to the HTML `class` and `for` attributes, respectively. They are preferred because `class` and `for` are reserved keywords in JavaScript. Since JSX is JavaScript, using these keywords directly would cause syntax errors. `className` maps to the `class` attribute for CSS styling, and `htmlFor` maps to the `for` attribute for associating labels with form controls.\n\nA React component's `render` method (or a functional component's return) needs to return a single root element (e.g., `<div>...</div>`) or use a `React.Fragment` (`<>...</>`) because:\n1.  **DOM Structure:** JSX compiles down to `React.createElement()` calls. A component's `render` method effectively returns a single JavaScript object representing the top-level element. If multiple top-level elements were returned, React wouldn't know which one to consider the root, leading to ambiguity in the DOM tree construction.\n2.  **Reconciliation:** React's reconciliation algorithm relies on comparing a single root node efficiently. Having multiple root nodes would complicate this process.\n3.  **Returning Arrays:** While it's technically possible to return an array of elements (each with a unique `key`), it's generally discouraged for top-level returns in favor of Fragments, as Fragments specifically address the need for a single parent without adding an extra DOM node.\n\n`React.Fragment` (or its shorthand `<></>`) is a special component that allows you to group multiple elements without adding an extra DOM node to the tree. This is useful when you want to return multiple elements without affecting the layout or styling with an unnecessary wrapper `div`.",
          "analysisPoints": [
            "Correctly identifying `className` and `htmlFor` as JSX attribute conventions.",
            "Explaining the reason for these conventions (reserved JS keywords).",
            "Explaining the single root element rule in React components.",
            "Relating the rule to underlying `React.createElement` calls and DOM structure.",
            "Explaining the purpose and benefit of `React.Fragment` (no extra DOM node)."
          ],
          "keyConcepts": [
            "JSX attributes",
            "className",
            "htmlFor",
            "React.Fragment",
            "Single root element",
            "DOM structure",
            "Reconciliation"
          ],
          "evaluationCriteria": [
            "Thoroughness of explanation for attribute naming.",
            "Clarity of reasoning for the single root element rule.",
            "Accurate description of `React.Fragment`'s role."
          ],
          "example": null,
          "tags": [
            "React",
            "JSX",
            "Attributes",
            "Fragments",
            "DOM",
            "Best Practices"
          ],
          "prerequisites": [
            "react_basics",
            "html_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_object_methods_1",
          "title": "Create a Robust Object Transformation Utility",
          "description": "\nDevelop a JavaScript utility function `transformObject(inputObject, transformationMap)` that takes an `inputObject` and a `transformationMap` object. The function should:\n\n1.  Create a *new* object (a deep copy of `inputObject` if it contains nested objects/arrays, otherwise a shallow copy).\n2.  Apply transformations specified in `transformationMap`. Each key in `transformationMap` represents a property name from the `inputObject` that needs to be renamed or its value transformed.\n    *   If `transformationMap[key]` is a string, it means rename `key` to `transformationMap[key]`.\n    *   If `transformationMap[key]` is a function, it means transform the value of `key` using this function. The function receives the original value and should return the new value.\n    *   Properties not in `transformationMap` should be copied as is.\n\nConsider the following edge cases:\n*   `inputObject` might be empty.\n*   `transformationMap` might be empty.\n*   `transformationMap` might contain keys not present in `inputObject`.\n*   `inputObject` can have nested objects and arrays that need to be deeply cloned.\n\n**Note**: For deep cloning, you can use `JSON.parse(JSON.stringify())` for simplicity, but be aware of its limitations (functions, Dates etc. will not be copied correctly). For this task, assume objects contain only primitive values, arrays, and other plain objects (JSON-serializable data).\n",
          "difficulty": "hard",
          "startingCode": "function transformObject(inputObject, transformationMap) {\n  if (!inputObject || typeof inputObject !== 'object') {\n    return inputObject; // Return primitives or null/undefined as is\n  }\n\n  // Step 1: Create a deep copy of the inputObject\n  // For this task, we can use JSON serialization for simplicity given the constraints.\n  // A more robust solution for general deep copy would involve recursion.\n  const newObject = JSON.parse(JSON.stringify(inputObject));\n\n  const result = {};\n\n  // Step 2: Iterate over the copied object's entries or keys to apply transformations\n  // TODO: Implement transformation logic here\n\n  return result;\n}\n",
          "solutionCode": "function transformObject(inputObject, transformationMap) {\n  if (!inputObject || typeof inputObject !== 'object' || Array.isArray(inputObject)) {\n    // For simplicity, we'll only process plain objects. Arrays and primitives are returned as is.\n    // A full solution would recursively deep copy arrays as well.\n    return inputObject;\n  }\n\n  // Step 1: Create a deep copy of the inputObject.\n  // We use JSON.parse(JSON.stringify) for simplicity, aware of its limitations.\n  const clonedObject = JSON.parse(JSON.stringify(inputObject));\n\n  const result = {};\n\n  // Step 2: Iterate over the cloned object's own properties\n  for (const key in clonedObject) {\n    if (Object.prototype.hasOwnProperty.call(clonedObject, key)) {\n      const originalValue = clonedObject[key];\n      const transformRule = transformationMap[key];\n\n      if (transformRule) {\n        if (typeof transformRule === 'string') {\n          // Rename property\n          result[transformRule] = originalValue;\n        } else if (typeof transformRule === 'function') {\n          // Transform value\n          const newValue = transformRule(originalValue);\n          result[key] = newValue;\n        } else {\n          // If transformationMap[key] is neither string nor function, copy as is\n          result[key] = originalValue;\n        }\n      } else {\n        // Copy property as is if no transformation rule exists\n        result[key] = originalValue;\n      }\n    }\n  }\n\n  return result;\n}\n",
          "testCases": [
            "transformObject({ a: 1, b: 'hello' }, { a: 'newA', b: (val) => val.toUpperCase() }) should return { newA: 1, b: 'HELLO' }",
            "transformObject({ x: 10, y: { z: 20 } }, { x: 'newX' }) should return { newX: 10, y: { z: 20 } } (deep copy of y)",
            "transformObject({ count: 5 }, {}) should return { count: 5 }",
            "transformObject({}, { a: 'newA' }) should return {}",
            "transformObject({ price: 100 }, { price: (val) => val * 1.2 }) should return { price: 120 }",
            "transformObject({ id: 'abc', data: { value: 123 } }, { id: (val) => `ITEM_${val.toUpperCase()}`, data: 'info' }) should return { id: 'ITEM_ABC', info: { value: 123 } }"
          ],
          "hints": [
            "Start by creating a copy of the `inputObject`. Consider the nuances of shallow vs. deep copy.",
            "Iterate over the keys of the `inputObject` to decide whether to rename, transform, or simply copy each property.",
            "Use `hasOwnProperty` when iterating with `for...in` to ensure you're only processing own properties.",
            "Remember to create a *new* object for the `result` to ensure immutability of the original."
          ],
          "tags": [
            "JavaScript",
            "Objects",
            "Cloning",
            "Transformation",
            "Utility",
            "Immutability"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "javascript_objects",
            "object_methods",
            "deep_copy_concepts"
          ],
          "complexity": 8,
          "interviewRelevance": 7,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Object.assign",
            "Object.keys",
            "Object.entries",
            "hasOwnProperty",
            "JSON_serialization"
          ]
        },
        {
          "id": "task_object_destructuring_1",
          "title": "Process User Profile Data with Destructuring",
          "description": "\nWrite a JavaScript function `formatUserProfile(userProfile)` that takes a `userProfile` object as an argument. The function should use object destructuring (including nested destructuring, default values, and aliases if appropriate) to extract and format specific user information into a readable string. \n\n**Requirements:**\n1.  The `userProfile` object will have the following structure:\n    ```javascript\n    {\n      id: 'some-uuid',\n      personalInfo: {\n        firstName: 'John',\n        lastName: 'Doe',\n        email: 'john.doe@example.com'\n      },\n      contact: {\n        phone: '123-456-7890', // Optional\n        address: { // Optional\n          street: '123 Main St',\n          city: 'Anytown',\n          zip: '12345'\n        }\n      },\n      preferences: {\n        theme: 'light', // Optional, default to 'dark'\n        notifications: true // Optional, default to false\n      },\n      status: 'active' // Optional, default to 'unknown'\n    }\n    ```\n2.  Extract `firstName`, `lastName`, `email`, `phone`, `city`, `theme`, `notifications`, and `status`.\n3.  Rename `firstName` to `first`, and `lastName` to `last` during destructuring.\n4.  Provide default values:\n    *   `phone`: 'N/A'\n    *   `city`: 'Unknown City'\n    *   `theme`: 'dark'\n    *   `notifications`: `false`\n    *   `status`: 'unknown'\n5.  Return a formatted string in the following format:\n    `User: [first] [last] ([email]) | Phone: [phone] | Location: [city] | Theme: [theme] | Notifications: [notifications] | Status: [status]`\n",
          "difficulty": "medium",
          "startingCode": "function formatUserProfile(userProfile) {\n  // TODO: Use object destructuring to extract and rename properties, and set default values.\n  // const { ... } = userProfile;\n\n  // TODO: Construct the formatted string.\n  return `User: ...`;\n}\n\n// Example usage:\n// const profile1 = {\n//   id: 'user1',\n//   personalInfo: { firstName: 'Alice', lastName: 'Smith', email: 'alice@example.com' },\n//   contact: { phone: '987-654-3210' },\n//   preferences: { theme: 'light' },\n//   status: 'active'\n// };\n// console.log(formatUserProfile(profile1));\n\n// const profile2 = {\n//   id: 'user2',\n//   personalInfo: { firstName: 'Bob', lastName: 'Johnson', email: 'bob@example.com' },\n//   // Missing contact, preferences, and status\n// };\n// console.log(formatUserProfile(profile2));",
          "solutionCode": "function formatUserProfile(userProfile) {\n  const {\n    personalInfo: { firstName: first, lastName: last, email },\n    contact: { phone = 'N/A', address: { city = 'Unknown City' } = {} } = {},\n    preferences: { theme = 'dark', notifications = false } = {},\n    status = 'unknown'\n  } = userProfile;\n\n  return `User: ${first} ${last} (${email}) | Phone: ${phone} | Location: ${city} | Theme: ${theme} | Notifications: ${notifications} | Status: ${status}`;\n}\n",
          "testCases": [
            "formatUserProfile({\n  id: 'user1',\n  personalInfo: { firstName: 'Alice', lastName: 'Smith', email: 'alice@example.com' },\n  contact: { phone: '987-654-3210', address: { street: '1 Main', city: 'Metropolis', zip: '11111' } },\n  preferences: { theme: 'light', notifications: true },\n  status: 'active'\n}) should return 'User: Alice Smith (alice@example.com) | Phone: 987-654-3210 | Location: Metropolis | Theme: light | Notifications: true | Status: active'",
            "formatUserProfile({\n  id: 'user2',\n  personalInfo: { firstName: 'Bob', lastName: 'Johnson', email: 'bob@example.com' }\n  // Missing contact, preferences, and status\n}) should return 'User: Bob Johnson (bob@example.com) | Phone: N/A | Location: Unknown City | Theme: dark | Notifications: false | Status: unknown'",
            "formatUserProfile({\n  id: 'user3',\n  personalInfo: { firstName: 'Charlie', lastName: 'Brown', email: 'charlie@example.com' },\n  contact: {}, // Empty contact object\n  preferences: { notifications: true } // Missing theme, but notifications is present\n}) should return 'User: Charlie Brown (charlie@example.com) | Phone: N/A | Location: Unknown City | Theme: dark | Notifications: true | Status: unknown'",
            "formatUserProfile({}) should handle gracefully and return 'User: undefined undefined (undefined) | Phone: N/A | Location: Unknown City | Theme: dark | Notifications: false | Status: unknown'"
          ],
          "hints": [
            "Start with the outermost destructuring, then progressively move to nested objects.",
            "Remember to provide default values for both properties and entire nested objects that might be missing.",
            "For deeply nested optional properties (like `address`), you might need to use an empty object `{}` as a default value for the intermediate object (`contact`) to prevent errors when trying to destructure properties from it.",
            "Pay close attention to parentheses and curly braces when nesting default values with destructuring."
          ],
          "tags": [
            "JavaScript",
            "Destructuring",
            "ES6",
            "Objects",
            "Data Formatting",
            "Frontend"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "javascript_objects",
            "object_destructuring"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Template Literals",
            "Optional Chaining"
          ]
        },
        {
          "id": "task_react_jsx_1",
          "title": "Create a Dynamic Product Card Component (JSX Concept)",
          "description": "\nImagine you are building a React application. Your task is to conceptualize and write the JSX for a `ProductCard` component. This component should display product information dynamically based on props it receives.\n\n**Requirements:**\n1.  The component should accept a `product` prop, which is an object with the following structure:\n    ```javascript\n    {\n      id: 'P123',\n      name: 'Wireless Headphones',\n      price: 129.99,\n      inStock: true,\n      imageUrl: 'https://example.com/headphones.jpg',\n      description: 'High-fidelity audio with noise cancellation.', // Optional\n      rating: 4.5 // Optional\n    }\n    ```\n2.  Render the product's `name` in an `<h2>` tag.\n3.  Display the `price` in a `<p>` tag, formatted as currency (e.g., '$129.99').\n4.  Conditionally render a 'SOLD OUT' `<span>` tag if `inStock` is `false`. Otherwise, render an 'Add to Cart' `<button>`.\n5.  Render the `imageUrl` as an `<img>` tag with `alt` text set to the product's `name`.\n6.  If `description` is provided, render it in a `<p>` tag. Otherwise, render nothing for the description.\n7.  If `rating` is provided, display it as 'Rating: [rating]/5' in a `<p>` tag.\n8.  The entire component should be wrapped in a single `div` with `className=\"product-card\"`.\n\nYour solution should only provide the JSX structure that would be returned by a functional React component, demonstrating how JavaScript expressions are embedded and how conditional rendering is handled within JSX.",
          "difficulty": "medium",
          "startingCode": "function ProductCard({ product }) {\n  // Assume 'product' object is destructured here\n  // const { id, name, price, inStock, imageUrl, description, rating } = product;\n\n  return (\n    // TODO: Implement the JSX structure here\n    // Remember the single root element rule and how to embed JS expressions.\n    <div>\n      {/* Product Name */}\n      {/* Price */}\n      {/* Stock Status / Add to Cart */}\n      {/* Image */}\n      {/* Description (conditional) */}\n      {/* Rating (conditional) */}\n    </div>\n  );\n}\n",
          "solutionCode": "function ProductCard({ product }) {\n  const { \n    name, \n    price, \n    inStock, \n    imageUrl, \n    description, \n    rating \n  } = product;\n\n  return (\n    <div className=\"product-card\">\n      <h2>{name}</h2>\n      <p>Price: ${price.toFixed(2)}</p>\n      \n      {inStock ? (\n        <button>Add to Cart</button>\n      ) : (\n        <span style={{ color: 'red', fontWeight: 'bold' }}>SOLD OUT</span>\n      )}\n\n      <img src={imageUrl} alt={name} style={{ maxWidth: '100px', height: 'auto' }} />\n      \n      {description && <p>{description}</p>}\n\n      {rating && <p>Rating: {rating}/5</p>}\n    </div>\n  );\n}\n\n// Conceptual usage for demonstration:\n// const sampleProduct1 = {\n//   id: 'P123',\n//   name: 'Wireless Headphones',\n//   price: 129.99,\n//   inStock: true,\n//   imageUrl: 'https://via.placeholder.com/150/0000FF/FFFFFF?text=Headphones',\n//   description: 'High-fidelity audio with noise cancellation.',\n//   rating: 4.5\n// };\n// console.log(ProductCard({ product: sampleProduct1 }));\n\n// const sampleProduct2 = {\n//   id: 'P456',\n//   name: 'Vintage Camera',\n//   price: 250.00,\n//   inStock: false,\n//   imageUrl: 'https://via.placeholder.com/150/FF0000/FFFFFF?text=Camera'\n//   // No description or rating\n// };\n// console.log(ProductCard({ product: sampleProduct2 }));\n",
          "testCases": [
            "ProductCard with full product data (inStock: true, description, rating) should render all elements correctly.",
            "ProductCard with product out of stock (inStock: false) should show 'SOLD OUT' and no 'Add to Cart' button.",
            "ProductCard with missing optional fields (description, rating) should not render paragraphs for those fields.",
            "ProductCard should wrap all content in a `div` with `className=\"product-card\"`.",
            "Price should be formatted to two decimal places.",
            "Image `alt` attribute should correctly use the product `name`."
          ],
          "hints": [
            "Use curly braces `{}` to embed JavaScript variables and expressions directly into your JSX.",
            "For conditional rendering, consider using the ternary operator (`condition ? <TrueComponent /> : <FalseComponent />`) or logical AND (`condition && <Component />`).",
            "Remember that attributes like `class` become `className` in JSX, and inline styles require a JavaScript object (e.g., `style={{ color: 'red' }}`).",
            "For optional props like `description` and `rating`, a simple `&&` operator is often sufficient to conditionally render an element only if the prop exists and is truthy."
          ],
          "tags": [
            "React",
            "JSX",
            "Components",
            "Conditional Rendering",
            "Props",
            "Frontend"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_jsx",
            "javascript_objects",
            "object_destructuring"
          ],
          "complexity": 6,
          "interviewRelevance": 10,
          "learningPath": "beginner",
          "relatedConcepts": [
            "Functional Components",
            "Props",
            "Styling in React"
          ]
        }
      ]
    }
  },
  {
    "id": "b36e3e91-e1b7-4efb-b48d-563618570d6f",
    "startLine": 2600,
    "endLine": 2699,
    "processedDate": "2025-06-17T08:24:36.995Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_jsx_fundamentals",
          "title": "JSX Fundamentals and Differences from HTML",
          "content": "JSX (JavaScript XML) is a syntax extension for JavaScript, commonly used with React to describe what the UI should look like. It allows you to write HTML-like syntax directly within your JavaScript code, which then gets transpiled into standard JavaScript function calls.\n\n## Multiline JSX\nWhen writing JSX across multiple lines, it must be wrapped in parentheses `()` to prevent automatic semicolon insertion from breaking the code. This ensures the entire JSX structure is treated as a single expression.\n\n## JSX vs. HTML Differences\nWhile JSX appears similar to HTML, there are crucial differences, primarily due to JSX being JavaScript under the hood:\n\n1.  **Attribute Naming (camelCase):** HTML attributes like `class` and `onclick` are reserved keywords in JavaScript or conflict with JavaScript naming conventions. Therefore, JSX uses camelCase for most attributes, such as `className` instead of `class` for CSS classes, and `onClick` instead of `onclick` for event handlers. Event handlers in JSX receive a JavaScript function reference directly, not a string of code.\n\n2.  **Self-Closing Tags:** In HTML, some tags like `<img>`, `<input>`, `<br>` can be self-closing (e.g., `<img src=\"image.jpg\">`) or explicitly closed (e.g., `<img></img>`). In JSX, all tags that do not have children must be explicitly self-closed with a trailing slash (`/`) before the closing angle bracket (e.g., `<img src=\"image.jpg\" />`). This applies to custom components as well.\n\n3.  **Style Attribute:** Unlike HTML where the `style` attribute takes a string of CSS rules, in JSX, the `style` attribute expects a JavaScript object. CSS property names within this object are also written in camelCase (e.g., `fontSize` instead of `font-size`), and their values are typically strings (for units) or numbers.\n\nThese differences are essential for writing valid and functional React components using JSX.",
          "examples": [
            {
              "id": "example_jsx_fundamentals_1",
              "title": "Basic Multiline JSX and Attributes",
              "code": "const element = (\n  <div>\n    <h1>Hello!</h1>\n    <p className=\"welcome-text\" onClick={() => console.log('Welcome clicked!')}>\n      Welcome to React\n    </p>\n    <img src=\"logo.png\" alt=\"React Logo\" />\n  </div>\n);\n\n// Example of inline style object\nconst styledElement = <div style={{ color: 'blue', fontSize: '20px' }}>Styled Text Example</div>;",
              "explanation": "This example demonstrates several key JSX features: The `div` is a multiline JSX element, hence wrapped in parentheses. `className` is used instead of `class` for the `p` tag. `onClick` is used for the event handler, receiving a function. The `img` tag is self-closed with `/>`. Finally, an inline style is applied using a JavaScript object.",
              "language": "javascript"
            },
            {
              "id": "example_jsx_fundamentals_2",
              "title": "JSX Style Attribute with Variable",
              "code": "const primaryColor = 'red';\nconst headerFontSize = '24px';\n\nconst styles = {\n  color: primaryColor,\n  fontSize: headerFontSize,\n  backgroundColor: '#eee',\n  padding: '10px'\n};\n\nconst elementWithVariableStyles = <h2 style={styles}>Dynamically Styled Header</h2>;",
              "explanation": "This example shows how to define styles as a separate JavaScript object and then pass that object to the `style` attribute. This approach promotes readability and reusability of style definitions, especially when styles are complex or need to be conditionally applied. Note the camelCase for `backgroundColor`.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_jsx_attributes_mcq_1",
            "question_jsx_self_closing_flashcard_1",
            "question_jsx_style_open_1",
            "question_jsx_conversion_code_1"
          ],
          "relatedTasks": [
            "task_html_to_jsx_conversion"
          ],
          "tags": [
            "JSX",
            "React",
            "Frontend",
            "Syntax",
            "Beginner"
          ],
          "technology": "React",
          "prerequisites": [
            "HTML_basics",
            "JavaScript_basics"
          ],
          "complexity": 3,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "requiredFor": [
            "react_components",
            "react_dom_rendering"
          ]
        },
        {
          "id": "theory_how_jsx_works",
          "title": "How JSX Works: Compilation to React.createElement()",
          "content": "While JSX provides a convenient and readable way to write UI structures, it is not directly understood by web browsers. Browsers only understand standard JavaScript. Therefore, JSX code must be transformed, or 'transpiled,' into regular JavaScript before it can be executed in a browser.\n\nThis transformation process is typically handled by a build tool like Babel. When Babel processes JSX, it converts each JSX element into a call to `React.createElement()`.\n\n## `React.createElement()` Function\n`React.createElement()` is the function that React uses internally to create virtual DOM elements. Its signature generally looks like this:\n\n```typescript\nReact.createElement(\n  type: string | Function | Class,\n  props?: object | null,\n  ...children: ReactNode[]\n): ReactElement;\n```\n\n-   **`type`**: This argument specifies the type of the HTML element as a string (e.g., `'div'`, `'h1'`) or a reference to a React component function/class.\n-   **`props`**: This argument is an object containing all the attributes (props) passed to the element. This includes `className`, `onClick`, `style`, etc.\n-   **`children`**: Subsequent arguments are considered the children of the element. These can be strings (for text content), other `React.createElement()` calls (for nested elements), or arrays of children.\n\nThis compilation step is crucial because it bridges the gap between the declarative JSX syntax and the imperative `React.createElement()` calls that React uses to build its Virtual DOM representation of the UI. Understanding this underlying mechanism helps in debugging and comprehending how React processes your UI code.",
          "examples": [
            {
              "id": "example_how_jsx_works_1",
              "title": "JSX to React.createElement() Transformation",
              "code": "// This JSX\nconst element = <h1 className=\"greeting\">Hello, world!</h1>;\n\n// Compiles to this JavaScript\nconst compiledElement = React.createElement(\n  'h1',\n  { className: 'greeting' },\n  'Hello, world!'\n);",
              "explanation": "This example clearly shows how a simple JSX `<h1>` element with a `className` prop and text content is transformed into a `React.createElement` call. The first argument is the element type (`'h1'`), the second is an object containing props (`{ className: 'greeting' }`), and the third is the child content (`'Hello, world!'`).",
              "language": "javascript"
            },
            {
              "id": "example_how_jsx_works_2",
              "title": "Nested JSX and Children Transformation",
              "code": "// This JSX with nesting\nconst nestedElement = (\n  <div>\n    <p>Paragraph text</p>\n    <span>Span text</span>\n  </div>\n);\n\n// Compiles to this JavaScript\nconst compiledNestedElement = React.createElement(\n  'div',\n  null, // No props on the div itself\n  React.createElement('p', null, 'Paragraph text'),\n  React.createElement('span', null, 'Span text')\n);",
              "explanation": "This example demonstrates how nested JSX elements are translated into nested `React.createElement()` calls. The children of the parent `div` (the `p` and `span` elements) become subsequent arguments to the parent `React.createElement` call.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_jsx_compilation_mcq_1",
            "question_babel_role_open_1",
            "question_create_element_flashcard_1",
            "question_jsx_vs_js_performance_open_1"
          ],
          "relatedTasks": [
            "task_manual_create_element"
          ],
          "tags": [
            "JSX",
            "React",
            "Compilation",
            "Babel",
            "Virtual DOM",
            "Core Concepts"
          ],
          "technology": "React",
          "prerequisites": [
            "JSX_fundamentals",
            "JavaScript_functions"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_architecture",
            "custom_renderers"
          ]
        },
        {
          "id": "theory_why_choose_react",
          "title": "Why Choose React? Key Advantages",
          "content": "React has become one of the most popular JavaScript libraries for building user interfaces due to several compelling advantages. These benefits contribute to efficient development, high performance, and scalable applications:\n\n1.  **Reusable Components:** React encourages a component-based architecture, allowing developers to build self-contained, independent, and reusable UI pieces. Each component manages its own state and logic, making it easy to compose complex UIs from smaller, manageable parts. This reusability significantly speeds up development and reduces code duplication.\n\n2.  **High Cohesion, Low Coupling:** Components in React are designed to have 'high cohesion,' meaning they encapsulate their functionality and related data within themselves. They maintain 'low coupling,' meaning they have minimal dependencies on other components. This separation of concerns leads to more maintainable, testable, and understandable codebases.\n\n3.  **Virtual DOM Performance:** React uses a lightweight JavaScript representation of the actual DOM, known as the Virtual DOM. When the state of a component changes, React first updates the Virtual DOM, then efficiently compares this updated version with the previous Virtual DOM (a process called 'diffing'). It then calculates the minimal set of changes needed to update the real DOM. This optimized update process minimizes direct DOM manipulation, which is often slow, leading to significant performance improvements and a smoother user experience.\n\n4.  **SEO Friendly (Server-Side Rendering - SSR):** React applications can be rendered on the server-side before being sent to the client. This technique, known as Server-Side Rendering (SSR), allows search engine crawlers to fully index the content of the page, as they receive a complete HTML document rather than an empty `div` that JavaScript would fill later. This greatly improves Search Engine Optimization (SEO).\n\n5.  **Predictable Application Behavior (Unidirectional Data Flow):** React enforces a unidirectional (one-way) data flow. Data flows down from parent components to child components via props. This makes it easier to reason about how changes in data affect the application's UI, leading to more predictable behavior and simpler debugging compared to bidirectional data flows.\n\n6.  **Developer Experience (JSX):** The JSX syntax, which combines JavaScript and HTML/XML, is highly intuitive for many developers. It allows for a declarative way to describe UI components, making them easy to understand and write. This improves developer productivity and reduces the cognitive load associated with separating logic from UI.\n\n7.  **Team Development:** The component-based structure of React naturally creates clear boundaries for team collaboration. Different team members or teams can work independently on different components, and these components can be easily integrated, facilitating parallel development and faster delivery.\n\n8.  **Hierarchical Components:** React's design inherently supports a hierarchical component structure. Components that are visually nested in the UI design are naturally represented as child components within their parent components in the React component tree. This mapping between UI design and code structure makes it easier to manage and visualize the application's layout.",
          "examples": [
            {
              "id": "example_why_choose_react_1",
              "title": "Reusable Component Example",
              "code": "function Button({ onClick, label }) {\n  return (\n    <button onClick={onClick}>\n      {label}\n    </button>\n  );\n}\n\nfunction App() {\n  return (\n    <div>\n      <Button onClick={() => alert('Clicked A!')} label=\"Button A\" />\n      <Button onClick={() => console.log('Clicked B')} label=\"Button B\" />\n    </div>\n  );\n}",
              "explanation": "This example showcases component reusability. The `Button` component is defined once but can be used multiple times throughout the application with different `onClick` handlers and `label` props, demonstrating its self-contained nature and ability to be composed into larger UIs.",
              "language": "javascript"
            },
            {
              "id": "example_why_choose_react_2",
              "title": "Unidirectional Data Flow Concept",
              "code": "// Parent component\nfunction Parent() {\n  const [message, setMessage] = React.useState('Hello from Parent');\n\n  return (\n    <div>\n      <h2>Parent Component</h2>\n      <Child message={message} /> {/* Data flows down to Child */}\n    </div>\n  );\n}\n\n// Child component\nfunction Child({ message }) {\n  return (\n    <p>Child received: {message}</p>\n  );\n}",
              "explanation": "This code illustrates unidirectional data flow. The `message` state is defined in the `Parent` component and passed down to the `Child` component as a prop. The `Child` component can only read this `message` prop; it cannot directly modify it, ensuring predictable data flow and easier state management.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_virtual_dom_open_1",
            "question_react_advantages_mcq_1",
            "question_unidirectional_data_flow_flashcard_1",
            "question_seo_ssr_open_2"
          ],
          "relatedTasks": [
            "task_reusable_component_builder",
            "task_virtual_dom_concept_simulation"
          ],
          "tags": [
            "React",
            "Architecture",
            "Performance",
            "SEO",
            "Developer Experience",
            "Virtual DOM",
            "Component-Based"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript_basics",
            "DOM_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "large_scale_applications",
            "performance_optimization"
          ]
        },
        {
          "id": "theory_jsx_dynamic_rendering",
          "title": "Dynamic Rendering in JSX: Conditionals and Lists",
          "content": "JSX allows embedding JavaScript expressions within `{}`. This capability is fundamental for creating dynamic UIs that respond to data and logic. Two common patterns for dynamic rendering are conditional rendering and list rendering.\n\n## JSX with Conditional Rendering\nConditional rendering allows you to render different elements or components based on certain conditions. Common patterns include:\n\n1.  **Ternary Operator (`condition ? expression1 : expression2`):** This is useful for simple `if-else` scenarios, where you want to render one of two possible outputs based on a boolean condition.\n\n    ```javascript\n    {isLoggedIn ? <WelcomeMessage /> : <SignInPrompt />}\n    ```\n\n2.  **Logical `&&` Operator (`condition && expression`):** If you want to render something only when a condition is true, otherwise render nothing (or `null`), the logical AND operator is concise. In JavaScript, `true && expression` evaluates to `expression`, and `false && expression` evaluates to `false` (which React renders as `null` or nothing).\n\n    ```javascript\n    {hasUnreadMessages && <NotificationIcon />}\n    ```\n\n3.  **`if`/`else` Statements (outside JSX):** While you cannot use `if`/`else` directly inside JSX, you can use them in the JavaScript part of your component to return different JSX structures.\n\n    ```javascript\n    function MyComponent({ user }) {\n      if (!user) {\n        return <p>Please log in.</p>;\n      }\n      return <p>Welcome, {user.name}!</p>;\n    }\n    ```\n\n## JSX with Lists\nRendering lists of items dynamically is a very common requirement. In React, you typically use the JavaScript `Array.prototype.map()` method to transform an array of data into an array of JSX elements.\n\n### The `key` Prop\nWhen rendering lists, each item in the list **must** have a unique `key` prop. React uses this `key` prop to identify which items have changed, are added, or are removed. This helps React efficiently update the UI and maintain the state of list items, preventing potential bugs and improving performance.\n\n-   **Uniqueness:** Keys must be unique among siblings in the list. They don't need to be globally unique.\n-   **Stability:** Ideally, keys should be stable and predictable. Using item IDs from your data source is the best practice (e.g., `item.id`).\n-   **Avoid Index as Key:** Using the array index (`index`) as a `key` is generally discouraged unless the list items are static and will never be reordered, filtered, or added/removed. This is because if the order changes, React might reuse components incorrectly, leading to unexpected behavior or performance issues.",
          "examples": [
            {
              "id": "example_jsx_dynamic_rendering_1",
              "title": "Conditional Rendering Examples",
              "code": "function Greeting({ isLoggedIn }) {\n  return (\n    <div>\n      {isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please sign in.</h1>}\n    </div>\n  );\n}\n\nfunction Notification({ hasMessages }) {\n  return (\n    <div>\n      {hasMessages && <span>You have unread messages</span>}\n    </div>\n  );\n}\n\n// Usage example:\n// <Greeting isLoggedIn={true} /> // Renders Welcome back!\n// <Notification hasMessages={false} /> // Renders nothing inside the div",
              "explanation": "This example demonstrates both the ternary operator for an `if-else` type condition and the logical `&&` operator for rendering content only when a condition is true. These are common and concise ways to handle conditional display within JSX.",
              "language": "javascript"
            },
            {
              "id": "example_jsx_dynamic_rendering_2",
              "title": "List Rendering with Unique Keys",
              "code": "function NumberList({ numbers }) {\n  return (\n    <ul>\n      {numbers.map((number) => (\n        <li key={number.toString()}>{number}</li> // Assuming numbers are unique\n      ))}\n    </ul>\n  );\n}\n\nfunction TodoList({ todos }) {\n  return (\n    <ul>\n      {todos.map((todo) => (\n        <li key={todo.id}>{todo.text}</li> // Using a stable unique ID\n      ))}\n    </ul>\n  );\n}\n\n// Usage example:\n// <NumberList numbers={[1, 2, 3, 4]} />\n// <TodoList todos={[{ id: 1, text: 'Buy milk' }, { id: 2, text: 'Walk dog' }]} />",
              "explanation": "This example shows how to render a list of items using `Array.prototype.map()`. Crucially, each `<li>` element is given a unique `key` prop. For numbers, `number.toString()` is used assuming the numbers themselves are unique. For more complex objects like todos, a stable `id` property from the data is the preferred choice for the key.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_conditional_rendering_mcq_1",
            "question_key_prop_importance_open_1",
            "question_list_rendering_code_1",
            "question_index_as_key_flashcard_1"
          ],
          "relatedTasks": [
            "task_dynamic_todo_list"
          ],
          "tags": [
            "JSX",
            "React",
            "Conditional Rendering",
            "List Rendering",
            "Key Prop",
            "Performance",
            "State Management"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript_arrays",
            "JavaScript_conditionals",
            "JSX_fundamentals"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "interactive_uis",
            "data_display_components"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_jsx_attributes_mcq_1",
          "topic": "JSX vs HTML Differences",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is the correct way to apply a CSS class to a div element in JSX?",
          "answer": "<div className=\"my-class\">Hello</div>",
          "options": [
            "<div class=\"my-class\">Hello</div>",
            "<div class-name=\"my-class\">Hello</div>",
            "<div className=\"my-class\">Hello</div>",
            "<div cssClass=\"my-class\">Hello</div>"
          ],
          "analysisPoints": [
            "Understanding of `className` attribute in JSX.",
            "Distinguishing between HTML `class` and JSX `className`.",
            "Knowledge of camelCase convention in JSX attributes."
          ],
          "keyConcepts": [
            "JSX attributes",
            "camelCase",
            "className"
          ],
          "evaluationCriteria": [
            "Correct application of JSX syntax for attributes.",
            "Recognition of common JSX pitfalls."
          ],
          "example": "The `class` attribute in HTML is a reserved keyword in JavaScript. To avoid conflicts and adhere to JavaScript's camelCase convention for property names, JSX uses `className` instead of `class`.",
          "tags": [
            "JSX",
            "Attributes",
            "Syntax",
            "Beginner"
          ],
          "prerequisites": [
            "JSX_fundamentals"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_jsx_self_closing_flashcard_1",
          "topic": "JSX vs HTML Differences",
          "level": "easy",
          "type": "flashcard",
          "question": "True or False: In JSX, all tags that do not have children must be explicitly self-closed.",
          "answer": "True",
          "options": [],
          "analysisPoints": [
            "Understanding of self-closing tag requirements in JSX.",
            "Distinction from HTML's optional self-closing for some tags."
          ],
          "keyConcepts": [
            "Self-closing tags",
            "JSX syntax"
          ],
          "evaluationCriteria": [
            "Recall of fundamental JSX syntax rules."
          ],
          "example": "In JSX, `<img src=\"image.jpg\" />` is correct, whereas `<img src=\"image.jpg\">` would be an error because JSX requires explicit closure for all non-parent tags.",
          "tags": [
            "JSX",
            "Syntax",
            "Flashcard"
          ],
          "prerequisites": [
            "JSX_fundamentals"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_jsx_style_open_1",
          "topic": "JSX vs HTML Differences",
          "level": "medium",
          "type": "open",
          "question": "Explain how the `style` attribute in JSX differs from its HTML counterpart and provide a practical example of applying multiple styles.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Understanding that JSX `style` takes a JavaScript object.",
            "Knowledge of camelCase for CSS properties within the style object.",
            "Ability to provide a correct code example."
          ],
          "keyConcepts": [
            "JSX style attribute",
            "JavaScript objects",
            "Inline styles",
            "camelCase CSS properties"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation.",
            "Correctness and completeness of the code example.",
            "Demonstration of understanding of JSX-specific styling rules."
          ],
          "example": "In HTML, the `style` attribute takes a CSS string, e.g., `<div style=\"color: red; font-size: 16px;\"></div>`. In JSX, it takes a JavaScript object where CSS properties are camelCased and values are strings or numbers. For example:\n\n```javascript\nconst myStyles = {\n  color: 'blue',\n  backgroundColor: '#f0f0f0',\n  padding: '10px'\n};\n\nconst element = <div style={myStyles}>This is a styled div.</div>;\n```\n\nThis approach allows for dynamic styling using JavaScript variables and logic.",
          "tags": [
            "JSX",
            "Styling",
            "Attributes",
            "Open-Ended"
          ],
          "prerequisites": [
            "JSX_fundamentals",
            "JavaScript_objects"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_jsx_conversion_code_1",
          "topic": "JSX Fundamentals",
          "level": "medium",
          "type": "code",
          "question": "Convert the following HTML snippet into valid JSX, paying attention to all JSX-specific rules:\n\n```html\n<div class=\"card\">\n  <h2 onclick=\"showAlert('Welcome')\">Product Title</h2>\n  <img src=\"product.jpg\" alt=\"Product Image\">\n  <p style=\"margin-top: 10px; color: grey;\">A short description.</p>\n</div>\n```",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Correctly replacing `class` with `className`.",
            "Converting `onclick` string to `onClick` with a function reference.",
            "Properly self-closing the `img` tag.",
            "Transforming inline `style` string to a JavaScript object with camelCase properties."
          ],
          "keyConcepts": [
            "JSX attributes",
            "Self-closing tags",
            "Event handlers in JSX",
            "Inline styles in JSX"
          ],
          "evaluationCriteria": [
            "Syntactic correctness of the JSX output.",
            "Adherence to all specified JSX transformation rules.",
            "Ability to identify and correct common HTML-to-JSX conversion errors."
          ],
          "example": "```javascript\nfunction ProductCard() {\n  const cardStyles = { marginTop: '10px', color: 'grey' };\n\n  return (\n    <div className=\"card\">\n      <h2 onClick={() => alert('Welcome')}>Product Title</h2>\n      <img src=\"product.jpg\" alt=\"Product Image\" />\n      <p style={cardStyles}>A short description.</p>\n    </div>\n  );\n}\n```",
          "tags": [
            "JSX",
            "Code Challenge",
            "Syntax",
            "Conversion"
          ],
          "prerequisites": [
            "JSX_fundamentals"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_jsx_compilation_mcq_1",
          "topic": "How JSX Works",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JSX:\n\n```jsx\nconst myElement = <a href=\"/home\">Go Home</a>;\n```\n\nWhich of the following `React.createElement()` calls is the correct equivalent after JSX compilation?",
          "answer": "React.createElement('a', { href: '/home' }, 'Go Home')",
          "options": [
            "React.createElement('a', 'href=/home', 'Go Home')",
            "React.createElement('a', { 'href': '/home' }, 'Go Home')",
            "React.createElement('a', { href: '/home' }, 'Go Home')",
            "React.createElement('a', null, { href: '/home' }, 'Go Home')"
          ],
          "analysisPoints": [
            "Understanding the order of arguments in `React.createElement` (type, props, children).",
            "Recognizing that props are passed as a JavaScript object.",
            "Correctly identifying string literals for element type and text content."
          ],
          "keyConcepts": [
            "JSX compilation",
            "`React.createElement`",
            "Props object"
          ],
          "evaluationCriteria": [
            "Accuracy in translating JSX to `React.createElement`.",
            "Knowledge of the `React.createElement` signature."
          ],
          "example": "The `React.createElement` function takes three main arguments: the type of element (e.g., `'a'`, `'div'`, or a component), an object containing its props (attributes), and then any children (text content or other elements). Options A and D incorrectly format the props or children. Option B uses string literals for the keys which is technically valid but less common than direct property names.",
          "tags": [
            "JSX",
            "Compilation",
            "React.createElement",
            "Core Concepts"
          ],
          "prerequisites": [
            "How_JSX_Works"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_babel_role_open_1",
          "topic": "How JSX Works",
          "level": "medium",
          "type": "open",
          "question": "What is the primary role of a tool like Babel in a React project, specifically concerning JSX? Why is it necessary?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Explaining that Babel transpiles JSX to `React.createElement` calls.",
            "Mentioning that browsers don't natively understand JSX.",
            "Highlighting that it converts modern JS features to older compatible versions (though not explicitly in provided text, it's a common Babel role and good to mention for completeness)."
          ],
          "keyConcepts": [
            "Babel",
            "Transpilation",
            "JSX",
            "Browser compatibility",
            "`React.createElement`"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of the explanation.",
            "Demonstration of understanding the compilation process."
          ],
          "example": "Babel's primary role in a React project is to transpile JSX syntax into regular JavaScript that web browsers can understand. Browsers do not natively interpret JSX; they only understand standard JavaScript. Therefore, Babel transforms JSX elements like `<p>Hello</p>` into `React.createElement('p', null, 'Hello')` calls. This process is necessary because it allows developers to use the more declarative and readable JSX syntax while ensuring the code remains executable in any browser environment.",
          "tags": [
            "Babel",
            "JSX",
            "Transpilation",
            "Build Tools",
            "Open-Ended"
          ],
          "prerequisites": [
            "How_JSX_Works"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_create_element_flashcard_1",
          "topic": "How JSX Works",
          "level": "easy",
          "type": "flashcard",
          "question": "Which React function does JSX compile into?",
          "answer": "React.createElement()",
          "options": [],
          "analysisPoints": [
            "Direct recall of the core compilation target."
          ],
          "keyConcepts": [
            "JSX compilation",
            "`React.createElement`"
          ],
          "evaluationCriteria": [
            "Accuracy of recall."
          ],
          "example": "N/A",
          "tags": [
            "JSX",
            "Compilation",
            "Flashcard"
          ],
          "prerequisites": [
            "How_JSX_Works"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_jsx_vs_js_performance_open_1",
          "topic": "How JSX Works",
          "level": "hard",
          "type": "open",
          "question": "From a performance perspective, is it more efficient to write React components using raw `React.createElement()` calls or JSX? Justify your answer.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Understanding that performance is not significantly different at runtime.",
            "Acknowledging that JSX is syntactic sugar.",
            "Focusing on developer experience/readability as the main differentiator.",
            "Mentioning that optimization happens at the React reconciliation phase, not at the JSX compilation level."
          ],
          "keyConcepts": [
            "JSX",
            "`React.createElement`",
            "Performance",
            "Developer Experience",
            "Syntactic Sugar",
            "Virtual DOM"
          ],
          "evaluationCriteria": [
            "Logical reasoning.",
            "Accuracy of technical details.",
            "Ability to differentiate between development-time convenience and runtime performance."
          ],
          "example": "From a performance perspective, there is no significant difference between writing React components using raw `React.createElement()` calls and using JSX. JSX is merely syntactic sugar that gets transpiled into `React.createElement()` calls by build tools like Babel. The browser ultimately executes the same `React.createElement()` calls regardless of whether you wrote JSX or the raw function calls.\n\nThe performance of a React application is primarily determined by how React's reconciliation algorithm (which uses the Virtual DOM) efficiently updates the actual DOM, and not by the initial syntax used to define the UI structure. The choice between JSX and raw `createElement` is purely for developer convenience and readability. JSX generally leads to more readable and maintainable code, especially for complex UI structures, which indirectly improves development efficiency.",
          "tags": [
            "JSX",
            "Performance",
            "React.createElement",
            "Advanced",
            "Open-Ended"
          ],
          "prerequisites": [
            "How_JSX_Works",
            "Virtual_DOM"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_virtual_dom_open_1",
          "topic": "Why Choose React?",
          "level": "medium",
          "type": "open",
          "question": "Explain the concept of the Virtual DOM in React and how it contributes to performance.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Defining Virtual DOM as a lightweight JS representation of the real DOM.",
            "Describing the 'diffing' algorithm (comparison of current vs. previous Virtual DOM).",
            "Explaining that only necessary changes are applied to the real DOM.",
            "Highlighting that direct DOM manipulation is slow and the Virtual DOM minimizes it."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Real DOM",
            "Diffing algorithm",
            "Reconciliation",
            "Performance optimization"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of the explanation.",
            "Ability to articulate the performance benefits."
          ],
          "example": "The Virtual DOM is a lightweight JavaScript object copy of the actual browser DOM (Document Object Model). When the state of a React component changes, instead of directly manipulating the slow real DOM, React first updates its Virtual DOM representation. Then, it compares this updated Virtual DOM with the previous Virtual DOM (a process called 'diffing'). Based on this comparison, React calculates the minimal set of changes required to update the real DOM. Finally, it applies only these necessary changes to the real DOM in an optimized batch. This approach significantly improves performance because direct manipulation of the browser's real DOM is a computationally expensive operation. By minimizing the number of actual DOM updates, the Virtual DOM makes React applications fast and efficient.",
          "tags": [
            "Virtual DOM",
            "React",
            "Performance",
            "Core Concepts",
            "Open-Ended"
          ],
          "prerequisites": [
            "DOM_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_advantages_mcq_1",
          "topic": "Why Choose React?",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is NOT a primary advantage of using React for web development?",
          "answer": "Guaranteed minimal bundle size",
          "options": [
            "Reusable Components",
            "Virtual DOM Performance",
            "SEO Friendly",
            "Guaranteed minimal bundle size"
          ],
          "analysisPoints": [
            "Identifying the core advantages of React.",
            "Recognizing that while React apps can be optimized, a 'guaranteed minimal bundle size' is not an inherent advantage and depends on various factors."
          ],
          "keyConcepts": [
            "React advantages",
            "Reusable components",
            "Virtual DOM",
            "SEO",
            "Bundle size"
          ],
          "evaluationCriteria": [
            "Understanding of React's key selling points.",
            "Ability to differentiate inherent advantages from general development considerations."
          ],
          "example": "React promotes reusable components, offers performance benefits through the Virtual DOM, and can be SEO-friendly via server-side rendering. However, a 'guaranteed minimal bundle size' is not an inherent advantage of React itself. While React is relatively small, the final bundle size depends heavily on the application's overall code, included libraries, build configurations, and optimization efforts.",
          "tags": [
            "React",
            "Advantages",
            "MCQ"
          ],
          "prerequisites": [
            "Why_Choose_React"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_unidirectional_data_flow_flashcard_1",
          "topic": "Why Choose React?",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary direction of data flow in a typical React application?",
          "answer": "Unidirectional (one-way, parent to child)",
          "options": [],
          "analysisPoints": [
            "Recalling the concept of unidirectional data flow.",
            "Understanding how data passes from parent to child via props."
          ],
          "keyConcepts": [
            "Unidirectional data flow",
            "Props",
            "State management"
          ],
          "evaluationCriteria": [
            "Accuracy of recall.",
            "Understanding of a fundamental React principle."
          ],
          "example": "N/A",
          "tags": [
            "React",
            "Data Flow",
            "Flashcard"
          ],
          "prerequisites": [
            "Why_Choose_React"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_seo_ssr_open_2",
          "topic": "Why Choose React?",
          "level": "medium",
          "type": "open",
          "question": "How does React's capability to run on the server contribute to SEO-friendliness?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Explaining Server-Side Rendering (SSR).",
            "Connecting SSR to how search engine crawlers interact with web pages.",
            "Contrasting with client-side rendering where content is loaded dynamically."
          ],
          "keyConcepts": [
            "SEO",
            "Server-Side Rendering (SSR)",
            "Client-Side Rendering (CSR)",
            "Search Engine Crawlers"
          ],
          "evaluationCriteria": [
            "Clear explanation of SSR.",
            "Understanding of SEO implications.",
            "Ability to compare CSR vs. SSR in the context of SEO."
          ],
          "example": "React's capability to run on the server is known as Server-Side Rendering (SSR). This means that the initial HTML of the application can be generated on the server before being sent to the browser. When a search engine crawler (like Googlebot) visits an SSR-enabled React application, it receives a fully pre-rendered HTML page with all its content already present. This is crucial for SEO because many older or simpler crawlers might not execute JavaScript, or might do so inefficiently, thus failing to see content that is dynamically loaded by client-side JavaScript. By providing a complete HTML document upfront, SSR ensures that all content is discoverable and indexable by search engines, greatly improving the application's SEO performance compared to purely client-side rendered applications.",
          "tags": [
            "React",
            "SEO",
            "SSR",
            "Open-Ended"
          ],
          "prerequisites": [
            "Why_Choose_React"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_conditional_rendering_mcq_1",
          "topic": "Dynamic Rendering in JSX",
          "level": "medium",
          "type": "mcq",
          "question": "You want to display a 'Login' button only if the user is NOT authenticated. Which JSX conditional rendering approach is most appropriate and concise for this scenario?",
          "answer": "{!isAuthenticated && <button>Login</button>}",
          "options": [
            "{isAuthenticated ? null : <button>Login</button>}",
            "{!isAuthenticated ? <button>Login</button> : null}",
            "{!isAuthenticated && <button>Login</button>}",
            "if (!isAuthenticated) { return <button>Login</button>; } else { return null; }"
          ],
          "analysisPoints": [
            "Understanding the common patterns for conditional rendering.",
            "Identifying the most concise pattern for rendering 'if true, render X, else render nothing'.",
            "Distinguishing between `&&` operator and ternary operator for specific use cases.",
            "Knowing that `if` statements cannot be directly inside JSX."
          ],
          "keyConcepts": [
            "Conditional rendering",
            "Logical && operator",
            "Ternary operator",
            "JSX expressions"
          ],
          "evaluationCriteria": [
            "Correct application of conditional rendering syntax.",
            "Choosing the most idiomatic React/JSX solution for the given condition."
          ],
          "example": "The logical `&&` operator is often the most concise way to render something conditionally when you only care about one branch (e.g., 'if condition is true, render this component, otherwise render nothing'). Option A and B use the ternary operator which is also correct but slightly more verbose when one branch is `null`. Option D is valid JavaScript but cannot be directly embedded within JSX. The correct answer uses `!isAuthenticated && <button>Login</button>`.",
          "tags": [
            "Conditional Rendering",
            "JSX",
            "Syntax",
            "MCQ"
          ],
          "prerequisites": [
            "JSX_dynamic_rendering"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_key_prop_importance_open_1",
          "topic": "Dynamic Rendering in JSX",
          "level": "hard",
          "type": "open",
          "question": "Explain the purpose and importance of the `key` prop when rendering lists in React. What are the potential issues if `key`s are not used or used incorrectly (e.g., using array index as key for mutable lists)?",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Defining `key` as a unique identifier for list items.",
            "Explaining how React uses `key` for efficient reconciliation (diffing).",
            "Discussing performance benefits (minimal DOM updates).",
            "Detailing potential bugs: incorrect state, re-ordering issues, UI inconsistencies, performance degradation when keys are unstable or missing.",
            "Explaining why index as key is problematic for mutable lists."
          ],
          "keyConcepts": [
            "Key prop",
            "List rendering",
            "Reconciliation",
            "Virtual DOM",
            "Performance",
            "State preservation",
            "Array index as key"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of `key`'s role.",
            "Accurate description of issues arising from incorrect `key` usage.",
            "Clarity and depth of understanding."
          ],
          "example": "The `key` prop in React is a special string attribute that you need to include when creating lists of elements. React uses `key`s to identify each item in a list uniquely. This is crucial for React's reconciliation algorithm (the diffing process of the Virtual DOM).\n\n**Purpose and Importance:**\nWhen a list changes (items are added, removed, or reordered), React uses the `key` prop to efficiently determine which actual DOM elements need to be updated, reordered, or removed, rather than re-rendering the entire list. Without unique `key`s, React might struggle to identify individual items, leading to inefficient updates and potential bugs. `key`s help React maintain the identity and state of components across renders.\n\n**Issues with Missing or Incorrect Keys (e.g., using array index for mutable lists):**\n1.  **Performance Problems:** Without unique and stable keys, React might re-render more DOM elements than necessary, leading to performance degradation, especially in large lists.\n2.  **Incorrect Component State:** If a list item changes its position, and the `key` is based on its index, React might reuse a component instance at a new index, carrying over its old internal state (e.g., input values, checkboxes checked state) to a different data item. This leads to visual bugs and incorrect data.\n3.  **UI Glitches:** Animations, transitions, or focus management might behave unexpectedly as React struggles to correctly track elements.\n4.  **Debugging Difficulty:** Such issues can be very difficult to debug because the underlying data might be correct, but the UI misbehaves due to React's inability to correctly identify elements.\n\nUsing the array `index` as a `key` is problematic when the list can change (items added, removed, reordered) because the index is not stable; it changes if the array is modified. For stable lists, a unique ID from your data (e.g., `item.id`) is always the best practice.",
          "tags": [
            "Key Prop",
            "List Rendering",
            "Performance",
            "React Concepts",
            "Advanced",
            "Open-Ended"
          ],
          "prerequisites": [
            "JSX_dynamic_rendering",
            "React_components"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_list_rendering_code_1",
          "topic": "Dynamic Rendering in JSX",
          "level": "medium",
          "type": "code",
          "question": "Given an array of user objects, render an unordered list where each list item displays the user's name and email. Ensure proper handling of `key` props.\n\n```javascript\nconst users = [\n  { id: 101, name: 'Alice', email: 'alice@example.com' },\n  { id: 102, name: 'Bob', email: 'bob@example.com' },\n  { id: 103, name: 'Charlie', email: 'charlie@example.com' }\n];\n\n// Your React component should render this list\nfunction UserList({ users }) {\n  // Implement rendering logic here\n}\n```",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Correctly using `Array.prototype.map()` to transform data into JSX elements.",
            "Applying the `key` prop to each list item.",
            "Using a stable and unique identifier (`user.id`) for the `key`.",
            "Correctly accessing nested properties (name, email)."
          ],
          "keyConcepts": [
            "List rendering",
            "`map` method",
            "`key` prop",
            "JSX expressions"
          ],
          "evaluationCriteria": [
            "Syntactic correctness of the React component.",
            "Proper use of `key` prop.",
            "Accurate rendering of user data."
          ],
          "example": "```javascript\nfunction UserList({ users }) {\n  return (\n    <ul>\n      {users.map((user) => (\n        <li key={user.id}> {/* Using user.id as a stable unique key */}\n          <strong>{user.name}</strong> - {user.email}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// To use it:\n// function App() {\n//   const users = [\n//     { id: 101, name: 'Alice', email: 'alice@example.com' },\n//     { id: 102, name: 'Bob', email: 'bob@example.com' },\n//     { id: 103, name: 'Charlie', email: 'charlie@example.com' }\n//   ];\n//   return <UserList users={users} />;\n// }\n```",
          "tags": [
            "List Rendering",
            "Code Challenge",
            "JSX",
            "Key Prop"
          ],
          "prerequisites": [
            "JSX_dynamic_rendering",
            "JavaScript_arrays"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_index_as_key_flashcard_1",
          "topic": "Dynamic Rendering in JSX",
          "level": "medium",
          "type": "flashcard",
          "question": "When is it generally safe to use the array index as the `key` prop for list items in React?",
          "answer": "When the list is static and its items will never be reordered, filtered, or added/removed.",
          "options": [],
          "analysisPoints": [
            "Understanding the limitations of using index as key.",
            "Knowing the specific conditions under which it's acceptable."
          ],
          "keyConcepts": [
            "Key prop",
            "List rendering",
            "Array index",
            "Static lists"
          ],
          "evaluationCriteria": [
            "Accurate recall of the `key` prop best practices."
          ],
          "example": "N/A",
          "tags": [
            "Key Prop",
            "List Rendering",
            "Flashcard"
          ],
          "prerequisites": [
            "JSX_dynamic_rendering"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_html_to_jsx_conversion",
          "title": "HTML to JSX Conversion Challenge",
          "description": "\nConvert the following complex HTML structure into a valid React JSX component. Pay close attention to all JSX-specific rules, including attribute naming, self-closing tags, and inline styles.\n\n**HTML Snippet:**\n```html\n<div class=\"app-container\">\n  <header>\n    <h1 id=\"main-title\" onclick=\"console.log('Title Clicked!')\">My Awesome App</h1>\n    <nav>\n      <ul>\n        <li><a href=\"#home\">Home</a></li>\n        <li><a href=\"#about\">About</a></li>\n        <li><a href=\"#contact\">Contact</a></li>\n      </ul>\n    </nav>\n  </header>\n  <main>\n    <section style=\"background-color: #f0f0f0; padding: 20px;\">\n      <h2>Welcome Section</h2>\n      <p>This is a paragraph of text.</p>\n      <input type=\"text\" placeholder=\"Enter your name\" required>\n      <br>\n      <img src=\"./assets/banner.png\" alt=\"Banner Image\" width=\"500\" height=\"300\">\n    </section>\n    <footer style=\"font-size: 14px; text-align: center; color: #666;\">\n      &copy; 2023 My Company. All rights reserved.\n    </footer>\n  </main>\n</div>\n```\n\n**Requirements:**\n1.  Create a functional React component (e.g., `AppLayout`).\n2.  Ensure all HTML attributes are converted to their correct JSX counterparts (`class` to `className`, `onclick` to `onClick`).\n3.  All self-closing tags (`input`, `br`, `img`) must be correctly self-closed with a trailing slash.\n4.  Inline `style` attributes must be converted to JavaScript objects, with CSS properties in camelCase.\n5.  The entire JSX structure should be wrapped in parentheses if it spans multiple lines.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nfunction AppLayout() {\n  return (\n    // Your JSX code here\n    // Remember multiline JSX needs parentheses\n    // Pay attention to className, onClick, style, and self-closing tags\n    <div>\n      {/* Start your conversion here */}\n    </div>\n  );\n}\n\nexport default AppLayout;",
          "solutionCode": "import React from 'react';\n\nfunction AppLayout() {\n  const sectionStyles = {\n    backgroundColor: '#f0f0f0',\n    padding: '20px'\n  };\n\n  const footerStyles = {\n    fontSize: '14px',\n    textAlign: 'center',\n    color: '#666'\n  };\n\n  return (\n    <div className=\"app-container\">\n      <header>\n        <h1 id=\"main-title\" onClick={() => console.log('Title Clicked!')}>My Awesome App</h1>\n        <nav>\n          <ul>\n            <li><a href=\"#home\">Home</a></li>\n            <li><a href=\"#about\">About</a></li>\n            <li><a href=\"#contact\">Contact</a></li>\n          </ul>\n        </nav>\n      </header>\n      <main>\n        <section style={sectionStyles}>\n          <h2>Welcome Section</h2>\n          <p>This is a paragraph of text.</p>\n          <input type=\"text\" placeholder=\"Enter your name\" required={true} /> {/* 'required' can be a boolean */}\n          <br />\n          <img src=\"./assets/banner.png\" alt=\"Banner Image\" width=\"500\" height=\"300\" />\n        </section>\n        <footer style={footerStyles}>\n          &copy; 2023 My Company. All rights reserved.\n        </footer>\n      </main>\n    </div>\n  );\n}\n\nexport default AppLayout;",
          "testCases": [
            "The output JSX should compile without errors.",
            "The `div` element should have `className=\"app-container\"`.",
            "The `h1` element should have an `onClick` prop with a function.",
            "The `input`, `br`, and `img` tags must be self-closed (e.g., `<input ... />`).",
            "The `section` and `footer` elements must have their `style` attributes as JavaScript objects with camelCased properties (e.g., `backgroundColor`, `fontSize`).",
            "The `required` attribute on the input should be treated as a boolean prop `required={true}`."
          ],
          "hints": [
            "Remember that event handlers in JSX (`onClick`) expect a JavaScript function reference, not a string.",
            "Pay close attention to camelCasing for CSS properties like `background-color` becoming `backgroundColor`.",
            "Boolean attributes like `required` can be written as `required` or `required={true}` in JSX.",
            "Make sure the root JSX element (the `div.app-container`) and any other multiline JSX are properly wrapped in parentheses."
          ],
          "tags": [
            "JSX",
            "Conversion",
            "Syntax",
            "Frontend Interview",
            "React"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "JSX_fundamentals"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "JSX attributes",
            "Self-closing tags",
            "Inline styles",
            "Event handlers"
          ]
        },
        {
          "id": "task_manual_create_element",
          "title": "Manually Replicate JSX with React.createElement()",
          "description": "\nYour task is to rewrite a given JSX snippet using only `React.createElement()` calls. This exercise will deepen your understanding of how JSX is internally processed by React.\n\n**JSX Snippet:**\n```jsx\n<div className=\"wrapper\">\n  <h1>Welcome!</h1>\n  <p>Learn more <a href=\"/docs\">here</a>.</p>\n  <img src=\"logo.svg\" alt=\"Logo\" />\n</div>\n```\n\n**Requirements:**\n1.  Create a functional React component (e.g., `ManualElementCreator`).\n2.  Inside this component, construct the exact same UI structure as the provided JSX, but *without* using any JSX syntax. Use only `React.createElement()` calls.\n3.  Ensure all attributes (like `className`, `href`, `src`, `alt`) and child elements/text nodes are correctly passed as arguments to `React.createElement()`.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nfunction ManualElementCreator() {\n  return (\n    // Your React.createElement() calls go here\n    // Hint: Start from the outermost element and nest inwards\n    // Example for a simple div: React.createElement('div', null, 'Hello')\n    null // Replace this with your implementation\n  );\n}\n\nexport default ManualElementCreator;",
          "solutionCode": "import React from 'react';\n\nfunction ManualElementCreator() {\n  return React.createElement(\n    'div',\n    { className: 'wrapper' },\n    React.createElement('h1', null, 'Welcome!'),\n    React.createElement(\n      'p',\n      null,\n      'Learn more ',\n      React.createElement('a', { href: '/docs' }, 'here'),\n      '.' // Text nodes after elements are separate children\n    ),\n    React.createElement('img', { src: 'logo.svg', alt: 'Logo' })\n  );\n}\n\nexport default ManualElementCreator;",
          "testCases": [
            "The component should render the exact same visual output as the original JSX.",
            "The rendered HTML structure should match (e.g., `div.wrapper > h1 + p + img`).",
            "All attributes should be correctly applied to their respective elements.",
            "No JSX syntax should be present in the solution code, only `React.createElement`."
          ],
          "hints": [
            "Remember the signature of `React.createElement(type, props, ...children)`.",
            "For nested elements, the child elements become subsequent arguments to the parent `React.createElement` call.",
            "Plain text content within an element is also treated as a child argument."
          ],
          "tags": [
            "React.createElement",
            "JSX",
            "Compilation",
            "Core Concepts",
            "Code Challenge"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "How_JSX_Works"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "JSX compilation",
            "Virtual DOM",
            "React elements"
          ]
        },
        {
          "id": "task_reusable_component_builder",
          "title": "Building Reusable UI Components",
          "description": "\nYour task is to create a set of reusable React components to build a simple `ProductCard` UI. This exercise emphasizes component reusability, prop drilling, and maintaining clean boundaries.\n\n**Requirements:**\n1.  **`Button` Component:** Create a reusable `Button` component that accepts `onClick` and `label` props. It should render a simple HTML `<button>`.\n2.  **`ProductImage` Component:** Create a `ProductImage` component that accepts `src` and `alt` props. It should render an `<img>` tag.\n3.  **`ProductTitle` Component:** Create a `ProductTitle` component that accepts a `title` prop. It should render an `<h2>` tag.\n4.  **`ProductDescription` Component:** Create a `ProductDescription` component that accepts a `description` prop. It should render a `<p>` tag.\n5.  **`ProductCard` Component:** Create a `ProductCard` component that composes the above components (`ProductImage`, `ProductTitle`, `ProductDescription`) and also includes a `Button`. It should accept `product` object as a prop (containing `id`, `name`, `imageUrl`, `description`) and an `onAddToCart` function.\n6.  **`App` Component:** In the `App` component, render at least two `ProductCard` instances with different product data, demonstrating reusability.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\n// 1. Create a reusable Button component here\n// function Button({ onClick, label }) { ... }\n\n// 2. Create a ProductImage component here\n// function ProductImage({ src, alt }) { ... }\n\n// 3. Create a ProductTitle component here\n// function ProductTitle({ title }) { ... }\n\n// 4. Create a ProductDescription component here\n// function ProductDescription({ description }) { ... }\n\n// 5. Create a ProductCard component here, composing the above\n// function ProductCard({ product, onAddToCart }) { ... }\n\nfunction App() {\n  const productA = {\n    id: 'prod1',\n    name: 'Fancy Gadget',\n    imageUrl: 'https://via.placeholder.com/150/FF0000/FFFFFF?text=GadgetA',\n    description: 'A cutting-edge gadget for your daily needs.'\n  };\n\n  const productB = {\n    id: 'prod2',\n    name: 'Magic Widget',\n    imageUrl: 'https://via.placeholder.com/150/0000FF/FFFFFF?text=WidgetB',\n    description: 'Unlock new possibilities with this magic widget.'\n  };\n\n  const handleAddToCart = (productId) => {\n    console.log(`Adding product ${productId} to cart.`);\n    alert(`Product ${productId} added!`);\n  };\n\n  return (\n    <div className=\"app-container\">\n      <h1>Our Products</h1>\n      {/* Render ProductCard instances here */}\n      {/* Example: <ProductCard product={productA} onAddToCart={handleAddToCart} /> */}\n    </div>\n  );\n}\n\nexport default App;",
          "solutionCode": "import React from 'react';\n\n// 1. Button Component\nfunction Button({ onClick, label }) {\n  return (\n    <button onClick={onClick} style={{ padding: '8px 15px', cursor: 'pointer', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '4px' }}>\n      {label}\n    </button>\n  );\n}\n\n// 2. ProductImage Component\nfunction ProductImage({ src, alt }) {\n  return (\n    <img src={src} alt={alt} style={{ maxWidth: '100%', height: 'auto', display: 'block', marginBottom: '10px' }} />\n  );\n}\n\n// 3. ProductTitle Component\nfunction ProductTitle({ title }) {\n  return (\n    <h2 style={{ fontSize: '1.5em', marginBottom: '8px' }}>{title}</h2>\n  );\n}\n\n// 4. ProductDescription Component\nfunction ProductDescription({ description }) {\n  return (\n    <p style={{ fontSize: '0.9em', color: '#555', marginBottom: '15px' }}>{description}</p>\n  );\n}\n\n// 5. ProductCard Component\nfunction ProductCard({ product, onAddToCart }) {\n  const cardStyle = {\n    border: '1px solid #ddd',\n    borderRadius: '8px',\n    padding: '20px',\n    margin: '15px',\n    width: '250px',\n    boxShadow: '0 2px 4px rgba(0,0,0,0.1)',\n    display: 'inline-block',\n    verticalAlign: 'top'\n  };\n\n  return (\n    <div style={cardStyle}>\n      <ProductImage src={product.imageUrl} alt={product.name} />\n      <ProductTitle title={product.name} />\n      <ProductDescription description={product.description} />\n      <Button onClick={() => onAddToCart(product.id)} label=\"Add to Cart\" />\n    </div>\n  );\n}\n\nfunction App() {\n  const productA = {\n    id: 'prod1',\n    name: 'Fancy Gadget',\n    imageUrl: 'https://via.placeholder.com/150/FF0000/FFFFFF?text=GadgetA',\n    description: 'A cutting-edge gadget for your daily needs.'\n  };\n\n  const productB = {\n    id: 'prod2',\n    name: 'Magic Widget',\n    imageUrl: 'https://via.placeholder.com/150/0000FF/FFFFFF?text=WidgetB',\n    description: 'Unlock new possibilities with this magic widget.'\n  };\n\n  const handleAddToCart = (productId) => {\n    console.log(`Adding product ${productId} to cart.`);\n    alert(`Product ${productId} added!`);\n  };\n\n  return (\n    <div className=\"app-container\" style={{ fontFamily: 'Arial, sans-serif', textAlign: 'center' }}>\n      <h1>Our Products</h1>\n      <div style={{ display: 'flex', justifyContent: 'center', flexWrap: 'wrap' }}>\n        <ProductCard product={productA} onAddToCart={handleAddToCart} />\n        <ProductCard product={productB} onAddToCart={handleAddToCart} />\n      </div>\n    </div>\n  );\n}\n\nexport default App;",
          "testCases": [
            "All individual components (`Button`, `ProductImage`, `ProductTitle`, `ProductDescription`) should render correctly with their respective props.",
            "The `ProductCard` component should successfully compose and render all child components.",
            "The `ProductCard` component should correctly pass product data to its sub-components.",
            "Clicking the 'Add to Cart' button on a `ProductCard` should trigger the `onAddToCart` handler with the correct `productId`.",
            "The `App` component should render at least two distinct `ProductCard` instances.",
            "The code should demonstrate proper prop drilling where necessary."
          ],
          "hints": [
            "Break down the UI into the smallest reusable units first.",
            "Think about what props each component needs to be truly reusable.",
            "Remember that functional components receive props as their first argument (an object).",
            "Use inline styles for simplicity, but convert them to JavaScript objects as required by JSX.",
            "For the `onAddToCart` prop, you'll need to pass a function that takes the `productId`."
          ],
          "tags": [
            "React Components",
            "Reusability",
            "Props",
            "Component Composition",
            "Frontend Interview"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "Why_Choose_React",
            "JSX_fundamentals"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component-based architecture",
            "High Cohesion, Low Coupling",
            "Unidirectional Data Flow"
          ]
        },
        {
          "id": "task_dynamic_todo_list",
          "title": "Dynamic Todo List with Conditional and List Rendering",
          "description": "\nCreate a React component that manages and displays a dynamic list of todo items. This task will require you to use conditional rendering and list rendering with proper `key` management.\n\n**Requirements:**\n1.  **`TodoList` Component:**\n    *   Accepts a `todos` array (each todo object has `id`, `text`, `isCompleted` properties).\n    *   Renders an unordered list (`<ul>`) of todo items.\n    *   Each list item (`<li>`) should display the todo's `text`.\n    *   If `isCompleted` is `true`, the text should be strike-through (e.g., `<del>text</del>` or `text-decoration: line-through`).\n    *   **Crucially, each `<li>` must have a unique `key` prop using the `todo.id`.\n2.  **`EmptyStateMessage` Component:**\n    *   This component should simply display a message like \"No todos yet! Add some to get started.\"\n3.  **`App` Component:**\n    *   Manage a state variable for the `todos` array.\n    *   Render the `TodoList` component if there are todos.\n    *   Conditionally render the `EmptyStateMessage` component if the `todos` array is empty.\n    *   (Bonus) Include a button or input to add new todos and mark existing ones as complete/incomplete to demonstrate state changes affecting the list.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// TodoList component placeholder\n// function TodoList({ todos }) { ... }\n\n// EmptyStateMessage component placeholder\n// function EmptyStateMessage() { ... }\n\nfunction App() {\n  const [todos, setTodos] = useState([\n    { id: 1, text: 'Learn React hooks', isCompleted: false },\n    { id: 2, text: 'Build a todo app', isCompleted: true },\n    { id: 3, text: 'Master conditional rendering', isCompleted: false },\n  ]);\n\n  // Bonus: Add handlers for adding/toggling todos here\n\n  return (\n    <div className=\"App\">\n      <h1>My Todo List</h1>\n      {/* Conditional rendering logic here */}\n      {/* Example: {todos.length > 0 ? <TodoList todos={todos} /> : <EmptyStateMessage />} */}\n    </div>\n  );\n}\n\nexport default App;",
          "solutionCode": "import React, { useState } from 'react';\n\n// TodoList component\nfunction TodoList({ todos, onToggleComplete }) {\n  return (\n    <ul style={{ listStyleType: 'none', padding: 0 }}>\n      {todos.map((todo) => (\n        <li\n          key={todo.id} // Essential for list rendering performance and correctness\n          onClick={() => onToggleComplete(todo.id)}\n          style={{\n            textDecoration: todo.isCompleted ? 'line-through' : 'none',\n            cursor: 'pointer',\n            padding: '8px',\n            margin: '5px 0',\n            border: '1px solid #eee',\n            borderRadius: '4px',\n            backgroundColor: todo.isCompleted ? '#f0f0f0' : 'white',\n            display: 'flex',\n            justifyContent: 'space-between',\n            alignItems: 'center'\n          }}\n        >\n          <span>{todo.text}</span>\n          {todo.isCompleted && <span style={{ color: 'green', fontSize: '0.8em' }}>&#10003; Done</span>}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// EmptyStateMessage component\nfunction EmptyStateMessage() {\n  return (\n    <p style={{ color: '#888', fontStyle: 'italic' }}>No todos yet! Add some to get started.</p>\n  );\n}\n\nfunction App() {\n  const [todos, setTodos] = useState([\n    { id: 1, text: 'Learn React hooks', isCompleted: false },\n    { id: 2, text: 'Build a todo app', isCompleted: true },\n    { id: 3, text: 'Master conditional rendering', isCompleted: false },\n  ]);\n\n  const [newTodoText, setNewTodoText] = useState('');\n\n  const handleAddTodo = () => {\n    if (newTodoText.trim() === '') return;\n    const newTodo = {\n      id: Date.now(), // Simple unique ID for demo\n      text: newTodoText.trim(),\n      isCompleted: false,\n    };\n    setTodos([...todos, newTodo]);\n    setNewTodoText('');\n  };\n\n  const handleToggleComplete = (id) => {\n    setTodos(todos.map(todo =>\n      todo.id === id ? { ...todo, isCompleted: !todo.isCompleted } : todo\n    ));\n  };\n\n  return (\n    <div className=\"App\" style={{ maxWidth: '500px', margin: '30px auto', padding: '20px', border: '1px solid #ccc', borderRadius: '8px', fontFamily: 'Arial, sans-serif' }}>\n      <h1>My Todo List</h1>\n      <div style={{ marginBottom: '20px' }}>\n        <input\n          type=\"text\"\n          value={newTodoText}\n          onChange={(e) => setNewTodoText(e.target.value)}\n          placeholder=\"Add a new todo...\"\n          onKeyPress={(e) => { if (e.key === 'Enter') handleAddTodo(); }}\n          style={{ padding: '8px', marginRight: '10px', width: '70%', borderRadius: '4px', border: '1px solid #ddd' }}\n        />\n        <button onClick={handleAddTodo} style={{ padding: '8px 15px', borderRadius: '4px', border: 'none', backgroundColor: '#28a745', color: 'white', cursor: 'pointer' }}>Add Todo</button>\n      </div>\n\n      {todos.length > 0 ? (\n        <TodoList todos={todos} onToggleComplete={handleToggleComplete} />\n      ) : (\n        <EmptyStateMessage />\n      )}\n    </div>\n  );\n}\n\nexport default App;",
          "testCases": [
            "The `TodoList` should render all items from the `todos` array.",
            "Completed todos should have strike-through text.",
            "Each `<li>` element in `TodoList` must have a unique `key` prop, preferably using `todo.id`.",
            "When `todos` array is empty, `EmptyStateMessage` should be displayed.",
            "When `todos` array is not empty, `TodoList` should be displayed, and `EmptyStateMessage` should not.",
            "Adding a new todo via the input field should correctly update the list.",
            "Clicking on a todo item should toggle its `isCompleted` status and update its style."
          ],
          "hints": [
            "Use the `Array.prototype.map()` method to iterate over the `todos` array and return a new array of `<li>` elements.",
            "For conditional styling (strike-through), you can use a ternary operator within the `style` prop of the `<li>` element.",
            "The `key` prop is critical for performance and correctness in lists. Always use a stable, unique identifier for each item.",
            "For conditional rendering, consider using the ternary operator (`condition ? <ComponentA /> : <ComponentB />`) or the logical `&&` operator (`condition && <Component />`).",
            "The `useState` hook will be essential for managing the `todos` array and the input field value."
          ],
          "tags": [
            "React",
            "Conditional Rendering",
            "List Rendering",
            "Key Prop",
            "State Management",
            "Frontend Interview",
            "Dynamic UI"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "JSX_dynamic_rendering",
            "React_useState"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component state",
            "Props",
            "Event handling",
            "Unidirectional data flow"
          ]
        }
      ]
    }
  },
  {
    "id": "0df84cf5-e861-42ae-9360-8d0826784d37",
    "startLine": 2700,
    "endLine": 2799,
    "processedDate": "2025-06-17T08:27:45.590Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_jsx_fragments",
          "title": "JSX Fragments: Grouping Elements Without Extra DOM Nodes",
          "content": "JSX Fragments allow you to group multiple elements together without introducing an additional wrapper DOM node into the final rendered output. This is particularly useful when a component needs to return multiple elements, but you want to avoid affecting the component's layout or the overall DOM structure with unnecessary parent elements.\n\n## Syntax\nThere are two primary ways to use Fragments:\n\n1.  **Long Syntax**: Using `React.Fragment`\n    This explicit form is necessary when you need to pass a `key` prop to the Fragment, such as when rendering a list of fragments.\n\n    ```typescript\n    import React from 'react';\n\n    function ListItems() {\n      return (\n        <React.Fragment>\n          <li>Item 1</li>\n          <li>Item 2</li>\n        </React.Fragment>\n      );\n    }\n    ```\n\n2.  **Short Syntax (Shorthand)**: Using `<></>`\n    This is a more concise and commonly used syntax when a `key` is not required. It's essentially syntactic sugar for `React.Fragment`.\n\n    ```typescript\n    function ListItems() {\n      return (\n        <>\n          <li>Item 1</li>\n          <li>Item 2</li>\n        </>\n      );\n    }\n    ```\n\n## Benefits of Fragments Over Container Divs\nUsing Fragments instead of a `div` or other wrapper element to group children provides several significant advantages, especially in complex applications:\n\n1.  **Performance**: Fragments lead to slightly better performance and reduced memory consumption because they do not create an extra DOM node. While the impact might be negligible for small applications, it becomes noticeable in very large and deeply nested component trees where many components might otherwise introduce superfluous wrapper divs.\n\n2.  **CSS Layout Integrity**: Many CSS layout mechanisms, such as Flexbox and CSS Grid, rely on specific parent-child relationships. Introducing an extra `div` in the middle of these relationships can break the intended layout or make it more complicated to achieve. Fragments allow components to return multiple children directly, maintaining the integrity of the CSS layout.\n\n3.  **DOM Inspector Clarity**: When debugging with browser developer tools, the DOM Inspector remains cleaner and less cluttered. Without unnecessary wrapper `div`s, it's easier to inspect the actual structure and identify relevant elements.\n\n4.  **Semantic HTML**: Fragments help in maintaining proper semantic HTML structure. For example, a `<table>` must contain `<tbody>`, `<thead>`, `<tfoot>` directly, and `<tbody>` must contain `<tr>`. Introducing a `div` between these elements would create invalid HTML, potentially impacting accessibility and SEO. Fragments allow you to return valid HTML structures.",
          "examples": [
            {
              "id": "example_jsx_fragments_1",
              "title": "Basic Fragment Usage",
              "code": "import React from 'react';\n\nfunction GreetingList() {\n  return (\n    <>\n      <h1>Hello!</h1>\n      <p>Welcome to the example.</p>\n    </>\n  );\n}\n\n// This component, when rendered, will output directly:\n// <h1>Hello!</h1>\n// <p>Welcome to the example.</p>\n// without an enclosing div.",
              "explanation": "This example demonstrates the most common use case for Fragments: grouping a few sibling elements without adding an extra `div` wrapper. The shorthand syntax `<></>` is used for conciseness. When `GreetingList` is rendered, its output will directly become siblings in the DOM, preserving the desired layout and semantic structure.",
              "language": "typescript"
            },
            {
              "id": "example_jsx_fragments_2",
              "title": "Fragment with Key Prop in Lists",
              "code": "import React from 'react';\n\ninterface ItemProps {\n  id: number;\n  name: string;\n}\n\nfunction TableRows({ items }: { items: ItemProps[] }) {\n  return (\n    <React.Fragment>\n      {items.map(item => (\n        <React.Fragment key={item.id}>\n          <td>{item.id}</td>\n          <td>{item.name}</td>\n        </React.Fragment>\n      ))}\n    </React.Fragment>\n  );\n}\n\n// Usage example within a table body:\n// <tbody>\n//   <TableRows items={[{ id: 1, name: 'Apple' }, { id: 2, name: 'Banana' }]} />\n// </tbody>\n// This will render directly:\n// <tbody>\n//   <td>1</td><td>Apple</td>\n//   <td>2</td><td>Banana</td>\n// </tbody>\n// (Note: This is a simplified example; typically, each row would be a <tr>, but this shows Fragment with keys.)",
              "explanation": "This example shows a more advanced use case where `React.Fragment` (the long syntax) is required because a `key` prop needs to be passed. When mapping over a list and each item needs to render multiple sibling elements (e.g., `<td>`s for a table row, if `<tr>` itself is not the wrapper for the entire row), you might need a fragment to group them. The `key` prop is crucial for React's reconciliation process to efficiently identify and update list items. Here, `React.Fragment` allows us to apply a unique `key` to each logical 'item' being rendered, even though it doesn't create a DOM node.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_jsx_fragments_1",
            "question_jsx_fragments_2",
            "question_jsx_fragments_3",
            "question_jsx_fragments_4",
            "question_jsx_fragments_5",
            "question_jsx_fragments_6"
          ],
          "relatedTasks": [
            "task_jsx_fragments_table_row"
          ],
          "tags": [
            "React",
            "JSX",
            "Fragments",
            "DOM",
            "Performance",
            "Semantic HTML",
            "Frontend"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "jsx_syntax"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced_component_design",
            "performance_optimization"
          ]
        },
        {
          "id": "theory_virtual_dom_reconciliation",
          "title": "Virtual DOM and Reconciliation in React",
          "content": "The Virtual DOM (VDOM) is a core concept and one of React's key optimization techniques. It is a lightweight JavaScript object representation of the actual browser DOM (Document Object Model). React uses the VDOM to efficiently update the user interface.\n\n## How Virtual DOM Works\nReact's rendering process involving the Virtual DOM follows these steps:\n\n1.  **Creation**: When a React component renders for the first time, or when its state or props change, React creates a new virtual DOM tree. This tree is a plain JavaScript object structure representing the desired UI state.\n\n    ```typescript\n    // React maintains a virtual representation of this DOM structure\n    <div className=\"app\">\n      <header>\n        <h1>Title</h1>\n      </header>\n      <main>\n        <ul>\n          <li>Item 1</li>\n          <li>Item 2</li>\n        </ul>\n      </main>\n    </div>\n    ```\n\n2.  **Diffing (Comparison)**: When an update occurs (e.g., state or props change), React doesn't directly update the real DOM. Instead, it creates another new virtual DOM tree (representing the new UI state) and then efficiently compares (diffs) this new virtual tree with the previous virtual tree.\n\n3.  **Reconciliation**: The diffing process identifies the minimal set of changes (updates, additions, deletions) required to make the real DOM reflect the new virtual DOM. This process is called reconciliation.\n\n4.  **Batching**: React batches multiple DOM updates together. Instead of applying each change individually to the real DOM, React collects all identified changes and applies them in a single, optimized batch operation. This minimizes direct manipulation of the expensive real DOM, leading to better performance.\n\n## Reconciliation Algorithm\nReact's reconciliation algorithm is optimized for speed, aiming for O(n) complexity where 'n' is the number of elements in the tree. It uses several heuristics (optimizations based on common scenarios) to achieve this:\n\n1.  **Different Element Types**: If the root elements of two compared trees have different types (e.g., `div` changes to `span`, or `ComponentA` changes to `ComponentB`), React tears down the old tree completely and builds a new one from scratch. This is because a change in element type implies a fundamental change in structure and behavior, making it more efficient to rebuild.\n\n2.  **Same Element Type**: If the root elements have the same type, React is able to keep the same underlying DOM node. It then recursively compares the attributes and children of these elements. Only the changed attributes are updated on the existing DOM node, and the reconciliation process continues for their children.\n\n3.  **Component Elements**: When a component updates, React first checks if the component instance is of the same type. If it is, React updates the component's props, calls its `render` method to get the new virtual DOM tree, and then applies the reconciliation algorithm recursively to compare the newly rendered tree with the previously rendered one.\n\n4.  **List Elements (Importance of `key` Prop)**: When dealing with lists of elements, React needs a way to identify which items have changed, been added, or been removed, even if their order changes. This is where the `key` prop becomes critical. A `key` is a special string attribute you need to include when creating lists of elements. React uses these keys to efficiently reconcile list items. Without stable, unique keys, React might re-render all items or perform inefficient updates when an item is added, removed, or reordered, potentially leading to performance issues or even incorrect UI state (e.g., issues with component state if React reuses components for different data).\n\n    *   **Bad Practice**: Using array `index` as `key` for dynamic lists.\n        ```typescript\n        // Without stable keys, React might re-render all items when one changes\n        // or behave unpredictably when items are added/removed/reordered.\n        // BAD PRACTICE for dynamic lists\n        {items.map((item, index) => <ListItem key={index} item={item} />)}\n        ```\n\n    *   **Good Practice**: Using a stable, unique ID from your data as `key`.\n        ```typescript\n        // With stable keys, React can efficiently identify which items changed,\n        // preserving component state and improving performance.\n        // GOOD PRACTICE: Use a stable unique ID\n        {items.map(item => <ListItem key={item.id} item={item} />)}\n        ```\n\n## Real DOM vs. Virtual DOM Comparison\n\n| Feature                       | Real DOM                                    | Virtual DOM                                      |\n| :---------------------------- | :------------------------------------------ | :----------------------------------------------- |\n| **Update Speed**              | Updates slowly, as direct manipulation is costly. | Updates faster due to in-memory representation.  |\n| **Direct HTML Update**        | Can directly update HTML elements.          | Cannot directly update HTML; it's a representation. |\n| **Element Update Mechanism**  | Creates a new DOM node if an element's structure or type changes significantly, or updates properties on existing nodes. | Updates the JSX (JavaScript representation) first, then diffs. |\n| **Manipulation Cost**         | DOM manipulation is very expensive due to browser layout, paint, and reflow operations. | DOM manipulation (in-memory) is very easy and cheap. |\n| **Memory Usage (Per Update)** | Can lead to high memory consumption and wastage due to frequent re-renders and re-creations of nodes. | Low memory wastage, as only a small, diffed patch is applied to the real DOM. |\n\nIn essence, the Virtual DOM acts as an intermediary layer that allows React to minimize direct interactions with the slow real DOM, leading to highly performant and responsive user interfaces.",
          "examples": [
            {
              "id": "example_virtual_dom_1",
              "title": "Virtual DOM Diffing Example",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    setCount(count + 1);\n  };\n\n  // When setCount is called:\n  // 1. React creates a new VDOM: <p>Count: 1</p>\n  // 2. Diffs it with old VDOM: <p>Count: 0</p>\n  // 3. Identifies only the text content within the <p> tag changed.\n  // 4. Updates ONLY that text content in the real DOM.\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n\n// Imagine the real DOM initially:\n// <div>\n//   <p>Count: 0</p>\n//   <button>Increment</button>\n// </div>",
              "explanation": "This example illustrates the Virtual DOM and reconciliation process. When the `Increment` button is clicked, `setCount` updates the component's state. React then creates a new Virtual DOM tree for the `Counter` component. It compares this new tree with the previous one. The diffing algorithm determines that only the text content within the `<p>` tag has changed. Instead of re-rendering the entire `div` or `p` element, React performs a precise update, only changing the `textContent` of the existing `<p>` DOM node. This granular update is significantly more efficient than direct DOM manipulation.",
              "language": "typescript"
            },
            {
              "id": "example_virtual_dom_2",
              "title": "Impact of Keys on List Reconciliation",
              "code": "import React, { useState } from 'react';\n\nfunction ItemList() {\n  const initialItems = [\n    { id: 'a', text: 'First' },\n    { id: 'b', text: 'Second' },\n    { id: 'c', text: 'Third' },\n  ];\n  const [items, setItems] = useState(initialItems);\n\n  const shuffleItems = () => {\n    setItems([...items].sort(() => Math.random() - 0.5));\n  };\n\n  const addItemAtBeginning = () => {\n    const newItemId = Math.random().toString(36).substring(7);\n    setItems([{ id: newItemId, text: 'New Item' }, ...items]);\n  };\n\n  return (\n    <div>\n      <button onClick={shuffleItems}>Shuffle Items</button>\n      <button onClick={addItemAtBeginning}>Add Item at Beginning</button>\n      <ul>\n        {items.map(item => (\n          <li key={item.id}>{item.text}</li> // Good: Using stable, unique ID as key\n          // <li key={index}>{item.text}</li> // Bad: Using index as key for dynamic list\n        ))}\n      </ul>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates the critical role of `key` props in list reconciliation. The `ItemList` component renders a dynamic list. When items are shuffled or a new item is added at the beginning, React uses the `key` prop to identify specific list items. By using `item.id` (a stable, unique identifier) as the key, React can efficiently reorder existing DOM nodes or insert new ones at the correct positions. If `index` were used as the key for a dynamic list (as shown in the commented line), React might inefficiently update the content of existing nodes or remount components unnecessarily, leading to performance issues or loss of internal component state (e.g., input values in a form within a list item). Stable keys ensure that React can correctly map data items to their corresponding component instances and DOM elements.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_virtual_dom_1",
            "question_virtual_dom_2",
            "question_virtual_dom_3",
            "question_virtual_dom_4",
            "question_virtual_dom_5",
            "question_virtual_dom_6",
            "question_virtual_dom_7",
            "question_virtual_dom_8",
            "question_virtual_dom_9",
            "question_virtual_dom_10"
          ],
          "relatedTasks": [
            "task_virtual_dom_dynamic_list"
          ],
          "tags": [
            "React",
            "Virtual DOM",
            "DOM",
            "Reconciliation",
            "Performance",
            "Keys",
            "JavaScript",
            "Frontend"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_basics",
            "dom_manipulation",
            "react_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_performance_optimization",
            "complex_ui_development"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_jsx_fragments_1",
          "topic": "JSX Fragments",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of JSX Fragments?",
          "answer": "To group multiple elements without adding an extra DOM node to the parent.",
          "options": [],
          "analysisPoints": [
            "Focus on 'grouping' and 'no extra DOM node'."
          ],
          "keyConcepts": [
            "JSX Fragments",
            "DOM structure"
          ],
          "evaluationCriteria": [
            "Ability to recall basic definition."
          ],
          "example": "",
          "tags": [
            "JSX",
            "Fragments",
            "DOM"
          ],
          "prerequisites": [
            "jsx_syntax"
          ],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_jsx_fragments_2",
          "topic": "JSX Fragments",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React component:\n\n```typescript\nfunction ItemRow({ item }) {\n  return (\n    <>\n      <td>{item.id}</td>\n      <td>{item.name}</td>\n    </>\n  );\n}\n\n// If used inside a <table> like this:\n// <table>\n//   <tbody>\n//     <ItemRow item={{ id: 1, name: 'Apple' }} />\n//     <ItemRow item={{ id: 2, name: 'Banana' }} />\n//   </tbody>\n// </table>\n```\n\nWhich of the following statements about the rendered DOM output is TRUE?",
          "answer": "The `<td>` elements will be direct children of the `<tbody>`.",
          "options": [
            "The `<td>` elements will be wrapped inside an empty `div`.",
            "The `<td>` elements will be direct children of the `<tbody>`.",
            "The `ItemRow` component will throw an error because it returns multiple elements.",
            "The `<td>` elements will be wrapped inside a `React.Fragment` DOM node."
          ],
          "analysisPoints": [
            "Tests understanding of Fragment's core behavior: no extra DOM node.",
            "Reinforces that Fragments allow returning multiple elements without a single parent.",
            "Highlights the correct DOM structure for semantic HTML like tables."
          ],
          "keyConcepts": [
            "JSX Fragments",
            "DOM structure",
            "Semantic HTML"
          ],
          "evaluationCriteria": [
            "Understanding of Fragment's effect on DOM.",
            "Knowledge of valid HTML table structure."
          ],
          "example": "JSX Fragments (`<></>` or `<React.Fragment>`) do not render any actual DOM element. They are a way to group elements in JSX without introducing an extra wrapper. Therefore, the `<td>` elements returned by `ItemRow` will effectively become direct children of the `<tbody>` element in the final HTML, which is crucial for maintaining valid table semantics (`<tbody>` should directly contain `<tr>` or `<td>`s for a simplified scenario like this, though typically `<tr>` is the direct child of `<tbody>` with `<td>`s inside `<tr>`). Option A and D are incorrect because Fragments add no DOM node. Option C is incorrect as Fragments specifically solve the problem of returning multiple elements.",
          "tags": [
            "JSX",
            "Fragments",
            "DOM",
            "MCQ"
          ],
          "prerequisites": [
            "jsx_syntax",
            "html_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_jsx_fragments_3",
          "topic": "JSX Fragments",
          "level": "medium",
          "type": "open",
          "question": "Explain at least three benefits of using JSX Fragments over wrapping multiple JSX elements in a `div` element.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Performance: Fragments avoid creating an extra DOM node, leading to slightly faster rendering and less memory usage, especially in deep component trees.",
            "CSS Layout Integrity: Prevents breaking specific CSS layouts (like Flexbox or CSS Grid) that rely on direct parent-child relationships, as a `div` wrapper would introduce an unintended intermediate box.",
            "DOM Inspector Clarity: Keeps the browser's DOM inspector cleaner and less cluttered by avoiding unnecessary wrapper elements, making debugging easier.",
            "Semantic HTML: Allows components to return valid semantic HTML structures (e.g., `<td>` elements directly inside `<tr>`, or `<li>` elements directly inside `<ul>`) without introducing non-semantic wrappers that would invalidate the HTML or affect accessibility/SEO."
          ],
          "keyConcepts": [
            "JSX Fragments",
            "Performance",
            "CSS Layout",
            "DOM Structure",
            "Semantic HTML",
            "Accessibility"
          ],
          "evaluationCriteria": [
            "Ability to articulate the core advantages.",
            "Detailing the 'why' behind each benefit (e.g., 'how' performance is affected).",
            "Providing clear examples or scenarios where each benefit applies."
          ],
          "example": "",
          "tags": [
            "JSX",
            "Fragments",
            "Performance",
            "CSS",
            "DOM",
            "Semantic HTML",
            "Open-ended"
          ],
          "prerequisites": [
            "jsx_syntax",
            "html_basics",
            "css_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_jsx_fragments_4",
          "topic": "JSX Fragments",
          "level": "easy",
          "type": "flashcard",
          "question": "When is it mandatory to use the long syntax `<React.Fragment>` instead of the shorthand `<></>` for Fragments?",
          "answer": "When you need to pass a `key` prop to the Fragment, typically when rendering a list of fragments.",
          "options": [],
          "analysisPoints": [
            "Focus on the `key` prop requirement."
          ],
          "keyConcepts": [
            "JSX Fragments",
            "key prop",
            "List rendering"
          ],
          "evaluationCriteria": [
            "Recall of specific syntax constraint."
          ],
          "example": "",
          "tags": [
            "JSX",
            "Fragments",
            "Key"
          ],
          "prerequisites": [
            "jsx_syntax"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_jsx_fragments_5",
          "topic": "JSX Fragments",
          "level": "medium",
          "type": "mcq",
          "question": "You are building a React component that needs to render a list of table rows (`<tr>` elements) directly inside a `<tbody>`. Which of the following is the most appropriate way to achieve this using Fragments while ensuring proper list reconciliation if items can be reordered?",
          "answer": "```typescript\nfunction TableBodyContent({ data }) {\n  return (\n    <React.Fragment>\n      {data.map(item => (\n        <tr key={item.id}>\n          <td>{item.name}</td>\n          <td>{item.value}</td>\n        </tr>\n      ))}\n    </React.Fragment>\n  );\n}\n```",
          "options": [
            "```typescript\nfunction TableBodyContent({ data }) {\n  return (\n    <div>\n      {data.map(item => (\n        <tr key={item.id}>\n          <td>{item.name}</td>\n          <td>{item.value}</td>\n        </tr>\n      ))}\n    </div>\n  );\n}\n```",
            "```typescript\nfunction TableBodyContent({ data }) {\n  return (\n    <>\n      {data.map(item => (\n        <tr key={item.id}>\n          <td>{item.name}</td>\n          <td>{item.value}</td>\n        </tr>\n      ))}\n    </>\n  );\n}\n```",
            "```typescript\nfunction TableBodyContent({ data }) {\n  return (\n    <React.Fragment key=\"table-rows\">\n      {data.map(item => (\n        <tr key={item.id}>\n          <td>{item.name}</td>\n          <td>{item.value}</td>\n        </tr>\n      ))}\n    </React.Fragment>\n  );\n}\n```",
            "```typescript\nfunction TableBodyContent({ data }) {\n  return (\n    <React.Fragment>\n      {data.map(item => (\n        <tr key={item.id}>\n          <td>{item.name}</td>\n          <td>{item.value}</td>\n        </tr>\n      ))}\n    </React.Fragment>\n  );\n}\n```"
          ],
          "analysisPoints": [
            "Option A: Incorrect, introduces an invalid `div` inside `<tbody>`.",
            "Option B: Incorrect, the outer `<></>` shorthand cannot accept a `key`.",
            "Option C: Incorrect, passing a `key` to the outer `React.Fragment` is not necessary or common here, as the `key` is applied to individual `<tr>` elements within the map. The outer fragment doesn't need a key unless it's part of a list of fragments itself.",
            "Option D: Correct. The outer `React.Fragment` (which could also be `<>`) correctly groups the `<tr>` elements without adding an extra DOM node. The `key={item.id}` is correctly applied to each `<tr>` within the `map` function, which is crucial for efficient list reconciliation.",
            "This question tests both Fragment usage and the critical role of `key` props in lists."
          ],
          "keyConcepts": [
            "JSX Fragments",
            "Semantic HTML",
            "List Rendering",
            "Key Prop"
          ],
          "evaluationCriteria": [
            "Correct application of Fragments for semantic HTML.",
            "Understanding where and how to use `key` props.",
            "Distinguishing between long and short Fragment syntax implications."
          ],
          "example": "The goal is to render `<tr>` elements directly inside a `<tbody>`. Using a `div` (Option A) would create invalid HTML. The `<></>` shorthand (Option B) is fine if you don't need a key for the Fragment itself, but the correct application of `key` is on the `<tr>` elements. Option C attempts to put a key on the outer `React.Fragment`, which is not typically needed here as the `<tr>` elements are the dynamic ones. Option D correctly uses `React.Fragment` (or `<>`) to wrap the mapped `<tr>` elements, and critically, places the `key` prop on each individual `<tr>` element, which is where React needs it for efficient list reconciliation.",
          "tags": [
            "JSX",
            "Fragments",
            "HTML",
            "List",
            "Key",
            "MCQ"
          ],
          "prerequisites": [
            "react_components",
            "jsx_syntax",
            "html_tables"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_jsx_fragments_6",
          "topic": "JSX Fragments",
          "level": "hard",
          "type": "code",
          "question": "Refactor the `UserProfile` component below to use JSX Fragments efficiently. The component needs to render a user's name, email, and a list of hobbies. The final output should not have any unnecessary wrapping `div`s around the name and email, and the hobbies list should be a direct sibling of the name/email block.\n\n**Current Code (Inefficient/Suboptimal):**\n```typescript\nimport React from 'react';\n\ninterface UserData {\n  name: string;\n  email: string;\n  hobbies: string[];\n}\n\nfunction UserProfile({ user }: { user: UserData }) {\n  return (\n    <div>\n      <div>\n        <h2>{user.name}</h2>\n        <p>Email: {user.email}</p>\n      </div>\n      <h3>Hobbies:</h3>\n      <ul>\n        {user.hobbies.map((hobby, index) => (\n          <li key={index}>{hobby}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n**Requirements:**\n1.  Remove the outer `div` wrapping the entire component's content.\n2.  Remove the inner `div` wrapping `<h2>` and `<p>`.\n3.  Ensure the `<h2>` and `<p>` are direct siblings.\n4.  Ensure the `<h3>` and `<ul>` are direct siblings of the `<h2>` and `<p>`.\n5.  The `hobbies` list should still use appropriate keys for list items.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Uses `<>` for the main component return to remove the outermost `div`.",
            "Uses `<>` or `<React.Fragment>` for grouping `<h2>` and `<p>` to remove the inner `div`.",
            "Correctly places `key={index}` on `<li>` elements, acknowledging it's acceptable for static lists but better practice to use unique IDs if hobbies can be reordered/modified dynamically."
          ],
          "keyConcepts": [
            "JSX Fragments",
            "Refactoring",
            "DOM Optimization",
            "Semantic HTML"
          ],
          "evaluationCriteria": [
            "Correct application of Fragments to eliminate unnecessary DOM nodes.",
            "Maintenance of correct element hierarchy and sibling relationships.",
            "Appropriate use of `key` prop for list rendering."
          ],
          "example": "```typescript\nimport React from 'react';\n\ninterface UserData {\n  name: string;\n  email: string;\n  hobbies: string[];\n}\n\nfunction UserProfile({ user }: { user: UserData }) {\n  return (\n    <>\n      <h2>{user.name}</h2>\n      <p>Email: {user.email}</p>\n      <h3>Hobbies:</h3>\n      <ul>\n        {user.hobbies.map((hobby, index) => (\n          <li key={hobby}>{hobby}</li> // Assuming hobby names are unique and stable for keys\n        ))}\n      </ul>\n    </>\n  );\n}\n```",
          "tags": [
            "JSX",
            "Fragments",
            "Code Challenge",
            "Refactoring",
            "Performance"
          ],
          "prerequisites": [
            "jsx_syntax",
            "react_components"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_1",
          "topic": "Virtual DOM and Reconciliation",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the Virtual DOM?",
          "answer": "A lightweight JavaScript object representation of the actual browser DOM.",
          "options": [],
          "analysisPoints": [
            "Focus on 'JavaScript object' and 'representation of DOM'."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "DOM"
          ],
          "evaluationCriteria": [
            "Basic definition recall."
          ],
          "example": "",
          "tags": [
            "Virtual DOM",
            "React",
            "DOM"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_virtual_dom_2",
          "topic": "Virtual DOM and Reconciliation",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following steps is NOT part of React's Virtual DOM process when state or props change?",
          "answer": "Directly updating the entire Real DOM with the new UI tree.",
          "options": [
            "Creating a new Virtual DOM tree based on the updated state/props.",
            "Diffing the new Virtual DOM tree with the previous one.",
            "Calculating the minimal set of changes needed for the Real DOM.",
            "Directly updating the entire Real DOM with the new UI tree."
          ],
          "analysisPoints": [
            "Option A, B, C are correct steps in the VDOM process.",
            "Option D is incorrect because React avoids direct full DOM updates; it only updates the minimal changes."
          ],
          "keyConcepts": [
            "Virtual DOM",
            "Reconciliation",
            "Diffing",
            "Batching"
          ],
          "evaluationCriteria": [
            "Understanding the steps involved in React's rendering process.",
            "Distinguishing between Virtual DOM operations and Real DOM updates."
          ],
          "example": "React's Virtual DOM process involves creating a new VDOM, diffing it against the old one, and then applying a minimal patch to the Real DOM. It never directly updates the entire Real DOM tree, as that would be inefficient. The efficiency comes from calculating precisely what changed and only modifying those specific parts of the actual DOM.",
          "tags": [
            "Virtual DOM",
            "Reconciliation",
            "React",
            "Performance",
            "MCQ"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_3",
          "topic": "Virtual DOM and Reconciliation",
          "level": "medium",
          "type": "open",
          "question": "Explain the concept of 'Reconciliation' in React and how it relates to the Virtual DOM and performance.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Define Reconciliation: The process by which React updates the actual DOM to match the desired state represented by the Virtual DOM.",
            "Role of Virtual DOM: Two VDOM trees are compared (old vs. new).",
            "Diffing Algorithm: Explain how React identifies differences (element types, attributes, children, keys for lists).",
            "Minimal Changes (Patching): React calculates the most efficient way (minimal operations) to update the real DOM.",
            "Performance Impact: By minimizing direct manipulation of the expensive real DOM, reconciliation significantly boosts performance, preventing unnecessary re-renders and layout thrashing."
          ],
          "keyConcepts": [
            "Reconciliation",
            "Virtual DOM",
            "Diffing Algorithm",
            "Performance",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Clear definition of reconciliation.",
            "Accurate description of the diffing process.",
            "Connection between VDOM, reconciliation, and performance benefits.",
            "Understanding of 'minimal changes' concept."
          ],
          "example": "",
          "tags": [
            "Virtual DOM",
            "Reconciliation",
            "Performance",
            "Open-ended",
            "React"
          ],
          "prerequisites": [
            "virtual_dom_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_4",
          "topic": "Virtual DOM and Reconciliation",
          "level": "hard",
          "type": "code",
          "question": "You have a list of user comments that can be reordered by a user. Explain why using the array `index` as a `key` for list items in such a scenario is considered a bad practice and demonstrate with a simple code example how this could lead to issues. Then, provide the corrected code using a proper key.\n\n**Initial (Problematic) Code Snippet:**\n```typescript\nimport React, { useState } from 'react';\n\ninterface Comment {\n  id: string;\n  text: string;\n}\n\nfunction CommentList() {\n  const [comments, setComments] = useState<Comment[]>([\n    { id: '1', text: 'First comment' },\n    { id: '2', text: 'Second comment' },\n    { id: '3', text: 'Third comment' },\n  ]);\n\n  const reorderComments = () => {\n    // Simulate reordering by reversing the array\n    setComments([...comments].reverse());\n  };\n\n  return (\n    <div>\n      <button onClick={reorderComments}>Reorder Comments</button>\n      <ul>\n        {comments.map((comment, index) => (\n          <li key={index}> {/* PROBLEM HERE */}\n            <input type=\"text\" value={comment.text} readOnly />\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n**Tasks:**\n1.  Explain the problem with `key={index}` in this dynamic scenario.\n2.  Modify the `CommentList` component to fix the `key` issue.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Explanation of `key={index}` problem: When items are reordered, added, or removed, the indices shift. React uses keys to identify unique components/elements. If keys are indices, React might think the component at index 0 is merely updated (when it's actually a different data item that moved to index 0) instead of recognizing a reorder. This can lead to incorrect UI updates, performance issues, or loss of internal component state (e.g., an input field retaining its value even if the associated data item changes).",
            "Corrected code should use `comment.id` as the key, assuming `id` is a stable and unique identifier for each comment.",
            "The example demonstrates why `input` field is important to show the 'loss of state' issue."
          ],
          "keyConcepts": [
            "Reconciliation",
            "Key Prop",
            "List Rendering",
            "Performance",
            "State Preservation"
          ],
          "evaluationCriteria": [
            "Clear articulation of the `key={index}` pitfall.",
            "Correctly applying unique, stable keys.",
            "Demonstrating the problem with a relevant example.",
            "Understanding React's reconciliation strategy for lists."
          ],
          "example": "### Explanation of the Problem with `key={index}`:\nWhen `key={index}` is used for dynamic lists that can change order (like reordering comments), React's reconciliation algorithm becomes inefficient and problematic. React uses keys to identify list items across renders. If the order of items changes, but the keys are just their array indices, React doesn't see that the *data item* has moved; it only sees that the *index* has changed and tries to update the existing DOM element at that index with new data. This can lead to:\n\n1.  **Incorrect UI updates**: An input field might retain its old value even though the underlying data associated with that `<li>` has changed, because React reuses the `<li>` element but updates its `value` prop incorrectly or doesn't re-mount a nested component.\n2.  **Performance issues**: React might perform more DOM operations than necessary (e.g., updating content instead of simply reordering DOM nodes).\n3.  **Loss of component state**: If a list item contains stateful components (like an input with its own internal state), that state might be incorrectly transferred or lost when items are reordered because React believes the components are the same, just with updated props.\n\nIn the provided `CommentList` example, if you were to type into an input field (e.g., in the 'First comment' input) and then click 'Reorder Comments', the text you typed would stay in the input field that is now displaying 'Third comment', because React sees the input at `index=0` as the same DOM element, just with different data.\n\n### Corrected Code:\n```typescript\nimport React, { useState } from 'react';\n\ninterface Comment {\n  id: string;\n  text: string;\n}\n\nfunction CommentList() {\n  const [comments, setComments] = useState<Comment[]>([\n    { id: '1', text: 'First comment' },\n    { id: '2', text: 'Second comment' },\n    { id: '3', text: 'Third comment' },\n  ]);\n\n  const reorderComments = () => {\n    // Simulate reordering by reversing the array\n    setComments([...comments].reverse());\n  };\n\n  // To demonstrate the actual input value persistence issue, let's make the input editable.\n  const handleCommentChange = (id: string, newText: string) => {\n    setComments(comments.map(comment => \n      comment.id === id ? { ...comment, text: newText } : comment\n    ));\n  };\n\n  return (\n    <div>\n      <button onClick={reorderComments}>Reorder Comments</button>\n      <ul>\n        {comments.map((comment) => (\n          <li key={comment.id}> {/* FIX: Using comment.id as key */}\n            <input \n              type=\"text\" \n              value={comment.text} \n              onChange={(e) => handleCommentChange(comment.id, e.target.value)}\n            />\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n**Explanation of the Fix:**\nBy changing `key={index}` to `key={comment.id}`, we provide React with a stable and unique identifier for each comment item. Now, when `reorderComments` is called, React can precisely track each `Comment` object based on its `id`. If 'First comment' (id '1') moves from index 0 to index 2, React knows it's the same item '1' that has moved, rather than thinking the item at index 0 has simply changed its content. This allows React to correctly reorder the actual DOM elements and preserve any internal state (like user input in the `input` field) associated with that specific comment item.",
          "tags": [
            "React",
            "Virtual DOM",
            "Reconciliation",
            "Keys",
            "List Rendering",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_state_props",
            "list_rendering"
          ],
          "complexity": 8,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_virtual_dom_5",
          "topic": "Virtual DOM and Reconciliation",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the Big O complexity of React's reconciliation algorithm?",
          "answer": "O(n), where 'n' is the number of elements in the tree.",
          "options": [],
          "analysisPoints": [
            "Recall of algorithm efficiency."
          ],
          "keyConcepts": [
            "Reconciliation",
            "Algorithm Complexity",
            "Big O"
          ],
          "evaluationCriteria": [
            "Ability to recall specific efficiency metric."
          ],
          "example": "",
          "tags": [
            "Virtual DOM",
            "Reconciliation",
            "Performance"
          ],
          "prerequisites": [
            "data_structures_algorithms_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_6",
          "topic": "Virtual DOM and Reconciliation",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast Real DOM and Virtual DOM based on their update speed, manipulation cost, and memory usage.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Update Speed: Real DOM is slow due to browser reflow/repaint; Virtual DOM is fast (in-memory comparison).",
            "Manipulation Cost: Real DOM manipulation is expensive; Virtual DOM manipulation is cheap.",
            "Memory Usage: Real DOM can lead to wastage with frequent full updates; Virtual DOM is efficient as it only patches minimal changes.",
            "Direct HTML Update: Real DOM directly updates HTML; Virtual DOM is a JS representation, doesn't directly update HTML.",
            "Element Update Mechanism: Real DOM often re-creates if elements change; Virtual DOM updates JSX, then diffs."
          ],
          "keyConcepts": [
            "Real DOM",
            "Virtual DOM",
            "Performance",
            "Memory",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison across multiple dimensions.",
            "Accuracy of statements regarding each DOM type.",
            "Clear articulation of the advantages of Virtual DOM."
          ],
          "example": "",
          "tags": [
            "Virtual DOM",
            "Real DOM",
            "Comparison",
            "Performance",
            "Open-ended"
          ],
          "prerequisites": [
            "virtual_dom_basics",
            "dom_manipulation"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_7",
          "topic": "Virtual DOM and Reconciliation",
          "level": "hard",
          "type": "mcq",
          "question": "A React component renders a `MyCustomComponent` that has internal state. If `MyCustomComponent` is replaced by a `div` element on a subsequent render (i.e., its parent changes its type from `<MyCustomComponent />` to `<div>`), what will React's reconciliation algorithm do?",
          "answer": "Tear down `MyCustomComponent` and its entire subtree, then build a new `div` and its subtree from scratch, losing any internal state of `MyCustomComponent`.",
          "options": [
            "Keep the `MyCustomComponent` instance, update its props, and then convert it to a `div`.",
            "Tear down `MyCustomComponent` and its entire subtree, then build a new `div` and its subtree from scratch, losing any internal state of `MyCustomComponent`.",
            "Perform a deep comparison between `MyCustomComponent`'s internal structure and the `div`'s structure to apply minimal changes.",
            "Only update the DOM node type from a custom component to a `div`, preserving the child elements if they are identical."
          ],
          "analysisPoints": [
            "Tests understanding of the 'Different Element Types' heuristic in reconciliation.",
            "Emphasizes that a type change at the root of a subtree leads to a complete rebuild, not just an update.",
            "Highlights the consequence of losing internal state when a component is unmounted and remounted."
          ],
          "keyConcepts": [
            "Reconciliation Algorithm",
            "Different Element Types",
            "Component Lifecycle",
            "State Preservation"
          ],
          "evaluationCriteria": [
            "Accurate recall of reconciliation heuristics.",
            "Understanding of component unmounting/remounting implications.",
            "Ability to apply reconciliation rules to specific scenarios."
          ],
          "example": "React's reconciliation algorithm has a heuristic: if elements at the same position have different types (e.g., a custom component changes to a standard HTML element like `div`), React will tear down the old component and its children and build the new element and its children from scratch. This is because a change in type implies a complete structural change, making it more efficient to rebuild. Consequently, any internal state of `MyCustomComponent` would be lost as it's unmounted.",
          "tags": [
            "React",
            "Reconciliation",
            "Virtual DOM",
            "Component Lifecycle",
            "MCQ"
          ],
          "prerequisites": [
            "react_component_basics",
            "virtual_dom_reconciliation"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_virtual_dom_8",
          "topic": "Virtual DOM and Reconciliation",
          "level": "easy",
          "type": "flashcard",
          "question": "What is 'Batching' in the context of React's DOM updates?",
          "answer": "React collects multiple DOM updates identified during reconciliation and applies them together in a single, optimized operation to the real DOM.",
          "options": [],
          "analysisPoints": [
            "Focus on 'collects multiple updates' and 'single operation'."
          ],
          "keyConcepts": [
            "Batching",
            "DOM Updates",
            "Performance"
          ],
          "evaluationCriteria": [
            "Recall of batching mechanism."
          ],
          "example": "",
          "tags": [
            "Virtual DOM",
            "Performance",
            "React"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_9",
          "topic": "Virtual DOM and Reconciliation",
          "level": "medium",
          "type": "open",
          "question": "Beyond the `key` prop, describe another specific heuristic React's reconciliation algorithm uses to optimize updates when elements have the 'Same Element Type'.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Identify the 'Same Element Type' heuristic.",
            "Explain that React keeps the same DOM node.",
            "Describe that React only updates changed attributes.",
            "Mention recursive comparison for children."
          ],
          "keyConcepts": [
            "Reconciliation Algorithm",
            "Same Element Type",
            "Attribute Updates",
            "Recursive Diffing"
          ],
          "evaluationCriteria": [
            "Accuracy in describing the specific heuristic.",
            "Detailing the actions React takes in this scenario.",
            "Understanding of the optimization benefit."
          ],
          "example": "When React encounters two elements of the 'Same Element Type' during reconciliation (e.g., both are `div`s), it assumes that the underlying DOM node can be reused. Instead of destroying and recreating the node, React preserves the existing DOM node. It then proceeds to compare the attributes of the old and new elements. Only the attributes that have actually changed (e.g., a `className`, `style` property, or event handler) are updated on the existing real DOM node. After updating attributes, React recursively applies the reconciliation algorithm to the children of these elements, ensuring that only necessary changes are made deep within the tree.",
          "tags": [
            "Virtual DOM",
            "Reconciliation",
            "Algorithm",
            "Performance",
            "Open-ended"
          ],
          "prerequisites": [
            "virtual_dom_reconciliation"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_virtual_dom_10",
          "topic": "Virtual DOM and Reconciliation",
          "level": "hard",
          "type": "code",
          "question": "Imagine you have a `Tabs` component that renders different tab content based on a selected tab ID. Initially, Tab A (`<TabA />`) is rendered. When the user switches to Tab B (`<TabB />`), the component's `render` method changes from returning `<TabA />` to `<TabB />`.\n\nDescribe the exact steps React's reconciliation algorithm will take regarding `TabA` and `TabB` components, assuming both `TabA` and `TabB` are custom React components (not native HTML elements) and they each manage their own internal state (e.g., form inputs, toggles).\n\nProvide a simplified code structure to illustrate the scenario.\n\n```typescript\nimport React, { useState } from 'react';\n\ninterface TabContentProps {\n  // Assume some props here\n}\n\nconst TabA: React.FC<TabContentProps> = () => {\n  const [value, setValue] = useState('');\n  console.log('Rendering TabA');\n  return (\n    <div>\n      <h2>Tab A Content</h2>\n      <input type=\"text\" value={value} onChange={(e) => setValue(e.target.value)} placeholder=\"Tab A input\" />\n    </div>\n  );\n};\n\nconst TabB: React.FC<TabContentProps> = () => {\n  const [count, setCount] = useState(0);\n  console.log('Rendering TabB');\n  return (\n    <div>\n      <h2>Tab B Content</h2>\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\n    </div>\n  );\n};\n\nfunction Tabs() {\n  const [activeTab, setActiveTab] = useState<'A' | 'B'>('A');\n\n  return (\n    <div>\n      <button onClick={() => setActiveTab('A')}>Show Tab A</button>\n      <button onClick={() => setActiveTab('B')}>Show Tab B</button>\n      <div style={{ border: '1px solid black', padding: '10px', marginTop: '10px' }}>\n        {activeTab === 'A' ? <TabA /> : <TabB />}\n      </div>\n    </div>\n  );\n}\n```",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Initial Render: `Tabs` renders `TabA`.",
            "State Change: `setActiveTab('B')` causes `Tabs` to re-render.",
            "Reconciliation Step 1 (Root Element Type Check): React compares `<TabA />` (from previous render) with `<TabB />` (from current render). Since `TabA` and `TabB` are different component types, this triggers the 'Different Element Types' heuristic.",
            "Reconciliation Step 2 (Teardown): React will unmount `TabA` and its entire subtree. This means `TabA`'s internal state (`value`) will be lost, and its `console.log('Rendering TabA')` will not be called again unless it is remounted.",
            "Reconciliation Step 3 (Build New Tree): React will then mount `TabB` and construct its entire subtree from scratch. `TabB` will initialize its own state (`count` to 0), and `console.log('Rendering TabB')` will be called.",
            "Consequence: Any user input or state within `TabA` is lost when switching to `TabB`, because `TabA` is completely replaced, not merely updated.",
            "This scenario is key to understanding why component unmounting/remounting occurs."
          ],
          "keyConcepts": [
            "Reconciliation Algorithm",
            "Different Element Types",
            "Component Lifecycle",
            "State Loss",
            "Mounting/Unmounting"
          ],
          "evaluationCriteria": [
            "Accurate description of the 'Different Element Types' heuristic.",
            "Clear explanation of unmounting and remounting consequences.",
            "Understanding of how internal component state is affected.",
            "Ability to trace the reconciliation steps for complex component changes."
          ],
          "example": "When the user switches from 'Tab A' to 'Tab B' by clicking the 'Show Tab B' button:\n\n1.  **`Tabs` component re-renders**: The `setActiveTab('B')` call triggers a re-render of the `Tabs` component.\n2.  **Virtual DOM comparison**: During the reconciliation process, React compares the previous virtual DOM tree for the content area (`<TabA />`) with the new virtual DOM tree (`<TabB />`).\n3.  **Different Element Types heuristic**: React identifies that the root element in that position has changed its type from `TabA` (a custom component type) to `TabB` (another custom component type). According to its reconciliation algorithm, if the root elements have different types, React considers them fundamentally different and opts for a complete teardown and rebuild.\n4.  **`TabA` unmounts**: React will unmount `TabA` and its entire subtree. This means `TabA`'s `useState` hook's value (`value`) will be completely reset and lost. Its `console.log('Rendering TabA')` will cease to be called unless `TabA` is mounted again.\n5.  **`TabB` mounts**: React will then mount `TabB` and build its entire subtree from scratch. `TabB`'s `useState` hook will be initialized, setting `count` to `0`, and `console.log('Rendering TabB')` will be called. Any state within `TabB` will start fresh.\n\n**Consequence**: If you type something into `TabA`'s input and then switch to `TabB` and back to `TabA`, the typed content in `TabA`'s input will be gone because `TabA` was unmounted and then re-mounted from scratch, resetting its state. This behavior is expected when component types change at the same position in the tree.",
          "tags": [
            "React",
            "Virtual DOM",
            "Reconciliation",
            "Component Lifecycle",
            "State Management",
            "Hard",
            "Code Challenge"
          ],
          "prerequisites": [
            "react_state_props",
            "component_lifecycle"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_jsx_fragments_table_row",
          "title": "Build a Semantic Table Component with JSX Fragments",
          "description": "\nCreate a React component `UserTable` that renders a `<table>` containing user data. Inside the `<tbody>`, you should have a `TableRow` component responsible for rendering a single row's `<td>` elements. Crucially, the `TableRow` component itself should not add an extra wrapper `div` or similar element around its `<td>` children, to maintain semantic HTML table structure.\n\n**Requirements:**\n1.  `UserTable` component that accepts an array of user objects.\n2.  `TableRow` component that accepts a single user object.\n3.  `TableRow` must return multiple `<td>` elements using a JSX Fragment to avoid invalid HTML.\n4.  Ensure `key` props are correctly used for list items within `UserTable` to enable efficient reconciliation.\n5.  Include a header row (`<thead>`) in `UserTable` for columns like 'ID', 'Name', 'Email'.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface UserTableProps {\n  users: User[];\n}\n\n// TODO: Implement TableRow component using Fragments\n// interface TableRowProps {\n//   user: User;\n// }\n// const TableRow: React.FC<TableRowProps> = ({ user }) => {\n//   return (\n//     // Your fragment implementation here\n//   );\n// };\n\nconst UserTable: React.FC<UserTableProps> = ({ users }) => {\n  return (\n    <table border={1} style={{ width: '100%', borderCollapse: 'collapse' }}>\n      <thead>\n        <tr>\n          <th>ID</th>\n          <th>Name</th>\n          <th>Email</th>\n        </tr>\n      </thead>\n      <tbody>\n        {/* TODO: Render TableRow components here */}\n      </tbody>\n    </table>\n  );\n};\n\nexport default UserTable;\n",
          "solutionCode": "import React from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface UserTableProps {\n  users: User[];\n}\n\ninterface TableRowProps {\n  user: User;\n}\n\nconst TableRow: React.FC<TableRowProps> = ({ user }) => {\n  return (\n    <> {/* Using shorthand fragment to group <td> elements */}\n      <td>{user.id}</td>\n      <td>{user.name}</td>\n      <td>{user.email}</td>\n    </>\n  );\n};\n\nconst UserTable: React.FC<UserTableProps> = ({ users }) => {\n  return (\n    <table border={1} style={{ width: '100%', borderCollapse: 'collapse' }}>\n      <thead>\n        <tr>\n          <th>ID</th>\n          <th>Name</th>\n          <th>Email</th>\n        </tr>\n      </thead>\n      <tbody>\n        {users.map(user => (\n          <tr key={user.id}> {/* Key prop on the <tr> element */}\n            <TableRow user={user} />\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  );\n};\n\nexport default UserTable;\n",
          "testCases": [
            "Render `UserTable` with an empty `users` array: Should render an empty table body with only headers.",
            "Render `UserTable` with a few user objects: Should correctly display rows with ID, Name, and Email.",
            "Inspect the DOM: Verify that `<td>` elements are direct children of `<tr>`, and `<tr>` elements are direct children of `<tbody>`, with no intermediate `div` wrappers from `TableRow` component."
          ],
          "hints": [
            "Remember that `<tbody>` expects `<tr>` as direct children, and `<tr>` expects `<td>` or `<th>` as direct children.",
            "The shorthand fragment `<></>` is typically sufficient unless you need to pass a `key` to the fragment itself (which is rare for a component directly returning `<td>`s)."
          ],
          "tags": [
            "React",
            "JSX",
            "Fragments",
            "Semantic HTML",
            "Tables",
            "DOM"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_components",
            "jsx_syntax",
            "html_tables"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "jsx_fragments",
            "list_rendering",
            "semantic_html"
          ]
        },
        {
          "id": "task_virtual_dom_dynamic_list",
          "title": "Implement a Dynamic Todo List with Correct Keys",
          "description": "\nCreate a React component `DynamicTodoList` that allows users to add, remove, and reorder todo items. This task specifically focuses on demonstrating the importance of stable `key` props for efficient Virtual DOM reconciliation.\n\n**Requirements:**\n1.  A stateful component `DynamicTodoList` that manages an array of todo items. Each todo item should have a unique `id` (e.g., using `Date.now()` or a UUID library for new items) and a `text` property.\n2.  An input field and a button to add new todo items to the beginning of the list.\n3.  A button to remove the first todo item from the list.\n4.  A button to reorder (e.g., shuffle or reverse) the existing todo items.\n5.  Each todo item displayed in the list (`<li>` or a separate `TodoItem` component) must contain an editable input field to demonstrate potential state loss if `key`s are misused.\n6.  **Crucially**: Ensure `key` props are correctly implemented using the `id` of the todo item to prevent reconciliation issues when items are added, removed, or reordered.\n7.  Add `console.log` statements inside the `TodoItem` component (if you create one) to track its mounting/unmounting behavior when keys are correctly used vs. when they might be incorrectly used (for self-observation).\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\n\ninterface TodoItem {\n  id: string;\n  text: string;\n}\n\nconst TodoItemComponent: React.FC<{ item: TodoItem }> = ({ item }) => {\n  const [currentText, setCurrentText] = useState(item.text);\n  console.log(`TodoItemComponent ${item.id} rendered`);\n  // Using effect to show mount/unmount\n  React.useEffect(() => {\n    console.log(`TodoItemComponent ${item.id} mounted`);\n    return () => {\n      console.log(`TodoItemComponent ${item.id} unmounted`);\n    };\n  }, []);\n\n  return (\n    <li>\n      <input\n        type=\"text\"\n        value={currentText}\n        onChange={(e) => setCurrentText(e.target.value)}\n      />\n    </li>\n  );\n};\n\nconst DynamicTodoList: React.FC = () => {\n  const [todos, setTodos] = useState<TodoItem[]>([\n    { id: 'a', text: 'Learn React' },\n    { id: 'b', text: 'Master Frontend' },\n    { id: 'c', text: 'Build Awesome Apps' },\n  ]);\n  const [newTodoText, setNewTodoText] = useState('');\n\n  const addTodo = () => {\n    if (newTodoText.trim() === '') return;\n    const newId = String(Date.now()); // Simple unique ID\n    setTodos([{ id: newId, text: newTodoText }, ...todos]);\n    setNewTodoText('');\n  };\n\n  const removeFirstTodo = () => {\n    setTodos(todos.slice(1));\n  };\n\n  const shuffleTodos = () => {\n    setTodos([...todos].sort(() => Math.random() - 0.5));\n  };\n\n  return (\n    <div>\n      <h2>Dynamic Todo List</h2>\n      <div>\n        <input\n          type=\"text\"\n          value={newTodoText}\n          onChange={(e) => setNewTodoText(e.target.value)}\n          placeholder=\"Add new todo\"\n        />\n        <button onClick={addTodo}>Add Todo</button>\n      </div>\n      <div>\n        <button onClick={removeFirstTodo}>Remove First</button>\n        <button onClick={shuffleTodos}>Shuffle Todos</button>\n      </div>\n      <ul>\n        {/* TODO: Map over todos and render TodoItemComponent with correct key */}\n      </ul>\n    </div>\n  );\n};\n\nexport default DynamicTodoList;\n",
          "solutionCode": "import React, { useState } from 'react';\n\ninterface TodoItem {\n  id: string;\n  text: string;\n}\n\nconst TodoItemComponent: React.FC<{ item: TodoItem }> = ({ item }) => {\n  const [currentText, setCurrentText] = useState(item.text);\n  console.log(`TodoItemComponent ${item.id} rendered`);\n  // Using effect to show mount/unmount\n  React.useEffect(() => {\n    console.log(`TodoItemComponent ${item.id} mounted`);\n    return () => {\n      console.log(`TodoItemComponent ${item.id} unmounted`);\n    };\n  }, []);\n\n  return (\n    <li>\n      <input\n        type=\"text\"\n        value={currentText}\n        onChange={(e) => setCurrentText(e.target.value)}\n      />\n    </li>\n  );\n};\n\nconst DynamicTodoList: React.FC = () => {\n  const [todos, setTodos] = useState<TodoItem[]>([\n    { id: 'a', text: 'Learn React' },\n    { id: 'b', text: 'Master Frontend' },\n    { id: 'c', text: 'Build Awesome Apps' },\n  ]);\n  const [newTodoText, setNewTodoText] = useState('');\n\n  const addTodo = () => {\n    if (newTodoText.trim() === '') return;\n    const newId = String(Date.now()); // Simple unique ID\n    setTodos([{ id: newId, text: newTodoText }, ...todos]);\n    setNewTodoText('');\n  };\n\n  const removeFirstTodo = () => {\n    setTodos(todos.slice(1));\n  };\n\n  const shuffleTodos = () => {\n    setTodos([...todos].sort(() => Math.random() - 0.5));\n  };\n\n  return (\n    <div>\n      <h2>Dynamic Todo List</h2>\n      <div>\n        <input\n          type=\"text\"\n          value={newTodoText}\n          onChange={(e) => setNewTodoText(e.target.value)}\n          placeholder=\"Add new todo\"\n        />\n        <button onClick={addTodo}>Add Todo</button>\n      </div>\n      <div>\n        <button onClick={removeFirstTodo}>Remove First</button>\n        <button onClick={shuffleTodos}>Shuffle Todos</button>\n      </div>\n      <ul>\n        {todos.map((todo) => (\n          <TodoItemComponent key={todo.id} item={todo} /> // Correctly using todo.id as key\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport default DynamicTodoList;\n",
          "testCases": [
            "Initial render: Verify all default todos are displayed.",
            "Add a new todo: Add a new item. Verify it appears at the top. Check the console for `TodoItemComponent` mount/unmount logs (only the new item should mount).",
            "Type into an input field, then shuffle: Type some text into the second todo item's input. Click 'Shuffle Todos'. Verify the text you typed follows the original todo item, proving state preservation. Observe console logs to confirm no unnecessary remounts.",
            "Type into an input field, then remove first: Type some text into the second todo item's input. Click 'Remove First'. Verify the first item is removed and your typed text remains with its original todo item (which is now the first). Observe console logs for correct unmounting of only the removed item.",
            "Replace `key={todo.id}` with `key={index}` temporarily: Repeat the 'Type into input then shuffle' test. Observe that the typed text likely stays with the _position_ instead of the _original todo item_, demonstrating the issue with `key={index}`."
          ],
          "hints": [
            "The `key` prop should be placed on the element directly inside the `map()` callback. In this case, it's on `TodoItemComponent`.",
            "Ensure your `TodoItem`'s `key` is based on `item.id`, not the array `index`.",
            "Use `console.log` statements in the `TodoItemComponent` to observe how often it mounts/unmounts with different key strategies. This is a great way to visually confirm the reconciliation behavior.",
            "For unique IDs, `Date.now().toString()` is a simple solution for this example, but in production, UUID libraries (`uuid`) are preferred."
          ],
          "tags": [
            "React",
            "Virtual DOM",
            "Reconciliation",
            "Keys",
            "List Rendering",
            "State Management",
            "Performance"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_state_props",
            "list_rendering",
            "virtual_dom_reconciliation"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "virtual_dom_reconciliation",
            "keys_in_lists",
            "component_lifecycle"
          ]
        }
      ]
    }
  }
]