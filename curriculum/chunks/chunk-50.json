[
  {
    "id": "fa6bfc6c-5475-4e6a-99e9-4e1e16383e0f",
    "startLine": 10000,
    "endLine": 10099,
    "processedDate": "2025-06-17T11:25:31.353Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_class_components",
          "title": "React Class Components: State, Props, and Controlled Components",
          "content": "React class components are a fundamental building block in older React applications, though functional components with hooks are now more common. They are JavaScript classes that extend `React.Component` and encapsulate their own state and lifecycle methods.\n\n## Core Concepts\n-   **`React.Component`**: The base class for all class components. Components inherit methods like `setState`, `render`, and various lifecycle methods.\n-   **`constructor(props)`**: The constructor is called before the component is mounted. It's the place to initialize local `state` and bind event handler methods. You must call `super(props)` inside the constructor.\n-   **`this.state`**: An object that holds local component state. State is private and mutable, but should only be updated using `setState`.\n-   **`setState(updater, callback)`**: The primary way to update component state. It asynchronously merges the `updater` (an object or a function) into `this.state` and re-renders the component. The `callback` is optional and executes after the state update is complete and the component has re-rendered.\n-   **`this.props`**: An object containing the properties passed down from a parent component. Props are immutable and read-only within the component that receives them.\n-   **`render()`**: A required method in class components that returns the JSX (React elements) to be rendered. It should be a pure function, meaning it doesn't modify component state or interact with the browser directly.\n\n## Controlled Components\nInput elements (like `<input>`, `<textarea>`, `<select>`) in React forms typically manage their own state. This is known as a \"controlled component.\" The input's value is controlled by React state, and changes are handled via an `onChange` event handler, which updates the state.\n\n### Form Handling\n-   **`onSubmit`**: An event handler attached to the `<form>` element. It's crucial to call `event.preventDefault()` inside this handler to stop the browser's default form submission behavior (which would cause a full page reload).\n-   **`trim()`**: A string method often used to remove whitespace from both ends of a string, useful for validating user input.\n\nIn `PhoneForm.jsx`, we see a classic example of a controlled component:\n```jsx\n// PhoneForm.jsx\nimport React from 'react';\n\nclass PhoneForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { phoneInput: '' };\n  }\n  \n  handleSubmit = (e) => { // Using class field for auto-binding 'this'\n    e.preventDefault();\n    if (this.state.phoneInput.trim()) {\n      this.props.addPhone(this.state.phoneInput);\n      this.setState({ phoneInput: '' }); // Clear input\n    }\n  }\n  \n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <input \n          type=\"text\" \n          value={this.state.phoneInput}\n          onChange={e => this.setState({ phoneInput: e.target.value })} // Controlled input\n          placeholder=\"Enter phone model\"\n        />\n        <button type=\"submit\">Add Phone</button>\n      </form>\n    );\n  }\n}\n```",
          "examples": [
            {
              "id": "example_class_component_state_1",
              "title": "Basic Class Component with State",
              "code": "import React from 'react';\n\nclass Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  increment = () => {\n    this.setState(prevState => ({ \n      count: prevState.count + 1 \n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n// ReactDOM.render(<Counter />, document.getElementById('root'));",
              "explanation": "This example demonstrates a simple `Counter` class component. The `count` is stored in `this.state`. The `increment` method uses `setState` with a functional updater to safely update the count, ensuring the update is based on the most recent state. The `render` method displays the current count and a button to trigger the update.",
              "language": "jsx"
            },
            {
              "id": "example_class_component_props_2",
              "title": "Passing and Receiving Props",
              "code": "import React from 'react';\n\nclass WelcomeMessage extends React.Component {\n  render() {\n    return (\n      <p>Hello, {this.props.name}!</p>\n    );\n  }\n}\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div>\n        <WelcomeMessage name=\"Alice\" />\n        <WelcomeMessage name=\"Bob\" />\n      </div>\n    );\n  }\n}\n// ReactDOM.render(<App />, document.getElementById('root'));",
              "explanation": "This example shows how props are passed from a parent `App` component to child `WelcomeMessage` components. The `name` prop is accessed within `WelcomeMessage` via `this.props.name`. Props are read-only and allow components to communicate data downwards in the component tree.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_class_component_lifecycle_1",
            "question_controlled_component_1",
            "question_setstate_async_1"
          ],
          "relatedTasks": [
            "task_implement_phone_item",
            "task_refactor_phoneform_hooks"
          ],
          "tags": [
            "React",
            "Class Components",
            "State Management",
            "Props",
            "Controlled Components",
            "Forms"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_es6_classes",
            "javascript_arrow_functions"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_functional_components",
            "react_hooks",
            "redux_integration"
          ]
        },
        {
          "id": "theory_react_list_rendering_keys",
          "title": "React List Rendering and The Importance of Keys",
          "content": "Rendering lists of elements is a common pattern in React applications. When rendering dynamic lists, it's crucial to understand how React re-renders and updates these lists efficiently. The `map()` array method is commonly used to transform an array of data into an array of React elements.\n\n## Key Concepts\n-   **`map()` Method**: Used to iterate over an array and transform each item into a new React element (e.g., a component instance).\n-   **`key` Prop**: A special string attribute that you need to include when creating lists of elements. Keys help React identify which items have changed, are added, or are removed. They give a stable identity to elements in the list.\n-   **Reconciliation**: React uses a reconciliation algorithm to efficiently update the DOM. When rendering lists, keys play a vital role in this process, allowing React to match existing elements in the DOM to new elements in the virtual DOM. Without stable keys, React might re-render or re-order elements inefficiently, leading to performance issues or incorrect component state.\n-   **Choosing Keys**: Keys must be unique among siblings in a list. The most stable and recommended choice for a key is a unique ID from your data (e.g., a database ID). If items do not have stable IDs, you might fall back to the item's `index` within the array, but this is generally discouraged for dynamic lists as it can lead to problems if the list items are reordered, added, or removed, potentially causing state issues or incorrect rendering.\n-   **Common Pitfall**: Using array `index` as a `key` when the list can change order, filter, or be modified. This can lead to unexpected behavior, performance degradation, and incorrect component state.\n\nIn `PhonesList.jsx`, we see a correct usage of the `key` prop:\n```jsx\n// PhonesList.jsx\nimport React from 'react';\nimport PhoneItem from './PhoneItem';\n\nclass PhonesList extends React.Component {\n  render() {\n    return (\n      <div className=\"phones-list\">\n        <h2>Phones List</h2>\n        {this.props.phones?.map(phone => (\n          <PhoneItem \n            key={phone} // 'phone' itself is assumed to be unique string (e.g., 'iPhone 13 Pro')\n            text={phone}\n            deletePhone={this.props.deletePhone}\n          />\n        ))}\n      </div>\n    );\n  }\n}\n```\nHere, it is assumed that `phone` (which is likely a string like 'iPhone X') is unique within the list. If it were an object with an `id`, `key={phone.id}` would be more robust.",
          "examples": [
            {
              "id": "example_list_rendering_correct_1",
              "title": "Correct List Rendering with Unique ID Keys",
              "code": "import React from 'react';\n\nfunction Item({ id, name }) {\n  return <li>{name} (ID: {id})</li>;\n}\n\nfunction ItemList({ items }) {\n  return (\n    <ul>\n      {items.map(item => (\n        <Item key={item.id} id={item.id} name={item.name} />\n      ))}\n    </ul>\n  );\n}\n\nconst data = [\n  { id: 1, name: 'Apple' },\n  { id: 2, name: 'Banana' },\n  { id: 3, name: 'Cherry' }\n];\n\n// ReactDOM.render(<ItemList items={data} />, document.getElementById('root'));",
              "explanation": "This example demonstrates the correct way to render a list using `map` and a unique `id` from the data as the `key` prop. This ensures React can efficiently update, add, or remove list items without issues.",
              "language": "jsx"
            },
            {
              "id": "example_list_rendering_incorrect_2",
              "title": "Incorrect List Rendering with Index as Key (Bad Practice)",
              "code": "import React from 'react';\n\nfunction BadItem({ name }) {\n  return <li>{name}</li>;\n}\n\nfunction BadItemList({ items }) {\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <BadItem key={index} name={item.name} /> // DANGER: Using index as key\n      ))}\n    </ul>\n  );\n}\n\n// Imagine items being reordered, added, or removed. This can cause bugs.\nconst dynamicData = ['First', 'Second', 'Third']; \n\n// ReactDOM.render(<BadItemList items={dynamicData} />, document.getElementById('root'));",
              "explanation": "This example shows the incorrect use of array `index` as a `key`. While it might work for static lists that never change, it can lead to unpredictable behavior, incorrect component state, and performance issues in dynamic lists where items are added, removed, or reordered.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_list_keys_purpose_1",
            "question_index_keys_problem_1",
            "question_reconciliation_keys_1"
          ],
          "relatedTasks": [
            "task_implement_phone_item",
            "task_enhance_phone_catalog_filtering"
          ],
          "tags": [
            "React",
            "Lists",
            "Keys",
            "Reconciliation",
            "Performance",
            "JSX"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_array_methods",
            "react_props"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "advanced_react_patterns",
            "state_management_performance"
          ]
        },
        {
          "id": "theory_redux_core_concepts",
          "title": "Redux Core Concepts: Actions, Reducers, and Store",
          "content": "Redux is a predictable state container for JavaScript apps. It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test. It's often associated with React, but can be used with any UI library.\n\n## Three Principles of Redux\n1.  **Single Source of Truth**: The state of your whole application is stored in a single object tree within a single *store*.\n2.  **State is Read-Only**: The only way to change the state is to emit an *action*, an object describing what happened.\n3.  **Changes are Made with Pure Functions**: To specify how the state tree is transformed by actions, you write pure *reducers*.\n\n## Key Concepts\n-   **Store**: The single source of truth for the application's state. It holds the state, allows access to the state via `getState()`, allows the state to be updated via `dispatch(action)`, and registers listeners via `subscribe(listener)`.\n-   **Actions**: Plain JavaScript objects that describe what happened. They must have a `type` property, which is typically a string constant. They can also carry data (payload) about the event.\n    ```javascript\n    // actions.js (example inferred from AppView.jsx)\n    export const ADD_PHONE = 'ADD_PHONE';\n    export const DELETE_PHONE = 'DELETE_PHONE';\n\n    export const addPhone = (phoneModel) => ({\n      type: ADD_PHONE,\n      payload: phoneModel,\n    });\n\n    export const deletePhone = (phoneModel) => ({\n      type: DELETE_PHONE,\n      payload: phoneModel,\n    });\n    ```\n-   **Reducers**: Pure functions that take the current `state` and an `action` as arguments, and return a *new* state. They must **not** mutate the original state directly. Instead, they return a new state object if changes are needed. Reducers specify how the application's state changes in response to actions.\n    ```javascript\n    // reducer.js (example inferred from AppView.jsx)\n    import { ADD_PHONE, DELETE_PHONE } from './actions';\n    import { Map, List } from 'immutable'; // Likely using Immutable.js based on state.get('phones')\n\n    const initialState = Map({\n      phones: List(['iPhone X', 'Samsung Galaxy S21'])\n    });\n\n    function rootReducer(state = initialState, action) {\n      switch (action.type) {\n        case ADD_PHONE:\n          // Immutable update: add new phone to the List\n          return state.update('phones', phones => phones.push(action.payload));\n        case DELETE_PHONE:\n          // Immutable update: remove phone from the List\n          return state.update('phones', phones => phones.filter(phone => phone !== action.payload));\n        default:\n          return state;\n      }\n    }\n\n    export default rootReducer;\n    ```\n-   **Immutability**: A core concept in Redux. State objects should never be directly modified. Instead, new state objects should be created with the desired changes. This makes state changes predictable, traceable, and helps with performance optimizations in React (e.g., `shouldComponentUpdate`). The provided code suggests the use of `Immutable.js` given `state.get('phones')` and `state.update('phones', ...)`, which provides efficient immutable data structures.\n-   **`combineReducers`**: When an application grows, it's common to split the root reducer into smaller, specialized reducers. `combineReducers` from Redux helps combine these individual reducers into a single root reducer.\n-   **Redux DevTools**: A powerful browser extension that provides time-travel debugging, action inspection, and state visualization, greatly aiding development.",
          "examples": [
            {
              "id": "example_redux_action_creator_1",
              "title": "Action Creator Example",
              "code": "export const SET_USER_NAME = 'SET_USER_NAME';\n\nexport const setUserName = (name) => ({\n  type: SET_USER_NAME,\n  payload: { name },\n});\n\n// Usage: store.dispatch(setUserName('Alice'));",
              "explanation": "This defines an action type constant `SET_USER_NAME` and an action creator function `setUserName`. The action creator returns a plain JavaScript object (the 'action') with a `type` property and a `payload` carrying the data.",
              "language": "javascript"
            },
            {
              "id": "example_redux_reducer_basic_2",
              "title": "Basic Reducer Example (Plain JS Objects)",
              "code": "const initialState = {\n  userName: '',\n  isAuthenticated: false,\n};\n\nfunction userReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'SET_USER_NAME':\n      return { ...state, userName: action.payload.name }; // Immutable update\n    case 'LOGIN_SUCCESS':\n      return { ...state, isAuthenticated: true }; // Immutable update\n    default:\n      return state;\n  }\n}\n\n// Note: This example uses plain JS objects for state. The provided code likely uses Immutable.js.",
              "explanation": "This reducer function handles actions related to user state. It takes the current `state` and an `action` and returns a *new* state object. It uses the spread operator (`...state`) to create a shallow copy of the existing state before modifying specific properties, thus ensuring immutability.",
              "language": "javascript"
            },
            {
              "id": "example_redux_store_setup_3",
              "title": "Basic Redux Store Setup",
              "code": "import { createStore } from 'redux';\n// Assuming you have a rootReducer defined elsewhere\n// import rootReducer from './reducer'; \n\nconst exampleRootReducer = (state = { data: [] }, action) => {\n  switch (action.type) {\n    case 'ADD_DATA':\n      return { ...state, data: [...state.data, action.payload] };\n    default:\n      return state;\n  }\n};\n\nconst store = createStore(exampleRootReducer);\n\n// console.log(store.getState()); // Access current state\n// store.dispatch({ type: 'ADD_DATA', payload: 'New Item' }); // Dispatch an action\n// console.log(store.getState());",
              "explanation": "This demonstrates how to create a Redux store using `createStore` and a `rootReducer`. The store is the central hub where the application state resides. You can `getState()` to read it and `dispatch()` actions to update it.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_redux_principles_1",
            "question_reducer_immutability_1",
            "question_action_reducer_data_flow_1",
            "question_immutable_js_usage_1"
          ],
          "relatedTasks": [
            "task_implement_redux_actions_reducer",
            "task_setup_redux_store"
          ],
          "tags": [
            "Redux",
            "State Management",
            "Actions",
            "Reducers",
            "Store",
            "Immutability",
            "Flux Architecture"
          ],
          "technology": "Redux",
          "prerequisites": [
            "javascript_objects",
            "javascript_functions",
            "javascript_es6_modules"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_redux_integration",
            "complex_state_management"
          ]
        },
        {
          "id": "theory_react_redux_integration",
          "title": "`react-redux`: Connecting React Components to Redux",
          "content": "`react-redux` is the official React binding for Redux. It provides utilities to seamlessly integrate Redux into your React application, handling the subscription logic and ensuring components re-render only when relevant parts of the state change.\n\n## Key Components and Functions\n-   **`<Provider store>`**: A special React component from `react-redux` that makes the Redux store available to any nested component that needs to access it. It should be rendered once at the root of your application, wrapping your main application component.\n    ```jsx\n    // index.js (simplified example)\n    import React from 'react';\n    import ReactDOM from 'react-dom';\n    import { Provider } from 'react-redux';\n    import store from './store'; // Your Redux store\n    import AppView from './AppView'; // Your root React component\n\n    ReactDOM.render(\n      <Provider store={store}>\n        <AppView />\n      </Provider>,\n      document.getElementById('root')\n    );\n    ```\n-   **`connect([mapStateToProps], [mapDispatchToProps])`**: This is a higher-order component (HOC) provided by `react-redux` that connects a React component to the Redux store. It returns a new, connected component that wraps your original component.\n    -   **`mapStateToProps(state, [ownProps])`**: An optional function that receives the entire Redux `state` and the component's `ownProps`. It should return an object where each key-value pair will be merged into the connected component's props. This function determines which parts of the Redux state your component needs to access.\n        ```javascript\n        function mapStateToProps(state) {\n          // In our example, state is likely an Immutable.js Map\n          return {\n            phones: state.get('phones') // Maps 'phones' from Redux state to 'phones' prop\n          };\n        }\n        ```\n    -   **`mapDispatchToProps(dispatch, [ownProps])`**: An optional function or object that receives the Redux `dispatch` function. It should return an object whose values are action creators or functions that dispatch actions. These functions will be merged into the connected component's props, allowing the component to dispatch actions.\n        -   **As an Object**: When `mapDispatchToProps` is passed as an object (as seen in the provided `AppView.jsx` example with `* as actions`), `react-redux` automatically wraps the action creators with `dispatch()`. This is a convenient shorthand.\n            ```javascript\n            // AppView.jsx\n            import * as actions from './actions'; // actions object contains { addPhone, deletePhone }\n\n            // ...\n            export default connect(mapStateToProps, actions)(AppView); \n            // This makes this.props.addPhone and this.props.deletePhone available\n            // and they will automatically dispatch the corresponding Redux actions.\n            ```\n        -   **As a Function**: More explicit control over dispatching. Useful if you need to dispatch multiple actions or perform logic before dispatching.\n            ```javascript\n            // Example as a function\n            function mapDispatchToProps(dispatch) {\n              return {\n                addPhone: (phoneModel) => dispatch(addPhone(phoneModel)),\n                deletePhone: (phoneModel) => dispatch(deletePhone(phoneModel)),\n                // You can also define custom functions that dispatch multiple actions\n                // combinedAction: (data) => {\n                //   dispatch(action1(data));\n                //   dispatch(action2());\n                // }\n              };\n            }\n            ```\n\n## Data Flow with `react-redux`\n1.  **User Interaction**: A user interacts with a React component (e.g., clicks a button, types in an input).\n2.  **Dispatch Action**: The component calls a prop function (e.g., `this.props.addPhone`) that, behind the scenes, dispatches a Redux action to the store.\n3.  **Reducer Update**: The Redux store receives the action and passes it to the root reducer. The reducer calculates a new state based on the action and the previous state.\n4.  **State Update**: The store's state is updated.\n5.  **`mapStateToProps` Re-evaluation**: `react-redux` (via `connect`) detects the state change. It re-runs `mapStateToProps` for all connected components.\n6.  **Component Re-render**: If the data returned by `mapStateToProps` has shallowly changed, the connected component and its children re-render with the new props.\n\n```jsx\n// AppView.jsx\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport PhonesList from './PhonesList';\nimport PhoneForm from './PhoneForm';\nimport * as actions from './actions'; // Imports all action creators\n\nclass AppView extends React.Component {\n  render() {\n    return (\n      <div className=\"app-container\">\n        <h1>Phone Catalog App</h1>\n        {/* addPhone prop is injected via connect(..., actions) */}\n        <PhoneForm addPhone={this.props.addPhone} /> \n        {/* phones and deletePhone props are injected via connect(mapStateToProps, actions) */}\n        <PhonesList {...this.props} /> \n      </div>\n    );\n  }\n}\n\n// Maps Redux state to component props\nfunction mapStateToProps(state) {\n  return {\n    // Assumes state is an Immutable.js Map\n    phones: state.get('phones') \n  };\n}\n\n// Connects AppView to Redux store\n// mapStateToProps provides 'phones' prop\n// actions object provides 'addPhone' and 'deletePhone' (assuming they exist in actions.js)\nexport default connect(mapStateToProps, actions)(AppView);\n```",
          "examples": [
            {
              "id": "example_react_redux_provider_1",
              "title": "Root Component with Provider",
              "code": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { createStore } from 'redux';\n\nconst rootReducer = (state = { data: 'initial' }, action) => {\n  switch (action.type) {\n    case 'UPDATE_DATA':\n      return { ...state, data: action.payload };\n    default:\n      return state;\n  }\n};\n\nconst store = createStore(rootReducer);\n\nconst App = () => <div>Hello React-Redux!</div>;\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n",
              "explanation": "This example shows the `Provider` component wrapping the root `App` component. It passes the Redux `store` as a prop, making the store available to all components within the `App` component tree that are connected using `connect`.",
              "language": "jsx"
            },
            {
              "id": "example_react_redux_connect_2",
              "title": "Connected Component with mapStateToProps and mapDispatchToProps",
              "code": "import React from 'react';\nimport { connect } from 'react-redux';\n\n// Action creators\nconst increment = () => ({ type: 'INCREMENT' });\nconst decrement = () => ({ type: 'DECREMENT' });\n\nclass CounterDisplay extends React.Component {\n  render() {\n    return (\n      <div>\n        <p>Count: {this.props.count}</p>\n        <button onClick={this.props.increment}>+</button>\n        <button onClick={this.props.decrement}>-</button>\n      </div>\n    );\n  }\n}\n\nfunction mapStateToProps(state) {\n  return { count: state.count };\n}\n\n// Using mapDispatchToProps as an object shorthand\nconst mapDispatchToProps = {\n  increment,\n  decrement\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(CounterDisplay);",
              "explanation": "This `CounterDisplay` component is connected to Redux. `mapStateToProps` extracts `count` from the Redux state and provides it as a prop. `mapDispatchToProps` (as an object) automatically binds `increment` and `decrement` action creators, making them available as props that dispatch actions when called.",
              "language": "jsx"
            }
          ],
          "relatedQuestions": [
            "question_provider_role_1",
            "question_connect_params_1",
            "question_mapstatetoprops_purpose_1",
            "question_mapdispatchtoprops_object_shorthand_1"
          ],
          "relatedTasks": [
            "task_implement_redux_actions_reducer",
            "task_setup_redux_store",
            "task_enhance_phone_catalog_filtering"
          ],
          "tags": [
            "React",
            "Redux",
            "react-redux",
            "Provider",
            "Connect",
            "mapStateToProps",
            "mapDispatchToProps",
            "HOC"
          ],
          "technology": "React, Redux",
          "prerequisites": [
            "redux_core_concepts",
            "react_props"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "requiredFor": [
            "enterprise_react_apps",
            "large_scale_state_management"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_react_class_component_lifecycle_1",
          "topic": "React Class Components",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary method that must be implemented in a React class component to render JSX?",
          "answer": "The `render()` method.",
          "options": [],
          "analysisPoints": [
            "Tests basic knowledge of React class component structure.",
            "Highlights the core rendering method."
          ],
          "keyConcepts": [
            "React Class Components",
            "render method"
          ],
          "evaluationCriteria": [
            "Recall of basic React syntax"
          ],
          "example": "",
          "tags": [
            "React",
            "Class Components",
            "Basics"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_controlled_component_1",
          "topic": "React Controlled Components",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React component for an input field:\n\n```jsx\nclass MyInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: '' };\n  }\n\n  handleChange = (e) => {\n    this.setState({ value: e.target.value });\n  };\n\n  render() {\n    return (\n      <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n    );\n  }\n}\n```\n\nWhich of the following best describes the `input` element in `MyInput`?",
          "answer": "It is a controlled component.",
          "options": [
            "It is an uncontrolled component.",
            "It is a controlled component.",
            "It directly modifies the DOM.",
            "It uses a ref to manage its value."
          ],
          "analysisPoints": [
            "Assesses understanding of controlled vs. uncontrolled components.",
            "Checks knowledge of `value` and `onChange` props in forms.",
            "Distinguishes between direct DOM manipulation and React's declarative approach."
          ],
          "keyConcepts": [
            "Controlled Components",
            "React State",
            "Forms",
            "onChange event"
          ],
          "evaluationCriteria": [
            "Ability to identify controlled components",
            "Understanding of React form handling"
          ],
          "example": "A controlled component means that its value is controlled by React state. The `value` prop is set to `this.state.value`, and any changes to the input trigger `onChange`, which then calls `this.setState` to update the state, and consequently, the input's displayed value. This creates a single source of truth for the input's value.",
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "State"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_setstate_async_1",
          "topic": "React State Management",
          "level": "medium",
          "type": "open",
          "question": "The `setState` method in React is asynchronous. What are the implications of this, and how can you ensure that code runs after the state has been updated?",
          "answer": "The asynchronous nature of `setState` means that React may batch multiple `setState` calls for performance, and the state update might not be immediately reflected after calling `setState`. This implies that you cannot rely on `this.state` immediately after a `setState` call to contain the new value.\n\nTo ensure code runs after the state has been updated, there are two primary methods:\n\n1.  **Callback Function**: `setState` accepts an optional second argument, which is a callback function that will be executed once the state update is complete and the component has re-rendered.\n    ```javascript\n    this.setState({ count: this.state.count + 1 }, () => {\n      console.log('New count after update:', this.state.count);\n    });\n    ```\n2.  **Lifecycle Methods (for class components)** or **`useEffect` Hook (for functional components)**: In class components, `componentDidUpdate` is called after every render, provided `shouldComponentUpdate` returns `true`. In functional components, the `useEffect` hook with appropriate dependencies can be used to run code after a state change.\n    ```javascript\n    // Class Component\n    componentDidUpdate(prevProps, prevState) {\n      if (prevState.count !== this.state.count) {\n        console.log('Count changed to:', this.state.count);\n      }\n    }\n\n    // Functional Component (with Hooks)\n    import React, { useState, useEffect } from 'react';\n\n    function MyComponent() {\n      const [count, setCount] = useState(0);\n\n      useEffect(() => {\n        console.log('Count updated:', count);\n      }, [count]); // Rerun when 'count' changes\n\n      return <button onClick={() => setCount(count + 1)}>Increment</button>;\n    }\n    ```",
          "options": [],
          "analysisPoints": [
            "Tests understanding of `setState`'s asynchronous behavior.",
            "Requires knowledge of methods to handle post-state-update logic.",
            "Differentiates between immediate state access and eventual state consistency."
          ],
          "keyConcepts": [
            "setState",
            "Asynchronous Operations",
            "React State",
            "Callbacks",
            "Lifecycle Methods",
            "useEffect Hook"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation",
            "Completeness of solutions",
            "Demonstration of practical knowledge"
          ],
          "example": "",
          "tags": [
            "React",
            "State Management",
            "Asynchronous",
            "setState",
            "Lifecycle"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_list_keys_purpose_1",
          "topic": "React List Rendering",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `key` prop when rendering lists in React?",
          "answer": "The `key` prop helps React identify which items have changed, are added, or are removed, allowing it to efficiently update the UI during reconciliation.",
          "options": [],
          "analysisPoints": [
            "Tests fundamental understanding of React list optimization.",
            "Highlights the role of keys in reconciliation."
          ],
          "keyConcepts": [
            "React Lists",
            "Keys",
            "Reconciliation",
            "Performance"
          ],
          "evaluationCriteria": [
            "Recall of key concept",
            "Conciseness"
          ],
          "example": "",
          "tags": [
            "React",
            "Lists",
            "Keys",
            "Performance"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_index_keys_problem_1",
          "topic": "React List Rendering Best Practices",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following scenarios is MOST likely to cause issues if you use the array `index` as the `key` prop for list items in React?\n\nA. The list is static and never changes.\nB. The list items are fetched asynchronously.\nC. Items are frequently added, removed, or reordered in the list.\nD. The list is rendered only once on component mount.\n\n```jsx\n// Example of using index as key\n{\n  myItems.map((item, index) => (\n    <MyListItem key={index} data={item} />\n  ));\n}\n```",
          "answer": "C. Items are frequently added, removed, or reordered in the list.",
          "options": [
            "A. The list is static and never changes.",
            "B. The list items are fetched asynchronously.",
            "C. Items are frequently added, removed, or reordered in the list.",
            "D. The list is rendered only once on component mount."
          ],
          "analysisPoints": [
            "Evaluates understanding of `key` prop's interaction with dynamic lists.",
            "Tests knowledge of common pitfalls in React list rendering.",
            "Distinguishes between safe and unsafe uses of `index` as a key."
          ],
          "keyConcepts": [
            "React Lists",
            "Keys",
            "Reconciliation",
            "Dynamic Lists",
            "Performance Issues"
          ],
          "evaluationCriteria": [
            "Identification of problematic scenarios",
            "Understanding of reconciliation implications"
          ],
          "example": "When items are added, removed, or reordered, using `index` as a key can lead to bugs. For example, if an item is inserted in the middle of a list, all subsequent items' indices (and thus their keys) will change. React sees this as completely different components, leading to re-rendering of existing components, loss of internal state (like input values), and potentially incorrect UI updates. Stable, unique IDs are essential for dynamic lists.",
          "tags": [
            "React",
            "Lists",
            "Keys",
            "Best Practices",
            "Performance"
          ],
          "prerequisites": [
            "react_list_rendering_keys"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_reconciliation_keys_1",
          "topic": "React Reconciliation",
          "level": "hard",
          "type": "open",
          "question": "Explain how React's reconciliation algorithm uses the `key` prop to optimize updates to lists of elements. Provide a scenario where not using a proper key (e.g., using `index` as key) can lead to a subtle bug.",
          "answer": "React's reconciliation algorithm is a process by which React updates the browser's DOM to match the new virtual DOM. When dealing with lists, React needs an efficient way to determine which list items are new, which have changed, and which have been removed, rather than re-rendering every item from scratch.\n\n**How `key` Prop Optimizes Updates:**\nWhen React compares two lists of children, it iterates over both lists simultaneously. If the elements have keys, React uses these keys to match children in the original tree with children in the subsequent tree. This allows React to:\n1.  **Identify unique elements**: A `key` provides a stable identity to each element, independent of its position in the array.\n2.  **Reorder existing elements**: If a key exists in both the old and new lists, React can simply move the DOM element rather than re-creating it.\n3.  **Detect additions/removals**: If a key is present in the new list but not the old, React creates a new component/DOM element. If a key is in the old list but not the new, React destroys the corresponding component/DOM element.\nThis intelligent matching significantly improves performance by minimizing actual DOM manipulations.\n\n**Scenario with a Subtle Bug (Using `index` as `key`):**\nConsider a to-do list where each item has an input field, and you can delete items:\n\n```jsx\n// Initial state:\nconst todos = [\n  { id: 1, text: 'Task A' },\n  { id: 2, text: 'Task B' },\n  { id: 3, text: 'Task C' }\n];\n\n// If rendered with key={index}:\n<input key={0} value=\"Task A\" />\n<input key={1} value=\"Task B\" />\n<input key={2} value=\"Task C\" />\n\n// Now, imagine the user types \"edited\" into the input for 'Task B'.\n// The UI shows: 'Task A', 'edited', 'Task C'\n\n// Then, 'Task A' is deleted:\nconst newTodos = [\n  { id: 2, text: 'Task B' }, // This was originally Task B\n  { id: 3, text: 'Task C' }\n];\n\n// If still rendered with key={index}:\n// React sees:\n<input key={0} value=\"Task B\" /> // Matches old key=0 (Task A's original position)\n<input key={1} value=\"Task C\" /> // Matches old key=1 (Task B's original position)\n```\n**The Bug**: When 'Task A' is deleted, 'Task B' moves from index `1` to `0`, and 'Task C' moves from `2` to `1`. Since `key={index}`, React will see:\n-   The component with `key=0` (originally 'Task A') now needs to render 'Task B'.\n-   The component with `key=1` (originally 'Task B') now needs to render 'Task C'.\n\nInstead of correctly updating the `value` of the existing `Task B` input and removing `Task A`'s input, React will likely just update the content of the existing elements based on their new positions. Crucially, the input for 'Task B' (which had `value=\"edited\"`) might retain its internal DOM state (`\"edited\"`) even though it's now displaying 'Task C's data based on its *new* index. The 'edited' text will incorrectly be associated with 'Task C's visual representation, or disappear entirely, because React thought it was just updating the item at index `1` with new props, rather than identifying that the original item at index `1` moved and the item at index `0` was removed.\n\nThis leads to state inconsistencies: the displayed UI (e.g., the text 'edited') does not match the underlying data or user's intention, because the `key` did not uniquely identify the *content* but rather its *position*.",
          "options": [],
          "analysisPoints": [
            "Deep understanding of React's reconciliation algorithm.",
            "Ability to articulate the specific benefits of keys beyond 'performance'.",
            "Skill in designing a scenario to demonstrate a subtle, hard-to-debug issue caused by misuse of keys."
          ],
          "keyConcepts": [
            "Reconciliation",
            "React Keys",
            "Virtual DOM",
            "Performance Optimization",
            "State Inconsistency"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of explanation",
            "Effectiveness of scenario demonstration",
            "Depth of technical detail"
          ],
          "example": "",
          "tags": [
            "React",
            "Lists",
            "Keys",
            "Reconciliation",
            "Bugs",
            "Performance",
            "Hard"
          ],
          "prerequisites": [
            "react_list_rendering_keys"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_redux_principles_1",
          "topic": "Redux Core Concepts",
          "level": "easy",
          "type": "flashcard",
          "question": "Name the three core principles of Redux.",
          "answer": "1. Single Source of Truth\n2. State is Read-Only\n3. Changes are Made with Pure Functions (Reducers)",
          "options": [],
          "analysisPoints": [
            "Tests recall of foundational Redux concepts.",
            "Ensures understanding of Redux's design philosophy."
          ],
          "keyConcepts": [
            "Redux Principles",
            "Store",
            "Actions",
            "Reducers"
          ],
          "evaluationCriteria": [
            "Accuracy of recall"
          ],
          "example": "",
          "tags": [
            "Redux",
            "Core Concepts",
            "Principles"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_reducer_immutability_1",
          "topic": "Redux Reducers",
          "level": "medium",
          "type": "open",
          "question": "Why is it critical for Redux reducers to be pure functions and to avoid direct state mutation? Provide a small code example demonstrating how to update an array immutably within a reducer.",
          "answer": "It is critical for Redux reducers to be pure functions and to avoid direct state mutation for several reasons:\n\n1.  **Predictability and Debugging**: Pure functions with immutable updates guarantee that given the same input (previous state and action), they will always produce the same output (new state). This makes the state changes predictable and makes debugging significantly easier, especially with tools like Redux DevTools which rely on state immutability for time-travel debugging.\n2.  **Performance Optimization (React Integration)**: React and `react-redux` rely on shallow comparisons of state and props to determine if a component needs to re-render. If a reducer mutates the original state object instead of returning a new one, the reference to the state object remains the same, even if its contents have changed. This would prevent `react-redux`'s `connect` HOC (or `useSelector` hook) from detecting the change, leading to components not re-rendering when they should.\n3.  **Undo/Redo Functionality**: Immutable state makes it easy to implement features like undo/redo because you can simply keep a history of state snapshots without complex deep copying.\n4.  **Concurrency Safety**: In environments where multiple operations might occur concurrently, immutable data structures prevent race conditions and unintended side effects, as data is never changed in place.\n\n**Example of Immutable Array Update in Reducer:**\n\n```javascript\nconst initialState = {\n  items: ['Apple', 'Banana']\n};\n\nfunction itemsReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      return {\n        ...state, // Copy existing state properties\n        items: [...state.items, action.payload] // Create a new array with new item\n      };\n    case 'REMOVE_ITEM':\n      return {\n        ...state,\n        items: state.items.filter(item => item !== action.payload) // Filter creates a new array\n      };\n    case 'UPDATE_ITEM':\n      return {\n        ...state,\n        items: state.items.map(item => \n          item === action.payload.oldItem ? action.payload.newItem : item\n        ) // Map creates a new array with updated item\n      };\n    default:\n      return state;\n  }\n}\n\n// Example Usage:\nlet state1 = itemsReducer(undefined, {}); // { items: ['Apple', 'Banana'] }\nlet state2 = itemsReducer(state1, { type: 'ADD_ITEM', payload: 'Cherry' }); \n// { items: ['Apple', 'Banana', 'Cherry'] }, state1 remains unchanged\nlet state3 = itemsReducer(state2, { type: 'REMOVE_ITEM', payload: 'Banana' });\n// { items: ['Apple', 'Cherry'] }, state2 remains unchanged\n\nconsole.log(state1 === state2); // false\nconsole.log(state1.items === state2.items); // false (new array reference)\n```",
          "options": [],
          "analysisPoints": [
            "Tests foundational understanding of Redux principles.",
            "Connects immutability to debugging, performance, and features.",
            "Demonstrates practical immutability techniques for arrays."
          ],
          "keyConcepts": [
            "Redux Reducers",
            "Pure Functions",
            "Immutability",
            "State Mutation",
            "Performance Optimization",
            "Time-travel Debugging"
          ],
          "evaluationCriteria": [
            "Completeness of explanation for 'why'",
            "Correctness and clarity of code example",
            "Ability to link concepts"
          ],
          "example": "",
          "tags": [
            "Redux",
            "Reducers",
            "Immutability",
            "Best Practices",
            "State Management",
            "Performance"
          ],
          "prerequisites": [
            "redux_core_concepts"
          ],
          "complexity": 8,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_action_reducer_data_flow_1",
          "topic": "Redux Data Flow",
          "level": "medium",
          "type": "code",
          "question": "Describe the complete data flow in a Redux application from a user interaction to a UI update. Use the provided `PhoneCatalogApp` as a context, focusing on the action of 'adding a phone'.",
          "answer": "The data flow in a Redux application follows a strict, unidirectional pattern. For adding a phone in the `PhoneCatalogApp`:\n\n1.  **User Interaction (`PhoneForm`)**: The user types a phone model into the input field in `PhoneForm` and clicks the 'Add Phone' button. The `PhoneForm` component has a local state (`phoneInput`) which is updated by the `onChange` event, making it a controlled component.\n\n2.  **Dispatch Action (`AppView` -> `PhoneForm`)**: When the 'Add Phone' button is clicked, `PhoneForm`'s `handleSubmit` method is triggered. This method prevents the default form submission and then calls `this.props.addPhone(this.state.phoneInput)`. The `addPhone` prop is passed down from `AppView`.\n    \n    `AppView` is connected to Redux using `connect(mapStateToProps, actions)`. Because `actions` is passed as the second argument, the `addPhone` action creator (imported from `./actions`) is automatically wrapped by `react-redux` so that when `this.props.addPhone()` is called in `PhoneForm`, it internally calls `store.dispatch({ type: 'ADD_PHONE', payload: phoneModel })`.\n\n3.  **Reducer Updates State (`rootReducer`)**: The Redux `store` receives the dispatched `ADD_PHONE` action. It passes the current state and this action to the `rootReducer` (which might be `rootReducer.js`). The `rootReducer` (or a specific slice reducer if using `combineReducers`) recognizes the `ADD_PHONE` type.\n    \n    It then takes the current `phones` list (likely an `Immutable.List`), creates a **new** list by adding `action.payload` (the new phone model), and returns a **new** state object/Map containing this updated `phones` list. It's crucial that the original state is not mutated.\n\n4.  **Store Notifies Subscribers (`react-redux` / `connect`)**: The Redux `store` updates its internal state. Any subscribers to the store are notified. In the `react-redux` context, the `connect` HOC for `AppView` (and implicitly `PhonesList`) is subscribed to the store.\n\n5.  **`mapStateToProps` Re-evaluates (`AppView`)**: `connect` detects the state change. It re-runs `mapStateToProps` for `AppView`. `mapStateToProps` returns a new `phones` array (or `Immutable.List`) because the underlying `phones` state in Redux has changed its reference (due to immutable update in the reducer).\n\n6.  **Component Re-render (`AppView` -> `PhonesList` -> `PhoneItem`)**: Since the `phones` prop passed to `AppView` (and then passed down to `PhonesList`) has changed (its reference is new due to immutability), `react-redux` triggers a re-render of `AppView`. `AppView` then re-renders `PhonesList`, which in turn re-renders the list of `PhoneItem` components with the updated `phones` prop, now including the newly added phone. The UI is updated to display the new phone.",
          "options": [],
          "analysisPoints": [
            "Traces the flow through all major Redux components (Action, Dispatch, Reducer, Store, Selector/mapStateToProps, UI Update).",
            "Integrates React component interaction (`PhoneForm`, `AppView`, `PhonesList`).",
            "Demonstrates understanding of `connect`'s role in the flow.",
            "Emphasizes immutability at the reducer step."
          ],
          "keyConcepts": [
            "Redux Data Flow",
            "Actions",
            "Reducers",
            "Store",
            "Provider",
            "Connect",
            "mapStateToProps",
            "mapDispatchToProps",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Clarity and logical sequence of steps",
            "Accuracy of Redux and React-Redux concepts",
            "Completeness of explanation"
          ],
          "example": "See main theory for code examples.",
          "tags": [
            "Redux",
            "Data Flow",
            "React-Redux",
            "State Management",
            "Interview Question"
          ],
          "prerequisites": [
            "redux_core_concepts",
            "react_redux_integration"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_immutable_js_usage_1",
          "topic": "Immutable.js in Redux",
          "level": "medium",
          "type": "flashcard",
          "question": "Based on the `mapStateToProps` function `state.get('phones')`, what assumption can be made about the Redux state structure and why might `Immutable.js` be used?",
          "answer": "It implies that the Redux state is an `Immutable.js` `Map` (or similar Immutable.js data structure). `Immutable.js` is used to enforce immutability strictly and efficiently, making state updates predictable and optimizing `shouldComponentUpdate` checks in connected components by ensuring reference equality checks are sufficient to detect changes.",
          "options": [],
          "analysisPoints": [
            "Infers underlying technology choice from code snippet.",
            "Explains the benefits of using Immutable.js in Redux.",
            "Connects Immutable.js to performance and predictability."
          ],
          "keyConcepts": [
            "Immutable.js",
            "Redux State",
            "Immutability",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Ability to infer technology",
            "Understanding of Immutable.js benefits"
          ],
          "example": "",
          "tags": [
            "Redux",
            "Immutable.js",
            "State Management",
            "Performance"
          ],
          "prerequisites": [
            "redux_core_concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_provider_role_1",
          "topic": "`react-redux` Provider",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary role of the `<Provider>` component from `react-redux`?",
          "answer": "The `<Provider>` component makes the Redux store available to any nested components that need to access it, usually by wrapping the root component of the application and passing the store via its `store` prop.",
          "options": [],
          "analysisPoints": [
            "Tests basic knowledge of `react-redux` setup.",
            "Highlights the global availability of the store."
          ],
          "keyConcepts": [
            "React-Redux",
            "Provider",
            "Redux Store",
            "Context API"
          ],
          "evaluationCriteria": [
            "Recall of fundamental React-Redux component"
          ],
          "example": "",
          "tags": [
            "React-Redux",
            "Provider",
            "Basics"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_connect_params_1",
          "topic": "`react-redux` connect HOC",
          "level": "medium",
          "type": "mcq",
          "question": "The `connect` function from `react-redux` takes two main optional arguments: `mapStateToProps` and `mapDispatchToProps`. What does each of these functions typically return?",
          "answer": "`mapStateToProps` returns an object of state data, and `mapDispatchToProps` returns an object of functions (action creators or functions that dispatch actions).",
          "options": [
            "`mapStateToProps` returns a JSX element, and `mapDispatchToProps` returns a promise.",
            "`mapStateToProps` returns a function, and `mapDispatchToProps` returns a React component.",
            "`mapStateToProps` returns an object of state data, and `mapDispatchToProps` returns an object of functions (action creators or functions that dispatch actions).",
            "`mapStateToProps` returns an array of actions, and `mapDispatchToProps` returns the Redux store."
          ],
          "analysisPoints": [
            "Tests understanding of the purpose and return types of `connect`'s arguments.",
            "Clarifies the roles of mapping state and dispatching actions."
          ],
          "keyConcepts": [
            "Connect HOC",
            "mapStateToProps",
            "mapDispatchToProps",
            "React-Redux",
            "Props"
          ],
          "evaluationCriteria": [
            "Accurate identification of return types",
            "Correct understanding of mapping principles"
          ],
          "example": "```javascript\n// mapStateToProps example\nfunction mapStateToProps(state) {\n  return { \n    phones: state.get('phones'), \n    isLoading: state.get('loading') \n  }; \n}\n\n// mapDispatchToProps as an object shorthand example\nconst actions = { addPhone, deletePhone }; // imported action creators\n// connect(mapStateToProps, actions)(MyComponent)\n\n// mapDispatchToProps as a function example\nfunction mapDispatchToProps(dispatch) {\n  return {\n    addPhone: (model) => dispatch({ type: 'ADD_PHONE', payload: model }),\n    // ... other dispatch functions\n  };\n}\n```",
          "tags": [
            "React-Redux",
            "Connect",
            "mapStateToProps",
            "mapDispatchToProps"
          ],
          "prerequisites": [
            "redux_core_concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_mapstatetoprops_purpose_1",
          "topic": "`react-redux` `mapStateToProps`",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of the `mapStateToProps` function when using `react-redux`'s `connect`?",
          "answer": "It specifies which pieces of the Redux store's state should be made available as props to the connected React component.",
          "options": [],
          "analysisPoints": [
            "Tests basic understanding of how Redux state is passed to React components.",
            "Highlights the data flow from store to component props."
          ],
          "keyConcepts": [
            "mapStateToProps",
            "React-Redux",
            "State Mapping",
            "Props"
          ],
          "evaluationCriteria": [
            "Recall of function purpose"
          ],
          "example": "",
          "tags": [
            "React-Redux",
            "mapStateToProps",
            "Basics"
          ],
          "prerequisites": [],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_mapdispatchtoprops_object_shorthand_1",
          "topic": "`react-redux` `mapDispatchToProps`",
          "level": "medium",
          "type": "open",
          "question": "In `AppView.jsx`, `connect(mapStateToProps, actions)(AppView)` is used, where `actions` is an imported object of action creators. Explain how `react-redux` handles `mapDispatchToProps` when an object of action creators is passed instead of a function, and what benefit this provides.",
          "answer": "When `mapDispatchToProps` is passed as an object (like `actions` in the example), `react-redux` automatically wraps the action creators within that object with the Redux `dispatch` function. This is equivalent to manually writing a `mapDispatchToProps` function that calls `dispatch` for each action creator.\n\n**How it works (internally simplified):**\nIf `actions` contains `addPhone` and `deletePhone` action creators:\n```javascript\n// Instead of:\n// function mapDispatchToProps(dispatch) {\n//   return {\n//     addPhone: (model) => dispatch(addPhone(model)),\n//     deletePhone: (model) => dispatch(deletePhone(model)),\n//   };\n// }\n\n// react-redux does something like this for you:\nconst boundActions = bindActionCreators(actions, dispatch);\n// which results in boundActions = { addPhone: (model) => dispatch(addPhone(model)), ... }\n// These bound actions are then merged into the component's props.\n```\n\n**Benefit:**\nThis object shorthand for `mapDispatchToProps` offers significant **convenience and conciseness**. It reduces boilerplate code because you don't have to manually write functions that dispatch each action creator. You simply import your action creators as an object and pass that object directly to `connect`. This makes your component connection code cleaner and easier to read, especially when dealing with many action creators.",
          "options": [],
          "analysisPoints": [
            "Tests understanding of `mapDispatchToProps`'s different forms.",
            "Explains the automatic binding process for action creators.",
            "Highlights the practical advantages of the shorthand."
          ],
          "keyConcepts": [
            "mapDispatchToProps",
            "React-Redux",
            "Action Creators",
            "Dispatch",
            "Convenience",
            "Boilerplate Reduction",
            "bindActionCreators"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation",
            "Understanding of the underlying mechanism",
            "Clarity of benefits"
          ],
          "example": "",
          "tags": [
            "React-Redux",
            "mapDispatchToProps",
            "Shorthand",
            "Best Practices"
          ],
          "prerequisites": [
            "react_redux_integration"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_state_immutability_js_1",
          "topic": "Immutable.js",
          "level": "medium",
          "type": "mcq",
          "question": "Given the use of `state.get('phones')` in `mapStateToProps`, and the typical Redux reducer pattern of returning a new state object, which of the following best describes the benefit of using `Immutable.js` (or similar immutable data structures) in this context?",
          "answer": "It simplifies performance optimizations by allowing shallow equality checks to reliably detect state changes, and ensures predictable state updates by preventing accidental mutations.",
          "options": [
            "It replaces the need for Redux reducers entirely.",
            "It simplifies performance optimizations by allowing shallow equality checks to reliably detect state changes, and ensures predictable state updates by preventing accidental mutations.",
            "It automatically re-renders components without needing `connect` or `mapStateToProps`.",
            "It allows direct modification of the Redux state for simpler updates."
          ],
          "analysisPoints": [
            "Confirms understanding of Immutable.js's role with Redux.",
            "Distinguishes between its benefits and incorrect assumptions.",
            "Reinforces the concept of immutability for performance."
          ],
          "keyConcepts": [
            "Immutable.js",
            "Redux",
            "Performance Optimization",
            "Immutability",
            "State Management"
          ],
          "evaluationCriteria": [
            "Correctly identifies core benefits",
            "Avoids misconceptions about Immutable.js"
          ],
          "example": "Immutable.js provides persistent data structures that, when modified, return a new version of the structure rather than changing the original. This means that a simple reference equality check (`===`) is sufficient to determine if a state object or collection has changed, which is much faster than deep comparisons. This optimizes `shouldComponentUpdate` or `React.memo` (and internally `react-redux`'s `connect`) by preventing unnecessary re-renders.",
          "tags": [
            "Immutable.js",
            "Redux",
            "Performance",
            "Immutability",
            "State Management"
          ],
          "prerequisites": [
            "redux_core_concepts"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_phone_item",
          "title": "Implement the `PhoneItem` React Component",
          "description": "\nBased on the provided `PhonesList.jsx` which renders `PhoneItem` components, implement the `PhoneItem.jsx` file. This component should:\n\n1.  Be a React class component.\n2.  Receive `text` and `deletePhone` as props.\n3.  Display the `text` (phone model).\n4.  Include a 'Delete' button.\n5.  When the 'Delete' button is clicked, it should call the `deletePhone` prop, passing its own `text` prop as an argument to identify which phone to delete.\n\nEnsure proper prop typing if using TypeScript (though JSX is sufficient for this task).\n",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\n\n// PhoneItem.jsx\nclass PhoneItem extends React.Component {\n  // TODO: Implement constructor if needed\n\n  // TODO: Implement handleDelete method\n\n  render() {\n    // TODO: Display phone text and a delete button\n    return (\n      <div className=\"phone-item\">\n        {/* Your JSX here */}\n      </div>\n    );\n  }\n}\n\nexport default PhoneItem;\n",
          "solutionCode": "import React from 'react';\n\n// PhoneItem.jsx\nclass PhoneItem extends React.Component {\n  // constructor(props) { // Not strictly needed if not using local state or binding methods\n  //   super(props);\n  // }\n\n  handleDelete = () => {\n    // Call the deletePhone prop, passing the phone's text\n    this.props.deletePhone(this.props.text);\n  };\n\n  render() {\n    const { text } = this.props;\n    return (\n      <div className=\"phone-item\">\n        <span>{text}</span>\n        <button onClick={this.handleDelete}>Delete</button>\n      </div>\n    );\n  }\n}\n\nexport default PhoneItem;\n",
          "testCases": [
            "Should display the `text` prop correctly.",
            "Clicking the 'Delete' button should invoke `deletePhone` with the correct `text` argument.",
            "Component should render without errors when `text` is an empty string.",
            "Component should render without errors when `deletePhone` is not provided (though this scenario should ideally not occur in a connected app)."
          ],
          "hints": [
            "Remember that class components receive props via `this.props`.",
            "Event handlers for buttons typically use `onClick`.",
            "An arrow function as a class property (`handleDelete = () => {}`) automatically binds `this`."
          ],
          "tags": [
            "React",
            "Class Components",
            "Props",
            "Event Handling",
            "Component Design"
          ],
          "timeEstimate": 20,
          "prerequisites": [
            "theory_react_class_components"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "react_props",
            "event_handling",
            "component_composition"
          ]
        },
        {
          "id": "task_implement_redux_actions_reducer",
          "title": "Implement Redux Actions and Reducers for Phone Catalog",
          "description": "\nBased on the `AppView.jsx` and the overall context of the Phone Catalog app, implement the Redux `actions.js` and `reducer.js` files. You will need to:\n\n1.  **`actions.js`**:\n    *   Define action type constants for `ADD_PHONE` and `DELETE_PHONE`.\n    *   Create action creator functions `addPhone` and `deletePhone`. These functions should return action objects with a `type` and a `payload` (the phone model string).\n\n2.  **`reducer.js`**:\n    *   Define an `initialState` for the application. It should contain a `phones` property, which is an `Immutable.List` (as suggested by `state.get('phones')` in `mapStateToProps`). Initialize it with a few example phone models.\n    *   Implement a `rootReducer` function that takes `state` and `action` as arguments.\n    *   Use a `switch` statement to handle `ADD_PHONE` and `DELETE_PHONE` actions.\n    *   For `ADD_PHONE`, add the new phone model to the `phones` list immutably (e.g., using `state.update('phones', phones => phones.push(action.payload))`).\n    *   For `DELETE_PHONE`, remove the specified phone model from the `phones` list immutably (e.g., using `state.update('phones', phones => phones.filter(...))`).\n    *   Ensure the reducer returns the existing `state` for any unhandled actions.\n\nRemember to import `Immutable.js` types like `Map` and `List`.\n",
          "difficulty": "medium",
          "startingCode": "// actions.js\n// TODO: Define action type constants\n// TODO: Define action creator functions\n\n\n// reducer.js\nimport { Map, List } from 'immutable';\n// TODO: Import action types from actions.js\n\nconst initialState = Map({\n  // TODO: Define initial state for phones as an Immutable List\n});\n\nfunction rootReducer(state = initialState, action) {\n  switch (action.type) {\n    // TODO: Handle ADD_PHONE and DELETE_PHONE actions immutably\n    default:\n      return state;\n  }\n}\n\nexport default rootReducer;\n",
          "solutionCode": "// actions.js\nexport const ADD_PHONE = 'ADD_PHONE';\nexport const DELETE_PHONE = 'DELETE_PHONE';\n\nexport const addPhone = (phoneModel) => ({\n  type: ADD_PHONE,\n  payload: phoneModel,\n});\n\nexport const deletePhone = (phoneModel) => ({\n  type: DELETE_PHONE,\n  payload: phoneModel,\n});\n\n\n// reducer.js\nimport { Map, List } from 'immutable';\nimport { ADD_PHONE, DELETE_PHONE } from './actions';\n\nconst initialState = Map({\n  phones: List(['iPhone 13', 'Samsung Galaxy S22', 'Google Pixel 6'])\n});\n\nfunction rootReducer(state = initialState, action) {\n  switch (action.type) {\n    case ADD_PHONE:\n      // Ensure payload is not empty before adding\n      if (action.payload && typeof action.payload === 'string' && action.payload.trim() !== '') {\n        return state.update('phones', phones => phones.push(action.payload));\n      }\n      return state;\n    case DELETE_PHONE:\n      return state.update('phones', phones => phones.filter(phone => phone !== action.payload));\n    default:\n      return state;\n  }\n}\n\nexport default rootReducer;\n",
          "testCases": [
            "Initial state should be correctly set up with example phones.",
            "Dispatching `ADD_PHONE` should add a new phone to the list without mutating the original state.",
            "Dispatching `DELETE_PHONE` should remove the specified phone from the list without mutating the original state.",
            "Dispatching an unknown action type should return the current state unchanged.",
            "Adding a duplicate phone model should be allowed (as per current logic).",
            "Adding an empty string or non-string payload for `ADD_PHONE` should not add to the list.",
            "Deleting a non-existent phone should not alter the state."
          ],
          "hints": [
            "Remember that reducers must be pure functions and return new state objects, not mutate existing ones.",
            "Use `Immutable.js` methods like `push()` and `filter()` on `List` and `update()` on `Map` for immutable updates.",
            "Consider edge cases like empty strings for adding phones."
          ],
          "tags": [
            "Redux",
            "Actions",
            "Reducers",
            "Immutability",
            "State Management",
            "Immutable.js"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_redux_core_concepts"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "redux_principles",
            "immutable_data_structures",
            "pure_functions"
          ]
        },
        {
          "id": "task_setup_redux_store",
          "title": "Set Up the Redux Store (`store.js`)",
          "description": "\nComplete the `store.js` file for the Phone Catalog application. This file is responsible for creating and configuring the Redux store.\n\nYour task is to:\n\n1.  Import `createStore` from 'redux'.\n2.  Import the `rootReducer` you created in `reducer.js`.\n3.  Create the Redux store by passing the `rootReducer` to `createStore`.\n4.  Export the created store as the default export.\n\nFor a more complete setup, you can optionally include Redux DevTools Extension integration if you have it installed.\n",
          "difficulty": "easy",
          "startingCode": "// store.js\nimport { createStore } from 'redux';\n// TODO: Import your rootReducer\n\n// TODO: Create the Redux store\n\n// TODO: Export the store\n",
          "solutionCode": "// store.js\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport rootReducer from './reducer';\n\n// Basic store creation\n// const store = createStore(rootReducer);\n\n// Enhanced store creation with Redux DevTools Extension (optional but common)\nconst composeEnhancers = typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? \n  window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose;\n\nconst store = createStore(\n  rootReducer,\n  composeEnhancers(\n    // Add any middleware here if you have them, e.g., applyMiddleware(thunk)\n  )\n);\n\nexport default store;\n",
          "testCases": [
            "The store should be successfully created and exported.",
            "Calling `store.getState()` should return the `initialState` defined in `reducer.js`.",
            "The application should run without errors related to store creation when integrated with `Provider`."
          ],
          "hints": [
            "The `createStore` function is straightforward; it just needs your root reducer.",
            "For Redux DevTools, you might need `compose` from 'redux' and a conditional check for `window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__`."
          ],
          "tags": [
            "Redux",
            "Store",
            "Configuration",
            "Developer Tools"
          ],
          "timeEstimate": 15,
          "prerequisites": [
            "theory_redux_core_concepts",
            "task_implement_redux_actions_reducer"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "redux_architecture",
            "devtools"
          ]
        },
        {
          "id": "task_refactor_phoneform_hooks",
          "title": "Refactor `PhoneForm` to a Functional Component with React Hooks",
          "description": "\nRefactor the `PhoneForm.jsx` from a class component to a functional component using React Hooks (`useState`).\n\nYour refactored component should:\n\n1.  Be a functional component.\n2.  Use the `useState` hook to manage the `phoneInput` state.\n3.  Handle form submission and input changes in the same way as the original class component (prevent default, add phone if input is not empty, clear input).\n4.  Still receive `addPhone` as a prop and call it upon submission.\n\nThis task tests your ability to translate class component patterns to modern functional component patterns.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\n// PhoneForm.jsx (Functional Component Template)\nconst PhoneForm = ({ addPhone }) => {\n  // TODO: Use useState for phoneInput state\n  \n  // TODO: Implement handleSubmit function\n\n  // TODO: Implement onChange handler\n\n  return (\n    <form onSubmit={/* TODO */}>\n      <input \n        type=\"text\" \n        value={/* TODO */}\n        onChange={/* TODO */}\n        placeholder=\"Enter phone model\"\n      />\n      <button type=\"submit\">Add Phone</button>\n    </form>\n  );\n};\n\nexport default PhoneForm;\n",
          "solutionCode": "import React, { useState } from 'react';\n\n// PhoneForm.jsx\nconst PhoneForm = ({ addPhone }) => {\n  const [phoneInput, setPhoneInput] = useState('');\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (phoneInput.trim()) {\n      addPhone(phoneInput); // Call prop directly in functional component\n      setPhoneInput(''); // Clear input\n    }\n  };\n  \n  const handleChange = (e) => {\n    setPhoneInput(e.target.value);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input \n        type=\"text\" \n        value={phoneInput}\n        onChange={handleChange}\n        placeholder=\"Enter phone model\"\n      />\n      <button type=\"submit\">Add Phone</button>\n    </form>\n  );\n};\n\nexport default PhoneForm;\n",
          "testCases": [
            "Input field should be controlled by `useState`.",
            "Typing in the input should update the `phoneInput` state.",
            "Submitting an empty input should do nothing.",
            "Submitting a valid phone model should call `addPhone` with the model and clear the input field.",
            "Component should render without errors."
          ],
          "hints": [
            "The `useState` hook returns an array: `[stateVariable, setStateFunction]`.",
            "Event handlers in functional components can be defined as regular JavaScript functions or arrow functions directly.",
            "Props are directly accessible as arguments to the functional component."
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "Functional Components",
            "Refactoring",
            "Forms"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "theory_react_class_components"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "react_state",
            "controlled_components"
          ]
        },
        {
          "id": "task_enhance_phone_catalog_filtering",
          "title": "Enhance Phone Catalog with Client-Side Filtering (Redux)",
          "description": "\nExtend the Phone Catalog application to include a client-side filtering mechanism for the list of phones. This will involve updating the Redux state and component logic.\n\nYour task is to:\n\n1.  **Modify `AppView.jsx` (or create a new connected component)**:\n    *   Add a new input field for filtering phone models (e.g., 'Filter by name').\n    *   The value of this input should be stored in the Redux store.\n\n2.  **Modify `actions.js`**:\n    *   Define a new action type `SET_FILTER_TEXT`.\n    *   Create a new action creator `setFilterText` that dispatches this action with the filter string as payload.\n\n3.  **Modify `reducer.js`**:\n    *   Add a new state property, e.g., `filterText`, to the `initialState` (as an empty string).\n    *   Handle the `SET_FILTER_TEXT` action: update the `filterText` state immutably.\n    *   Modify the `phones` selector logic (or `mapStateToProps`) to return a **filtered** list of phones based on the `filterText` state. The filter should be case-insensitive.\n\n4.  **Update `PhonesList.jsx` (or `AppView.jsx`'s `mapStateToProps`)**:\n    *   Ensure `PhonesList` receives the already filtered list of phones from Redux.\n\nThis task combines React components, forms, and Redux state management, including managing new state in Redux and deriving computed state.\n",
          "difficulty": "hard",
          "startingCode": "// actions.js (add to existing)\n// export const SET_FILTER_TEXT = 'SET_FILTER_TEXT';\n// export const setFilterText = (text) => ({ type: SET_FILTER_TEXT, payload: text });\n\n// reducer.js (modify existing)\n// import { SET_FILTER_TEXT } from './actions';\n// const initialState = Map({\n//   phones: List(['iPhone 13', 'Samsung Galaxy S22', 'Google Pixel 6']),\n//   filterText: '' // New state property\n// });\n// function rootReducer(state = initialState, action) {\n//   switch (action.type) {\n//     case SET_FILTER_TEXT:\n//       return state.set('filterText', action.payload);\n//     // ... existing cases\n//     default:\n//       return state;\n//   }\n// }\n\n// AppView.jsx (modify existing, within render method and mapStateToProps)\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport PhonesList from './PhonesList';\nimport PhoneForm from './PhoneForm';\nimport * as actions from './actions';\n\nclass AppView extends React.Component {\n  render() {\n    const { addPhone, setFilterText, filterText, phones } = this.props; // Destructure new props\n    return (\n      <div className=\"app-container\">\n        <h1>Phone Catalog App</h1>\n        <PhoneForm addPhone={addPhone} />\n        <div className=\"filter-section\">\n          <input \n            type=\"text\" \n            placeholder=\"Filter phones...\" \n            value={filterText} // Controlled input from Redux state\n            onChange={e => setFilterText(e.target.value)} // Dispatch action on change\n          />\n        </div>\n        <PhonesList phones={phones} deletePhone={this.props.deletePhone} />\n      </div>\n    );\n  }\n}\n\nfunction mapStateToProps(state) {\n  const allPhones = state.get('phones');\n  const currentFilterText = state.get('filterText');\n  \n  // TODO: Implement filtering logic here\n  const filteredPhones = allPhones.filter(phone => \n    phone.toLowerCase().includes(currentFilterText.toLowerCase())\n  );\n\n  return {\n    phones: filteredPhones, // Pass filtered phones\n    filterText: currentFilterText, // Pass filter text for controlled input\n  };\n}\n\nexport default connect(mapStateToProps, actions)(AppView);\n",
          "solutionCode": "// actions.js\nexport const ADD_PHONE = 'ADD_PHONE';\nexport const DELETE_PHONE = 'DELETE_PHONE';\nexport const SET_FILTER_TEXT = 'SET_FILTER_TEXT'; // New action type\n\nexport const addPhone = (phoneModel) => ({\n  type: ADD_PHONE,\n  payload: phoneModel,\n});\n\nexport const deletePhone = (phoneModel) => ({\n  type: DELETE_PHONE,\n  payload: phoneModel,\n});\n\nexport const setFilterText = (text) => ({\n  type: SET_FILTER_TEXT,\n  payload: text,\n});\n\n\n// reducer.js\nimport { Map, List } from 'immutable';\nimport { ADD_PHONE, DELETE_PHONE, SET_FILTER_TEXT } from './actions';\n\nconst initialState = Map({\n  phones: List(['iPhone 13', 'Samsung Galaxy S22', 'Google Pixel 6', 'OnePlus 9 Pro', 'Xiaomi Mi 11']),\n  filterText: '' // New state property\n});\n\nfunction rootReducer(state = initialState, action) {\n  switch (action.type) {\n    case ADD_PHONE:\n      if (action.payload && typeof action.payload === 'string' && action.payload.trim() !== '') {\n        return state.update('phones', phones => phones.push(action.payload));\n      }\n      return state;\n    case DELETE_PHONE:\n      return state.update('phones', phones => phones.filter(phone => phone !== action.payload));\n    case SET_FILTER_TEXT:\n      // Update the filterText state property immutably\n      return state.set('filterText', action.payload);\n    default:\n      return state;\n  }\n}\n\nexport default rootReducer;\n\n\n// AppView.jsx\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport PhonesList from './PhonesList';\nimport PhoneForm from './PhoneForm';\nimport * as actions from './actions';\n\nclass AppView extends React.Component {\n  render() {\n    const { addPhone, setFilterText, filterText, phones, deletePhone } = this.props; \n    return (\n      <div className=\"app-container\">\n        <h1>Phone Catalog App</h1>\n        <PhoneForm addPhone={addPhone} />\n        <div className=\"filter-section\">\n          <input \n            type=\"text\" \n            placeholder=\"Filter phones...\" \n            value={filterText} \n            onChange={e => setFilterText(e.target.value)} \n          />\n        </div>\n        <PhonesList phones={phones} deletePhone={deletePhone} />\n      </div>\n    );\n  }\n}\n\n// Map state from the store to component props\nfunction mapStateToProps(state) {\n  const allPhones = state.get('phones');\n  const currentFilterText = state.get('filterText');\n  \n  // Filter logic applied directly in mapStateToProps\n  const filteredPhones = allPhones.filter(phone => \n    phone.toLowerCase().includes(currentFilterText.toLowerCase())\n  );\n\n  return {\n    phones: filteredPhones, // PhonesList receives the filtered subset\n    filterText: currentFilterText // PhoneForm's filter input controls this\n  };\n}\n\n// Connect the component to Redux\n// actions object includes setFilterText as well\nexport default connect(mapStateToProps, actions)(AppView);\n",
          "testCases": [
            "Filtering input should appear and be a controlled component.",
            "Typing 'iP' into the filter should only show phones containing 'iP' (case-insensitive).",
            "Typing a filter text that doesn't match any phone should result in an empty list.",
            "Clearing the filter input should show all phones again.",
            "Adding a new phone should still work correctly and appear in the list, subject to current filter.",
            "Deleting a phone should still work correctly, whether filtered or not.",
            "Filter text should persist when adding/deleting phones.",
            "Reducer should immutably update `filterText` state."
          ],
          "hints": [
            "Remember to make the filter case-insensitive using `toLowerCase()`.",
            "`mapStateToProps` is a good place to put data transformation logic (like filtering) that depends on multiple slices of Redux state.",
            "Ensure `setFilterText` action creator is included in the `actions` object passed to `connect`."
          ],
          "tags": [
            "React",
            "Redux",
            "State Management",
            "Filtering",
            "Immutable.js",
            "Data Transformation",
            "Advanced"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_redux_core_concepts",
            "theory_react_redux_integration",
            "task_implement_redux_actions_reducer"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "derived_state",
            "selectors",
            "controlled_components"
          ]
        }
      ]
    }
  },
  {
    "id": "73f67bde-2821-44c1-b9ea-58b85347ce72",
    "startLine": 10100,
    "endLine": 10199,
    "processedDate": "2025-06-17T11:28:34.919Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_redux_react_integration",
          "title": "Redux with React: Integration & Core Concepts",
          "content": "This section covers the foundational aspects of integrating Redux with React applications, emphasizing the key components and patterns involved in setting up a scalable state management solution.\n\n## Core Concepts\n\n### Provider\n`Provider` is a special React component provided by `react-redux` that makes the Redux store available to any nested components that need to access it. It typically wraps the root component of your application, ensuring that the entire component tree can connect to the Redux store without explicitly passing the store down through props at every level (prop drilling).\n\n### Store Configuration and Initialization\nThe Redux store is the single source of truth for the application's state. It holds the complete state tree and is responsible for dispatching actions and running reducers to update the state. The store is typically configured once during application startup, bringing together all reducers.\n\n### Action Creators and Action Types\n- **Action Types**: Constants that define the type of action being performed. They are usually string literals and help avoid typos and promote consistency.\n- **Action Creators**: Functions that return an action object. An action is a plain JavaScript object with a `type` property (mandatory) and often a `payload` containing data relevant to the action. Actions are the only way to send data from your application to the Redux store.\n\n### Reducer Implementation (with Immutable.js context)\nReducers are pure functions that take the current state and an action as arguments, and return a new state. They must not mutate the original state directly. If `Immutable.js` is used, it provides immutable data structures that help enforce this principle by returning new instances of data structures whenever changes are made, rather than modifying the existing ones.\n\n### Component Hierarchy and Composition\nReact applications are built as a tree of components. With Redux, components can be categorized into presentational (dumb) components that only render UI based on props and container (smart) components that connect to the Redux store and pass data/callbacks to presentational components.\n\n### Connecting Components to Redux with `connect()`\n`connect()` is a Higher-Order Component (HOC) from `react-redux` that allows React components to read data from the Redux store and dispatch actions to the store. It takes two optional arguments: `mapStateToProps` and `mapDispatchToProps`.\n- `mapStateToProps`: A function that receives the entire Redux state and returns an object of data that the component needs. This data is then passed as props to the connected component.\n- `mapDispatchToProps`: A function or object that defines which action creators should be dispatched. These dispatch functions are also passed as props to the connected component.\n\n## Redux Flow Example\n```jsx\nReactDOM.render(\n  <Provider store={store}>\n    <AppView />\n  </Provider>,\n  document.getElementById('root')\n);\n```\nThis snippet illustrates the root-level integration where the `Provider` component makes the `store` available to `AppView` and all its descendants.\n\n![Flux Architecture Flow](images/flux_pattern.png)",
          "examples": [
            {
              "id": "example_redux_react_integration_1",
              "title": "Basic Store and Provider Setup",
              "code": "import { createStore } from 'redux';\nimport { Provider } from 'react-redux';\nimport ReactDOM from 'react-dom';\nimport React from 'react';\n\n// A simple reducer\nconst counterReducer = (state = { count: 0 }, action) => {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { count: state.count + 1 };\n    case 'DECREMENT':\n      return { count: state.count - 1 };\n    default:\n      return state;\n  }\n};\n\n// Create the Redux store\nconst store = createStore(counterReducer);\n\n// A simple App component\nconst App = () => (\n  <div>\n    <h1>Redux App</h1>\n  </div>\n);\n\n// Render the application with Provider\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);",
              "explanation": "This example shows the minimal setup for a Redux application with React. A `store` is created using `createStore` and a basic `counterReducer`. The `Provider` component then wraps the root `App` component, making the `store` accessible to all components within the `App`'s tree. This is the entry point for integrating Redux into a React application.",
              "language": "javascript"
            },
            {
              "id": "example_redux_react_integration_2",
              "title": "Connecting a Component with `connect`",
              "code": "import React from 'react';\nimport { connect } from 'react-redux';\n\n// Action creators\nconst increment = () => ({ type: 'INCREMENT' });\nconst decrement = () => ({ type: 'DECREMENT' });\n\n// A React component that displays a counter\nconst Counter = ({ count, increment, decrement }) => (\n  <div>\n    <p>Count: {count}</p>\n    <button onClick={increment}>Increment</button>\n    <button onClick={decrement}>Decrement</button>\n  </div>\n);\n\n// mapStateToProps: maps state from Redux store to component props\nconst mapStateToProps = (state) => ({\n  count: state.count,\n});\n\n// mapDispatchToProps: maps action creators to component props (dispatch automatically)\nconst mapDispatchToProps = {\n  increment,\n  decrement,\n};\n\n// Connect the Counter component to Redux\nexport default connect(mapStateToProps, mapDispatchToProps)(Counter);",
              "explanation": "This example demonstrates how to use the `connect` HOC to link a React component (`Counter`) to the Redux store. `mapStateToProps` extracts the `count` from the Redux state and passes it as a prop. `mapDispatchToProps` provides the `increment` and `decrement` action creators as props, which automatically dispatch the respective actions when called. This pattern separates data fetching/logic from UI rendering.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_redux_react_1",
            "question_redux_react_2",
            "question_redux_react_3",
            "question_redux_react_4",
            "question_redux_react_5",
            "question_redux_react_6"
          ],
          "relatedTasks": [
            "task_redux_integration_1",
            "task_redux_integration_2"
          ],
          "tags": [
            "Redux",
            "React",
            "State Management",
            "Provider",
            "Connect",
            "Actions",
            "Reducers",
            "Store"
          ],
          "technology": "React, Redux",
          "prerequisites": [
            "React Basics",
            "JavaScript ES6+",
            "Functional Programming Concepts"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced Redux",
            "Large Scale React Apps",
            "Frontend Architecture"
          ]
        },
        {
          "id": "theory_flux_architecture",
          "title": "Flux Architecture: Unidirectional Data Flow",
          "content": "Flux is an architectural pattern, developed by Facebook, that complements React's declarative views by enforcing a unidirectional data flow. Its primary goal is to manage application data consistently and predictably, preventing issues like data pollution and ensuring that derived data can be reliably controlled across multiple components.\n\n## Key Principles\n-   **Unidirectional Data Flow**: Data flows in a single direction, making it easier to understand how changes occur and to debug applications.\n-   **Declarative UI**: React components are declarative; the rendered UI is a direct function of the application's state. Flux ensures this state is managed reliably.\n-   **Data Integrity**: By restricting direct access to shared data and centralizing change logic, Flux helps maintain the integrity of application state.\n\n## Flux Flow Components\n1.  **Actions**: These are plain JavaScript objects that describe something that happened in the application. They are the payloads of information that send data from the application (e.g., from a user interaction in a View) to the Dispatcher. Actions typically have a `type` and may contain additional data (`payload`).\n2.  **Dispatcher**: The central hub of a Flux application. It manages all data flow and is responsible for receiving actions and dispatching them to registered Stores. The Dispatcher ensures that actions are processed one at a time, in a specific order, which helps in preventing race conditions and managing dependencies between Stores.\n3.  **Stores**: These are containers for application state and logic. Each Store manages the state for a specific domain of the application (e.g., a UserStore, a ProductStore). Stores react to actions dispatched by the Dispatcher, update their internal state, and then emit a 'change' event to notify interested Views that their data has been updated. Stores contain the logic for how the state changes in response to an action.\n4.  **Views**: These are the React components that represent the user interface. Views listen for change events from the Stores, retrieve the updated state from the Stores, and re-render themselves to reflect the new state. Views can also trigger new Actions based on user interactions, closing the loop of the unidirectional data flow.\n\n## Stateless Components in Flux\nStateless components are pure functions that render the DOM based exclusively on the props provided to them. They do not manage their own internal state. This characteristic makes them highly suitable for use within a Flux architecture, where data is primarily managed by Stores and passed down to Views (including stateless components) via props. They are predictable, reusable, and easy to test.\n\n```javascript\n// Example of a stateless component in a Flux architecture\nconst StatelessComponent = props => {\n  return (\n    <div className=\"my-stateless-component\">\n      {props.name}: {props.birthday}\n    </div>\n  );\n};\n\n// Usage\nReactDOM.render(\n  <StatelessComponent name=\"User\" birthday=\"10/01/1980\" />,\n  document.getElementById('main')\n);\n```\n\n![Flux Architecture Flow](images/flux_pattern.png)",
          "examples": [
            {
              "id": "example_flux_architecture_1",
              "title": "Flux Action and Dispatcher Example",
              "code": "// Action type constant\nconst UPDATE_USER_NAME = 'UPDATE_USER_NAME';\n\n// Action creator function\nconst updateUserName = (name) => ({\n  type: UPDATE_USER_NAME,\n  payload: { name },\n});\n\n// A very simplified Dispatcher concept (not how Flux's real Dispatcher works, but for illustration)\nconst Dispatcher = {\n  _callbacks: [],\n  register(callback) {\n    this._callbacks.push(callback);\n  },\n  dispatch(action) {\n    console.log('Dispatching action:', action.type, action.payload);\n    this._callbacks.forEach(callback => callback(action));\n  },\n};\n\n// Example usage\n// Dispatcher.register(someStoreCallback);\n// Dispatcher.dispatch(updateUserName('Alice'));",
              "explanation": "This example illustrates the concept of an Action creator and a very simplified Dispatcher in a Flux pattern. `updateUserName` creates an action object. The `Dispatcher` conceptually receives this action and would then distribute it to all registered `_callbacks` (which would typically be Store methods). This shows how information flows from the application into the Flux system.",
              "language": "javascript"
            },
            {
              "id": "example_flux_architecture_2",
              "title": "Simple Flux Store Concept",
              "code": "import EventEmitter from 'events';\n\nconst UserStore = Object.assign({}, EventEmitter.prototype, {\n  _userName: 'Guest',\n\n  getUserName() {\n    return this._userName;\n  },\n\n  emitChange() {\n    this.emit('change');\n  },\n\n  addChangeListener(callback) {\n    this.on('change', callback);\n  },\n\n  removeChangeListener(callback) {\n    this.removeListener('change', callback);\n  },\n\n  // This would be called by the Dispatcher upon action reception\n  __onDispatch(action) {\n    switch (action.type) {\n      case 'UPDATE_USER_NAME':\n        this._userName = action.payload.name;\n        this.emitChange();\n        break;\n      // other action types\n    }\n  }\n});\n\n// In a real Flux app, the Dispatcher would register this: \n// Dispatcher.register(UserStore.__onDispatch.bind(UserStore));",
              "explanation": "This code snippet demonstrates a conceptual Flux Store. It holds application state (`_userName`), provides public getters (`getUserName`), and an event emitter (`EventEmitter`) to notify Views of changes. The `__onDispatch` method is where the Store reacts to specific actions dispatched by the central Dispatcher, updates its state, and then calls `emitChange()` to trigger re-renders in listening Views. This embodies the 'Store' component of Flux.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_flux_1",
            "question_flux_2",
            "question_flux_3",
            "question_flux_4",
            "question_flux_5",
            "question_flux_6"
          ],
          "relatedTasks": [
            "task_flux_conceptual_1"
          ],
          "tags": [
            "Flux",
            "Architecture",
            "Unidirectional Data Flow",
            "Actions",
            "Dispatcher",
            "Stores",
            "Views",
            "Stateless Components"
          ],
          "technology": "Frontend Architecture",
          "prerequisites": [
            "React Basics",
            "Design Patterns"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Understanding State Management Evolution",
            "Frontend System Design"
          ]
        },
        {
          "id": "theory_flux_redux_comparison",
          "title": "Flux vs. Redux: A Comparative Analysis",
          "content": "While Redux is heavily inspired by Flux, it introduces several simplifications and enhancements. Understanding their differences is crucial for grasping Redux's design philosophy.\n\n## Core Differences\n\n### Store Structure\n-   **Flux**: Typically involves multiple, domain-specific stores. Each store manages its own slice of the application state and contains the logic for updating that state in response to actions. This can lead to managing dependencies between stores if one store's state depends on another's.\n-   **Redux**: Emphasizes a single, immutable store. All application state is contained within a single JavaScript object tree. This centralized state makes it easier to trace state changes and enables powerful debugging tools like time-travel debugging.\n\n### Dispatcher\n-   **Flux**: Requires a central, dedicated dispatcher. The dispatcher is responsible for orchestrating the flow of data to stores, ensuring actions are processed one by one. It manages dependencies between stores through explicit registration and `waitFor` mechanisms.\n-   **Redux**: Does not have a separate dispatcher. The `dispatch` function is part of the store itself. Instead of a dispatcher, Redux relies on a single root reducer (composed of smaller reducers) and the principle of pure functions to handle state updates. Actions are directly dispatched to the store, and the root reducer processes them.\n\n### State Mutations\n-   **Flux**: Allows state mutations within the stores themselves. While best practices often suggest avoiding direct mutation, the Flux pattern inherently permits it, which can sometimes make state changes harder to track.\n-   **Redux**: Strictly enforces immutability. Reducers must always return new state objects instead of modifying the existing ones. This is a core tenet that simplifies debugging, enables performance optimizations (e.g., shallow equality checks in React components), and facilitates features like undo/redo and time-travel debugging.\n\n### Logic Separation\n-   **Flux**: Stores contain both the application state and the logic (the `switch` statements) for how that state changes in response to actions.\n-   **Redux**: Separates the store (which holds the state) from the change logic (which resides entirely in pure functions called reducers). Reducers are separate entities that describe how an action transforms the state tree.\n\n### Middleware Support\n-   **Flux**: Does not have a built-in concept of middleware. Handling asynchronous operations or side effects typically involves more manual patterns within action creators or stores.\n-   **Redux**: Provides robust middleware support. Middleware allows intercepting dispatched actions before they reach the reducers, enabling powerful features like asynchronous operations (e.g., Redux Thunk, Redux Saga), logging, crash reporting, and more, in a declarative way.\n\n## Comparison Table\n| Feature         | Flux                      | Redux                             |\n|-----------------|---------------------------|-----------------------------------|\n| **Stores**      | Multiple stores           | Single store                      |\n| **Dispatcher**  | Required central dispatcher | No dispatcher (uses pure functions)|\n| **State mutations** | Allows state mutations    | Pure functions (no mutations)     |\n| **Store structure** | Stores contain state and change logic | Store and change logic are separate |\n| **Middleware**  | Not built-in              | Supports middleware               |",
          "examples": [],
          "relatedQuestions": [
            "question_flux_redux_comp_1",
            "question_flux_redux_comp_2",
            "question_flux_redux_comp_3",
            "question_flux_redux_comp_4",
            "question_flux_redux_comp_5"
          ],
          "relatedTasks": [],
          "tags": [
            "Flux",
            "Redux",
            "Comparison",
            "State Management",
            "Architecture",
            "Middleware",
            "Immutability"
          ],
          "technology": "Frontend Architecture",
          "prerequisites": [
            "Flux Architecture",
            "Redux Core Concepts"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Architectural Decisions",
            "Debugging State Management"
          ]
        },
        {
          "id": "theory_redux_toolkit",
          "title": "Redux Toolkit: Simplifying Redux Development",
          "content": "Redux Toolkit (RTK) is the official, opinionated, batteries-included toolset for efficient Redux development. It was created to simplify common Redux use cases, reduce boilerplate code, and enforce best practices like immutability. RTK aims to address common criticisms of Redux, such as the amount of setup code required and the complexity of managing boilerplate.\n\n## Key Features and Benefits\n-   **Reduces Boilerplate**: Automates the creation of action types, action creators, and reducers.\n-   **Opinionated Defaults**: Provides sensible defaults for common patterns, reducing configuration efforts.\n-   **Includes Immer**: Built-in integration with Immer allows you to write 'mutating' logic inside reducers while still producing immutable updates behind the scenes, making reducer code much simpler and more readable.\n-   **Built-in Thunk Middleware**: `redux-thunk` is included by default, simplifying asynchronous logic.\n-   **Developer Experience**: Improves the overall development experience by streamlining setup and reducing cognitive load.\n\n## `createSlice` Function\n`createSlice` is a central function in Redux Toolkit that significantly simplifies the process of creating Redux reducers and actions. It combines the creation of actions and reducers into a single function.\n\nWhen you use `createSlice`:\n-   It automatically generates action creators for each function defined in the `reducers` object.\n-   It automatically generates action types based on the slice name and reducer function names.\n-   It uses the Immer library internally, so you can write mutable logic within your reducers (e.g., `state.value += 1;`), and Immer will handle producing a new immutable state under the hood.\n\n```typescript\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = {\n  value: 0,\n};\n\nconst counterSlice = createSlice({\n  name: 'counter', // Slice name, used as a prefix for action types\n  initialState,   // The initial state for this reducer\n  reducers: {    // Define reducer functions here\n    increment(state) { // 'state' here is a draft provided by Immer\n      state.value += 1; // Direct mutation is safe due to Immer\n    },\n    decrement(state) {\n      state.value -= 1;\n    },\n    // Example of a reducer with a payload\n    addAmount(state, action) {\n      state.value += action.payload;\n    }\n  },\n});\n\n// Action creators are automatically generated and exported\nexport const { increment, decrement, addAmount } = counterSlice.actions;\n\n// The reducer function for this slice is also exported\nexport default counterSlice.reducer;\n```\n\nThis single `createSlice` call replaces the need for manually defining action types, writing action creator functions, and constructing a switch-case reducer, drastically reducing boilerplate and potential errors.",
          "examples": [
            {
              "id": "example_redux_toolkit_1",
              "title": "Full Redux Toolkit Store Setup",
              "code": "import { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from './counterSlice'; // Assuming counterSlice.ts/js is in the same directory\n\nconst store = configureStore({\n  reducer: {\n    counter: counterReducer, // Assign the slice reducer to a key in the root state\n  },\n  // devTools: true by default, etc.\n});\n\nexport default store;",
              "explanation": "This example shows how to set up a Redux store using `configureStore` from Redux Toolkit. `configureStore` automatically sets up the Redux DevTools Extension, `redux-thunk` middleware, and combines reducers. It's the recommended way to create a Redux store with RTK, simplifying complex configurations.",
              "language": "typescript"
            },
            {
              "id": "example_redux_toolkit_2",
              "title": "`createSlice` with Payload and Extra Reducers",
              "code": "import { createSlice } from '@reduxjs/toolkit';\n\nconst userSlice = createSlice({\n  name: 'user',\n  initialState: { name: 'Guest', status: 'idle' },\n  reducers: {\n    // Reducer with a payload\n    setName: (state, action) => {\n      state.name = action.payload;\n    },\n    setStatus: (state, action) => {\n      state.status = action.payload;\n    },\n  },\n  // 'extraReducers' allows handling actions defined outside this slice\n  // e.g., actions from other slices or async thunks\n  // extraReducers: (builder) => {\n  //   builder\n  //     .addCase(someOtherAction, (state, action) => {\n  //       // handle other action\n  //     });\n  // },\n});\n\nexport const { setName, setStatus } = userSlice.actions;\nexport default userSlice.reducer;",
              "explanation": "This example further demonstrates `createSlice` by showing how to define reducers that accept a `payload` from the action. It also briefly mentions `extraReducers`, a powerful feature that allows a slice to react to action types not generated by its own `reducers` property, useful for integrating with async thunks or actions from other slices. This highlights RTK's flexibility and completeness.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_redux_toolkit_1",
            "question_redux_toolkit_2",
            "question_redux_toolkit_3",
            "question_redux_toolkit_4",
            "question_redux_toolkit_5"
          ],
          "relatedTasks": [
            "task_redux_toolkit_1",
            "task_redux_toolkit_2"
          ],
          "tags": [
            "Redux Toolkit",
            "RTK",
            "createSlice",
            "Immer",
            "Boilerplate",
            "State Management",
            "Redux"
          ],
          "technology": "Redux, TypeScript",
          "prerequisites": [
            "Redux Core Concepts",
            "JavaScript ES6+"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Modern Redux Applications",
            "Frontend Development Best Practices"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_redux_react_1",
          "topic": "Redux/React Integration: Provider",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `Provider` component in a React Redux application?",
          "answer": "The `Provider` component from `react-redux` makes the Redux store available to all connected components in the application's component tree without needing to pass it down explicitly via props.",
          "options": [],
          "analysisPoints": [
            "Identifies `Provider` as the entry point for Redux integration.",
            "Understands its role in making the store accessible.",
            "Recognizes that it prevents prop drilling for the store."
          ],
          "keyConcepts": [
            "Provider",
            "Redux Store",
            "Context API (underlying)"
          ],
          "evaluationCriteria": [
            "Direct recall of component function.",
            "Understanding of its impact on component hierarchy."
          ],
          "example": "The `Provider` component typically wraps the root React component, like this:\n```jsx\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n```",
          "tags": [
            "Redux",
            "React",
            "Provider",
            "Basic"
          ],
          "prerequisites": [
            "React Basics",
            "Redux Store"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_redux_react_2",
          "topic": "Redux Core: Action Creators and Types",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following Redux action and action creator:\n\n```typescript\n// Action Type\nconst ADD_TODO = 'ADD_TODO';\n\n// Action Creator\nconst addTodo = (text: string) => ({\n  type: ADD_TODO,\n  payload: { id: Date.now(), text, completed: false }\n});\n```\n\nWhich of the following statements about Redux actions and action creators is TRUE?",
          "answer": "Action creators are functions that return a plain JavaScript object with a `type` property and optionally a `payload`.",
          "options": [
            "Action creators directly modify the Redux state.",
            "Actions must always have a `payload` property.",
            "Action types are typically functions that describe the action.",
            "Action creators are functions that return a plain JavaScript object with a `type` property and optionally a `payload`."
          ],
          "analysisPoints": [
            "Tests understanding of action creator's return value (plain object).",
            "Verifies knowledge of mandatory `type` property.",
            "Checks understanding of optional `payload`.",
            "Distinguishes action creators from direct state modification."
          ],
          "keyConcepts": [
            "Actions",
            "Action Creators",
            "Action Types",
            "Payload"
          ],
          "evaluationCriteria": [
            "Accuracy of definitions.",
            "Correct identification of action structure."
          ],
          "example": "The example demonstrates an action creator `addTodo` that returns an action object. This object has a `type` (`ADD_TODO`) and a `payload` containing the new todo item's data. Reducers will then use this information to update the state.",
          "tags": [
            "Redux",
            "Actions",
            "Action Creators",
            "MCQ"
          ],
          "prerequisites": [
            "Redux Core Concepts"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_react_3",
          "topic": "Redux Core: Reducers and Immutability",
          "level": "medium",
          "type": "open",
          "question": "Explain the role of reducers in Redux. Why is it critical for reducers to be pure functions and avoid direct state mutations? Discuss the implications if state is directly mutated.",
          "answer": "Reducers are pure functions that take the current `state` and an `action` as arguments and return a new `state`. Their primary role is to specify how the application's state changes in response to actions.\n\nIt is critical for reducers to be pure functions and avoid direct state mutations for several reasons:\n1.  **Predictability and Debugging**: Pure functions always produce the same output for the same input, making state changes predictable and easier to reason about. If reducers mutated state, it would be difficult to track where and when state changes occurred, complicating debugging (e.g., 'time-travel debugging' would be impossible).\n2.  **Performance Optimization**: React's reconciliation process and `shouldComponentUpdate` (or `React.memo`, `PureComponent`) rely on shallow equality checks to determine if a component needs to re-render. If a reducer mutates the state object directly, the reference to the state object remains the same, even if its contents change. This means React might not detect a change, leading to components not re-rendering when they should, or performing unnecessary deep comparisons.\n3.  **Time-Travel Debugging**: Tools like Redux DevTools rely on the immutability of state to replay actions and 'travel' through different states of the application. If state were mutable, this functionality would break.\n4.  **Concurrency Safety**: In environments where multiple operations might touch state concurrently, immutable state helps prevent race conditions and unexpected side effects.\n\nIf state is directly mutated, it leads to:\n-   **Unpredictable Behavior**: Components might not update correctly, or state might be altered unexpectedly.\n-   **Debugging Nightmares**: Tracing the source of state changes becomes extremely difficult.\n-   **Performance Issues**: Inefficient re-renders or missed re-renders.\n-   **Broken DevTools**: Inability to use powerful debugging features.",
          "options": [],
          "analysisPoints": [
            "Defines reducer role correctly.",
            "Explains 'pure function' in the context of reducers (no side effects, same output for same input).",
            "Details the importance of immutability for predictability, debugging (time-travel), and performance optimizations in React.",
            "Outlines negative consequences of direct mutation."
          ],
          "keyConcepts": [
            "Reducers",
            "Pure Functions",
            "Immutability",
            "State Mutation",
            "Debugging",
            "Performance",
            "Time-Travel Debugging"
          ],
          "evaluationCriteria": [
            "Completeness of explanation.",
            "Accuracy of technical details.",
            "Clarity of reasoning."
          ],
          "example": "```javascript\n// CORRECT: Immutable update\nconst immutableReducer = (state = { count: 0 }, action) => {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { ...state, count: state.count + 1 }; // Returns a new object\n    default:\n      return state;\n  }\n};\n\n// INCORRECT: Direct mutation (AVOID!)\nconst mutableReducer = (state = { count: 0 }, action) => {\n  switch (action.type) {\n    case 'INCREMENT':\n      state.count++; // Mutates the original state object\n      return state;\n    default:\n      return state;\n  }\n};\n```",
          "tags": [
            "Redux",
            "Reducers",
            "Immutability",
            "Pure Functions",
            "Open-ended"
          ],
          "prerequisites": [
            "Redux Core Concepts",
            "JavaScript Immutability"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_react_4",
          "topic": "Redux/React Integration: `connect()` HOC",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following best describes the purpose of the `connect()` Higher-Order Component (HOC) from `react-redux`?",
          "answer": "It provides a way to connect React components to the Redux store, injecting state and action dispatch functions as props.",
          "options": [
            "It directly modifies the Redux store state from within a React component.",
            "It is used to define action creators and action types.",
            "It replaces the need for reducers in Redux.",
            "It provides a way to connect React components to the Redux store, injecting state and action dispatch functions as props."
          ],
          "analysisPoints": [
            "Correctly identifies `connect` as an HOC.",
            "Understands that it maps Redux state/dispatch to component props.",
            "Distinguishes its role from state modification or action/reducer definitions."
          ],
          "keyConcepts": [
            "connect HOC",
            "mapStateToProps",
            "mapDispatchToProps",
            "React-Redux"
          ],
          "evaluationCriteria": [
            "Accurate functional description.",
            "Understanding of React-Redux bridge."
          ],
          "example": "```javascript\nimport { connect } from 'react-redux';\n\nconst MyComponent = (props) => { /* ... */ };\n\nconst mapStateToProps = (state) => ({ myData: state.someSlice.data });\nconst mapDispatchToProps = { myActionCreator };\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MyComponent);\n```",
          "tags": [
            "Redux",
            "React-Redux",
            "connect",
            "HOC",
            "MCQ"
          ],
          "prerequisites": [
            "React HOCs",
            "Redux Core Concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_react_5",
          "topic": "Redux Flow",
          "level": "easy",
          "type": "flashcard",
          "question": "Describe the basic unidirectional data flow in a Redux application, starting from a user interaction.",
          "answer": "User interaction -> View dispatches an Action -> Action is processed by a Reducer -> New State is generated -> View re-renders based on the new state.",
          "options": [],
          "analysisPoints": [
            "Correctly identifies the sequence of events.",
            "Includes all key components of the flow.",
            "Demonstrates understanding of unidirectional nature."
          ],
          "keyConcepts": [
            "Redux Flow",
            "Actions",
            "Reducers",
            "Store",
            "Views",
            "Unidirectional Data Flow"
          ],
          "evaluationCriteria": [
            "Sequential accuracy.",
            "Inclusion of all flow steps."
          ],
          "example": "A user clicks a 'Like' button in a `Post` component.\n1.  The `Post` component (View) dispatches a `LIKE_POST` action.\n2.  The action is received by the Redux store and passed to the relevant reducer.\n3.  The reducer processes `LIKE_POST` and returns a new state where the post's like count is incremented.\n4.  The `Post` component, being connected to the store, detects the state change and re-renders to show the updated like count.",
          "tags": [
            "Redux",
            "Flow",
            "Flashcard",
            "Basic"
          ],
          "prerequisites": [
            "Redux Core Concepts"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_redux_react_6",
          "topic": "Immutable.js in Redux",
          "level": "medium",
          "type": "open",
          "question": "The provided markdown mentions 'Reducer implementation with Immutable.js'. While not explicitly shown, how does Immutable.js typically contribute to Redux reducer implementations, and why might it be used?",
          "answer": "Immutable.js provides persistent, immutable data structures (like `List`, `Map`, `Set`) that simplify working with immutable data in JavaScript. In Redux reducers, its contribution is primarily to enforce immutability strictly and consistently.\n\n**How it contributes:**\n-   Instead of using plain JavaScript objects and arrays and manually spreading them (`{...state, ...}`, `[...arr, item]`), developers would use Immutable.js data structures for their Redux state.\n-   Operations like adding, updating, or deleting items on an Immutable.js collection (`state.get('items').push(newItem)`) do not mutate the original collection. Instead, they return a new Immutable.js instance with the changes, which aligns perfectly with Redux's requirement for reducers to return new state objects without mutation.\n\n**Why it might be used:**\n-   **Strict Immutability**: Guarantees that state is never accidentally mutated, preventing subtle bugs.\n-   **Performance**: Immutable.js structures allow for efficient structural sharing (reusing unchanged parts of the data tree) and quick reference equality checks, which can be beneficial for performance in large applications by optimizing `shouldComponentUpdate` logic.\n-   **Consistency**: Provides a consistent API for immutable operations across different data types (arrays, objects, sets).\n\nWhile Redux Toolkit's Immer.js achieves similar benefits with mutable-looking syntax, Immutable.js was a popular choice before RTK for ensuring strict immutability in larger Redux applications.",
          "options": [],
          "analysisPoints": [
            "Defines Immutable.js and its purpose.",
            "Explains how it enforces immutability in reducers (returning new instances).",
            "Discusses benefits like strictness, performance (structural sharing, reference equality), and consistency.",
            "Contextualizes its usage relative to modern tools like Immer."
          ],
          "keyConcepts": [
            "Immutable.js",
            "Immutability",
            "Redux Reducers",
            "State Management",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Understanding of library's role.",
            "Ability to explain benefits and mechanisms.",
            "Contextual knowledge."
          ],
          "example": "```javascript\nimport { Map, List } from 'immutable';\n\nconst initialState = Map({\n  todos: List([\n    Map({ id: 1, text: 'Learn Redux', completed: false })\n  ])\n});\n\nconst todosReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return state.update('todos', todos =>\n        todos.push(Map({ id: action.payload.id, text: action.payload.text, completed: false }))\n      );\n    case 'TOGGLE_TODO':\n      return state.update('todos', todos =>\n        todos.map(todo =>\n          todo.get('id') === action.payload.id\n            ? todo.set('completed', !todo.get('completed'))\n            : todo\n        )\n      );\n    default:\n      return state;\n  }\n};\n```",
          "tags": [
            "Redux",
            "Immutable.js",
            "Immutability",
            "State Management",
            "Open-ended"
          ],
          "prerequisites": [
            "Redux Reducers",
            "JavaScript Immutability"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_flux_1",
          "topic": "Flux Architecture: Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary architectural pattern that Flux represents?",
          "answer": "Flux is an architectural pattern that enforces unidirectional data flow.",
          "options": [],
          "analysisPoints": [
            "Direct recall of Flux's core characteristic."
          ],
          "keyConcepts": [
            "Flux",
            "Architectural Pattern",
            "Unidirectional Data Flow"
          ],
          "evaluationCriteria": [
            "Basic definition recall."
          ],
          "example": "Flux was developed by Facebook to manage data flow in their large-scale applications, especially alongside React.",
          "tags": [
            "Flux",
            "Architecture",
            "Basic"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_flux_2",
          "topic": "Flux Architecture: Data Flow Components",
          "level": "medium",
          "type": "mcq",
          "question": "In the Flux architecture, which component is described as the 'central hub that manages all data flow' and ensures actions are processed?",
          "answer": "Dispatcher",
          "options": [
            "Action",
            "Store",
            "View",
            "Dispatcher"
          ],
          "analysisPoints": [
            "Correctly identifies the role of the Dispatcher.",
            "Distinguishes Dispatcher from other Flux components."
          ],
          "keyConcepts": [
            "Flux Flow",
            "Dispatcher",
            "Actions",
            "Stores",
            "Views"
          ],
          "evaluationCriteria": [
            "Specific component identification.",
            "Understanding of component responsibilities."
          ],
          "example": "The Dispatcher receives actions and then distributes them to all registered stores, ensuring a consistent order of operations.",
          "tags": [
            "Flux",
            "Dispatcher",
            "MCQ"
          ],
          "prerequisites": [
            "Flux Architecture Overview"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_flux_3",
          "topic": "Flux Architecture: Stateless Components",
          "level": "medium",
          "type": "open",
          "question": "The content states that 'Stateless components are pure functions that render the DOM based exclusively on the props provided to them. This makes them ideal for use within a Flux architecture'. Elaborate on why stateless components are well-suited for Flux.",
          "answer": "Stateless components are ideal for Flux architecture due to their inherent nature as pure functions that rely solely on `props` for rendering and have no internal state. This aligns perfectly with Flux's unidirectional data flow and centralized state management.\n\nHere's why:\n1.  **Predictability**: Being pure functions, stateless components always render the same UI for the same set of props. In Flux, data flows predictably from Stores to Views (including stateless components) via props, ensuring that changes in the Store are reliably reflected in the UI.\n2.  **Clear Data Flow**: They don't manage their own data. All necessary data comes from higher-order components (often connected Views in Flux/React) that retrieve state from Stores. This reinforces the unidirectional flow, making it clear where data originates and how it influences the UI.\n3.  **Testability**: Since their output depends only on inputs, stateless components are very easy to test in isolation.\n4.  **Reusability**: They are highly reusable as they are not tied to any specific state or logic. They simply present data.\n5.  **Performance (implicit)**: Without internal state management, they are simpler and potentially more performant, as React can make optimizations knowing they won't trigger re-renders from internal state changes.",
          "options": [],
          "analysisPoints": [
            "Connects stateless component characteristics (pure functions, prop-driven) to Flux principles.",
            "Explains benefits like predictability, clear data flow, testability, and reusability.",
            "Demonstrates understanding of the synergy between React components and Flux pattern."
          ],
          "keyConcepts": [
            "Stateless Components",
            "Pure Functions",
            "Flux Architecture",
            "Props",
            "Unidirectional Data Flow"
          ],
          "evaluationCriteria": [
            "Clarity and depth of explanation.",
            "Logical connection between concepts."
          ],
          "example": "```javascript\nconst DisplayMessage = ({ message }) => (\n  <div>\n    <p>{message}</p>\n  </div>\n);\n\n// In a Flux app, 'message' would come from a Store and passed via a parent View.\n// This component doesn't need to know how 'message' was updated; it just displays it.\n```",
          "tags": [
            "Flux",
            "React",
            "Stateless Components",
            "Open-ended"
          ],
          "prerequisites": [
            "Flux Architecture",
            "React Component Types"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_flux_4",
          "topic": "Flux Architecture: Flow Cycle",
          "level": "medium",
          "type": "open",
          "question": "Describe the complete lifecycle of a data update in a Flux application, starting from a user action in a View and ending with the View re-rendering. Use the terms: Actions, Dispatcher, Stores, Views.",
          "answer": "The complete lifecycle of a data update in a Flux application follows a strict unidirectional flow:\n\n1.  **View Action**: A user interacts with a **View** (React component), such as clicking a button or typing into an input field. This interaction triggers the View to call an **Action Creator**.\n2.  **Action Creation**: The Action Creator constructs an **Action** object, which is a plain JavaScript object containing a `type` (describing what happened) and often a `payload` (the data associated with the event).\n3.  **Action Dispatch**: The Action is then sent to the **Dispatcher**. The Dispatcher is the central hub, responsible for receiving all actions and broadcasting them to all registered **Stores**. It ensures actions are processed one at a time and in order, managing dependencies between Stores.\n4.  **Store Update**: Each **Store** (which holds a specific slice of the application's state and its related logic) listens for relevant actions from the Dispatcher. When a Store receives an action it's interested in, it updates its internal state based on the action's type and payload. Importantly, Stores are the only place where state can be changed.\n5.  **Store Emission**: After a Store updates its state, it emits a 'change' event (e.g., using Node's `EventEmitter`).\n6.  **View Re-render**: The **Views** that are interested in the specific Store's data are listening for these 'change' events. Upon receiving a change event, these Views retrieve the updated state from the Store and re-render themselves to reflect the new data in the UI.\n\nThis cycle ensures that all data changes are predictable and traceable.",
          "options": [],
          "analysisPoints": [
            "Accurately describes each step of the Flux data flow.",
            "Clearly defines the role of Actions, Dispatcher, Stores, and Views in the cycle.",
            "Emphasizes the unidirectional nature and the responsibilities of each component."
          ],
          "keyConcepts": [
            "Flux Flow",
            "Actions",
            "Dispatcher",
            "Stores",
            "Views",
            "Unidirectional Data Flow"
          ],
          "evaluationCriteria": [
            "Completeness and accuracy of the flow.",
            "Correct usage of terminology."
          ],
          "example": "![Flux Architecture Flow](images/flux_pattern.png)",
          "tags": [
            "Flux",
            "Flow",
            "Architecture",
            "Open-ended"
          ],
          "prerequisites": [
            "Flux Architecture Overview"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_flux_5",
          "topic": "Flux Architecture: Stores",
          "level": "easy",
          "type": "flashcard",
          "question": "In Flux, what do 'Stores' primarily contain?",
          "answer": "Stores are containers for application state and logic.",
          "options": [],
          "analysisPoints": [
            "Direct recall of Store's content."
          ],
          "keyConcepts": [
            "Flux",
            "Stores",
            "State",
            "Logic"
          ],
          "evaluationCriteria": [
            "Basic definition recall."
          ],
          "example": "A `UserStore` in a Flux application might hold the current user's data (state) and methods to update that user data (logic) based on actions like `LOGIN` or `LOGOUT`.",
          "tags": [
            "Flux",
            "Stores",
            "Basic"
          ],
          "prerequisites": [
            "Flux Architecture Overview"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_flux_6",
          "topic": "Flux Architecture: Actions",
          "level": "easy",
          "type": "flashcard",
          "question": "What are 'Actions' in Flux architecture?",
          "answer": "Actions are payloads of information that send data from your application (typically from Views) to your store, via the Dispatcher.",
          "options": [],
          "analysisPoints": [
            "Direct recall of Action's purpose."
          ],
          "keyConcepts": [
            "Flux",
            "Actions",
            "Payloads",
            "Data Flow"
          ],
          "evaluationCriteria": [
            "Basic definition recall."
          ],
          "example": "An example of an action could be `{ type: 'ADD_ITEM', item: { name: 'Milk', quantity: 1 } }`.",
          "tags": [
            "Flux",
            "Actions",
            "Basic"
          ],
          "prerequisites": [
            "Flux Architecture Overview"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_flux_redux_comp_1",
          "topic": "Flux vs. Redux: Stores",
          "level": "medium",
          "type": "mcq",
          "question": "A key difference between Flux and Redux lies in their approach to state storage. Which statement accurately reflects this difference?",
          "answer": "Flux typically utilizes multiple, domain-specific stores, whereas Redux enforces a single, centralized store for the entire application state.",
          "options": [
            "Flux uses a single store, while Redux uses multiple stores.",
            "Both Flux and Redux require multiple stores to manage complex application state.",
            "Flux typically utilizes multiple, domain-specific stores, whereas Redux enforces a single, centralized store for the entire application state.",
            "Neither Flux nor Redux has a concept of 'stores'; they directly manage state in components."
          ],
          "analysisPoints": [
            "Correctly identifies the distinction in store quantity.",
            "Understands the concept of single vs. multiple sources of truth.",
            "Avoids common misconceptions."
          ],
          "keyConcepts": [
            "Flux vs Redux",
            "Stores",
            "Single Source of Truth"
          ],
          "evaluationCriteria": [
            "Accurate comparison point.",
            "Knowledge of architectural differences."
          ],
          "example": "In Flux, you might have a `UserStore` and a `ProductStore` operating independently. In Redux, all user and product data would reside within a single state tree managed by one Redux store.",
          "tags": [
            "Flux",
            "Redux",
            "Comparison",
            "Stores",
            "MCQ"
          ],
          "prerequisites": [
            "Flux Architecture",
            "Redux Core Concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_flux_redux_comp_2",
          "topic": "Flux vs. Redux: Dispatcher",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary difference in how Flux and Redux handle the dispatching mechanism?",
          "answer": "Flux requires a central, dedicated Dispatcher that manages all data flow and ensures actions are processed. Redux, on the other hand, does not have a separate Dispatcher; it relies on the store's `dispatch` method and pure reducer functions to handle actions.",
          "options": [],
          "analysisPoints": [
            "Highlights the presence/absence of a dedicated Dispatcher.",
            "Explains how each architecture handles action processing.",
            "Connects Redux's approach to pure functions."
          ],
          "keyConcepts": [
            "Flux vs Redux",
            "Dispatcher",
            "Action Dispatch",
            "Pure Functions"
          ],
          "evaluationCriteria": [
            "Accuracy of comparison.",
            "Understanding of architectural mechanics."
          ],
          "example": "In Flux, all actions go through the Dispatcher. In Redux, you call `store.dispatch(action)`, and the action goes directly to the root reducer.",
          "tags": [
            "Flux",
            "Redux",
            "Comparison",
            "Dispatcher",
            "Flashcard"
          ],
          "prerequisites": [
            "Flux Architecture",
            "Redux Core Concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_flux_redux_comp_3",
          "topic": "Flux vs. Redux: State Mutations",
          "level": "hard",
          "type": "open",
          "question": "Discuss the stance of Flux and Redux on state mutations. How does Redux enforce its approach, and what are the benefits of this enforcement compared to Flux's allowances?",
          "answer": "The handling of state mutations is one of the most significant architectural differences between Flux and Redux.\n\n**Flux's Stance**: Flux generally **allows state mutations** within its Stores. While best practices often suggest avoiding direct mutation even in Flux, the pattern itself doesn't strictly prevent it. Stores can directly modify their internal state when reacting to actions.\n\n**Redux's Stance**: Redux strictly **enforces immutability**. Reducers in Redux must always return a *new* state object, rather than modifying the existing one. This is a foundational principle of Redux.\n\n**How Redux Enforces Immutability**:\n1.  **Reducer Contract**: The core contract of a Redux reducer is `(state, action) => newState`. It's implicitly understood that `newState` must be a newly created object, not a mutated version of `state`.\n2.  **Developer Convention**: Developers are trained to use techniques like object spread (`{...state, ...}`), array spread (`[...array, item]`), or libraries like Immer (built into Redux Toolkit) to ensure immutable updates.\n3.  **DevTools and Middleware**: Redux DevTools heavily rely on state immutability for features like time-travel debugging and action replay. Middleware often expects state to be immutable for predictable processing.\n\n**Benefits of Redux's Enforcement Compared to Flux's Allowance**:\n1.  **Predictability and Debugging**: Immutability makes state changes entirely predictable. Every state is a snapshot, making it easy to trace exactly how the state evolved over time. This is crucial for debugging, especially with Redux DevTools' time-travel capabilities.\n2.  **Performance Optimizations in React**: React's reconciliation algorithm can efficiently optimize re-renders using shallow equality checks. If state objects are truly new when they change (due to immutability), React can quickly determine if a component's props/state have changed by simply comparing references, avoiding expensive deep comparisons. Flux's allowance of mutation can lead to subtle bugs where React components don't re-render because the state object reference hasn't changed, even if its contents have.\n3.  **Undo/Redo Functionality**: Implementing features like undo/redo is straightforward with immutable state, as you simply maintain a history of state objects.\n4.  **Concurrency Safety**: Immutable data structures are inherently thread-safe, which can be advantageous in complex scenarios, though less critical for typical single-threaded JavaScript environments.\n5.  **Simpler Change Detection**: Knowing that a new reference means a change, and an old reference means no change, simplifies change detection logic significantly across the application.",
          "options": [],
          "analysisPoints": [
            "Clearly contrasts state mutation policies.",
            "Explains Redux's methods of enforcing immutability.",
            "Provides comprehensive benefits of Redux's immutable approach (debugging, performance, features).",
            "Highlights the pitfalls of mutable state in Flux contexts (though not strictly a Flux flaw, it's a potential pitfall of its model)."
          ],
          "keyConcepts": [
            "Flux vs Redux",
            "State Mutations",
            "Immutability",
            "Pure Functions",
            "Debugging",
            "Performance",
            "Time-Travel Debugging",
            "Immer"
          ],
          "evaluationCriteria": [
            "Depth of analysis.",
            "Accuracy of technical details.",
            "Comparative insight."
          ],
          "example": "See `question_redux_react_3` example for mutable vs. immutable reducer code.",
          "tags": [
            "Flux",
            "Redux",
            "Comparison",
            "Immutability",
            "State Mutations",
            "Open-ended"
          ],
          "prerequisites": [
            "Flux Architecture",
            "Redux Core Concepts",
            "JavaScript Immutability"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_flux_redux_comp_4",
          "topic": "Flux vs. Redux: Middleware",
          "level": "medium",
          "type": "mcq",
          "question": "Regarding middleware, which of the following statements accurately describes the difference between Flux and Redux?",
          "answer": "Redux has built-in support for middleware, allowing interception of dispatched actions for side effects, while Flux does not have a built-in middleware concept.",
          "options": [
            "Both Flux and Redux have robust, built-in middleware systems for handling asynchronous operations.",
            "Flux's central Dispatcher inherently provides middleware capabilities, whereas Redux requires external libraries.",
            "Redux has built-in support for middleware, allowing interception of dispatched actions for side effects, while Flux does not have a built-in middleware concept.",
            "Middleware in Redux is only used for logging, not for asynchronous operations."
          ],
          "analysisPoints": [
            "Correctly identifies Redux's native middleware support.",
            "Notes Flux's lack of built-in middleware.",
            "Understands middleware's role beyond just logging (e.g., async operations)."
          ],
          "keyConcepts": [
            "Flux vs Redux",
            "Middleware",
            "Asynchronous Operations",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Accurate comparison point.",
            "Knowledge of middleware purpose."
          ],
          "example": "Redux middleware like `redux-thunk` or `redux-saga` allow you to write logic that interacts with dispatched actions before they reach the reducers, enabling API calls or other side effects. Flux typically handles these directly in action creators or stores.",
          "tags": [
            "Flux",
            "Redux",
            "Comparison",
            "Middleware",
            "MCQ"
          ],
          "prerequisites": [
            "Redux Middleware"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_flux_redux_comp_5",
          "topic": "Flux vs. Redux: Logic Separation",
          "level": "easy",
          "type": "flashcard",
          "question": "How do Flux and Redux differ in terms of how state and change logic are structured within their 'Store' concepts?",
          "answer": "In Flux, Stores contain both the state and the logic for state changes. In Redux, the Store holds the state, but the change logic is separated into pure functions called reducers.",
          "options": [],
          "analysisPoints": [
            "Highlights the coupling vs. separation of state and logic.",
            "Identifies reducers as the distinct logic handlers in Redux."
          ],
          "keyConcepts": [
            "Flux vs Redux",
            "Stores",
            "Logic Separation",
            "Reducers"
          ],
          "evaluationCriteria": [
            "Accuracy of comparison point.",
            "Conciseness."
          ],
          "example": "In Flux, a `UserStore` would have `_users` array and a `switch` statement to update it. In Redux, the `users` array is part of the state, and a `usersReducer` handles updates.",
          "tags": [
            "Flux",
            "Redux",
            "Comparison",
            "Flashcard"
          ],
          "prerequisites": [
            "Flux Architecture",
            "Redux Core Concepts"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_toolkit_1",
          "topic": "Redux Toolkit: General Benefits",
          "level": "medium",
          "type": "open",
          "question": "What is Redux Toolkit, and what are its primary benefits for Redux application development?",
          "answer": "Redux Toolkit (RTK) is the official, opinionated, batteries-included toolset for efficient Redux development. It was created to simplify common Redux use cases, reduce boilerplate code, and enforce best practices.\n\nIts primary benefits include:\n1.  **Reduced Boilerplate**: RTK automates the creation of action types, action creators, and reducers, significantly reducing the amount of manual code needed.\n2.  **Simplified Configuration**: `configureStore` handles complex store setup (e.g., adding Redux DevTools, `redux-thunk`) with sensible defaults.\n3.  **Immutability with Immer**: Built-in integration with Immer allows developers to write 'mutating' logic within reducers, which is then automatically translated into immutable updates, making reducer code more intuitive and readable.\n4.  **Best Practices Enforcement**: RTK guides developers towards recommended Redux patterns, such as keeping state immutable and using proper action structures.\n5.  **Improved Developer Experience**: Overall, RTK streamlines the Redux development process, making it faster, less error-prone, and more enjoyable, especially for newcomers.",
          "options": [],
          "analysisPoints": [
            "Defines Redux Toolkit accurately.",
            "Lists and explains key benefits like boilerplate reduction, simplified config, Immer integration, and improved DX.",
            "Demonstrates understanding of RTK's role in modern Redux."
          ],
          "keyConcepts": [
            "Redux Toolkit",
            "RTK",
            "Boilerplate",
            "Immer",
            "Best Practices",
            "Developer Experience"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of RTK's purpose and advantages.",
            "Clarity and detail."
          ],
          "example": "Before RTK, setting up Redux often involved defining many constants, action creator functions, and complex switch statements for reducers. RTK condenses much of this into functions like `createSlice`.",
          "tags": [
            "Redux Toolkit",
            "RTK",
            "Benefits",
            "Open-ended"
          ],
          "prerequisites": [
            "Redux Core Concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_toolkit_2",
          "topic": "Redux Toolkit: `createSlice`",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following `createSlice` definition:\n\n```typescript\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState: { isAuthenticated: false, user: null },\n  reducers: {\n    login(state, action) {\n      state.isAuthenticated = true;\n      state.user = action.payload;\n    },\n    logout(state) {\n      state.isAuthenticated = false;\n      state.user = null;\n    },\n  },\n});\n\nexport const { login, logout } = authSlice.actions;\nexport default authSlice.reducer;\n```\n\nWhich statement is TRUE regarding the `login` and `logout` functions exported from `authSlice.actions`?",
          "answer": "They are action creators that, when called, return action objects with a `type` property automatically derived from the slice name and reducer function name (e.g., `auth/login`).",
          "options": [
            "They are reducers that directly mutate the `authSlice` state.",
            "They are asynchronous thunks that handle API calls.",
            "They are action types (string constants) that define the action.",
            "They are action creators that, when called, return action objects with a `type` property automatically derived from the slice name and reducer function name (e.g., `auth/login`)."
          ],
          "analysisPoints": [
            "Identifies the exported functions as action creators.",
            "Understands that RTK automatically generates action types.",
            "Recognizes that direct state mutation in reducers is safe due to Immer.",
            "Distinguishes action creators from reducers or action types."
          ],
          "keyConcepts": [
            "Redux Toolkit",
            "createSlice",
            "Action Creators",
            "Action Types",
            "Immer"
          ],
          "evaluationCriteria": [
            "Accurate understanding of `createSlice` output.",
            "Knowledge of RTK's automation."
          ],
          "example": "If you call `login({ username: 'testuser' })`, it will return an action object like `{ type: 'auth/login', payload: { username: 'testuser' } }`. This action can then be dispatched to the Redux store.",
          "tags": [
            "Redux Toolkit",
            "createSlice",
            "Actions",
            "MCQ"
          ],
          "prerequisites": [
            "Redux Toolkit Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_toolkit_3",
          "topic": "Redux Toolkit: Immer Integration",
          "level": "hard",
          "type": "open",
          "question": "Redux Toolkit uses Immer internally with `createSlice`. Explain how Immer enables 'mutating' logic within reducers without actually breaking Redux's immutability principle. What are the advantages of this approach?",
          "answer": "Immer is a library that allows you to work with state in a more convenient, mutable-looking way while ensuring that the actual state updates remain immutable. Redux Toolkit integrates Immer by default within its `createSlice` function.\n\n**How Immer Works (Enabling 'Mutable' Logic with Immutability):**\nWhen you define a reducer function inside `createSlice` (e.g., `increment(state) { state.value += 1; }`), the `state` argument that Immer provides to your reducer is not the actual original Redux state object. Instead, it's a special `draft` object (a Proxy).\n\n1.  **Draft State**: Immer creates a `draft` copy of your current state. You can then write code that appears to 'mutate' this `draft` object directly (e.g., `state.value += 1;`, `state.items.push(newItem)`).\n2.  **Change Tracking**: Immer tracks all changes made to this `draft` object.\n3.  **Produce New State**: Once your reducer function finishes, Immer uses the recorded changes to produce a brand-new, immutable state tree based on the original state. It applies the 'mutations' to the original state to create a new one, ensuring that no original data is actually modified. Only the parts of the state tree that were changed are copied; unchanged parts are structurally shared.\n\n**Advantages of this Approach (Immer + RTK):**\n1.  **Simplified Reducer Logic**: Reducers become much easier to write and read, as you no longer need to manually use spread operators (`...`) or other immutable update patterns, especially for nested state.\n2.  **Reduced Boilerplate**: It significantly cuts down the boilerplate associated with writing Redux reducers, particularly for complex state structures.\n3.  **Prevents Accidental Mutations**: By ensuring all 'mutations' are applied to a draft and result in a new immutable state, Immer helps prevent common bugs related to accidental direct state mutations that could occur when manually handling immutability.\n4.  **Improved Developer Experience**: Developers can write more intuitive, imperative-style code within reducers, which feels more natural for many, without sacrificing the benefits of immutability.",
          "options": [],
          "analysisPoints": [
            "Explains Immer's mechanism (draft state, change tracking, new state production).",
            "Connects Immer's functionality to Redux's immutability principle.",
            "Details the practical advantages for developers (simplicity, reduced boilerplate, bug prevention, DX).",
            "Distinguishes between perceived mutation and actual immutable update."
          ],
          "keyConcepts": [
            "Redux Toolkit",
            "Immer",
            "Immutability",
            "createSlice",
            "Proxy",
            "Draft State",
            "Boilerplate"
          ],
          "evaluationCriteria": [
            "Deep understanding of Immer's technical workings.",
            "Clear explanation of benefits.",
            "Ability to reconcile mutable syntax with immutable outcome."
          ],
          "example": "```typescript\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst exampleSlice = createSlice({\n  name: 'example',\n  initialState: { user: { name: 'Alice', age: 30 }, items: ['apple'] },\n  reducers: {\n    updateAge: (state, action) => {\n      state.user.age = action.payload; // Looks like mutation, but Immer handles immutably\n    },\n    addItem: (state, action) => {\n      state.items.push(action.payload); // Looks like mutation, but Immer handles immutably\n    },\n  },\n});\n```",
          "tags": [
            "Redux Toolkit",
            "Immer",
            "Immutability",
            "createSlice",
            "Open-ended"
          ],
          "prerequisites": [
            "Redux Immutability",
            "Redux Toolkit Basics"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_redux_toolkit_4",
          "topic": "Redux Toolkit: `configureStore`",
          "level": "easy",
          "type": "flashcard",
          "question": "What function in Redux Toolkit is used for setting up the Redux store, and what conveniences does it provide out-of-the-box?",
          "answer": "The `configureStore` function is used for setting up the Redux store. It automatically includes `redux-thunk` middleware, sets up Redux DevTools Extension integration, and combines reducers (if an object is passed to `reducer`).",
          "options": [],
          "analysisPoints": [
            "Identifies `configureStore`.",
            "Lists key automatic features (thunk, devtools, reducer combining).",
            "Highlights simplified setup."
          ],
          "keyConcepts": [
            "Redux Toolkit",
            "configureStore",
            "Redux Thunk",
            "Redux DevTools",
            "Middleware"
          ],
          "evaluationCriteria": [
            "Basic recall of function and its features."
          ],
          "example": "```typescript\nimport { configureStore } from '@reduxjs/toolkit';\nimport myReducer from './myReducer';\n\nconst store = configureStore({\n  reducer: {\n    myFeature: myReducer\n  }\n});\n```",
          "tags": [
            "Redux Toolkit",
            "configureStore",
            "Flashcard"
          ],
          "prerequisites": [
            "Redux Store Setup"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_redux_toolkit_5",
          "topic": "Redux Toolkit: Action Type Generation",
          "level": "easy",
          "type": "flashcard",
          "question": "How does `createSlice` simplify the definition of Redux action types?",
          "answer": "`createSlice` automatically generates unique action type strings for each reducer function defined within its `reducers` object, typically by combining the slice `name` and the reducer function name (e.g., `counter/increment`).",
          "options": [],
          "analysisPoints": [
            "Explains automatic generation.",
            "Describes the naming convention (slice name/reducer name).",
            "Highlights the reduction of manual work."
          ],
          "keyConcepts": [
            "Redux Toolkit",
            "createSlice",
            "Action Types",
            "Boilerplate"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation for action type generation."
          ],
          "example": "For a `counterSlice` with an `increment` reducer, the action type automatically generated will be `'counter/increment'`.",
          "tags": [
            "Redux Toolkit",
            "createSlice",
            "Actions",
            "Flashcard"
          ],
          "prerequisites": [
            "Redux Action Types"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_redux_integration_1",
          "title": "Build a Simple Redux Counter with React `connect`",
          "description": "\nImplement a basic counter application using Redux for state management and React for the UI. You'll need to set up the Redux store, define actions and a reducer, and connect a React component to the store using `react-redux`'s `connect()` HOC.\n\n**Requirements:**\n1.  **Redux Store**: Create a Redux store that manages a single `count` state, initialized to `0`.\n2.  **Actions**: Define two action types and corresponding action creators: `INCREMENT` and `DECREMENT`.\n3.  **Reducer**: Implement a pure reducer function that updates the `count` based on `INCREMENT` and `DECREMENT` actions, ensuring immutability.\n4.  **React Component**: Create a `Counter` React component that displays the current `count` and has two buttons: 'Increment' and 'Decrement'.\n5.  **Connect**: Use `react-redux`'s `connect()` HOC to link the `Counter` component to the Redux store. Ensure `count` is mapped from state to props, and `increment` and `decrement` action creators are mapped to props (dispatching automatically).\n6.  **Provider**: Wrap your main `App` (or `Counter`) component with `Provider` to make the store available.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore } from 'redux';\nimport { Provider, connect } from 'react-redux';\n\n// 1. Action Types\nconst INCREMENT = 'INCREMENT';\nconst DECREMENT = 'DECREMENT';\n\n// 2. Action Creators\nconst increment = () => ({ type: INCREMENT });\nconst decrement = () => ({ type: DECREMENT });\n\n// 3. Reducer\nconst counterReducer = (state = { count: 0 }, action) => {\n  switch (action.type) {\n    // TODO: Implement INCREMENT and DECREMENT logic ensuring immutability\n    default:\n      return state;\n  }\n};\n\n// Create the Redux store\nconst store = createStore(counterReducer);\n\n// 4. React Component\nconst Counter = ({ count, increment, decrement }) => {\n  return (\n    <div>\n      <h1>Counter: {count}</h1>\n      {/* TODO: Add Increment and Decrement buttons that call the respective props */}\n    </div>\n  );\n};\n\n// 5. mapStateToProps and mapDispatchToProps\nconst mapStateToProps = (state) => {\n  // TODO: Map Redux state 'count' to component prop 'count'\n  return {};\n};\n\nconst mapDispatchToProps = {\n  // TODO: Map action creators 'increment' and 'decrement' to component props\n};\n\n// Connect the Counter component\nconst ConnectedCounter = connect(mapStateToProps, mapDispatchToProps)(Counter);\n\n// 6. Render the application\nReactDOM.render(\n  <Provider store={store}>\n    <ConnectedCounter />\n  </Provider>,\n  document.getElementById('root')\n);\n",
          "solutionCode": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore } from 'redux';\nimport { Provider, connect } from 'react-redux';\n\n// 1. Action Types\nconst INCREMENT = 'INCREMENT';\nconst DECREMENT = 'DECREMENT';\n\n// 2. Action Creators\nconst increment = () => ({ type: INCREMENT });\nconst decrement = () => ({ type: DECREMENT });\n\n// 3. Reducer\nconst counterReducer = (state = { count: 0 }, action) => {\n  switch (action.type) {\n    case INCREMENT:\n      return { ...state, count: state.count + 1 };\n    case DECREMENT:\n      return { ...state, count: state.count - 1 };\n    default:\n      return state;\n  }\n};\n\n// Create the Redux store\nconst store = createStore(counterReducer);\n\n// 4. React Component\nconst Counter = ({ count, increment, decrement }) => {\n  return (\n    <div>\n      <h1>Counter: {count}</h1>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n    </div>\n  );\n};\n\n// 5. mapStateToProps and mapDispatchToProps\nconst mapStateToProps = (state) => ({\n  count: state.count,\n});\n\nconst mapDispatchToProps = {\n  increment,\n  decrement,\n};\n\n// Connect the Counter component\nconst ConnectedCounter = connect(mapStateToProps, mapDispatchToProps)(Counter);\n\n// 6. Render the application\nReactDOM.render(\n  <Provider store={store}>\n    <ConnectedCounter />\n  </Provider>,\n  document.getElementById('root')\n);\n",
          "testCases": [
            "Initial render: Counter should display 'Counter: 0'.",
            "Clicking 'Increment' button: Counter should display 'Counter: 1'.",
            "Clicking 'Increment' button twice: Counter should display 'Counter: 2'.",
            "Clicking 'Decrement' button: Counter should display 'Counter: 1'.",
            "Clicking 'Decrement' button from 0: Counter should display 'Counter: -1' (or appropriate negative value handling).",
            "Reducer immutability: Ensure reducer returns a new object for state changes, not mutating the original."
          ],
          "hints": [
            "Remember to use the spread operator (`...`) to create a new state object in your reducer to ensure immutability.",
            "`mapDispatchToProps` can be an object mapping action creators directly, `react-redux` will wrap them with `dispatch` automatically.",
            "Ensure `connect` is used correctly as a Higher-Order Component, wrapping your `Counter`."
          ],
          "tags": [
            "Redux",
            "React",
            "State Management",
            "connect",
            "Provider",
            "Beginner"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Basics",
            "Redux Core Concepts"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Redux Store",
            "Actions",
            "Reducers",
            "mapStateToProps",
            "mapDispatchToProps"
          ]
        },
        {
          "id": "task_redux_integration_2",
          "title": "Implement a Todo List with Redux and Async Actions",
          "description": "\nExtend the previous Redux setup to manage a todo list. This task will involve handling an array of objects, adding items, toggling their completion status, and simulating an asynchronous action (e.g., fetching todos).\n\n**Requirements:**\n1.  **State Structure**: The Redux state should manage an array of todo objects, each with `id`, `text`, and `completed` properties. Add a loading state for async operations.\n2.  **Actions**: Define action types and creators for:\n    *   `ADD_TODO`: Adds a new todo item.\n    *   `TOGGLE_TODO`: Toggles the `completed` status of a todo by `id`.\n    *   `FETCH_TODOS_REQUEST`, `FETCH_TODOS_SUCCESS`, `FETCH_TODOS_FAILURE`: For an async operation.\n3.  **Reducer**: Update the reducer to handle these new actions, maintaining immutability for the todo list.\n4.  **React Component**: Create `TodoList` and `TodoItem` components. `TodoList` displays the list, `TodoItem` displays a single todo and allows toggling completion. Include an input field and 'Add Todo' button, and a 'Fetch Todos' button.\n5.  **`connect`**: Connect components as needed to dispatch actions and display state.\n6.  **Async Action**: Implement a thunk (or simulate one) for `fetchTodos`. When the 'Fetch Todos' button is clicked, simulate a network request (e.g., using `setTimeout`) and then dispatch `FETCH_TODOS_SUCCESS` with mock data, or `FETCH_TODOS_FAILURE` on error.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore, applyMiddleware, combineReducers } from 'redux';\nimport { Provider, connect } from 'react-redux';\nimport thunk from 'redux-thunk';\n\n// Action Types\nconst ADD_TODO = 'ADD_TODO';\nconst TOGGLE_TODO = 'TOGGLE_TODO';\nconst FETCH_TODOS_REQUEST = 'FETCH_TODOS_REQUEST';\nconst FETCH_TODOS_SUCCESS = 'FETCH_TODOS_SUCCESS';\nconst FETCH_TODOS_FAILURE = 'FETCH_TODOS_FAILURE';\n\n// Action Creators\nconst addTodo = (text) => ({ type: ADD_TODO, payload: { id: Date.now(), text, completed: false } });\nconst toggleTodo = (id) => ({ type: TOGGLE_TODO, payload: { id } });\nconst fetchTodosRequest = () => ({ type: FETCH_TODOS_REQUEST });\nconst fetchTodosSuccess = (todos) => ({ type: FETCH_TODOS_SUCCESS, payload: todos });\nconst fetchTodosFailure = (error) => ({ type: FETCH_TODOS_FAILURE, payload: error });\n\n// Async Action Creator (Thunk)\nconst fetchTodos = () => async (dispatch) => {\n  dispatch(fetchTodosRequest());\n  try {\n    // TODO: Simulate an API call with setTimeout\n    const mockTodos = [\n      // Add some mock todo objects here\n    ];\n    // TODO: Dispatch fetchTodosSuccess with mockTodos after a delay\n  } catch (error) {\n    // TODO: Dispatch fetchTodosFailure on error\n  }\n};\n\n// Reducer\nconst todosReducer = (state = { list: [], loading: false, error: null }, action) => {\n  switch (action.type) {\n    // TODO: Implement ADD_TODO, TOGGLE_TODO, FETCH_TODOS_REQUEST/SUCCESS/FAILURE\n    default:\n      return state;\n  }\n};\n\nconst rootReducer = combineReducers({\n  todos: todosReducer,\n});\n\n// Create store with middleware\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\n// React Components\nconst TodoItem = ({ todo, toggleTodo }) => (\n  <li style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n    {todo.text}\n    <button onClick={() => toggleTodo(todo.id)}>Toggle</button>\n  </li>\n);\n\nconst TodoList = ({ todos, loading, error, addTodo, toggleTodo, fetchTodos }) => {\n  const [newTodoText, setNewTodoText] = useState('');\n\n  const handleAddTodo = () => {\n    if (newTodoText.trim()) {\n      addTodo(newTodoText);\n      setNewTodoText('');\n    }\n  };\n\n  return (\n    <div>\n      <h2>Todo List</h2>\n      <input\n        type=\"text\"\n        value={newTodoText}\n        onChange={(e) => setNewTodoText(e.target.value)}\n        placeholder=\"Add new todo\"\n      />\n      <button onClick={handleAddTodo}>Add Todo</button>\n      <button onClick={fetchTodos} disabled={loading}>Fetch Todos</button>\n\n      {loading && <p>Loading todos...</p>}\n      {error && <p style={{ color: 'red' }}>Error: {error.message}</p>}\n\n      <ul>\n        {/* TODO: Render TodoItem components */}\n      </ul>\n    </div>\n  );\n};\n\nconst mapStateToProps = (state) => ({\n  todos: state.todos.list,\n  loading: state.todos.loading,\n  error: state.todos.error,\n});\n\nconst mapDispatchToProps = {\n  addTodo,\n  toggleTodo,\n  fetchTodos,\n};\n\nconst ConnectedTodoList = connect(mapStateToProps, mapDispatchToProps)(TodoList);\n\nReactDOM.render(\n  <Provider store={store}>\n    <ConnectedTodoList />\n  </Provider>,\n  document.getElementById('root')\n);\n",
          "solutionCode": "import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore, applyMiddleware, combineReducers } from 'redux';\nimport { Provider, connect } from 'react-redux';\nimport thunk from 'redux-thunk';\n\n// Action Types\nconst ADD_TODO = 'ADD_TODO';\nconst TOGGLE_TODO = 'TOGGLE_TODO';\nconst FETCH_TODOS_REQUEST = 'FETCH_TODOS_REQUEST';\nconst FETCH_TODOS_SUCCESS = 'FETCH_TODOS_SUCCESS';\nconst FETCH_TODOS_FAILURE = 'FETCH_TODOS_FAILURE';\n\n// Action Creators\nconst addTodo = (text) => ({ type: ADD_TODO, payload: { id: Date.now(), text, completed: false } });\nconst toggleTodo = (id) => ({ type: TOGGLE_TODO, payload: { id } });\nconst fetchTodosRequest = () => ({ type: FETCH_TODOS_REQUEST });\nconst fetchTodosSuccess = (todos) => ({ type: FETCH_TODOS_SUCCESS, payload: todos });\nconst fetchTodosFailure = (error) => ({ type: FETCH_TODOS_FAILURE, payload: error });\n\n// Async Action Creator (Thunk)\nconst fetchTodos = () => async (dispatch) => {\n  dispatch(fetchTodosRequest());\n  try {\n    await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate API call\n    const mockTodos = [\n      { id: 101, text: 'Learn Redux', completed: false },\n      { id: 102, text: 'Build a Todo App', completed: true },\n      { id: 103, text: 'Explore Redux Toolkit', completed: false },\n    ];\n    if (Math.random() > 0.1) { // 90% success, 10% failure\n      dispatch(fetchTodosSuccess(mockTodos));\n    } else {\n      throw new Error('Failed to fetch todos.');\n    }\n  } catch (error) {\n    dispatch(fetchTodosFailure(error));\n  }\n};\n\n// Reducer\nconst todosReducer = (state = { list: [], loading: false, error: null }, action) => {\n  switch (action.type) {\n    case ADD_TODO:\n      return { ...state, list: [...state.list, action.payload] };\n    case TOGGLE_TODO:\n      return {\n        ...state,\n        list: state.list.map(todo =>\n          todo.id === action.payload.id ? { ...todo, completed: !todo.completed } : todo\n        ),\n      };\n    case FETCH_TODOS_REQUEST:\n      return { ...state, loading: true, error: null };\n    case FETCH_TODOS_SUCCESS:\n      return { ...state, loading: false, error: null, list: action.payload };\n    case FETCH_TODOS_FAILURE:\n      return { ...state, loading: false, error: action.payload };\n    default:\n      return state;\n  }\n};\n\nconst rootReducer = combineReducers({\n  todos: todosReducer,\n});\n\n// Create store with middleware\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\n// React Components\nconst TodoItem = ({ todo, toggleTodo }) => (\n  <li style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n    {todo.text}\n    <button onClick={() => toggleTodo(todo.id)}>Toggle</button>\n  </li>\n);\n\nconst TodoList = ({ todos, loading, error, addTodo, toggleTodo, fetchTodos }) => {\n  const [newTodoText, setNewTodoText] = useState('');\n\n  const handleAddTodo = () => {\n    if (newTodoText.trim()) {\n      addTodo(newTodoText);\n      setNewTodoText('');\n    }\n  };\n\n  return (\n    <div>\n      <h2>Todo List</h2>\n      <input\n        type=\"text\"\n        value={newTodoText}\n        onChange={(e) => setNewTodoText(e.target.value)}\n        placeholder=\"Add new todo\"\n      />\n      <button onClick={handleAddTodo}>Add Todo</button>\n      <button onClick={fetchTodos} disabled={loading}>Fetch Todos</button>\n\n      {loading && <p>Loading todos...</p>}\n      {error && <p style={{ color: 'red' }}>Error: {error.message}</p>}\n\n      <ul>\n        {todos.map(todo => (\n          <TodoItem key={todo.id} todo={todo} toggleTodo={toggleTodo} />\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nconst mapStateToProps = (state) => ({\n  todos: state.todos.list,\n  loading: state.todos.loading,\n  error: state.todos.error,\n});\n\nconst mapDispatchToProps = {\n  addTodo,\n  toggleTodo,\n  fetchTodos,\n};\n\nconst ConnectedTodoList = connect(mapStateToProps, mapDispatchToProps)(TodoList);\n\nReactDOM.render(\n  <Provider store={store}>\n    <ConnectedTodoList />\n  </Provider>,\n  document.getElementById('root')\n);\n",
          "testCases": [
            "Initial render: Todo list should be empty, no loading/error messages.",
            "Add todo: Typing in input and clicking 'Add Todo' should add a new item to the list, clear input.",
            "Toggle todo: Clicking 'Toggle' on an item should cross it out (and vice versa).",
            "Fetch todos (success): Clicking 'Fetch Todos' should show 'Loading...', then display mock todos and hide loading message.",
            "Fetch todos (error): Simulate an error during fetch (e.g., `Math.random()` to trigger failure), 'Loading...' should disappear and an error message should be displayed.",
            "Reducer immutability: Verify that all reducer operations return new state objects/arrays, not mutated originals.",
            "Loading state: 'Fetch Todos' button should be disabled when `loading` is true."
          ],
          "hints": [
            "Use `combineReducers` if you plan to have more than one reducer (though for this task, a single one for `todos` is fine if it manages `list`, `loading`, `error`).",
            "Remember that `redux-thunk` middleware is necessary to dispatch functions (thunks) instead of plain objects.",
            "For array immutability, `Array.prototype.map()` and `Array.prototype.filter()` are your friends, along with spread syntax (`...`).",
            "Handle edge cases like empty input for new todos.",
            "Consider using a `key` prop when mapping list items in React."
          ],
          "tags": [
            "Redux",
            "React",
            "State Management",
            "Async",
            "Middleware",
            "Thunk",
            "Complex"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "Redux Integration",
            "Redux Middleware",
            "JavaScript Promises"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Redux Thunk",
            "combineReducers",
            "Asynchronous Actions",
            "State Normalization"
          ]
        },
        {
          "id": "task_redux_toolkit_1",
          "title": "Refactor a Counter App to Redux Toolkit `createSlice`",
          "description": "\nRefactor a traditional Redux counter application to use Redux Toolkit's `createSlice`. This task focuses on simplifying the action types, action creators, and reducer definition.\n\n**Requirements:**\n1.  **Original Redux Setup (Provided)**: Start with a basic Redux counter (like in `task_redux_integration_1`).\n2.  **`createSlice`**: Replace the manual action type constants, action creators, and the `switch-case` reducer with a single `createSlice` call for the 'counter' feature.\n3.  **`configureStore`**: Use `configureStore` to set up the Redux store, passing your new slice reducer.\n4.  **React Component**: The React `Counter` component should remain functionally the same, but its connected `mapStateToProps` and `mapDispatchToProps` (or `useSelector`/`useDispatch` if you prefer, but `connect` is also fine to show refactoring) should be updated to work with the `createSlice` generated actions/state.\n5.  **Immer Usage**: Demonstrate that you can directly 'mutate' the `state` object inside the `reducers` property of `createSlice` and it still works correctly due to Immer.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore } from 'redux'; // We will replace this with configureStore from RTK\nimport { Provider, connect } from 'react-redux';\n\n// --- Old Redux Boilerplate (To be replaced with Redux Toolkit) ---\nconst INCREMENT = 'INCREMENT';\nconst DECREMENT = 'DECREMENT';\n\nconst increment = () => ({ type: INCREMENT });\nconst decrement = () => ({ type: DECREMENT });\n\nconst counterReducer = (state = { count: 0 }, action) => {\n  switch (action.type) {\n    case INCREMENT:\n      return { ...state, count: state.count + 1 };\n    case DECREMENT:\n      return { ...state, count: state.count - 1 };\n    default:\n      return state;\n  }\n};\n\nconst store = createStore(counterReducer);\n// ------------------------------------------------------------------\n\n// React Component (should remain the same functionally)\nconst Counter = ({ count, increment, decrement }) => {\n  return (\n    <div>\n      <h1>Counter: {count}</h1>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n    </div>\n  );\n};\n\n// mapStateToProps and mapDispatchToProps (will need updates)\nconst mapStateToProps = (state) => ({\n  count: state.count,\n});\n\nconst mapDispatchToProps = {\n  increment,\n  decrement,\n};\n\nconst ConnectedCounter = connect(mapStateToProps, mapDispatchToProps)(Counter);\n\nReactDOM.render(\n  <Provider store={store}>\n    <ConnectedCounter />\n  </Provider>,\n  document.getElementById('root')\n);\n",
          "solutionCode": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { configureStore, createSlice } from '@reduxjs/toolkit';\nimport { Provider, connect } from 'react-redux';\n\n// --- Redux Toolkit Implementation ---\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 },\n  reducers: {\n    increment: (state) => {\n      state.value += 1; // Immer allows direct mutation here\n    },\n    decrement: (state) => {\n      state.value -= 1; // Immer allows direct mutation here\n    },\n    // Example with payload\n    addAmount: (state, action) => {\n      state.value += action.payload;\n    },\n  },\n});\n\nexport const { increment, decrement, addAmount } = counterSlice.actions;\n\n// Configure the store using Redux Toolkit's configureStore\nconst store = configureStore({\n  reducer: {\n    counter: counterSlice.reducer, // Assign the slice reducer\n  },\n});\n// -------------------------------------\n\n// React Component (functionally the same)\nconst Counter = ({ count, increment, decrement }) => {\n  return (\n    <div>\n      <h1>Counter: {count}</h1>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n    </div>\n  );\n};\n\n// mapStateToProps and mapDispatchToProps (updated for RTK slice structure)\nconst mapStateToProps = (state) => ({\n  // Access the 'value' property nested under the 'counter' slice\n  count: state.counter.value,\n});\n\nconst mapDispatchToProps = {\n  // Use the action creators exported from counterSlice.actions\n  increment,\n  decrement,\n};\n\nconst ConnectedCounter = connect(mapStateToProps, mapDispatchToProps)(Counter);\n\nReactDOM.render(\n  <Provider store={store}>\n    <ConnectedCounter />\n  </Provider>,\n  document.getElementById('root')\n);\n",
          "testCases": [
            "Initial render: Counter should display 'Counter: 0'.",
            "Clicking 'Increment': Counter should display 'Counter: 1'.",
            "Clicking 'Decrement': Counter should display 'Counter: 0'.",
            "Verify `createSlice` output: The `increment` and `decrement` functions exported from `counterSlice.actions` should be valid action creators (e.g., `increment().type` should be 'counter/increment').",
            "Verify `configureStore` functionality: Redux DevTools should correctly show actions and state changes (if active in browser)."
          ],
          "hints": [
            "Remember to import `configureStore` and `createSlice` from `@reduxjs/toolkit`.",
            "Your `initialState` within `createSlice` should be a plain object, and your reducer logic within `reducers` can directly 'mutate' this state (due to Immer).",
            "When accessing state in `mapStateToProps`, remember that `createSlice` places its state under the `name` you gave it (e.g., `state.counter.value`).",
            "The action creators generated by `createSlice` are automatically bound for `dispatch` if used in `mapDispatchToProps` as an object."
          ],
          "tags": [
            "Redux Toolkit",
            "RTK",
            "createSlice",
            "Refactoring",
            "Boilerplate",
            "Intermediate"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Redux Integration",
            "Redux Core Concepts"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "configureStore",
            "Immer",
            "Action Creators",
            "Reducers"
          ]
        },
        {
          "id": "task_redux_toolkit_2",
          "title": "Build a Feature with `createSlice` and Asynchronous Thunks",
          "description": "\nBuild a small 'user profile' feature that allows fetching user data asynchronously and updating parts of it locally, all managed with Redux Toolkit's `createSlice` and async thunks.\n\n**Requirements:**\n1.  **State Structure**: Create a slice for `user` state, including `profile` (e.g., `id`, `name`, `email`), `status` (e.g., 'idle', 'loading', 'succeeded', 'failed'), and `error`.\n2.  **`createSlice`**: Define the `userSlice` using `createSlice`. It should have:\n    *   `initialState` for `profile`, `status`, `error`.\n    *   Synchronous `reducers` for updating `name` and `email` locally.\n    *   `extraReducers` to handle the lifecycle of an asynchronous thunk for fetching user data.\n3.  **Asynchronous Thunk**: Implement an `asyncThunk` (e.g., `fetchUserById`) that simulates an API call (e.g., with `setTimeout`) and dispatches success or failure actions. This thunk should be handled in `extraReducers`.\n4.  **React Components**: Create a main `UserProfile` component that:\n    *   Displays user `name` and `email`.\n    *   Shows loading/error status.\n    *   Has an 'Edit Name' input and button to update the name locally.\n    *   Has a 'Fetch User' button to trigger the async thunk.\n5.  **Integration**: Connect the `UserProfile` component to the Redux store using `useSelector` and `useDispatch` (or `connect` if preferred) to display state and dispatch actions/thunks.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\nimport { configureStore, createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { Provider, useSelector, useDispatch } from 'react-redux';\n\n// 1. Define the async thunk for fetching user data\nexport const fetchUserById = createAsyncThunk(\n  'user/fetchById', // Action type prefix\n  async (userId, { rejectWithValue }) => {\n    try {\n      // TODO: Simulate an API call\n      await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate network delay\n      const mockUsers = {\n        '1': { id: '1', name: 'Alice Smith', email: 'alice@example.com' },\n        '2': { id: '2', name: 'Bob Johnson', email: 'bob@example.com' },\n      };\n      const user = mockUsers[userId];\n      if (!user) {\n        throw new Error('User not found!');\n      }\n      if (Math.random() < 0.2) { // 20% chance of failure\n        throw new Error('Network error!');\n      }\n      return user;\n    } catch (err) {\n      return rejectWithValue(err.message); // Return error message on failure\n    }\n  }\n);\n\n// 2. Define the user slice using createSlice\nconst userSlice = createSlice({\n  name: 'user',\n  initialState: {\n    profile: null,\n    status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'\n    error: null,\n  },\n  reducers: {\n    // TODO: Add synchronous reducers like 'updateUserName'\n  },\n  extraReducers: (builder) => {\n    // TODO: Handle the lifecycle of fetchUserById (pending, fulfilled, rejected)\n    builder\n      // .addCase(fetchUserById.pending, (state) => { /* ... */ })\n      // .addCase(fetchUserById.fulfilled, (state, action) => { /* ... */ })\n      // .addCase(fetchUserById.rejected, (state, action) => { /* ... */ })\n  },\n});\n\nexport const { /* TODO: Export synchronous action creators */ } = userSlice.actions;\nexport default userSlice.reducer;\n\n// 3. Configure the Redux store\nconst store = configureStore({\n  reducer: {\n    user: userSlice.reducer,\n  },\n});\n\n// 4. React UserProfile Component\nconst UserProfile = () => {\n  const dispatch = useDispatch();\n  const { profile, status, error } = useSelector((state) => state.user);\n  const [newUserName, setNewUserName] = useState('');\n\n  useEffect(() => {\n    // Optionally fetch a default user on component mount\n    // dispatch(fetchUserById('1'));\n  }, [dispatch]);\n\n  const handleUpdateName = () => {\n    if (newUserName.trim() && profile) {\n      // TODO: Dispatch the synchronous action to update user name\n      setNewUserName('');\n    }\n  };\n\n  const handleFetchUser = () => {\n    // TODO: Dispatch the async thunk to fetch user by ID (e.g., '1')\n  };\n\n  return (\n    <div>\n      <h2>User Profile</h2>\n      {status === 'loading' && <p>Loading user data...</p>}\n      {status === 'failed' && <p style={{ color: 'red' }}>Error: {error}</p>}\n\n      {profile ? (\n        <div>\n          <p>Name: {profile.name}</p>\n          <p>Email: {profile.email}</p>\n          <div>\n            <input\n              type=\"text\"\n              value={newUserName}\n              onChange={(e) => setNewUserName(e.target.value)}\n              placeholder=\"New Name\"\n            />\n            <button onClick={handleUpdateName}>Update Name Locally</button>\n          </div>\n        </div>\n      ) : (\n        !loading && !error && <p>No user loaded. Click 'Fetch User'.</p>\n      )}\n\n      <button onClick={handleFetchUser} disabled={status === 'loading'}>\n        Fetch User (ID: 1)\n      </button>\n    </div>\n  );\n};\n\nReactDOM.render(\n  <Provider store={store}>\n    <UserProfile />\n  </Provider>,\n  document.getElementById('root')\n);\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\nimport { configureStore, createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { Provider, useSelector, useDispatch } from 'react-redux';\n\n// 1. Define the async thunk for fetching user data\nexport const fetchUserById = createAsyncThunk(\n  'user/fetchById', // Action type prefix\n  async (userId, { rejectWithValue }) => {\n    try {\n      await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate network delay\n      const mockUsers = {\n        '1': { id: '1', name: 'Alice Smith', email: 'alice@example.com' },\n        '2': { id: '2', name: 'Bob Johnson', email: 'bob@example.com' },\n      };\n      const user = mockUsers[userId];\n      if (!user) {\n        throw new Error('User not found!');\n      }\n      if (Math.random() < 0.2) { // 20% chance of failure\n        throw new Error('Network error!');\n      }\n      return user;\n    } catch (err) {\n      return rejectWithValue(err.message); // Return error message on failure\n    }\n  }\n);\n\n// 2. Define the user slice using createSlice\nconst userSlice = createSlice({\n  name: 'user',\n  initialState: {\n    profile: null,\n    status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'\n    error: null,\n  },\n  reducers: {\n    updateUserName: (state, action) => {\n      if (state.profile) {\n        state.profile.name = action.payload;\n      }\n    },\n    // More local update reducers can go here\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchUserById.pending, (state) => {\n        state.status = 'loading';\n        state.error = null;\n      })\n      .addCase(fetchUserById.fulfilled, (state, action) => {\n        state.status = 'succeeded';\n        state.profile = action.payload;\n        state.error = null;\n      })\n      .addCase(fetchUserById.rejected, (state, action) => {\n        state.status = 'failed';\n        state.error = action.payload as string; // Payload is the error message\n        state.profile = null;\n      });\n  },\n});\n\nexport const { updateUserName } = userSlice.actions;\nexport default userSlice.reducer;\n\n// 3. Configure the Redux store\nconst store = configureStore({\n  reducer: {\n    user: userSlice.reducer,\n  },\n});\n\n// 4. React UserProfile Component\nconst UserProfile = () => {\n  const dispatch = useDispatch();\n  const { profile, status, error } = useSelector((state) => state.user);\n  const [newUserName, setNewUserName] = useState('');\n\n  useEffect(() => {\n    // Optionally fetch a default user on component mount\n    dispatch(fetchUserById('1')); // Fetch user with ID 1 by default\n  }, [dispatch]);\n\n  const handleUpdateName = () => {\n    if (newUserName.trim() && profile) {\n      dispatch(updateUserName(newUserName));\n      setNewUserName('');\n    }\n  };\n\n  const handleFetchUser = () => {\n    dispatch(fetchUserById('1')); // Always fetch user with ID 1 for this example\n  };\n\n  return (\n    <div>\n      <h2>User Profile</h2>\n      {status === 'loading' && <p>Loading user data...</p>}\n      {status === 'failed' && <p style={{ color: 'red' }}>Error: {error}</p>}\n\n      {profile ? (\n        <div>\n          <p>Name: {profile.name}</p>\n          <p>Email: {profile.email}</p>\n          <div>\n            <input\n              type=\"text\"\n              value={newUserName}\n              onChange={(e) => setNewUserName(e.target.value)}\n              placeholder=\"New Name\"\n            />\n            <button onClick={handleUpdateName}>Update Name Locally</button>\n          </div>\n        </div>\n      ) : (\n        status === 'idle' && <p>No user loaded. Click 'Fetch User'.</p>\n      )}\n\n      <button onClick={handleFetchUser} disabled={status === 'loading'}>\n        Fetch User (ID: 1)\n      </button>\n    </div>\n  );\n};\n\nReactDOM.render(\n  <Provider store={store}>\n    <UserProfile />\n  </Provider>,\n  document.getElementById('root')\n);\n",
          "testCases": [
            "Initial render: Should show 'Loading user data...' then display default user ('Alice Smith') or 'No user loaded.' depending on `useEffect` initial dispatch.",
            "Local name update: Typing a new name and clicking 'Update Name Locally' should change the displayed name without a network request.",
            "Fetch user (success): Clicking 'Fetch User' should show 'Loading...' for ~1.5s, then display 'Alice Smith'.",
            "Fetch user (failure): Repeatedly clicking 'Fetch User' should eventually trigger the simulated network error (20% chance), displaying an error message (e.g., 'Network error!').",
            "Loading state: 'Fetch User' button should be disabled when `status` is 'loading'.",
            "Error state clearing: After an error, a subsequent successful 'Fetch User' should clear the error and display user data.",
            "Immutability check: Verify that state updates (both sync and async) do not mutate the original state object directly when observed in Redux DevTools.",
            "Edge case: Update name locally when no user is loaded (should not cause error, or button should be disabled)."
          ],
          "hints": [
            "Remember to use `createAsyncThunk` for your asynchronous logic.",
            "The `extraReducers` builder uses `addCase` to handle actions from `createAsyncThunk` (which dispatches `pending`, `fulfilled`, `rejected` actions automatically).",
            "Ensure your reducers in `extraReducers` correctly update `status`, `profile`, and `error` states based on the async thunk's lifecycle.",
            "Don't forget to export the synchronous action creators from `userSlice.actions`."
          ],
          "tags": [
            "Redux Toolkit",
            "RTK",
            "createSlice",
            "createAsyncThunk",
            "Async Operations",
            "State Management",
            "Hard"
          ],
          "timeEstimate": 120,
          "prerequisites": [
            "Redux Toolkit Basics",
            "Redux Thunk",
            "Promises",
            "React Hooks"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Redux DevTools",
            "Middleware",
            "Error Handling",
            "Data Fetching Patterns"
          ]
        }
      ]
    }
  }
]