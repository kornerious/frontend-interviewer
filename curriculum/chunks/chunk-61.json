[
  {
    "id": "460ee28e-203f-4b26-bf47-da77a1ba06fc",
    "startLine": 12400,
    "endLine": 12499,
    "processedDate": "2025-06-17T12:53:51.914Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_deployment_checklist",
          "title": "Deployment Checklist for Frontend Applications",
          "content": "Optimizing a frontend application for production involves several crucial steps to ensure speed, efficiency, and reliability. This deployment checklist covers key areas to improve user experience and reduce operational costs.\n\n## Key Concepts\n- **Bundle Minification**: Reduces the size of JavaScript and CSS files by removing unnecessary characters like whitespace, comments, and shorting variable names without changing their functionality. This speeds up download times.\n- **Tree Shaking**: A form of dead code elimination. It removes unused code from the final bundle, especially effective with ES modules, further reducing bundle size.\n- **Code Splitting**: Divides the application's code into smaller, on-demand chunks. This allows the browser to load only the necessary code for a given view or feature, improving initial load times.\n- **Cache Optimizations**: Uses techniques like content hashing (adding a hash of the file's content to its filename) to enable aggressive caching by browsers and CDNs. When content changes, the hash changes, invalidating the old cache and ensuring users get the latest version.\n- **Gzip Compression**: A data compression method that significantly reduces the size of text-based assets (HTML, CSS, JavaScript) before they are sent from the server to the client. The browser then decompresses them.\n- **Image Optimization**: Involves compressing images to reduce file size without significant loss of quality, and serving them in modern formats (like WebP) or at appropriate resolutions. This is critical as images often contribute most to page weight.\n- **Critical CSS**: Extracts and inlines the minimum CSS required for the 'above-the-fold' content (what's visible without scrolling) directly into the HTML. This allows the browser to render the initial view faster, preventing a flash of unstyled content (FOUC).\n- **Service Workers**: Scripts that run in the background, separate from the web page, enabling features like offline capabilities, push notifications, and advanced caching strategies. They act as a proxy between the browser and the network.\n- **CDN Usage (Content Delivery Network)**: A geographically distributed network of servers that caches static assets (images, CSS, JS) closer to users. This reduces latency and improves loading speeds by serving content from the nearest server.\n- **Error Monitoring**: Implementing production error logging and reporting tools to proactively identify and fix issues that users encounter, improving the application's reliability and stability.\n\nThese techniques collectively aim to reduce load times, improve interactivity, and enhance the overall performance and user experience of a web application.",
          "examples": [
            {
              "id": "example_minification_1",
              "title": "Minification Example",
              "code": "// Original JavaScript\nfunction calculateSum(a, b) {\n  // This function calculates the sum of two numbers\n  const result = a + b;\n  return result;\n}\n\n// Minified JavaScript\nfunction calculateSum(a,b){const result=a+b;return result;}",
              "explanation": "This example shows how minification removes whitespace, comments, and shortens variable names (though `result` here is too simple for a major change) to reduce file size without altering functionality.",
              "language": "javascript"
            },
            {
              "id": "example_gzip_1",
              "title": "Gzip Compression (Conceptual)",
              "code": "/* \n  Server-side configuration for Gzip (e.g., in Nginx)\n  \n  gzip on;\n  gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\n  gzip_comp_level 6;\n  gzip_min_length 1000;\n*/\n\n// Browser receives compressed content and decompresses it automatically.",
              "explanation": "While Gzip is a server-side configuration, this snippet conceptually shows how a server (like Nginx) is configured to compress specific text-based file types to reduce their transfer size.",
              "language": "nginx"
            }
          ],
          "relatedQuestions": [
            "question_deployment_checklist_1",
            "question_deployment_checklist_2",
            "question_deployment_checklist_3",
            "question_deployment_checklist_4",
            "question_deployment_checklist_5",
            "question_deployment_checklist_6",
            "question_deployment_checklist_7",
            "question_deployment_checklist_8",
            "question_deployment_checklist_9",
            "question_deployment_checklist_10",
            "question_deployment_checklist_11",
            "question_deployment_checklist_12"
          ],
          "relatedTasks": [
            "task_configure_webpack_optimization",
            "task_implement_service_worker_caching"
          ],
          "tags": [
            "performance",
            "deployment",
            "optimization",
            "build-process",
            "web-essentials"
          ],
          "technology": "Web Performance",
          "prerequisites": [
            "javascript_basics",
            "css_basics",
            "http_protocol"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "senior_frontend_dev",
            "devops_for_frontend"
          ]
        },
        {
          "id": "theory_frontend_performance_metrics",
          "title": "Frontend Performance Metrics: Core Web Vitals and Beyond",
          "content": "Understanding and measuring frontend performance is crucial for delivering a good user experience. Key metrics provide insights into how quickly content loads, becomes interactive, and maintains visual stability.\n\n## Core Web Vitals\nCore Web Vitals are a set of standardized metrics from Google that measure real-world user experience for loading performance, interactivity, and visual stability. They are significant because they are used as ranking signals by Google Search.\n\n-   **LCP (Largest Contentful Paint)**:\n    -   **What it measures**: Loading performance. Specifically, it reports the render time of the largest image or text block visible within the viewport. This is often perceived as the main content load.\n    -   **Good threshold**: Within 2.5 seconds of when the page first starts loading.\n    -   **Impact**: A low LCP indicates that users see the primary content of the page quickly, leading to a better first impression.\n\n-   **FID (First Input Delay)**:\n    -   **What it measures**: Interactivity. It quantifies the time from when a user first interacts with a page (e.g., clicks a button, taps a link) to the time when the browser is actually able to begin processing event handlers in response to that interaction. High FID usually indicates a busy main thread.\n    -   **Good threshold**: 100 milliseconds or less.\n    -   **Impact**: A low FID means the page responds quickly to user actions, leading to a smoother and more responsive experience.\n\n-   **CLS (Cumulative Layout Shift)**:\n    -   **What it measures**: Visual stability. It quantifies the amount of unexpected layout shift of visual page content. An unexpected layout shift occurs when a visible element changes its position from one rendered frame to the next. For example, text moving down because an image loads above it.\n    -   **Good threshold**: 0.1 or less.\n    -   **Impact**: A low CLS score ensures a stable visual experience, preventing users from clicking the wrong element or losing their place while reading.\n\n## Additional Metrics\nBeyond Core Web Vitals, other metrics provide more granular insights into the loading process:\n\n-   **TTFB (Time to First Byte)**:\n    -   **What it measures**: Server response time. It's the time it takes for a user's browser to receive the very first byte of content from the server after making an HTTP request. It includes DNS lookup, TCP connection, and server processing.\n    -   **Impact**: A high TTFB can indicate server-side performance issues or network latency.\n\n-   **FCP (First Contentful Paint)**:\n    -   **What it measures**: When the first bit of content (text, image, non-white canvas, SVG) is painted to the screen. It signifies the first visual feedback to the user that the page is loading.\n    -   **Impact**: A low FCP provides early visual reassurance to users that the page is loading.\n\n-   **TTI (Time to Interactive)**:\n    -   **What it measures**: When the page is fully interactive. This is the point at which the layout is stable, key web fonts are visible, and the main thread is idle enough to handle user input reliably.\n    -   **Impact**: A low TTI means users can quickly and reliably interact with the page, avoiding frustrating delays or unresponsive UIs.",
          "examples": [],
          "relatedQuestions": [
            "question_performance_metrics_1",
            "question_performance_metrics_2",
            "question_performance_metrics_3",
            "question_performance_metrics_4",
            "question_performance_metrics_5",
            "question_performance_metrics_6",
            "question_performance_metrics_7",
            "question_performance_metrics_8",
            "question_performance_metrics_9",
            "question_performance_metrics_10",
            "question_performance_metrics_11"
          ],
          "relatedTasks": [
            "task_analyze_and_improve_lcp",
            "task_debug_and_fix_cls"
          ],
          "tags": [
            "performance",
            "metrics",
            "core-web-vitals",
            "user-experience",
            "seo"
          ],
          "technology": "Web Performance",
          "prerequisites": [
            "http_protocol",
            "browser_rendering_pipeline"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "web_performance_engineer",
            "frontend_architect"
          ]
        },
        {
          "id": "theory_performance_optimization_techniques",
          "title": "Frontend Performance Optimization Techniques: Code Splitting and Lazy Loading",
          "content": "Efficient loading of web applications is paramount for user satisfaction. Code splitting and lazy loading are powerful techniques to achieve this by only loading what's immediately necessary.\n\n## Code Splitting\nCode splitting is a technique supported by bundlers like Webpack, Rollup, or Parcel, that allows you to split your code into various bundles which can then be loaded on demand or in parallel. This can drastically improve the load time of your application, especially for large single-page applications (SPAs), as the initial bundle size is reduced. Instead of loading one monolithic JavaScript file, the browser only downloads the parts of the application needed for the current view.\n\n## React.lazy and Suspense\n`React.lazy` is a built-in React function that enables component-level code splitting. It lets you render a dynamic import as a regular React component. This means the component's code is loaded only when it's first rendered, not upfront with the initial bundle.\n\n`Suspense` is a React component that allows you to \"wait\" for some code to load and declaratively specify a loading indicator (fallback UI) while waiting. It's designed to work hand-in-hand with `React.lazy` to handle the asynchronous loading of components.\n\n### Important Notes for `React.lazy` and `Suspense`:\n-   `React.lazy` takes a function that must call a dynamic `import()` statement. This `import()` returns a Promise that resolves to a module.\n-   The Promise returned by the dynamic import must resolve to a module with a `default` export containing a React component.\n-   A lazy component (created with `React.lazy`) must always be rendered inside a `Suspense` component. The `Suspense` component provides a `fallback` prop, which is a React element that will be rendered while the lazy component is loading.\n-   Currently, `React.lazy` and `Suspense` are primarily client-side features. They are not yet available for server-side rendering (SSR) without additional workarounds or libraries (e.g., `loadable-components`). For SSR, you often need a different approach for code splitting that can pre-render the entire app.\n\n## Code Splitting with React Router\nCode splitting is particularly effective when combined with routing libraries like React Router. Instead of loading all route components upfront, you can lazy-load components for specific routes. This means the code for a particular route is only fetched when the user navigates to it, improving initial load times for the application's entry point.\n\nThis approach typically involves using `React.lazy` for each route component and wrapping the routes in a `Suspense` component.",
          "examples": [
            {
              "id": "example_dynamic_import_1",
              "title": "Basic Dynamic Import",
              "code": "// module.js\nexport function sayHello() {\n  console.log('Hello from dynamically loaded module!');\n}\n\n// main.js\ndocument.getElementById('loadButton').addEventListener('click', () => {\n  import('./module.js')\n    .then(module => {\n      module.sayHello();\n    })\n    .catch(error => {\n      console.error('Module loading failed:', error);\n    });\n});",
              "explanation": "This example demonstrates a basic dynamic import. The `module.js` code is not loaded until the button is clicked, showcasing on-demand loading.",
              "language": "javascript"
            },
            {
              "id": "example_react_lazy_suspense_1",
              "title": "React.lazy and Suspense",
              "code": "import React, { Suspense, lazy } from 'react';\n\nconst OtherComponent = lazy(() => import('./OtherComponent'));\n\nfunction MyComponent() {\n  return (\n    <div>\n      <h1>Welcome</h1>\n      <Suspense fallback={<div>Loading OtherComponent...</div>}>\n        <OtherComponent />\n      </Suspense>\n    </div>\n  );\n}\n\nexport default MyComponent;",
              "explanation": "This code shows how `React.lazy` is used to define `OtherComponent` so its bundle is loaded only when `MyComponent` attempts to render it. `Suspense` provides a `Loading...` fallback during the async load.",
              "language": "typescript"
            },
            {
              "id": "example_react_router_lazy_1",
              "title": "Code Splitting with React Router",
              "code": "import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';\nimport React, { Suspense, lazy } from 'react';\n\n// Use lazy loading for route components\nconst Home = lazy(() => import('./routes/Home'));\nconst About = lazy(() => import('./routes/About'));\nconst Contact = lazy(() => import('./routes/Contact'));\n\nfunction App() {\n  return (\n    <Router>\n      <Suspense fallback={<div>Loading Page...</div>}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/about\" element={<About />} />\n          <Route path=\"/contact\" element={<Contact />} />\n        </Routes>\n      </Suspense>\n    </Router>\n  );\n}\n\nexport default App;",
              "explanation": "This example demonstrates how to implement code splitting with React Router. Each route's component (`Home`, `About`, `Contact`) is lazy-loaded. The `Suspense` component wraps the `Routes` to provide a loading fallback while the specific route's component chunk is being fetched.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_optimization_techniques_1",
            "question_optimization_techniques_2",
            "question_optimization_techniques_3",
            "question_optimization_techniques_4",
            "question_optimization_techniques_5",
            "question_optimization_techniques_6",
            "question_optimization_techniques_7",
            "question_optimization_techniques_8"
          ],
          "relatedTasks": [
            "task_implement_react_lazy_suspense",
            "task_code_splitting_react_router"
          ],
          "tags": [
            "performance",
            "optimization",
            "react",
            "code-splitting",
            "lazy-loading",
            "webpack"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "es6_modules",
            "promises",
            "webpack_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_developer",
            "frontend_architect"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_deployment_checklist_1",
          "topic": "Bundle Minification",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary goal of bundle minification in frontend deployment?",
          "answer": "To reduce the file size of JavaScript and CSS assets by removing unnecessary characters, leading to faster download times.",
          "analysisPoints": [
            "Minification removes whitespace, comments, and often renames variables.",
            "It focuses on byte-size reduction for faster network transfer.",
            "It does not change the functionality of the code."
          ],
          "keyConcepts": [
            "minification",
            "bundle size",
            "load time"
          ],
          "evaluationCriteria": [
            "Ability to define minification's purpose"
          ],
          "example": "",
          "tags": [
            "minification",
            "deployment",
            "optimization"
          ],
          "prerequisites": [
            "web_performance_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_deployment_checklist_2",
          "topic": "Tree Shaking",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following best describes 'tree shaking' in the context of frontend optimization?\n\n```javascript\n// utils.js\nexport function add(a, b) { return a + b; }\nexport function subtract(a, b) { return a - b; }\n\n// main.js\nimport { add } from './utils';\nconsole.log(add(1, 2));\n// The 'subtract' function is never used.\n```",
          "answer": "Removing unused code from the final JavaScript bundle during the build process, like the `subtract` function in the example.",
          "options": [
            "Compressing image assets to reduce their file size.",
            "Breaking down a large JavaScript file into smaller, loadable chunks.",
            "Removing unused code from the final JavaScript bundle during the build process, like the `subtract` function in the example.",
            "Optimizing the order of CSS rules for faster rendering."
          ],
          "analysisPoints": [
            "Tree shaking is a form of dead code elimination.",
            "It relies on the static analysis of ES Modules.",
            "Its primary benefit is reducing bundle size and thus load time."
          ],
          "keyConcepts": [
            "tree shaking",
            "dead code elimination",
            "bundle size",
            "ES modules"
          ],
          "evaluationCriteria": [
            "Understanding of tree shaking mechanism.",
            "Ability to differentiate it from other optimization techniques."
          ],
          "example": "Tree shaking works by analyzing import/export statements. If a module exports multiple functions but only one is imported and used, the unused functions are 'shaken out' of the final bundle, reducing its size.",
          "tags": [
            "tree-shaking",
            "optimization",
            "webpack",
            "bundle-size"
          ],
          "prerequisites": [
            "es6_modules",
            "javascript_bundlers"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_deployment_checklist_3",
          "topic": "Code Splitting",
          "level": "medium",
          "type": "open",
          "question": "Explain the concept of code splitting and how it benefits initial page load performance. Provide a conceptual example of where you might apply it.",
          "answer": "Code splitting is a technique that divides your application's code into smaller, manageable chunks that can be loaded on demand or in parallel. This means the browser doesn't have to download the entire application's JavaScript bundle upfront. Instead, it only downloads the code necessary for the initial view, significantly reducing the initial payload and improving the time to interactive (TTI).\n\n**Benefit for initial page load**: By reducing the size of the initial JavaScript bundle, the browser can parse, compile, and execute less code, making the page interactive much faster.\n\n**Conceptual Example**: In a large single-page application (SPA) with multiple routes (e.g., `/home`, `/dashboard`, `/admin`), you could apply code splitting to load the `Dashboard` and `Admin` components only when the user navigates to those specific routes, rather than loading them when the application first starts. This keeps the initial bundle for the `/home` route small.",
          "analysisPoints": [
            "Definition of code splitting.",
            "Direct link between reduced initial bundle size and improved load performance.",
            "Ability to provide a relevant, practical example.",
            "Mention of 'on-demand' loading."
          ],
          "keyConcepts": [
            "code splitting",
            "initial load time",
            "bundle size",
            "on-demand loading"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of explanation.",
            "Relevance of the example.",
            "Understanding of the performance impact."
          ],
          "example": "",
          "tags": [
            "code-splitting",
            "performance",
            "optimization",
            "spa"
          ],
          "prerequisites": [
            "javascript_bundlers",
            "web_performance_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_deployment_checklist_4",
          "topic": "Cache Optimizations",
          "level": "easy",
          "type": "flashcard",
          "question": "How does 'content hashing' improve cache optimization?",
          "answer": "By adding a hash of the file's content to its filename (e.g., `bundle.f71b2a.js`), browsers can aggressively cache the file. When the file content changes, its hash changes, leading to a new filename that bypasses the old cache, ensuring users always get the latest version.",
          "analysisPoints": [
            "Content hashing creates unique filenames for unique content.",
            "Enables long-term caching headers for static assets.",
            "Ensures cache invalidation when content updates."
          ],
          "keyConcepts": [
            "caching",
            "content hashing",
            "cache invalidation",
            "browser cache"
          ],
          "evaluationCriteria": [
            "Understanding of content hashing and its role in caching"
          ],
          "example": "",
          "tags": [
            "caching",
            "optimization",
            "deployment"
          ],
          "prerequisites": [
            "http_headers"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_deployment_checklist_5",
          "topic": "Gzip Compression",
          "level": "easy",
          "type": "mcq",
          "question": "Gzip compression is most effective for which type of web assets?",
          "answer": "Text-based assets like HTML, CSS, and JavaScript files.",
          "options": [
            "Image files (JPEG, PNG)",
            "Video files (MP4, WebM)",
            "Binary files (Executables, PDFs)",
            "Text-based assets like HTML, CSS, and JavaScript files."
          ],
          "analysisPoints": [
            "Gzip works by finding repetitive patterns in text.",
            "Binary files (like images/videos) are often already compressed or have high entropy, so Gzip offers minimal benefit."
          ],
          "keyConcepts": [
            "gzip",
            "compression",
            "file types",
            "network transfer"
          ],
          "evaluationCriteria": [
            "Knowledge of Gzip's effectiveness.",
            "Understanding of what types of data compress well."
          ],
          "example": "",
          "tags": [
            "gzip",
            "compression",
            "performance"
          ],
          "prerequisites": [
            "http_protocol"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_deployment_checklist_6",
          "topic": "Image Optimization",
          "level": "medium",
          "type": "open",
          "question": "What are two common strategies for image optimization in frontend development, and why are they important for performance?",
          "answer": "1.  **Compression and Modern Formats**: Compressing images (e.g., using tools to reduce quality slightly or remove metadata) and serving them in modern formats like WebP significantly reduces file size. This is important because images often contribute the most to a page's total weight, directly impacting download times and bandwidth usage.\n2.  **Responsive Images/Lazy Loading**: Serving images at appropriate resolutions for different screen sizes (using `srcset`, `sizes`, or picture element) prevents downloading unnecessarily large images on smaller devices. Lazy loading defers the loading of images until they are in or near the viewport. Both are important because they reduce the initial page load time and conserve bandwidth, improving overall page speed and user experience.",
          "analysisPoints": [
            "Identify at least two distinct strategies.",
            "Explain the 'why' (performance benefit) for each strategy.",
            "Mention common tools or techniques (WebP, srcset, lazy loading)."
          ],
          "keyConcepts": [
            "image optimization",
            "web-performance",
            "compression",
            "responsive images",
            "lazy loading",
            "WebP"
          ],
          "evaluationCriteria": [
            "Ability to identify effective strategies.",
            "Clear explanation of performance benefits.",
            "Practical understanding of implementation."
          ],
          "example": "",
          "tags": [
            "image-optimization",
            "performance",
            "responsive-design",
            "lazy-loading"
          ],
          "prerequisites": [
            "html_images",
            "css_media_queries"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_deployment_checklist_7",
          "topic": "Critical CSS",
          "level": "medium",
          "type": "flashcard",
          "question": "What is 'Critical CSS' and why is it beneficial for initial rendering?",
          "answer": "Critical CSS is the minimum amount of CSS required to style the 'above-the-fold' content (what's immediately visible in the viewport without scrolling). It is inlined directly into the HTML `<head>`. This is beneficial because the browser can render the essential content without waiting for the external CSS stylesheet to download and parse, preventing a 'flash of unstyled content' (FOUC) and improving perceived performance (FCP).",
          "analysisPoints": [
            "Definition of critical CSS (above-the-fold).",
            "Method of delivery (inlined).",
            "Direct performance benefit (faster FCP, no FOUC)."
          ],
          "keyConcepts": [
            "critical-css",
            "fouc",
            "fcp",
            "inlining",
            "render-blocking"
          ],
          "evaluationCriteria": [
            "Understanding of critical CSS and its impact"
          ],
          "example": "",
          "tags": [
            "css",
            "performance",
            "rendering",
            "optimization"
          ],
          "prerequisites": [
            "css_rendering",
            "browser_rendering_pipeline"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_deployment_checklist_8",
          "topic": "Service Workers",
          "level": "medium",
          "type": "open",
          "question": "Describe the main role of a Service Worker in a web application. What specific deployment checklist items can they enable?",
          "answer": "A Service Worker is a JavaScript file that runs in the background, separate from the main browser thread. It acts as a programmatic proxy between the web application, the browser, and the network. Its main role is to intercept network requests, cache resources, and serve content from the cache, enabling offline capabilities and more robust caching strategies.\n\nService Workers directly enable:\n1.  **Offline capabilities**: By caching static assets and even dynamic content, they allow the application to function even when the user is offline.\n2.  **Advanced Cache optimizations**: They provide fine-grained control over caching, allowing strategies like 'cache first, then network', 'network first, then cache', or 'stale-while-revalidate'.\n3.  **Push notifications**: They can receive push messages from a server and display notifications to the user, even when the browser is closed.\n4.  **Background synchronization**: They can defer actions until the user has stable connectivity.",
          "analysisPoints": [
            "Accurate definition of a service worker's role (proxy, background thread).",
            "Identification of offline capabilities as a primary feature.",
            "Mention of advanced caching, push notifications, or background sync."
          ],
          "keyConcepts": [
            "service worker",
            "offline-first",
            "caching-strategies",
            "push-notifications",
            "PWA"
          ],
          "evaluationCriteria": [
            "Understanding of service worker architecture.",
            "Ability to list key features it enables."
          ],
          "example": "",
          "tags": [
            "service-worker",
            "pwa",
            "caching",
            "offline",
            "deployment"
          ],
          "prerequisites": [
            "javascript_async",
            "http_protocol"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_deployment_checklist_9",
          "topic": "CDN Usage",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a CDN and how does it improve website performance?",
          "answer": "A CDN (Content Delivery Network) is a geographically distributed network of servers. It improves website performance by caching static assets (like images, CSS, JavaScript) on servers located closer to the end-user, reducing latency and accelerating content delivery.",
          "analysisPoints": [
            "Definition of CDN (distributed network).",
            "Explanation of how it reduces latency and improves speed.",
            "Mention of static assets."
          ],
          "keyConcepts": [
            "cdn",
            "latency",
            "static-assets",
            "caching",
            "geographical distribution"
          ],
          "evaluationCriteria": [
            "Basic understanding of CDN's role and benefits"
          ],
          "example": "",
          "tags": [
            "cdn",
            "performance",
            "network",
            "deployment"
          ],
          "prerequisites": [
            "http_protocol"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_deployment_checklist_10",
          "topic": "Error Monitoring",
          "level": "easy",
          "type": "flashcard",
          "question": "Why is 'Error Monitoring' an important part of the deployment checklist for production applications?",
          "answer": "Error monitoring allows developers to proactively identify, track, and resolve issues that users encounter in a production environment. This ensures application stability, improves user experience, and helps maintain the overall health of the system by preventing widespread failures.",
          "analysisPoints": [
            "Proactive issue identification.",
            "Impact on user experience and stability.",
            "Importance for maintenance and reliability."
          ],
          "keyConcepts": [
            "error-monitoring",
            "production",
            "debugging",
            "reliability",
            "user-experience"
          ],
          "evaluationCriteria": [
            "Understanding the value of error monitoring"
          ],
          "example": "",
          "tags": [
            "error-handling",
            "monitoring",
            "production",
            "deployment"
          ],
          "prerequisites": [
            "javascript_error_handling"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_deployment_checklist_11",
          "topic": "Deployment Checklist Overview",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following optimization techniques is primarily aimed at reducing the **initial** download size of your JavaScript bundle for a large application?\n\nI. Image Optimization\nII. Gzip Compression\nIII. Code Splitting\nIV. Critical CSS Inlining",
          "answer": "III. Code Splitting",
          "options": [
            "I and II only",
            "III only",
            "II and III only",
            "I, II, III, and IV"
          ],
          "analysisPoints": [
            "Code splitting directly reduces the *initial* JS bundle size by deferring loading.",
            "Gzip compression reduces the *transfer size* of the bundle but the *uncompressed* size is still the same. It's about network efficiency, not initial parsing/execution size reduction.",
            "Image optimization targets image assets, not specifically JS bundle size.",
            "Critical CSS targets CSS for above-the-fold content, not JS bundle size."
          ],
          "keyConcepts": [
            "code-splitting",
            "bundle-size",
            "initial-load",
            "optimization"
          ],
          "evaluationCriteria": [
            "Ability to distinguish between different optimization goals.",
            "Understanding of the direct impact of each technique."
          ],
          "example": "While all options contribute to overall performance, code splitting is the most direct way to reduce the *logical* size of the initial JavaScript bundle that needs to be parsed and executed upfront.",
          "tags": [
            "optimization",
            "code-splitting",
            "bundle-size",
            "performance"
          ],
          "prerequisites": [
            "web_performance_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_deployment_checklist_12",
          "topic": "Deployment Checklist Combined",
          "level": "hard",
          "type": "open",
          "question": "Imagine you're auditing a new frontend application before its first production deployment. You notice that the initial load time is very high (over 5 seconds) and users frequently report 'jumps' in content while browsing. What three items from the deployment checklist would you prioritize addressing first, and why?",
          "answer": "Given a high initial load time (over 5 seconds) and content 'jumps' (indicating layout shifts), I would prioritize the following three items:\n\n1.  **Code Splitting**: High initial load time often means a large JavaScript bundle. Code splitting can drastically reduce the initial payload by only loading necessary code for the first view, improving Time to Interactive and overall load speed.\n2.  **Image Optimization**: Images are frequently the largest contributors to page weight. Unoptimized images can significantly increase download times. Compressing and serving optimized images (e.g., WebP, responsive images) would directly tackle the load time issue.\n3.  **Critical CSS / Cumulative Layout Shift (CLS) Mitigation**: Content 'jumps' are a direct symptom of poor visual stability, typically measured by CLS. Inlining critical CSS ensures the styling for above-the-fold content loads immediately, preventing FOUC and layout shifts as other stylesheets or content load later. Also, ensuring images and embeds have explicit dimensions can prevent CLS. Addressing CLS would directly fix the 'jumps' reported by users.",
          "analysisPoints": [
            "Correctly diagnose the root causes based on symptoms.",
            "Prioritize solutions that directly address the most critical symptoms.",
            "Provide clear justifications for each chosen priority.",
            "Connect the symptoms (slow load, jumps) to specific checklist items (code splitting, image optimization, critical CSS/CLS)."
          ],
          "keyConcepts": [
            "performance-auditing",
            "troubleshooting",
            "code-splitting",
            "image-optimization",
            "critical-css",
            "cls"
          ],
          "evaluationCriteria": [
            "Problem-solving ability.",
            "Prioritization skills.",
            "Depth of understanding of optimization techniques and their impact."
          ],
          "example": "",
          "tags": [
            "deployment",
            "performance",
            "troubleshooting",
            "prioritization",
            "cls",
            "load-time"
          ],
          "prerequisites": [
            "all_deployment_checklist_items",
            "frontend_performance_metrics"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_performance_metrics_1",
          "topic": "Core Web Vitals",
          "level": "easy",
          "type": "flashcard",
          "question": "Name the three Core Web Vitals.",
          "answer": "Largest Contentful Paint (LCP), First Input Delay (FID), and Cumulative Layout Shift (CLS).",
          "analysisPoints": [
            "Correctly recall the three metrics."
          ],
          "keyConcepts": [
            "core-web-vitals",
            "lcp",
            "fid",
            "cls"
          ],
          "evaluationCriteria": [
            "Basic recall of core web vitals"
          ],
          "example": "",
          "tags": [
            "performance",
            "metrics",
            "core-web-vitals"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_performance_metrics_2",
          "topic": "LCP (Largest Contentful Paint)",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following describes what LCP (Largest Contentful Paint) measures?\n\n```html\n<body>\n  <header>...</header>\n  <main>\n    <h1>Welcome to our site!</h1>\n    <img src=\"hero.jpg\" alt=\"Hero Image\" class=\"main-hero-image\" />\n    <p>Some introductory text.</p>\n  </main>\n</body>\n```\n\nAssuming `hero.jpg` is a large image visible in the viewport.",
          "answer": "The render time of the largest image or text block visible within the viewport, often representing the main content load.",
          "options": [
            "The time it takes for the first byte of the page to arrive from the server.",
            "The time from when a user first interacts with a page to when the browser processes that interaction.",
            "The cumulative score of unexpected layout shifts during the page's lifecycle.",
            "The render time of the largest image or text block visible within the viewport, often representing the main content load."
          ],
          "analysisPoints": [
            "LCP is about the largest *contentful* element.",
            "It focuses on *loading performance* and *perceived speed*.",
            "The example shows a common LCP element (hero image or main heading)."
          ],
          "keyConcepts": [
            "lcp",
            "loading-performance",
            "perceived-speed",
            "viewport",
            "contentful"
          ],
          "evaluationCriteria": [
            "Accurate definition of LCP.",
            "Distinction from other metrics."
          ],
          "example": "In the provided HTML, if `hero.jpg` is the largest element visible in the viewport when the page loads, its render time would be the LCP. Optimizing this image (size, format, preloading) is key to improving LCP.",
          "tags": [
            "lcp",
            "core-web-vitals",
            "performance",
            "metrics"
          ],
          "prerequisites": [
            "web_rendering_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_performance_metrics_3",
          "topic": "FID (First Input Delay)",
          "level": "medium",
          "type": "open",
          "question": "A user complains that when they click a button on your website, there's a noticeable delay before anything happens. Which Core Web Vital is most directly impacted by this issue, and what might be a common cause?",
          "answer": "The Core Web Vital most directly impacted is **FID (First Input Delay)**. FID measures the time from when a user first interacts with a page (e.g., clicking a button) to the time when the browser is actually able to begin processing event handlers in response to that interaction.\n\nA common cause for a high FID is a **busy main thread**. If the main thread is occupied with long-running JavaScript tasks (like parsing, compiling, or executing a large script), it cannot immediately respond to user input. This leads to input delay and a unresponsive user experience.",
          "analysisPoints": [
            "Correctly identify FID as the affected metric.",
            "Provide a clear explanation of what FID measures.",
            "Identify 'busy main thread' or 'long JavaScript tasks' as the primary cause."
          ],
          "keyConcepts": [
            "fid",
            "interactivity",
            "main-thread",
            "long-tasks",
            "user-experience"
          ],
          "evaluationCriteria": [
            "Diagnostic ability for performance issues.",
            "Understanding of FID's measurement and common causes."
          ],
          "example": "",
          "tags": [
            "fid",
            "core-web-vitals",
            "performance",
            "interactivity"
          ],
          "prerequisites": [
            "javascript_execution",
            "browser_rendering_pipeline"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_performance_metrics_4",
          "topic": "CLS (Cumulative Layout Shift)",
          "level": "medium",
          "type": "mcq",
          "question": "Which scenario is most likely to result in a high CLS (Cumulative Layout Shift) score?",
          "answer": "An image loading dynamically without predefined dimensions, causing text below it to suddenly jump down.",
          "options": [
            "A large JavaScript bundle delaying the initial render of the page.",
            "A slow server response time delaying the delivery of the first byte of content.",
            "An image loading dynamically without predefined dimensions, causing text below it to suddenly jump down.",
            "The browser taking a long time to parse and execute initial JavaScript before the page becomes interactive."
          ],
          "analysisPoints": [
            "CLS specifically measures *unexpected visual shifts*.",
            "Dynamic content without reserved space is a classic cause of CLS.",
            "Distinguish CLS from loading or interactivity metrics."
          ],
          "keyConcepts": [
            "cls",
            "visual-stability",
            "layout-shifts",
            "dynamic-content",
            "image-dimensions"
          ],
          "evaluationCriteria": [
            "Understanding of CLS measurement.",
            "Ability to identify common causes of layout shifts."
          ],
          "example": "When an image without `width` and `height` attributes loads, the browser initially allocates no space for it. Once the image loads, the browser has to reflow the layout, causing content below it to shift, leading to a poor CLS score.",
          "tags": [
            "cls",
            "core-web-vitals",
            "performance",
            "layout"
          ],
          "prerequisites": [
            "css_box_model",
            "html_images"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_performance_metrics_5",
          "topic": "TTFB (Time to First Byte)",
          "level": "easy",
          "type": "flashcard",
          "question": "What does TTFB (Time to First Byte) measure, and what does a high TTFB typically indicate?",
          "answer": "TTFB measures the time it takes for a user's browser to receive the first byte of content from the server. A high TTFB typically indicates server-side performance issues, slow database queries, or high network latency between the user and the server.",
          "analysisPoints": [
            "Definition of TTFB (server response).",
            "Common causes of high TTFB."
          ],
          "keyConcepts": [
            "ttfb",
            "server-response",
            "latency",
            "backend-performance"
          ],
          "evaluationCriteria": [
            "Understanding of TTFB and its implications"
          ],
          "example": "",
          "tags": [
            "ttfb",
            "performance",
            "metrics",
            "server-side"
          ],
          "prerequisites": [
            "http_protocol"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_performance_metrics_6",
          "topic": "FCP (First Contentful Paint)",
          "level": "easy",
          "type": "flashcard",
          "question": "When does FCP (First Contentful Paint) occur?",
          "answer": "FCP occurs when the first content (text, image, non-white canvas, or SVG) is painted to the screen, providing the user with the first visual feedback that the page is loading.",
          "analysisPoints": [
            "Definition of FCP (first visual content).",
            "Importance of early visual feedback."
          ],
          "keyConcepts": [
            "fcp",
            "visual-feedback",
            "loading-performance"
          ],
          "evaluationCriteria": [
            "Basic understanding of FCP"
          ],
          "example": "",
          "tags": [
            "fcp",
            "performance",
            "metrics"
          ],
          "prerequisites": [
            "web_rendering_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_performance_metrics_7",
          "topic": "TTI (Time to Interactive)",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the significance of TTI (Time to Interactive) in terms of user experience?",
          "answer": "TTI measures when the page is fully interactive, meaning the layout is stable, key web fonts are visible, and the main thread is idle enough to respond reliably to user input. Its significance lies in ensuring users can quickly and reliably interact with the page without experiencing frustrating delays or unresponsive UIs, leading to a much better user experience.",
          "analysisPoints": [
            "Definition of TTI (fully interactive).",
            "Direct link to user experience (responsiveness, no delays)."
          ],
          "keyConcepts": [
            "tti",
            "interactivity",
            "user-experience",
            "main-thread-idle"
          ],
          "evaluationCriteria": [
            "Understanding of TTI's importance for user interaction"
          ],
          "example": "",
          "tags": [
            "tti",
            "performance",
            "metrics",
            "interactivity"
          ],
          "prerequisites": [
            "javascript_execution"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_performance_metrics_8",
          "topic": "Metrics Comparison",
          "level": "hard",
          "type": "open",
          "question": "Distinguish between FCP (First Contentful Paint) and LCP (Largest Contentful Paint). Why are both important, even though LCP is a Core Web Vital?",
          "answer": "**FCP (First Contentful Paint)** measures when the *very first* piece of content (text, image, etc.) appears on the screen. It's the initial visual feedback that something is happening.\n\n**LCP (Largest Contentful Paint)** measures when the *largest content element* (typically a hero image or main heading) becomes visible within the viewport. This is often perceived by users as the main content loading.\n\nBoth are important because:\n-   **FCP** provides crucial early visual reassurance to the user that the page is loading and not broken. A quick FCP prevents users from abandoning the page prematurely.\n-   **LCP**, being a Core Web Vital, is a stronger indicator of perceived load speed of the *primary content*. It's critical for user satisfaction because it focuses on what matters most to the user on that specific page. Google uses LCP for SEO ranking, making it strategically important.\n\nWhile FCP indicates the start of rendering, LCP indicates that the main valuable content is ready, and both contribute to a holistic understanding of the page's loading experience.",
          "analysisPoints": [
            "Clear distinction between FCP and LCP.",
            "Explanation of what each measures and represents.",
            "Justification for the importance of both, including LCP's Core Web Vital status."
          ],
          "keyConcepts": [
            "fcp",
            "lcp",
            "core-web-vitals",
            "perceived-performance",
            "loading-performance",
            "seo"
          ],
          "evaluationCriteria": [
            "Ability to differentiate nuanced metrics.",
            "Understanding of their individual and combined importance.",
            "Knowledge of their impact on user experience and SEO."
          ],
          "example": "",
          "tags": [
            "performance",
            "metrics",
            "fcp",
            "lcp",
            "core-web-vitals"
          ],
          "prerequisites": [
            "web_rendering_pipeline"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_performance_metrics_9",
          "topic": "Metrics & Optimization",
          "level": "hard",
          "type": "open",
          "question": "For a React application, discuss how code splitting (using `React.lazy`) can positively impact FID and TTI. Are there any potential downsides?",
          "answer": "Code splitting using `React.lazy` can significantly improve FID and TTI in a React application:\n\n**Impact on FID (First Input Delay)**:\n-   By splitting the code into smaller, on-demand chunks, the initial JavaScript bundle size is reduced. This means the browser has less code to download, parse, and execute during the initial load.\n-   A smaller initial script means the main thread becomes idle sooner, as it spends less time processing the initial bundle. This allows it to respond to user interactions (like clicks or scrolls) much more quickly, thus lowering FID.\n\n**Impact on TTI (Time to Interactive)**:\n-   Similar to FID, a reduced initial JavaScript payload due to code splitting means the main thread is freed up earlier.\n-   The page reaches a state where it's reliably interactive faster because critical scripts are executed, and non-critical scripts are deferred, ensuring that the main thread is available to handle user input.\n\n**Potential Downsides**:\n-   **Increased Network Requests**: Instead of one large request, there might be multiple smaller requests for chunks. While parallelizable, this can introduce overhead if not managed well (e.g., too many small chunks).\n-   **Loading States/UX**: Introducing `Suspense` fallbacks means users might see 'Loading...' states as they navigate, which could be jarring if not handled smoothly.\n-   **Bundle Configuration Complexity**: Setting up optimal code splitting can be complex, especially with dynamic imports and ensuring correct chunking strategies in bundlers like Webpack.\n-   **SSR Limitations**: `React.lazy` and `Suspense` are primarily client-side. Implementing code splitting with Server-Side Rendering requires additional libraries or different approaches (e.g., `loadable-components`) to avoid hydration mismatches and ensure SEO friendliness.",
          "analysisPoints": [
            "Connect code splitting directly to reduced JS execution on the main thread.",
            "Explain how this impacts FID (responsiveness) and TTI (full interactivity).",
            "Identify and explain common downsides such as increased network requests, loading states, and SSR compatibility.",
            "Demonstrate a holistic understanding of the technique's pros and cons."
          ],
          "keyConcepts": [
            "code-splitting",
            "react.lazy",
            "suspense",
            "fid",
            "tti",
            "main-thread",
            "performance-tradeoffs",
            "ssr"
          ],
          "evaluationCriteria": [
            "Depth of technical understanding.",
            "Ability to analyze positive and negative impacts.",
            "Consideration of real-world implementation challenges."
          ],
          "example": "",
          "tags": [
            "performance",
            "react",
            "code-splitting",
            "fid",
            "tti",
            "optimization",
            "ssr"
          ],
          "prerequisites": [
            "react_performance",
            "javascript_execution_model"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_performance_metrics_10",
          "topic": "Core Web Vitals",
          "level": "medium",
          "type": "flashcard",
          "question": "Why are Core Web Vitals considered more important than other performance metrics for website owners?",
          "answer": "Core Web Vitals are considered more important because they are a standardized set of metrics directly reflecting real-world user experience across loading, interactivity, and visual stability. Crucially, Google uses them as part of its search ranking signals, meaning good Core Web Vitals can positively impact a site's SEO and visibility.",
          "analysisPoints": [
            "Standardized and user-centric.",
            "Direct link to Google SEO ranking.",
            "Reflects real-world user experience."
          ],
          "keyConcepts": [
            "core-web-vitals",
            "seo",
            "user-experience",
            "google-ranking"
          ],
          "evaluationCriteria": [
            "Understanding of strategic importance of Core Web Vitals"
          ],
          "example": "",
          "tags": [
            "core-web-vitals",
            "seo",
            "performance"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_performance_metrics_11",
          "topic": "Frontend Performance Metrics",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is an 'additional metric' and not part of the Core Web Vitals?",
          "answer": "TTFB (Time to First Byte)",
          "options": [
            "LCP (Largest Contentful Paint)",
            "FID (First Input Delay)",
            "TTFB (Time to First Byte)",
            "CLS (Cumulative Layout Shift)"
          ],
          "analysisPoints": [
            "Recall the specific three Core Web Vitals.",
            "Identify metrics outside of the Core Web Vitals set."
          ],
          "keyConcepts": [
            "core-web-vitals",
            "ttfb",
            "fcp",
            "tti"
          ],
          "evaluationCriteria": [
            "Ability to differentiate Core Web Vitals from other metrics"
          ],
          "example": "",
          "tags": [
            "performance",
            "metrics",
            "core-web-vitals"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_optimization_techniques_1",
          "topic": "Code Splitting",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of implementing code splitting?",
          "answer": "It reduces the initial bundle size, leading to faster initial page load times and improved Time to Interactive, as the browser only downloads necessary code.",
          "analysisPoints": [
            "Reduced initial bundle size.",
            "Faster load times.",
            "On-demand loading."
          ],
          "keyConcepts": [
            "code-splitting",
            "bundle-size",
            "initial-load",
            "tti"
          ],
          "evaluationCriteria": [
            "Understanding the core benefit of code splitting"
          ],
          "example": "",
          "tags": [
            "code-splitting",
            "performance",
            "optimization"
          ],
          "prerequisites": [
            "javascript_bundlers"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_optimization_techniques_2",
          "topic": "React.lazy",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React component:\n\n```typescript\nimport React, { Suspense, lazy } from 'react';\n\nconst MyLazyComponent = lazy(() => import('./MyLazyComponent'));\n\nfunction App() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        {/* A */}\n        <MyLazyComponent />\n        {/* B */}\n      </Suspense>\n    </div>\n  );\n}\n```\n\nWhen will the code for `MyLazyComponent` be fetched?",
          "answer": "When `MyLazyComponent` is first rendered in the component tree at point A.",
          "options": [
            "When the `App` component is first imported.",
            "When the `App` component is first rendered, regardless of `MyLazyComponent`'s presence.",
            "When `MyLazyComponent` is first rendered in the component tree at point A.",
            "After the entire `App` component tree has finished mounting and is interactive."
          ],
          "analysisPoints": [
            "`React.lazy` loads components *when they are rendered*.",
            "It's not eager loading; it's on-demand.",
            "The `import()` call is part of the `lazy` function's argument and is executed upon rendering."
          ],
          "keyConcepts": [
            "react.lazy",
            "lazy-loading",
            "dynamic-import",
            "react-component-lifecycle"
          ],
          "evaluationCriteria": [
            "Understanding of `React.lazy`'s loading mechanism.",
            "Knowledge of when dynamic imports are triggered."
          ],
          "example": "The key is that `lazy` only *defines* the component; the actual `import()` call (and thus code fetching) happens only when React tries to render `MyLazyComponent` for the first time.",
          "tags": [
            "react",
            "lazy-loading",
            "code-splitting",
            "performance"
          ],
          "prerequisites": [
            "react_basics",
            "dynamic_imports"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_optimization_techniques_3",
          "topic": "React.lazy and Suspense",
          "level": "medium",
          "type": "open",
          "question": "What is the purpose of the `Suspense` component when using `React.lazy`, and what happens if you omit it?",
          "answer": "The purpose of the `Suspense` component when using `React.lazy` is to gracefully handle the asynchronous loading of a lazy-loaded component. It allows you to display a fallback UI (e.g., a loading spinner or message) while the component's code is being fetched and processed.\n\nIf you omit the `Suspense` component when rendering a `React.lazy` component, React will throw an error, typically something like \"A component suspended while responding to an event. This will not be supported in a future version of React. Wrap the suspended component in a `<Suspense>` boundary.\" This is because `React.lazy` components `suspend` their rendering until their code is loaded, and React requires a `Suspense` boundary to catch and manage this suspension.",
          "analysisPoints": [
            "Define Suspense's role (fallback UI, async handling).",
            "Explain the consequence of omitting Suspense (error).",
            "Mention the `fallback` prop."
          ],
          "keyConcepts": [
            "react.lazy",
            "suspense",
            "fallback-ui",
            "asynchronous-loading",
            "error-handling-react"
          ],
          "evaluationCriteria": [
            "Understanding of `Suspense`'s function.",
            "Knowledge of error handling without `Suspense`."
          ],
          "example": "",
          "tags": [
            "react",
            "suspense",
            "lazy-loading",
            "error-handling",
            "ux"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_optimization_techniques_4",
          "topic": "React.lazy Limitations",
          "level": "medium",
          "type": "flashcard",
          "question": "What is a significant limitation of `React.lazy` and `Suspense` regarding server-side rendering (SSR)?",
          "answer": "Currently, `React.lazy` and `Suspense` are primarily client-side features and are not directly supported for server-side rendering without additional workarounds or libraries like `loadable-components`.",
          "analysisPoints": [
            "Identify SSR as a limitation.",
            "Mention need for external solutions."
          ],
          "keyConcepts": [
            "react.lazy",
            "suspense",
            "ssr",
            "limitations"
          ],
          "evaluationCriteria": [
            "Knowledge of SSR compatibility issues with `React.lazy`"
          ],
          "example": "",
          "tags": [
            "react",
            "ssr",
            "lazy-loading",
            "limitations"
          ],
          "prerequisites": [
            "ssr_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_optimization_techniques_5",
          "topic": "Dynamic Imports",
          "level": "easy",
          "type": "flashcard",
          "question": "What kind of statement must the function passed to `React.lazy` call?",
          "answer": "A dynamic `import()` statement.",
          "analysisPoints": [
            "Recall the specific syntax requirement for `React.lazy`."
          ],
          "keyConcepts": [
            "react.lazy",
            "dynamic-import",
            "syntax"
          ],
          "evaluationCriteria": [
            "Basic recall of `React.lazy` syntax"
          ],
          "example": "```javascript\nconst MyComponent = React.lazy(() => import('./MyComponent'));\n```",
          "tags": [
            "react",
            "dynamic-imports",
            "lazy-loading"
          ],
          "prerequisites": [
            "es6_modules"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_optimization_techniques_6",
          "topic": "Code Splitting with React Router",
          "level": "medium",
          "type": "code",
          "question": "You have a React application using `react-router-dom` with routes for `/home`, `/about`, and `/dashboard`. You want to implement code splitting so that the `Dashboard` component is only loaded when the user navigates to `/dashboard`.\n\nComplete the `App` component below to achieve this using `React.lazy` and `Suspense`.\n\n```typescript\nimport { BrowserRouter as Router, Route, Routes } from 'react-router-dom';\nimport React, { Suspense, lazy } from 'react';\n\nconst Home = lazy(() => import('./routes/Home'));\nconst About = lazy(() => import('./routes/About'));\n// TODO: Create a lazy-loaded Dashboard component\n// const Dashboard = ...\n\nfunction App() {\n  return (\n    <Router>\n      {/* TODO: Add Suspense boundary */}\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/about\" element={<About />} />\n          {/* TODO: Add Dashboard route */}\n        </Routes>\n      {/* TODO: Close Suspense boundary */}\n    </Router>\n  );\n}\n\nexport default App;\n```",
          "answer": "```typescript\nimport { BrowserRouter as Router, Route, Routes } from 'react-router-dom';\nimport React, { Suspense, lazy } from 'react';\n\nconst Home = lazy(() => import('./routes/Home'));\nconst About = lazy(() => import('./routes/About'));\nconst Dashboard = lazy(() => import('./routes/Dashboard'));\n\nfunction App() {\n  return (\n    <Router>\n      <Suspense fallback={<div>Loading Page...</div>}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/about\" element={<About />} />\n          <Route path=\"/dashboard\" element={<Dashboard />} />\n        </Routes>\n      </Suspense>\n    </Router>\n  );\n}\n\nexport default App;\n```",
          "analysisPoints": [
            "Correct use of `lazy` for the `Dashboard` component.",
            "Correct placement of the `Suspense` component wrapping the `Routes`.",
            "Correct `fallback` prop for `Suspense`.",
            "Proper use of `Route` element with the lazy component."
          ],
          "keyConcepts": [
            "react.lazy",
            "suspense",
            "react-router-dom",
            "code-splitting",
            "dynamic-imports"
          ],
          "evaluationCriteria": [
            "Ability to apply `React.lazy` and `Suspense` in a routing context.",
            "Correct React Router syntax for routes.",
            "Syntactic correctness and functionality."
          ],
          "example": "This solution correctly lazy-loads the `Dashboard` component, ensuring its code is only fetched when the user navigates to `/dashboard`. The `Suspense` boundary provides a smooth loading experience.",
          "tags": [
            "react",
            "react-router",
            "code-splitting",
            "lazy-loading",
            "coding-challenge"
          ],
          "prerequisites": [
            "react_basics",
            "react_router_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_optimization_techniques_7",
          "topic": "Code Splitting vs. Minification/Gzip",
          "level": "hard",
          "type": "open",
          "question": "While bundle minification and Gzip compression reduce file size, how does code splitting offer a distinct advantage for initial page load performance that these two techniques cannot fully achieve?",
          "answer": "Minification and Gzip compression primarily reduce the *transfer size* of the entire JavaScript bundle. They make the network download faster, but the browser still has to download *all* of the code, and then parse, compile, and execute it.\n\n**Code splitting's distinct advantage**: It reduces the *logical size* (and thus the *processing load*) of the initial JavaScript bundle. Instead of downloading and processing the entire application, code splitting allows the browser to download only the necessary code for the current view or feature. This directly translates to:\n\n1.  **Faster Parsing/Compilation/Execution**: Less JavaScript needs to be processed upfront, freeing up the main thread sooner.\n2.  **Improved Time to Interactive (TTI) and First Input Delay (FID)**: The page becomes interactive much quicker because critical paths are unblocked faster.\n3.  **Reduced Memory Usage**: Less code in memory at any given time.\n\nEssentially, while minification and Gzip optimize *how much* you send, code splitting optimizes *what* you send initially, deferring non-critical assets until they are actually needed.",
          "analysisPoints": [
            "Clearly explain what minification/Gzip do (reduce transfer size).",
            "Explain what code splitting does (reduces logical size, defers loading).",
            "Highlight the difference in impact on browser processing (parsing, compilation, execution).",
            "Connect to specific metrics like TTI/FID."
          ],
          "keyConcepts": [
            "code-splitting",
            "minification",
            "gzip",
            "initial-load",
            "bundle-size",
            "tti",
            "fid",
            "browser-parsing"
          ],
          "evaluationCriteria": [
            "In-depth understanding of different optimization techniques.",
            "Ability to compare and contrast their unique benefits.",
            "Strong grasp of browser rendering and execution processes."
          ],
          "example": "",
          "tags": [
            "performance",
            "optimization",
            "code-splitting",
            "bundle-size",
            "browser-performance"
          ],
          "prerequisites": [
            "javascript_execution_model",
            "webpack_performance"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_optimization_techniques_8",
          "topic": "Code Splitting vs. Tree Shaking",
          "level": "medium",
          "type": "mcq",
          "question": "Both 'code splitting' and 'tree shaking' are techniques to reduce the final bundle size. What is the fundamental difference in *how* they achieve this reduction?",
          "answer": "Code splitting divides the bundle into smaller, separate chunks loaded on demand, while tree shaking eliminates unused code from within a bundle.",
          "options": [
            "Code splitting only works for React applications, while tree shaking is universal.",
            "Code splitting is a runtime optimization, while tree shaking is a build-time optimization.",
            "Code splitting divides the bundle into smaller, separate chunks loaded on demand, while tree shaking eliminates unused code from within a bundle.",
            "Tree shaking compresses the code, while code splitting encrypts it."
          ],
          "analysisPoints": [
            "Code splitting is about breaking up the bundle into multiple files/chunks.",
            "Tree shaking is about removing dead code from *within* a file/chunk.",
            "Both are build-time optimizations, but they address different aspects of bundle size."
          ],
          "keyConcepts": [
            "code-splitting",
            "tree-shaking",
            "bundle-size",
            "optimization-techniques"
          ],
          "evaluationCriteria": [
            "Ability to differentiate between related but distinct optimization techniques.",
            "Understanding their mechanisms."
          ],
          "example": "Imagine a large book. Tree shaking is like removing blank pages or unused chapters from the book. Code splitting is like dividing the book into multiple smaller volumes, so you only need to carry the volume you're currently reading.",
          "tags": [
            "code-splitting",
            "tree-shaking",
            "optimization",
            "bundle-size"
          ],
          "prerequisites": [
            "javascript_bundlers"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_configure_webpack_optimization",
          "title": "Configure Webpack for Production Optimization (Minification & Gzip Simulation)",
          "description": "\nAs a frontend engineer, you're tasked with optimizing a simple React application for production. Your goal is to configure a Webpack build process to achieve bundle minification and simulate Gzip compression benefits by analyzing the build output.\n\n**Requirements:**\n1.  **Minify JavaScript**: Ensure that the output JavaScript bundle is minified.\n2.  **Minify CSS**: Ensure that any output CSS is minified.\n3.  **Analyze Bundle Size**: Use a Webpack bundle analyzer to visualize and confirm the size reduction after minification. You don't need to actually serve compressed files, but observe the reported gzipped size in the analysis.\n4.  **Entry Point**: The application has a single JavaScript entry point.\n\n**Note**: You don't need to write the React app itself, just focus on the `webpack.config.js` and the analysis.",
          "difficulty": "medium",
          "startingCode": "const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  mode: 'development', // Change this to 'production' later\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react'],\n          },\n        },\n      },\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './public/index.html',\n    }),\n  ],\n  // TODO: Add optimization specific for production\n};\n\n// src/index.js (example content)\n// import React from 'react';\n// import ReactDOM from 'react-dom/client';\n// const App = () => <h1>Hello Webpack!</h1>;\n// const root = ReactDOM.createRoot(document.getElementById('root'));\n// root.render(<App />);\n\n// public/index.html (example content)\n// <!DOCTYPE html>\n// <html>\n// <head><title>Webpack App</title></head>\n// <body><div id=\"root\"></div><script src=\"bundle.js\"></script></body>\n// </html>\n",
          "solutionCode": "const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin');\nconst TerserPlugin = require('terser-webpack-plugin');\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  mode: 'production', // Set mode to production for built-in optimizations\n  entry: './src/index.js',\n  output: {\n    filename: '[name].[contenthash].js', // Use contenthash for cache busting\n    path: path.resolve(__dirname, 'dist'),\n    clean: true, // Clean the dist folder before each build\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react'],\n          },\n        },\n      },\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './public/index.html',\n    }),\n    new BundleAnalyzerPlugin({ analyzerMode: 'static', openAnalyzer: false }), // Generate a static report, don't open automatically\n  ],\n  optimization: {\n    minimize: true, // Enable minimization\n    minimizer: [\n      new TerserPlugin({ // For JavaScript minification (default in production mode, but explicit for clarity)\n        terserOptions: {\n          format: {\n            comments: false,\n          },\n        },\n        extractComments: false,\n      }),\n      new CssMinimizerPlugin(), // For CSS minification\n    ],\n    // You could also add splitChunks for code splitting, but not required by this task.\n  },\n};\n",
          "testCases": [
            "Run `webpack --mode production` to build the project.",
            "Verify `dist/` directory contains minified JS and CSS (if any CSS asset is added to project).",
            "Check that `bundle-analyzer-report.html` is generated in `dist/` and shows reduced sizes (including Gzip/Brotli estimations).",
            "Observe that the output JavaScript file has a content hash in its name (e.g., `main.f71b2a.js`)."
          ],
          "hints": [
            "Webpack's `mode: 'production'` enables many optimizations by default, including `TerserPlugin` for JS minification.",
            "For CSS minification, you'll need `css-minimizer-webpack-plugin`.",
            "The `webpack-bundle-analyzer` plugin is essential for visualizing bundle contents and sizes.",
            "Remember to install necessary plugins and loaders via npm/yarn."
          ],
          "tags": [
            "webpack",
            "optimization",
            "minification",
            "gzip",
            "deployment",
            "build-tools"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "webpack_basics",
            "npm_yarn_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "bundle_minification",
            "gzip_compression",
            "cache_optimizations"
          ]
        },
        {
          "id": "task_implement_service_worker_caching",
          "title": "Implement Basic Service Worker Caching for Offline Assets",
          "description": "\nYour goal is to enhance a simple static HTML/CSS/JS application by adding a basic Service Worker that caches essential assets, allowing the page to be loaded offline after the first visit.\n\n**Requirements:**\n1.  **Register Service Worker**: Register a service worker (`sw.js`) in `index.html`.\n2.  **Install Event**: In `sw.js`, listen for the `install` event and cache the `index.html`, `style.css`, and `script.js` files using the Cache Storage API.\n3.  **Activate Event**: In `sw.js`, listen for the `activate` event and clean up old caches (if any).\n4.  **Fetch Event**: In `sw.js`, intercept network requests via the `fetch` event. For cached assets, serve them from the cache first; otherwise, fetch from the network and then cache the response for future use (cache-first strategy).\n5.  **Test Offline**: Verify the application loads correctly when offline after an initial online visit.\n",
          "difficulty": "medium",
          "startingCode": "// index.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Offline App</title>\n    <link rel=\"stylesheet\" href=\"style.css\">\n</head>\n<body>\n    <h1>Welcome to the Offline App!</h1>\n    <p>This content should be available offline.</p>\n    <button id=\"fetchBtn\">Fetch Data</button>\n    <div id=\"data\"></div>\n    <script src=\"script.js\"></script>\n    <script>\n        // TODO: Register service worker here\n    </script>\n</body>\n</html>\n\n// style.css\nbody {\n    font-family: sans-serif;\n    margin: 20px;\n    background-color: #f0f0f0;\n}\nh1 {\n    color: #333;\n}\n\n// script.js\ndocument.getElementById('fetchBtn').addEventListener('click', async () => {\n    const dataDiv = document.getElementById('data');\n    dataDiv.textContent = 'Fetching...';\n    try {\n        const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');\n        const data = await response.json();\n        dataDiv.textContent = `Todo: ${data.title}`; \n    } catch (error) {\n        dataDiv.textContent = 'Failed to fetch data. Are you offline?';\n        console.error('Fetch error:', error);\n    }\n});\n",
          "solutionCode": "// index.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Offline App</title>\n    <link rel=\"stylesheet\" href=\"style.css\">\n</head>\n<body>\n    <h1>Welcome to the Offline App!</h1>\n    <p>This content should be available offline.</p>\n    <button id=\"fetchBtn\">Fetch Data</button>\n    <div id=\"data\"></div>\n    <script src=\"script.js\"></script>\n    <script>\n        if ('serviceWorker' in navigator) {\n            window.addEventListener('load', () => {\n                navigator.serviceWorker.register('/sw.js')\n                    .then(registration => {\n                        console.log('Service Worker registered with scope:', registration.scope);\n                    })\n                    .catch(error => {\n                        console.error('Service Worker registration failed:', error);\n                    });\n            });\n        }\n    </script>\n</body>\n</html>\n\n// sw.js\nconst CACHE_NAME = 'my-pwa-cache-v1';\nconst urlsToCache = [\n  '/', // Catches index.html when accessed via root\n  '/index.html',\n  '/style.css',\n  '/script.js'\n];\n\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then((cache) => {\n        console.log('Opened cache');\n        return cache.addAll(urlsToCache);\n      })\n  );\n});\n\nself.addEventListener('fetch', (event) => {\n  event.respondWith(\n    caches.match(event.request)\n      .then((response) => {\n        // Cache hit - return response\n        if (response) {\n          return response;\n        }\n        // No cache hit - fetch from network and cache for future\n        return fetch(event.request).then(\n          (response) => {\n            // Check if we received a valid response\n            if(!response || response.status !== 200 || response.type !== 'basic') {\n              return response;\n            }\n            // IMPORTANT: Clone the response. A response is a stream\n            // and can only be consumed once. We must clone it so that\n            // the browser can consume the original response and we can\n            // consume the clone. If the browser consumes the original response\n            // first, then we can't cache it.\n            const responseToCache = response.clone();\n\n            caches.open(CACHE_NAME)\n              .then((cache) => {\n                cache.put(event.request, responseToCache);\n              });\n\n            return response;\n          }\n        );\n      })\n    .catch(error => {\n        console.log('Fetch failed, returning cached page if available:', error);\n        // Optional: Serve a custom offline page if primary assets fail to load\n        // return caches.match('/offline.html');\n    })\n  );\n});\n\nself.addEventListener('activate', (event) => {\n  event.waitUntil(\n    caches.keys().then((cacheNames) => {\n      return Promise.all(\n        cacheNames.map((cacheName) => {\n          if (cacheName !== CACHE_NAME) {\n            console.log('Deleting old cache:', cacheName);\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n",
          "testCases": [
            "Open `index.html` in a browser (e.g., via `http-server` or Live Server extension).",
            "Verify the Service Worker is registered in browser DevTools (Application tab -> Service Workers).",
            "Reload the page to ensure assets are cached.",
            "Go offline (e.g., turn off Wi-Fi or select 'Offline' in DevTools -> Network tab).",
            "Reload the page: It should still load correctly from the cache.",
            "Verify `fetchBtn` still attempts to fetch, but logs an error when offline, as that endpoint is not cached."
          ],
          "hints": [
            "Service Workers run in their own scope, usually at the root of your application (`/sw.js`).",
            "Use `event.waitUntil()` in `install` and `activate` events to ensure tasks are completed before the service worker is considered installed/activated.",
            "The `fetch` event listener is where you define your caching strategy. `caches.match()` checks the cache, and `caches.open().then(cache => cache.put())` adds to the cache.",
            "Remember to `clone()` responses before putting them into the cache, as responses are streams and can only be consumed once."
          ],
          "tags": [
            "service-worker",
            "pwa",
            "caching",
            "offline",
            "javascript",
            "browser-api"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "javascript_promises",
            "fetch_api",
            "html_css_js_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "service_workers",
            "cache_optimizations"
          ]
        },
        {
          "id": "task_analyze_and_improve_lcp",
          "title": "Analyze and Propose Improvements for LCP",
          "description": "\nYou are given a simple HTML page that simulates a common LCP issue: a large image that loads late. Your task is to analyze its LCP using browser developer tools and then propose and implement a solution to improve its LCP score.\n\n**Requirements:**\n1.  **Analyze LCP**: Open the `index.html` in Chrome DevTools (or similar), go to the `Performance` tab, and record a page load. Identify the LCP element and its LCP time.\n2.  **Propose Solution**: Based on your analysis, propose a specific technique to improve the LCP of the identified element.\n3.  **Implement Solution**: Modify the `index.html` to implement your chosen LCP optimization technique.\n4.  **Verify Improvement**: Re-run the performance analysis and compare the new LCP time with the old one, explaining the improvement.\n\n**Scenario**: The page has a large hero image that appears below some text but is critical to the perceived loading experience.",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>LCP Optimization</title>\n    <style>\n        body {\n            font-family: sans-serif;\n            margin: 0;\n            padding: 20px;\n            text-align: center;\n        }\n        .hero-section {\n            margin-top: 50px;\n        }\n        .hero-image {\n            width: 100%;\n            max-width: 800px;\n            height: auto;\n            display: block;\n            margin: 0 auto;\n            /* Simulate slow loading without a network throttle, or use a larger image */\n            /* For a real test, use a large image and network throttling in DevTools */\n        }\n    </style>\n</head>\n<body>\n    <h1>Welcome to Our Awesome Page!</h1>\n    <p>This is some introductory text to our amazing content. Please wait for the main image to load.</p>\n    <div class=\"hero-section\">\n        <img src=\"https://picsum.photos/id/237/1200/800\" alt=\"Large Hero Image\" class=\"hero-image\">\n    </div>\n    <p>More content will appear below the image.</p>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>LCP Optimization</title>\n    <style>\n        body {\n            font-family: sans-serif;\n            margin: 0;\n            padding: 20px;\n            text-align: center;\n        }\n        .hero-section {\n            margin-top: 50px;\n        }\n        .hero-image {\n            width: 100%;\n            max-width: 800px;\n            height: auto;\n            display: block;\n            margin: 0 auto;\n        }\n    </style>\n    <!-- Solution: Preload the LCP image -->\n    <link rel=\"preload\" as=\"image\" href=\"https://picsum.photos/id/237/1200/800\">\n</head>\n<body>\n    <h1>Welcome to Our Awesome Page!</h1>\n    <p>This is some introductory text to our amazing content. The main image should load faster now!</p>\n    <div class=\"hero-section\">\n        <img src=\"https://picsum.photos/id/237/1200/800\" alt=\"Large Hero Image\" class=\"hero-image\">\n    </div>\n    <p>More content will appear below the image.</p>\n</body>\n</html>\n",
          "testCases": [
            "Open `index.html` in Chrome DevTools.",
            "Go to the 'Performance' tab, click record, and reload the page. Stop recording.",
            "Locate the 'LCP' marker in the timings. Note the time and the element.",
            "Apply the `link rel=\"preload\"` hint to the `<head>`.",
            "Repeat the performance recording.",
            "Compare the LCP times: the second run should show a significantly lower LCP time for the image.",
            "Explain that `preload` tells the browser to fetch the image with high priority earlier in the rendering process."
          ],
          "hints": [
            "Common LCP culprits include large images (especially hero images), large blocks of text, or large background images.",
            "To improve LCP for images, consider using `link rel=\"preload\"` in the `<head>`, optimizing image file size and format (e.g., WebP), or responsive images (`srcset`).",
            "Network throttling in DevTools (Network tab) can help simulate real-world conditions and make LCP issues more apparent.",
            "The `Performance` tab in DevTools will clearly highlight the LCP event and the element responsible for it."
          ],
          "tags": [
            "lcp",
            "performance",
            "optimization",
            "browser-dev-tools",
            "html",
            "images"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "html_basics",
            "browser_dev_tools",
            "web_performance_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "lcp",
            "image_optimization",
            "preload"
          ]
        },
        {
          "id": "task_debug_and_fix_cls",
          "title": "Debug and Fix Cumulative Layout Shift (CLS) Issues",
          "description": "\nYou are presented with a web page that exhibits a noticeable layout shift (CLS) when an advertisement or image loads. Your task is to identify the cause of the CLS using browser developer tools and implement a solution to prevent the layout shift.\n\n**Requirements:**\n1.  **Identify CLS**: Load the provided `index.html`. Observe the page. Use Chrome DevTools (or similar) 'Performance' tab to record a page load and identify the layout shift events. Note the element causing the shift and the CLS score.\n2.  **Propose Solution**: Based on the identified cause, propose a method to prevent the layout shift.\n3.  **Implement Solution**: Modify the `index.html` or `style.css` to implement your solution.\n4.  **Verify Fix**: Re-run the performance analysis and confirm that the CLS score has significantly improved (ideally to 0) and the visual shift is gone.\n\n**Scenario**: A banner ad (simulated by a delayed image) loads and pushes existing content down.",
          "difficulty": "medium",
          "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>CLS Debugging</title>\n    <style>\n        body {\n            font-family: sans-serif;\n            margin: 20px;\n            text-align: center;\n        }\n        .content-area {\n            border: 1px solid #ccc;\n            padding: 20px;\n            margin-bottom: 20px;\n        }\n        .ad-container {\n            width: 100%;\n            max-width: 728px;\n            margin: 20px auto;\n            background-color: #eee;\n            border: 1px dashed #999;\n            text-align: center;\n            line-height: 50px; /* Placeholder for ad */\n            color: #666;\n            font-style: italic;\n        }\n        /* Simulate a delayed ad image loading */\n        img.delayed-ad {\n            display: none; /* Hidden initially */\n            width: 728px; /* Intended width */\n            height: 90px; /* Intended height */\n        }\n    </style>\n</head>\n<body>\n    <h1>Website Content</h1>\n    <div class=\"content-area\">\n        <p>This is the main content of our page. It should ideally stay stable and not jump around.</p>\n        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>\n    </div>\n    \n    <div class=\"ad-container\" id=\"adSlot\">\n        Loading Ad...\n    </div>\n\n    <div class=\"content-area\">\n        <p>More content below the ad. This part often gets pushed down.</p>\n        <p>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>\n    </div>\n\n    <script>\n        // Simulate an ad loading after a delay\n        setTimeout(() => {\n            const adSlot = document.getElementById('adSlot');\n            adSlot.innerHTML = `<img src=\"https://placehold.co/728x90/FF0000/FFFFFF?text=Awesome+Ad\" alt=\"Ad Banner\" class=\"delayed-ad\">`;\n            // Remove display:none and make it visible after some time to simulate dynamic loading.\n            const img = adSlot.querySelector('img');\n            if (img) {\n                img.style.display = 'block'; // Make it visible after content insertion\n                adSlot.style.lineHeight = 'initial'; // Remove placeholder line-height\n            }\n        }, 1500);\n    </script>\n</body>\n</html>\n",
          "solutionCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>CLS Debugging</title>\n    <style>\n        body {\n            font-family: sans-serif;\n            margin: 20px;\n            text-align: center;\n        }\n        .content-area {\n            border: 1px solid #ccc;\n            padding: 20px;\n            margin-bottom: 20px;\n        }\n        .ad-container {\n            width: 100%;\n            max-width: 728px;\n            margin: 20px auto;\n            background-color: #eee;\n            border: 1px dashed #999;\n            text-align: center;\n            /* Solution: Reserve space for the ad */\n            min-height: 90px; /* Explicitly reserve height */\n            display: flex; /* To center content within the reserved space */\n            align-items: center;\n            justify-content: center;\n        }\n        img.delayed-ad {\n            width: 728px; /* Intended width */\n            height: 90px; /* Intended height */\n            display: none;\n        }\n    </style>\n</head>\n<body>\n    <h1>Website Content</h1>\n    <div class=\"content-area\">\n        <p>This is the main content of our page. It should ideally stay stable and not jump around.</p>\n        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>\n    </div>\n    \n    <div class=\"ad-container\" id=\"adSlot\">\n        Loading Ad...\n    </div>\n\n    <div class=\"content-area\">\n        <p>More content below the ad. This part often gets pushed down.</p>\n        <p>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>\n    </div>\n\n    <script>\n        setTimeout(() => {\n            const adSlot = document.getElementById('adSlot');\n            adSlot.innerHTML = `<img src=\"https://placehold.co/728x90/FF0000/FFFFFF?text=Awesome+Ad\" alt=\"Ad Banner\" class=\"delayed-ad\">`;\n            const img = adSlot.querySelector('img');\n            if (img) {\n                img.style.display = 'block';\n                // No need to adjust line-height if min-height is set on container\n            }\n        }, 1500);\n    </script>\n</body>\n</html>\n",
          "testCases": [
            "Open `index.html` in Chrome DevTools.",
            "Go to the 'Performance' tab, click record, and reload the page. Observe the ad loading and any layout shifts.",
            "In the 'Experience' section of the performance report, check the CLS score and identify the elements that shifted.",
            "Implement the solution (e.g., adding `min-height` to `.ad-container`).",
            "Re-run the performance recording and verify that the CLS score is now 0 or significantly reduced, and no visual shifts occur.",
            "Explain *why* the `min-height` property fixes the CLS issue for the ad container."
          ],
          "hints": [
            "CLS often occurs when dynamically injected content (like ads, images, or embeds) or fonts that load late don't have space reserved for them.",
            "The key to fixing CLS is to ensure that space is reserved for content that will eventually load or render.",
            "For images and iframes, always specify `width` and `height` attributes.",
            "For dynamic content containers, use CSS properties like `min-height` or aspect ratio boxes to reserve space.",
            "The 'Layout Shift' section in the Performance tab, or the 'Layout Shift Regions' checkbox in the Rendering tab (in DevTools) can help visualize shifts.",
            "Using `content-visibility: auto` (experimental) can also help, but `min-height` is a more widely supported fix for this specific case."
          ],
          "tags": [
            "cls",
            "performance",
            "layout-shift",
            "css",
            "html",
            "browser-dev-tools"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "html_css_basics",
            "browser_dev_tools"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "cls",
            "visual_stability",
            "web_performance_metrics"
          ]
        },
        {
          "id": "task_implement_react_lazy_suspense",
          "title": "Implement React.lazy and Suspense for a Collapsible Section",
          "description": "\nYou are building a React application that includes a large, complex component (e.g., a data table, a rich text editor) that is only visible when a user clicks a 'Show Details' button. To optimize the initial load time, you need to lazy-load this component using `React.lazy` and `Suspense`.\n\n**Requirements:**\n1.  **Create a Lazy Component**: Define `DetailedInfo` component in a separate file (`DetailedInfo.js`). This component should simulate heavy loading (e.g., `console.log` a message when rendered).\n2.  **Use React.lazy**: In `App.js`, use `React.lazy` to import `DetailedInfo`.\n3.  **Implement Toggle Logic**: Create a button that toggles the visibility of `DetailedInfo`.\n4.  **Add Suspense Boundary**: Wrap the `DetailedInfo` component with `Suspense` and provide a suitable `fallback` UI (e.g., 'Loading Details...').\n5.  **Verify**: Confirm that `DetailedInfo.js` is only loaded when the button is clicked, and the fallback UI appears during loading. (Check Network tab in DevTools for the chunk file).\n",
          "difficulty": "medium",
          "startingCode": "// App.js\nimport React, { useState } from 'react';\n// import DetailedInfo from './DetailedInfo'; // Don't import directly!\n\nfunction App() {\n  const [showDetails, setShowDetails] = useState(false);\n\n  const toggleDetails = () => {\n    setShowDetails(!showDetails);\n  };\n\n  return (\n    <div>\n      <h1>Main Application</h1>\n      <button onClick={toggleDetails}>\n        {showDetails ? 'Hide Details' : 'Show Details'}\n      </button>\n      \n      {/* TODO: Render DetailedInfo component using React.lazy and Suspense */}\n      {/* {showDetails && <DetailedInfo />} */}\n\n    </div>\n  );\n}\n\nexport default App;\n\n// DetailedInfo.js\nimport React from 'react';\n\nconst DetailedInfo = () => {\n  console.log('DetailedInfo component rendered!');\n  return (\n    <div style={{ border: '1px solid blue', padding: '20px', marginTop: '20px' }}>\n      <h2>Detailed Information</h2>\n      <p>This is a complex component with lots of data or heavy logic that should only load when needed.</p>\n      <ul>\n        <li>Item 1</li>\n        <li>Item 2</li>\n        <li>Item 3</li>\n      </ul>\n    </div>\n  );\n};\n\nexport default DetailedInfo;\n",
          "solutionCode": "// App.js\nimport React, { useState, Suspense, lazy } from 'react';\n\n// Use React.lazy for dynamic import\nconst DetailedInfo = lazy(() => import('./DetailedInfo'));\n\nfunction App() {\n  const [showDetails, setShowDetails] = useState(false);\n\n  const toggleDetails = () => {\n    setShowDetails(!showDetails);\n  };\n\n  return (\n    <div>\n      <h1>Main Application</h1>\n      <button onClick={toggleDetails}>\n        {showDetails ? 'Hide Details' : 'Show Details'}\n      </button>\n      \n      {showDetails && (\n        <Suspense fallback={<div>Loading Details...</div>}>\n          <DetailedInfo />\n        </Suspense>\n      )}\n    </div>\n  );\n}\n\nexport default App;\n\n// DetailedInfo.js\nimport React from 'react';\n\nconst DetailedInfo = () => {\n  console.log('DetailedInfo component rendered!');\n  return (\n    <div style={{ border: '1px solid blue', padding: '20px', marginTop: '20px' }}>\n      <h2>Detailed Information</h2>\n      <p>This is a complex component with lots of data or heavy logic that should only load when needed.</p>\n      <ul>\n        <li>Item 1</li>\n        <li>Item 2</li>\n        <li>Item 3</li>\n      </ul>\n    </div>\n  );\n};\n\nexport default DetailedInfo;\n",
          "testCases": [
            "Run the React application.",
            "Open DevTools (Network tab) and ensure 'JS' filter is active.",
            "Initially, observe that the `DetailedInfo.js` chunk is *not* loaded.",
            "Click the 'Show Details' button. Observe 'Loading Details...' briefly appearing.",
            "In the Network tab, verify that a new JavaScript chunk (representing `DetailedInfo.js`) is downloaded.",
            "Toggle the button multiple times: the chunk should only download once.",
            "Verify `DetailedInfo component rendered!` message appears in console only when the component is shown."
          ],
          "hints": [
            "Remember to import `Suspense` and `lazy` from `react`.",
            "The `lazy` function takes a function that returns a Promise, which resolves to a module with a default export.",
            "The `Suspense` component must wrap the lazy-loaded component and takes a `fallback` prop.",
            "To easily simulate a slight delay for better observation of the loading state, you could add a `setTimeout` inside the `import()` promise in `App.js` for testing purposes, but remove it for production.",
            "Ensure `DetailedInfo.js` has a `default export` for the component."
          ],
          "tags": [
            "react",
            "lazy-loading",
            "code-splitting",
            "suspense",
            "performance",
            "frontend-architecture"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_basics",
            "es6_modules",
            "promises"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "react.lazy",
            "suspense",
            "code_splitting"
          ]
        },
        {
          "id": "task_code_splitting_react_router",
          "title": "Implement Route-Based Code Splitting with React Router",
          "description": "\nEnhance a provided React application that uses `react-router-dom` by implementing route-based code splitting. The goal is to lazy-load specific route components to reduce the initial bundle size and improve load performance when navigating to those routes.\n\n**Requirements:**\n1.  **Define Route Components**: Create three simple components in separate files: `Home.js`, `About.js`, `Contact.js`.\n2.  **Lazy Load Components**: Use `React.lazy` to import `About` and `Contact` components in `App.js`.\n3.  **Integrate with React Router**: Set up `react-router-dom` routes in `App.js` for `/`, `/about`, and `/contact`.\n4.  **Add Suspense Boundary**: Wrap the `Routes` component with `Suspense` to provide a loading fallback.\n5.  **Verification**: Use browser DevTools (Network tab) to confirm that the `About.js` and `Contact.js` bundles are only loaded when their respective routes are accessed, not on initial page load.\n",
          "difficulty": "medium",
          "startingCode": "// App.js\nimport { BrowserRouter as Router, Route, Routes } from 'react-router-dom';\nimport React from 'react';\n// import Home from './components/Home';\n// import About from './components/About'; // TODO: Make lazy\n// import Contact from './components/Contact'; // TODO: Make lazy\n\nfunction App() {\n  return (\n    <Router>\n      <nav>\n        <a href=\"/\">Home</a> | <a href=\"/about\">About</a> | <a href=\"/contact\">Contact</a>\n      </nav>\n      {/* TODO: Add Suspense boundary for routes */}\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          {/* TODO: Add lazy-loaded About and Contact routes */}\n          {/* <Route path=\"/about\" element={<About />} /> */}\n          {/* <Route path=\"/contact\" element={<Contact />} /> */}\n        </Routes>\n      {/* TODO: Close Suspense boundary */}\n    </Router>\n  );\n}\n\nexport default App;\n\n// components/Home.js\nimport React from 'react';\n\nconst Home = () => <h2>Home Page</h2>;\nexport default Home;\n\n// components/About.js\nimport React from 'react';\n\nconst About = () => {\n  console.log('About component loaded!');\n  return <h2>About Us</h2>;\n};\nexport default About;\n\n// components/Contact.js\nimport React from 'react';\n\nconst Contact = () => {\n  console.log('Contact component loaded!');\n  return <h2>Contact Page</h2>;\n};\nexport default Contact;\n",
          "solutionCode": "// App.js\nimport { BrowserRouter as Router, Route, Routes, Link } from 'react-router-dom';\nimport React, { Suspense, lazy } from 'react';\n\n// Home component can be eagerly loaded if it's the default landing page, or also lazy-loaded.\n// For this task, let's keep Home eagerly loaded for contrast.\nimport Home from './components/Home';\n\n// Lazy load About and Contact components\nconst About = lazy(() => import('./components/About'));\nconst Contact = lazy(() => import('./components/Contact'));\n\nfunction App() {\n  return (\n    <Router>\n      <nav>\n        <Link to=\"/\">Home</Link> | <Link to=\"/about\">About</Link> | <Link to=\"/contact\">Contact</Link>\n      </nav>\n      <Suspense fallback={<div>Loading page...</div>}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/about\" element={<About />} />\n          <Route path=\"/contact\" element={<Contact />} />\n        </Routes>\n      </Suspense>\n    </Router>\n  );\n}\n\nexport default App;\n\n// components/Home.js\nimport React from 'react';\n\nconst Home = () => <h2>Home Page</h2>;\nexport default Home;\n\n// components/About.js\nimport React from 'react';\n\nconst About = () => {\n  console.log('About component loaded!');\n  return <h2>About Us</h2>;\n};\nexport default About;\n\n// components/Contact.js\nimport React from 'react';\n\nconst Contact = () => {\n  console.log('Contact component loaded!');\n  return <h2>Contact Page</h2>;\n};\nexport default Contact;\n",
          "testCases": [
            "Run the React application.",
            "Open DevTools (Network tab) and filter for 'JS' files.",
            "On initial load (when `/` is active), confirm that `Home.js` (or its bundle) is loaded, but `About.js` and `Contact.js` chunks are NOT.",
            "Click the 'About' link. Observe a brief 'Loading page...' message, and then verify that the `About.js` chunk is loaded in the Network tab, and 'About component loaded!' is logged.",
            "Click the 'Contact' link. Observe similar behavior for `Contact.js`.",
            "Navigate back and forth: confirm chunks are only loaded once.",
            "Ensure navigation still works correctly after lazy-loading."
          ],
          "hints": [
            "Remember to import `Suspense` and `lazy` from `react`.",
            "For `react-router-dom` v6, use `Routes` and `element={<Component />}` for routes.",
            "The `Suspense` component should wrap the `Routes` component to handle loading states for any lazy-loaded route children.",
            "Use `<Link to=\"/path\">` from `react-router-dom` instead of `<a>` tags to prevent full page reloads, which would hide the lazy loading effect."
          ],
          "tags": [
            "react",
            "react-router",
            "code-splitting",
            "lazy-loading",
            "performance",
            "frontend-architecture"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_basics",
            "react_router_basics",
            "es6_modules",
            "promises"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "code_splitting",
            "react.lazy",
            "suspense",
            "react_router"
          ]
        }
      ]
    }
  }
]