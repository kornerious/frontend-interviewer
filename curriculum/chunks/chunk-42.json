[
  {
    "id": "20ef4a66-a599-4844-b72b-87e393b9bfff",
    "startLine": 8300,
    "endLine": 8399,
    "processedDate": "2025-06-17T10:39:49.728Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_use_debug_value",
          "title": "useDebugValue Hook",
          "content": "The `useDebugValue` hook is a specialized React Hook primarily intended for use within custom hooks. Its main purpose is to display a custom label for custom hooks in React DevTools. This can be extremely useful for debugging, as it allows developers to inspect the current value or state of a custom hook without having to expand it or dig through its internal state.\n\n### How it Works\n`useDebugValue` accepts two arguments:\n1.  **Value**: The value you want to display in DevTools. This can be any JavaScript value.\n2.  **Formatter Function (Optional)**: An optional formatter function. If provided, this function will receive the `value` as its argument and should return a formatted display value. This function is only executed when the React DevTools are open and the hook is inspected, which helps prevent unnecessary computations in production environments.\n\n### Benefits\n-   **Improved Debugging Experience**: Provides immediate visibility into the internal state of custom hooks.\n-   **Performance**: The formatter function ensures that expensive formatting operations are only performed when necessary (i.e., when DevTools are active and inspecting the hook).\n\n### Usage Guidelines\n-   It should only be used inside custom hooks.\n-   It is a development-time tool and has no impact on production bundles or application logic.\n-   Use it judiciously for values that are genuinely helpful for debugging the custom hook's behavior.",
          "examples": [
            {
              "id": "example_use_debug_value_basic",
              "title": "Basic useDebugValue in a Custom Hook",
              "code": "import React, { useState, useEffect, useDebugValue } from 'react';\n\n// Simulate external API for user status\nconst userStatusStore = {};\nfunction subscribeToUserStatus(userId, callback) {\n  userStatusStore[userId] = userStatusStore[userId] || { isOnline: false };\n  // Simulate async subscription\n  setTimeout(() => {\n    callback(userStatusStore[userId]);\n  }, 100);\n}\nfunction unsubscribeFromUserStatus(userId, callback) {\n  // In a real app, clean up subscription\n}\n\n// Custom hook with debug value\nfunction useUserStatus(userId) {\n  const [isOnline, setIsOnline] = useState(null);\n  \n  useEffect(() => {\n    // Subscribe to user online status\n    const handleStatusChange = (status) => {\n      setIsOnline(status.isOnline);\n    };\n    \n    // Simplified API call\n    subscribeToUserStatus(userId, handleStatusChange);\n    \n    return () => {\n      unsubscribeFromUserStatus(userId, handleStatusChange);\n    };\n  }, [userId]);\n  \n  // Show custom label in React DevTools\n  // This will display 'Online' or 'Offline' next to the hook in DevTools\n  useDebugValue(isOnline ? 'Online' : 'Offline');\n  \n  return isOnline;\n}\n\n// Usage example component\nfunction UserStatus({ userId }) {\n  const isOnline = useUserStatus(userId);\n  \n  if (isOnline === null) {\n    return <div>Loading user {userId} status...</div>;\n  }\n  \n  return (\n    <div>\n      User {userId} is {isOnline ? 'online' : 'offline'}\n    </div>\n  );\n}\n\n// To run this, you would render <UserStatus userId=\"123\" /> in your app.\n// Then open React DevTools, inspect the component, and look for 'Hooks' tab.\n",
              "explanation": "This example demonstrates a `useUserStatus` custom hook that subscribes to a user's online status. The `useDebugValue` hook is used to display a simple 'Online' or 'Offline' string directly in the React DevTools, making it easy to see the user's status without drilling down into the hook's internal state. This is particularly helpful for custom hooks that manage complex logic or asynchronous operations.",
              "language": "typescript"
            },
            {
              "id": "example_use_debug_value_formatter",
              "title": "useDebugValue with Formatter Function",
              "code": "import React, { useState, useEffect, useDebugValue } from 'react';\n\nfunction useCounter(initialValue) {\n  const [count, setCount] = useState(initialValue);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setCount(prevCount => prevCount + 1);\n    }, 1000);\n    return () => clearInterval(interval);\n  }, []);\n\n  // Use a formatter function to display a more descriptive label\n  useDebugValue(count, c => `Count: ${c} (Active)`);\n\n  return count;\n}\n\nfunction CounterDisplay() {\n  const currentCount = useCounter(0);\n\n  return (\n    <div>\n      Current Count: {currentCount}\n    </div>\n  );\n}\n",
              "explanation": "This example shows `useDebugValue` with its optional second argument, a formatter function. The `useCounter` hook manages a simple counter. Instead of just displaying the raw `count` number, the formatter function `c => `Count: ${c} (Active)`` provides a more descriptive string. This function is only executed when DevTools are open, optimizing performance by avoiding unnecessary string interpolation in production.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React Hooks",
            "Debugging",
            "Developer Tools",
            "Custom Hooks"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "Custom Hooks"
          ],
          "complexity": 5,
          "interviewRelevance": 6,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced React Debugging",
            "Custom Hook Development"
          ]
        },
        {
          "id": "theory_preventing_unnecessary_updates_set_state",
          "title": "Optimizing Re-renders with setState and Functional Updates",
          "content": "In React class components, `setState` is the primary method for updating component state. By default, calling `setState` will trigger a re-render of the component and its children. However, not all state updates necessitate a re-render. React provides a mechanism to prevent unnecessary updates, thereby optimizing performance, especially for frequently updated components or components with many children.\n\n### Functional setState for Conditional Updates\nWhen `setState` is passed a function (rather than an object), this function receives the previous state (`state`) and current props (`props`) as arguments. This functional form is primarily used when the new state depends on the previous state. A less commonly known but powerful feature of this functional `setState` is its ability to **bail out of an update**.\n\nIf the function passed to `setState` returns `null`, React will interpret this as a signal that no state change occurred, and it will **prevent the component from re-rendering**. This is an effective way to optimize performance when you determine that the new state value is identical to the current state value, thus avoiding redundant rendering cycles.\n\n### Advantages\n-   **Performance Optimization**: Prevents unnecessary re-renders, reducing CPU cycles and improving application responsiveness.\n-   **Idempotence**: Ensures that calling `setState` with the same value multiple times does not lead to redundant work.\n\n### Considerations\n-   This optimization applies to class components using `setState`.\n-   For functional components, memoization hooks like `useMemo` and `useCallback`, along with `React.memo`, are typically used for similar re-render optimizations.\n-   It's important to perform a deep comparison if the state value is a complex object or array, as a shallow comparison might not accurately reflect whether a change occurred.",
          "examples": [
            {
              "id": "example_set_state_bail_out",
              "title": "Preventing Re-renders with Functional setState",
              "code": "import React from 'react';\n\nclass UserProfileManager extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      address: '123 Main St',\n      name: 'John Doe'\n    };\n  }\n\n  // Simulates fetching a user profile from an API\n  getUserProfile = (user) => {\n    const latestAddress = user.address;\n    \n    console.log(`Attempting to update address to: ${latestAddress}`);\n\n    // Using functional setState for comparison with previous state\n    this.setState(state => {\n      // If address hasn't changed, return null to prevent re-render\n      if (state.address === latestAddress) {\n        console.log('Address is the same, preventing re-render.');\n        return null; // React bails out of the update\n      } else {\n        // Only update if the value has changed\n        console.log('Address changed, updating state and re-rendering.');\n        return { address: latestAddress };\n      }\n    }, () => {\n        // Callback after state update (or bail out)\n        console.log('Current state address:', this.state.address);\n    });\n  };\n\n  componentDidMount() {\n    // Simulate receiving updates\n    this.getUserProfile({ address: '123 Main St' }); // No change, should bail out\n    setTimeout(() => {\n      this.getUserProfile({ address: '456 Oak Ave' }); // Change, should update\n    }, 1000);\n    setTimeout(() => {\n      this.getUserProfile({ address: '456 Oak Ave' }); // No change, should bail out again\n    }, 2000);\n  }\n\n  render() {\n    console.log('UserProfileManager rendered!');\n    return (\n      <div>\n        <h2>User Profile</h2>\n        <p>Name: {this.state.name}</p>\n        <p>Address: {this.state.address}</p>\n      </div>\n    );\n  }\n}\n\n// To run this, render <UserProfileManager /> in your application.\n",
              "explanation": "This example demonstrates how to use the functional form of `setState` to conditionally prevent a component from re-rendering. The `getUserProfile` method checks if the incoming `latestAddress` is identical to the current `state.address`. If they are the same, it returns `null` from the `setState` function, causing React to skip the update and subsequent re-render. This is verified by the console logs, which show 'UserProfileManager rendered!' only when the address actually changes.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Class Components",
            "Performance Optimization",
            "setState",
            "Re-renders"
          ],
          "technology": "React",
          "prerequisites": [
            "React Class Components",
            "State Management in React"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Performance Tuning",
            "Advanced React Class Components"
          ]
        },
        {
          "id": "theory_use_callback_use_memo",
          "title": "useCallback and useMemo Hooks for Performance Optimization",
          "content": "In React functional components, `useCallback` and `useMemo` are powerful hooks used for performance optimization by memoizing (caching) functions and values, respectively. They help prevent unnecessary re-renders of child components that rely on prop equality checks (e.g., components wrapped with `React.memo`).\n\n### useCallback Hook\n`useCallback` returns a memoized version of the callback function that only changes if one of the dependencies has changed. This is crucial when passing callbacks to optimized child components that use `React.memo`, as it prevents the child from re-rendering unnecessarily due to a new function reference being passed on every parent re-render.\n\n**Syntax:**\n```typescript\nconst memoizedCallback = useCallback(\n  () => {\n    // Function body\n    doSomething(a, b);\n  },\n  [a, b], // Dependency array\n);\n```\n-   The first argument is the function to be memoized.\n-   The second argument is a dependency array. The memoized function will only be re-created if any of the values in this array change.\n\n**When to use:**\n-   Passing callbacks to `React.memo` wrapped child components.\n-   Optimizing event handlers.\n-   Preventing infinite loops in `useEffect` or `useMemo` when a function is a dependency.\n\n### useMemo Hook\n`useMemo` returns a memoized value. It only recomputes the memoized value when one of the dependencies has changed. This is useful for expensive calculations that don't need to be re-run on every render.\n\n**Syntax:**\n```typescript\nconst memoizedValue = useMemo(\n  () => computeExpensiveValue(a, b),\n  [a, b] // Dependency array\n);\n```\n-   The first argument is a 'create' function that computes the value.\n-   The second argument is a dependency array. The value will only be recomputed if any of the values in this array change.\n\n**When to use:**\n-   Performing expensive calculations (e.g., complex data transformations, filtering large arrays).\n-   Memoizing objects or arrays passed as props to `React.memo` wrapped child components, to prevent unnecessary re-renders due to new object/array references.\n\n### Key Differences\n-   `useCallback` memoizes **functions**.\n-   `useMemo` memoizes **values** (the result of a function call).\n\n### Important Considerations\n-   **Don't overuse**: Memoization adds a slight overhead. Only use these hooks when profiling indicates a performance bottleneck, or when passing props to `React.memo` wrapped components.\n-   **Correct dependencies**: Always ensure the dependency array is correct and includes all values from the component scope that are used inside the memoized function or computation. Incorrect dependencies can lead to stale closures or missed updates.\n-   `React.memo` is often used in conjunction with `useCallback` and `useMemo` for optimizing child components.",
          "examples": [
            {
              "id": "example_use_callback_basic",
              "title": "Basic useCallback Usage",
              "code": "import React, { useState, useCallback, memo } from 'react';\n\n// A child component that only re-renders if its props change\nconst Button = memo(({ onClick, label }) => {\n  console.log(`Rendering ${label} Button`);\n  return <button onClick={onClick}>{label}</button>;\n});\n\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n\n  // Without useCallback, this handleIncrement function would be recreated on every ParentComponent render,\n  // causing the memoized Button to re-render even if 'count' doesn't affect it directly (unless it uses other props).\n  const handleIncrement = useCallback(() => {\n    setCount(prevCount => prevCount + 1);\n  }, []); // Empty dependency array means this function is created once\n\n  const handleChange = useCallback((e) => {\n    setText(e.target.value);\n  }, []); // Empty dependency array means this function is created once\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <Button onClick={handleIncrement} label=\"Increment\" />\n      <input type=\"text\" value={text} onChange={handleChange} placeholder=\"Type something\" />\n      <p>Input Text: {text}</p>\n    </div>\n  );\n}\n\n// To run this, render <ParentComponent /> in your application.\n// Observe console logs to see when 'Increment Button' re-renders.\n",
              "explanation": "This example illustrates `useCallback` with a `memo`-wrapped child component. The `Button` component is wrapped with `React.memo`, meaning it will only re-render if its props change. Without `useCallback`, `handleIncrement` would be a new function on every `ParentComponent` render (due to `text` state changes, for example), causing `Button` to re-render. By wrapping `handleIncrement` with `useCallback` and providing an empty dependency array `[]`, the function reference remains stable across renders, preventing unnecessary re-renders of the `Button` component when `text` changes.",
              "language": "typescript"
            },
            {
              "id": "example_use_memo_basic",
              "title": "Basic useMemo Usage for Expensive Calculation",
              "code": "import React, { useState, useMemo } from 'react';\n\n// Simulate an expensive calculation\nconst computeExpensiveValue = (num) => {\n  console.log('Computing expensive value...');\n  let result = 0;\n  for (let i = 0; i < 100000000; i++) {\n    result += num;\n  }\n  return result;\n};\n\nfunction ValueCalculator() {\n  const [number, setNumber] = useState(10);\n  const [count, setCount] = useState(0);\n\n  // The expensive calculation will only re-run if 'number' changes\n  const memoizedResult = useMemo(() => computeExpensiveValue(number), [number]);\n\n  return (\n    <div>\n      <input\n        type=\"number\"\n        value={number}\n        onChange={(e) => setNumber(parseInt(e.target.value) || 0)}\n      />\n      <p>Expensive Calculation Result: {memoizedResult}</p>\n\n      <button onClick={() => setCount(prevCount => prevCount + 1)}>\n        Increment Count: {count}\n      </button>\n      <p>This button increments 'count' state. The expensive calculation above does not re-run when 'count' changes.</p>\n    </div>\n  );\n}\n\n// To run this, render <ValueCalculator /> in your application.\n// Observe console logs to see when 'Computing expensive value...' runs.\n",
              "explanation": "This example demonstrates `useMemo` for an expensive calculation. `computeExpensiveValue` is a placeholder for a computationally intensive function. `memoizedResult` will only be re-computed when the `number` state changes. When the `count` state is updated (by clicking the 'Increment Count' button), the `ValueCalculator` component re-renders, but `computeExpensiveValue` is not executed again, because its dependency (`number`) has not changed. This prevents unnecessary and costly re-calculations, improving UI responsiveness.",
              "language": "typescript"
            },
            {
              "id": "example_use_memo_for_object_ref",
              "title": "useMemo for Object References in Props",
              "code": "import React, { useState, useMemo, memo } from 'react';\n\nconst DisplayDetails = memo(({ details }) => {\n  console.log('DisplayDetails component rendered');\n  return (\n    <div>\n      <p>Name: {details.name}</p>\n      <p>Age: {details.age}</p>\n    </div>\n  );\n});\n\nfunction UserProfile() {\n  const [userName, setUserName] = useState('Alice');\n  const [userAge, setUserAge] = useState(30);\n  const [theme, setTheme] = useState('light');\n\n  // Without useMemo, 'userDetails' would be a new object on every render,\n  // causing DisplayDetails (if memoized) to re-render even if name/age are stable.\n  const userDetails = useMemo(() => ({\n    name: userName,\n    age: userAge,\n  }), [userName, userAge]); // Dependencies ensure new object only if name or age changes\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={userName}\n        onChange={(e) => setUserName(e.target.value)}\n      />\n      <button onClick={() => setUserAge(prevAge => prevAge + 1)}>\n        Increase Age ({userAge})\n      </button>\n      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>\n        Toggle Theme ({theme})\n      </button>\n      <DisplayDetails details={userDetails} />\n      <p>Current Theme: {theme}</p>\n    </div>\n  );\n}\n\n// To run this, render <UserProfile /> in your application.\n// Observe console logs to see when 'DisplayDetails component rendered' runs.\n",
              "explanation": "This example shows `useMemo` being used to memoize an object passed as a prop to a `React.memo` wrapped child component (`DisplayDetails`). If `userDetails` were created directly as `{ name: userName, age: userAge }` on each render, it would be a new object reference every time, causing `DisplayDetails` to re-render even if `userName` and `userAge` haven't changed. By wrapping it with `useMemo`, a new `userDetails` object is only created when `userName` or `userAge` actually change, preventing unnecessary re-renders of `DisplayDetails` when the `theme` state changes.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React Hooks",
            "Performance Optimization",
            "Memoization",
            "useCallback",
            "useMemo",
            "Functional Components",
            "React.memo"
          ],
          "technology": "React",
          "prerequisites": [
            "React Functional Components",
            "State and Props in React",
            "React.memo"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "Optimized React Applications",
            "Large-scale React Development"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_use_debug_value_1",
          "topic": "useDebugValue Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `useDebugValue` hook in React?",
          "answer": "To display a custom label for custom hooks in React DevTools.",
          "analysisPoints": [
            "Identifies the specific use case for `useDebugValue`.",
            "Distinguishes its purpose from other debugging techniques."
          ],
          "keyConcepts": [
            "useDebugValue",
            "React DevTools",
            "Custom Hooks"
          ],
          "evaluationCriteria": [
            "Understanding of `useDebugValue`'s core functionality."
          ],
          "example": "",
          "tags": [
            "React Hooks",
            "Debugging"
          ],
          "prerequisites": [
            "Custom Hooks"
          ],
          "complexity": 2,
          "interviewFrequency": 4,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_debug_value_2",
          "topic": "useDebugValue Hook",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following custom hook:\n```typescript\nimport { useState, useDebugValue } from 'react';\n\nfunction useFeatureToggle(featureName: string, defaultValue: boolean) {\n  const [isEnabled, setIsEnabled] = useState(defaultValue);\n\n  useDebugValue(isEnabled ? `Feature ${featureName}: ON` : `Feature ${featureName}: OFF`);\n\n  return [isEnabled, setIsEnabled];\n}\n```\nWhich of the following statements about the `useDebugValue` line in this hook is TRUE?",
          "answer": "The string 'Feature [featureName]: ON' or 'Feature [featureName]: OFF' will appear next to the `useFeatureToggle` hook in React DevTools.",
          "options": [
            "The string 'Feature [featureName]: ON' or 'Feature [featureName]: OFF' will be logged to the browser console when the hook updates.",
            "The `useDebugValue` call will cause the component using `useFeatureToggle` to re-render whenever `isEnabled` changes.",
            "The string 'Feature [featureName]: ON' or 'Feature [featureName]: OFF' will appear next to the `useFeatureToggle` hook in React DevTools.",
            "The `useDebugValue` hook is primarily used for optimizing the performance of the custom hook."
          ],
          "analysisPoints": [
            "Tests understanding of `useDebugValue`'s effect on DevTools.",
            "Differentiates `useDebugValue` from console logging.",
            "Clarifies that `useDebugValue` does not cause re-renders.",
            "Corrects the misconception about its primary purpose (not performance optimization)."
          ],
          "keyConcepts": [
            "useDebugValue",
            "React DevTools",
            "Custom Hooks",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Correctly identifies the function of `useDebugValue`.",
            "Understands its impact on the development environment, not runtime behavior.",
            "Avoids common misconceptions about its purpose."
          ],
          "example": "The `useDebugValue` hook's sole purpose is to provide supplementary debugging information in React DevTools. It does not affect component rendering, application logic, or console output. The string passed to it is displayed within the DevTools interface, helping developers quickly understand the state of a custom hook.",
          "tags": [
            "React Hooks",
            "Debugging",
            "Developer Tools"
          ],
          "prerequisites": [
            "React Hooks",
            "Custom Hooks",
            "React DevTools"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_use_debug_value_3",
          "topic": "useDebugValue Hook",
          "level": "hard",
          "type": "open",
          "question": "You have a custom hook `useLocalStorage` that synchronizes a state value with `localStorage`. Explain how and why you might use `useDebugValue` within this hook, specifically considering the scenario where the stored value might be a large object or array. What are the potential benefits and any performance considerations?",
          "answer": "To use `useDebugValue` in `useLocalStorage`, you would typically pass the current value from localStorage (or the hook's state) to it. For example: `useDebugValue(storedValue, val => `Local Storage: ${JSON.stringify(val).substring(0, 50)}...`);`.\n\n**Why use it:**\n-   **Visibility:** It provides quick visibility into the actual value stored in localStorage, which can be helpful for debugging issues related to persistence or initial state loading. You can see the value directly in DevTools without manually checking localStorage or adding `console.log` statements.\n\n**Scenario with Large Objects/Arrays:**\n-   When the `storedValue` is a large object or array, directly displaying it might clutter DevTools or cause performance issues if `JSON.stringify` is called on every render.\n-   This is where the optional **formatter function** comes in handy. You can pass a formatter function as the second argument to `useDebugValue`. This function receives the value and should return a formatted string representation. Critically, **this formatter function is only executed when the React DevTools are open and the hook is being inspected**. This optimizes performance by delaying expensive operations.\n\n**Potential Benefits:**\n-   **Efficient Debugging:** Get an immediate summary or truncated view of complex data in DevTools.\n-   **Performance Optimization (with formatter):** Avoids serializing large objects/arrays unnecessarily in production or when DevTools are not actively inspecting the hook.\n-   **Contextual Information:** Can add prefixes or suffixes to the debug value (e.g., 'LocalStorage: ...', 'Active Session: ...').\n\n**Performance Considerations:**\n-   Without a formatter function, if the first argument (the value) itself is an object that needs serialization (e.g., if you pass a complex object directly and DevTools tries to display it), there could be a minor overhead, though usually negligible for development.\n-   With a formatter function, the performance impact is minimal because the function is only invoked on demand when DevTools is open and inspecting the hook.",
          "analysisPoints": [
            "Demonstrates understanding of `useDebugValue`'s arguments, especially the formatter function.",
            "Explains the `why` (debugging visibility) and `how` (implementation).",
            "Addresses the specific edge case of large data structures and the performance implications.",
            "Highlights the benefit of the formatter function in optimizing for this scenario."
          ],
          "keyConcepts": [
            "useDebugValue",
            "Custom Hooks",
            "Debugging",
            "React DevTools",
            "Performance Optimization",
            "Formatter Function"
          ],
          "evaluationCriteria": [
            "Ability to apply `useDebugValue` in a practical custom hook scenario.",
            "Understanding of the formatter function's role in performance and readability.",
            "Awareness of potential performance pitfalls with large data and how to mitigate them."
          ],
          "example": "",
          "tags": [
            "React Hooks",
            "Debugging",
            "Performance",
            "Advanced"
          ],
          "prerequisites": [
            "useDebugValue",
            "Custom Hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_set_state_bail_out_1",
          "topic": "Optimizing Re-renders with setState",
          "level": "easy",
          "type": "flashcard",
          "question": "In React class components, what is the effect of returning `null` from the function passed to `this.setState`?",
          "answer": "React will bail out of the update process, preventing the component from re-rendering.",
          "analysisPoints": [
            "Tests knowledge of a specific `setState` behavior.",
            "Identifies the performance implication."
          ],
          "keyConcepts": [
            "setState",
            "Class Components",
            "Re-renders",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Correctly states the consequence of returning `null` from functional `setState`."
          ],
          "example": "",
          "tags": [
            "React",
            "Class Components",
            "Performance"
          ],
          "prerequisites": [
            "setState"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "intermediate"
        },
        {
          "id": "question_set_state_bail_out_2",
          "topic": "Optimizing Re-renders with setState",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `componentDidUpdate` lifecycle method in a React class component:\n```typescript\nclass MyComponent extends React.Component {\n  state = { value: 0 };\n\n  updateValue(newValue) {\n    this.setState(prevState => {\n      if (prevState.value === newValue) {\n        return null; // A\n      } else {\n        return { value: newValue }; // B\n      }\n    });\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (this.state.value !== prevState.value) {\n      console.log('Component re-rendered due to value change');\n    }\n  }\n\n  render() {\n    console.log('Render method executed');\n    return <div>Value: {this.state.value}</div>;\n  }\n}\n\n// Scenario 1: myComponentInstance.updateValue(5);\n// Scenario 2: myComponentInstance.updateValue(5); (called again immediately)\n```\nWhat will be the console output for Scenario 2 (calling `updateValue(5)` again when `value` is already 5)?",
          "answer": "Only 'Render method executed' once (from the first call to updateValue(5)), and no 'Component re-rendered...' message.",
          "options": [
            "Only 'Render method executed' once (from the first call to updateValue(5)), and no 'Component re-rendered...' message.",
            "'Render method executed' twice, and 'Component re-rendered due to value change' twice.",
            "'Render method executed' twice, and 'Component re-rendered due to value change' once.",
            "No console output at all, as React optimizes everything."
          ],
          "analysisPoints": [
            "Correctly identifies that returning `null` prevents re-render.",
            "Understands that `render` is tied to the re-render process.",
            "Recognizes that `componentDidUpdate` depends on actual state change, not just `setState` call."
          ],
          "keyConcepts": [
            "setState",
            "Functional setState",
            "Re-renders",
            "Performance Optimization",
            "componentDidUpdate"
          ],
          "evaluationCriteria": [
            "Accurate prediction of re-render behavior with `null` return from `setState`.",
            "Understanding the interaction between `setState`, `render`, and `componentDidUpdate`."
          ],
          "example": "When `updateValue(5)` is called the first time, `prevState.value` (which is 0) is not equal to `newValue` (5), so `{ value: 5 }` is returned, leading to a state update, re-render, and `componentDidUpdate` firing. When `updateValue(5)` is called a second time, `prevState.value` (now 5) *is* equal to `newValue` (5), so `null` is returned from `setState`. This prevents any state update or re-render, thus `render` is not called again, and `componentDidUpdate` is not called.",
          "tags": [
            "React",
            "Class Components",
            "Performance",
            "setState"
          ],
          "prerequisites": [
            "React State",
            "setState",
            "Class Lifecycle"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_set_state_bail_out_3",
          "topic": "Optimizing Re-renders with setState",
          "level": "hard",
          "type": "open",
          "question": "Discuss scenarios where returning `null` from a functional `this.setState` update is an effective optimization strategy. What are its limitations or potential pitfalls, especially when dealing with nested objects or arrays in state?",
          "answer": "**Effective Optimization Scenarios:**\n1.  **Frequently Updated Values with Infrequent Changes:** When a component receives frequent updates (e.g., from an external subscription, sensor data, or user input debounce) but the actual *value* of a specific state property doesn't change often. Returning `null` avoids redundant renders.\n2.  **Derived State:** If a part of the state is derived from props or other state, and the derived value hasn't changed despite the source changing, you can bail out.\n3.  **Preventing Chained Renders:** In complex component trees, preventing an unnecessary re-render in a parent component can prevent a cascade of unnecessary re-renders in its children.\n\n**Limitations/Potential Pitfalls:**\n1.  **Shallow Comparison Default:** The most significant limitation when dealing with nested objects or arrays is that JavaScript's `===` operator (used in the `if (state.address === latestAddress)` check) performs a **shallow comparison**. This means it only checks if the *references* are the same, not the *contents*.\n    -   If `state.address` was an object `{ street: '123 Main St' }` and `latestAddress` was a *new object* `{ street: '123 Main St' }` with the same content, `state.address === latestAddress` would be `false`, leading to an update even if the content is identical.\n    -   To properly handle nested objects/arrays, you would need to perform a **deep comparison** (e.g., using a utility like `lodash.isEqual` or implementing a custom deep comparison logic).\n2.  **Complexity**: Adding conditional logic within `setState` can make the state update logic more complex and harder to read or maintain if not carefully implemented.\n3.  **Functional vs. Class Components**: This specific bail-out mechanism is exclusive to class components and `setState`. For functional components, `React.memo`, `useMemo`, and `useCallback` are the primary tools for preventing unnecessary re-renders.\n4.  **Misunderstanding Intent**: Developers unfamiliar with this `setState` behavior might find it confusing why a `setState` call doesn't always lead to a render.\n\nIn summary, returning `null` from functional `setState` is a powerful optimization for primitive state values or shallow comparisons, but requires careful consideration and often deep comparison logic for complex data structures.",
          "analysisPoints": [
            "Identifies appropriate scenarios for the optimization.",
            "Clearly explains the critical limitation of shallow comparison with nested data.",
            "Suggests solutions for deep comparison.",
            "Compares its relevance to functional component optimization strategies.",
            "Discusses potential drawbacks like increased complexity."
          ],
          "keyConcepts": [
            "setState",
            "Performance Optimization",
            "Shallow Comparison",
            "Deep Comparison",
            "Class Components",
            "Functional setState",
            "Re-renders"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of the optimization's benefits and drawbacks.",
            "Ability to articulate the shallow vs. deep comparison issue with examples.",
            "Knowledge of alternative optimization strategies for functional components.",
            "Critical thinking about when and when not to apply the technique."
          ],
          "example": "",
          "tags": [
            "React",
            "Performance",
            "Class Components",
            "Advanced"
          ],
          "prerequisites": [
            "setState",
            "React State Management"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_callback_memo_1",
          "topic": "useCallback and useMemo",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference between `useCallback` and `useMemo`?",
          "answer": "`useCallback` memoizes functions (returns a memoized callback), while `useMemo` memoizes values (returns a memoized value from a computation).",
          "analysisPoints": [
            "Clearly distinguishes the core purpose of each hook.",
            "Uses precise terminology (functions vs. values)."
          ],
          "keyConcepts": [
            "useCallback",
            "useMemo",
            "Memoization",
            "Functions",
            "Values"
          ],
          "evaluationCriteria": [
            "Correctly identifies what each hook memoizes."
          ],
          "example": "",
          "tags": [
            "React Hooks",
            "Memoization"
          ],
          "prerequisites": [
            "React Hooks"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_callback_memo_2",
          "topic": "useCallback and useMemo",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React component:\n```typescript\nimport React, { useState, useCallback, memo } from 'react';\n\nconst ExpensiveCalculationDisplay = memo(({ calculate }) => {\n  console.log('ExpensiveCalculationDisplay rendered');\n  const result = calculate(100);\n  return <p>Calculated Result: {result}</p>;\n});\n\nfunction ParentComponent() {\n  const [counter, setCounter] = useState(0);\n  const [multiplier, setMultiplier] = useState(2);\n\n  const doCalculation = (num) => {\n    // Simulate expensive calculation\n    for (let i = 0; i < 1000000; i++) {}\n    return num * multiplier;\n  };\n\n  // Which line correctly uses useCallback to optimize doCalculation?\n  const memoizedCalculation = /* Line A */\n\n  return (\n    <div>\n      <button onClick={() => setCounter(counter + 1)}>Increment Counter ({counter})</button>\n      <button onClick={() => setMultiplier(multiplier + 1)}>Increment Multiplier ({multiplier})</button>\n      <ExpensiveCalculationDisplay calculate={memoizedCalculation} />\n    </div>\n  );\n}\n```\nWhich `useCallback` usage correctly memoizes `doCalculation` to prevent `ExpensiveCalculationDisplay` from unnecessary re-renders when only `counter` changes?",
          "answer": "`useCallback(() => (num) => { for (let i = 0; i < 1000000; i++) {}; return num * multiplier; }, [multiplier]);`",
          "options": [
            "`useCallback(doCalculation, []);`",
            "`useCallback(doCalculation, [counter]);`",
            "`useCallback(() => (num) => { for (let i = 0; i < 1000000; i++) {}; return num * multiplier; }, []);`",
            "`useCallback(() => (num) => { for (let i = 0; i < 1000000; i++) {}; return num * multiplier; }, [multiplier]);`"
          ],
          "analysisPoints": [
            "Tests understanding of `useCallback`'s first argument (the function itself).",
            "Assesses knowledge of dependency array and capturing correct variables.",
            "Highlights the importance of including all external dependencies (like `multiplier`) in the array.",
            "Differentiates between memoizing the function reference vs. its execution."
          ],
          "keyConcepts": [
            "useCallback",
            "Memoization",
            "Dependency Array",
            "React.memo",
            "Re-renders"
          ],
          "evaluationCriteria": [
            "Correctly constructs `useCallback` syntax.",
            "Identifies the necessary dependencies for the memoized function.",
            "Understands how `useCallback` works with `React.memo` to prevent re-renders."
          ],
          "example": "Option D is correct. `useCallback` expects a function to memoize. The `doCalculation` function uses `multiplier` from the component's scope, so `multiplier` *must* be included in the dependency array. If `multiplier` changes, `memoizedCalculation` needs to be re-created to use the new `multiplier` value. Options A and C use an empty dependency array, which would lead to a stale closure where `memoizedCalculation` always uses the initial `multiplier` value. Option B incorrectly includes `counter` in dependencies; `counter` is not used within `doCalculation`, so its changes should not invalidate `doCalculation`'s memoization.",
          "tags": [
            "React Hooks",
            "Performance",
            "useCallback",
            "Memoization"
          ],
          "prerequisites": [
            "React Hooks",
            "Dependency Array",
            "React.memo"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_callback_memo_3",
          "topic": "useCallback and useMemo",
          "level": "hard",
          "type": "open",
          "question": "You are building a data table component that displays a large dataset. The table has sorting, filtering, and pagination functionalities. Each row is rendered by a `TableRow` component, which is memoized using `React.memo`. Discuss how you would use `useMemo` and `useCallback` to optimize the performance of this data table, specifically addressing:\n1.  Memoizing the `processedData` (after filtering/sorting).\n2.  Memoizing the `onRowClick` handler passed to `TableRow`.\n3.  Potential pitfalls if dependencies are managed incorrectly for either hook.",
          "answer": "**1. Memoizing `processedData` with `useMemo`:**\n-   **How:** The data transformation (filtering, sorting, pagination) can be computationally expensive, especially for large datasets. This transformed data should be memoized using `useMemo`.\n    ```typescript\n    const processedData = useMemo(() => {\n      // Complex filtering, sorting, pagination logic here\n      let filtered = applyFilters(data, filters);\n      let sorted = applySorting(filtered, sortConfig);\n      let paginated = applyPagination(sorted, currentPage, itemsPerPage);\n      return paginated;\n    }, [data, filters, sortConfig, currentPage, itemsPerPage]);\n    ```\n-   **Why:** `useMemo` ensures that the `processedData` array is only recomputed when its dependencies (`data`, `filters`, `sortConfig`, `currentPage`, `itemsPerPage`) change. If only other states (e.g., `theme`) change, the expensive data processing is skipped, preventing unnecessary re-renders of the table and potentially its rows.\n\n**2. Memoizing `onRowClick` handler with `useCallback`:**\n-   **How:** The `onRowClick` function is passed as a prop to each `TableRow` component. Since `TableRow` is memoized with `React.memo`, if `onRowClick` is a new function reference on every parent render, all `TableRow` components would re-render unnecessarily.\n    ```typescript\n    const handleRowClick = useCallback((rowData) => {\n      // Logic to handle row click, e.g., open detail view\n      console.log('Row clicked:', rowData.id);\n      // If this handler depends on data that changes frequently, e.g., 'selectedRowId'\n      // it needs to be included in the dependencies, or handle it functionally.\n    }, []); // Add dependencies if this function uses values from parent scope that change\n    // e.g., [selectedRowId, otherDependency]\n    ```\n-   **Why:** `useCallback` ensures that `handleRowClick` maintains the same function reference across renders, as long as its dependencies don't change. This allows `React.memo` on `TableRow` to effectively skip re-renders, improving performance.\n\n**3. Potential Pitfalls with Incorrect Dependencies:**\n-   **Stale Closures (Missing Dependencies):** If a dependency is omitted from the dependency array, the memoized value (`useMemo`) or function (`useCallback`) will 'capture' an old value of that dependency from the render it was first created in. This leads to unexpected behavior where the logic operates on outdated data.\n    -   *Example (useCallback):* If `handleRowClick` used a `selectedRowId` state and `selectedRowId` was not in its dependencies `[]`, `handleRowClick` would always use the `selectedRowId` from the initial render, even if `selectedRowId` later changed.\n    -   *Example (useMemo):* If `processedData`'s dependencies were missing `filters`, the table would display outdated data even after filters change.\n-   **Over-Memoization (Too Many Dependencies/Unnecessary Memoization):** Including too many dependencies, or dependencies that change frequently, defeats the purpose of memoization. If the dependencies change on almost every render, the memoized value/function will be re-created just as often, adding the overhead of memoization without the benefit.\n    -   *Example:* Including a `timestamp` in `processedData` dependencies would cause it to recompute constantly.\n-   **Performance Degradation from `useMemo`/`useCallback` Overhead:** While minor, there is a cost associated with memoization (storing the memoized value/function and comparing dependencies). Overusing these hooks for trivial computations or functions that are not passed to memoized children can add unnecessary overhead without significant performance gains.\n\nEffective use of `useMemo` and `useCallback` requires careful consideration of dependencies and profiling to identify actual performance bottlenecks.",
          "analysisPoints": [
            "Provides concrete examples of applying `useMemo` for data transformation.",
            "Demonstrates `useCallback` for event handlers passed to memoized children.",
            "Thoroughly explains the critical pitfall of stale closures due to missing dependencies.",
            "Discusses the counter-intuitive pitfall of over-memoization.",
            "Emphasizes the need for correct dependency management and profiling."
          ],
          "keyConcepts": [
            "useCallback",
            "useMemo",
            "Memoization",
            "React.memo",
            "Performance Optimization",
            "Dependency Array",
            "Stale Closures",
            "Data Table"
          ],
          "evaluationCriteria": [
            "Ability to apply memoization hooks to a complex, real-world scenario (data table).",
            "Deep understanding of dependency array importance and pitfalls.",
            "Knowledge of how `useCallback`/`useMemo` interact with `React.memo`.",
            "Comprehensive discussion of benefits and potential issues."
          ],
          "example": "",
          "tags": [
            "React Hooks",
            "Performance",
            "Optimization",
            "Advanced",
            "Data Structures"
          ],
          "prerequisites": [
            "React Hooks",
            "React.memo",
            "State Management"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "expert"
        }
      ],
      "tasks": [
        {
          "id": "task_use_debug_value_1",
          "title": "Create a `useNetworkStatus` Hook with Debugging Info",
          "description": "\nImplement a custom React hook `useNetworkStatus` that determines if the user is online or offline. This hook should leverage the `navigator.onLine` API and listen for `online` and `offline` events on the `window` object.\n\n**Requirements:**\n1.  The hook should return a boolean: `true` if online, `false` if offline.\n2.  It should initialize its state based on `navigator.onLine`.\n3.  It must subscribe to `online` and `offline` events using `useEffect`.\n4.  Crucially, use `useDebugValue` to display the current network status ('Online' or 'Offline') in React DevTools when inspecting the hook.\n5.  Provide a simple functional component `NetworkStatusDisplay` that consumes this hook and displays the status.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect, useDebugValue } from 'react';\n\n// TODO: Implement the useNetworkStatus custom hook\nfunction useNetworkStatus() {\n  // Your implementation here\n  return true; // Placeholder\n}\n\nfunction NetworkStatusDisplay() {\n  const isOnline = useNetworkStatus();\n\n  return (\n    <div>\n      <p>Network Status: {isOnline ? 'Online' : 'Offline'}</p>\n    </div>\n  );\n}\n\n// To test, render <NetworkStatusDisplay /> and toggle your browser's network status in DevTools.\n",
          "solutionCode": "import React, { useState, useEffect, useDebugValue } from 'react';\n\nfunction useNetworkStatus() {\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n\n  useEffect(() => {\n    const handleOnline = () => setIsOnline(true);\n    const handleOffline = () => setIsOnline(false);\n\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []); // Empty dependency array means this effect runs once on mount\n\n  // Display status in React DevTools\n  useDebugValue(isOnline ? 'Online' : 'Offline');\n\n  return isOnline;\n}\n\nfunction NetworkStatusDisplay() {\n  const isOnline = useNetworkStatus();\n\n  return (\n    <div>\n      <h2>Network Status Monitor</h2>\n      <p>Your current network status is: <strong>{isOnline ? 'Online ' : 'Offline '}</strong></p>\n      <p>Check React DevTools to see the `useNetworkStatus` hook's debug value.</p>\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: Should display 'Online' if `navigator.onLine` is true.",
            "Transition to offline: Toggling browser network offline should update the display to 'Offline' and debug value.",
            "Transition to online: Toggling browser network online should update the display to 'Online' and debug value.",
            "Hook cleanup: Ensure event listeners are removed on unmount (implicit in `useEffect` return)."
          ],
          "hints": [
            "Remember that `useDebugValue` can only be called inside a custom hook.",
            "The `useEffect` hook is essential for managing side effects like event listeners, including cleanup.",
            "The `navigator.onLine` property provides the current network status."
          ],
          "tags": [
            "React Hooks",
            "Custom Hooks",
            "Debugging",
            "Browser APIs"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "React Hooks",
            "useEffect",
            "useState"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "useDebugValue",
            "useEffect",
            "navigator.onLine"
          ]
        },
        {
          "id": "task_prevent_unnecessary_updates_1",
          "title": "Optimize Class Component State Updates with Conditional `setState`",
          "description": "\nRefactor a given React class component to prevent unnecessary re-renders when a specific piece of state is updated with an identical value.\n\n**Requirements:**\n1.  You are provided with a `Counter` class component that updates a `count` and `message` state.\n2.  Modify the `updateCount` method to use the functional form of `this.setState`.\n3.  Inside the functional `setState`, implement logic to check if the `newCount` is the same as the `prevState.count`. If it is, return `null` to prevent a re-render.\n4.  Observe console logs to confirm that `render` is not called when `updateCount` is called with the current `count` value.\n\n**Component Structure:**\n```typescript\nimport React from 'react';\n\nclass Counter extends React.Component {\n  state = {\n    count: 0,\n    message: 'Welcome!'\n  };\n\n  updateCount = (newCount) => {\n    // TODO: Implement conditional setState here\n    this.setState({ count: newCount }); // Replace this line\n  };\n\n  updateMessage = (newMessage) => {\n    this.setState({ message: newMessage });\n  };\n\n  render() {\n    console.log('Counter component rendered!');\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <p>Message: {this.state.message}</p>\n        <button onClick={() => this.updateCount(this.state.count + 1)}>Increment Count</button>\n        <button onClick={() => this.updateCount(this.state.count)}>Set Same Count</button>\n        <button onClick={() => this.updateMessage('Hello World!')}>Change Message</button>\n      </div>\n    );\n  }\n}\n\n// Usage:\n// <Counter />\n```\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass Counter extends React.Component {\n  state = {\n    count: 0,\n    message: 'Welcome!'\n  };\n\n  updateCount = (newCount) => {\n    // TODO: Implement conditional setState here\n    this.setState({ count: newCount }); // Replace this line\n  };\n\n  updateMessage = (newMessage) => {\n    this.setState({ message: newMessage });\n  };\n\n  render() {\n    console.log('Counter component rendered!');\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <p>Message: {this.state.message}</p>\n        <button onClick={() => this.updateCount(this.state.count + 1)}>Increment Count</button>\n        <button onClick={() => this.updateCount(this.state.count)}>Set Same Count</button>\n        <button onClick={() => this.updateMessage('Hello World!')}>Change Message</button>\n      </div>\n    );\n  }\n}\n",
          "solutionCode": "import React from 'react';\n\nclass Counter extends React.Component {\n  state = {\n    count: 0,\n    message: 'Welcome!'\n  };\n\n  updateCount = (newCount) => {\n    this.setState(prevState => {\n      if (prevState.count === newCount) {\n        console.log(`Preventing re-render: count ${newCount} is same as ${prevState.count}`);\n        return null; // Prevent update and re-render\n      } else {\n        console.log(`Updating count to ${newCount}`);\n        return { count: newCount }; // Allow update and re-render\n      }\n    });\n  };\n\n  updateMessage = (newMessage) => {\n    this.setState({ message: newMessage });\n  };\n\n  render() {\n    console.log('Counter component rendered!');\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <p>Message: {this.state.message}</p>\n        <button onClick={() => this.updateCount(this.state.count + 1)}>Increment Count</button>\n        <button onClick={() => this.updateCount(this.state.count)}>Set Same Count</button>\n        <button onClick={() => this.updateMessage('Hello World!')}>Change Message</button>\n      </div>\n    );\n  }\n}\n",
          "testCases": [
            "Click 'Increment Count': `render` should be called, `count` increases.",
            "Click 'Set Same Count' immediately after 'Increment Count': `render` should NOT be called again.",
            "Click 'Set Same Count' when `count` is 0: `render` should NOT be called.",
            "Click 'Change Message': `render` should be called, `message` changes, `count` remains the same and doesn't trigger extra re-renders through `updateCount` logic if not explicitly called."
          ],
          "hints": [
            "Recall the two forms of `this.setState` and which one takes a function as an argument.",
            "To prevent a re-render from a functional `setState`, what special value should you return?",
            "Use `console.log` statements inside the `render` method and inside your `setState` function to observe the flow."
          ],
          "tags": [
            "React",
            "Class Components",
            "Performance",
            "setState",
            "Optimization"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Class Components",
            "setState"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "setState",
            "Re-renders",
            "Performance Optimization"
          ]
        },
        {
          "id": "task_use_callback_use_memo_1",
          "title": "Optimize a Filterable List with `useCallback` and `useMemo`",
          "description": "\nRefactor a functional React component that displays a list of items to use `useMemo` for filtering/sorting and `useCallback` for event handlers. The goal is to prevent unnecessary re-renders of the list items and the overall list when irrelevant state changes.\n\n**Requirements:**\n1.  **`useMemo` for filtered items**: The `filteredItems` array should only be recomputed when `items` or `filterText` change. This array is used by `ItemList`.\n2.  **`useCallback` for event handlers**: The `handleFilterChange` and `handleAddItem` functions should be memoized. These functions are passed as props to child components (`FilterInput` and `AddItemForm` respectively), which might be wrapped with `React.memo` (assume they are, for the purpose of this exercise).\n3.  Demonstrate the optimization by adding `console.log` statements inside the `filterItems` function and `ItemList` component's render, and observing when they execute.\n\n**Initial Component Structure:**\n```typescript\nimport React, { useState } from 'react';\n\n// Assume these are memoized child components\nconst FilterInput = React.memo(({ onFilterChange }) => {\n  console.log('FilterInput rendered');\n  return (\n    <input\n      type=\"text\"\n      placeholder=\"Filter items...\"\n      onChange={(e) => onFilterChange(e.target.value)}\n    />\n  );\n});\n\nconst AddItemForm = React.memo(({ onAddItem }) => {\n  console.log('AddItemForm rendered');\n  const [newItem, setNewItem] = useState('');\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (newItem) {\n      onAddItem(newItem);\n      setNewItem('');\n    }\n  };\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        value={newItem}\n        onChange={(e) => setNewItem(e.target.value)}\n        placeholder=\"New item name\"\n      />\n      <button type=\"submit\">Add Item</button>\n    </form>\n  );\n});\n\nconst ItemList = React.memo(({ items }) => {\n  console.log('ItemList rendered');\n  return (\n    <ul>\n      {items.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  );\n});\n\nlet nextId = 3;\nfunction FilterableList() {\n  const [items, setItems] = useState([\n    { id: 1, name: 'Apple' },\n    { id: 2, name: 'Banana' },\n  ]);\n  const [filterText, setFilterText] = useState('');\n  const [extraState, setExtraState] = useState(0); // This state should not cause re-renders of filtered list/handlers\n\n  const handleFilterChange = (text) => {\n    setFilterText(text);\n  };\n\n  const handleAddItem = (itemName) => {\n    setItems(prevItems => [...prevItems, { id: nextId++, name: itemName }]);\n  };\n\n  const filterItems = (items, text) => {\n    console.log('Filtering items...');\n    return items.filter(item => item.name.toLowerCase().includes(text.toLowerCase()));\n  };\n\n  const filteredItems = filterItems(items, filterText);\n\n  return (\n    <div>\n      <h1>My Filterable List</h1>\n      <FilterInput onFilterChange={handleFilterChange} />\n      <AddItemForm onAddItem={handleAddItem} />\n      <button onClick={() => setExtraState(extraState + 1)}>Update Extra State ({extraState})</button>\n      <ItemList items={filteredItems} />\n    </div>\n  );\n}\n\n// Usage: <FilterableList />\n```\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\n\nconst FilterInput = React.memo(({ onFilterChange }) => {\n  console.log('FilterInput rendered');\n  return (\n    <input\n      type=\"text\"\n      placeholder=\"Filter items...\"\n      onChange={(e) => onFilterChange(e.target.value)}\n    />\n  );\n});\n\nconst AddItemForm = React.memo(({ onAddItem }) => {\n  console.log('AddItemForm rendered');\n  const [newItem, setNewItem] = useState('');\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (newItem) {\n      onAddItem(newItem);\n      setNewItem('');\n    }\n  };\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        value={newItem}\n        onChange={(e) => setNewItem(e.target.value)}\n        placeholder=\"New item name\"\n      />\n      <button type=\"submit\">Add Item</button>\n    </form>\n  );\n});\n\nconst ItemList = React.memo(({ items }) => {\n  console.log('ItemList rendered');\n  return (\n    <ul>\n      {items.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  );\n});\n\nlet nextId = 3;\nfunction FilterableList() {\n  const [items, setItems] = useState([\n    { id: 1, name: 'Apple' },\n    { id: 2, name: 'Banana' },\n  ]);\n  const [filterText, setFilterText] = useState('');\n  const [extraState, setExtraState] = useState(0); // This state should not cause re-renders of filtered list/handlers\n\n  const handleFilterChange = (text) => {\n    setFilterText(text);\n  };\n\n  const handleAddItem = (itemName) => {\n    setItems(prevItems => [...prevItems, { id: nextId++, name: itemName }]);\n  };\n\n  const filterItems = (items, text) => {\n    console.log('Filtering items...');\n    return items.filter(item => item.name.toLowerCase().includes(text.toLowerCase()));\n  };\n\n  const filteredItems = filterItems(items, filterText);\n\n  return (\n    <div>\n      <h1>My Filterable List</h1>\n      <FilterInput onFilterChange={handleFilterChange} />\n      <AddItemForm onAddItem={handleAddItem} />\n      <button onClick={() => setExtraState(extraState + 1)}>Update Extra State ({extraState})</button>\n      <ItemList items={filteredItems} />\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState, useMemo, useCallback } from 'react';\n\nconst FilterInput = React.memo(({ onFilterChange }) => {\n  console.log('FilterInput rendered');\n  return (\n    <input\n      type=\"text\"\n      placeholder=\"Filter items...\"\n      onChange={(e) => onFilterChange(e.target.value)}\n    />\n  );\n});\n\nconst AddItemForm = React.memo(({ onAddItem }) => {\n  console.log('AddItemForm rendered');\n  const [newItem, setNewItem] = useState('');\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (newItem) {\n      onAddItem(newItem);\n      setNewItem('');\n    }\n  };\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        value={newItem}\n        onChange={(e) => setNewItem(e.target.value)}\n        placeholder=\"New item name\"\n      />\n      <button type=\"submit\">Add Item</button>\n    </form>\n  );\n});\n\nconst ItemList = React.memo(({ items }) => {\n  console.log('ItemList rendered');\n  return (\n    <ul>\n      {items.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  );\n});\n\nlet nextId = 3;\nfunction FilterableList() {\n  const [items, setItems] = useState([\n    { id: 1, name: 'Apple' },\n    { id: 2, name: 'Banana' },\n  ]);\n  const [filterText, setFilterText] = useState('');\n  const [extraState, setExtraState] = useState(0); // This state should not cause re-renders of filtered list/handlers\n\n  // Memoize handleFilterChange to maintain reference for FilterInput\n  const handleFilterChange = useCallback((text) => {\n    setFilterText(text);\n  }, []); // No dependencies, as setFilterText is stable\n\n  // Memoize handleAddItem to maintain reference for AddItemForm\n  const handleAddItem = useCallback((itemName) => {\n    setItems(prevItems => [...prevItems, { id: nextId++, name: itemName }]);\n  }, []); // No dependencies, as setItems is stable and nextId is a mutable outside scope for simplicity here (in real app, consider useRef or state for nextId)\n\n  // Memoize the expensive filtering operation\n  const filteredItems = useMemo(() => {\n    console.log('Filtering items...');\n    return items.filter(item => item.name.toLowerCase().includes(filterText.toLowerCase()));\n  }, [items, filterText]); // Re-run only when items or filterText change\n\n  return (\n    <div>\n      <h1>My Filterable List</h1>\n      <FilterInput onFilterChange={handleFilterChange} />\n      <AddItemForm onAddItem={handleAddItem} />\n      <button onClick={() => setExtraState(extraState + 1)}>Update Extra State ({extraState})</button>\n      <ItemList items={filteredItems} />\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: `FilterInput`, `AddItemForm`, `ItemList` render, `Filtering items...` runs once.",
            "Type in filter input: `FilterInput` and `ItemList` render, `Filtering items...` runs again (as `filterText` changes).",
            "Click 'Add Item': `AddItemForm` (due to local state), `ItemList` render, `Filtering items...` runs again (as `items` changes).",
            "Click 'Update Extra State': Only `FilterableList` renders, `FilterInput`, `AddItemForm`, `ItemList` should NOT re-render. `Filtering items...` should NOT run.",
            "Type in filter, then clear filter: Observe `Filtering items...` runs only when text changes.",
            "Add multiple items: Observe `Filtering items...` runs each time `items` state is updated."
          ],
          "hints": [
            "`useMemo` and `useCallback` both take a dependency array as their second argument.",
            "Think about what values inside your memoized function or computation can change and need to trigger a re-memoization.",
            "For `setX` functions returned by `useState`, their references are guaranteed to be stable, so they typically don't need to be in dependency arrays.",
            "Focus on wrapping the actual computation logic for `useMemo` and the function definitions for `useCallback`."
          ],
          "tags": [
            "React Hooks",
            "Performance",
            "Optimization",
            "useCallback",
            "useMemo",
            "React.memo"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Hooks",
            "useState",
            "React.memo"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Memoization",
            "Stale Closures",
            "Dependency Array",
            "Functional Components"
          ]
        }
      ]
    }
  },
  {
    "id": "ec766fc1-c053-48c6-b515-3b9d04a5d79c",
    "startLine": 8400,
    "endLine": 8499,
    "processedDate": "2025-06-17T10:41:16.974Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_fetching_data_hooks",
          "title": "Fetching Data with Hooks (useEffect)",
          "content": "In React functional components, the `useEffect` hook is commonly used to perform side effects, including data fetching. When `useEffect` is provided with an empty dependency array (`[]`), the effect runs only once after the initial render, mimicking the behavior of `componentDidMount` in class components. This is crucial for data fetching to prevent infinite loops.\n\nWhen fetching data, it's common to use `async/await` syntax for handling asynchronous operations. However, the function passed to `useEffect` cannot be directly `async` because it must return either nothing or a cleanup function. Therefore, the `async` function for data fetching is typically defined inside the `useEffect` callback and then immediately invoked.\n\nPopular libraries like `axios` or the built-in `fetch` API are used to make HTTP requests. After the data is successfully fetched, it's stored in the component's state using a state setter function (e.g., `setData`), triggering a re-render with the new data.\n\n### Key Concepts\n-   `useEffect` Hook: For performing side effects in functional components.\n-   Dependency Array (`[]`): Controls when the effect runs. An empty array means it runs once on mount.\n-   Asynchronous Operations: Handling promises with `async/await`.\n-   State Management: Updating component state with fetched data.",
          "examples": [
            {
              "id": "example_fetching_data_hooks_1",
              "title": "Basic Data Fetching with useEffect and Axios",
              "code": "import React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nfunction DataFetcher() {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const result = await axios('http://hn.algolia.com/api/v1/search?query=react');\n        setData(result.data);\n        setError(null);\n      } catch (err) {\n        setError(err);\n        setData(null);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, []); // Empty dependency array ensures this runs once on mount\n\n  if (loading) return <div>Loading data...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  if (!data || !data.hits) return <div>No data found.</div>;\n\n  return (\n    <div>\n      <h2>Fetched Data</h2>\n      <ul>\n        {data.hits.map((item) => (\n          <li key={item.objectID}>{item.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default DataFetcher;",
              "explanation": "This example demonstrates fetching data using `useEffect` with an empty dependency array. An inner `async` function `fetchData` is defined and immediately called to handle the asynchronous API request. State variables `data`, `loading`, and `error` are used to manage the different states of the data fetching process, providing a robust user experience.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_useEffect_dependency_array",
            "question_async_in_useEffect",
            "question_data_fetching_alternatives",
            "question_error_handling_fetch"
          ],
          "relatedTasks": [
            "task_implement_data_fetching_component"
          ],
          "tags": [
            "React Hooks",
            "useEffect",
            "Data Fetching",
            "Async/Await",
            "Axios",
            "Side Effects"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_async_await",
            "react_state",
            "react_functional_components"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_custom_hooks",
            "react_global_state"
          ]
        },
        {
          "id": "theory_react_performance_optimization",
          "title": "React Performance Optimization Techniques",
          "content": "Optimizing React application performance involves reducing unnecessary re-renders and efficiently managing component updates. Several built-in mechanisms and best practices can be employed.\n\n## React.memo\n`React.memo` is a higher-order component (HOC) introduced in React 16.6 that memoizes a functional component. It works by preventing the component from re-rendering if its props have not changed since the last render. This is similar to `PureComponent` for class components but for functional components. By default, `React.memo` performs a shallow comparison of props. You can provide a custom comparison function as the second argument to `React.memo` to define your own comparison logic for more complex props.\n\n## shouldComponentUpdate\n`shouldComponentUpdate` is a lifecycle method available only in React class components. It allows you to control whether a component should re-render or not. This method receives `nextProps` and `nextState` as arguments and should return `true` if the component needs to update, and `false` otherwise. Returning `false` prevents the `render` method and subsequent lifecycle methods (`componentDidUpdate`) from being called, effectively skipping the re-render. This method performs a shallow comparison by default if used with `React.PureComponent`.\n\n## Window Resize Listener Management\nWhen working with browser events like `resize`, `scroll`, or `mousemove`, it's crucial to manage event listeners properly to prevent memory leaks and performance issues. Event listeners should be added when the component mounts (e.g., in `componentDidMount` for class components or `useEffect` with an empty dependency array for functional components) and removed when the component unmounts (e.g., in `componentWillUnmount` for class components or the cleanup function returned by `useEffect`). Failure to remove listeners can lead to the listener callback being invoked even after the component is removed from the DOM.\n\n### Key Concepts\n-   **Memoization**: Caching computation results to avoid redundant calculations.\n-   **Higher-Order Component (HOC)**: A function that takes a component and returns a new component with enhanced capabilities.\n-   **Lifecycle Methods**: Special methods in class components that run at specific points in a component's life.\n-   **Side Effect Cleanup**: Removing subscriptions or event listeners when a component is no longer needed.\n-   **Throttling/Debouncing**: Techniques to limit the rate at which a function is called, especially for frequently occurring events.",
          "examples": [
            {
              "id": "example_react_memo",
              "title": "Using React.memo for Functional Component Optimization",
              "code": "import React from 'react';\n\nconst ExpensiveComponent = ({ value, onClick }) => {\n  console.log('Rendering ExpensiveComponent...');\n  // Simulate an expensive calculation\n  const calculatedResult = value * 2;\n  return (\n    <div onClick={onClick}>\n      <p>Value: {value}</p>\n      <p>Calculated Result: {calculatedResult}</p>\n    </div>\n  );\n};\n\n// Memoize the component to prevent re-renders if props don't change\nconst MemoizedExpensiveComponent = React.memo(ExpensiveComponent);\n\n// Example with custom comparison function (for complex props)\nconst AnotherMemoizedComponent = React.memo((props) => {\n  /* render using props */\n}, (prevProps, nextProps) => {\n  // Only re-render if `id` prop changes\n  return prevProps.id === nextProps.id;\n});\n\nexport default MemoizedExpensiveComponent;",
              "explanation": "This example shows how `React.memo` is used to wrap a functional component. `MemoizedExpensiveComponent` will only re-render if its `value` or `onClick` props shallowly change. The second example demonstrates a custom comparison function, allowing more granular control over when the component re-renders.",
              "language": "typescript"
            },
            {
              "id": "example_should_component_update",
              "title": "Using shouldComponentUpdate for Class Component Optimization",
              "code": "import React from 'react';\n\nclass DataDisplay extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Only re-render if the 'id' prop changes\n    // This prevents re-renders if other props change but 'id' remains the same\n    console.log(`shouldComponentUpdate: prevId=${this.props.id}, nextId=${nextProps.id}`);\n    return nextProps.id !== this.props.id || nextState.data !== this.state.data;\n  }\n\n  render() {\n    console.log('Rendering DataDisplay...');\n    return (\n      <div>\n        <h3>Data ID: {this.props.id}</h3>\n        <p>Content: {this.props.content}</p>\n      </div>\n    );\n  }\n}\n\nexport default DataDisplay;",
              "explanation": "`shouldComponentUpdate` is a powerful way to manually control re-renders in class components. Here, the component only re-renders if the `id` prop or the `data` state (if it had any) has changed, preventing updates for other unrelated prop changes. This can significantly improve performance for components with stable props.",
              "language": "typescript"
            },
            {
              "id": "example_window_resize_listener",
              "title": "Managing Window Resize Listener in Class Component",
              "code": "import React from 'react';\n\nclass WindowDimensions extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      width: window.innerWidth,\n      height: window.innerHeight,\n    };\n    this.updateDimensions = this.updateDimensions.bind(this); // Bind 'this'\n  }\n\n  componentDidMount() {\n    // Add event listener when component mounts\n    window.addEventListener('resize', this.updateDimensions);\n    console.log('Window resize listener added.');\n  }\n\n  componentWillUnmount() {\n    // Remove event listener when component unmounts to prevent memory leaks\n    window.removeEventListener('resize', this.updateDimensions);\n    console.log('Window resize listener removed.');\n  }\n\n  updateDimensions() {\n    this.setState({\n      width: window.innerWidth,\n      height: window.innerHeight,\n    });\n    console.log(`Dimensions updated: ${window.innerWidth}x${window.innerHeight}`);\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Window Width: {this.state.width}px</p>\n        <p>Window Height: {this.state.height}px</p>\n      </div>\n    );\n  }\n}\n\nexport default WindowDimensions;",
              "explanation": "This example demonstrates the correct way to add and remove a window resize event listener in a class component. The listener is added in `componentDidMount` and, critically, removed in `componentWillUnmount` to prevent memory leaks. The `updateDimensions` method updates the component's state, causing a re-render with the new dimensions. The `bind(this)` in the constructor ensures `this` context is correct.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_memo_purpose",
            "question_should_component_update_vs_react_memo",
            "question_sCU_return_value",
            "question_event_listener_cleanup",
            "question_throttling_debouncing"
          ],
          "relatedTasks": [
            "task_optimize_component_with_memo",
            "task_optimize_class_component_sCU",
            "task_responsive_component_with_hooks"
          ],
          "tags": [
            "React Performance",
            "React.memo",
            "shouldComponentUpdate",
            "HOC",
            "Lifecycle Methods",
            "Event Handling",
            "Memory Leaks",
            "Optimization"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_state",
            "react_props"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_custom_hooks_performance",
            "react_profiling"
          ]
        },
        {
          "id": "theory_set_state_callbacks_and_updaters",
          "title": "setState Callback and Function Updater",
          "content": "The `setState` method in React class components is asynchronous and offers different ways to update state, each with specific use cases and performance implications.\n\n## setState Callback\nThe `setState` method accepts an optional second argument: a callback function. This function executes *after* the state has been updated and the component has re-rendered. This is useful when you need to perform an action immediately after a state change has been applied to the DOM, such as interacting with the DOM based on the new state or logging the updated state.\n\n**Performance Considerations for Callbacks:** If this callback function is passed as a prop to child components, it might cause those child components to re-render unnecessarily if not handled carefully. To prevent potential issues with `this` context and ensure optimal performance when passing methods as props, it's generally preferred to bind `this` in the constructor or use public class fields syntax (arrow functions as class properties) instead of binding directly in `render` or creating anonymous functions on the fly.\n\n## Using setState with Function Updater\nWhen the new state depends on the previous state, it's crucial to use the functional form of `setState`. This form accepts a function as its first argument. This function receives the `prevState` and `props` as arguments, ensuring you are working with the most up-to-date state and props values. This prevents race conditions that can occur when `setState` calls are batched or asynchronous, especially when multiple `setState` calls are made in quick succession or when state updates rely on values that might change before the `setState` call is processed.\n\n### Key Concepts\n-   **Asynchronous State Updates**: `setState` does not immediately update the state.\n-   **State Callback**: Executes after state update and re-render.\n-   **Context Binding**: Ensuring `this` refers to the component instance.\n-   **Public Class Fields Syntax**: A modern JavaScript feature for defining class properties and methods (including arrow functions) directly within the class body, automatically binding `this`.\n-   **Functional setState**: Safely updating state based on previous state and props.",
          "examples": [
            {
              "id": "example_set_state_callback",
              "title": "setState with Callback Function",
              "code": "import React from 'react';\n\nclass NameUpdater extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { name: 'Alice' };\n    this.updateName = this.updateName.bind(this);\n  }\n\n  updateName() {\n    this.setState(\n      { name: 'John' },\n      () => {\n        // This callback runs AFTER the state has been updated and component re-rendered\n        console.log('The name state has updated and component re-rendered. Current name:', this.state.name);\n        // You could perform DOM manipulations here if needed\n      }\n    );\n    console.log('setState called, but state might not be updated yet:', this.state.name); // Will likely log 'Alice'\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Current Name: {this.state.name}</p>\n        <button onClick={this.updateName}>Update Name</button>\n      </div>\n    );\n  }\n}\n\nexport default NameUpdater;",
              "explanation": "This example shows the `setState` callback in action. The `console.log` inside the callback confirms that the state (`this.state.name`) has been updated. The `console.log` immediately after `setState` call shows that `setState` is asynchronous, and the state might not be immediately updated.",
              "language": "typescript"
            },
            {
              "id": "example_functional_set_state",
              "title": "setState with Function Updater (prevState and props)",
              "code": "import React from 'react';\n\nclass Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  // Correct way to update state when new state depends on previous state\n  incrementCount = () => { // Using public class fields for auto-binding\n    this.setState((prevState, props) => ({\n      count: prevState.count + (props.increment || 1)\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.incrementCount}>Increment</button>\n      </div>\n    );\n  }\n}\n\nexport default Counter;",
              "explanation": "This example demonstrates the functional form of `setState`. It's used to increment a counter, ensuring that the `count` update is based on the most recent `prevState.count` value, even if `setState` calls are batched or multiple updates occur rapidly. The `incrementCount` method uses public class fields syntax, so `this` is automatically bound.",
              "language": "typescript"
            },
            {
              "id": "example_binding_this",
              "title": "Binding 'this' for Class Methods",
              "code": "import React from 'react';\n\nclass MyButton extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { clicked: false };\n    // Method 1: Bind in the constructor (most common and performant for class components)\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  // Method 2: Public class fields syntax (arrow function as class property)\n  // handleClick = () => {\n  //   this.setState({ clicked: true });\n  //   console.log('Button clicked (public class field)');\n  // };\n\n  handleClick() {\n    this.setState({ clicked: true });\n    console.log('Button clicked (bound in constructor)');\n  }\n\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        {this.state.clicked ? 'Clicked!' : 'Click Me'}\n      </button>\n    );\n  }\n}\n\nexport default MyButton;",
              "explanation": "This example illustrates the two preferred ways to bind `this` to class methods in React: binding in the constructor and using public class fields syntax. Both ensure that `this` inside `handleClick` correctly refers to the component instance when the method is passed as an event handler.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_set_state_async",
            "question_set_state_callback_purpose",
            "question_functional_set_state",
            "question_binding_this_methods"
          ],
          "relatedTasks": [
            "task_implement_counter_functional_set_state",
            "task_set_state_callback_logger"
          ],
          "tags": [
            "React State",
            "setState",
            "Callbacks",
            "Functional Updates",
            "Performance",
            "Class Components",
            "This Binding"
          ],
          "technology": "React",
          "prerequisites": [
            "react_state",
            "javascript_this_context"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "complex_state_management",
            "optimizing_event_handlers"
          ]
        },
        {
          "id": "theory_styling_in_react",
          "title": "Styling in React: Inline Styles and Merging",
          "content": "React offers several ways to style components, with inline styles being one of the most basic approaches. While powerful, they also have specific syntax requirements and considerations.\n\n## Inline Styles with Vendor Prefixes\nIn React, inline styles are applied using a JavaScript object where CSS property names are camelCased (e.g., `backgroundColor` instead of `background-color`). Property values are typically strings, but for numeric values like `width` or `padding`, you can also use numbers, which React will automatically convert to pixel values.\n\nWhen dealing with vendor prefixes (e.g., `-webkit-`, `-ms-`), it's crucial to note their capitalization: `Webkit` uses a capital 'W', while `ms` uses a lowercase 'm' (`msTransform`). This is because the JavaScript style object properties follow a specific convention for cross-browser compatibility. React handles adding 'px' for numeric values of certain properties, but for properties like `transform` which take specific string values, you need to provide the full string, including units and prefixes.\n\n## Merging Styles\nWhile the provided markdown briefly mentions 'Merging Styles' without detail, a common scenario in React is needing to combine multiple style objects. This is typically done using the spread operator (`...`) to merge objects. The order of merging is important, as properties in later objects will override properties in earlier objects if there are conflicts. This allows for creating base styles that can be overridden or extended by specific component styles or dynamic styles based on props or state.\n\n### Key Concepts\n-   **JavaScript Style Objects**: CSS properties are camelCased.\n-   **Vendor Prefixes**: Specific capitalization rules (`Webkit`, `ms`).\n-   **Dynamic Styles**: Applying styles based on component state or props.\n-   **Style Merging**: Combining multiple style objects using object spread syntax.",
          "examples": [
            {
              "id": "example_inline_styles_vendor_prefixes",
              "title": "Inline Styles with Vendor Prefixes",
              "code": "import React from 'react';\n\nfunction TransformBox() {\n  const boxStyle = {\n    width: 100,\n    height: 100,\n    backgroundColor: 'lightblue',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    color: 'white',\n    fontWeight: 'bold',\n    // Note the capital 'W' in WebkitTransform and lowercase 'm' in msTransform\n    transform: 'rotate(90deg)',\n    WebkitTransform: 'rotate(90deg)', // For Webkit browsers (Chrome, Safari, older Opera)\n    msTransform: 'rotate(90deg)'     // For Internet Explorer\n  };\n\n  return (\n    <div style={boxStyle}>\n      Rotated\n    </div>\n  );\n}\n\nexport default TransformBox;",
              "explanation": "This example demonstrates applying inline styles with vendor prefixes. Notice how CSS properties like `background-color` become `backgroundColor` (camelCase). For `transform`, specific vendor-prefixed properties like `WebkitTransform` and `msTransform` are used, respecting their unique capitalization rules in the JavaScript style object. Numeric values like `width` and `height` are automatically interpreted as 'px'.",
              "language": "typescript"
            },
            {
              "id": "example_merging_styles",
              "title": "Merging Multiple Style Objects",
              "code": "import React from 'react';\n\nfunction MergedStyledComponent({ isActive }) {\n  const baseStyle = {\n    padding: '10px',\n    margin: '5px',\n    border: '1px solid gray',\n    borderRadius: '5px',\n  };\n\n  const activeStyle = {\n    backgroundColor: 'lightgreen',\n    borderColor: 'green',\n    fontWeight: 'bold',\n  };\n\n  const mergedStyle = {\n    ...baseStyle,\n    ...(isActive ? activeStyle : {}), // Conditionally apply activeStyle\n    color: 'navy', // This will override 'color' if present in baseStyle or activeStyle\n  };\n\n  return (\n    <div style={mergedStyle}>\n      This component is {isActive ? 'active' : 'inactive'}.\n    </div>\n  );\n}\n\nexport default MergedStyledComponent;",
              "explanation": "This example shows how to merge style objects using the object spread syntax (`...`). `baseStyle` provides common properties, and `activeStyle` is conditionally spread based on the `isActive` prop. Properties defined later in the spread order (like `color: 'navy'`) will override earlier ones. This pattern is common for composing styles.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_inline_style_camel_case",
            "question_inline_style_limitations",
            "question_vendor_prefix_capitalization",
            "question_merge_styles_precedence"
          ],
          "relatedTasks": [
            "task_dynamic_inline_styling",
            "task_merge_style_utility"
          ],
          "tags": [
            "React Styling",
            "Inline Styles",
            "CSS-in-JS",
            "Vendor Prefixes",
            "Style Merging",
            "CSS"
          ],
          "technology": "React",
          "prerequisites": [
            "html_css_basics",
            "javascript_objects"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "requiredFor": [
            "css_modules",
            "styled_components"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_useEffect_dependency_array",
          "topic": "Fetching Data with Hooks",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of the empty dependency array `[]` in a `useEffect` hook used for data fetching?",
          "answer": "It ensures the effect runs only once after the initial render, similar to `componentDidMount` in class components, preventing re-runs on every render.",
          "options": [],
          "analysisPoints": [
            "Understanding of `useEffect` lifecycle.",
            "Significance of the dependency array.",
            "Comparison with class component lifecycle methods."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation",
            "Completeness of analogy"
          ],
          "example": "",
          "tags": [
            "React Hooks",
            "useEffect",
            "Data Fetching"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_async_in_useEffect",
          "topic": "Fetching Data with Hooks",
          "level": "medium",
          "type": "open",
          "question": "Explain why the `useEffect` callback function itself cannot be directly marked as `async`, and how you would typically handle `async/await` operations inside `useEffect` for data fetching.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Understanding `useEffect`'s return value requirement (cleanup function or nothing).",
            "How an `async` function implicitly returns a Promise, violating `useEffect`'s contract.",
            "Correct pattern: defining an `async` function inside `useEffect` and immediately invoking it.",
            "Importance of proper cleanup if asynchronous operation can be cancelled."
          ],
          "keyConcepts": [
            "useEffect",
            "Async/Await",
            "Promises",
            "Side Effects",
            "Cleanup"
          ],
          "evaluationCriteria": [
            "Clarity of explanation regarding `useEffect` return value.",
            "Correctness of the proposed pattern.",
            "Mention of potential cleanup for ongoing promises."
          ],
          "example": "```typescript\nuseEffect(() => {\n  const fetchData = async () => {\n    // ... fetch logic ...\n  };\n  fetchData();\n  // Optional: return cleanup function for ongoing promises\n  // return () => { controller.abort(); };\n}, []);\n```",
          "tags": [
            "React Hooks",
            "useEffect",
            "Async/Await",
            "Data Fetching"
          ],
          "prerequisites": [
            "javascript_async_await",
            "react_hooks_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_data_fetching_alternatives",
          "topic": "Fetching Data with Hooks",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a common or recommended alternative/enhancement for data fetching in React applications compared to basic `useEffect` and `axios`?",
          "answer": "Using `localStorage` directly as the primary data source for all API calls.",
          "options": [
            "Using `React Query` or `SWR` libraries.",
            "Implementing a custom `useFetch` hook.",
            "Integrating with `Redux Thunk` or `Redux Saga` for global state management.",
            "Using `localStorage` directly as the primary data source for all API calls."
          ],
          "analysisPoints": [
            "`React Query`/`SWR` are dedicated data fetching libraries for caching, revalidation, etc.",
            "Custom hooks encapsulate fetching logic for reusability.",
            "`Redux Thunk`/`Saga` manage async actions in a global state store.",
            "`localStorage` is for client-side persistence, not typically a primary data source for real-time API calls due to lack of freshness guarantees and limited size."
          ],
          "keyConcepts": [
            "Data Fetching",
            "State Management",
            "Client-side Caching",
            "React Hooks"
          ],
          "evaluationCriteria": [
            "Knowledge of ecosystem solutions for data fetching.",
            "Understanding the purpose of different storage/state management mechanisms."
          ],
          "example": "The question tests your understanding of various patterns and tools available in the React ecosystem for handling data fetching beyond a basic `useEffect` call. While `localStorage` can be used for caching, it's not a primary mechanism for fetching fresh data from an API.",
          "tags": [
            "React Ecosystem",
            "Data Fetching",
            "State Management",
            "Performance"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_memo_purpose",
          "topic": "React Performance Optimization",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of `React.memo`?",
          "answer": "To memoize a functional component, preventing it from re-rendering if its props have not shallowly changed, thereby optimizing performance.",
          "options": [],
          "analysisPoints": [
            "Definition of `React.memo`.",
            "Its role in performance optimization.",
            "Distinction between `React.memo` for functional components and `PureComponent` for class components."
          ],
          "keyConcepts": [
            "React.memo",
            "Memoization",
            "Performance Optimization",
            "Functional Components",
            "HOC"
          ],
          "evaluationCriteria": [
            "Conciseness and accuracy"
          ],
          "example": "",
          "tags": [
            "React Performance",
            "React.memo"
          ],
          "prerequisites": [
            "react_functional_components"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_should_component_update_vs_react_memo",
          "topic": "React Performance Optimization",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast `shouldComponentUpdate` and `React.memo`. When would you choose one over the other?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Identify `shouldComponentUpdate` as a class component lifecycle method.",
            "Identify `React.memo` as a higher-order component for functional components.",
            "Both serve the purpose of preventing unnecessary re-renders based on prop/state changes.",
            "Default behavior: `shouldComponentUpdate` requires manual implementation of comparison; `React.memo` performs shallow comparison by default.",
            "Custom comparison: `shouldComponentUpdate` allows full control; `React.memo` accepts a custom comparison function as a second argument.",
            "Choice depends on component type (class vs. functional) and specific optimization needs (e.g., deep comparison)."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "React.memo",
            "Performance Optimization",
            "Class Components",
            "Functional Components",
            "Shallow Comparison",
            "Lifecycle Methods",
            "HOC"
          ],
          "evaluationCriteria": [
            "Clear differentiation between class and functional component applicability.",
            "Accurate description of default and custom comparison behaviors.",
            "Insightful discussion of use case scenarios."
          ],
          "example": "```typescript\n// Class Component\nclass MyClassComp extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    return nextProps.value !== this.props.value;\n  }\n  render() { /* ... */ }\n}\n\n// Functional Component\nconst MyFuncComp = React.memo(({ value }) => {\n  /* ... */\n});\n\n// Functional Component with custom comparison\nconst MyFuncCompCustom = React.memo((props) => {\n  /* ... */\n}, (prevProps, nextProps) => {\n  return prevProps.id === nextProps.id && prevProps.data.length === nextProps.data.length;\n});\n```",
          "tags": [
            "React Performance",
            "React.memo",
            "shouldComponentUpdate"
          ],
          "prerequisites": [
            "react_components",
            "react_props",
            "react_state"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_sCU_return_value",
          "topic": "React Performance Optimization",
          "level": "easy",
          "type": "mcq",
          "question": "What should the `shouldComponentUpdate(nextProps, nextState)` method return to prevent a class component from re-rendering?",
          "answer": "`false`",
          "options": [
            "`true`",
            "`false`",
            "`null`",
            "`undefined`"
          ],
          "analysisPoints": [
            "The explicit boolean return value controls the re-render.",
            "`true` means re-render, `false` means skip re-render."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Re-rendering",
            "Class Components"
          ],
          "evaluationCriteria": [
            "Correctness of boolean return value"
          ],
          "example": "```typescript\nshouldComponentUpdate(nextProps, nextState) {\n  if (nextProps.count === this.props.count && nextState.loading === this.state.loading) {\n    return false; // Prevent re-render if count and loading haven't changed\n  }\n  return true;\n}\n```",
          "tags": [
            "React Performance",
            "shouldComponentUpdate"
          ],
          "prerequisites": [
            "react_class_components"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_event_listener_cleanup",
          "topic": "React Performance Optimization",
          "level": "medium",
          "type": "open",
          "question": "Why is it important to remove event listeners in React components when they unmount? Provide examples for both class components and functional components.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Preventing memory leaks: Listeners keep references to components, preventing garbage collection.",
            "Avoiding unexpected behavior: Listeners on unmounted components can cause errors or updates on non-existent DOM nodes.",
            "Class component: `componentDidMount` for adding, `componentWillUnmount` for removing.",
            "Functional component: `useEffect` for adding, returning a cleanup function for removing."
          ],
          "keyConcepts": [
            "Event Listeners",
            "Memory Leaks",
            "Component Lifecycle",
            "useEffect Cleanup",
            "componentDidMount",
            "componentWillUnmount"
          ],
          "evaluationCriteria": [
            "Clear explanation of memory leak prevention.",
            "Correct usage of lifecycle methods/hooks for setup and teardown."
          ],
          "example": "```typescript\n// Class Component\nclass MyClassComp extends React.Component {\n  componentDidMount() {\n    window.addEventListener('scroll', this.handleScroll);\n  }\n  componentWillUnmount() {\n    window.removeEventListener('scroll', this.handleScroll);\n  }\n  handleScroll = () => { /* ... */ };\n}\n\n// Functional Component\nfunction MyFuncComp() {\n  useEffect(() => {\n    const handleScroll = () => { /* ... */ };\n    window.addEventListener('scroll', handleScroll);\n    return () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, []);\n}\n```",
          "tags": [
            "React Performance",
            "Event Handling",
            "Memory Leaks",
            "Component Lifecycle"
          ],
          "prerequisites": [
            "javascript_events",
            "react_components"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_throttling_debouncing",
          "topic": "React Performance Optimization",
          "level": "hard",
          "type": "open",
          "question": "When handling frequently firing browser events (like `resize`, `scroll`, `mousemove`), what techniques can be used to improve performance, and how do they differ?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Identify throttling and debouncing as key techniques.",
            "**Throttling**: Limits the rate at which a function can be called. It ensures the function is called at most once within a specified time period. Useful for animations, continuous updates.",
            "**Debouncing**: Delays function execution until after a certain period of inactivity. The function is only called once the event has stopped firing for the specified time. Useful for search suggestions, input validation.",
            "Explain typical implementations (e.g., using `setTimeout` and `clearTimeout`, or utility libraries like Lodash).",
            "Discuss use cases for each."
          ],
          "keyConcepts": [
            "Throttling",
            "Debouncing",
            "Event Performance",
            "Performance Optimization",
            "Browser Events",
            "setTimeout",
            "clearTimeout"
          ],
          "evaluationCriteria": [
            "Accurate definitions of throttling and debouncing.",
            "Clear distinction between their behaviors and use cases.",
            "Mention of implementation approach or common libraries."
          ],
          "example": "```typescript\n// Debounce example\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n\n// Throttle example\nfunction throttle(func, delay) {\n  let inThrottle;\n  return function(...args) {\n    if (!inThrottle) {\n      func.apply(this, args);\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), delay);\n    }\n  };\n}\n```",
          "tags": [
            "React Performance",
            "JavaScript",
            "Event Handling",
            "Optimization Algorithms"
          ],
          "prerequisites": [
            "javascript_timers",
            "javascript_functions"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_set_state_async",
          "topic": "setState Callback and Function Updater",
          "level": "easy",
          "type": "flashcard",
          "question": "Is `setState` synchronous or asynchronous?",
          "answer": "Asynchronous (it does not immediately update `this.state` or trigger a re-render; React may batch updates).",
          "options": [],
          "analysisPoints": [
            "Understanding of `setState`'s asynchronous nature.",
            "Implications for immediately reading `this.state` after calling `setState`."
          ],
          "keyConcepts": [
            "setState",
            "Asynchronous",
            "State Management"
          ],
          "evaluationCriteria": [
            "Correctness of answer",
            "Brief explanation"
          ],
          "example": "",
          "tags": [
            "React State",
            "setState"
          ],
          "prerequisites": [
            "react_state_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_set_state_callback_purpose",
          "topic": "setState Callback and Function Updater",
          "level": "medium",
          "type": "open",
          "question": "When and why would you use the optional callback function in `setState`? What are its performance considerations if passed as a prop?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Purpose: Execute code *after* state update and re-render are complete.",
            "Use cases: DOM manipulations, logging the updated state, subsequent state updates dependent on the current one.",
            "Performance consideration: If not correctly bound (`.bind(this)` in constructor or public class fields), passing a new function reference as a prop on every render can cause unnecessary re-renders in child components (though React often optimizes this with shallow comparison in `PureComponent`/`React.memo`)."
          ],
          "keyConcepts": [
            "setState",
            "Callbacks",
            "Asynchronous State",
            "Performance",
            "Function Binding"
          ],
          "evaluationCriteria": [
            "Accurate description of callback timing.",
            "Relevant use cases.",
            "Understanding of potential performance pitfalls and their remedies (binding)."
          ],
          "example": "```typescript\nthis.setState({ data: newData }, () => {\n  console.log('State updated and component re-rendered:', this.state.data);\n  // Potentially call a function that depends on the updated DOM or state\n});\n```",
          "tags": [
            "React State",
            "setState",
            "Callbacks",
            "Performance"
          ],
          "prerequisites": [
            "react_state",
            "javascript_this_context"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_set_state",
          "topic": "setState Callback and Function Updater",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React class component. Which `setState` call correctly updates the `count` state when the new `count` depends on the previous `count`?",
          "answer": "Option B",
          "options": [
            "Option A: `this.setState({ count: this.state.count + 1 });`",
            "Option B: `this.setState((prevState, props) => ({ count: prevState.count + props.increment }));`",
            "Option C: `this.state.count++; this.setState({});`",
            "Option D: `this.setState(prevState => prevState.count + 1);`"
          ],
          "analysisPoints": [
            "Option A is incorrect because `this.state.count` might be stale due to asynchronous batching.",
            "Option B is the correct functional updater form, receiving `prevState` and `props`.",
            "Option C directly mutates state, which is an anti-pattern in React.",
            "Option D is also a functional form but expects an object return, not just a value."
          ],
          "keyConcepts": [
            "setState",
            "Functional Updates",
            "Immutability",
            "State Management",
            "Batching"
          ],
          "evaluationCriteria": [
            "Correct identification of functional `setState`.",
            "Understanding of why direct state mutation is wrong.",
            "Awareness of batching and stale closures."
          ],
          "example": "The functional form of `setState` is crucial when state updates depend on the previous state. `this.setState((prevState, props) => ({ count: prevState.count + props.increment }))` ensures that you are always working with the most up-to-date state and props, preventing race conditions that can occur with the object form, especially when multiple `setState` calls are batched.",
          "tags": [
            "React State",
            "setState",
            "Functional Updates"
          ],
          "prerequisites": [
            "react_state_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_binding_this_methods",
          "topic": "setState Callback and Function Updater",
          "level": "medium",
          "type": "flashcard",
          "question": "What are the two recommended ways to bind `this` to class methods in React to ensure they have the correct context when passed as event handlers?",
          "answer": "1. Binding in the constructor (`this.methodName = this.methodName.bind(this);`).\n2. Using public class fields syntax (arrow functions as class properties: `methodName = () => { ... };`).",
          "options": [],
          "analysisPoints": [
            "Constructor binding: Performed once, efficient.",
            "Public class fields: Concise, automatically binds `this`, but newer syntax.",
            "Avoid binding in `render` or using anonymous arrow functions in `render` as it creates a new function on every render, potentially causing performance issues for child components."
          ],
          "keyConcepts": [
            "This Binding",
            "Class Components",
            "Event Handlers",
            "Performance",
            "JavaScript `this`"
          ],
          "evaluationCriteria": [
            "Accuracy and completeness of methods",
            "Mention of performance implications"
          ],
          "example": "",
          "tags": [
            "React Class Components",
            "JavaScript",
            "This Context"
          ],
          "prerequisites": [
            "javascript_this_context"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_inline_style_camel_case",
          "topic": "Styling in React",
          "level": "easy",
          "type": "flashcard",
          "question": "Why are CSS properties like `background-color` written as `backgroundColor` when using inline styles in React?",
          "answer": "Because inline styles in React are JavaScript objects, and JavaScript object properties cannot contain hyphens directly. CamelCase is used as a convention to represent multi-word CSS property names.",
          "options": [],
          "analysisPoints": [
            "Understanding JavaScript object property naming rules.",
            "React's convention for CSS properties in JS objects."
          ],
          "keyConcepts": [
            "Inline Styles",
            "CSS-in-JS",
            "JavaScript Objects",
            "CamelCase"
          ],
          "evaluationCriteria": [
            "Correct explanation of JS object syntax requirement"
          ],
          "example": "",
          "tags": [
            "React Styling",
            "Inline Styles"
          ],
          "prerequisites": [
            "javascript_objects_basics",
            "css_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_inline_style_limitations",
          "topic": "Styling in React",
          "level": "medium",
          "type": "open",
          "question": "What are some limitations or drawbacks of using inline styles extensively in React, and what are common alternatives?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "**Limitations**: No pseudo-classes (`:hover`), no media queries, no keyframe animations, lack of cascade/inheritance, increased verbosity for complex styles, potential for `!important` abuse, poorer separation of concerns than traditional CSS (though this is debated).",
            "**Alternatives**: CSS Modules, Styled Components, Emotion, SCSS/Sass with Webpack loaders, utility-first CSS frameworks (Tailwind CSS)."
          ],
          "keyConcepts": [
            "Inline Styles",
            "CSS-in-JS",
            "Styling Approaches",
            "Pseudo-classes",
            "Media Queries"
          ],
          "evaluationCriteria": [
            "Comprehensive list of limitations.",
            "Diverse set of alternative styling solutions."
          ],
          "example": "```typescript\n// Inline styles cannot easily handle hover effects:\n<button style={{ backgroundColor: 'blue', ':hover': { backgroundColor: 'darkblue' } }}>\n  Hover Me (Doesn't work directly)\n</button>\n\n// With Styled Components (an alternative):\nimport styled from 'styled-components';\nconst StyledButton = styled.button`\n  background-color: blue;\n  &:hover {\n    background-color: darkblue;\n  }\n`;\n```",
          "tags": [
            "React Styling",
            "Inline Styles",
            "CSS-in-JS",
            "Best Practices"
          ],
          "prerequisites": [
            "html_css_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_vendor_prefix_capitalization",
          "topic": "Styling in React",
          "level": "medium",
          "type": "mcq",
          "question": "When applying inline styles in React that require vendor prefixes, which of the following is the correct capitalization for `webkit-transform` and `ms-transform`?",
          "answer": "WebkitTransform and msTransform",
          "options": [
            "webkitTransform and MS-Transform",
            "WebkitTransform and MsTransform",
            "WebkitTransform and msTransform",
            "webkitTransform and ms-Transform"
          ],
          "analysisPoints": [
            "Understanding React's specific handling of vendor prefixes in inline style objects.",
            "The unique capitalization of 'Webkit' (capital W) and 'ms' (lowercase m)."
          ],
          "keyConcepts": [
            "Inline Styles",
            "Vendor Prefixes",
            "CamelCase",
            "CSS"
          ],
          "evaluationCriteria": [
            "Correct identification of specific capitalization rules"
          ],
          "example": "```typescript\n<div style={{\n  WebkitTransform: 'scale(1.2)',\n  msTransform: 'scale(1.2)'\n}} />\n```",
          "tags": [
            "React Styling",
            "Inline Styles",
            "CSS"
          ],
          "prerequisites": [
            "css_vendor_prefixes"
          ],
          "complexity": 4,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_merge_styles_precedence",
          "topic": "Styling in React",
          "level": "medium",
          "type": "open",
          "question": "When merging multiple inline style objects in React using the spread operator, how is property precedence determined? Provide an example.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Properties from objects spread later in the order will override properties from objects spread earlier if they have the same key.",
            "This is standard JavaScript object merging behavior.",
            "Demonstrate with an example where a property is defined in multiple objects being merged."
          ],
          "keyConcepts": [
            "Inline Styles",
            "Style Merging",
            "Object Spread Syntax",
            "Property Precedence",
            "JavaScript Objects"
          ],
          "evaluationCriteria": [
            "Correct explanation of object spread precedence.",
            "Clear and concise code example."
          ],
          "example": "```typescript\nconst baseStyles = { color: 'blue', fontSize: '16px' };\nconst overrideStyles = { color: 'red', fontWeight: 'bold' };\n\nconst finalStyles = { ...baseStyles, ...overrideStyles };\n// finalStyles will be: { color: 'red', fontSize: '16px', fontWeight: 'bold' }\n// 'color' from overrideStyles overwrites 'color' from baseStyles.\n\n<div style={finalStyles}>Hello</div>\n```",
          "tags": [
            "React Styling",
            "JavaScript",
            "Object Manipulation"
          ],
          "prerequisites": [
            "javascript_objects_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_data_fetching_component",
          "title": "Implement a Data Fetching Component with Loading and Error States",
          "description": "\nCreate a React functional component that fetches data from a public API (`https://jsonplaceholder.typicode.com/posts`) when it mounts. The component should:\n\n1.  Display a 'Loading...' message while data is being fetched.\n2.  Display an 'Error: [error message]' if the fetch fails.\n3.  Render a list of post titles if the fetch is successful.\n4.  Use `useEffect` for data fetching and `useState` for managing data, loading, and error states.\n5.  Ensure proper cleanup if the component unmounts while fetching (optional but good practice).\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\nfunction PostList() {\n  const [posts, setPosts] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // TODO: Implement data fetching logic here\n    // Use an inner async function for fetching\n    // Handle loading, success, and error states\n    // Remember to clean up if using AbortController (optional for this task)\n\n  }, []);\n\n  if (loading) {\n    return <div>Loading posts...</div>;\n  }\n\n  if (error) {\n    return <div>Error: {error.message}</div>;\n  }\n\n  return (\n    <div>\n      <h1>Posts</h1>\n      <ul>\n        {posts.map(post => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default PostList;",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction PostList() {\n  const [posts, setPosts] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    const signal = abortController.signal;\n\n    const fetchPosts = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        const response = await fetch('https://jsonplaceholder.typicode.com/posts', { signal });\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        setPosts(data);\n      } catch (err) {\n        if (err.name === 'AbortError') {\n          console.log('Fetch aborted');\n        } else {\n          setError(err);\n        }\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchPosts();\n\n    return () => {\n      abortController.abort(); // Cleanup: abort ongoing fetch request\n    };\n  }, []);\n\n  if (loading) {\n    return <div>Loading posts...</div>;\n  }\n\n  if (error) {\n    return <div>Error: {error.message}</div>;\n  }\n\n  return (\n    <div>\n      <h1>Posts</h1>\n      <ul>\n        {posts.map(post => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default PostList;",
          "testCases": [
            "Component should display 'Loading posts...' initially.",
            "After successful fetch, component should display a list of post titles (e.g., at least 10 items).",
            "If the API endpoint is changed to an invalid one (e.g., `https://jsonplaceholder.typicode.com/invalid`), an 'Error: ...' message should be displayed.",
            "Test cleanup: If the component is unmounted immediately after starting fetch (simulated), no `setState` warning should occur for unmounted component (if `AbortController` or similar logic is implemented).",
            "Ensure `key` prop is used for list items."
          ],
          "hints": [
            "Remember that `useEffect`'s callback cannot be `async` directly. Define an `async` function inside it and call it.",
            "Use `fetch` API or `axios` for the HTTP request.",
            "Handle potential network errors or non-200 HTTP responses.",
            "Consider `AbortController` for cleaning up pending fetch requests if the component unmounts."
          ],
          "tags": [
            "React Hooks",
            "Data Fetching",
            "useEffect",
            "useState",
            "Error Handling",
            "Loading States",
            "API Integration"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_hooks_basics",
            "javascript_async_await",
            "web_api_fetch"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_fetching_data_hooks"
          ]
        },
        {
          "id": "task_optimize_component_with_memo",
          "title": "Optimize a Functional Component with React.memo",
          "description": "\nCreate two functional React components: a parent component (`ParentComponent`) and a child component (`ChildComponent`).\n\n`ChildComponent` should accept a `value` prop and `ParentComponent` should have a state `count` that updates every second using `setInterval`.\n\nYour task is to:\n\n1.  Initially, observe `ChildComponent` re-rendering every time `ParentComponent`'s `count` state updates, even if `ChildComponent`'s `value` prop doesn't change.\n2.  Apply `React.memo` to `ChildComponent` to prevent unnecessary re-renders when only `ParentComponent`'s internal state (that doesn't affect `ChildComponent`'s props) changes.\n3.  Verify the optimization using `console.log` messages in `ChildComponent`'s render.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// ChildComponent - DO NOT MODIFY ITS INTERNAL LOGIC, ONLY WRAP IT\nconst ChildComponent = ({ value }) => {\n  console.log('ChildComponent re-rendered with value:', value);\n  return (\n    <div style={{ padding: '10px', border: '1px solid gray', margin: '10px' }}>\n      <h3>Child Component</h3>\n      <p>Received Value: {value}</p>\n    </div>\n  );\n};\n\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n  const [staticValue] = useState('This is a static prop for child');\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setCount(prevCount => prevCount + 1);\n    }, 1000);\n\n    return () => clearInterval(intervalId);\n  }, []);\n\n  return (\n    <div style={{ border: '2px solid blue', padding: '20px' }}>\n      <h2>Parent Component</h2>\n      <p>Parent Count: {count}</p>\n      {/* TODO: Render ChildComponent here. Apply React.memo for optimization. */}\n      <ChildComponent value={staticValue} />\n    </div>\n  );\n}\n\nexport default ParentComponent;",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// ChildComponent - DO NOT MODIFY ITS INTERNAL LOGIC, ONLY WRAP IT\nconst ChildComponent = ({ value }) => {\n  console.log('ChildComponent re-rendered with value:', value);\n  return (\n    <div style={{ padding: '10px', border: '1px solid gray', margin: '10px' }}>\n      <h3>Child Component</h3>\n      <p>Received Value: {value}</p>\n    </div>\n  );\n};\n\n// Apply React.memo to optimize ChildComponent\nconst MemoizedChildComponent = React.memo(ChildComponent);\n\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n  const [staticValue] = useState('This is a static prop for child');\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setCount(prevCount => prevCount + 1);\n    }, 1000);\n\n    return () => clearInterval(intervalId);\n  }, []);\n\n  return (\n    <div style={{ border: '2px solid blue', padding: '20px' }}>\n      <h2>Parent Component</h2>\n      <p>Parent Count: {count}</p>\n      {/* Render the memoized ChildComponent */}\n      <MemoizedChildComponent value={staticValue} />\n    </div>\n  );\n}\n\nexport default ParentComponent;",
          "testCases": [
            "Initially, `ChildComponent` should log 'ChildComponent re-rendered...' on every parent render.",
            "After applying `React.memo`, `ChildComponent` should only log 'ChildComponent re-rendered...' once (on initial mount), even as `ParentComponent`'s `count` updates.",
            "If you pass a new prop value to `MemoizedChildComponent` (e.g., `value={count % 2 === 0 ? 'Even' : 'Odd'}`), it should re-render only when that specific prop's value changes."
          ],
          "hints": [
            "Remember that `React.memo` is a Higher-Order Component (HOC) that wraps your functional component.",
            "Place the `console.log` inside the `ChildComponent`'s render function to observe its re-renders."
          ],
          "tags": [
            "React Performance",
            "React.memo",
            "Functional Components",
            "Optimization",
            "HOC"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_functional_components",
            "react_state",
            "react_hooks"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_performance_optimization"
          ]
        },
        {
          "id": "task_optimize_class_component_sCU",
          "title": "Optimize a Class Component with shouldComponentUpdate",
          "description": "\nCreate a React class component `ProductDisplay` that receives `productId` and `productName` as props. Implement `shouldComponentUpdate` to prevent unnecessary re-renders.\n\n`ProductDisplay` should only re-render if:\n1.  The `productId` prop changes.\n2.  The `productName` prop changes.\n\nSimulate a parent component that passes `productId` and `productName`, but also other props (`lastUpdated`) that change frequently. Verify that `ProductDisplay` only re-renders when its relevant props (`productId`, `productName`) actually change, and not when `lastUpdated` changes.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass ProductDisplay extends React.Component {\n  // TODO: Implement shouldComponentUpdate here\n  shouldComponentUpdate(nextProps, nextState) {\n    // Only re-render if relevant props change\n    // return true; // Default behavior, causing unnecessary re-renders\n  }\n\n  render() {\n    console.log('ProductDisplay re-rendered for product ID:', this.props.productId);\n    const { productId, productName, lastUpdated } = this.props;\n    return (\n      <div style={{ padding: '15px', border: '1px solid green', margin: '10px' }}>\n        <h3>Product Details (Class Component)</h3>\n        <p>ID: {productId}</p>\n        <p>Name: {productName}</p>\n        <p>Last Updated (irrelevant prop): {lastUpdated}</p>\n      </div>\n    );\n  }\n}\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      currentProductId: 'A101',\n      currentProductName: 'Laptop',\n      lastUpdated: new Date().toLocaleTimeString(),\n    };\n  }\n\n  componentDidMount() {\n    setInterval(() => {\n      this.setState({\n        lastUpdated: new Date().toLocaleTimeString(),\n      });\n    }, 500);\n\n    setTimeout(() => {\n      this.setState({ currentProductName: 'Gaming Laptop' }); // Only product name changes\n    }, 3000);\n\n    setTimeout(() => {\n      this.setState({ currentProductId: 'B202', currentProductName: 'Tablet' }); // Both change\n    }, 6000);\n  }\n\n  render() {\n    const { currentProductId, currentProductName, lastUpdated } = this.state;\n    return (\n      <div>\n        <h1>App Container</h1>\n        <ProductDisplay\n          productId={currentProductId}\n          productName={currentProductName}\n          lastUpdated={lastUpdated} // This prop changes frequently\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;",
          "solutionCode": "import React from 'react';\n\nclass ProductDisplay extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Only re-render if productId or productName changes\n    return (nextProps.productId !== this.props.productId ||\n            nextProps.productName !== this.props.productName);\n  }\n\n  render() {\n    console.log('ProductDisplay re-rendered for product ID:', this.props.productId);\n    const { productId, productName, lastUpdated } = this.props;\n    return (\n      <div style={{ padding: '15px', border: '1px solid green', margin: '10px' }}>\n        <h3>Product Details (Class Component)</h3>\n        <p>ID: {productId}</p>\n        <p>Name: {productName}</p>\n        <p>Last Updated (irrelevant prop): {lastUpdated}</p>\n      </div>\n    );\n  }\n}\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      currentProductId: 'A101',\n      currentProductName: 'Laptop',\n      lastUpdated: new Date().toLocaleTimeString(),\n    };\n  }\n\n  componentDidMount() {\n    setInterval(() => {\n      this.setState({\n        lastUpdated: new Date().toLocaleTimeString(),\n      });\n    }, 500);\n\n    setTimeout(() => {\n      this.setState({ currentProductName: 'Gaming Laptop' }); // Only product name changes\n    }, 3000);\n\n    setTimeout(() => {\n      this.setState({ currentProductId: 'B202', currentProductName: 'Tablet' }); // Both change\n    }, 6000);\n  }\n\n  render() {\n    const { currentProductId, currentProductName, lastUpdated } = this.state;\n    return (\n      <div>\n        <h1>App Container</h1>\n        <ProductDisplay\n          productId={currentProductId}\n          productName={currentProductName}\n          lastUpdated={lastUpdated}\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;",
          "testCases": [
            "Initially, `ProductDisplay` should re-render once on mount.",
            "After mount, `ProductDisplay` should NOT re-render every 500ms when only `lastUpdated` prop changes (check console logs).",
            "At 3 seconds, `ProductDisplay` should re-render once when `productName` changes.",
            "At 6 seconds, `ProductDisplay` should re-render once when both `productId` and `productName` change."
          ],
          "hints": [
            "`shouldComponentUpdate` receives `nextProps` and `nextState`.",
            "You need to compare `nextProps.productId` with `this.props.productId` and `nextProps.productName` with `this.props.productName`.",
            "Return `true` if any of these relevant props have changed, `false` otherwise."
          ],
          "tags": [
            "React Performance",
            "shouldComponentUpdate",
            "Class Components",
            "Optimization",
            "Lifecycle Methods"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_class_components",
            "react_props",
            "react_state"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_performance_optimization"
          ]
        },
        {
          "id": "task_responsive_component_with_hooks",
          "title": "Create a Responsive Component Using `useEffect` for Window Dimensions",
          "description": "\nImplement a React functional component `WindowSizeMonitor` that displays the current window width and height.\n\nYour task is to:\n\n1.  Use `useState` to store the window dimensions.\n2.  Use `useEffect` to add a `resize` event listener to the `window` object when the component mounts.\n3.  Implement a cleanup function within `useEffect` to remove the event listener when the component unmounts.\n4.  Update the component's state (`width`, `height`) whenever the window is resized.\n5.  Optionally, implement debouncing to limit the frequency of state updates during rapid resizing.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\nfunction WindowSizeMonitor() {\n  const [width, setWidth] = useState(window.innerWidth);\n  const [height, setHeight] = useState(window.innerHeight);\n\n  useEffect(() => {\n    const updateDimensions = () => {\n      // TODO: Update width and height state here\n      console.log('Window resized!'); // Observe how often this logs\n    };\n\n    // TODO: Add event listener\n\n    return () => {\n      // TODO: Remove event listener for cleanup\n    };\n  }, []); // Empty dependency array for componentDidMount-like behavior\n\n  return (\n    <div style={{ border: '2px dashed purple', padding: '20px', margin: '20px' }}>\n      <h2>Window Dimensions</h2>\n      <p>Width: {width}px</p>\n      <p>Height: {height}px</p>\n    </div>\n  );\n}\n\nexport default WindowSizeMonitor;",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction WindowSizeMonitor() {\n  const [width, setWidth] = useState(window.innerWidth);\n  const [height, setHeight] = useState(window.innerHeight);\n\n  useEffect(() => {\n    // Debounce function (simplified for demonstration)\n    const debounce = (func, delay) => {\n      let timeoutId;\n      return function() {\n        const context = this;\n        const args = arguments;\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => func.apply(context, args), delay);\n      };\n    };\n\n    const updateDimensions = () => {\n      setWidth(window.innerWidth);\n      setHeight(window.innerHeight);\n      console.log('Window resized and state updated!');\n    };\n\n    // Debounced version of the update function\n    const debouncedUpdateDimensions = debounce(updateDimensions, 200);\n\n    window.addEventListener('resize', debouncedUpdateDimensions);\n\n    return () => {\n      window.removeEventListener('resize', debouncedUpdateDimensions);\n      console.log('Window resize listener removed.');\n    };\n  }, []); // Empty dependency array ensures listener is added/removed once\n\n  return (\n    <div style={{ border: '2px dashed purple', padding: '20px', margin: '20px' }}>\n      <h2>Window Dimensions</h2>\n      <p>Width: {width}px</p>\n      <p>Height: {height}px</p>\n    </div>\n  );\n}\n\nexport default WindowSizeMonitor;",
          "testCases": [
            "Initial render should display current window width and height.",
            "Resizing the browser window should update the displayed dimensions.",
            "Observe console logs: `updateDimensions` should not fire excessively during continuous resizing (if debouncing is implemented).",
            "Verify cleanup: If the component is conditionally rendered and then unmounted, the listener should be removed (check console for 'Window resize listener removed.')."
          ],
          "hints": [
            "The `useEffect` hook with an empty dependency array (`[]`) behaves like `componentDidMount` and `componentWillUnmount` combined.",
            "The function returned by `useEffect` is the cleanup function.",
            "For debouncing, you can implement a simple `debounce` utility function or use a library like Lodash.",
            "Make sure to update `useState` setters (`setWidth`, `setHeight`) inside the event handler."
          ],
          "tags": [
            "React Hooks",
            "useEffect",
            "Event Handling",
            "Window API",
            "Responsive Design",
            "Performance",
            "Debouncing"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_hooks_basics",
            "javascript_events",
            "javascript_timers"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_react_performance_optimization"
          ]
        },
        {
          "id": "task_implement_counter_functional_set_state",
          "title": "Implement a Counter with Functional setState",
          "description": "\nCreate a React class component `SafeCounter` that manages a `count` state. Implement a button that increments the `count` by a given `increment` prop value.\n\nYour task is to:\n\n1.  Use the functional form of `setState` to update the `count`.\n2.  Demonstrate why the functional form is safer by simulating multiple rapid updates (e.g., calling the increment function multiple times in quick succession or with `setTimeout(0)`).\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\nclass SafeCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  increment = () => {\n    const { increment = 1 } = this.props;\n    // TODO: Implement state update using the functional form of setState\n    // Hint: The functional form receives prevState and props as arguments.\n    // Call it multiple times to demonstrate safety.\n    this.setState({ count: this.state.count + increment }); // This is the unsafe way for demonstration\n\n    // Simulate rapid updates\n    // this.setState({ count: this.state.count + increment });\n    // this.setState({ count: this.state.count + increment });\n  };\n\n  render() {\n    return (\n      <div style={{ border: '2px solid orange', padding: '20px', margin: '20px' }}>\n        <h2>Safe Counter</h2>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment by {this.props.increment || 1}</button>\n      </div>\n    );\n  }\n}\n\nexport default SafeCounter;",
          "solutionCode": "import React from 'react';\n\nclass SafeCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  increment = () => {\n    const { increment = 1 } = this.props;\n    // Correct: Use the functional form when new state depends on previous state\n    this.setState((prevState, props) => ({\n      count: prevState.count + (props.increment || 1)\n    }));\n\n    // Simulate rapid updates to demonstrate safety against race conditions\n    // These calls will be batched, but the functional updater ensures correct count\n    this.setState((prevState, props) => ({\n      count: prevState.count + (props.increment || 1)\n    }));\n    this.setState((prevState, props) => ({\n      count: prevState.count + (props.increment || 1)\n    }));\n\n    console.log('setState calls made. Current count (might be stale):', this.state.count);\n  };\n\n  render() {\n    return (\n      <div style={{ border: '2px solid orange', padding: '20px', margin: '20px' }}>\n        <h2>Safe Counter</h2>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment by {this.props.increment || 1}</button>\n      </div>\n    );\n  }\n}\n\nexport default SafeCounter;",
          "testCases": [
            "Clicking the 'Increment' button once should increase the count by `props.increment` (or 1 if not provided).",
            "If you uncomment the multiple `this.setState` calls in `increment`, the counter should still update correctly (e.g., if `increment` is 1, three calls should result in +3). Compare this to the behavior of the object-based `setState` when called multiple times rapidly.",
            "Ensure the component correctly uses `this.props.increment` within the functional updater."
          ],
          "hints": [
            "The functional form of `setState` is `this.setState((prevState, props) => ({ newState }));`",
            "The `prevState` argument guarantees you're working with the most up-to-date state."
          ],
          "tags": [
            "React State",
            "setState",
            "Functional Updates",
            "Class Components",
            "Concurrency"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_state_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_set_state_callbacks_and_updaters"
          ]
        },
        {
          "id": "task_set_state_callback_logger",
          "title": "Demonstrate setState Callback for Logging Updated State",
          "description": "\nCreate a React class component `StateLogger` with a state variable `message` and a button that updates this message.\n\nYour task is to:\n\n1.  Update the `message` state using `setState`.\n2.  Use the `setState` callback function to `console.log` the *updated* `message` state immediately after it has been applied and the component re-rendered.\n3.  Also, add a `console.log` right after the `setState` call (but outside the callback) to demonstrate the asynchronous nature of `setState` (i.e., it might log the old state value).\n",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\n\nclass StateLogger extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { message: 'Initial Message' };\n  }\n\n  updateMessage = () => {\n    const newMessage = 'Updated Message: ' + new Date().toLocaleTimeString();\n\n    // TODO: Call setState with a new message and a callback function\n    this.setState({ message: newMessage }); // This is incomplete\n\n    // TODO: Add a console.log here to show state before callback\n    console.log('State immediately after setState call:', this.state.message);\n  };\n\n  render() {\n    return (\n      <div style={{ border: '2px solid cadetblue', padding: '20px', margin: '20px' }}>\n        <h2>State Logger</h2>\n        <p>Current Message: {this.state.message}</p>\n        <button onClick={this.updateMessage}>Update Message</button>\n      </div>\n    );\n  }\n}\n\nexport default StateLogger;",
          "solutionCode": "import React from 'react';\n\nclass StateLogger extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { message: 'Initial Message' };\n  }\n\n  updateMessage = () => {\n    const newMessage = 'Updated Message: ' + new Date().toLocaleTimeString();\n\n    this.setState(\n      { message: newMessage },\n      () => {\n        // This callback executes AFTER state is updated and re-render occurs\n        console.log('State inside setState callback (updated):', this.state.message);\n      }\n    );\n\n    // This console.log executes IMMEDIATELY, before the state is updated\n    console.log('State immediately after setState call (might be stale):', this.state.message);\n  };\n\n  render() {\n    return (\n      <div style={{ border: '2px solid cadetblue', padding: '20px', margin: '20px' }}>\n        <h2>State Logger</h2>\n        <p>Current Message: {this.state.message}</p>\n        <button onClick={this.updateMessage}>Update Message</button>\n      </div>\n    );\n  }\n}\n\nexport default StateLogger;",
          "testCases": [
            "Click the 'Update Message' button.",
            "Observe the console output. The `console.log` immediately after `setState` should show the *old* message.",
            "The `console.log` inside the `setState` callback should show the *newly updated* message."
          ],
          "hints": [
            "The `setState` method has an optional second argument which is a callback function.",
            "This callback function is guaranteed to run after the state update has been processed and the component has re-rendered."
          ],
          "tags": [
            "React State",
            "setState",
            "Callbacks",
            "Asynchronous",
            "Class Components"
          ],
          "timeEstimate": 20,
          "prerequisites": [
            "react_state_basics"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "theory_set_state_callbacks_and_updaters"
          ]
        },
        {
          "id": "task_dynamic_inline_styling",
          "title": "Apply Dynamic Inline Styles with Vendor Prefixes",
          "description": "\nCreate a React functional component `DynamicBox` that renders a `div` element.\n\nYour task is to:\n\n1.  Apply inline styles to the `div` to give it a fixed `width`, `height`, and `backgroundColor`.\n2.  Add a `transform` property to rotate the box by `90deg`.\n3.  Crucially, include the necessary vendor prefixes (`WebkitTransform`, `msTransform`) for the `transform` property, paying attention to their exact capitalization.\n4.  Optionally, add a state variable (e.g., `isRotated`) and a button to toggle the rotation between `0deg` and `90deg` to make the styling dynamic.\n",
          "difficulty": "easy",
          "startingCode": "import React, { useState } from 'react';\n\nfunction DynamicBox() {\n  const [isRotated, setIsRotated] = useState(false);\n\n  const boxStyle = {\n    width: 100,\n    height: 100,\n    backgroundColor: 'coral',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    color: 'white',\n    fontWeight: 'bold',\n    // TODO: Add transform and its vendor-prefixed versions here\n    // The angle should be dynamic based on isRotated state\n    transform: isRotated ? 'rotate(90deg)' : 'rotate(0deg)',\n  };\n\n  const toggleRotation = () => {\n    setIsRotated(prev => !prev);\n  };\n\n  return (\n    <div style={{ padding: '20px', margin: '20px', border: '1px solid black' }}>\n      <div style={boxStyle}>\n        {isRotated ? 'Rotated' : 'Static'}\n      </div>\n      <button onClick={toggleRotation} style={{ marginTop: '10px' }}>\n        Toggle Rotation\n      </button>\n    </div>\n  );\n}\n\nexport default DynamicBox;",
          "solutionCode": "import React, { useState } from 'react';\n\nfunction DynamicBox() {\n  const [isRotated, setIsRotated] = useState(false);\n\n  const rotationDegree = isRotated ? '90deg' : '0deg';\n\n  const boxStyle = {\n    width: 100,\n    height: 100,\n    backgroundColor: 'coral',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    color: 'white',\n    fontWeight: 'bold',\n    // Apply transform with vendor prefixes\n    transform: `rotate(${rotationDegree})`,\n    WebkitTransform: `rotate(${rotationDegree})`, // Webkit browsers\n    msTransform: `rotate(${rotationDegree})`     // Internet Explorer\n  };\n\n  const toggleRotation = () => {\n    setIsRotated(prev => !prev);\n  };\n\n  return (\n    <div style={{ padding: '20px', margin: '20px', border: '1px solid black' }}>\n      <div style={boxStyle}>\n        {isRotated ? 'Rotated' : 'Static'}\n      </div>\n      <button onClick={toggleRotation} style={{ marginTop: '10px' }}>\n        Toggle Rotation\n      </button>\n    </div>\n  );\n}\n\nexport default DynamicBox;",
          "testCases": [
            "The box should initially be unrotated.",
            "Clicking the 'Toggle Rotation' button should rotate the box 90 degrees.",
            "Ensure the box rotates correctly in different browsers (Chrome, Firefox, Edge) to verify vendor prefix effectiveness. (Manual check required for this specific test case).",
            "Verify that CSS properties are camelCased (e.g., `backgroundColor`)."
          ],
          "hints": [
            "Remember to use camelCase for CSS properties in the JavaScript style object.",
            "Pay close attention to the capitalization of vendor prefixes: `Webkit` (capital 'W') and `ms` (lowercase 'm').",
            "Use template literals (` `` `) for dynamic string values in styles."
          ],
          "tags": [
            "React Styling",
            "Inline Styles",
            "CSS",
            "Vendor Prefixes",
            "Dynamic Styles"
          ],
          "timeEstimate": 25,
          "prerequisites": [
            "react_functional_components",
            "css_basics"
          ],
          "complexity": 5,
          "interviewRelevance": 6,
          "learningPath": "beginner",
          "relatedConcepts": [
            "theory_styling_in_react"
          ]
        },
        {
          "id": "task_merge_style_utility",
          "title": "Create a Style Merging Utility Function for React Components",
          "description": "\nDevelop a simple utility function `mergeStyles` that takes an arbitrary number of style objects as arguments and returns a single merged style object.\n\nYour task is to:\n\n1.  Implement `mergeStyles` to correctly combine properties from all input style objects.\n2.  Ensure that properties from later objects in the argument list override properties from earlier objects.\n3.  Demonstrate its use in a React component where you apply a base style and then override some properties with a specific variant style.\n",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\n\n// TODO: Implement the mergeStyles utility function here\nconst mergeStyles = (...styles) => {\n  // Hint: Use the object spread syntax\n  return {}; // Placeholder\n};\n\nfunction MergedStyleComponent({ type }) {\n  const baseButtonStyle = {\n    padding: '10px 15px',\n    border: 'none',\n    borderRadius: '4px',\n    cursor: 'pointer',\n    fontSize: '16px',\n    color: 'white',\n  };\n\n  const primaryButtonStyle = {\n    backgroundColor: 'blue',\n  };\n\n  const secondaryButtonStyle = {\n    backgroundColor: 'gray',\n    color: 'black',\n  };\n\n  let currentStyle = {};\n  if (type === 'primary') {\n    currentStyle = mergeStyles(baseButtonStyle, primaryButtonStyle);\n  } else if (type === 'secondary') {\n    currentStyle = mergeStyles(baseButtonStyle, secondaryButtonStyle);\n  } else {\n    currentStyle = baseButtonStyle; // Default\n  }\n\n  return (\n    <button style={currentStyle}>\n      {type ? `${type} Button` : 'Default Button'}\n    </button>\n  );\n}\n\nfunction App() {\n  return (\n    <div style={{ padding: '20px', display: 'flex', gap: '10px' }}>\n      <MergedStyleComponent type=\"primary\" />\n      <MergedStyleComponent type=\"secondary\" />\n      <MergedStyleComponent />\n    </div>\n  );\n}\n\nexport default App;",
          "solutionCode": "import React from 'react';\n\n// Implemented mergeStyles utility function\nconst mergeStyles = (...styles) => {\n  return styles.reduce((merged, currentStyle) => ({\n    ...merged,\n    ...currentStyle\n  }), {});\n};\n\nfunction MergedStyleComponent({ type }) {\n  const baseButtonStyle = {\n    padding: '10px 15px',\n    border: 'none',\n    borderRadius: '4px',\n    cursor: 'pointer',\n    fontSize: '16px',\n    color: 'white',\n  };\n\n  const primaryButtonStyle = {\n    backgroundColor: 'blue',\n  };\n\n  const secondaryButtonStyle = {\n    backgroundColor: 'gray',\n    color: 'black',\n  };\n\n  let currentStyle = {};\n  if (type === 'primary') {\n    currentStyle = mergeStyles(baseButtonStyle, primaryButtonStyle);\n  } else if (type === 'secondary') {\n    currentStyle = mergeStyles(baseButtonStyle, secondaryButtonStyle);\n  } else {\n    currentStyle = baseButtonStyle;\n  }\n\n  return (\n    <button style={currentStyle}>\n      {type ? `${type} Button` : 'Default Button'}\n    </button>\n  );\n}\n\nfunction App() {\n  return (\n    <div style={{ padding: '20px', display: 'flex', gap: '10px' }}>\n      <MergedStyleComponent type=\"primary\" />\n      <MergedStyleComponent type=\"secondary\" />\n      <MergedStyleComponent />\n      <MergedStyleComponent type=\"primary\" style={{ color: 'red', fontSize: '20px' }} /> {/* Demonstrates further overriding */}\n    </div>\n  );\n}\n\nexport default App;",
          "testCases": [
            "The 'primary Button' should have a blue background and white text.",
            "The 'secondary Button' should have a gray background and black text (overriding `baseButtonStyle`'s white text).",
            "The 'Default Button' should only have `baseButtonStyle` applied.",
            "If you add an extra style object to a component call like `<MergedStyleComponent type=\"primary\" style={{ color: 'red' }} />`, the `color` should be red, demonstrating that later styles passed to `mergeStyles` take precedence.",
            "Test `mergeStyles` with no arguments, or with a single argument, ensuring it still returns a valid object."
          ],
          "hints": [
            "The `...` (spread) operator is very useful for merging objects.",
            "The `Array.prototype.reduce` method can be used to process an array of style objects into a single one.",
            "Remember that when spreading objects, properties from objects appearing later in the spread will overwrite those from earlier objects if their keys conflict."
          ],
          "tags": [
            "React Styling",
            "Inline Styles",
            "JavaScript",
            "Utility Function",
            "Object Manipulation",
            "ES6"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "javascript_objects_basics",
            "javascript_es6_features"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_styling_in_react"
          ]
        }
      ]
    }
  }
]