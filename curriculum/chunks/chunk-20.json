[
  {
    "id": "e4fbbc01-c6ff-4ee2-ab4e-695915cf88ef",
    "startLine": 4000,
    "endLine": 4099,
    "processedDate": "2025-06-17T09:02:20.772Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_uncontrolled_components",
          "title": "Uncontrolled Components in React",
          "content": "Uncontrolled components are a way to handle form data in React where the form data is handled by the DOM itself, rather than by React state. In this approach, instead of writing an event handler for every state update, you use a ref to get the form values directly from the DOM when the form is submitted. This is similar to how HTML forms work without React.\n\n### Key Concepts\n-   **DOM as Source of Truth:** The input elements maintain their own internal state, and you query the DOM using refs to get their current value.\n-   **`React.createRef()`:** Used to create a ref that can be attached to a DOM element (or a class component instance) in the `render` method.\n-   **`this.refName.current`:** After the component mounts, the `current` property of the ref object will hold a reference to the DOM element (e.g., `<input>`). You can then access its properties like `value` or `files`.\n-   **File Inputs:** File inputs are always uncontrolled because their value can only be set by a user, not programmatically by React.\n-   **`defaultValue` and `defaultChecked`:** For initial values, uncontrolled components use `defaultValue` (for text inputs, select, textarea) or `defaultChecked` (for checkboxes/radio buttons) instead of `value` or `checked` which are used for controlled components.\n\n### Use Cases\nUncontrolled components are useful in specific scenarios:\n-   **Integrating with non-React code:** When you need to interact with DOM elements managed by libraries or code outside of React.\n-   **Simpler code for basic forms:** For forms with very few inputs where direct DOM access might seem simpler than managing multiple state variables.\n-   **Working with file inputs:** File inputs are inherently uncontrolled as their value cannot be set by JavaScript for security reasons.\n\n### Limitations\nFor most form scenarios, controlled components are recommended because they provide more reactive control over form data, easier validation, and immediate feedback. Uncontrolled components can make it harder to implement features like instant input validation, conditionally disabling the submit button, or enforcing input format.\n\n### Example Code Structure\n```typescript\nimport React from 'react';\n\nclass UncontrolledForm extends React.Component {\n  constructor(props) {\n    super(props);\n    // Create refs to access DOM elements directly\n    this.input = React.createRef();\n    this.fileInput = React.createRef();\n  }\n\n  handleSubmit = (event) => {\n    // Prevent default form submission behavior (page reload)\n    event.preventDefault();\n    \n    // Access input values directly from the DOM using refs\n    const inputValue = this.input.current.value;\n    const fileValue = this.fileInput.current.files[0]; // For file input, files[0] gets the first selected file\n    \n    // Process the form data\n    console.log('Input Value:', inputValue);\n    console.log('Selected File:', fileValue);\n    \n    // You can still send the form data to a server or parent component\n    this.props.onSubmit({ inputValue, fileValue });\n  };\n  \n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <div>\n          <label htmlFor=\"name\">Name:</label>\n          <input\n            id=\"name\"\n            className=\"form-input\"\n            defaultValue=\"\" // Use defaultValue for initial value in uncontrolled components\n            placeholder=\"Enter your name\"\n            ref={this.input} // Attach the ref to the input element\n          />\n        </div>\n        \n        <div>\n          <label htmlFor=\"file\">Upload File:</label>\n          <input\n            id=\"file\"\n            type=\"file\"\n            ref={this.fileInput} // Attach ref to file input\n          />\n        </div>\n        \n        <button type=\"submit\">Submit</button>\n      </form>\n    );\n  }\n}\n\n// Example Usage (conceptual, not in original content but good for context)\n// <UncontrolledForm onSubmit={(data) => console.log('Form submitted:', data)} />\n```",
          "examples": [
            {
              "id": "example_uncontrolled_1",
              "title": "Basic Uncontrolled Text Input",
              "code": "import React, { useRef } from 'react';\n\nfunction NameForm() {\n  const nameInputRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    alert('A name was submitted: ' + nameInputRef.current.value);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Name:\n        <input type=\"text\" ref={nameInputRef} defaultValue=\"Bob\" />\n      </label>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}",
              "explanation": "This example demonstrates a basic uncontrolled text input. The `useRef` hook is used in a functional component to create a ref. The `ref` is then attached to the input element. When the form is submitted, `nameInputRef.current.value` directly accesses the current value from the DOM.",
              "language": "typescript"
            },
            {
              "id": "example_uncontrolled_file_input",
              "title": "Uncontrolled File Input",
              "code": "import React, { useRef } from 'react';\n\nfunction FileUploadForm() {\n  const fileInputRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    const file = fileInputRef.current.files[0];\n    if (file) {\n      console.log('Selected file:', file.name, file.type, file.size, 'bytes');\n      // In a real application, you would upload this file to a server\n    } else {\n      console.log('No file selected.');\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Upload File:\n        <input type=\"file\" ref={fileInputRef} />\n      </label>\n      <button type=\"submit\">Upload</button>\n    </form>\n  );\n}",
              "explanation": "This example shows how to handle a file input, which is always an uncontrolled component. The `useRef` hook provides access to the underlying DOM file input element. Upon submission, `fileInputRef.current.files[0]` retrieves the first selected file, which can then be processed (e.g., uploaded).",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "Refs",
            "DOM Interaction"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "react_state",
            "dom_manipulation"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "controlled_components",
            "react_hooks",
            "form_validation"
          ]
        },
        {
          "id": "theory_ref_forwarding",
          "title": "Ref Forwarding in React",
          "content": "Ref forwarding is a technique in React for automatically passing a ref from a parent component through to one of its children's underlying DOM elements or class component instances. This is particularly useful for building reusable component libraries, allowing consumers of a component to get a direct reference to an internal DOM node.\n\n### Why Ref Forwarding?\nBy default, when you attach a ref to a custom component (e.g., `<MyComponent ref={myRef} />`), `myRef` will receive the instance of `MyComponent` itself, not the DOM element rendered *by* `MyComponent`. If `MyComponent` renders an `input` element and you want to directly access that `input`'s DOM node (e.g., to focus it), you need ref forwarding.\n\n### `React.forwardRef()` API\n`React.forwardRef()` is a higher-order component that takes a render function. This function receives `props` as its first argument and `ref` as its second argument. The `ref` argument is the ref that was passed to the `forwardRef` component by its parent. You then attach this `ref` to the desired underlying DOM element or class component instance.\n\n```jsx\nReact.forwardRef((props, ref) => {\n  // Inside this function, `ref` is the ref from the parent\n  return <DOMElement ref={ref} {...props} />;\n});\n```\n\n### Key Principles\n-   `ref` is not a regular prop: React handles `ref` specially, similar to `key`. It's not passed down automatically via the `props` object.\n-   Allows parent to interact with child's DOM: Enables common patterns like imperatively triggering focus, selection, or animations on a child's DOM node.\n-   Enhances reusability: Makes your components more flexible and composable, as their internal DOM elements can be manipulated by their parents when necessary.\n\n### When to use?\n-   **Imperative animations:** Triggering animations on child DOM nodes.\n-   **Managing focus, text selection, or media playback:** For example, focusing an input field after a button click.\n-   **Integrating with third-party DOM libraries:** When you need a direct reference to a DOM element for integration.\n\n```typescript\nimport React from 'react';\n\n// ButtonElement is a functional component that forwards its ref to the native <button> DOM element.\nconst ButtonElement = React.forwardRef((props, ref) => (\n  <button ref={ref} className=\"CustomButton\">\n    {props.children}\n  </button>\n));\n\n// Usage example:\nclass ParentComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    // Create a ref that will eventually hold the DOM button element\n    this.buttonRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // After the component mounts, buttonRef.current will refer to the <button> DOM node\n    if (this.buttonRef.current) {\n      console.log('Button DOM element:', this.buttonRef.current);\n      this.buttonRef.current.focus(); // Example: focus the button\n    }\n  }\n\n  render() {\n    return (\n      // Pass the ref to ButtonElement, which then forwards it to its internal <button>\n      <ButtonElement ref={this.buttonRef}>{'Forward Ref Example'}</ButtonElement>\n    );\n  }\n}\n\n// You can also use useRef hook in functional components:\n// import React, { useRef, useEffect } from 'react';\n// function FunctionalParent() {\n//   const buttonRef = useRef(null);\n//   useEffect(() => {\n//     if (buttonRef.current) {\n//       console.log('Button DOM element (functional):', buttonRef.current);\n//       buttonRef.current.click(); // Example: programmatically click the button\n//     }\n//   }, []);\n//   return <ButtonElement ref={buttonRef}>{'Click Me'}</ButtonElement>;\n// }\n```",
          "examples": [
            {
              "id": "example_ref_forwarding_input",
              "title": "Ref Forwarding for an Input Component",
              "code": "import React, { useRef, useEffect } from 'react';\n\n// MyInput component forwards the ref to the native <input> element\nconst MyInput = React.forwardRef((props, ref) => (\n  <input type=\"text\" ref={ref} placeholder=\"Type something...\" {...props} />\n));\n\nfunction App() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // Focus the input when the component mounts\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []);\n\n  const handleClick = () => {\n    if (inputRef.current) {\n      alert('Input value: ' + inputRef.current.value);\n    }\n  };\n\n  return (\n    <div>\n      <MyInput ref={inputRef} />\n      <button onClick={handleClick}>Get Input Value</button>\n    </div>\n  );\n}",
              "explanation": "This example shows how to create a custom `MyInput` component that correctly forwards a ref to its internal HTML `input` element. The parent `App` component can then use `useRef` to get a direct reference to the DOM input and perform imperative actions like `focus()` or access its `value`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Refs",
            "Ref Forwarding",
            "DOM Interaction",
            "Component Design"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_refs",
            "functional_components",
            "useRef_hook"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "higher_order_components",
            "render_props_pattern",
            "component_libraries"
          ]
        },
        {
          "id": "theory_ref_forwarding_hocs",
          "title": "Ref Forwarding in Higher-Order Components (HOCs)",
          "content": "Higher-Order Components (HOCs) are functions that take a component and return a new component. They are a powerful pattern for reusing component logic. However, a common pitfall arises when using refs with HOCs.\n\n### The Problem with Refs and HOCs\nBy default, if you add a ref to a component wrapped by an HOC (e.g., `<MyHOCWrappedComponent ref={myRef} />`), the `myRef` will not refer to the original `WrappedComponent` instance or its internal DOM node. Instead, it will refer to the instance of the *outermost wrapper component* created by the HOC.\n\nThis happens because `ref` is not a regular prop; React handles it specially. When `MyHOCWrappedComponent` is rendered, React sees the `ref` on the element created by the HOC itself, not the `WrappedComponent` that the HOC is rendering internally. This prevents you from directly accessing the underlying component or its DOM element.\n\n### The Solution: Using `React.forwardRef` within HOCs\nTo correctly forward refs through an HOC, you need to combine `React.forwardRef` with the HOC pattern. The `React.forwardRef` API allows the HOC to receive the ref passed by the parent and explicitly pass it down to the `WrappedComponent`.\n\nHere's how it works:\n1.  **Define the HOC:** The HOC function takes a `Component` as an argument.\n2.  **Create an internal wrapper component:** This component (e.g., `LogProps` in the example) will render the `Component` passed to the HOC.\n3.  **Use `React.forwardRef` for the HOC's return value:** The HOC's return value is now a `React.forwardRef` call. This `forwardRef`'s render function receives the `props` and the `ref` from the parent.\n4.  **Pass the forwarded ref as a prop:** Inside the `forwardRef`'s render function, you extract the `ref` (often renamed to `forwardedRef` to avoid naming conflicts with original props) and pass it as a *regular prop* to the internal wrapper component (e.g., `<LogProps forwardedRef={ref} />`).\n5.  **Attach the prop to the wrapped component:** Inside the internal wrapper component's `render` method, you attach `this.props.forwardedRef` to the actual `WrappedComponent` (`<Component ref={forwardedRef} />`).\n\nThis ensures that the ref from the parent ultimately attaches to the `WrappedComponent`, allowing direct access to its instance or its internal DOM element (if the `WrappedComponent` itself uses `React.forwardRef`).\n\n```typescript\nimport React from 'react';\n\n// A Higher-Order Component that logs props and forwards refs\nfunction logProps(Component) {\n  class LogProps extends React.Component {\n    componentDidUpdate(prevProps) {\n      console.log('old props:', prevProps);\n      console.log('new props:', this.props);\n    }\n    \n    render() {\n      // Extract the forwarded ref from props (it's passed as a regular prop here)\n      const { forwardedRef, ...rest } = this.props;\n      \n      // Pass the ref to the wrapped component using its 'ref' attribute\n      // 'Component' itself must be a functional component wrapped with React.forwardRef\n      // OR a class component.\n      return <Component ref={forwardedRef} {...rest} />;\n    }\n  }\n  \n  // Use React.forwardRef to allow the HOC itself to receive a ref\n  // and pass it down to the LogProps wrapper.\n  return React.forwardRef((props, ref) => {\n    // Here, 'ref' is the ref from the parent that rendered the HOC-wrapped component.\n    // We pass it to LogProps as a regular prop named 'forwardedRef'.\n    return <LogProps {...props} forwardedRef={ref} />;\n  });\n}\n\n// Example usage:\n// First, define a component that can receive a ref (e.g., using forwardRef itself)\nconst MyButton = React.forwardRef((props, ref) => (\n  <button ref={ref} onClick={props.onClick}>\n    {props.children}\n  </button>\n));\n\n// Now, wrap MyButton with the logProps HOC\nconst LoggedButton = logProps(MyButton);\n\n// A parent component that uses the HOC-wrapped component and attaches a ref\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.buttonRef = React.createRef();\n  }\n\n  componentDidMount() {\n    if (this.buttonRef.current) {\n      console.log('Direct DOM access via HOC-forwarded ref:', this.buttonRef.current);\n      this.buttonRef.current.focus(); // We can focus the actual button!\n    }\n  }\n\n  handleClick = () => {\n    alert('Button clicked!');\n  };\n\n  render() {\n    return (\n      <LoggedButton ref={this.buttonRef} onClick={this.handleClick}>\n        Click Me (Logged & Ref-Forwarded)\n      </LoggedButton>\n    );\n  }\n}\n\n// To use this, render <App />\n```",
          "examples": [
            {
              "id": "example_hoc_ref_forwarding_basic",
              "title": "HOC for Input with Ref Forwarding",
              "code": "import React, { useRef, useEffect } from 'react';\n\n// HOC: withLogging that logs renders and forwards refs\nfunction withLogging(WrappedComponent) {\n  class WithLogging extends React.Component {\n    componentDidMount() {\n      console.log(`${WrappedComponent.name || 'Component'} mounted.`);\n    }\n\n    render() {\n      const { forwardedRef, ...restProps } = this.props;\n      return <WrappedComponent ref={forwardedRef} {...restProps} />;\n    }\n  }\n\n  return React.forwardRef((props, ref) => {\n    return <WithLogging {...props} forwardedRef={ref} />;\n  });\n}\n\n// A simple input component that supports ref forwarding\nconst MyInput = React.forwardRef((props, ref) => {\n  return <input type=\"text\" ref={ref} placeholder={props.placeholder} />;\n});\n\n// Create a logged version of MyInput\nconst LoggedInput = withLogging(MyInput);\n\nfunction App() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n      console.log('Input focused via forwarded ref in HOC!');\n    }\n  }, []);\n\n  return (\n    <div>\n      <h1>HOC Ref Forwarding Demo</h1>\n      <LoggedInput ref={inputRef} placeholder=\"Enter text here\" />\n    </div>\n  );\n}",
              "explanation": "This example demonstrates how to correctly forward refs through a Higher-Order Component (`withLogging`). `withLogging` takes `MyInput` (which itself uses `React.forwardRef`) and returns a new component `LoggedInput`. The key is that `withLogging` wraps `MyInput` with `React.forwardRef` to intercept the parent's ref and pass it down as a regular prop (`forwardedRef`) to its internal `WithLogging` component, which then attaches it to the `WrappedComponent` (`MyInput`). This allows `App` to directly focus the actual `<input>` element.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "HOCs",
            "Ref Forwarding",
            "Advanced React",
            "Component Patterns"
          ],
          "technology": "React",
          "prerequisites": [
            "react_hocs",
            "react_forwardRef",
            "react_class_components",
            "react_functional_components"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "custom_hooks",
            "render_props_vs_hocs",
            "performance_optimization_react"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_uncontrolled_components_1",
          "topic": "Uncontrolled Components",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary mechanism used to access data from an uncontrolled component in React?",
          "answer": "Refs",
          "options": [],
          "analysisPoints": [
            "Uncontrolled components directly interact with the DOM.",
            "Refs provide a way to access the underlying DOM nodes."
          ],
          "keyConcepts": [
            "Uncontrolled Components",
            "Refs",
            "DOM Interaction"
          ],
          "evaluationCriteria": [
            "Recall of fundamental concepts.",
            "Understanding of ref purpose."
          ],
          "example": "Refs are used to get the current value of an input field in an uncontrolled component, for example, `this.inputRef.current.value`.",
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "Refs"
          ],
          "prerequisites": [
            "react_basics",
            "react_refs"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_uncontrolled_components_2",
          "topic": "Uncontrolled Components",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following scenarios is **most** suitable for using an uncontrolled component in React?",
          "answer": "Integrating React with an existing jQuery-based form.",
          "options": [
            "Implementing a live search filter with immediate feedback.",
            "Building a multi-step form with complex validation rules.",
            "Creating a custom controlled input component for a design system.",
            "Integrating React with an existing jQuery-based form."
          ],
          "analysisPoints": [
            "Uncontrolled components shine when React isn't the sole owner of the DOM.",
            "Scenarios requiring immediate feedback or complex logic are better suited for controlled components.",
            "Custom components for design systems typically aim for controlled behavior for consistency."
          ],
          "keyConcepts": [
            "Uncontrolled Components",
            "Controlled Components",
            "Use Cases",
            "Interoperability"
          ],
          "evaluationCriteria": [
            "Ability to identify appropriate use cases for different component types.",
            "Understanding of React's paradigm for forms."
          ],
          "example": "Uncontrolled components are ideal when you need to integrate React with non-React DOM manipulation, such as a legacy form handled by jQuery, where you don't want React to fully manage the input's state.",
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "Use Cases",
            "Integration"
          ],
          "prerequisites": [
            "react_forms",
            "controlled_components"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_uncontrolled_components_3",
          "topic": "Uncontrolled Components",
          "level": "medium",
          "type": "open",
          "question": "Explain the difference in how `defaultValue` is used in uncontrolled components versus `value` in controlled components. Why does React make this distinction?",
          "answer": "In uncontrolled components, `defaultValue` is used to set the initial value of an input field. After the component mounts, the DOM element manages its own state, and React doesn't control subsequent updates. You access the current value directly from the DOM using a ref when needed (e.g., on form submission).\n\nIn controlled components, `value` is used to set the current value of an input field. The `value` prop is typically tied to a piece of React state, and an `onChange` event handler is used to update that state. React is the 'single source of truth' for the input's value, and every render reflects the state. This allows React to control the input's behavior programmatically, enabling features like immediate validation, formatting, or conditional disabling.\n\nReact makes this distinction to clearly separate the 'source of truth' for form data. For controlled components, React state is the source of truth, enabling full declarative control. For uncontrolled components, the DOM itself is the source of truth, facilitating simpler integration with non-React code or for simple use cases where full control isn't necessary, like file inputs.",
          "options": [],
          "analysisPoints": [
            "Understanding of data flow in controlled vs. uncontrolled.",
            "Role of React state in controlled components.",
            "Role of DOM in uncontrolled components.",
            "Reasons for React's design choices (control vs. simplicity/interop)."
          ],
          "keyConcepts": [
            "Controlled Components",
            "Uncontrolled Components",
            "defaultValue",
            "value",
            "State Management",
            "DOM as Source of Truth"
          ],
          "evaluationCriteria": [
            "Clarity of explanation.",
            "Accuracy of concepts.",
            "Depth of understanding on design principles."
          ],
          "example": "```jsx\n// Uncontrolled:\n<input type=\"text\" defaultValue=\"Initial Name\" ref={nameRef} />\n\n// Controlled:\n<input type=\"text\" value={this.state.name} onChange={this.handleChange} />\n```",
          "tags": [
            "React",
            "Forms",
            "Controlled Components",
            "Uncontrolled Components",
            "State"
          ],
          "prerequisites": [
            "react_state",
            "controlled_components_vs_uncontrolled"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_uncontrolled_components_4",
          "topic": "Uncontrolled Components",
          "level": "hard",
          "type": "code",
          "question": "Given the following controlled component, refactor it into an uncontrolled component. The component should still submit the username and password, but now by directly accessing DOM values via refs. Ensure `event.preventDefault()` is called.",
          "answer": "```typescript\nimport React, { useRef } from 'react';\n\nfunction LoginFormUncontrolled({ onSubmit }) {\n  const usernameRef = useRef(null);\n  const passwordRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    const username = usernameRef.current.value;\n    const password = passwordRef.current.value;\n    onSubmit({ username, password });\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"username\">Username:</label>\n        <input type=\"text\" id=\"username\" ref={usernameRef} defaultValue=\"\" />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password:</label>\n        <input type=\"password\" id=\"password\" ref={passwordRef} defaultValue=\"\" />\n      </div>\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n\n// Example usage:\n// function App() {\n//   const handleLogin = (data) => {\n//     console.log('Uncontrolled Login Data:', data);\n//     alert(`Login attempt for: ${data.username}`);\n//   };\n//   return <LoginFormUncontrolled onSubmit={handleLogin} />;\n// }\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `useRef` hook (or `React.createRef` for class components).",
            "Attaching refs to the correct input elements.",
            "Accessing `current.value` from the refs.",
            "Replacing `value` and `onChange` with `defaultValue`.",
            "Properly preventing default form submission."
          ],
          "keyConcepts": [
            "Uncontrolled Components",
            "Refs",
            "Form Handling",
            "Functional Components",
            "useRef"
          ],
          "evaluationCriteria": [
            "Correct application of refs for data access.",
            "Appropriate removal of controlled component patterns.",
            "Functional correctness."
          ],
          "example": "```typescript\n// Original controlled component (for context, not part of the question's provided content)\n// import React, { useState } from 'react';\n// function LoginFormControlled({ onSubmit }) {\n//   const [username, setUsername] = useState('');\n//   const [password, setPassword] = useState('');\n//   const handleSubmit = (event) => {\n//     event.preventDefault();\n//     onSubmit({ username, password });\n//   };\n//   return (\n//     <form onSubmit={handleSubmit}>\n//       <div>\n//         <label htmlFor=\"username\">Username:</label>\n//         <input type=\"text\" id=\"username\" value={username} onChange={(e) => setUsername(e.target.value)} />\n//       </div>\n//       <div>\n//         <label htmlFor=\"password\">Password:</label>\n//         <input type=\"password\" id=\"password\" value={password} onChange={(e) => setPassword(e.target.value)} />\n//       </div>\n//       <button type=\"submit\">Login</button>\n//     </form>\n//   );\n// }\n\n// Refactored uncontrolled component provided in the answer section.\n```",
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "Code Challenge",
            "Refactoring"
          ],
          "prerequisites": [
            "react_forms",
            "react_refs",
            "controlled_components"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_ref_forwarding_1",
          "topic": "Ref Forwarding",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of `React.forwardRef()`?",
          "answer": "To allow a component to pass a ref it receives down to one of its children, typically a DOM element.",
          "options": [],
          "analysisPoints": [
            "Focus on the 'passing down' aspect of refs.",
            "Distinction from regular refs on custom components."
          ],
          "keyConcepts": [
            "Ref Forwarding",
            "React.forwardRef",
            "Refs"
          ],
          "evaluationCriteria": [
            "Recall of API purpose."
          ],
          "example": "```jsx\nconst MyComponent = React.forwardRef((props, ref) => (\n  <input ref={ref} type=\"text\" />\n));\n// Parent uses: <MyComponent ref={inputRef} />\n```",
          "tags": [
            "React",
            "Refs",
            "Ref Forwarding"
          ],
          "prerequisites": [
            "react_refs"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_ref_forwarding_2",
          "topic": "Ref Forwarding",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following component:\n\n```jsx\nfunction CustomButton(props) {\n  return <button className=\"btn\">{props.children}</button>;\n}\n\n// Parent component wants to focus the button:\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.buttonRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // This will currently try to focus the CustomButton component instance, not the DOM button\n    // this.buttonRef.current.focus(); \n  }\n\n  render() {\n    return <CustomButton ref={this.buttonRef}>Click Me</CustomButton>;\n  }\n}\n```\n\nTo allow `App` to directly focus the underlying `<button>` DOM element inside `CustomButton`, what modification is required for `CustomButton`?",
          "answer": "Wrap `CustomButton` with `React.forwardRef` and pass the received ref to the `<button>` element.",
          "options": [
            "Add a `ref` prop to `CustomButton` and pass it down as `props.ref` to the `<button>` element.",
            "Change `CustomButton` to a class component and make the `<button>` a class property.",
            "Wrap `CustomButton` with `React.forwardRef` and pass the received ref to the `<button>` element.",
            "Use `document.getElementById` in `App` to get the button element directly."
          ],
          "analysisPoints": [
            "Refs are not regular props and are not automatically passed down.",
            "`React.forwardRef` is the explicit API for this purpose.",
            "Accessing DOM directly outside React (e.g., `getElementById`) is discouraged when React provides a mechanism.",
            "Class components can receive refs, but `forwardRef` is specifically for passing them *through* a component to its children.",
            "The second argument of the `forwardRef` render function is the ref to be forwarded."
          ],
          "keyConcepts": [
            "Ref Forwarding",
            "React.forwardRef",
            "Refs",
            "DOM Interaction",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Understanding of `forwardRef` mechanics.",
            "Ability to identify incorrect ref handling patterns.",
            "Problem-solving in component interaction."
          ],
          "example": "```jsx\n// Corrected CustomButton:\nconst CustomButton = React.forwardRef((props, ref) => (\n  <button ref={ref} className=\"btn\">{props.children}</button>\n));\n\n// Parent usage remains the same:\n// <CustomButton ref={this.buttonRef}>Click Me</CustomButton>\n```",
          "tags": [
            "React",
            "Refs",
            "Ref Forwarding",
            "MCQ",
            "Component Interaction"
          ],
          "prerequisites": [
            "react_refs",
            "functional_components"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_ref_forwarding_3",
          "topic": "Ref Forwarding",
          "level": "hard",
          "type": "code",
          "question": "Implement a `FocusableInput` functional component in React that takes a `label` prop and an arbitrary `type` prop (e.g., 'text', 'password'). This component should render a `label` and an `input` element. Critically, it must expose the `input` element's DOM node via ref forwarding, so a parent component can programmatically focus the input. Provide an example of how a parent component would use and focus this `FocusableInput`.",
          "answer": "```typescript\nimport React, { useRef, useEffect } from 'react';\n\n// FocusableInput component using React.forwardRef\nconst FocusableInput = React.forwardRef(({ label, type, ...props }, ref) => {\n  return (\n    <div>\n      <label>{label}: </label>\n      <input type={type} ref={ref} {...props} />\n    </div>\n  );\n});\n\n// Parent component to demonstrate usage\nfunction ParentComponent() {\n  const usernameInputRef = useRef(null);\n  const passwordInputRef = useRef(null);\n\n  useEffect(() => {\n    // Focus the username input when the component mounts\n    if (usernameInputRef.current) {\n      usernameInputRef.current.focus();\n    }\n  }, []);\n\n  const handleFocusPassword = () => {\n    if (passwordInputRef.current) {\n      passwordInputRef.current.focus();\n    }\n  };\n\n  return (\n    <div>\n      <h1>Login Form</h1>\n      <FocusableInput ref={usernameInputRef} label=\"Username\" type=\"text\" placeholder=\"Enter username\" />\n      <FocusableInput ref={passwordInputRef} label=\"Password\" type=\"password\" placeholder=\"Enter password\" style={{ marginTop: '10px' }} />\n      <button onClick={handleFocusPassword} style={{ marginLeft: '10px' }}>Focus Password Field</button>\n    </div>\n  );\n}\n\n// Example usage: <ParentComponent />\n```",
          "options": [],
          "analysisPoints": [
            "Correct usage of `React.forwardRef` with two arguments (`props`, `ref`).",
            "Passing the `ref` argument directly to the `input` element.",
            "Destructuring `label` and `type` from `props` and spreading `...props` to allow other HTML attributes.",
            "Demonstrating parent component's use of `useRef` to interact with the forwarded ref.",
            "Ability to programmatically focus the input.",
            "Handles arbitrary `type` prop correctly."
          ],
          "keyConcepts": [
            "Ref Forwarding",
            "React.forwardRef",
            "Functional Components",
            "useRef Hook",
            "Imperative Handles"
          ],
          "evaluationCriteria": [
            "Correct implementation of ref forwarding.",
            "Clear demonstration of usage in parent component.",
            "Handling of props and DOM attributes.",
            "Code readability and best practices."
          ],
          "example": "The solution code above serves as the example.",
          "tags": [
            "React",
            "Refs",
            "Ref Forwarding",
            "Code Challenge",
            "Component Design",
            "Hooks"
          ],
          "prerequisites": [
            "react_functional_components",
            "useRef_hook"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_ref_forwarding_1",
          "topic": "Ref Forwarding in HOCs",
          "level": "medium",
          "type": "mcq",
          "question": "When applying a Higher-Order Component (HOC) like `withAuth` to `MyComponent` (`const EnhancedComponent = withAuth(MyComponent);`), and then attempting to attach a ref to `EnhancedComponent` (`<EnhancedComponent ref={myRef} />`), what does `myRef.current` typically refer to by default, without any special handling?",
          "answer": "The instance of the wrapper component created by the `withAuth` HOC.",
          "options": [
            "The DOM element of `MyComponent`.",
            "The instance of `MyComponent` itself.",
            "An error, as refs cannot be used with HOCs.",
            "The instance of the wrapper component created by the `withAuth` HOC."
          ],
          "analysisPoints": [
            "Refs are not regular props; they are handled specially by React.",
            "Without `forwardRef`, the ref attaches to the immediate element it's applied to.",
            "In an HOC, the immediate element is the wrapper component.",
            "The problem `React.forwardRef` in HOCs solves."
          ],
          "keyConcepts": [
            "HOCs",
            "Refs",
            "Ref Forwarding",
            "Wrapper Components"
          ],
          "evaluationCriteria": [
            "Understanding of default ref behavior with HOCs.",
            "Knowledge of React's special handling of refs."
          ],
          "example": "```jsx\nfunction withAuth(Component) {\n  class AuthWrapper extends React.Component {\n    render() {\n      return <Component {...this.props} />;\n    }\n  }\n  return AuthWrapper;\n}\nconst EnhancedComponent = withAuth(MyComponent);\n// If you do <EnhancedComponent ref={myRef} />, myRef.current will be an instance of AuthWrapper, not MyComponent.\n```",
          "tags": [
            "React",
            "HOCs",
            "Refs",
            "Ref Forwarding",
            "MCQ"
          ],
          "prerequisites": [
            "react_hocs",
            "react_refs"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_ref_forwarding_2",
          "topic": "Ref Forwarding in HOCs",
          "level": "medium",
          "type": "open",
          "question": "Describe the problem that occurs when trying to pass a ref through a Higher-Order Component (HOC) by default, and explain how `React.forwardRef` resolves this problem.",
          "answer": "The problem with passing a ref through a HOC by default is that `ref` is a special prop in React, not a regular prop. When you attach a ref to a component wrapped by an HOC (e.g., `<MyHOCWrappedComponent ref={myRef} />`), `myRef` will receive the instance of the *outermost wrapper component* created by the HOC, not the `WrappedComponent` or its internal DOM node that you might intend to reference. This means you cannot directly access or manipulate the underlying component's instance or its elements.\n\n`React.forwardRef` resolves this problem by explicitly allowing the HOC to receive the ref from its parent and then pass it down to the actual `WrappedComponent`. Here's how:\n1.  The HOC function, instead of directly returning a wrapper component, returns the result of `React.forwardRef((props, ref) => { ... })`.\n2.  Inside this `forwardRef`'s render function, the `ref` argument is the actual ref passed by the parent component.\n3.  This `ref` is then passed as a *regular prop* (e.g., `forwardedRef`) to the internal wrapper component (e.g., a class component inside the HOC).\n4.  Finally, the internal wrapper component renders the original `WrappedComponent` and attaches the `forwardedRef` prop to it using the standard `ref` attribute (e.g., `<WrappedComponent ref={forwardedRef} />`).\n\nThis chain ensures that the ref from the parent correctly reaches and attaches to the target `WrappedComponent`, allowing the parent to interact with it directly.",
          "options": [],
          "analysisPoints": [
            "Identification of the core issue: `ref` not being a regular prop.",
            "Understanding that the ref attaches to the HOC's wrapper.",
            "Step-by-step explanation of `forwardRef`'s mechanism within an HOC.",
            "Role of passing `forwardedRef` as a regular prop."
          ],
          "keyConcepts": [
            "HOCs",
            "Refs",
            "Ref Forwarding",
            "React.forwardRef",
            "Wrapper Components"
          ],
          "evaluationCriteria": [
            "Accuracy and completeness of problem description.",
            "Clarity and correctness of the solution explanation.",
            "Demonstration of in-depth React understanding."
          ],
          "example": "See the `logProps` HOC example in `theory_ref_forwarding_hocs` for practical implementation.",
          "tags": [
            "React",
            "HOCs",
            "Refs",
            "Ref Forwarding",
            "Problem Solving",
            "Architecture"
          ],
          "prerequisites": [
            "react_hocs",
            "react_forwardRef"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_ref_forwarding_3",
          "topic": "Ref Forwarding in HOCs",
          "level": "hard",
          "type": "code",
          "question": "Create an HOC named `withHighlightOnMount` that takes a component (`WrappedComponent`). This HOC should add a CSS class `highlight` to the `WrappedComponent`'s root DOM element for 2 seconds immediately after mounting, then remove it. Ensure that the HOC correctly forwards any ref passed to it by its parent, allowing the parent to still interact with `WrappedComponent`'s underlying DOM element after the highlight effect fades. Assume `WrappedComponent` is a functional component that accepts a ref.",
          "answer": "```typescript\nimport React, { useEffect, useRef } from 'react';\n\n// HOC: withHighlightOnMount\nfunction withHighlightOnMount(WrappedComponent) {\n  const HighlightWrapper = React.forwardRef((props, ref) => {\n    const innerRef = useRef(null);\n    \n    // Combine the forwarded ref with our internal ref\n    const combinedRef = (node) => {\n      innerRef.current = node; // Our internal ref\n      if (typeof ref === 'function') {\n        ref(node); // Parent's ref (function form)\n      } else if (ref) {\n        ref.current = node; // Parent's ref (object form)\n      }\n    };\n\n    useEffect(() => {\n      if (innerRef.current) {\n        const element = innerRef.current;\n        element.classList.add('highlight');\n\n        const timer = setTimeout(() => {\n          element.classList.remove('highlight');\n        }, 2000);\n\n        return () => clearTimeout(timer);\n      }\n    }, []);\n\n    return <WrappedComponent ref={combinedRef} {...props} />;\n  });\n  HighlightWrapper.displayName = `withHighlightOnMount(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return HighlightWrapper;\n}\n\n// A sample component that accepts a ref\nconst MyDiv = React.forwardRef((props, ref) => (\n  <div ref={ref} style={{ padding: '10px', border: '1px solid gray', margin: '5px' }} className={props.className}>\n    {props.children}\n  </div>\n));\n\n// Create the enhanced component\nconst HighlightedDiv = withHighlightOnMount(MyDiv);\n\n// Parent component to demonstrate usage\nfunction App() {\n  const divRef = useRef(null);\n\n  useEffect(() => {\n    // After 3 seconds, log the content of the div via the forwarded ref\n    const logTimer = setTimeout(() => {\n      if (divRef.current) {\n        console.log('Content via forwarded ref after highlight:', divRef.current.innerText);\n      }\n    }, 3000);\n    return () => clearTimeout(logTimer);\n  }, []);\n\n  return (\n    <div>\n      <style>\n        {`\n          .highlight {\n            border: 2px solid red !important;\n            background-color: yellow;\n            transition: all 0.3s ease-in-out;\n          }\n        `}\n      </style>\n      <h1>HOC with Ref Forwarding and Effect</h1>\n      <HighlightedDiv ref={divRef}>This div will highlight briefly on mount.</HighlightedDiv>\n      <button onClick={() => divRef.current?.innerText = 'Updated via ref!'}>Update Div via Ref</button>\n    </div>\n  );\n}\n\n// To use this, render <App />\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `React.forwardRef` as the return of the HOC.",
            "Properly combining internal refs (for the HOC's logic) with the external (forwarded) ref.",
            "Implementing `useEffect` for the highlight logic (adding/removing class, cleanup).",
            "Ensuring the `WrappedComponent` receives the combined ref.",
            "Demonstrating parent component's ability to interact with the ref *after* the HOC's effect.",
            "Handling `displayName` for better debugging."
          ],
          "keyConcepts": [
            "HOCs",
            "Ref Forwarding",
            "React.forwardRef",
            "useRef",
            "useEffect",
            "DOM Manipulation",
            "CSS in JS"
          ],
          "evaluationCriteria": [
            "Correct HOC implementation with ref forwarding.",
            "Effective use of React Hooks for side effects.",
            "Proper cleanup of effects.",
            "Demonstration of parent interaction.",
            "Code quality and robust ref handling."
          ],
          "example": "The solution code above serves as the example.",
          "tags": [
            "React",
            "HOCs",
            "Ref Forwarding",
            "Code Challenge",
            "Advanced React",
            "Hooks"
          ],
          "prerequisites": [
            "react_hocs",
            "react_forwardRef",
            "useRef_hook",
            "useEffect_hook"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "expert"
        }
      ],
      "tasks": [
        {
          "id": "task_uncontrolled_form_builder",
          "title": "Build a Simple Uncontrolled Registration Form",
          "description": "\nCreate a React component `UncontrolledRegistrationForm` that handles user registration using uncontrolled components. The form should include:\n\n1.  **Username Input:** A text input for the username.\n2.  **Email Input:** A text input for the user's email.\n3.  **Password Input:** A password input field.\n4.  **Agree to Terms Checkbox:** A checkbox for agreeing to terms and conditions.\n5.  **Submit Button:** A button to submit the form.\n\nWhen the form is submitted, prevent the default browser behavior and log all input values (username, email, password, and whether terms were agreed) to the console. All inputs must utilize refs to access their values upon submission. Use `defaultValue` and `defaultChecked` where appropriate for initial states.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useRef } from 'react';\n\nfunction UncontrolledRegistrationForm() {\n  // Create refs here for each input\n  const usernameRef = useRef(null);\n  const emailRef = useRef(null);\n  const passwordRef = useRef(null);\n  const termsRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    // TODO: Prevent default form submission\n    // TODO: Access values from refs\n    // TODO: Log values to console\n  };\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px', maxWidth: '300px', margin: '20px auto', padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <div>\n        <label htmlFor=\"username\">Username:</label>\n        <input type=\"text\" id=\"username\" /* TODO: Attach ref and set defaultValue */ />\n      </div>\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input type=\"email\" id=\"email\" /* TODO: Attach ref and set defaultValue */ />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password:</label>\n        <input type=\"password\" id=\"password\" /* TODO: Attach ref and set defaultValue */ />\n      </div>\n      <div>\n        <input type=\"checkbox\" id=\"terms\" /* TODO: Attach ref and set defaultChecked */ />\n        <label htmlFor=\"terms\"> I agree to the terms and conditions</label>\n      </div>\n      <button type=\"submit\" style={{ padding: '8px 15px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}>Register</button>\n    </form>\n  );\n}\n\n// Example usage:\n// function App() {\n//   return <UncontrolledRegistrationForm />;\n// }\n",
          "solutionCode": "import React, { useRef } from 'react';\n\nfunction UncontrolledRegistrationForm() {\n  const usernameRef = useRef(null);\n  const emailRef = useRef(null);\n  const passwordRef = useRef(null);\n  const termsRef = useRef(null);\n\n  const handleSubmit = (event) => {\n    event.preventDefault(); // Prevent default form submission\n    \n    const username = usernameRef.current.value;\n    const email = emailRef.current.value;\n    const password = passwordRef.current.value;\n    const agreedToTerms = termsRef.current.checked;\n\n    console.log('Registration Data:', {\n      username,\n      email,\n      password,\n      agreedToTerms,\n    });\n    alert(`User ${username} registered (check console for details)!`);\n    // In a real app, you would send this data to a backend server\n  };\n\n  return (\n    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '10px', maxWidth: '300px', margin: '20px auto', padding: '20px', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <div>\n        <label htmlFor=\"username\">Username:</label>\n        <input type=\"text\" id=\"username\" ref={usernameRef} defaultValue=\"\" />\n      </div>\n      <div>\n        <label htmlFor=\"email\">Email:</label>\n        <input type=\"email\" id=\"email\" ref={emailRef} defaultValue=\"\" />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password:</label>\n        <input type=\"password\" id=\"password\" ref={passwordRef} defaultValue=\"\" />\n      </div>\n      <div>\n        <input type=\"checkbox\" id=\"terms\" ref={termsRef} defaultChecked={false} />\n        <label htmlFor=\"terms\"> I agree to the terms and conditions</label>\n      </div>\n      <button type=\"submit\" style={{ padding: '8px 15px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}>Register</button>\n    </form>\n  );\n}\n",
          "testCases": [
            "Submitting with all fields filled: Should log correct username, email, password, and `agreedToTerms: true/false`.",
            "Submitting with empty fields: Should log empty strings for text fields and correct boolean for checkbox.",
            "Verify `event.preventDefault()`: Page should not reload after submission.",
            "Initial state: Text inputs should be empty, checkbox unchecked by default."
          ],
          "hints": [
            "Remember to use `useRef` for each input element.",
            "Attach the created ref to the `ref` prop of the input elements.",
            "For a checkbox, the value is accessed via `ref.current.checked`, not `ref.current.value`.",
            "Don't forget `event.preventDefault()` inside `handleSubmit`."
          ],
          "tags": [
            "React",
            "Forms",
            "Uncontrolled Components",
            "Refs",
            "Form Handling"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_functional_components",
            "useRef_hook",
            "react_forms_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "controlled_components",
            "form_validation"
          ]
        },
        {
          "id": "task_focusable_button_component",
          "title": "Create a Reusable Focusable Button Component",
          "description": "\nImplement a `FocusableButton` React component. This component should:\n\n1.  Render a native `<button>` HTML element.\n2.  Accept a `children` prop to display text inside the button.\n3.  Crucially, it must support ref forwarding, allowing a parent component to obtain a direct reference to the underlying `<button>` DOM element and programmatically interact with it (e.g., call `focus()` or `click()`).\n4.  Demonstrate its usage in a parent `App` component where a `FocusableButton` is rendered, and an effect or an event handler programmatically focuses or clicks it after a short delay.\n\nYour solution should use `React.forwardRef` and functional components/hooks.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useRef, useEffect } from 'react';\n\n// TODO: Implement FocusableButton component using React.forwardRef\nconst FocusableButton = /* ... */;\n\nfunction App() {\n  const buttonRef = useRef(null);\n\n  useEffect(() => {\n    // TODO: Programmatically focus or click the button after a delay\n    // Hint: buttonRef.current will be the DOM element\n  }, []);\n\n  const handleClick = () => {\n    alert('Button was clicked!');\n  };\n\n  return (\n    <div>\n      <h1>Focusable Button Demo</h1>\n      {/* TODO: Render FocusableButton and pass the ref */}\n      <button onClick={() => buttonRef.current && buttonRef.current.blur()}>Blur Button (manual)</button>\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useRef, useEffect } from 'react';\n\n// FocusableButton component using React.forwardRef\nconst FocusableButton = React.forwardRef(({ children, ...props }, ref) => (\n  <button ref={ref} {...props}>\n    {children}\n  </button>\n));\n\nfunction App() {\n  const buttonRef = useRef(null);\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      if (buttonRef.current) {\n        console.log('Programmatically focusing button...');\n        buttonRef.current.focus(); // Focus the button\n        \n        // Optional: Programmatically click the button after another delay\n        setTimeout(() => {\n          console.log('Programmatically clicking button...');\n          buttonRef.current.click(); // Trigger click event\n        }, 1000);\n      }\n    }, 2000); // Focus after 2 seconds\n\n    return () => clearTimeout(timer);\n  }, []);\n\n  const handleClick = () => {\n    alert('Button was clicked via user interaction or programmatically!');\n  };\n\n  return (\n    <div style={{ display: 'flex', flexDirection: 'column', gap: '15px', padding: '20px' }}>\n      <h1>Focusable Button Demo</h1>\n      <p>The button below will be focused and then clicked programmatically after a delay.</p>\n      <FocusableButton ref={buttonRef} onClick={handleClick} style={{ padding: '10px 20px', fontSize: '1.2em' }}>\n        My Awesome Button\n      </FocusableButton>\n      <button onClick={() => buttonRef.current && buttonRef.current.blur()} style={{ padding: '8px 15px' }}>Blur Button (manual)</button>\n    </div>\n  );\n}\n",
          "testCases": [
            "Button is rendered with correct text.",
            "Button is programmatically focused after initial mount (check browser focus indicator).",
            "Button is programmatically clicked after focus (check `alert` or console message).",
            "Manual 'Blur Button' click correctly unfocuses the `FocusableButton`."
          ],
          "hints": [
            "Remember that `React.forwardRef` takes a render function with two arguments: `props` and `ref`.",
            "The `ref` argument needs to be attached directly to the native DOM element you want to expose.",
            "Use `useEffect` with `setTimeout` for timed actions in the parent component.",
            "Ensure cleanup for `setTimeout` using the return function of `useEffect`."
          ],
          "tags": [
            "React",
            "Refs",
            "Ref Forwarding",
            "Component Design",
            "Hooks",
            "DOM Interaction"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_functional_components",
            "useRef_hook",
            "useEffect_hook"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "imperative_react",
            "higher_order_components"
          ]
        },
        {
          "id": "task_hoc_autofocus_input",
          "title": "Create a `withAutoFocus` HOC with Ref Forwarding",
          "description": "\nDevelop a Higher-Order Component (HOC) called `withAutoFocus`. This HOC should:\n\n1.  Take any React component (`WrappedComponent`) as an argument.\n2.  Return a new component that automatically focuses the `WrappedComponent`'s root DOM element when it mounts.\n3.  Crucially, ensure that the `withAutoFocus` HOC correctly forwards any ref passed to it by its parent component. This means the parent should still be able to get a direct reference to the `WrappedComponent`'s underlying DOM element.\n4.  Provide a `WrappedComponent` (e.g., a simple `Input` component) that uses `React.forwardRef` to expose its internal input element.\n5.  Demonstrate the usage by applying `withAutoFocus` to your `Input` component and rendering it in an `App` component. Verify that the input is focused on mount and that you can still log its value via a ref from `App`.\n\n**Assumptions:** The `WrappedComponent` you pass to `withAutoFocus` will itself support `React.forwardRef` if it's a functional component that needs ref access to its DOM children.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useRef, useEffect } from 'react';\n\n// TODO: Implement the withAutoFocus HOC\nfunction withAutoFocus(WrappedComponent) {\n  // Remember to use React.forwardRef here for the HOC's return\n  // and pass the received ref down as a prop.\n  return /* ... */;\n}\n\n// A sample WrappedComponent that supports ref forwarding\nconst MyInput = React.forwardRef((props, ref) => {\n  return <input type=\"text\" ref={ref} placeholder={props.placeholder} {...props} />;\n});\n\n// Apply the HOC\nconst AutoFocusedInput = withAutoFocus(MyInput);\n\nfunction App() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // TODO: Verify the input is focused automatically.\n    // TODO: After a delay, log the input's current value using inputRef.\n  }, []);\n\n  const handleButtonClick = () => {\n    if (inputRef.current) {\n      alert('Current value: ' + inputRef.current.value);\n    }\n  };\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h1>Auto-Focused Input Demo (HOC with Ref Forwarding)</h1>\n      <AutoFocusedInput ref={inputRef} placeholder=\"Type something...\" />\n      <button onClick={handleButtonClick} style={{ marginLeft: '10px' }}>Get Value via Parent Ref</button>\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useRef, useEffect } from 'react';\n\n// HOC: withAutoFocus\nfunction withAutoFocus(WrappedComponent) {\n  class FocusWrapper extends React.Component {\n    componentDidMount() {\n      // Check if the forwardedRef exists and has a current property (DOM node)\n      if (this.props.forwardedRef && this.props.forwardedRef.current) {\n        console.log('AutoFocus HOC: Focusing input!');\n        this.props.forwardedRef.current.focus();\n      }\n    }\n\n    render() {\n      const { forwardedRef, ...restProps } = this.props;\n      // Pass the forwardedRef to the WrappedComponent as its 'ref' prop\n      return <WrappedComponent ref={forwardedRef} {...restProps} />;\n    }\n  }\n\n  // Use React.forwardRef to pass the parent's ref into the HOC's wrapper component\n  const ComponentWithRef = React.forwardRef((props, ref) => {\n    // Here, 'ref' is the ref from the component that consumes AutoFocusedInput.\n    // We pass it to FocusWrapper as a regular prop named 'forwardedRef'.\n    return <FocusWrapper {...props} forwardedRef={ref} />;\n  });\n\n  // Good practice for debugging: give the HOC a display name\n  ComponentWithRef.displayName = `withAutoFocus(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return ComponentWithRef;\n}\n\n// A sample WrappedComponent that supports ref forwarding\nconst MyInput = React.forwardRef((props, ref) => {\n  return <input type=\"text\" ref={ref} placeholder={props.placeholder} {...props} />;\n});\n\n// Apply the HOC\nconst AutoFocusedInput = withAutoFocus(MyInput);\n\nfunction App() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // The input should be focused automatically by the HOC\n    console.log('App component mounted. Input should be auto-focused.');\n\n    const timer = setTimeout(() => {\n      if (inputRef.current) {\n        console.log('App: Current input value via forwarded ref:', inputRef.current.value);\n      }\n    }, 3000);\n    return () => clearTimeout(timer);\n  }, []);\n\n  const handleButtonClick = () => {\n    if (inputRef.current) {\n      alert('Current value from parent ref: ' + inputRef.current.value);\n    }\n  };\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h1>Auto-Focused Input Demo (HOC with Ref Forwarding)</h1>\n      <p>The input below should be automatically focused on page load.</p>\n      <AutoFocusedInput ref={inputRef} placeholder=\"Type something...\" />\n      <button onClick={handleButtonClick} style={{ marginLeft: '10px', padding: '8px 15px' }}>Get Value via Parent Ref</button>\n      <p style={{ marginTop: '20px', fontSize: '0.9em', color: '#666' }}>Try typing something and then click 'Get Value via Parent Ref'.</p>\n    </div>\n  );\n}\n",
          "testCases": [
            "Input field is automatically focused on component mount (visually confirm cursor in input).",
            "Typing into the input field works normally.",
            "Clicking 'Get Value via Parent Ref' button correctly displays the current value of the input, proving the ref forwarding works.",
            "No console errors or warnings related to refs or HOCs."
          ],
          "hints": [
            "The HOC must return `React.forwardRef(...)`.",
            "Inside the `forwardRef` render function, the second argument is the `ref` from the parent. Pass this as a regular prop (e.g., `forwardedRef`) to your HOC's internal wrapper component.",
            "The internal wrapper component (a class component for `componentDidMount` or a functional one with `useEffect`) then uses `this.props.forwardedRef` (or just `forwardedRef` for functional) and attaches it to the `WrappedComponent` via its `ref` prop.",
            "Remember to check `ref.current` before trying to access properties like `focus()` or `value`."
          ],
          "tags": [
            "React",
            "HOCs",
            "Ref Forwarding",
            "Code Challenge",
            "Advanced React",
            "Hooks"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "react_hocs",
            "react_forwardRef",
            "useRef_hook",
            "useEffect_hook",
            "react_class_components"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "expert",
          "relatedConcepts": [
            "render_props",
            "custom_hooks",
            "imperative_handles"
          ]
        }
      ]
    }
  },
  {
    "id": "9f907456-bdef-4313-855f-6f398f6b2d8c",
    "startLine": 4100,
    "endLine": 4199,
    "processedDate": "2025-06-17T09:03:46.656Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_forward_ref",
          "title": "React.forwardRef: Forwarding Refs in React",
          "content": "Refs in React provide a way to access DOM nodes or React components created in the render method. However, when you use Higher-Order Components (HOCs) or render props, refs are not automatically passed through to the wrapped component or the component rendered by the render prop. This is because `ref` is a special prop, handled directly by React, and it's not simply passed down like other props.\n\n`React.forwardRef` is a React utility that addresses this limitation. It allows your component to receive a ref and pass it further down to one of its children.\n\n## Key Concepts\n- **Problem Statement**: Standard props are passed down, but `ref` is a special prop that is consumed by React itself when attaching to a component instance or DOM node. When a component wraps another component (e.g., via HOCs or render props), the ref placed on the wrapper component refers to the *wrapper component itself*, not the inner component you might intend to reference.\n- **Solution**: `React.forwardRef` creates a React component that takes `props` and `ref` as arguments in its render function. The `ref` argument is the actual ref that was passed from the parent component.\n- **Syntax**: `React.forwardRef((props, ref) => <MyComponent ref={ref} {...props} />)`\n- **Use Cases**: Primarily used when building reusable component libraries, HOCs, or render prop components where you need to expose an underlying DOM element or component instance to a parent component for imperative actions (e.g., `focus()`, `measure()`).\n\n## Note on Refs with HOCs\nRefs are *not* passed through HOCs (Higher Order Components) by default. If you try to place a ref on a HOC-wrapped component, you will get a ref to the *outer wrapper component* (the HOC itself), not the wrapped component. `React.forwardRef` is essential to enable ref forwarding through HOCs, allowing the HOC to 'see' the ref and pass it to its `WrappedComponent`.",
          "examples": [
            {
              "id": "example_forward_ref_1",
              "title": "Forwarding Ref with a Higher-Order Component",
              "code": "import React from 'react';\n\n// A Higher-Order Component (HOC) that logs props.\n// It needs to be ref-aware to forward refs.\nfunction logProps(WrappedComponent) {\n  class LogProps extends React.Component {\n    // This is where React.forwardRef injects the ref\n    // The ref passed by the parent component will be assigned to this.ref\n    render() {\n      const { forwardedRef, ...rest } = this.props;\n      // console.log('Props:', rest);\n      return <WrappedComponent ref={forwardedRef} {...rest} />;\n    }\n  }\n\n  // Using React.forwardRef to pass the ref to the internal WrappedComponent\n  // The second argument 'ref' is the ref passed by the parent.\n  return React.forwardRef((props, ref) => {\n    return <LogProps {...props} forwardedRef={ref} />;\n  });\n}\n\n// A functional component (or class component) that needs its ref forwarded.\n// It receives the ref as the second argument if wrapped by forwardRef.\nconst FancyButton = React.forwardRef((props, ref) => (\n  <button ref={ref} className=\"FancyButton\">\n    {props.label}\n  </button>\n));\n\n// Original class component, before forwarding ref was applied directly\n// class FancyButton extends React.Component {\n//   focus() {\n//     // Implementation for focusing\n//     console.log('FancyButton focused!');\n//     this.buttonRef.current.focus();\n//   }\n//\n//   constructor(props) {\n//     super(props);\n//     this.buttonRef = React.createRef();\n//   }\n//\n//   render() {\n//     return <button ref={this.buttonRef}>Click me!</button>;\n//   }\n// }\n\n// Export wrapped component\nconst EnhancedFancyButton = logProps(FancyButton);\n\n// Consumer component\nfunction App() {\n  const ref = React.createRef();\n  \n  // The ref will be forwarded to the FancyButton component\n  const handleFocus = () => {\n    if (ref.current) {\n      // This calls the .focus() method of the underlying HTML button element\n      ref.current.focus();\n    }\n  };\n\n  return (\n    <div>\n      <EnhancedFancyButton ref={ref} label=\"Click Me\" />\n      <button onClick={handleFocus}>Focus the fancy button</button>\n    </div>\n  );\n}\n\n// To demonstrate the original class component with internal ref and its focus method:\nclass OriginalFancyButton extends React.Component {\n  constructor(props) {\n    super(props);\n    this.buttonRef = React.createRef();\n  }\n  \n  focus() {\n    // Implementation\n    console.log('OriginalFancyButton focused!');\n    this.buttonRef.current.focus();\n  }\n  \n  render() {\n    return <button ref={this.buttonRef}>Click me!</button>;\n  }\n}\n\n// Export wrapped component (if we were using the original class)\n// const EnhancedOriginalFancyButton = logProps(OriginalFancyButton);\n\n// // Consumer component demonstrating original class focus\n// function AppOriginal() {\n//   const ref = React.createRef();\n//   return (\n//     <div>\n//       {/* Without forwardRef on the OriginalFancyButton itself, this ref \n//           would refer to the LogProps instance, not the FancyButton. */}\n//       <EnhancedOriginalFancyButton ref={ref} label=\"Click Me\" />\n//       <button onClick={() => ref.current.focus()}>Focus the fancy button (Original)</button>\n//     </div>\n//   );\n// }",
              "explanation": "This example demonstrates how `React.forwardRef` is used to allow a parent component (`App`) to obtain a ref to an underlying DOM element (the `<button>` inside `FancyButton`), even when `FancyButton` is wrapped by a Higher-Order Component (`logProps`).\n\n1.  `FancyButton` is defined using `React.forwardRef`. This makes `FancyButton` a 'ref-aware' component, meaning it accepts a `ref` prop as its second argument in the render function. This `ref` is then passed directly to the `<button>` element.\n2.  The `logProps` HOC also uses `React.forwardRef`. Inside `logProps`, a wrapper component (`LogProps` class) is created. The `ref` argument from `React.forwardRef` is passed as a regular prop (`forwardedRef`) to this internal `LogProps` component. `LogProps` then renders the `WrappedComponent` (`FancyButton`) and attaches `forwardedRef` to its `ref` prop.\n3.  In `App`, `React.createRef()` creates a ref object. When `EnhancedFancyButton` (the HOC-wrapped `FancyButton`) is rendered with `ref={ref}`, this ref is forwarded through `logProps` and eventually reaches the `<button>` element inside `FancyButton`.\n4.  Clicking 'Focus the fancy button' calls `ref.current.focus()`. Because the ref points directly to the HTML button element, its native `focus()` method is invoked, demonstrating successful ref forwarding.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Refs",
            "forwardRef",
            "HOCs",
            "Composition"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_props",
            "react_refs"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "custom_form_controls",
            "third_party_integrations"
          ]
        },
        {
          "id": "theory_higher_order_components",
          "title": "Higher-Order Components (HOCs)",
          "content": "A Higher-Order Component (HOC) is an advanced technique in React for reusing component logic. HOCs are *not* part of the React API; rather, they are a pattern that emerges from React's compositional nature. They are a powerful way to share reusable functionality between components without modifying the components themselves.\n\n## Definition\nA HOC is a function that takes a component and returns a new enhanced component.\n\n```typescript\nconst EnhancedComponent = higherOrderComponent(WrappedComponent);\n```\n\nHOCs solve the problem of code reuse across components with shared functionality, avoiding issues like:\n- **Cross-cutting concerns**: Logic that applies to many components (e.g., data fetching, authentication, logging, styling).\n- **Repetitive logic**: Avoiding writing the same `componentDidMount`, `setState` logic, or rendering conditionals in multiple components.\n- **Render prop and Hook alternatives**: Before Hooks became standard, HOCs (along with render props) were the primary way to share stateful logic.\n\n## Common HOC Patterns\nThere are generally two ways HOCs manipulate the `WrappedComponent`:\n\n### 1. Proxy Props (or Props Proxy)\nThis pattern involves the HOC rendering the `WrappedComponent` and passing additional props to it. It can also read, manipulate, or inject props, or even control the rendering of the `WrappedComponent` (e.g., conditional rendering).\n\n**Characteristics:**\n- The HOC returns a class or functional component that renders the `WrappedComponent`.\n- It receives props from its parent and forwards them to the `WrappedComponent`.\n- It can inject new props, modify existing props, or filter props.\n\n### 2. State Injection (or HOCs for State Management)\nThis pattern focuses on injecting state and methods related to that state into the `WrappedComponent`. The HOC manages its own internal state and passes relevant parts of that state (and possibly updater functions) as props to the `WrappedComponent`.\n\n**Characteristics:**\n- The HOC typically manages state and lifecycle methods (for class HOCs).\n- It subscribes to external data sources or performs data fetching.\n- It passes the derived data as props to the `WrappedComponent`.\n\n## Naming Conventions\nIt's common to prefix HOCs with `with` (e.g., `withRouter`, `withTheme`, `withSubscription`) to clearly indicate that they are higher-order components.",
          "examples": [
            {
              "id": "example_hoc_proxy_props",
              "title": "Creating HOCs with Proxy Props",
              "code": "import React from 'react';\n\nfunction withExtraProps(WrappedComponent) {\n  return class EnhancedComponent extends React.Component {\n    render() {\n      // Pass through existing props and add new ones\n      const newProps = {\n        title: 'New Header',\n        footer: false,\n        showFeatureX: false,\n        showFeatureY: true\n      };\n      // Ensure existing props are spread first to allow them to be overridden\n      // by newProps if desired, or newProps first to allow overrides from parent\n      // (depends on desired precedence). Here, newProps can override this.props.\n      return <WrappedComponent {...this.props} {...newProps} />;\n    }\n  };\n}\n\n// Usage Example:\nfunction MyComponent(props) {\n  return (\n    <div>\n      <h1>{props.title || 'Default Title'}</h1>\n      <p>Hello, {props.name}!</p>\n      {props.showFeatureY && <p>Feature Y is enabled.</p>}\n      {!props.footer && <p>No footer here.</p>}\n    </div>\n  );\n}\n\nconst EnhancedMyComponent = withExtraProps(MyComponent);\n\n// In your App or another component:\n// function App() {\n//   return <EnhancedMyComponent name=\"World\" />;\n// }",
              "explanation": "This example demonstrates the 'Proxy Props' pattern. The `withExtraProps` HOC takes `WrappedComponent` and returns `EnhancedComponent`. `EnhancedComponent`'s `render` method simply renders `WrappedComponent`, but importantly, it injects a set of predefined `newProps` along with all the props it received from its parent (`this.props`). This allows the HOC to provide default values, additional features, or override props for the `WrappedComponent` without `WrappedComponent` itself needing to be aware of these injected props directly. The `MyComponent` then receives `name`, `title`, `footer`, `showFeatureX`, and `showFeatureY` as its props, even if the parent only passed `name`.",
              "language": "typescript"
            },
            {
              "id": "example_hoc_state_injection",
              "title": "Creating HOCs with State Injection",
              "code": "import React from 'react';\n\n// A mock data source for demonstration purposes\nconst DataSource = {\n  data: 'Initial Data',\n  listeners: [],\n  getData: function(props) {\n    // Simulate data selection based on props\n    return `Data for ${props.id || 'default'}: ${this.data}`;\n  },\n  addChangeListener: function(callback) {\n    this.listeners.push(callback);\n  },\n  removeChangeListener: function(callback) {\n    this.listeners = this.listeners.filter(cb => cb !== callback);\n  },\n  // Simulate data changes\n  changeData: function(newData) {\n    this.data = newData;\n    this.listeners.forEach(cb => cb());\n  }\n};\n\nfunction withSubscription(WrappedComponent, selectData) {\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        data: selectData(DataSource, props)\n      };\n    }\n\n    componentDidMount() {\n      // Subscribe to changes\n      DataSource.addChangeListener(this.handleChange);\n    }\n\n    componentWillUnmount() {\n      // Clean up subscription\n      DataSource.removeChangeListener(this.handleChange);\n    }\n\n    handleChange = () => {\n      this.setState({\n        data: selectData(DataSource, this.props)\n      });\n    };\n\n    render() {\n      // Pass all props and inject state as additional prop\n      // The 'data' prop is injected from the HOC's state.\n      return <WrappedComponent data={this.state.data} {...this.props} />;\n    }\n  };\n}\n\n// Usage Example:\nfunction MyDataComponent(props) {\n  return (\n    <div>\n      <h2>Subscribed Data:</h2>\n      <p>{props.data}</p>\n      <p>Component ID: {props.id}</p>\n    </div>\n  );\n}\n\n// This HOC will subscribe MyDataComponent to changes in DataSource\nconst MyEnhancedDataComponent = withSubscription(MyDataComponent, (source, props) => source.getData(props));\n\n// To use it in an App:\n// function App() {\n//   React.useEffect(() => {\n//     // Simulate data changing after some time\n//     const timer = setTimeout(() => {\n//       DataSource.changeData('Updated Data from HOC!');\n//     }, 2000);\n//     return () => clearTimeout(timer);\n//   }, []);\n//\n//   return (\n//     <div>\n//       <MyEnhancedDataComponent id=\"123\" />\n//       <button onClick={() => DataSource.changeData('Manual Data Update!')}>Manual Update</button>\n//     </div>\n//   );\n// }",
              "explanation": "This example illustrates the 'State Injection' pattern. The `withSubscription` HOC is responsible for managing data subscription. It creates an internal state (`this.state.data`), subscribes to `DataSource` changes in `componentDidMount`, updates its state on change (`handleChange`), and cleans up in `componentWillUnmount`. Finally, it renders the `WrappedComponent` (`MyDataComponent`), passing the managed `data` as a prop. This abstracts away the data fetching/subscription logic from `MyDataComponent`, allowing `MyDataComponent` to be a purely presentational component that just receives `data` as a prop.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "HOCs",
            "Code Reuse",
            "Design Patterns",
            "Component Composition",
            "Higher Order Functions"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_props",
            "react_state",
            "react_lifecycle_methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "scalable_applications",
            "custom_libraries",
            "legacy_codebases"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_forward_ref_1",
          "topic": "React.forwardRef Fundamentals",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary purpose of `React.forwardRef`?",
          "answer": "To allow a parent component to obtain a ref to an underlying DOM element or React component instance inside a child component, especially when using HOCs or render props.",
          "options": [
            "To allow a parent component to obtain a ref to an underlying DOM element or React component instance inside a child component, especially when using HOCs or render props.",
            "To create a Higher-Order Component that injects a ref prop into the wrapped component.",
            "To optimize component re-renders by preventing unnecessary ref updates.",
            "To explicitly pass a ref from a functional component to its immediate child."
          ],
          "analysisPoints": [
            "`React.forwardRef` explicitly addresses the limitation of refs not being automatically passed through intermediate components.",
            "It's crucial for component libraries or when abstracting DOM access behind reusable components.",
            "While HOCs might be involved, `forwardRef`'s purpose is broader than just HOCs; it's about ref 'tunneling'."
          ],
          "keyConcepts": [
            "React.forwardRef",
            "Refs",
            "Higher-Order Components (HOCs)",
            "Component Composition"
          ],
          "evaluationCriteria": [
            "Understanding of the core problem `forwardRef` solves.",
            "Distinguishing its purpose from HOC creation or performance optimization."
          ],
          "example": "```typescript\nconst MyInput = React.forwardRef((props, ref) => (\n  <input ref={ref} {...props} />\n));\n\nfunction ParentComponent() {\n  const inputRef = React.useRef(null);\n\n  const handleClick = () => {\n    inputRef.current.focus();\n  };\n\n  return (\n    <div>\n      <MyInput ref={inputRef} placeholder=\"Type here...\" />\n      <button onClick={handleClick}>Focus Input</button>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "Refs",
            "forwardRef",
            "HOCs"
          ],
          "prerequisites": [
            "react_refs",
            "react_props"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_forward_ref_2",
          "topic": "Ref Passing through HOCs",
          "level": "hard",
          "type": "open",
          "question": "Explain why refs are not automatically passed through Higher-Order Components (HOCs) by default, and provide a detailed explanation of how `React.forwardRef` addresses this limitation with a suitable code example.",
          "answer": "Refs are a special prop in React. Unlike regular props, `ref` is handled directly by React's reconciliation process to attach to a component instance or DOM node. When you place a `ref` on a component `MyHOC(MyComponent)`, React attaches the ref to the instance of `MyHOC`'s internal wrapper component, not to `MyComponent` itself. This is because `MyHOC` acts as an intermediate layer, obscuring `MyComponent` from the parent's direct ref assignment.\n\n`React.forwardRef` solves this by creating a component that explicitly forwards the `ref` prop it receives to an inner component. When you wrap `MyComponent` with `React.forwardRef` (or create your HOC to use `React.forwardRef`), it allows React to 'see' the ref prop and make it available as a second argument (`ref`) in the component's render function. This `ref` argument can then be explicitly passed down to the intended inner component or DOM element. The HOC itself would also need to be ref-aware, often by also wrapping its returned component with `React.forwardRef` and passing the ref as a regular prop internally before applying it.",
          "analysisPoints": [
            "Understanding of React's special handling of the `ref` prop.",
            "Ability to explain the 'ref-chain' break caused by intermediate components (HOCs).",
            "Clear articulation of `forwardRef`'s role in breaking this limitation.",
            "Correct implementation of `forwardRef` in both the wrapped component and potentially the HOC."
          ],
          "keyConcepts": [
            "React.forwardRef",
            "Refs",
            "Higher-Order Components",
            "Special Props"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of the explanation.",
            "Demonstrated understanding of React's internal ref mechanism.",
            "Correct and illustrative code example."
          ],
          "example": "```typescript\nimport React from 'react';\n\n// HOC that logs props, now also forwards refs\nfunction withLogger(WrappedComponent) {\n  class Logger extends React.Component {\n    render() {\n      const { forwardedRef, ...rest } = this.props;\n      console.log('Props received by HOC:', rest);\n      return <WrappedComponent ref={forwardedRef} {...rest} />;\n    }\n  }\n  \n  // This ensures the HOC itself is ref-aware\n  return React.forwardRef((props, ref) => {\n    return <Logger {...props} forwardedRef={ref} />;\n  });\n}\n\n// Component that needs its ref forwarded\nconst TextInput = React.forwardRef((props, ref) => (\n  <input type=\"text\" ref={ref} placeholder={props.placeholder} />\n));\n\n// Applying the HOC to the ref-aware component\nconst EnhancedTextInput = withLogger(TextInput);\n\nfunction App() {\n  const inputRef = React.useRef(null);\n\n  const handleFocus = () => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  };\n\n  return (\n    <div>\n      <EnhancedTextInput ref={inputRef} placeholder=\"Enter text...\" />\n      <button onClick={handleFocus}>Focus Input via Ref</button>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "Refs",
            "forwardRef",
            "HOCs",
            "Advanced React"
          ],
          "prerequisites": [
            "react_refs",
            "higher_order_components"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_1",
          "topic": "Higher-Order Components Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of a Higher-Order Component (HOC) in React?",
          "answer": "To reuse component logic across multiple components.",
          "analysisPoints": [
            "Focus on the core concept of code reuse.",
            "HOCs allow sharing behaviors without altering component structure."
          ],
          "keyConcepts": [
            "Higher-Order Components",
            "Code Reuse",
            "Design Patterns"
          ],
          "evaluationCriteria": [
            "Ability to recall the fundamental definition."
          ],
          "example": "A HOC like `withRouter` adds routing capabilities to any component it wraps, without the component itself needing to implement routing logic.",
          "tags": [
            "React",
            "HOCs",
            "Definition"
          ],
          "prerequisites": [
            "react_components"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_2",
          "topic": "HOC Characteristics",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements is TRUE about Higher-Order Components (HOCs) in React?",
          "answer": "A HOC is a function that takes a component as an argument and returns a new, enhanced component.",
          "options": [
            "A HOC is a function that takes a component as an argument and returns a new, enhanced component.",
            "HOCs are part of the core React API and are specifically designed for state management.",
            "HOCs should always modify the passed component's prototype directly.",
            "HOCs are primarily used for rendering conditional JSX based on props."
          ],
          "analysisPoints": [
            "The definition of HOC as a function transforming components is central.",
            "HOCs are a pattern, not part of the core React API.",
            "Modifying prototypes is an anti-pattern for HOCs (side effects, hard to debug).",
            "While HOCs *can* do conditional rendering, it's not their *primary* distinguishing feature."
          ],
          "keyConcepts": [
            "Higher-Order Components",
            "React API",
            "Functional Programming Pattern"
          ],
          "evaluationCriteria": [
            "Accurate understanding of HOC definition and nature.",
            "Distinguishing HOCs from other React concepts or anti-patterns."
          ],
          "example": "```typescript\n// Correct HOC pattern\nfunction withLogger(WrappedComponent) {\n  return function LoggedComponent(props) {\n    console.log(`Rendering ${WrappedComponent.name} with props:`, props);\n    return <WrappedComponent {...props} />;\n  };\n}\n\n// Incorrect (anti-pattern: mutating original component)\n// function badHOC(Component) {\n//   Component.prototype.someMethod = () => console.log('Bad idea');\n//   return Component;\n// }\n```",
          "tags": [
            "React",
            "HOCs",
            "Fundamentals"
          ],
          "prerequisites": [
            "react_components"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_3",
          "topic": "HOC Patterns",
          "level": "medium",
          "type": "open",
          "question": "Describe two common patterns for implementing Higher-Order Components (HOCs): Proxy Props and State Injection. For each, provide a brief explanation of how it works and a typical use case.",
          "answer": "1.  **Proxy Props (or Props Proxy)**:\n    *   **How it works**: The HOC renders the `WrappedComponent` and passes through (proxies) the original props, while also having the ability to inject new props, modify existing ones, or filter them out. The HOC itself doesn't typically manage significant state related to the `WrappedComponent`'s behavior, but rather augments its rendering context.\n    *   **Typical Use Case**: Adding common props like `theme` data, user roles, or global configurations. For instance, a `withAuthorization` HOC that injects an `isAuthorized` prop based on the current user, or a `withStyles` HOC that injects styling props.\n\n2.  **State Injection (or HOCs for State Management)**:\n    *   **How it works**: The HOC manages its own internal state, often involving side effects like data fetching, subscriptions, or lifecycle methods. It then passes a portion of this managed state, along with any relevant state-updating methods, as props to the `WrappedComponent`. This offloads stateful logic from the `WrappedComponent`.\n    *   **Typical Use Case**: Connecting to external data stores (e.g., Redux `connect`, a `withSubscription` HOC to a global `DataSource`), handling form input state, or managing UI states like toggles or loading indicators. For example, a `withLoading` HOC that fetches data and injects `isLoading` and `data` props.",
          "analysisPoints": [
            "Clear distinction between prop manipulation and state management roles.",
            "Accurate description of the mechanism for each pattern.",
            "Relevant and distinct use cases for both patterns."
          ],
          "keyConcepts": [
            "Higher-Order Components",
            "Proxy Props",
            "State Injection",
            "Code Reusability"
          ],
          "evaluationCriteria": [
            "Thoroughness of explanation.",
            "Ability to connect patterns to practical scenarios.",
            "Clarity and conciseness."
          ],
          "example": "```typescript\n// Proxy Props example (from theory)\nfunction withExtraProps(WrappedComponent) { \n  return class EnhancedComponent extends React.Component { \n    render() {\n      const newProps = { \n        timestamp: Date.now() \n      }\n      return <WrappedComponent {...this.props} {...newProps} />\n    }\n  }\n}\n\n// State Injection example (simplified)\nfunction withToggle(WrappedComponent) {\n  return class ToggleComponent extends React.Component {\n    state = { isOn: false };\n    toggle = () => this.setState(prevState => ({ isOn: !prevState.isOn }));\n    render() {\n      return <WrappedComponent {...this.props} isOn={this.state.isOn} toggle={this.toggle} />;\n    }\n  };\n}\n```",
          "tags": [
            "React",
            "HOCs",
            "Patterns",
            "Design"
          ],
          "prerequisites": [
            "react_state",
            "react_props"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_4",
          "topic": "HOC Use Cases",
          "level": "hard",
          "type": "coding",
          "question": "Implement a Higher-Order Component named `withAuthentication` that checks if a user is authenticated. If the user is authenticated, it should render the `WrappedComponent`. If not, it should render a `<p>` tag displaying 'Please log in to view this content.' For simplicity, `isAuthenticated` can be a boolean passed as a prop to the HOC's returned component. Demonstrate its usage with a `Dashboard` component.",
          "answer": "```typescript\nimport React from 'react';\n\nfunction withAuthentication(WrappedComponent) {\n  return function AuthenticatedComponent(props) {\n    const { isAuthenticated, ...restProps } = props;\n\n    if (isAuthenticated) {\n      return <WrappedComponent {...restProps} />;\n    } else {\n      return <p>Please log in to view this content.</p>;\n    }\n  };\n}\n\n// Example WrappedComponent\nfunction Dashboard(props) {\n  return (\n    <div>\n      <h2>Welcome to your Dashboard, {props.username || 'Guest'}!</h2>\n      <p>Here's some secret content.</p>\n    </div>\n  );\n}\n\nconst AuthenticatedDashboard = withAuthentication(Dashboard);\n\n// How to use it:\nfunction App() {\n  const [loggedIn, setLoggedIn] = React.useState(false);\n\n  return (\n    <div>\n      <h1>My Application</h1>\n      <button onClick={() => setLoggedIn(!loggedIn)}>\n        {loggedIn ? 'Log Out' : 'Log In'}\n      </button>\n      <hr />\n      <AuthenticatedDashboard isAuthenticated={loggedIn} username=\"Alice\" />\n    </div>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n```",
          "analysisPoints": [
            "Correct implementation of a HOC (function returning a component).",
            "Proper prop spreading (`...restProps`) to ensure original props are passed.",
            "Conditional rendering based on injected logic.",
            "Demonstration of usage with a sample component."
          ],
          "keyConcepts": [
            "Higher-Order Components",
            "Conditional Rendering",
            "Props Spreading",
            "Code Reuse"
          ],
          "evaluationCriteria": [
            "Functional correctness of the HOC.",
            "Adherence to HOC pattern.",
            "Clarity of demonstration."
          ],
          "example": "The HOC `withAuthentication` takes `Dashboard` and returns `AuthenticatedDashboard`. `AuthenticatedDashboard` then conditionally renders `Dashboard` or a login message based on the `isAuthenticated` prop it receives from its parent (`App`). This encapsulates the authentication logic, keeping `Dashboard` clean and focused on its content.",
          "tags": [
            "React",
            "HOCs",
            "Authentication",
            "Conditional Rendering",
            "Coding"
          ],
          "prerequisites": [
            "react_components",
            "react_props"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_forward_ref_3",
          "topic": "React.forwardRef vs. React.useRef",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the key difference between `React.createRef()` (or `useRef`) and `React.forwardRef`?",
          "answer": "`React.createRef()` (or `useRef` for functional components) is used to *create* a ref object that can hold a mutable value. `React.forwardRef` is used to *pass* a ref created by a parent component *through* a component to an underlying DOM element or another component.",
          "analysisPoints": [
            "Distinguishes between creating and propagating refs.",
            "Highlights their different roles in the ref mechanism."
          ],
          "keyConcepts": [
            "React.createRef",
            "React.useRef",
            "React.forwardRef",
            "Refs"
          ],
          "evaluationCriteria": [
            "Accurate differentiation of ref utilities."
          ],
          "example": "```typescript\n// Creating a ref\nconst myRef = React.createRef(); // For class components\nconst myRefHook = React.useRef(null); // For functional components\n\n// Passing a ref using forwardRef\nconst ChildComponent = React.forwardRef((props, ref) => (\n  <input ref={ref} />\n));\n```",
          "tags": [
            "React",
            "Refs",
            "forwardRef",
            "useRef",
            "createRef"
          ],
          "prerequisites": [
            "react_refs"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_forward_ref_hoc_integration",
          "title": "Implement a Ref-Forwarding Input Component with a Validation HOC",
          "description": "\nCreate a `CustomInput` component that renders an `<input>` element. This `CustomInput` should be ref-aware, meaning it can receive a ref from its parent and forward it to the internal `<input>` element.\n\nNext, implement a Higher-Order Component named `withValidation`.\nThis HOC should:\n1.  Take a `WrappedComponent` as an argument.\n2.  Manage an internal `isValid` state, initialized to `true`.\n3.  Provide a `validate` method (e.g., through a prop to the `WrappedComponent` or via an exposed `useImperativeHandle` for complex validation).\n4.  Render the `WrappedComponent`, passing along all original props and potentially injecting a prop like `isValid`.\n5.  The `withValidation` HOC itself must also correctly forward refs to its `WrappedComponent`.\n\nFinally, demonstrate how to use `CustomInput` wrapped by `withValidation` in an `App` component. The `App` component should:\n-   Render the `ValidatedInput` (the HOC-wrapped `CustomInput`).\n-   Have a button that, when clicked, focuses the `ValidatedInput` using a ref *obtained from the `App` component*.\n-   Have another button that triggers a simple validation logic (e.g., check if input is not empty) via the `withValidation` HOC.\n\n**Requirements:**\n-   `CustomInput` uses `React.forwardRef`.\n-   `withValidation` HOC uses `React.forwardRef` to correctly pass refs to the `CustomInput`.\n-   The `App` component should successfully focus the input via the ref.\n-   The `withValidation` HOC should manage a simple validation state (e.g., `isValid` based on input value not being empty).\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useRef, useImperativeHandle } from 'react';\n\n// 1. Create CustomInput using React.forwardRef\nconst CustomInput = React.forwardRef((props, ref) => {\n  // TODO: Render an <input> element and forward the ref\n  return <input {...props} ref={ref} />;\n});\n\n// 2. Create withValidation HOC that also uses React.forwardRef\nfunction withValidation(WrappedComponent) {\n  class WithValidationLogic extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = { isValid: true };\n      this.inputRef = React.createRef(); // Internal ref to wrapped component\n      // Expose validate method if needed using useImperativeHandle on outer component\n    }\n\n    // Example validation method\n    validate = (value) => {\n      const valid = value.trim() !== ''; // Simple check for non-empty\n      this.setState({ isValid: valid });\n      return valid;\n    };\n\n    render() {\n      const { forwardedRef, ...rest } = this.props;\n      return (\n        <WrappedComponent\n          ref={forwardedRef}\n          isValid={this.state.isValid}\n          validate={this.validate}\n          {...rest}\n        />\n      );\n    }\n  }\n\n  return React.forwardRef((props, ref) => (\n    <WithValidationLogic {...props} forwardedRef={ref} />\n  ));\n}\n\n// 3. Apply the HOC\nconst ValidatedInput = withValidation(CustomInput);\n\n// 4. Demonstrate in App component\nfunction App() {\n  const inputRef = useRef(null);\n  const [inputValue, setInputValue] = useState('');\n\n  const handleFocus = () => {\n    // TODO: Focus the input using inputRef\n    inputRef.current.focus();\n  };\n\n  const handleValidate = () => {\n    // TODO: Trigger validation. This might require accessing the HOC's instance or specific props.\n    // For this example, we'll assume `validate` prop is passed down and accessible.\n    // A more robust solution might expose validation logic via useImperativeHandle.\n    if (inputRef.current && inputRef.current.validate) {\n      const isValid = inputRef.current.validate(inputValue);\n      alert(`Input is ${isValid ? 'valid' : 'invalid'}`);\n    } else {\n        // Fallback for simple direct DOM element validation if validate isn't exposed through ref\n        const isValid = inputValue.trim() !== '';\n        alert(`Direct DOM element check: Input is ${isValid ? 'valid' : 'invalid'}`);\n    }\n  };\n\n  return (\n    <div>\n      <h1>Ref Forwarding with HOC Validation</h1>\n      <ValidatedInput\n        ref={inputRef}\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        placeholder=\"Type something...\"\n        style={{ borderColor: inputRef.current?.isValid === false ? 'red' : 'green' }}\n      />\n      <button onClick={handleFocus}>Focus Input</button>\n      <button onClick={handleValidate}>Validate Input</button>\n      <p>Is Valid: {inputRef.current?.isValid ? 'Yes' : 'No'}</p>\n    </div>\n  );\n}\n\nexport default App;",
          "solutionCode": "import React, { useState, useRef, useImperativeHandle } from 'react';\n\n// 1. Create CustomInput using React.forwardRef\nconst CustomInput = React.forwardRef((props, ref) => {\n  const { isValid, ...restProps } = props;\n  return (\n    <input\n      {...restProps}\n      ref={ref}\n      style={{ borderColor: isValid === false ? 'red' : 'initial', borderWidth: '2px', padding: '5px' }}\n    />\n  );\n});\n\n// 2. Create withValidation HOC that also uses React.forwardRef\nfunction withValidation(WrappedComponent) {\n  class WithValidationLogic extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = { isValid: true };\n      this.internalRef = React.createRef(); // Ref to the WrappedComponent instance\n    }\n\n    // This method is called by the HOC's consumer (e.g., App) via the forwarded ref.\n    // It exposes the WrappedComponent's focus method and the HOC's validate logic.\n    exposeMethods = () => ({\n      focus: () => {\n        if (this.internalRef.current && typeof this.internalRef.current.focus === 'function') {\n          this.internalRef.current.focus();\n        } else if (this.internalRef.current && this.internalRef.current.nodeType === 1) {\n           // If ref is a DOM element (like in CustomInput), focus directly\n           this.internalRef.current.focus();\n        }\n      },\n      validate: (value) => {\n        const valid = value.trim() !== '';\n        this.setState({ isValid: valid });\n        return valid;\n      },\n      // Expose current isValid state\n      get isValid() {\n        return this.state.isValid;\n      }\n    });\n\n    render() {\n      const { forwardedRef, ...rest } = this.props;\n\n      // Use useImperativeHandle to expose methods through the forwardedRef\n      // This must be inside a functional component or use a wrapper class's instance method directly.\n      // Here, we adapt for a class component HOC by using a ref callback.\n      const setRef = instance => {\n        this.internalRef.current = instance;\n        if (forwardedRef) {\n          if (typeof forwardedRef === 'function') {\n            forwardedRef(this.exposeMethods()); // Pass methods to the forwarded ref\n          } else {\n            forwardedRef.current = this.exposeMethods();\n          }\n        }\n      };\n\n      return (\n        <WrappedComponent\n          ref={setRef} // Pass our internal ref callback to the WrappedComponent\n          isValid={this.state.isValid}\n          {...rest}\n        />\n      );\n    }\n  }\n\n  // The outer HOC function which creates the ref-aware component\n  return React.forwardRef((props, ref) => (\n    <WithValidationLogic {...props} forwardedRef={ref} />\n  ));\n}\n\n// 3. Apply the HOC\nconst ValidatedInput = withValidation(CustomInput);\n\n// 4. Demonstrate in App component\nfunction App() {\n  const inputRef = useRef(null);\n  const [inputValue, setInputValue] = useState('');\n\n  const handleFocus = () => {\n    if (inputRef.current && typeof inputRef.current.focus === 'function') {\n      inputRef.current.focus();\n    } else {\n      console.warn(\"Focus method not available on ref.current.\");\n    }\n  };\n\n  const handleValidate = () => {\n    if (inputRef.current && typeof inputRef.current.validate === 'function') {\n      const isValid = inputRef.current.validate(inputValue);\n      alert(`Input is ${isValid ? 'valid' : 'invalid'}`);\n    } else {\n      console.warn(\"Validate method not available on ref.current.\");\n    }\n  };\n\n  return (\n    <div>\n      <h1>Ref Forwarding with HOC Validation</h1>\n      <ValidatedInput\n        ref={inputRef}\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        placeholder=\"Type something...\"\n      />\n      <p>Current input value: {inputValue}</p>\n      <p>Input Validity: {inputRef.current?.isValid ? 'Valid' : 'Invalid'}</p>\n      <button onClick={handleFocus} style={{ marginRight: '10px' }}>Focus Input</button>\n      <button onClick={handleValidate}>Validate Input</button>\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "**Test Case 1: Initial Render**\n- **Input**: Render `App`.\n- **Expected Output**: Input field is rendered, 'Is Valid: Yes' is displayed. Focus button and Validate button are visible. Input border is default (or green if style applied).\n\n**Test Case 2: Focus Functionality**\n- **Input**: Click 'Focus Input' button.\n- **Expected Output**: The input field receives focus (cursor appears, field highlights).\n\n**Test Case 3: Empty Input Validation**\n- **Input**: Type nothing into the input. Click 'Validate Input' button.\n- **Expected Output**: An alert 'Input is invalid' appears. The 'Is Valid:' text changes to 'No'. Input border turns red.\n\n**Test Case 4: Valid Input Validation**\n- **Input**: Type 'hello' into the input. Click 'Validate Input' button.\n- **Expected Output**: An alert 'Input is valid' appears. The 'Is Valid:' text changes to 'Yes'. Input border turns green (or default).\n\n**Test Case 5: Ref Access (Console Check)**\n- **Input**: Inspect `inputRef.current` in browser console after `App` renders.\n- **Expected Output**: `inputRef.current` should be an object containing `focus()` and `validate()` methods, and an `isValid` getter, demonstrating `useImperativeHandle`'s effect (or equivalent for class HOC). It should NOT be `null` or point to the HOC instance directly if `forwardRef` isn't properly used on the HOC.",
            "**Test Case 6: Typing updates validity visually**\n- **Input**: Type some text into the input, then delete it to make it empty.\n- **Expected Output**: The border color should dynamically change between green/default and red as the content becomes valid/invalid (assuming `onChange` is linked to validation or `isValid` prop affects styling)."
          ],
          "hints": [
            "Remember that `React.forwardRef` takes two arguments: `props` and `ref`.",
            "When a HOC needs to forward a ref, the component returned by the HOC function should itself be wrapped in `React.forwardRef`.",
            "To expose specific methods (like `focus` or `validate`) from the `WrappedComponent` or the HOC's internal logic via the ref, consider using `useImperativeHandle` within the `WrappedComponent` (if it's functional) or by manually exposing them from the HOC's internal ref (for class-based HOCs). In this case, exposing HOC's methods through the `forwardedRef` is key.",
            "Ensure proper prop spreading (`{...props}`) to pass all original props down the chain.",
            "The `isValid` prop can be used by `CustomInput` to change its appearance (e.g., border color)."
          ],
          "tags": [
            "React",
            "forwardRef",
            "HOCs",
            "Refs",
            "Validation",
            "Composition",
            "Advanced React"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_react_forward_ref",
            "theory_higher_order_components",
            "react_functional_components",
            "react_hooks_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "useImperativeHandle",
            "Controlled Components"
          ]
        },
        {
          "id": "task_data_fetching_hoc",
          "title": "Implement a Data Fetching HOC",
          "description": "\nCreate a Higher-Order Component named `withDataFetching` that abstracts data fetching logic. This HOC should:\n\n1.  Accept two arguments: a `url` string (the API endpoint to fetch data from) and the `WrappedComponent`.\n2.  Manage three pieces of state internally: `data` (for the fetched data, initially `null`), `isLoading` (boolean, initially `true`), and `error` (for any fetch errors, initially `null`).\n3.  Perform the data fetch when the component mounts. Use `fetch` API.\n4.  Update its internal state based on the fetch operation's success, loading status, or failure.\n5.  Pass `data`, `isLoading`, and `error` as props to the `WrappedComponent`.\n6.  Handle unmounting gracefully (e.g., aborting fetch requests if component unmounts).\n\nDemonstrate its usage by wrapping a `UserList` component that expects `data` (an array of users) and displays it. The `UserList` component should also conditionally render based on `isLoading` and `error` props.\n\n**Requirements:**\n-   The HOC should be a class component to demonstrate lifecycle methods (or a functional component with `useEffect` for a modern approach, but stick to class for this task if it clarifies HOC concepts).\n-   Error handling should be present.\n-   The HOC should pass all original props to the `WrappedComponent`.\n-   A mock API can be used if a real one isn't available (e.g., `https://jsonplaceholder.typicode.com/users`).\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\n// HOC for data fetching\nfunction withDataFetching(WrappedComponent, url) {\n  return class DataFetcher extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        data: null,\n        isLoading: true,\n        error: null,\n      };\n      this.abortController = new AbortController(); // For handling unmount\n    }\n\n    componentDidMount() {\n      // TODO: Implement data fetching logic\n      // Use this.abortController.signal for fetch options to enable aborting\n      // Update state based on fetch outcome\n    }\n\n    componentWillUnmount() {\n      // TODO: Abort any pending fetch requests\n      this.abortController.abort();\n    }\n\n    render() {\n      // TODO: Pass data, isLoading, error, and original props to WrappedComponent\n      return <WrappedComponent {...this.props} {...this.state} />;\n    }\n  };\n}\n\n// Example WrappedComponent\nfunction UserList({ data, isLoading, error, title }) {\n  if (isLoading) {\n    return <div>Loading users...</div>;\n  }\n\n  if (error) {\n    return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n  }\n\n  if (!data || data.length === 0) {\n    return <div>No users found.</div>;\n  }\n\n  return (\n    <div>\n      <h2>{title}</h2>\n      <ul>\n        {data.map((user) => (\n          <li key={user.id}>{user.name} ({user.email})</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// Apply the HOC\nconst EnhancedUserList = withDataFetching(UserList, 'https://jsonplaceholder.typicode.com/users');\n\n// Demonstrate in App\nfunction App() {\n  return (\n    <div>\n      <h1>Data Fetching with HOC</h1>\n      <EnhancedUserList title=\"List of Users\" />\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React from 'react';\n\n// HOC for data fetching\nfunction withDataFetching(WrappedComponent, url) {\n  return class DataFetcher extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        data: null,\n        isLoading: true,\n        error: null,\n      };\n      this.abortController = new AbortController(); // For handling unmount\n    }\n\n    componentDidMount() {\n      const signal = this.abortController.signal;\n\n      fetch(url, { signal })\n        .then(response => {\n          if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n          }\n          return response.json();\n        })\n        .then(data => {\n          if (!signal.aborted) { // Check if not aborted before setting state\n            this.setState({\n              data: data,\n              isLoading: false,\n            });\n          }\n        })\n        .catch(error => {\n          if (error.name === 'AbortError') {\n            console.log('Fetch aborted');\n            return; // Do nothing if fetch was aborted on unmount\n          }\n          if (!signal.aborted) { // Check if not aborted before setting state\n            this.setState({\n              error: error,\n              isLoading: false,\n            });\n          }\n        });\n    }\n\n    componentWillUnmount() {\n      this.abortController.abort();\n    }\n\n    render() {\n      // Pass data, isLoading, error, and original props to WrappedComponent\n      return <WrappedComponent {...this.props} {...this.state} />;\n    }\n  };\n}\n\n// Example WrappedComponent\nfunction UserList({ data, isLoading, error, title }) {\n  if (isLoading) {\n    return <div>Loading users...</div>;\n  }\n\n  if (error) {\n    return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n  }\n\n  if (!data || data.length === 0) {\n    return <div>No users found.</div>;\n  }\n\n  return (\n    <div>\n      <h2>{title}</h2>\n      <ul>\n        {data.map((user) => (\n          <li key={user.id}>{user.name} ({user.email})</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// Apply the HOC\nconst EnhancedUserList = withDataFetching(UserList, 'https://jsonplaceholder.typicode.com/users');\n\n// Demonstrate in App\nfunction App() {\n  return (\n    <div>\n      <h1>Data Fetching with HOC</h1>\n      <EnhancedUserList title=\"List of Users\" />\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "**Test Case 1: Successful Data Fetch**\n- **Input**: Render `App` component.\n- **Expected Output**: Initially displays 'Loading users...', then after a short delay, displays 'List of Users' title followed by a list of user names and emails (e.g., Leanne Graham (Sincere@april.biz)).\n\n**Test Case 2: Error Handling**\n- **Input**: Modify the `url` in `withDataFetching` to an invalid or non-existent endpoint (e.g., `https://jsonplaceholder.typicode.com/invalid-users`). Render `App`.\n- **Expected Output**: Displays an error message in red, e.g., 'Error: HTTP error! status: 404' or a network error.\n\n**Test Case 3: Empty Data**\n- **Input**: Modify the mock API or simulate an empty response (e.g., fetch from an endpoint that returns `[]`).\n- **Expected Output**: Displays 'No users found.'\n\n**Test Case 4: Component Unmount (manual check)**\n- **Input**: Render `App`, then quickly unmount it (e.g., via conditional rendering in a parent component, or using a dev tool to remove it from DOM) while the fetch is still pending.\n- **Expected Output**: No errors in the console related to setting state on an unmounted component. Console should log 'Fetch aborted' if `AbortError` is caught, confirming clean-up.",
            "**Test Case 5: Prop Transparency**\n- **Input**: Ensure `UserList` receives the `title` prop passed from `App`.",
            "- **Expected Output**: The `h2` tag should display 'List of Users'."
          ],
          "hints": [
            "Use `fetch` for the API call.",
            "Remember to use `componentDidMount` for initial data fetching and `componentWillUnmount` for cleanup.",
            "The `AbortController` is critical for preventing 'Can't perform a React state update on an unmounted component' warnings/errors.",
            "Ensure `response.ok` is checked after `fetch` to handle HTTP errors (like 404, 500) correctly, before parsing JSON.",
            "Spread `this.props` to ensure any props passed to the `EnhancedComponent` are also passed down to the `WrappedComponent`."
          ],
          "tags": [
            "React",
            "HOCs",
            "Data Fetching",
            "API Integration",
            "Lifecycle Methods",
            "Error Handling"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_higher_order_components",
            "react_lifecycle_methods",
            "javascript_async_await_fetch"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "State Injection Pattern",
            "Controlled Components",
            "fetch API"
          ]
        }
      ]
    }
  },
  {
    "id": "24e2797c-36a4-4004-88b8-52a028a351a1",
    "startLine": 4200,
    "endLine": 4299,
    "processedDate": "2025-06-17T09:05:03.762Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_high_order_components",
          "title": "High-Order Components (HOCs)",
          "content": "High-Order Components (HOCs) in React are an advanced technique for reusing component logic. A Higher-Order Component is a function that takes a component as an argument and returns a new component. They are not React components themselves, but rather functions that transform components.\n\n## Core Concept\nAn HOC wraps the original component, enhancing it with additional props, state, or behavior, without modifying the original component itself. This allows for clean separation of concerns and efficient code reuse.\n\n```typescript\ntype HOC<P extends object, T extends object> = (WrappedComponent: React.ComponentType<P>) => React.ComponentType<P & T>;\n\n// Example structure:\nfunction withLogger<P extends object>(WrappedComponent: React.ComponentType<P>): React.ComponentType<P> {\n  class WithLogger extends React.Component<P> {\n    componentDidMount() {\n      console.log(`${getDisplayName(WrappedComponent)} mounted`);\n    }\n    componentWillUnmount() {\n      console.log(`${getDisplayName(WrappedComponent)} unmounted`);\n    }\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n  WithLogger.displayName = `withLogger(${getDisplayName(WrappedComponent)})`;\n  return WithLogger;\n}\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n```\n\n## Common HOC Use Cases\nHOCs are powerful for addressing cross-cutting concerns and abstracting state or props. Key use cases include:\n\n1.  **Code Reuse and Cross-Cutting Concerns:**\n    *   **Authentication/Authorization:** Wrapping components to check user permissions or redirect unauthenticated users.\n    *   **Data Fetching and Loading States:** Providing data from an external source and managing loading/error states.\n    *   **Measuring Performance:** Logging render times or tracking component interactions.\n    *   **Error Handling:** Catching errors in child components and displaying fallback UI.\n    *   **Analytics:** Injecting analytics tracking logic.\n\n2.  **State Abstraction:**\n    *   **Managing Form State:** Handling form input values and validation logic.\n    *   **Managing Subscription Data:** Subscribing to external data sources (e.g., Redux store, external APIs) and passing updates as props.\n    *   **Managing Global UI State:** Controlling modals, tooltips, or themes.\n\n3.  **Prop Manipulation:**\n    *   **Filtering or Transforming Props:** Modifying the props passed to the wrapped component.\n    *   **Adding Extra Props:** Injecting additional props that the wrapped component needs (e.g., `theme`, `currentUser`).\n    *   **Renaming Props for Compatibility:** Adapting prop names to fit a specific component's interface.\n\n## HOC Best Practices\nTo leverage HOCs effectively and avoid common pitfalls, follow these best practices:\n\n1.  **Don't Mutate the Original Component:**\n    *   HOCs should aim for pure functions, meaning they don't modify the input component. Instead, they should return a *new* component that wraps the original. Mutating the original component can lead to side effects, make debugging harder, and break component reusability.\n    ```typescript\n    // Bad - mutates the original component (e.g., adding lifecycle methods directly)\n    function withStylesBad<P extends object>(WrappedComponent: React.ComponentType<P>) {\n      // This modifies the prototype of the original component, affecting all instances.\n      // This is generally an anti-pattern in React.\n      (WrappedComponent.prototype as any).componentDidMount = function() { /* ... */ };\n      return WrappedComponent;\n    }\n    \n    // Good - creates a new component that wraps the original\n    function withStylesGood<P extends object>(WrappedComponent: React.ComponentType<P>) {\n      return class extends React.Component<P> {\n        componentDidMount() { \n          console.log(`Component ${getDisplayName(WrappedComponent)} styled.`);\n        }\n        render() {\n          // Passes all original props to the wrapped component\n          return <WrappedComponent {...this.props} />;\n        }\n      };\n    }\n    ```\n\n2.  **Pass Unrelated Props Through:**\n    *   HOCs should pass all props that are not specifically consumed or injected by the HOC itself directly to the wrapped component. This ensures flexibility and prevents unintended prop loss, allowing the wrapped component to receive all necessary external props.\n    ```typescript\n    function withMousePosition<P extends object>(WrappedComponent: React.ComponentType<P>) {\n      interface MouseState {\n        x: number;\n        y: number;\n      }\n      // Defines the props that the HOC adds to the wrapped component\n      interface InjectedProps {\n        mousePosition: MouseState;\n      }\n\n      type Props = P & InjectedProps;\n\n      return class WithMousePosition extends React.Component<Props> {\n        state: MouseState = { x: 0, y: 0 };\n\n        handleMouseMove = (event: MouseEvent) => {\n          this.setState({ x: event.clientX, y: event.clientY });\n        };\n\n        componentDidMount() {\n          window.addEventListener('mousemove', this.handleMouseMove);\n        }\n\n        componentWillUnmount() {\n          window.removeEventListener('mousemove', this.handleMouseMove);\n        }\n\n        render() {\n          // Injects mousePosition but passes through all other props (P type)\n          const { mousePosition, ...restProps } = this.props;\n          return <WrappedComponent mousePosition={this.state} {...(restProps as P)} />;\n        }\n      };\n    }\n    ```\n\n3.  **Maximize Composability:**\n    *   HOCs are designed to be composed together. You can chain them to apply multiple concerns to a single component. For better readability and maintainability, especially with many HOCs, consider using a `compose` utility function (e.g., from Redux or Lodash) which applies HOCs from right to left.\n    ```typescript\n    // Compose multiple HOCs by chaining them\n    const EnhancedComponent = withRouter(withTheme(withAuth(MyComponent)));\n    \n    // Or using a compose utility for cleaner syntax and right-to-left application\n    // (MyComponent -> withAuth -> withTheme -> withRouter)\n    type ComposeFunction = (...fns: Function[]) => (x: any) => any;\n\n    const compose: ComposeFunction = (...fns) => x => fns.reduceRight((v, f) => f(v), x);\n\n    const enhance = compose(\n      withRouter,\n      withTheme,\n      withAuth\n    );\n    const EnhancedComponent = enhance(MyComponent);\n    ```\n\n4.  **Convention: Include Display Name for Debugging:**\n    *   Setting a `displayName` for the HOC-returned component helps immensely with debugging in React Developer Tools. It makes the component tree more understandable by providing meaningful names for the wrapped components.\n    ```typescript\n    function withSubscription<P extends object, InjectedProps extends object>(\n      WrappedComponent: React.ComponentType<P & InjectedProps>,\n      selectData: (dataSource: any, props: P) => InjectedProps\n    ): React.ComponentType<P> {\n      interface SubscriptionState extends InjectedProps {}\n\n      class WithSubscription extends React.Component<P, SubscriptionState> {\n        state: SubscriptionState = {} as SubscriptionState; // Initial state based on injected props\n        dataSource: any; // Assume DataSource is defined elsewhere\n\n        componentDidMount() {\n          this.dataSource = {}; // Placeholder for actual data source\n          this.setState(selectData(this.dataSource, this.props));\n        }\n        \n        render() {\n          return <WrappedComponent {...this.props} {...this.state} />;\n        }\n      }\n      \n      // Add a proper displayName for dev tools\n      WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;\n      \n      return WithSubscription;\n    }\n    \n    function getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n      return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n    }\n\n    // Usage Example:\n    interface CommentListProps {\n      postId: string;\n      comments: string[]; // Injected by HOC\n    }\n\n    const CommentList: React.FC<CommentListProps> = ({ postId, comments }) => (\n      <div>\n        <h2>Comments for Post #{postId}</h2>\n        {comments.map((comment, index) => <p key={index}>{comment}</p>)}\n      </div>\n    );\n\n    // Assume a DataSource exists globally or is passed in\n    const DataSource = {\n      getComments: (postId: string) => {\n        console.log(`Fetching comments for post ${postId}`);\n        return { comments: [`Comment 1 for ${postId}`, `Comment 2 for ${postId}`] };\n      }\n    };\n\n    const CommentListWithSubscription = withSubscription(\n      CommentList,\n      (source, props) => DataSource.getComments(props.postId)\n    );\n\n    // Example of how it would be rendered:\n    // <CommentListWithSubscription postId=\"123\" />\n    ```\n\n## Limitations of HOCs\nWhile powerful, HOCs have certain limitations:\n\n*   **Don't use HOCs inside the `render` method:** Creating a new HOC-returned component inside `render` will cause the component to unmount and remount every time the parent renders. This leads to performance issues (lost state, unnecessary re-renders) and identity problems (e.g., `shouldComponentUpdate` failing).\n*   **Static methods must be copied over manually or with a utility:** If your wrapped component has static methods (e.g., `MyComponent.someStaticMethod`), these are not automatically copied to the new component returned by the HOC. You need to copy them explicitly or use a utility like `hoist-non-react-statics`.\n*   **Refs aren't passed through automatically (use `React.forwardRef`):** Refs created on the HOC-returned component will refer to the HOC instance, not the instance of the wrapped component. To get a ref to the actual wrapped component, you must use `React.forwardRef` within your HOC to pass the ref down.\n",
          "examples": [
            {
              "id": "example_hoc_basic_usage",
              "title": "Basic HOC Usage: `withSubscription`",
              "code": "import React from 'react';\n\ninterface CommentListProps {\n  postId: string;\n  comments: string[]; // This prop is injected by the HOC\n}\n\nconst CommentList: React.FC<CommentListProps> = ({ postId, comments }) => (\n  <div>\n    <h3>Comments for Post #{postId}</h3>\n    {comments.length > 0 ? (\n      <ul>\n        {comments.map((comment, index) => (\n          <li key={index}>{comment}</li>\n        ))}\n      </ul>\n    ) : (\n      <p>No comments available.</p>\n    )}\n  </div>\n);\n\n// Placeholder for a data source. In a real app, this would be more sophisticated.\nconst DataSource = {\n  getComments: (postId: string) => {\n    // Simulate API call\n    return { comments: [`Comment A for ${postId}`, `Comment B for ${postId}`] };\n  },\n  // Other data fetching methods...\n};\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\ninterface InjectedSubscriptionProps {\n  comments: string[];\n}\n\n// HOC definition\nfunction withSubscription<P extends object>(\n  WrappedComponent: React.ComponentType<P & InjectedSubscriptionProps>,\n  selectData: (dataSource: typeof DataSource, props: P) => InjectedSubscriptionProps\n): React.ComponentType<P> {\n  class WithSubscription extends React.Component<P, InjectedSubscriptionProps> {\n    static displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;\n\n    state: InjectedSubscriptionProps = { comments: [] };\n\n    componentDidMount() {\n      this.setState(selectData(DataSource, this.props));\n    }\n\n    render() {\n      // Pass down all original props AND the injected state (comments)\n      return <WrappedComponent {...this.props} {...this.state} />;\n    }\n  }\n  return WithSubscription;\n}\n\n// Usage\nconst CommentListWithSubscription = withSubscription(\n  CommentList,\n  (source, props) => source.getComments(props.postId)\n);\n\n// How you would use CommentListWithSubscription in your application:\n// <CommentListWithSubscription postId=\"1\" />\n",
              "explanation": "This example demonstrates a common HOC pattern: data subscription. The `withSubscription` HOC takes a `CommentList` component and a `selectData` function. It then internally manages fetching 'comments' based on `props.postId` using a `DataSource`. The fetched `comments` are then injected as props into the `CommentList`. This separates data fetching logic from the presentational component, making `CommentList` reusable and focused solely on rendering comments.",
              "language": "typescript"
            },
            {
              "id": "example_hoc_prop_passthrough",
              "title": "HOC: Passing Unrelated Props Through",
              "code": "import React from 'react';\n\ninterface MyComponentProps {\n  message: string;\n  value: number; // This prop is passed through by the HOC\n  timestamp: Date; // This prop is added by the HOC\n}\n\nconst MyComponent: React.FC<MyComponentProps> = ({ message, value, timestamp }) => (\n  <div>\n    <p>Message: {message}</p>\n    <p>Value from parent: {value}</p>\n    <p>Timestamp from HOC: {timestamp.toLocaleString()}</p>\n  </div>\n);\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\ninterface WithTimestampProps {\n  timestamp: Date;\n}\n\nfunction withTimestamp<P extends object>(WrappedComponent: React.ComponentType<P & WithTimestampProps>): React.ComponentType<P> {\n  class WithTimestamp extends React.Component<P> {\n    static displayName = `WithTimestamp(${getDisplayName(WrappedComponent)})`;\n\n    render() {\n      // The HOC injects a 'timestamp' prop.\n      // All other props (of type P) are passed through using {...this.props}.\n      return <WrappedComponent {...this.props as P} timestamp={new Date()} />;\n    }\n  }\n  return WithTimestamp;\n}\n\n// Usage\nconst EnhancedMyComponent = withTimestamp(MyComponent);\n\n// Example of how it would be rendered:\n// <EnhancedMyComponent message=\"Hello HOC!\" value={42} />\n",
              "explanation": "This example showcases the best practice of passing unrelated props through an HOC. The `withTimestamp` HOC adds a `timestamp` prop to `MyComponent`. Critically, `MyComponent` also expects `message` and `value` props directly from its parent. The `WithTimestamp` HOC ensures that `message` and `value` are correctly passed down to `MyComponent` by using `{...this.props}` in its `render` method, alongside the newly injected `timestamp` prop.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_hoc_definition_1",
            "question_hoc_use_cases_mcq_1",
            "question_hoc_best_practice_mutation_1",
            "question_hoc_props_passthrough_open_1",
            "question_hoc_limitations_render_1",
            "question_hoc_forwardref_mcq_1",
            "question_hoc_static_methods_open_1",
            "question_hoc_composability_mcq_1",
            "question_hoc_displayname_flashcard_1"
          ],
          "relatedTasks": [
            "task_hoc_logger",
            "task_hoc_data_loader",
            "task_hoc_access_control",
            "task_hoc_combine_features"
          ],
          "tags": [
            "React",
            "HOC",
            "Higher-Order Components",
            "Component Patterns",
            "Code Reuse",
            "State Management",
            "Prop Manipulation",
            "Best Practices"
          ],
          "technology": "React",
          "prerequisites": [
            "React Components",
            "JavaScript Functions",
            "Props",
            "State",
            "Lifecycle Methods"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Custom Hooks",
            "Advanced React Patterns",
            "Component Architecture"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_hoc_definition_1",
          "topic": "High-Order Components (HOCs) Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a High-Order Component (HOC) in React?",
          "answer": "A function that takes a component as an argument and returns a new component with enhanced capabilities.",
          "options": [],
          "analysisPoints": [
            "Identifies HOCs as functions, not components.",
            "Recognizes their role in transforming/enhancing components."
          ],
          "keyConcepts": [
            "HOC",
            "Function as Component Transformer"
          ],
          "evaluationCriteria": [
            "Basic recall of HOC definition",
            "Understanding of its functional nature"
          ],
          "example": "",
          "tags": [
            "HOC",
            "Definition",
            "React Basics"
          ],
          "prerequisites": [
            "React Components",
            "JavaScript Functions"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_hoc_use_cases_mcq_1",
          "topic": "Common HOC Use Cases",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following scenarios is LEAST likely to be a common use case for a High-Order Component (HOC)?",
          "answer": "Directly manipulating the DOM structure of a component's children without using React's declarative API.",
          "options": [
            "Implementing authentication checks and redirecting unauthenticated users.",
            "Managing data fetching logic and displaying loading/error states.",
            "Injecting analytics tracking code into multiple components.",
            "Directly manipulating the DOM structure of a component's children without using React's declarative API."
          ],
          "analysisPoints": [
            "Tests understanding of HOC's primary purpose (logic reuse, prop/state enhancement).",
            "Identifies scenarios where HOCs are typically applied (cross-cutting concerns, data, state).",
            "Recognizes that direct DOM manipulation is generally an anti-pattern in React and not a role for HOCs, which work at the component level."
          ],
          "keyConcepts": [
            "HOC Use Cases",
            "Cross-Cutting Concerns",
            "Data Fetching",
            "Authentication",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Ability to differentiate appropriate vs. inappropriate HOC use",
            "Understanding of React's declarative nature"
          ],
          "example": "HOCs abstract logic and enhance components by providing props or state, or wrapping them with additional behavior. Direct DOM manipulation typically violates React's declarative paradigm and is usually handled through refs or imperative APIs when absolutely necessary, not via an HOC.",
          "tags": [
            "HOC",
            "Use Cases",
            "Anti-patterns"
          ],
          "prerequisites": [
            "React Components",
            "HOC Concepts"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_best_practice_mutation_1",
          "topic": "HOC Best Practices: No Mutation",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following High-Order Component implementation:\n```typescript\nfunction withLogger(WrappedComponent) {\n  WrappedComponent.prototype.componentDidMount = function() {\n    console.log(`${WrappedComponent.name} mounted.`);\n  };\n  return WrappedComponent;\n}\n\nclass MyComponent extends React.Component {\n  render() {\n    return <div>Hello</div>;\n  }\n}\n\nconst EnhancedMyComponent = withLogger(MyComponent);\n```\nWhat is the primary best practice violation in the `withLogger` HOC?",
          "answer": "It mutates the original `WrappedComponent` by directly modifying its prototype.",
          "options": [
            "It doesn't pass through unrelated props.",
            "It doesn't set a `displayName` for debugging.",
            "It mutates the original `WrappedComponent` by directly modifying its prototype.",
            "It cannot be composed with other HOCs."
          ],
          "analysisPoints": [
            "Identifies the core issue of mutating the original component.",
            "Understands why direct prototype modification is harmful (side effects, unexpected behavior)."
          ],
          "keyConcepts": [
            "HOC Best Practices",
            "Immutability",
            "Component Mutation",
            "Prototype Chain"
          ],
          "evaluationCriteria": [
            "Recognition of HOC anti-patterns",
            "Understanding of JavaScript prototype behavior"
          ],
          "example": "The HOC `withLogger` directly adds a `componentDidMount` method to the `WrappedComponent`'s prototype. This is bad because it changes the original component itself, leading to unintended side effects on all instances of `MyComponent`, even those not wrapped by `withLogger`. A good HOC should always return a *new* component that wraps the original, preserving the original component's integrity.",
          "tags": [
            "HOC",
            "Best Practices",
            "Mutation",
            "Anti-pattern"
          ],
          "prerequisites": [
            "React HOCs",
            "JavaScript Prototypes"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_props_passthrough_open_1",
          "topic": "HOC Best Practices: Prop Passthrough",
          "level": "medium",
          "type": "open",
          "question": "Explain why it's a critical best practice for High-Order Components (HOCs) to pass through all unrelated props to the wrapped component. Provide a small code snippet demonstrating this.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Explains that HOCs should not block props from reaching the wrapped component.",
            "Highlights the importance of flexibility and reusability.",
            "Demonstrates `spread` operator (`{...this.props}`) for prop passthrough.",
            "Mentions avoiding unexpected behavior or prop loss."
          ],
          "keyConcepts": [
            "HOC Best Practices",
            "Prop Passthrough",
            "Component Flexibility",
            "Spread Operator"
          ],
          "evaluationCriteria": [
            "Clarity of explanation",
            "Correct code demonstration",
            "Understanding of HOC's role in prop management"
          ],
          "example": "It's critical for HOCs to pass through all unrelated props to the wrapped component to maintain the wrapped component's flexibility and reusability. If an HOC consumes some props (e.g., `data` for data fetching) and adds others (e.g., `isLoading`), it should still pass through any other props that the parent component might provide and that the wrapped component expects. Failing to do so would lead to 'prop drilling' issues, where parent components would need to know which props an HOC consumes, or worse, wrapped components would mysteriously lose expected props.\n\n```typescript\nfunction withFeatureToggle<P extends object>(WrappedComponent: React.ComponentType<P & { isFeatureEnabled: boolean }>) {\n  return class WithFeatureToggle extends React.Component<P> {\n    render() {\n      const isFeatureEnabled = Math.random() > 0.5; // Example toggle logic\n      // Pass the new 'isFeatureEnabled' prop AND all original props down\n      return <WrappedComponent {...this.props as P} isFeatureEnabled={isFeatureEnabled} />;\n    }\n  };\n}\n```",
          "tags": [
            "HOC",
            "Best Practices",
            "Props",
            "Reusability"
          ],
          "prerequisites": [
            "HOC Fundamentals",
            "React Props"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_limitations_render_1",
          "topic": "HOC Limitations: Usage in Render",
          "level": "medium",
          "type": "open",
          "question": "Why should you avoid creating a High-Order Component (HOC) inside the `render` method of another component?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Explains that HOCs in `render` create a *new* component class on every render.",
            "Discusses the implications: unnecessary unmounting/remounting.",
            "Mentions loss of state and performance degradation.",
            "Connects it to React's reconciliation process and component identity."
          ],
          "keyConcepts": [
            "HOC Limitations",
            "Render Method",
            "Performance",
            "Component Lifecycle",
            "Reconciliation"
          ],
          "evaluationCriteria": [
            "Understanding of React's internal mechanisms",
            "Ability to articulate performance implications"
          ],
          "example": "Creating an HOC inside the `render` method of another component is an anti-pattern because it causes a *new component class* to be created on every render. React's reconciliation algorithm relies on component identity to determine if it should update an existing component instance or unmount the old one and mount a new one. When a new component class is created each time, React sees it as a completely new component, even if its props haven't changed. This leads to:\n\n1.  **Lost State:** The component's internal state (from `useState` or `this.state`) and any DOM state will be reset.\n2.  **Performance Issues:** Unnecessary unmounting and remounting incurs overhead and can trigger costly re-renders of the component's entire subtree.\n3.  **Ref Issues:** Any refs attached to the component will break or point to newly created instances.\n\nInstead, HOCs should be defined outside the `render` method, typically at the top level of a module, so that the component class they return is stable across renders.",
          "tags": [
            "HOC",
            "Limitations",
            "Performance",
            "Anti-pattern"
          ],
          "prerequisites": [
            "React Component Lifecycle",
            "React Reconciliation"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hoc_forwardref_mcq_1",
          "topic": "HOC Limitations: Refs",
          "level": "hard",
          "type": "mcq",
          "question": "You've created a High-Order Component `withAuth` that wraps `MyButton`. If you try to attach a ref directly to `EnhancedMyButton = withAuth(MyButton)`, like `<EnhancedMyButton ref={myRef} />`, what will `myRef.current` typically refer to?",
          "answer": "An instance of the `withAuth` HOC component itself, not `MyButton`.",
          "options": [
            "An instance of the `MyButton` component.",
            "An instance of the `withAuth` HOC component itself, not `MyButton`.",
            "A DOM element if `MyButton` is a native HTML element.",
            "The ref will be `null` because HOCs prevent refs from being passed."
          ],
          "analysisPoints": [
            "Tests understanding of how refs interact with HOCs.",
            "Identifies `React.forwardRef` as the solution.",
            "Distinguishes between the HOC instance and the wrapped component instance."
          ],
          "keyConcepts": [
            "HOC Limitations",
            "Refs",
            "React.forwardRef",
            "Component Instances"
          ],
          "evaluationCriteria": [
            "Deep understanding of React refs and HOC interaction",
            "Knowledge of `forwardRef` solution"
          ],
          "example": "When you attach a ref to a component wrapped by an HOC, the ref by default points to the *instance of the HOC component*, not the instance of the component it wraps. This is because the HOC creates a new component that renders the wrapped component as its child. To get a ref to the `MyButton` component (the wrapped component), you need to explicitly forward the ref using `React.forwardRef` within your HOC. Without `forwardRef`, `myRef.current` would refer to the internal instance of the `WithAuth` class component.",
          "tags": [
            "HOC",
            "Limitations",
            "Refs",
            "React.forwardRef"
          ],
          "prerequisites": [
            "React Refs",
            "HOCs"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_static_methods_open_1",
          "topic": "HOC Limitations: Static Methods",
          "level": "medium",
          "type": "open",
          "question": "A component `MyForm` has a static method `MyForm.validateInput()`. If `MyForm` is wrapped by an HOC `withFormState`, will `EnhancedMyForm.validateInput()` be accessible automatically? If not, how can you make it accessible?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Explains that static methods are not automatically copied.",
            "Describes the reason: HOC returns a new component, not the original.",
            "Provides solutions: manual copy or `hoist-non-react-statics`.",
            "Includes a code snippet for manual copying."
          ],
          "keyConcepts": [
            "HOC Limitations",
            "Static Methods",
            "Component Properties",
            "hoist-non-react-statics"
          ],
          "evaluationCriteria": [
            "Understanding of static method behavior with HOCs",
            "Knowledge of practical solutions"
          ],
          "example": "No, `EnhancedMyForm.validateInput()` will not be accessible automatically. When an HOC wraps a component, it returns a *new* component class. Static methods defined on the original `MyForm` component are properties of that specific class constructor, not its instances. The HOC's returned component is a different class, so it won't inherit `MyForm`'s static methods by default.\n\nTo make them accessible, you need to explicitly copy the static methods from the `WrappedComponent` to the `NewComponent` returned by the HOC. This can be done manually or by using a utility like `hoist-non-react-statics`.\n\n**Manual Copying:**\n```typescript\nfunction withFormState<P extends object>(WrappedComponent: React.ComponentType<P>) {\n  class WithFormState extends React.Component<P> {\n    // ... HOC logic ...\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n\n  // Manually copy static methods\n  for (let key in WrappedComponent) {\n    if (typeof (WrappedComponent as any)[key] === 'function') {\n      (WithFormState as any)[key] = (WrappedComponent as any)[key];\n    }\n  }\n\n  return WithFormState;\n}\n```\n\nFor more robust solutions, `hoist-non-react-statics` is commonly used as it correctly handles all React-specific static properties.",
          "tags": [
            "HOC",
            "Limitations",
            "Static Methods",
            "hoist-non-react-statics"
          ],
          "prerequisites": [
            "HOCs",
            "JavaScript Classes",
            "Static Methods"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_composability_mcq_1",
          "topic": "HOC Best Practices: Composability",
          "level": "medium",
          "type": "mcq",
          "question": "You have three HOCs: `withAuth`, `withLogger`, and `withTheme`. You want to apply them to `MyComponent` in a way that `withAuth` is applied first, then `withLogger`, then `withTheme`. Which of the following correctly demonstrates a highly composable and readable way to achieve this?\n\nAssume a `compose` utility function is available that applies functions from right to left.\n\n```typescript\nconst compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);\n```",
          "answer": "```typescript\nconst enhance = compose(\n  withTheme,\n  withLogger,\n  withAuth\n);\nconst EnhancedComponent = enhance(MyComponent);\n```",
          "options": [
            "```typescript\nconst EnhancedComponent = withAuth(withLogger(withTheme(MyComponent)));\n```",
            "```typescript\nconst EnhancedComponent = withTheme(withLogger(withAuth(MyComponent)));\n```",
            "```typescript\nconst enhance = compose(\n  withTheme,\n  withLogger,\n  withAuth\n);\nconst EnhancedComponent = enhance(MyComponent);\n```",
            "```typescript\nconst enhance = compose(\n  withAuth,\n  withLogger,\n  withTheme\n);\nconst EnhancedComponent = enhance(MyComponent);\n```"
          ],
          "analysisPoints": [
            "Tests understanding of HOC chaining/composition.",
            "Verifies knowledge of `compose` utility's typical right-to-left application.",
            "Recognizes that `compose(f, g, h)(x)` is equivalent to `f(g(h(x)))`."
          ],
          "keyConcepts": [
            "HOC Composability",
            "Function Composition",
            "Compose Utility"
          ],
          "evaluationCriteria": [
            "Correct application of functional composition principles",
            "Readability and best practices in HOC usage"
          ],
          "example": "The `compose` function typically applies its arguments from right to left. So, `compose(f, g, h)(x)` means `f(g(h(x)))`. To apply `withAuth` first to `MyComponent`, then `withLogger`, then `withTheme`, the order of application should be `withTheme(withLogger(withAuth(MyComponent)))`. Therefore, `withAuth` should be the rightmost argument to `compose`, followed by `withLogger`, and then `withTheme` as the leftmost argument.",
          "tags": [
            "HOC",
            "Composability",
            "Functional Programming",
            "Compose"
          ],
          "prerequisites": [
            "HOCs",
            "JavaScript Functions",
            "Functional Programming Concepts"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_hoc_displayname_flashcard_1",
          "topic": "HOC Best Practices: Display Name",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of setting a `displayName` property for the component returned by an HOC?",
          "answer": "It improves debugging experience in React Developer Tools by providing meaningful names in the component tree.",
          "options": [],
          "analysisPoints": [
            "Connects `displayName` to debugging tools.",
            "Highlights the clarity it adds to the component tree."
          ],
          "keyConcepts": [
            "HOC Best Practices",
            "Debugging",
            "React Developer Tools",
            "DisplayName"
          ],
          "evaluationCriteria": [
            "Basic recall of `displayName` purpose"
          ],
          "example": "",
          "tags": [
            "HOC",
            "Debugging",
            "Best Practices"
          ],
          "prerequisites": [
            "React Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        }
      ],
      "tasks": [
        {
          "id": "task_hoc_logger",
          "title": "Implement a `withLogger` HOC",
          "description": "\nImplement a High-Order Component `withLogger` that logs when a wrapped component mounts and unmounts. This HOC should:\n\n1.  Take a `WrappedComponent` as an argument.\n2.  Return a new component that renders the `WrappedComponent`.\n3.  Log a message to the console in `componentDidMount` indicating the component has mounted (e.g., \"MyComponent mounted\").\n4.  Log a message in `componentWillUnmount` indicating the component has unmounted (e.g., \"MyComponent unmounted\").\n5.  Ensure all props passed to the HOC are correctly forwarded to the `WrappedComponent`.\n6.  Set a proper `displayName` for the returned component for better debugging.\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\n// Helper to get component display name\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\n// Your task: Implement withLogger HOC\nfunction withLogger<P extends object>(WrappedComponent: React.ComponentType<P>): React.ComponentType<P> {\n  // TODO: Implement the HOC logic here\n  return class extends React.Component<P> {\n    // ...\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  };\n}\n\n// Example Usage (for testing your HOC)\ninterface GreetProps {\n  name: string;\n}\n\nconst Greet: React.FC<GreetProps> = ({ name }) => {\n  return <div>Hello, {name}!</div>;\n};\n\nconst GreetWithLogger = withLogger(Greet);\n\n// To test, you might render GreetWithLogger within another component \n// that controls its mounting/unmounting or use a testing framework.\n// Example:\n/*\nconst App = () => {\n  const [show, setShow] = React.useState(true);\n  return (\n    <div>\n      <button onClick={() => setShow(!show)}>Toggle Greet</button>\n      {show && <GreetWithLogger name=\"World\" />}\n    </div>\n  );\n};\n\nReactDOM.render(<App />, document.getElementById('root'));\n*/\n",
          "solutionCode": "import React from 'react';\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nfunction withLogger<P extends object>(WrappedComponent: React.ComponentType<P>): React.ComponentType<P> {\n  class WithLogger extends React.Component<P> {\n    static displayName = `withLogger(${getDisplayName(WrappedComponent)})`;\n\n    componentDidMount() {\n      console.log(`${getDisplayName(WrappedComponent)} mounted`);\n    }\n\n    componentWillUnmount() {\n      console.log(`${getDisplayName(WrappedComponent)} unmounted`);\n    }\n\n    render() {\n      // Pass all props through to the wrapped component\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n\n  return WithLogger;\n}\n\ninterface GreetProps {\n  name: string;\n}\n\nconst Greet: React.FC<GreetProps> = ({ name }) => {\n  return <div>Hello, {name}!</div>;\n};\n\nconst GreetWithLogger = withLogger(Greet);\n\n// Test component to demonstrate mounting/unmounting\nconst TestLoggerApp: React.FC = () => {\n  const [showGreet, setShowGreet] = React.useState(true);\n\n  React.useEffect(() => {\n    // Simulate unmounting after a delay\n    const timer = setTimeout(() => setShowGreet(false), 2000);\n    return () => clearTimeout(timer);\n  }, []);\n\n  return (\n    <div>\n      <h1>Logger HOC Test</h1>\n      {showGreet ? <GreetWithLogger name=\"User\" /> : <p>Greet component unmounted.</p>}\n    </div>\n  );\n};\n\n// Usage example for a real environment:\n// ReactDOM.render(<TestLoggerApp />, document.getElementById('root'));\n",
          "testCases": [
            "When `GreetWithLogger` is first rendered, 'Greet mounted' should appear in the console.",
            "When `GreetWithLogger` is removed from the DOM (e.g., by toggling its visibility), 'Greet unmounted' should appear in the console.",
            "Verify that props (e.g., `name=\"User\"`) are correctly passed to the `Greet` component.",
            "Check that the `displayName` for the component in React Dev Tools reflects `withLogger(Greet)`."
          ],
          "hints": [
            "Remember that lifecycle methods like `componentDidMount` and `componentWillUnmount` are class component methods.",
            "The `super(props)` call is crucial if you're writing a class component and using `this.props` in the constructor.",
            "The `getDisplayName` helper function is provided to assist with setting the `displayName`."
          ],
          "tags": [
            "React",
            "HOC",
            "Lifecycle Methods",
            "Logging",
            "Best Practices"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "React Class Components",
            "React Lifecycle",
            "HOC Fundamentals"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component Lifecycle",
            "Cross-Cutting Concerns",
            "Debugging"
          ]
        },
        {
          "id": "task_hoc_data_loader",
          "title": "Implement a `withDataLoader` HOC",
          "description": "\nCreate a High-Order Component `withDataLoader` that fetches data from a simulated API and passes it as props to the wrapped component. This HOC should:\n\n1.  Accept a `WrappedComponent` and a `dataFetcher` function as arguments.\n2.  The `dataFetcher` function should take the HOC's props and return a Promise that resolves with the data.\n3.  Manage `loading` and `error` states internally.\n4.  Render a 'Loading...' message when data is being fetched.\n5.  Render an 'Error: [message]' if data fetching fails.\n6.  Once data is successfully fetched, pass the data (e.g., as a prop named `data`) along with `isLoading` and `error` flags to the `WrappedComponent`.\n7.  Ensure all other props are passed through.\n8.  Set a `displayName`.\n\n**Simulated API:**\n```typescript\nconst simulatedApi = {\n  fetchUserData: (userId: string) => new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId === 'error') {\n        reject(new Error('Failed to fetch user data.'));\n      } else if (userId === '1') {\n        resolve({ id: '1', name: 'Alice', email: 'alice@example.com' });\n      } else if (userId === '2') {\n        resolve({ id: '2', name: 'Bob', email: 'bob@example.com' });\n      } else {\n        resolve(null);\n      }\n    }, 1000);\n  }),\n  fetchProductData: (productId: string) => new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (productId === 'error') {\n        reject(new Error('Product data not found.'));\n      } else if (productId === 'P1') {\n        resolve({ id: 'P1', name: 'Laptop', price: 1200 });\n      } else {\n        resolve(null);\n      }\n    }, 800);\n  })\n};\n```\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\n\n// Helper to get component display name\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\n// Simulated API (provided in description)\nconst simulatedApi = {\n  fetchUserData: (userId: string) => new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId === 'error') {\n        reject(new Error('Failed to fetch user data.'));\n      } else if (userId === '1') {\n        resolve({ id: '1', name: 'Alice', email: 'alice@example.com' });\n      } else if (userId === '2') {\n        resolve({ id: '2', name: 'Bob', email: 'bob@example.com' });\n      } else {\n        resolve(null);\n      }\n    }, 1000);\n  }),\n  fetchProductData: (productId: string) => new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (productId === 'error') {\n        reject(new Error('Product data not found.'));\n      } else if (productId === 'P1') {\n        resolve({ id: 'P1', name: 'Laptop', price: 1200 });\n      } else {\n        resolve(null);\n      }\n    }, 800);\n  })\n};\n\n// Your task: Implement withDataLoader HOC\n// P: Props for the HOC (which are also passed to the dataFetcher)\n// D: Type of the data fetched\n// InjectedProps: { data: D | null, isLoading: boolean, error: Error | null }\nfunction withDataLoader<P extends object, D>(\n  WrappedComponent: React.ComponentType<P & { data: D | null, isLoading: boolean, error: Error | null }>,\n  dataFetcher: (props: P) => Promise<D | null>\n): React.ComponentType<P> {\n  // TODO: Implement the HOC logic here\n  // Consider initial state, lifecycle methods for fetching, and error handling.\n\n  return class extends React.Component<P> {\n    // ...\n    render() {\n      // This is a placeholder. You'll need to manage loading/error/data states.\n      return <WrappedComponent {...this.props} data={null} isLoading={false} error={null} />;\n    }\n  };\n}\n\n// Example usage component 1:\ninterface UserDisplayProps {\n  userId: string;\n  data: { id: string; name: string; email: string } | null;\n  isLoading: boolean;\n  error: Error | null;\n}\n\nconst UserDisplay: React.FC<UserDisplayProps> = ({ userId, data, isLoading, error }) => {\n  if (isLoading) return <p>Loading user {userId}...</p>;\n  if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n  if (!data) return <p>User {userId} not found.</p>;\n  return (\n    <div>\n      <h3>User Details (ID: {data.id})</h3>\n      <p>Name: {data.name}</p>\n      <p>Email: {data.email}</p>\n    </div>\n  );\n};\n\n// Example usage component 2:\ninterface ProductDisplayProps {\n  productId: string;\n  data: { id: string; name: string; price: number } | null;\n  isLoading: boolean;\n  error: Error | null;\n}\n\nconst ProductDisplay: React.FC<ProductDisplayProps> = ({ productId, data, isLoading, error }) => {\n  if (isLoading) return <p>Loading product {productId}...</p>;\n  if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n  if (!data) return <p>Product {productId} not found.</p>;\n  return (\n    <div>\n      <h3>Product Details (ID: {data.id})</h3>\n      <p>Name: {data.name}</p>\n      <p>Price: ${data.price}</p>\n    </div>\n  );\n};\n\nconst UserDataLoader = withDataLoader(UserDisplay, (props: { userId: string }) => simulatedApi.fetchUserData(props.userId));\nconst ProductDataLoader = withDataLoader(ProductDisplay, (props: { productId: string }) => simulatedApi.fetchProductData(props.productId));\n\n// Example of how to use the DataLoader HOCs in a parent component:\n/*\nconst App = () => (\n  <div>\n    <UserDataLoader userId=\"1\" />\n    <hr />\n    <ProductDataLoader productId=\"P1\" />\n    <hr />\n    <UserDataLoader userId=\"error\" />\n    <hr />\n    <ProductDataLoader productId=\"non-existent\" />\n  </div>\n);\n\nReactDOM.render(<App />, document.getElementById('root'));\n*/\n",
          "solutionCode": "import React from 'react';\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nconst simulatedApi = {\n  fetchUserData: (userId: string) => new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId === 'error') {\n        reject(new Error('Failed to fetch user data.'));\n      } else if (userId === '1') {\n        resolve({ id: '1', name: 'Alice', email: 'alice@example.com' });\n      } else if (userId === '2') {\n        resolve({ id: '2', name: 'Bob', email: 'bob@example.com' });\n      } else {\n        resolve(null);\n      }\n    }, 1000);\n  }),\n  fetchProductData: (productId: string) => new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (productId === 'error') {\n        reject(new Error('Product data not found.'));\n      } else if (productId === 'P1') {\n        resolve({ id: 'P1', name: 'Laptop', price: 1200 });\n      } else {\n        resolve(null);\n      }\n    }, 800);\n  })\n};\n\ninterface DataLoaderState<D> {\n  data: D | null;\n  isLoading: boolean;\n  error: Error | null;\n}\n\nfunction withDataLoader<P extends object, D>(\n  WrappedComponent: React.ComponentType<P & DataLoaderState<D>>,\n  dataFetcher: (props: P) => Promise<D | null>\n): React.ComponentType<P> {\n  class WithDataLoader extends React.Component<P, DataLoaderState<D>> {\n    static displayName = `withDataLoader(${getDisplayName(WrappedComponent)})`;\n\n    state: DataLoaderState<D> = {\n      data: null,\n      isLoading: false,\n      error: null,\n    };\n\n    private mounted = false; // To prevent setting state on unmounted component\n\n    componentDidMount() {\n      this.mounted = true;\n      this.fetchData();\n    }\n\n    componentDidUpdate(prevProps: P) {\n      // Re-fetch data if relevant props change\n      if (JSON.stringify(this.props) !== JSON.stringify(prevProps)) {\n        this.fetchData();\n      }\n    }\n\n    componentWillUnmount() {\n      this.mounted = false;\n    }\n\n    fetchData = async () => {\n      if (!this.mounted) return;\n      this.setState({ isLoading: true, error: null });\n      try {\n        const result = await dataFetcher(this.props);\n        if (this.mounted) {\n          this.setState({ data: result, isLoading: false });\n        }\n      } catch (err: any) {\n        if (this.mounted) {\n          this.setState({ error: err, isLoading: false });\n        }\n      }\n    };\n\n    render() {\n      const { data, isLoading, error } = this.state;\n      return (\n        <WrappedComponent\n          {...this.props as P}\n          data={data}\n          isLoading={isLoading}\n          error={error}\n        />\n      );\n    }\n  }\n\n  return WithDataLoader;\n}\n\ninterface UserDisplayProps {\n  userId: string;\n  data: { id: string; name: string; email: string } | null;\n  isLoading: boolean;\n  error: Error | null;\n}\n\nconst UserDisplay: React.FC<UserDisplayProps> = ({ userId, data, isLoading, error }) => {\n  if (isLoading) return <p>Loading user {userId}...</p>;\n  if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n  if (!data) return <p>User {userId} not found.</p>;\n  return (\n    <div>\n      <h3>User Details (ID: {data.id})</h3>\n      <p>Name: {data.name}</p>\n      <p>Email: {data.email}</p>\n    </div>\n  );\n};\n\ninterface ProductDisplayProps {\n  productId: string;\n  data: { id: string; name: string; price: number } | null;\n  isLoading: boolean;\n  error: Error | null;\n}\n\nconst ProductDisplay: React.FC<ProductDisplayProps> = ({ productId, data, isLoading, error }) => {\n  if (isLoading) return <p>Loading product {productId}...</p>;\n  if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n  if (!data) return <p>Product {productId} not found.</p>;\n  return (\n    <div>\n      <h3>Product Details (ID: {data.id})</h3>\n      <p>Name: {data.name}</p>\n      <p>Price: ${data.price}</p>\n    </div>\n  );\n};\n\nconst UserDataLoader = withDataLoader(UserDisplay, (props: { userId: string }) => simulatedApi.fetchUserData(props.userId));\nconst ProductDataLoader = withDataLoader(ProductDisplay, (props: { productId: string }) => simulatedApi.fetchProductData(props.productId));\n\nconst App: React.FC = () => (\n  <div>\n    <UserDataLoader userId=\"1\" />\n    <hr />\n    <ProductDataLoader productId=\"P1\" />\n    <hr />\n    <UserDataLoader userId=\"error\" />\n    <hr />\n    <ProductDataLoader productId=\"non-existent\" />\n    <hr />\n    {/* Test re-fetching on prop change */}\n    <UserDataLoader userId=\"2\" />\n  </div>\n);\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n",
          "testCases": [
            "Render `UserDataLoader` with `userId=\"1\"`. It should show 'Loading...' then 'User Details (ID: 1)'.",
            "Render `ProductDataLoader` with `productId=\"P1\"`. It should show 'Loading...' then 'Product Details (ID: P1)'.",
            "Render `UserDataLoader` with `userId=\"error\"`. It should show 'Loading...' then 'Error: Failed to fetch user data.'.",
            "Render `ProductDataLoader` with `productId=\"non-existent\"`. It should show 'Loading...' then 'Product P1 not found.' (or similar for null data).",
            "Render a component wrapped by `withDataLoader` where the data-fetching prop changes. Verify that data is re-fetched and states update correctly.",
            "Ensure `displayName` is set correctly for debugging.",
            "Verify that unrelated props are passed correctly if `WrappedComponent` expects them (e.g., `<UserDataLoader userId=\"1\" extraProp=\"test\" />`)."
          ],
          "hints": [
            "Use `componentDidMount` to initiate the initial data fetch.",
            "Use `componentDidUpdate` to handle re-fetching data when the HOC's props change.",
            "Remember to handle the `Promise` resolution and rejection for success and error states.",
            "Set `isLoading` to `true` before fetching and `false` after the promise resolves or rejects.",
            "Don't forget to pass all existing `this.props` to the `WrappedComponent` along with the new `data`, `isLoading`, and `error` props.",
            "Consider adding a flag like `this.mounted` in `componentDidMount` and setting it to `false` in `componentWillUnmount` to prevent setting state on an unmounted component, which can lead to memory leaks or warnings."
          ],
          "tags": [
            "React",
            "HOC",
            "Data Fetching",
            "Loading States",
            "Error Handling",
            "Async Operations"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Class Components",
            "React Lifecycle",
            "Promises",
            "HOC Fundamentals",
            "TypeScript Generics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Fetch API",
            "Component Composition",
            "State Management Patterns"
          ]
        },
        {
          "id": "task_hoc_access_control",
          "title": "Build a `withAccessControl` HOC",
          "description": "\nDevelop a High-Order Component `withAccessControl` that enforces access permissions based on user roles. This HOC should:\n\n1.  Take a `WrappedComponent` and an array of `requiredRoles` (e.g., `['admin', 'editor']`) as arguments.\n2.  Assume there's a `UserContext` or a global `authService` that provides the `currentUser` object, which has a `roles` array (e.g., `['viewer']`).\n3.  If the `currentUser` has at least one of the `requiredRoles`:\n    *   Render the `WrappedComponent` with all its original props.\n4.  If the `currentUser` does NOT have any of the `requiredRoles`:\n    *   Render a fallback `Unauthorized` message (e.g., `<div>Access Denied</div>`).\n    *   Alternatively, accept an optional `fallbackComponent` prop to render instead.\n5.  Ensure all props are passed through.\n6.  Set a `displayName`.\n\n**Mock `AuthService` (for context):**\n```typescript\ninterface User {\n  id: string;\n  name: string;\n  roles: string[];\n}\n\nconst authService = {\n  currentUser: null as User | null,\n  login: (user: User) => { authService.currentUser = user; },\n  logout: () => { authService.currentUser = null; },\n  getCurrentUser: () => authService.currentUser,\n  hasRole: (role: string) => authService.currentUser?.roles.includes(role) || false,\n  hasAnyRole: (roles: string[]) => roles.some(role => authService.hasRole(role)),\n};\n\n// Simulate different users\nconst adminUser: User = { id: 'u1', name: 'Admin User', roles: ['admin', 'viewer'] };\nconst editorUser: User = { id: 'u2', name: 'Editor User', roles: ['editor', 'viewer'] };\nconst viewerUser: User = { id: 'u3', name: 'Viewer User', roles: ['viewer'] };\nconst noRoleUser: User = { id: 'u4', name: 'Guest User', roles: [] };\n```\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\n// Helper to get component display name\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\ninterface User {\n  id: string;\n  name: string;\n  roles: string[];\n}\n\n// Mock AuthService (provided in description)\nconst authService = {\n  currentUser: null as User | null,\n  login: (user: User) => { authService.currentUser = user; },\n  logout: () => { authService.currentUser = null; },\n  getCurrentUser: () => authService.currentUser,\n  hasRole: (role: string) => authService.currentUser?.roles.includes(role) || false,\n  hasAnyRole: (roles: string[]) => roles.some(role => authService.hasRole(role)),\n};\n\n// Simulate different users (provided in description)\nconst adminUser: User = { id: 'u1', name: 'Admin User', roles: ['admin', 'viewer'] };\nconst editorUser: User = { id: 'u2', name: 'Editor User', roles: ['editor', 'viewer'] };\nconst viewerUser: User = { id: 'u3', name: 'Viewer User', roles: ['viewer'] };\nconst noRoleUser: User = { id: 'u4', name: 'Guest User', roles: [] };\n\n// Your task: Implement withAccessControl HOC\n// P: Props for the HOC\n// FallbackComponentProps: Optional props for the fallback component (if applicable)\nfunction withAccessControl<P extends object>(\n  WrappedComponent: React.ComponentType<P>,\n  requiredRoles: string[],\n  FallbackComponent?: React.ComponentType<any> // Optional fallback component\n): React.ComponentType<P> {\n  // TODO: Implement the HOC logic here\n\n  return class extends React.Component<P> {\n    render() {\n      // This is a placeholder. Implement actual access control logic.\n      return <WrappedComponent {...this.props} />;\n    }\n  };\n}\n\n// Example Usage Components\nconst AdminDashboard: React.FC = () => <div>Welcome to the Admin Dashboard!</div>;\nconst EditorPanel: React.FC = () => <div>Edit content here.</div>;\nconst ViewerContent: React.FC = () => <div>View general content.</div>;\n\n// Apply HOCs\nconst AuthenticatedAdminDashboard = withAccessControl(AdminDashboard, ['admin']);\nconst AuthenticatedEditorPanel = withAccessControl(EditorPanel, ['editor']);\nconst AuthenticatedViewerContent = withAccessControl(ViewerContent, ['viewer']);\n\nconst FallbackMessage: React.FC = () => <div style={{ color: 'orange' }}>Please log in with sufficient privileges.</div>;\nconst SpecificFallbackAdminDashboard = withAccessControl(AdminDashboard, ['admin'], FallbackMessage);\n\n// Test application:\n/*\nconst App = () => {\n  const [user, setUser] = React.useState<User | null>(null);\n\n  React.useEffect(() => {\n    authService.login(adminUser); // Set initial user\n    setUser(authService.getCurrentUser());\n  }, []);\n\n  return (\n    <div>\n      <h1>Access Control Demo (Current User: {user?.name || 'None'})</h1>\n      <button onClick={() => { authService.login(adminUser); setUser(authService.getCurrentUser()); }}>Login as Admin</button>\n      <button onClick={() => { authService.login(editorUser); setUser(authService.getCurrentUser()); }}>Login as Editor</button>\n      <button onClick={() => { authService.login(viewerUser); setUser(authService.getCurrentUser()); }}>Login as Viewer</button>\n      <button onClick={() => { authService.login(noRoleUser); setUser(authService.getCurrentUser()); }}>Login as Guest</button>\n      <button onClick={() => { authService.logout(); setUser(authService.getCurrentUser()); }}>Logout</button>\n      \n      <hr/>\n      <h2>Admin Section:</h2>\n      <AuthenticatedAdminDashboard />\n      <hr/>\n      <h2>Editor Section:</h2>\n      <AuthenticatedEditorPanel />\n      <hr/>\n      <h2>Viewer Section:</h2>\n      <AuthenticatedViewerContent />\n      <hr/>\n      <h2>Admin Section with Custom Fallback:</h2>\n      <SpecificFallbackAdminDashboard />\n    </div>\n  );\n};\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n*/\n",
          "solutionCode": "import React from 'react';\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\ninterface User {\n  id: string;\n  name: string;\n  roles: string[];\n}\n\nconst authService = {\n  currentUser: null as User | null,\n  login: (user: User) => { authService.currentUser = user; },\n  logout: () => { authService.currentUser = null; },\n  getCurrentUser: () => authService.currentUser,\n  hasRole: (role: string) => authService.currentUser?.roles.includes(role) || false,\n  hasAnyRole: (roles: string[]) => roles.some(role => authService.hasRole(role)),\n};\n\nconst adminUser: User = { id: 'u1', name: 'Admin User', roles: ['admin', 'viewer'] };\nconst editorUser: User = { id: 'u2', name: 'Editor User', roles: ['editor', 'viewer'] };\nconst viewerUser: User = { id: 'u3', name: 'Viewer User', roles: ['viewer'] };\nconst noRoleUser: User = { id: 'u4', name: 'Guest User', roles: [] };\n\nfunction withAccessControl<P extends object>(\n  WrappedComponent: React.ComponentType<P>,\n  requiredRoles: string[],\n  FallbackComponent?: React.ComponentType<any> \n): React.ComponentType<P> {\n  class WithAccessControl extends React.Component<P> {\n    static displayName = `withAccessControl(${getDisplayName(WrappedComponent)})`;\n\n    render() {\n      const hasAccess = authService.hasAnyRole(requiredRoles);\n\n      if (!hasAccess) {\n        if (FallbackComponent) {\n          return <FallbackComponent {...this.props} />; // Pass props to fallback too\n        } else {\n          return <div style={{ color: 'red', fontWeight: 'bold' }}>Access Denied! Required roles: {requiredRoles.join(', ')}</div>;\n        }\n      }\n\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n\n  return WithAccessControl;\n}\n\nconst AdminDashboard: React.FC = () => <div>Welcome to the Admin Dashboard!</div>;\nconst EditorPanel: React.FC = () => <div>Edit content here.</div>;\nconst ViewerContent: React.FC = () => <div>View general content.</div>;\n\nconst AuthenticatedAdminDashboard = withAccessControl(AdminDashboard, ['admin']);\nconst AuthenticatedEditorPanel = withAccessControl(EditorPanel, ['editor']);\nconst AuthenticatedViewerContent = withAccessControl(ViewerContent, ['viewer']);\n\nconst FallbackMessage: React.FC = () => <div style={{ color: 'orange' }}>Please log in with sufficient privileges.</div>;\nconst SpecificFallbackAdminDashboard = withAccessControl(AdminDashboard, ['admin'], FallbackMessage);\n\nconst App: React.FC = () => {\n  const [user, setUser] = React.useState<User | null>(authService.getCurrentUser());\n\n  const handleLogin = (userToLogin: User) => {\n    authService.login(userToLogin);\n    setUser(authService.getCurrentUser());\n  };\n\n  const handleLogout = () => {\n    authService.logout();\n    setUser(authService.getCurrentUser());\n  };\n\n  return (\n    <div>\n      <h1>Access Control Demo (Current User: {user?.name || 'None'})</h1>\n      <button onClick={() => handleLogin(adminUser)}>Login as Admin</button>\n      <button onClick={() => handleLogin(editorUser)}>Login as Editor</button>\n      <button onClick={() => handleLogin(viewerUser)}>Login as Viewer</button>\n      <button onClick={() => handleLogin(noRoleUser)}>Login as Guest</button>\n      <button onClick={handleLogout}>Logout</button>\n      \n      <hr/>\n      <h2>Admin Section:</h2>\n      <AuthenticatedAdminDashboard />\n      <hr/>\n      <h2>Editor Section:</h2>\n      <AuthenticatedEditorPanel />\n      <hr/>\n      <h2>Viewer Section:</h2>\n      <AuthenticatedViewerContent />\n      <hr/>\n      <h2>Admin Section with Custom Fallback:</h2>\n      <SpecificFallbackAdminDashboard />\n    </div>\n  );\n};\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n",
          "testCases": [
            "Login as `adminUser`: `AuthenticatedAdminDashboard`, `AuthenticatedEditorPanel`, `AuthenticatedViewerContent`, and `SpecificFallbackAdminDashboard` should all render their respective components.",
            "Login as `editorUser`: `AuthenticatedAdminDashboard` should show 'Access Denied', `AuthenticatedEditorPanel` should render, `AuthenticatedViewerContent` should render, `SpecificFallbackAdminDashboard` should show the `FallbackMessage`.",
            "Login as `viewerUser`: `AuthenticatedAdminDashboard` and `AuthenticatedEditorPanel` should show 'Access Denied' / `FallbackComponent`, `AuthenticatedViewerContent` should render.",
            "Login as `noRoleUser` (Guest): All protected components (`AuthenticatedAdminDashboard`, `AuthenticatedEditorPanel`, `AuthenticatedViewerContent`) should show 'Access Denied' / `FallbackComponent`.",
            "Logout: All protected components should show 'Access Denied' / `FallbackComponent`.",
            "Verify `displayName` is set for debugging.",
            "Ensure props passed to `withAccessControl` (e.g., `<AuthenticatedAdminDashboard someProp=\"value\" />`) are correctly forwarded to `AdminDashboard` when access is granted, or to `FallbackComponent` if provided."
          ],
          "hints": [
            "The `authService.hasAnyRole` method is crucial for checking permissions.",
            "Access the current user's roles via `authService.getCurrentUser()`.",
            "The logic for rendering the `WrappedComponent` or the fallback should reside directly in the HOC's `render` method.",
            "Remember to pass `this.props` to both `WrappedComponent` and `FallbackComponent` to maintain flexibility."
          ],
          "tags": [
            "React",
            "HOC",
            "Authentication",
            "Authorization",
            "Access Control",
            "Security"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Components",
            "HOC Fundamentals",
            "Conditional Rendering"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Context API",
            "Security Patterns",
            "Conditional UI"
          ]
        },
        {
          "id": "task_hoc_combine_features",
          "title": "Compose HOCs for Enhanced Component",
          "description": "\nThis task requires you to combine multiple Higher-Order Components (HOCs) to create a single, enhanced component, demonstrating the power of HOC composability and adherence to best practices.\n\n**Given the following HOCs (you don't need to implement them, just use them as if they exist):**\n1.  `withAuth(WrappedComponent)`: Injects an `isAuthenticated: boolean` prop. Renders a `SignInMessage` if not authenticated.\n2.  `withTheme(WrappedComponent)`: Injects a `theme: { primaryColor: string, secondaryColor: string }` prop.\n3.  `withLogger(WrappedComponent)`: Logs component mount/unmount (from previous task, assume it works).\n\n**Your Goal:**\nCreate an `EnhancedDashboard` component by composing `Dashboard` with `withAuth`, `withTheme`, and `withLogger`. The order of application should be:\n\n*   First, `withAuth` to handle authentication.\n*   Second, `withTheme` to provide theming.\n*   Third, `withLogger` for logging.\n\n**Requirements:**\n1.  Define a simple `Dashboard` functional component that accepts `isAuthenticated`, `theme`, and other standard props.\n2.  Implement the `compose` utility function (if not provided).\n3.  Use the `compose` utility to chain the HOCs in the specified order.\n4.  Render `EnhancedDashboard` and verify its behavior (e.g., authentication status, theme colors, and console logs).\n\n**Mock HOCs to use:**\n```typescript\nimport React from 'react';\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\n// Mock HOC 1: withAuth\ninterface WithAuthProps { isAuthenticated: boolean; }\nconst SignInMessage: React.FC = () => <div style={{ padding: '10px', background: '#ffe0b2', border: '1px solid orange' }}>Please sign in to view this content.</div>;\nconst withAuth = <P extends object>(WrappedComponent: React.ComponentType<P & WithAuthProps>): React.ComponentType<P> => {\n  return class WithAuth extends React.Component<P> {\n    static displayName = `withAuth(${getDisplayName(WrappedComponent)})`;\n    render() {\n      const isAuthenticated = true; // Simulate authentication for now\n      if (!isAuthenticated) {\n        return <SignInMessage />;\n      }\n      return <WrappedComponent {...this.props as P} isAuthenticated={isAuthenticated} />;\n    }\n  };\n};\n\n// Mock HOC 2: withTheme\ninterface Theme { primaryColor: string; secondaryColor: string; }\ninterface WithThemeProps { theme: Theme; }\nconst withTheme = <P extends object>(WrappedComponent: React.ComponentType<P & WithThemeProps>): React.ComponentType<P> => {\n  return class WithTheme extends React.Component<P> {\n    static displayName = `withTheme(${getDisplayName(WrappedComponent)})`;\n    render() {\n      const theme = { primaryColor: '#2196F3', secondaryColor: '#FFC107' }; // Default theme\n      return <WrappedComponent {...this.props as P} theme={theme} />;\n    }\n  };\n};\n\n// Mock HOC 3: withLogger (from previous task, simplified for this one)\nconst withLogger = <P extends object>(WrappedComponent: React.ComponentType<P>): React.ComponentType<P> => {\n  return class WithLogger extends React.Component<P> {\n    static displayName = `withLogger(${getDisplayName(WrappedComponent)})`;\n    componentDidMount() { console.log(`${getDisplayName(WrappedComponent)} mounted.`); }\n    componentWillUnmount() { console.log(`${getDisplayName(WrappedComponent)} unmounted.`); }\n    render() { return <WrappedComponent {...this.props} />; }\n  };\n};\n\n// Compose utility (if not provided by a library)\nconst compose = (...fns: Function[]) => (x: any) => fns.reduceRight((v, f) => f(v), x);\n\n// Your Dashboard component and composition logic goes here.\n```\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\n// Helper to get component display name\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\n// Mock HOCs (Provided in description - copy them here for local testing)\n// Mock HOC 1: withAuth\ninterface WithAuthProps { isAuthenticated: boolean; }\nconst SignInMessage: React.FC = () => <div style={{ padding: '10px', background: '#ffe0b2', border: '1px solid orange' }}>Please sign in to view this content.</div>;\nconst withAuth = <P extends object>(WrappedComponent: React.ComponentType<P & WithAuthProps>): React.ComponentType<P> => {\n  return class WithAuth extends React.Component<P> {\n    static displayName = `withAuth(${getDisplayName(WrappedComponent)})`;\n    render() {\n      const isAuthenticated = true; // Simulate authentication for now\n      if (!isAuthenticated) {\n        return <SignInMessage />;\n      }\n      return <WrappedComponent {...this.props as P} isAuthenticated={isAuthenticated} />;\n    }\n  };\n};\n\n// Mock HOC 2: withTheme\ninterface Theme { primaryColor: string; secondaryColor: string; }\ninterface WithThemeProps { theme: Theme; }\nconst withTheme = <P extends object>(WrappedComponent: React.ComponentType<P & WithThemeProps>): React.ComponentType<P> => {\n  return class WithTheme extends React.Component<P> {\n    static displayName = `withTheme(${getDisplayName(WrappedComponent)})`;\n    render() {\n      const theme = { primaryColor: '#2196F3', secondaryColor: '#FFC107' }; // Default theme\n      return <WrappedComponent {...this.props as P} theme={theme} />;\n    }\n  };\n};\n\n// Mock HOC 3: withLogger\nconst withLogger = <P extends object>(WrappedComponent: React.ComponentType<P>): React.ComponentType<P> => {\n  return class WithLogger extends React.Component<P> {\n    static displayName = `withLogger(${getDisplayName(WrappedComponent)})`;\n    componentDidMount() { console.log(`${getDisplayName(WrappedComponent)} mounted.`); }\n    componentWillUnmount() { console.log(`${getDisplayName(WrappedComponent)} unmounted.`); }\n    render() { return <WrappedComponent {...this.props} />; }\n  };\n};\n\n// Compose utility (Provided in description)\nconst compose = (...fns: Function[]) => (x: any) => fns.reduceRight((v, f) => f(v), x);\n\n// Your task: Define Dashboard component and compose HOCs\n\ninterface DashboardProps {\n  isAuthenticated: boolean;\n  theme: Theme;\n  welcomeMessage?: string; // An example of an unrelated prop\n}\n\nconst Dashboard: React.FC<DashboardProps> = ({ isAuthenticated, theme, welcomeMessage }) => {\n  // TODO: Implement Dashboard component to display injected props\n  return <div>Your Dashboard Content Here</div>;\n};\n\n// TODO: Compose HOCs to create EnhancedDashboard\n// const EnhancedDashboard = ...;\n\n// Example Usage:\n/*\nconst App: React.FC = () => {\n  return (\n    <div>\n      <h1>Composed Dashboard:</h1>\n      <EnhancedDashboard welcomeMessage=\"Hello User!\" />\n    </div>\n  );\n};\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n*/\n",
          "solutionCode": "import React from 'react';\n\nfunction getDisplayName<P extends object>(WrappedComponent: React.ComponentType<P>): string {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\ninterface WithAuthProps { isAuthenticated: boolean; }\nconst SignInMessage: React.FC = () => <div style={{ padding: '10px', background: '#ffe0b2', border: '1px solid orange' }}>Please sign in to view this content.</div>;\nconst withAuth = <P extends object>(WrappedComponent: React.ComponentType<P & WithAuthProps>): React.ComponentType<P> => {\n  return class WithAuth extends React.Component<P> {\n    static displayName = `withAuth(${getDisplayName(WrappedComponent)})`;\n    render() {\n      const isAuthenticated = true; // Simulate authentication: true for main test\n      if (!isAuthenticated) {\n        return <SignInMessage />;\n      }\n      return <WrappedComponent {...this.props as P} isAuthenticated={isAuthenticated} />;\n    }\n  };\n};\n\ninterface Theme { primaryColor: string; secondaryColor: string; }\ninterface WithThemeProps { theme: Theme; }\nconst withTheme = <P extends object>(WrappedComponent: React.ComponentType<P & WithThemeProps>): React.ComponentType<P> => {\n  return class WithTheme extends React.Component<P> {\n    static displayName = `withTheme(${getDisplayName(WrappedComponent)})`;\n    render() {\n      const theme = { primaryColor: '#2196F3', secondaryColor: '#FFC107' }; // Default theme\n      return <WrappedComponent {...this.props as P} theme={theme} />;\n    }\n  };\n};\n\nconst withLogger = <P extends object>(WrappedComponent: React.ComponentType<P>): React.ComponentType<P> => {\n  return class WithLogger extends React.Component<P> {\n    static displayName = `withLogger(${getDisplayName(WrappedComponent)})`;\n    componentDidMount() { console.log(`${getDisplayName(WrappedComponent)} mounted.`); }\n    componentWillUnmount() { console.log(`${getDisplayName(WrappedComponent)} unmounted.`); }\n    render() { return <WrappedComponent {...this.props} />; }\n  };\n};\n\nconst compose = (...fns: Function[]) => (x: any) => fns.reduceRight((v, f) => f(v), x);\n\ninterface DashboardProps {\n  isAuthenticated: boolean;\n  theme: Theme;\n  welcomeMessage?: string; // An example of an unrelated prop\n}\n\nconst Dashboard: React.FC<DashboardProps> = ({ isAuthenticated, theme, welcomeMessage }) => {\n  return (\n    <div style={{ padding: '20px', border: `2px solid ${theme.primaryColor}`, color: theme.primaryColor }}>\n      <h2 style={{ color: theme.secondaryColor }}>{welcomeMessage || 'Welcome to your Dashboard!'}</h2>\n      <p>Authentication Status: {isAuthenticated ? 'Authenticated' : 'Not Authenticated'}</p>\n      <p>Primary Color: {theme.primaryColor}</p>\n      <p>Secondary Color: {theme.secondaryColor}</p>\n      <p>This component is enhanced by multiple HOCs!</p>\n    </div>\n  );\n};\n\n// Compose HOCs in the specified order (right-to-left for compose)\n// Order: Dashboard -> withAuth -> withTheme -> withLogger\nconst EnhancedDashboard = compose(\n  withLogger,\n  withTheme,\n  withAuth\n)(Dashboard);\n\nconst App: React.FC = () => {\n  return (\n    <div>\n      <h1>Composed Dashboard:</h1>\n      <EnhancedDashboard welcomeMessage=\"Hello User!\" />\n      <br/>\n      <p>Check console for mount/unmount logs. Inspect component in DevTools for display name.</p>\n    </div>\n  );\n};\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n",
          "testCases": [
            "Render `EnhancedDashboard` and verify that the 'Dashboard mounted.' message appears in the console (due to `withLogger`).",
            "Inspect `EnhancedDashboard` in React Developer Tools and confirm its `displayName` is correctly chained (e.g., `withLogger(withTheme(withAuth(Dashboard)))`).",
            "Verify that `isAuthenticated` is `true` and the theme colors (`primaryColor`, `secondaryColor`) are displayed correctly on the `Dashboard` component.",
            "Pass an additional prop like `welcomeMessage` to `EnhancedDashboard` and confirm it renders correctly on `Dashboard` (ensuring prop passthrough)."
          ],
          "hints": [
            "Remember that `compose` utilities typically apply functions from right to left.",
            "Think about the order of HOCs: the inner-most HOC (closest to `Dashboard`) is applied first.",
            "Ensure your `Dashboard` component explicitly accepts all the props that the HOCs will inject (`isAuthenticated`, `theme`).",
            "Don't forget to pass through any extra props given to `EnhancedDashboard` itself."
          ],
          "tags": [
            "React",
            "HOC",
            "Composability",
            "Best Practices",
            "Authentication",
            "Theming",
            "Logging"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "HOC Fundamentals",
            "Functional Composition",
            "React Props"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Middleware",
            "Design Patterns",
            "Cross-Cutting Concerns"
          ]
        }
      ]
    }
  }
]