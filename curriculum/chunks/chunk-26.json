[
  {
    "id": "4f07cbeb-e572-419a-97a0-563bc61e4192",
    "startLine": 4900,
    "endLine": 4999,
    "processedDate": "2025-06-17T09:21:20.457Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_hooks_state_effects_memoization",
          "title": "React Hooks: State Management, Side Effects, and Memoization",
          "content": "React Hooks are functions that let you \"hook into\" React state and lifecycle features from function components. They were introduced in React 16.8 to allow developers to use state and other React features without writing a class.\n\n## useState Hook\n`useState` is a Hook that lets you add React state to function components. It returns a pair: the current state value and a function that lets you update it. The update function is typically named `set[StateVariable]`. When the setter function is called, React re-renders the component.\n\n## useEffect Hook\n`useEffect` is a Hook that lets you perform side effects in function components. Side effects are operations that affect the world outside of the component, such as data fetching, subscriptions, or manually changing the DOM. `useEffect` runs after every render of the component by default, but its behavior can be controlled by a dependency array.\n\n*   **No dependency array**: The effect runs after every render, comparable to `componentDidMount` and `componentDidUpdate` combined.\n*   **Empty dependency array (`[]`)**: The effect runs only once after the initial render, and the cleanup function (if provided) runs only when the component unmounts. This is comparable to `componentDidMount` and `componentWillUnmount`.\n*   **Dependency array with values (`[dep1, dep2]`)**: The effect runs after the initial render and then only if any of the values in the dependency array change between renders. The cleanup function runs before the effect re-runs due to a dependency change, and when the component unmounts. This is comparable to `componentDidUpdate` for specific props/state.\n\n`useEffect` can optionally return a cleanup function. This function is called by React before the component unmounts, or before the effect re-runs (if dependencies change). This is crucial for cleaning up subscriptions, timers, or other resources to prevent memory leaks.\n\n### Handling Unmounted Components in useEffect\nWhen performing asynchronous operations (like data fetching) inside `useEffect`, it's possible that the component might unmount before the asynchronous operation completes. If the state update is attempted on an unmounted component, React will issue a warning or potentially cause errors. A common pattern to prevent this is to use a mutable flag (e.g., `isMounted`) that is set to `false` in the cleanup function. Before updating state, check the value of this flag.\n\n## useMemo Hook\n`useMemo` is a Hook that lets you memoize (cache) the result of a function computation. It returns a memoized value that is re-computed only when one of its dependencies has changed. This is useful for optimizing performance by avoiding expensive calculations on every render, especially when those calculations depend on values that don't change frequently. `useMemo` takes two arguments: a function that computes the value and a dependency array.\n\n### Relationship to Class Component Lifecycle Methods\n\n*   `useState` replaces `this.state` and `this.setState`.\n*   `useEffect` with an empty dependency array (`[]`) replaces `componentDidMount` for initial setup and `componentWillUnmount` for cleanup.\n*   `useEffect` with a dependency array (`[props.someValue]`) replaces `componentDidUpdate` for reacting to specific prop/state changes.\n*   `useMemo` can serve as a way to derive state from props or state efficiently, similar in concept to `getDerivedStateFromProps` in terms of deriving state, but for computed values rather than state itself, and without the associated pitfalls.\n",
          "examples": [
            {
              "id": "example_hooks_1",
              "title": "Basic useState and useEffect for Data Fetching",
              "code": "import React, { useState, useEffect } from 'react';\n\nfunction ProfilePage({ userId }) {\n  const [user, setUser] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    let isMounted = true; // Flag to track component mount status\n    setLoading(true); // Indicate loading state\n    setError(null); // Clear previous errors\n    \n    fetch(`/api/users/${userId}`)\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then(data => {\n        if (isMounted) { // Only update if component is still mounted\n          setUser(data);\n          setLoading(false);\n        }\n      })\n      .catch(err => {\n        if (isMounted) { // Only update if component is still mounted\n          setError(err);\n          setLoading(false);\n        }\n      });\n    \n    return () => {\n      isMounted = false; // Set flag to false when component unmounts or effect re-runs\n    };\n  }, [userId]); // Re-run effect when userId changes\n\n  const userNameDisplay = user ? `${user.firstName} ${user.lastName}` : 'Loading...';\n\n  if (loading) return <div>Loading user profile...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  \n  return (\n    <div>\n      <h2>{userNameDisplay}</h2>\n      <div>Email: {user.email}</div>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates `useState` for managing `user`, `error`, and `loading` states. `useEffect` is used for data fetching; it runs when `userId` changes. The `isMounted` flag in the `useEffect`'s closure prevents state updates on an unmounted component, which is a common best practice for async operations in effects. The cleanup function sets `isMounted` to `false` when the component unmounts or when the effect re-runs due to `userId` changing.",
              "language": "javascript"
            },
            {
              "id": "example_hooks_2",
              "title": "Using useMemo for Memoized Calculations",
              "code": "import React, { useState, useMemo } from 'react';\n\nfunction ProductDisplay({ price, quantity }) {\n  const [discount, setDiscount] = useState(0.1);\n\n  // Calculate total price only when price, quantity, or discount change\n  const totalCost = useMemo(() => {\n    console.log('Calculating total cost...');\n    return (price * quantity) * (1 - discount);\n  }, [price, quantity, discount]);\n\n  return (\n    <div>\n      <p>Price per item: ${price}</p>\n      <p>Quantity: {quantity}</p>\n      <p>Discount: {discount * 100}%</p>\n      <h3>Total Cost: ${totalCost.toFixed(2)}</h3>\n      <button onClick={() => setDiscount(prev => prev === 0.1 ? 0.2 : 0.1)}>Toggle Discount</button>\n      <button onClick={() => console.log('Component re-rendered without total cost recalculation')}>Force Re-render (Check Console)</button>\n    </div>\n  );\n}",
              "explanation": "This example uses `useMemo` to calculate `totalCost`. The calculation only re-runs if `price`, `quantity`, or `discount` change. If the `ProductDisplay` component re-renders for other reasons (e.g., a parent component re-renders), the `totalCost` calculation is skipped unless its dependencies have changed, improving performance. The console log helps observe when the calculation actually occurs.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_hooks_1",
            "question_hooks_2",
            "question_hooks_3",
            "question_hooks_4",
            "question_hooks_5",
            "question_hooks_6",
            "question_hooks_7",
            "question_hooks_8",
            "question_hooks_9",
            "question_hooks_10",
            "question_hooks_11",
            "question_hooks_12"
          ],
          "relatedTasks": [
            "task_data_fetching_component",
            "task_memoized_calculation"
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "useEffect",
            "useMemo",
            "Side Effects",
            "Memoization",
            "Data Fetching",
            "Functional Components",
            "Lifecycle"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript_basics",
            "React_components",
            "Promises"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced_React_Patterns",
            "Performance_Optimization"
          ]
        },
        {
          "id": "theory_deprecated_lifecycle_methods",
          "title": "Legacy React Class Component Lifecycle Methods (Deprecated)",
          "content": "Before React Hooks, class components were the primary way to use state and lifecycle features. React provides several lifecycle methods that allow developers to run code at specific points in a component's life cycle (mounting, updating, unmounting).\n\nOver time, some of these methods were identified as problematic, leading to their deprecation. These 'UNSAFE_' prefixed methods are considered legacy and should be avoided in new code due to potential for bugs, unexpected behavior, and making future concurrent React features difficult to implement. Using them might cause issues with Strict Mode and React's async rendering capabilities.\n\n## UNSAFE_componentWillMount()\n*   **When called:** Just before the component is mounted (i.e., before the first `render()`).\n*   **Why deprecated:** Performing side effects (like data fetching) here is discouraged because it can block the initial render. If `setState` is called here, it won't trigger a re-render but will overwrite the state, potentially leading to confusion and issues with server-side rendering (SSR) where it might run multiple times.\n*   **Recommended replacements:**\n    *   For initial state setup: Use the `constructor` or `useState` hook.\n    *   For side effects (like data fetching): Use `componentDidMount` or `useEffect` hook with an empty dependency array (`[]`).\n\n## UNSAFE_componentWillReceiveProps(nextProps)\n*   **When called:** When the component is receiving new props before a re-render.\n*   **Why deprecated:** This method was often misused for deriving state from props, leading to subtle bugs, especially when `setState` was called inside it. Calling `setState` unconditionally here could lead to infinite loops if not carefully managed. It also ran before `render`, which could cause inconsistencies if props changed mid-render.\n*   **Recommended replacements:**\n    *   For deriving state from props: Use static `getDerivedStateFromProps`.\n    *   For side effects that depend on props changes: Use `componentDidUpdate` or `useEffect` with a dependency array.\n\n## UNSAFE_componentWillUpdate(nextProps, nextState)\n*   **When called:** Just before rendering with new props or state, but not for the initial render.\n*   **Why deprecated:** Similar to `UNSAFE_componentWillReceiveProps`, this method was problematic because it ran before `render` and `componentDidUpdate`, making it difficult to guarantee that DOM operations would be consistent. It was also commonly misused for side effects that should have been in `componentDidUpdate`.\n*   **Recommended replacements:**\n    *   For inspecting DOM before updates: Use `getSnapshotBeforeUpdate`.\n    *   For side effects after updates: Use `componentDidUpdate` or `useEffect` with a dependency array.\n\nWhile these methods still technically work in older React versions, their use is strongly discouraged, and they are marked as `UNSAFE_` to highlight that they can cause issues with future React features like Async Rendering and Concurrent Mode. Migrating away from them to newer lifecycle methods or Hooks is best practice.\n",
          "examples": [
            {
              "id": "example_deprecated_lifecycle_1",
              "title": "Example of Legacy Deprecated Lifecycle Methods",
              "code": "import React from 'react';\n\nclass LegacyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null };\n    console.log('1. Constructor: Initializing state');\n  }\n\n  // UNSAFE_componentWillMount is called before mounting occurs\n  // Avoid using this method in modern React applications.\n  UNSAFE_componentWillMount() {\n    console.log('2. UNSAFE_componentWillMount: Called before component mounts (avoid)');\n    // Example of what NOT to do: calling setState here will not trigger a re-render,\n    // but will update state before initial render. This can lead to issues.\n    // this.setState({ data: 'initial data set in cWM' });\n  }\n\n  // componentDidMount is ideal for side effects like data fetching\n  componentDidMount() {\n    console.log('3. componentDidMount: Component mounted, suitable for data fetching');\n    // Example: fetch('/api/data').then(res => this.setState({ data: res.data }));\n  }\n\n  // UNSAFE_componentWillReceiveProps is called when props update\n  // Avoid using this method in modern React applications.\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    console.log('4. UNSAFE_componentWillReceiveProps: Called when props update (avoid)');\n    // Example of what NOT to do: deriving state from props directly here often leads to bugs.\n    // if (nextProps.userId !== this.props.userId) {\n    //   this.setState({ data: null, loading: true });\n    // }\n  }\n\n  // getDerivedStateFromProps is the recommended way to derive state from props\n  static getDerivedStateFromProps(nextProps, prevState) {\n    console.log('getDerivedStateFromProps: Deriving state from props');\n    // Example: if (nextProps.userId !== prevState.userId) { return { data: null, userId: nextProps.userId }; } return null;\n    return null;\n  }\n\n  // shouldComponentUpdate can optimize performance by preventing unnecessary re-renders\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('shouldComponentUpdate: Deciding whether to re-render');\n    return true; // Always re-render for this example\n  }\n\n  // UNSAFE_componentWillUpdate is called before rendering with new props/state\n  // Avoid using this method in modern React applications.\n  UNSAFE_componentWillUpdate(nextProps, nextState) {\n    console.log('5. UNSAFE_componentWillUpdate: Called before re-render (avoid)');\n    // Example of what NOT to do: side effects here can cause issues.\n  }\n\n  // getSnapshotBeforeUpdate is useful for capturing DOM state before an update\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('getSnapshotBeforeUpdate: Capturing DOM snapshot');\n    return null;\n  }\n\n  // componentDidUpdate is ideal for side effects after updates\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('6. componentDidUpdate: Component updated, suitable for side effects');\n  }\n\n  // componentWillUnmount is for cleanup before component unmounts\n  componentWillUnmount() {\n    console.log('7. componentWillUnmount: Component is about to unmount');\n  }\n\n  render() {\n    console.log('8. Render: Rendering component UI');\n    return (\n      <div>\n        <h3>Legacy Component Example</h3>\n        <p>Data: {this.state.data || 'N/A'}</p>\n        <p>Props: {JSON.stringify(this.props)}</p>\n      </div>\n    );\n  }\n}\n\nexport default LegacyComponent;\n",
              "explanation": "This code snippet illustrates the deprecated lifecycle methods within a class component. Comments highlight where each method is called and, importantly, why `UNSAFE_` methods should be avoided. It also indicates the recommended modern alternatives (like `constructor`, `componentDidMount`, `getDerivedStateFromProps`, `getSnapshotBeforeUpdate`, and `componentDidUpdate`). Observing the console logs when this component mounts and updates would demonstrate the order of execution.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_legacy_lifecycle_1",
            "question_legacy_lifecycle_2",
            "question_legacy_lifecycle_3",
            "question_legacy_lifecycle_4",
            "question_legacy_lifecycle_5",
            "question_legacy_lifecycle_6",
            "question_legacy_lifecycle_7",
            "question_legacy_lifecycle_8"
          ],
          "relatedTasks": [
            "task_refactor_legacy_component"
          ],
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "Deprecated",
            "UNSAFE",
            "Migration",
            "Hooks"
          ],
          "technology": "React",
          "prerequisites": [
            "React_class_components"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Maintaining_Legacy_Code",
            "Understanding_React_Evolution"
          ]
        },
        {
          "id": "theory_conditional_rendering",
          "title": "Conditional Rendering in React",
          "content": "Conditional rendering in React allows you to render different elements or components based on certain conditions. This is a fundamental concept for building dynamic and interactive user interfaces where the UI needs to change based on application state, user permissions, data availability, or other factors.\n\nReact components encapsulate their own logic, and conditional rendering is a powerful tool within this paradigm to control what gets rendered to the DOM.\n\n## Using `if` Statements\nThe most straightforward way to conditionally render components is by using standard JavaScript `if` statements. You can use them inside the component's function body (before the `return` statement) to return different JSX based on a condition.\n\n## Using Ternary Operators (`condition ? trueExpression : falseExpression`)\nFor inline conditional rendering, especially when you need to render one of two different elements, the ternary operator is a concise choice. It allows you to embed conditional logic directly within JSX.\n\n## Using Logical `&&` Operator (`condition && expression`)\nThe logical `&&` operator is useful when you want to render something only if a condition is true, and render nothing otherwise (or if the condition is false). If the `condition` is `true`, the `expression` to its right is evaluated and rendered. If the `condition` is `false`, React ignores the `expression` and renders nothing (because `false` is a valid renderable value that results in no output).\n\n## Other Approaches (Briefly Mentioned)\n*   **Element Variables:** You can declare a variable to hold an element and then conditionally assign components to it before returning that variable in JSX.\n*   **Switch Statements:** For multiple complex conditions, a `switch` statement can be used inside the component's function body to return different JSX, similar to `if` statements.\n\nChoosing the right method depends on the complexity of the condition and personal preference for readability.\n",
          "examples": [
            {
              "id": "example_conditional_rendering_1",
              "title": "Conditional Rendering with if Statement",
              "code": "import React from 'react';\n\nfunction UserHeader() {\n  return <h1>Welcome, User!</h1>;\n}\n\nfunction GuestHeader() {\n  return <h1>Welcome, Guest! Please Log In.</h1>;\n}\n\nfunction Header(props) {\n  if (props.isLoggedIn) {\n    return <UserHeader />;\n  }\n  return <GuestHeader />;\n}",
              "explanation": "This example uses a standard `if` statement to render either `UserHeader` or `GuestHeader` based on the `isLoggedIn` prop. This is a clear and readable way to handle distinct rendering paths.",
              "language": "javascript"
            },
            {
              "id": "example_conditional_rendering_2",
              "title": "Conditional Rendering with Ternary Operator",
              "code": "import React from 'react';\n\nfunction UserMessage() {\n  return <p>You have new messages!</p>;\n}\n\nfunction GuestMessage() {\n  return <p>Log in to view messages.</p>;\n}\n\nfunction Message(props) {\n  return (\n    <div>\n      {props.isLoggedIn ? <UserMessage /> : <GuestMessage />}\n    </div>\n  );\n}",
              "explanation": "Here, the ternary operator (`condition ? trueExpression : falseExpression`) is used for inline conditional rendering. It's concise and ideal when you need to switch between two different pieces of JSX directly within the return statement.",
              "language": "javascript"
            },
            {
              "id": "example_conditional_rendering_3",
              "title": "Conditional Rendering with Logical && Operator",
              "code": "import React from 'react';\n\nfunction AdminPanel() {\n  return (\n    <div style={{ border: '1px solid red', padding: '10px' }}>\n      <h3>Admin Controls</h3>\n      <button>Manage Users</button>\n      <button>View Reports</button>\n    </div>\n  );\n}\n\nfunction Dashboard({ userRole, isLoading }) {\n  return (\n    <div>\n      <h2>User Dashboard</h2>\n      {isLoading && <p>Loading dashboard data...</p>}\n      {userRole === 'admin' && <AdminPanel />}\n      <p>Your content goes here.</p>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates the logical `&&` operator. `isLoading && <p>Loading...</p>` will render the loading message only if `isLoading` is true. Similarly, `userRole === 'admin' && <AdminPanel />` will render the `AdminPanel` component only if `userRole` is exactly 'admin'. This is particularly useful when you want to render an element or component only when a condition is true, and render nothing otherwise.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_conditional_rendering_1",
            "question_conditional_rendering_2",
            "question_conditional_rendering_3",
            "question_conditional_rendering_4",
            "question_conditional_rendering_5",
            "question_conditional_rendering_6"
          ],
          "relatedTasks": [
            "task_build_auth_ui"
          ],
          "tags": [
            "React",
            "Conditional Rendering",
            "JSX",
            "JavaScript",
            "UI/UX",
            "Control Flow"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript_basics",
            "React_components",
            "JSX"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "beginner",
          "requiredFor": [
            "Dynamic_UI",
            "Form_Validation"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_hooks_1",
          "topic": "React useState Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `useState` hook in React?",
          "answer": "`useState` allows functional components to manage and update local state.",
          "options": [],
          "analysisPoints": [
            "Identifies `useState` with state management.",
            "Connects `useState` specifically to functional components."
          ],
          "keyConcepts": [
            "useState",
            "State Management",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Basic understanding of `useState` purpose"
          ],
          "example": "```javascript\nconst [count, setCount] = useState(0);\n```",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "State"
          ],
          "prerequisites": [
            "React_components"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_hooks_2",
          "topic": "React useEffect Hook",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `useEffect` hook. When will the effect inside it run?",
          "answer": "Only once after the initial render and before the component unmounts.",
          "options": [
            "After every render.",
            "Only once after the initial render and before the component unmounts.",
            "Only when the component mounts.",
            "Only when the component unmounts."
          ],
          "analysisPoints": [
            "Tests understanding of `useEffect` with an empty dependency array.",
            "Distinguishes between initial mount and subsequent renders.",
            "Recognizes the role of the cleanup function."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Lifecycle",
            "Cleanup Function"
          ],
          "evaluationCriteria": [
            "Correct interpretation of `useEffect` dependency array behavior",
            "Knowledge of `useEffect` cleanup"
          ],
          "example": "```javascript\nuseEffect(() => {\n  console.log('Component Mounted');\n  return () => {\n    console.log('Component Unmounted');\n  };\n}, []); // <-- Empty dependency array\n```\nThis specific setup for `useEffect` with an empty dependency array `([])` ensures that the effect function (the first argument) runs only once after the component's initial render. The cleanup function (the return value) then runs only when the component unmounts. This behavior makes it equivalent to `componentDidMount` and `componentWillUnmount` in class components.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Lifecycle"
          ],
          "prerequisites": [
            "React_components",
            "useEffect_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_3",
          "topic": "React useEffect Cleanup",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose of the `return () => { isMounted = false; };` statement within the `useEffect` hook in the `ProfilePage` example. Why is this pattern used?",
          "answer": "The `return () => { isMounted = false; };` statement defines a cleanup function for the `useEffect` hook. This function is executed when the component unmounts or before the effect re-runs (if its dependencies change).\n\nIts purpose, in this specific data-fetching pattern, is to prevent 'memory leaks' or, more accurately, to prevent React from issuing warnings about state updates on unmounted components. When an asynchronous operation (like a `fetch` request) is initiated in `useEffect`, the component might unmount before the `fetch` request completes. If the `fetch` then resolves and tries to call `setUser` or `setError`, React will log a warning because you are trying to update state on a component that no longer exists in the DOM.\n\nThe `isMounted` flag pattern addresses this: `isMounted` is initially `true`. If the cleanup function runs (meaning the component unmounted or `userId` changed before the fetch finished), `isMounted` is set to `false`. Subsequent state updates within the `then` or `catch` blocks of the `fetch` promise will then check `if (isMounted)` and prevent the update if the component is no longer mounted, thus avoiding the warning.",
          "options": [],
          "analysisPoints": [
            "Defines the cleanup function's role.",
            "Explains the problem of updating state on unmounted components.",
            "Details how the `isMounted` flag solves this specific issue.",
            "Connects to memory leak prevention and warning avoidance."
          ],
          "keyConcepts": [
            "useEffect",
            "Cleanup Function",
            "Asynchronous Operations",
            "Memory Leaks",
            "State Management"
          ],
          "evaluationCriteria": [
            "Thorough explanation of `useEffect` cleanup",
            "Understanding of async pitfalls in React",
            "Ability to explain common patterns"
          ],
          "example": "```javascript\nuseEffect(() => {\n  let isMounted = true;\n  fetchData().then(() => {\n    if (isMounted) {\n      // Update state\n    }\n  });\n  return () => {\n    isMounted = false;\n  };\n}, []);\n```",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Cleanup",
            "Asynchronous",
            "Best Practices"
          ],
          "prerequisites": [
            "useEffect_basics",
            "Promises"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hooks_4",
          "topic": "React useMemo Hook",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary benefit of using the `useMemo` hook?",
          "answer": "`useMemo` memoizes a computed value, preventing its recalculation on every render unless its dependencies change, which improves performance for expensive calculations.",
          "options": [],
          "analysisPoints": [
            "Identifies `useMemo` with memoization.",
            "Highlights performance optimization.",
            "Mentions dependency-based recalculation."
          ],
          "keyConcepts": [
            "useMemo",
            "Memoization",
            "Performance Optimization",
            "Dependencies"
          ],
          "evaluationCriteria": [
            "Basic understanding of `useMemo` purpose"
          ],
          "example": "```javascript\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n```",
          "tags": [
            "React",
            "Hooks",
            "useMemo",
            "Performance"
          ],
          "prerequisites": [
            "React_functional_components"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_5",
          "topic": "React Hooks vs. Class Components",
          "level": "medium",
          "type": "open",
          "question": "How do `useState`, `useEffect`, and `useMemo` collectively provide similar functionalities to class component lifecycle methods like `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`, and `getDerivedStateFromProps`?",
          "answer": "1.  **`useState` vs. `this.state`/`this.setState`**: `useState` provides local state management for functional components, directly replacing the `this.state` and `this.setState` paradigm found in class components.\n2.  **`useEffect` vs. `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`**: `useEffect` is a versatile hook that consolidates the functionalities of these three class lifecycle methods:\n    *   **`componentDidMount`**: Achieved by `useEffect` with an empty dependency array (`[]`). The effect runs once after the initial render.\n    *   **`componentDidUpdate`**: Achieved by `useEffect` with a dependency array containing specific values (`[dep1, dep2]`). The effect runs when any of these dependencies change, mimicking `componentDidUpdate`'s behavior for specific prop/state changes.\n    *   **`componentWillUnmount`**: Achieved by the cleanup function returned by `useEffect`. This function runs when the component unmounts, or before the effect re-runs due to dependency changes, allowing for resource cleanup.\n3.  **`useMemo` vs. `getDerivedStateFromProps` (conceptual overlap)**: While `useMemo` doesn't directly replace `getDerivedStateFromProps` (which is for deriving state, not just values), `useMemo` provides a mechanism to efficiently compute derived values based on dependencies. `getDerivedStateFromProps` is a static method to derive state from props/state changes, running before render. `useMemo` runs during rendering and memoizes the result of a calculation based on its dependencies, preventing recalculations. It allows for similar performance benefits when complex calculations depend on props or state, serving as a more flexible and often safer alternative for deriving *computed data* rather than directly manipulating state based on props.",
          "options": [],
          "analysisPoints": [
            "Correctly maps each hook to its class component equivalent(s).",
            "Explains the role of the `useEffect` dependency array and cleanup function.",
            "Clarifies the conceptual similarity between `useMemo` and `getDerivedStateFromProps` regarding derived values/state, while noting their differences."
          ],
          "keyConcepts": [
            "React Hooks",
            "Class Components",
            "Lifecycle Methods",
            "useState",
            "useEffect",
            "useMemo",
            "Comparison"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of hook equivalences",
            "Ability to articulate differences and best practices"
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "Class Components",
            "Comparison",
            "Lifecycle"
          ],
          "prerequisites": [
            "React_hooks_basics",
            "React_class_components_lifecycle"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hooks_6",
          "topic": "React useEffect Dependencies",
          "level": "hard",
          "type": "code",
          "question": "Given the `ProfilePage` component, what would happen if `userId` was omitted from the `useEffect` dependency array? Describe the implications and how it would affect data fetching.",
          "answer": null,
          "options": [],
          "analysisPoints": [
            "Understands the consequence of omitting a dependency.",
            "Explains that the effect would only run once on mount.",
            "Identifies that data would not update when `userId` changes.",
            "Connects this to stale closures and potential bugs."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Stale Closures",
            "Data Fetching",
            "Bugs"
          ],
          "evaluationCriteria": [
            "Ability to identify and explain `useEffect` dependency issues",
            "Predicting behavior changes due to incorrect dependencies"
          ],
          "example": "```javascript\nimport React, { useState, useEffect } from 'react';\n\nfunction ProfilePageNoDep({ userId }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    // Problematic: userId is not in dependencies, so this effect will only run ONCE on mount.\n    // If userId changes later, the effect (and fetch) will NOT re-run.\n    setLoading(true);\n    fetch(`/api/users/${userId}`) // This userId is captured from the initial render\n      .then(response => response.json())\n      .then(data => {\n        setUser(data);\n        setLoading(false);\n      })\n      .catch(err => {\n        console.error(err);\n        setLoading(false);\n      });\n    \n    // Cleanup is still important but doesn't solve the stale dependency issue.\n    return () => {}; \n  }, []); // <-- userId is missing from here!\n  \n  if (loading) return <div>Loading...</div>;\n  return <div>User: {user ? user.name : 'N/A'}</div>;\n}\n\n// Implications:\n// If ProfilePageNoDep is used like: <ProfilePageNoDep userId=\"1\" />\n// And then later changes to: <ProfilePageNoDep userId=\"2\" />\n// The data fetch will *not* re-run, and the component will continue to display user 1's data.\n```\nIf `userId` were omitted from the `useEffect` dependency array (i.e., `[]` was used), the effect would only run once after the initial render of the `ProfilePageNoDep` component. This means that if the `userId` prop subsequently changes (e.g., the parent component passes a different `userId`), the `fetch` request inside `useEffect` would *not* be re-triggered. Consequently, the component would continue to display data for the *initial* `userId` it received, leading to stale and incorrect data being shown to the user. This is a classic 'stale closure' problem in Hooks, where the effect closes over the initial `userId` value and doesn't react to its changes.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Dependency Array",
            "Stale Closures",
            "Bugs",
            "Data Fetching"
          ],
          "prerequisites": [
            "useEffect_advanced"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_hooks_7",
          "topic": "React `useMemo` vs `useCallback`",
          "level": "hard",
          "type": "open",
          "question": "When would you use `useMemo` versus `useCallback`, and what problem do they both aim to solve in React?",
          "answer": "`useMemo` and `useCallback` are both memoization hooks that aim to solve performance problems related to unnecessary re-renders in React by preventing expensive computations or function re-creations.\n\n*   **`useMemo`**: This hook is used to memoize a *value*. It takes a function that computes a value and a dependency array. It will only re-compute the value when one of its dependencies changes. You should use `useMemo` when you have an expensive calculation that produces a specific value (e.g., filtering a large list, transforming data) and you want to avoid recalculating it on every render if the inputs (dependencies) haven't changed.\n\n    ```javascript\n    const memoizedValue = useMemo(() => calculateExpensiveValue(a, b), [a, b]);\n    ```\n\n*   **`useCallback`**: This hook is used to memoize a *function*. It takes a function definition and a dependency array. It returns a memoized version of the callback that only changes if one of the dependencies has changed. You should use `useCallback` primarily when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary re-renders (e.g., `React.memo` components or components using `shouldComponentUpdate`). Without `useCallback`, a new function instance would be created on every render, causing the child component to re-render even if its props haven't conceptually changed.\n\n    ```javascript\n    const memoizedCallback = useCallback(() => {\n      doSomething(a, b);\n    }, [a, b]);\n    ```\n\n**Common Problem Solved:** Both hooks address the issue of unnecessary re-renders of child components or re-execution of expensive operations. In React, components re-render whenever their state or props change. If a parent component re-renders, its child components also re-render by default. By memoizing values or functions, these hooks ensure that child components (especially those wrapped with `React.memo` or implementing `shouldComponentUpdate`) don't re-render if the props they receive (including functions) are referentially identical, thus optimizing the rendering performance of the application.",
          "options": [],
          "analysisPoints": [
            "Clearly defines the purpose of `useMemo` (memoize value) and `useCallback` (memoize function).",
            "Provides correct usage examples for both.",
            "Explains the core problem they both solve: unnecessary re-renders and expensive computations.",
            "Connects `useCallback` specifically to optimizing child components that rely on referential equality.",
            "Shows a strong understanding of React's rendering optimizations."
          ],
          "keyConcepts": [
            "useMemo",
            "useCallback",
            "Memoization",
            "Performance Optimization",
            "Referential Equality",
            "React.memo"
          ],
          "evaluationCriteria": [
            "Deep understanding of memoization hooks",
            "Ability to differentiate their use cases",
            "Knowledge of performance optimization in React"
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "Performance",
            "Optimization",
            "useMemo",
            "useCallback"
          ],
          "prerequisites": [
            "React_memoization",
            "React_functional_components"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hooks_8",
          "topic": "React Hooks",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a correct rule for using React Hooks?",
          "answer": "Hooks can be called inside loops, conditions, or nested functions.",
          "options": [
            "Hooks must be called at the top level of function components.",
            "Hooks must be called from React function components or custom Hooks.",
            "Hooks can be called inside loops, conditions, or nested functions.",
            "The number of Hook calls must be stable across renders."
          ],
          "analysisPoints": [
            "Tests knowledge of the 'Rules of Hooks'.",
            "Identifies the core constraint that Hooks cannot be conditionally called.",
            "Reinforces that Hook calls must be consistent across renders."
          ],
          "keyConcepts": [
            "React Hooks",
            "Rules of Hooks",
            "useState",
            "useEffect",
            "Ordering"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental Hook usage rules"
          ],
          "example": "The 'Rules of Hooks' state that Hooks must be called at the top level of your React function components â€“ this means you cannot call Hooks inside loops, conditions, or nested functions. This rule is crucial for React to correctly associate the state and effects with the component across multiple renders. If Hooks were called conditionally, React wouldn't be able to guarantee the order of Hook calls on subsequent renders, leading to inconsistencies and bugs. The other options are correct rules for using Hooks.",
          "tags": [
            "React",
            "Hooks",
            "Rules of Hooks"
          ],
          "prerequisites": [
            "React_hooks_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_9",
          "topic": "React Hooks",
          "level": "medium",
          "type": "code",
          "question": "Refactor the following class component into a functional component using `useState` and `useEffect` to manage the counter.",
          "answer": "```javascript\nimport React, { useState, useEffect } from 'react';\n\nfunction FunctionalCounter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Component mounted or count updated:', count);\n    return () => {\n      console.log('Cleanup for count:', count);\n    };\n  }, [count]); // Re-run effect when count changes\n\n  const increment = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "Correctly converts class state to `useState`.",
            "Uses `useEffect` to mimic `componentDidMount` and `componentDidUpdate`.",
            "Demonstrates proper dependency array usage.",
            "Shows understanding of functional state updates (`prevCount`)."
          ],
          "keyConcepts": [
            "useState",
            "useEffect",
            "Refactoring",
            "Class to Functional Components"
          ],
          "evaluationCriteria": [
            "Ability to refactor components",
            "Correct Hook implementation"
          ],
          "example": "```javascript\nimport React from 'react';\n\nclass ClassCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  componentDidMount() {\n    console.log('Component mounted:', this.state.count);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.count !== this.state.count) {\n      console.log('Component updated, count:', this.state.count);\n    }\n  }\n\n  increment = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n```",
          "tags": [
            "React",
            "Hooks",
            "Refactoring",
            "useState",
            "useEffect",
            "Class Components"
          ],
          "prerequisites": [
            "React_class_components",
            "React_hooks_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_10",
          "topic": "React useState",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is the correct way to initialize state using `useState`?",
          "answer": "const [data, setData] = useState({});",
          "options": [
            "const data = useState({});",
            "const [data] = useState({});",
            "const [data, setData] = useState({});",
            "const { data, setData } = useState({});"
          ],
          "analysisPoints": [
            "Tests knowledge of destructuring array returned by `useState`.",
            "Verifies correct variable naming convention for state and setter."
          ],
          "keyConcepts": [
            "useState",
            "State Initialization",
            "Array Destructuring"
          ],
          "evaluationCriteria": [
            "Correct syntax for `useState`"
          ],
          "example": "The `useState` hook returns an array containing two elements: the current state value and a function to update it. Array destructuring `[stateVariable, setStateVariable]` is the standard way to assign these values to variables.",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "Syntax"
          ],
          "prerequisites": [
            "React_functional_components"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_hooks_11",
          "topic": "React useEffect",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the behavior of `useEffect` if no dependency array is provided?",
          "answer": "If no dependency array is provided, the `useEffect` callback will run after every render of the component.",
          "options": [],
          "analysisPoints": [
            "Identifies 'runs after every render' as the default behavior.",
            "Implies comparison to `componentDidMount` and `componentDidUpdate`."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Lifecycle"
          ],
          "evaluationCriteria": [
            "Understanding of `useEffect` default behavior"
          ],
          "example": null,
          "tags": [
            "React",
            "Hooks",
            "useEffect"
          ],
          "prerequisites": [
            "useEffect_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_12",
          "topic": "React `useMemo`",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following component, which line would cause the `expensiveCalculation` to re-run?",
          "answer": "Changing the value of `propA` or `propB`.",
          "options": [
            "Any re-render of the `MyComponent` component, regardless of prop changes.",
            "Changing the value of `propC` (not used in calculation dependencies).",
            "Changing the value of `propA` or `propB`.",
            "Only when the component is initially mounted."
          ],
          "analysisPoints": [
            "Tests understanding of `useMemo`'s dependency array.",
            "Distinguishes between dependencies and other props.",
            "Connects dependency changes to re-computation."
          ],
          "keyConcepts": [
            "useMemo",
            "Memoization",
            "Dependencies",
            "Performance"
          ],
          "evaluationCriteria": [
            "Correctly identifies dependency triggering re-computation for `useMemo`"
          ],
          "example": "```javascript\nimport React, { useMemo } from 'react';\n\nfunction expensiveCalculation(a, b) {\n  console.log('Performing expensive calculation...');\n  return a * 2 + b * 3;\n}\n\nfunction MyComponent({ propA, propB, propC }) {\n  const result = useMemo(() => expensiveCalculation(propA, propB), [propA, propB]);\n\n  return (\n    <div>\n      <p>Result: {result}</p>\n      <p>Prop C: {propC}</p>\n    </div>\n  );\n}\n```\n`useMemo` will only re-run the `expensiveCalculation` function if any of the values in its dependency array `[propA, propB]` change. If `propC` changes, but `propA` and `propB` remain the same, `MyComponent` will re-render, but `expensiveCalculation` will not execute again. If no dependencies change, `useMemo` returns the previously memoized value.",
          "tags": [
            "React",
            "Hooks",
            "useMemo",
            "Performance",
            "Dependencies"
          ],
          "prerequisites": [
            "useMemo_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_legacy_lifecycle_1",
          "topic": "Deprecated Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Which React class component lifecycle method is called before mounting occurs and is now considered `UNSAFE_`?",
          "answer": "`UNSAFE_componentWillMount()`",
          "options": [],
          "analysisPoints": [
            "Recalls the specific deprecated method.",
            "Associates it with the 'before mounting' phase."
          ],
          "keyConcepts": [
            "Class Components",
            "Lifecycle Methods",
            "UNSAFE_componentWillMount",
            "Deprecated"
          ],
          "evaluationCriteria": [
            "Basic recall of deprecated methods"
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Deprecated"
          ],
          "prerequisites": [
            "React_class_components"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_legacy_lifecycle_2",
          "topic": "Deprecated Lifecycle Methods",
          "level": "medium",
          "type": "mcq",
          "question": "Which modern React feature is the recommended replacement for the functionality often misused in `UNSAFE_componentWillReceiveProps` for deriving state from props?",
          "answer": "`static getDerivedStateFromProps()`",
          "options": [
            "`componentDidMount()`",
            "`static getDerivedStateFromProps()`",
            "`useReducer()`",
            "`componentWillUnmount()`"
          ],
          "analysisPoints": [
            "Correctly identifies the static method for deriving state.",
            "Understands why `UNSAFE_componentWillReceiveProps` was problematic."
          ],
          "keyConcepts": [
            "Deprecated Lifecycle",
            "getDerivedStateFromProps",
            "State Derivation"
          ],
          "evaluationCriteria": [
            "Knowledge of modern alternatives to deprecated methods"
          ],
          "example": "The `static getDerivedStateFromProps` lifecycle method is specifically designed for cases where state depends on changes in props over time. It runs before every render, both on the initial mount and on subsequent updates. It returns an object to update the state, or `null` to indicate no state update. This method replaced the problematic `UNSAFE_componentWillReceiveProps` for deriving state, as it prevents common anti-patterns like setting state asynchronously based on props, which could lead to infinite loops or inconsistent state.",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Deprecated",
            "getDerivedStateFromProps"
          ],
          "prerequisites": [
            "React_class_components_lifecycle"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_legacy_lifecycle_3",
          "topic": "Deprecated Lifecycle Methods",
          "level": "hard",
          "type": "open",
          "question": "Why are lifecycle methods prefixed with `UNSAFE_` considered problematic in modern React, and what are the general risks associated with using them?",
          "answer": "Lifecycle methods prefixed with `UNSAFE_` (`UNSAFE_componentWillMount`, `UNSAFE_componentWillReceiveProps`, `UNSAFE_componentWillUpdate`) are problematic because they were often misused in ways that led to bugs and made future React features (like Async Rendering and Concurrent Mode) difficult to implement.\n\n**Reasons for deprecation and risks:**\n\n1.  **Race Conditions and Inconsistent State**: These methods execute before `render`. In a future asynchronous rendering environment (Concurrent Mode), React might pause, abort, or restart renders. If side effects (like data fetching or setting state) are performed in these `UNSAFE_` methods, they might run multiple times or at unexpected times, leading to inconsistent UI states, memory leaks, or race conditions if not handled extremely carefully.\n2.  **Blocking Rendering**: Performing expensive operations or data fetching in `UNSAFE_componentWillMount` can block the initial render of the component, leading to a poorer user experience (blank screen).\n3.  **Misuse for Side Effects**: Developers often placed side effects (subscriptions, data fetches, DOM manipulations) in `componentWillMount` or `componentWillUpdate` that should have occurred *after* rendering. This led to issues because the DOM might not yet be available or fully updated when these methods ran.\n4.  **Deriving State Issues**: `UNSAFE_componentWillReceiveProps` was frequently misused to derive state from props. This pattern often led to infinite loops if `setState` was called unconditionally, or subtle bugs due to state not being reset correctly when props changed. `getDerivedStateFromProps` was introduced to safely handle this specific use case.\n\nIn essence, these methods encouraged patterns that were incompatible with React's evolving rendering model, where rendering is not guaranteed to be synchronous and might be interrupted. Their deprecation nudges developers towards safer patterns (like using `componentDidMount`/`Update` or `useEffect` for side effects, and `getDerivedStateFromProps` for state derivation) that align with the core principles of React's reconciliation process.",
          "options": [],
          "analysisPoints": [
            "Explains the core problem (incompatibility with async React).",
            "Lists specific risks like race conditions, inconsistent state, blocking render.",
            "Connects misuse of side effects/state derivation to the deprecation.",
            "Demonstrates understanding of React's rendering model evolution."
          ],
          "keyConcepts": [
            "Deprecated Lifecycle",
            "UNSAFE_",
            "Async React",
            "Concurrent Mode",
            "Side Effects",
            "State Management",
            "Performance"
          ],
          "evaluationCriteria": [
            "Deep understanding of deprecation rationale",
            "Ability to articulate potential pitfalls"
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Deprecated",
            "Interview Question"
          ],
          "prerequisites": [
            "React_class_components_lifecycle_advanced"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_legacy_lifecycle_4",
          "topic": "Deprecated Lifecycle Methods",
          "level": "medium",
          "type": "code",
          "question": "Provide a class component snippet that uses a deprecated lifecycle method and briefly explain why it's problematic.",
          "answer": "```javascript\nimport React from 'react';\n\nclass DataFetcherComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null, loading: true };\n  }\n\n  // Problematic: This method is called before the component is mounted to the DOM.\n  // If data fetching is performed here, it blocks the initial render.\n  // In React's future concurrent mode, this method might also run multiple times \n  // or be interrupted, leading to inconsistent state or unexpected behavior.\n  // Side effects like data fetching should ideally happen after mounting (in componentDidMount or useEffect).\n  UNSAFE_componentWillMount() {\n    console.log('UNSAFE_componentWillMount: Fetching data...');\n    fetch('/api/some-data')\n      .then(response => response.json())\n      .then(data => this.setState({ data, loading: false }))\n      .catch(error => {\n        console.error('Fetch error:', error);\n        this.setState({ loading: false });\n      });\n  }\n\n  render() {\n    if (this.state.loading) {\n      return <div>Loading data...</div>;\n    }\n    if (!this.state.data) {\n      return <div>No data found.</div>;\n    }\n    return <div>Data: {JSON.stringify(this.state.data)}</div>;\n  }\n}\n```\n\n**Why it's problematic:** Using `UNSAFE_componentWillMount` for data fetching is problematic because it runs *before* the component is actually mounted to the DOM. This means if the data fetch takes time, it will block the initial render of the component, leading to a blank screen or a perceived delay for the user. Furthermore, in future React concurrent rendering modes, this method could be invoked multiple times or asynchronously, making side effects like data fetching unpredictable and prone to race conditions. The recommended approach for data fetching in class components is `componentDidMount` (or `useEffect` in functional components) because it ensures the DOM is ready and the side effect runs only once after the component is fully mounted.",
          "options": [],
          "analysisPoints": [
            "Provides a valid code snippet using an `UNSAFE_` method.",
            "Clearly explains the specific problem caused by using that method (e.g., blocking render for `UNSAFE_componentWillMount`).",
            "Mentions the implications for future React features.",
            "Suggests the correct alternative."
          ],
          "keyConcepts": [
            "Deprecated Lifecycle",
            "UNSAFE_componentWillMount",
            "Data Fetching",
            "Performance",
            "Race Conditions"
          ],
          "evaluationCriteria": [
            "Ability to identify and explain a specific problem with deprecated methods in code"
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Deprecated",
            "Code Example"
          ],
          "prerequisites": [
            "React_class_components",
            "Lifecycle_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_legacy_lifecycle_5",
          "topic": "Deprecated Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "Which `UNSAFE_` lifecycle method is called when new props are received, and what is its recommended replacement for side effects?",
          "answer": "`UNSAFE_componentWillReceiveProps`. For side effects reacting to prop changes, the recommended replacement is `componentDidUpdate` (or `useEffect` in functional components).",
          "options": [],
          "analysisPoints": [
            "Identifies `UNSAFE_componentWillReceiveProps`.",
            "Provides the correct replacement for side effects."
          ],
          "keyConcepts": [
            "UNSAFE_componentWillReceiveProps",
            "componentDidUpdate",
            "Side Effects",
            "Deprecated"
          ],
          "evaluationCriteria": [
            "Recall of deprecated method and its side-effect replacement"
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Deprecated"
          ],
          "prerequisites": [
            "React_class_components"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_legacy_lifecycle_6",
          "topic": "Deprecated Lifecycle Methods",
          "level": "medium",
          "type": "open",
          "question": "In the context of class components, what is `getSnapshotBeforeUpdate` used for, and why was it introduced as a safer alternative compared to `UNSAFE_componentWillUpdate` for certain use cases?",
          "answer": "`getSnapshotBeforeUpdate(prevProps, prevState)` is a lifecycle method in React class components that is invoked right before the most recently rendered output is committed to the DOM. It enables your component to capture some information from the DOM (e.g., scroll position) *before* it is potentially changed by the upcoming update. The value returned by `getSnapshotBeforeUpdate` is then passed as a third parameter to `componentDidUpdate(prevProps, prevState, snapshot)`.\n\nIt was introduced as a safer alternative to `UNSAFE_componentWillUpdate` for situations where you need to read information from the DOM *before* an update. `UNSAFE_componentWillUpdate` was problematic because it ran before `render`, and in a future async React, `render` might be interrupted or re-run multiple times, making it unreliable to perform DOM-related operations. `getSnapshotBeforeUpdate` guarantees that you can read the DOM state synchronously *just before* the changes are painted, ensuring that you get a consistent snapshot of the DOM's state at that precise moment, avoiding potential race conditions or inconsistencies that could arise with `UNSAFE_componentWillUpdate` in concurrent scenarios.",
          "options": [],
          "analysisPoints": [
            "Clearly defines `getSnapshotBeforeUpdate`'s purpose (capture DOM info before update).",
            "Explains its position in the lifecycle and how its return value is used.",
            "Highlights the safety aspect compared to `UNSAFE_componentWillUpdate`.",
            "Connects to the consistency needed for DOM operations in async React."
          ],
          "keyConcepts": [
            "getSnapshotBeforeUpdate",
            "UNSAFE_componentWillUpdate",
            "DOM Manipulation",
            "Lifecycle",
            "Asynchronous React"
          ],
          "evaluationCriteria": [
            "Thorough explanation of `getSnapshotBeforeUpdate`",
            "Understanding of its relation to deprecated methods and async rendering"
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "getSnapshotBeforeUpdate",
            "Deprecated"
          ],
          "prerequisites": [
            "React_class_components_lifecycle_advanced"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_legacy_lifecycle_7",
          "topic": "Legacy Lifecycle Methods",
          "level": "medium",
          "type": "mcq",
          "question": "Which pair correctly matches a deprecated lifecycle method with its primary replacement in functional components using Hooks?",
          "answer": "`UNSAFE_componentWillMount` -> `useEffect` with an empty dependency array (`[]`)",
          "options": [
            "`UNSAFE_componentWillReceiveProps` -> `useMemo`",
            "`UNSAFE_componentWillMount` -> `useEffect` with an empty dependency array (`[]`)",
            "`UNSAFE_componentWillUpdate` -> `useCallback`",
            "`componentWillUnmount` -> `useState`"
          ],
          "analysisPoints": [
            "Correctly identifies the direct Hook equivalent for `UNSAFE_componentWillMount` for initial setup.",
            "Recognizes that other options are incorrect or misaligned replacements."
          ],
          "keyConcepts": [
            "Deprecated Lifecycle",
            "Hooks Equivalents",
            "useEffect",
            "useState",
            "useMemo",
            "useCallback"
          ],
          "evaluationCriteria": [
            "Accurate mapping of deprecated methods to Hook patterns"
          ],
          "example": "`UNSAFE_componentWillMount` was typically used for initial setup or data fetching before the first render. In functional components, this behavior is best replicated using `useEffect` with an empty dependency array (`[]`), which ensures the effect runs only once after the initial render, similar to `componentDidMount`. While `componentWillUnmount` is replaced by the cleanup function in `useEffect`, `useState` is for state, `useMemo` for memoized values, and `useCallback` for memoized functions, none of which directly replace the broad functionality of the deprecated 'will mount' method.",
          "tags": [
            "React",
            "Hooks",
            "Class Components",
            "Lifecycle",
            "Comparison"
          ],
          "prerequisites": [
            "React_class_components_lifecycle",
            "React_hooks_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_legacy_lifecycle_8",
          "topic": "Deprecated Lifecycle Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "What common prefix is added to deprecated React class lifecycle methods to indicate they are unsafe?",
          "answer": "`UNSAFE_`",
          "options": [],
          "analysisPoints": [
            "Recalls the specific prefix used for deprecated methods."
          ],
          "keyConcepts": [
            "Deprecated Lifecycle",
            "UNSAFE_"
          ],
          "evaluationCriteria": [
            "Basic knowledge of React deprecation conventions"
          ],
          "example": null,
          "tags": [
            "React",
            "Class Components",
            "Lifecycle",
            "Deprecated"
          ],
          "prerequisites": [
            "React_class_components"
          ],
          "complexity": 2,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_conditional_rendering_1",
          "topic": "Conditional Rendering",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of conditional rendering in React?",
          "answer": "To render different UI elements or components based on certain conditions or application state.",
          "options": [],
          "analysisPoints": [
            "Defines conditional rendering with 'different UI' and 'conditions'."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "UI",
            "State"
          ],
          "evaluationCriteria": [
            "Basic understanding of conditional rendering concept"
          ],
          "example": null,
          "tags": [
            "React",
            "Conditional Rendering",
            "UI"
          ],
          "prerequisites": [
            "React_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_conditional_rendering_2",
          "topic": "Conditional Rendering",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following JSX snippets correctly uses the logical `&&` operator for conditional rendering?",
          "answer": "{isLoggedIn && <WelcomeMessage />}",
          "options": [
            "{isLoggedIn ? <WelcomeMessage />}",
            "{isLoggedIn && <WelcomeMessage />}",
            "{<WelcomeMessage /> if isLoggedIn}",
            "{if (isLoggedIn) { <WelcomeMessage /> }}"
          ],
          "analysisPoints": [
            "Identifies correct syntax for logical `&&` in JSX.",
            "Distinguishes from incorrect or non-JSX valid syntax."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "Logical && Operator",
            "JSX Syntax"
          ],
          "evaluationCriteria": [
            "Correct application of `&&` for conditional rendering"
          ],
          "example": "The logical `&&` operator works well when you want to render *something* only when a condition is `true`, and *nothing* otherwise. If `isLoggedIn` is `true`, `WelcomeMessage` will be rendered. If `isLoggedIn` is `false` (or `null`, `undefined`, `0`, `''`), React will render nothing because `false` (or the other falsy values) are valid renderable values in JSX that result in no output. The other options are either incorrect syntax for JSX or not the `&&` operator.",
          "tags": [
            "React",
            "Conditional Rendering",
            "JSX"
          ],
          "prerequisites": [
            "React_basics",
            "JavaScript_operators"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_conditional_rendering_3",
          "topic": "Conditional Rendering",
          "level": "medium",
          "type": "code",
          "question": "Implement a `Notification` component that conditionally renders a message based on two props: `hasNotifications` (boolean) and `message` (string). If `hasNotifications` is true, display the `message` inside a `div`. Otherwise, display 'No new notifications.' Use both an `if` statement and a ternary operator in two separate examples.",
          "answer": "```javascript\nimport React from 'react';\n\n// Using if statement\nfunction NotificationIf({ hasNotifications, message }) {\n  if (hasNotifications) {\n    return <div style={{ color: 'blue' }}>{message}</div>;\n  }\n  return <div>No new notifications.</div>;\n}\n\n// Using ternary operator\nfunction NotificationTernary({ hasNotifications, message }) {\n  return (\n    <div>\n      {hasNotifications \n        ? <div style={{ color: 'green' }}>{message}</div> \n        : <div>No new notifications.</div>\n      }\n    </div>\n  );\n}\n\n// Example Usage:\n// <NotificationIf hasNotifications={true} message=\"You have 3 unread emails!\" />\n// <NotificationTernary hasNotifications={false} message=\"\" />\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `if` statement for conditional return.",
            "Correctly uses ternary operator for inline conditional rendering.",
            "Handles both true and false conditions."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "If Statement",
            "Ternary Operator",
            "JSX"
          ],
          "evaluationCriteria": [
            "Ability to implement conditional logic using different syntax"
          ],
          "example": null,
          "tags": [
            "React",
            "Conditional Rendering",
            "Code Example"
          ],
          "prerequisites": [
            "React_components",
            "JavaScript_control_flow"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_conditional_rendering_4",
          "topic": "Conditional Rendering",
          "level": "easy",
          "type": "flashcard",
          "question": "When is it generally preferred to use an `if` statement over a ternary operator for conditional rendering in React?",
          "answer": "An `if` statement is generally preferred when the conditional logic is complex, involves multiple distinct rendering paths, or when you need to return null (or nothing) for one of the conditions. It improves readability for more elaborate logic compared to a nested ternary.",
          "options": [],
          "analysisPoints": [
            "Connects `if` to complexity and multiple paths.",
            "Emphasizes readability."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "If Statement",
            "Readability"
          ],
          "evaluationCriteria": [
            "Understanding of best practices for choosing conditional rendering methods"
          ],
          "example": null,
          "tags": [
            "React",
            "Conditional Rendering",
            "Best Practices"
          ],
          "prerequisites": [
            "Conditional_rendering_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_conditional_rendering_5",
          "topic": "Conditional Rendering",
          "level": "medium",
          "type": "open",
          "question": "Describe a scenario where using the logical `&&` operator for conditional rendering would be more concise or appropriate than a ternary operator or an `if` statement.",
          "answer": "The logical `&&` operator (`condition && expression`) is most appropriate and concise when you want to render an element *only if a condition is true*, and render *nothing* otherwise. It is particularly useful for small, inline conditions where there is no alternative UI to display when the condition is false.\n\n**Scenario:** Displaying a loading spinner only when data is being fetched, or showing an 'unread messages' badge only when there are unread messages.\n\nExample:\n```javascript\nfunction UserDashboard({ isLoading, unreadMessagesCount }) {\n  return (\n    <div>\n      <h2>Dashboard</h2>\n      {isLoading && <p>Loading data...</p>} {/* Only render loading message if isLoading is true */}\n      {unreadMessagesCount > 0 && \n        <span>You have {unreadMessagesCount} unread messages!</span> /* Only render if count > 0 */\n      }\n      <p>Welcome back!</p>\n    </div>\n  );\n}\n```\nIn this scenario, if `isLoading` is false, or `unreadMessagesCount` is 0, we don't want to render any alternative UI; we just want those elements to disappear. Using `&&` is cleaner than `isLoading ? <p>Loading...</p> : null` or an `if` statement for each small, optional element.",
          "options": [],
          "analysisPoints": [
            "Identifies the specific use case: render only if true, nothing otherwise.",
            "Provides a clear, practical scenario (e.g., loading spinners, badges).",
            "Demonstrates understanding of conciseness compared to alternatives."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "Logical && Operator",
            "Conciseness",
            "UI/UX"
          ],
          "evaluationCriteria": [
            "Ability to identify appropriate use cases for specific techniques",
            "Explaining benefits of chosen method"
          ],
          "example": null,
          "tags": [
            "React",
            "Conditional Rendering",
            "Logical &&",
            "Best Practices"
          ],
          "prerequisites": [
            "Conditional_rendering_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_conditional_rendering_6",
          "topic": "Conditional Rendering",
          "level": "hard",
          "type": "code",
          "question": "Create a `UserProfile` component that displays user information. It should handle three states:\n1.  **Loading**: Show 'Loading user data...' if `isLoading` is true.\n2.  **Error**: Show 'Error: [error message]' if `error` is present.\n3.  **Data Loaded**: Show user's name and email if `user` data is available.\n\nUse a combination of conditional rendering techniques (`if` statements, ternary, `&&` operator) as appropriate for each state, ensuring a clear priority (error > loading > data).",
          "answer": "```javascript\nimport React from 'react';\n\nfunction UserProfile({ user, isLoading, error }) {\n  // 1. Prioritize error state using an if statement for early exit\n  if (error) {\n    return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n  }\n\n  // 2. Prioritize loading state using an if statement for early exit\n  if (isLoading) {\n    return <div>Loading user data...</div>;\n  }\n\n  // 3. Render user data if available, using ternary for concise display or && for optional parts\n  // Using ternary for whether user exists, and && for optional email\n  return (\n    <div>\n      {user ? (\n        <>\n          <h2>Name: {user.firstName} {user.lastName}</h2>\n          {user.email && <p>Email: {user.email}</p>}\n          {/* Example of optional profile image */}\n          {user.profilePicUrl && <img src={user.profilePicUrl} alt=\"Profile\" style={{width: '100px', height: '100px'}} />}\n        </>\n      ) : (\n        <div>No user data available.</div> // Fallback if user is null/undefined after loading/error check\n      )}\n    </div>\n  );\n}\n\n/* Example Usage:\n<UserProfile user={null} isLoading={true} error={null} /> // Shows Loading\n<UserProfile user={null} isLoading={false} error={{ message: 'User not found' }} /> // Shows Error\n<UserProfile user={{ firstName: 'John', lastName: 'Doe', email: 'john@example.com' }} isLoading={false} error={null} /> // Shows User data\n<UserProfile user={{ firstName: 'Jane', lastName: 'Smith' }} isLoading={false} error={null} /> // Shows User data without email\n*/\n```",
          "options": [],
          "analysisPoints": [
            "Correctly handles multiple, prioritized states (error, loading, data).",
            "Effectively uses `if` statements for early exits for primary states.",
            "Utilizes ternary operator for `user` existence or fallback.",
            "Applies logical `&&` for optional data fields (e.g., email, profilePicUrl).",
            "Demonstrates a comprehensive understanding of combining conditional rendering techniques."
          ],
          "keyConcepts": [
            "Conditional Rendering",
            "If Statement",
            "Ternary Operator",
            "Logical && Operator",
            "State Management",
            "UI Priority"
          ],
          "evaluationCriteria": [
            "Ability to combine multiple conditional rendering techniques effectively",
            "Handling priority in UI states",
            "Clean and readable code"
          ],
          "example": null,
          "tags": [
            "React",
            "Conditional Rendering",
            "Complex UI",
            "State Management",
            "Best Practices"
          ],
          "prerequisites": [
            "Conditional_rendering_basics",
            "React_components"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_data_fetching_component",
          "title": "Implement a Data Fetching User List Component",
          "description": "\nCreate a React functional component named `UserList` that fetches a list of users from a mock API endpoint (`/api/users`). The component should:\n\n1.  **Manage State**: Use `useState` for `users` (an array), `loading` (boolean), and `error` (object/string).\n2.  **Fetch Data**: Use `useEffect` to perform the data fetch when the component mounts. The `useEffect` should have an empty dependency array.\n3.  **Error Handling**: If the fetch fails, set the `error` state and display an error message.\n4.  **Loading State**: Display a 'Loading users...' message while fetching.\n5.  **Display Data**: Once data is successfully fetched, render a list (e.g., `<ul>`) of user names. If no users are found, display 'No users available.'\n6.  **Cleanup**: Implement a cleanup function in `useEffect` to prevent state updates on unmounted components (e.g., using an `isMounted` flag). Mimic the `ProfilePage` example's `useEffect` behavior for cleanup.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// Assume a mock fetch function for testing\nconst mockFetchUsers = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const success = Math.random() > 0.3; // 70% chance of success\n      if (success) {\n        resolve([\n          { id: 1, name: 'Alice' },\n          { id: 2, name: 'Bob' },\n          { id: 3, name: 'Charlie' }\n        ]);\n      } else {\n        reject(new Error('Failed to fetch users.'));\n      }\n    }, 1000);\n  });\n};\n\nfunction UserList() {\n  // TODO: Implement state variables for users, loading, and error\n\n  // TODO: Implement useEffect for data fetching with cleanup\n\n  // TODO: Implement conditional rendering for loading, error, and data display\n\n  return (\n    <div>\n      {/* Your rendering logic here */}\n    </div>\n  );\n}\n\nexport default UserList;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nconst mockFetchUsers = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const success = Math.random() > 0.3; \n      if (success) {\n        // To test 'No users available' case, uncomment the empty array occasionally\n        resolve([\n          { id: 1, name: 'Alice' },\n          { id: 2, name: 'Bob' },\n          { id: 3, name: 'Charlie' }\n        ]);\n        // resolve([]); // Uncomment to test no users found\n      } else {\n        reject(new Error('Network request failed. Please try again.'));\n      }\n    }, 1000);\n  });\n};\n\nfunction UserList() {\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let isMounted = true; // Flag to track mount status\n    setLoading(true);    // Set loading true before fetch\n    setError(null);      // Clear any previous errors\n\n    mockFetchUsers()\n      .then(data => {\n        if (isMounted) {\n          setUsers(data);\n          setLoading(false);\n        }\n      })\n      .catch(err => {\n        if (isMounted) {\n          setError(err);\n          setLoading(false);\n        }\n      });\n\n    return () => {\n      isMounted = false; // Cleanup: set flag to false when component unmounts\n    };\n  }, []); // Empty dependency array means this effect runs once on mount\n\n  if (loading) {\n    return <div>Loading users...</div>;\n  }\n\n  if (error) {\n    return <div style={{ color: 'red' }}>Error: {error.message}</div>;\n  }\n\n  if (users.length === 0) {\n    return <div>No users available.</div>;\n  }\n\n  return (\n    <div>\n      <h2>User List</h2>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>{user.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default UserList;\n",
          "testCases": [
            "Component should display 'Loading users...' initially.",
            "On successful fetch, component should display a list of user names.",
            "On failed fetch, component should display an error message.",
            "If `mockFetchUsers` resolves with an empty array, 'No users available.' should be displayed.",
            "Simulate unmounting the component before fetch completes; verify no console warnings about state updates."
          ],
          "hints": [
            "Remember to use `useState` for each piece of state (users, loading, error).",
            "The `useEffect` hook with an empty dependency array `[]` is crucial for 'run once on mount' behavior.",
            "Don't forget the cleanup function in `useEffect` to handle potential unmounted component issues during asynchronous operations.",
            "Consider the order of your conditional `if` statements for displaying loading, error, or data messages."
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "useEffect",
            "Data Fetching",
            "Error Handling",
            "Loading States",
            "Conditional Rendering"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React_functional_components",
            "Promises",
            "useEffect_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Side Effects",
            "Asynchronous JavaScript",
            "Component Lifecycle"
          ]
        },
        {
          "id": "task_memoized_calculation",
          "title": "Build a Shopping Cart Item Component with Memoized Price Calculation",
          "description": "\nCreate a `CartItem` React functional component that displays details of a product in a shopping cart. The component should:\n\n1.  Accept `item` (an object with `name`, `price`, `quantity`) and `discountPercentage` as props.\n2.  Use `useState` for the `quantity` (making it editable) and a button to increase/decrease it.\n3.  Calculate the `totalPrice` for the item (price * quantity * (1 - discountPercentage)). This calculation can be expensive in a real-world scenario.\n4.  **Optimize Calculation**: Use `useMemo` to memoize the `totalPrice` calculation. Ensure it only re-calculates when `price`, `quantity`, or `discountPercentage` change, but not on other renders (e.g., parent re-renders).\n5.  Display the item's name, individual price, current quantity, discount, and the memoized total price.\n6.  Include a console log inside the `useMemo` calculation to prove when it re-runs.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useMemo } from 'react';\n\nfunction CartItem({ item, discountPercentage }) {\n  // item: { name: string, price: number, quantity: number (initial) }\n  // discountPercentage: number (e.g., 0.1 for 10%)\n\n  // TODO: Manage quantity state with useState\n\n  // TODO: Use useMemo for total price calculation\n\n  // TODO: Implement increase/decrease quantity buttons\n\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '15px', margin: '10px', borderRadius: '5px' }}>\n      {/* Your rendering logic here */}\n    </div>\n  );\n}\n\nexport default CartItem;\n\n// Example Usage (in a parent component):\n// <CartItem item={{ name: 'Laptop', price: 1200, quantity: 1 }} discountPercentage={0.05} />\n// <CartItem item={{ name: 'Mouse', price: 25, quantity: 2 }} discountPercentage={0.10} />\n",
          "solutionCode": "import React, { useState, useMemo } from 'react';\n\nfunction CartItem({ item, discountPercentage }) {\n  const [quantity, setQuantity] = useState(item.quantity);\n\n  // Use useMemo to memoize the totalPrice calculation\n  const totalPrice = useMemo(() => {\n    console.log(`Calculating total price for ${item.name}...`);\n    return item.price * quantity * (1 - discountPercentage);\n  }, [item.price, quantity, discountPercentage]); // Dependencies\n\n  const increaseQuantity = () => {\n    setQuantity(prevQuantity => prevQuantity + 1);\n  };\n\n  const decreaseQuantity = () => {\n    setQuantity(prevQuantity => Math.max(1, prevQuantity - 1)); // Ensure quantity doesn't go below 1\n  };\n\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '15px', margin: '10px', borderRadius: '5px' }}>\n      <h3>{item.name}</h3>\n      <p>Price per unit: ${item.price.toFixed(2)}</p>\n      <p>Quantity:\n        <button onClick={decreaseQuantity} disabled={quantity === 1}>-</button>\n        {' '}{quantity}{' '}\n        <button onClick={increaseQuantity}>+</button>\n      </p>\n      <p>Discount: {(discountPercentage * 100).toFixed(0)}%</p>\n      <p><strong>Total: ${totalPrice.toFixed(2)}</strong></p>\n      <small>Check console for 'Calculating total price...' log to see memoization in action.</small>\n    </div>\n  );\n}\n\nexport default CartItem;\n",
          "testCases": [
            "Initial render: 'Calculating total price...' should appear in console.",
            "Clicking 'Increase Quantity': 'Calculating total price...' should appear in console, total price should update.",
            "Clicking 'Decrease Quantity': 'Calculating total price...' should appear in console, total price should update (quantity >= 1).",
            "If a parent component re-renders `CartItem` without changing `item.price`, `quantity` (internal state), or `discountPercentage`, 'Calculating total price...' should *not* appear in console.",
            "Verify `totalPrice` calculation is correct with different quantities and discounts."
          ],
          "hints": [
            "The `useMemo` hook takes a function as its first argument and a dependency array as its second.",
            "The console log should be placed *inside* the function passed to `useMemo`.",
            "Remember that `useState`'s setter function can accept a callback to update state based on the previous state (`setQuantity(prev => prev + 1)`)."
          ],
          "tags": [
            "React",
            "Hooks",
            "useMemo",
            "useState",
            "Performance Optimization",
            "Memoization",
            "Shopping Cart"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React_functional_components",
            "useMemo_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component Optimization",
            "Derived State",
            "Referential Equality"
          ]
        },
        {
          "id": "task_refactor_legacy_component",
          "title": "Refactor a Class-Based Counter with Lifecycle Logging to Functional Component with Hooks",
          "description": "\nRefactor the provided `LegacyCounter` class component into a `FunctionalCounter` component using React Hooks. The new component should:\n\n1.  **State Management**: Use `useState` to manage the `count`.\n2.  **Lifecycle Logging**: Use `useEffect` to replicate the console logging behavior of `componentDidMount` and `componentDidUpdate` (i.e., log when the component mounts and when the count changes). Include a cleanup log resembling `componentWillUnmount`.\n3.  **Increment/Decrement**: Provide buttons to increment and decrement the count.\n4.  Ensure the component behaves identically in terms of functionality and logging.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// Original Class Component for reference:\n/*\nclass LegacyCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  componentDidMount() {\n    console.log('Class: Component mounted, count:', this.state.count);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.count !== this.state.count) {\n      console.log('Class: Component updated, count:', this.state.count);\n    }\n  }\n\n  componentWillUnmount() {\n    console.log('Class: Component unmounting, count:', this.state.count);\n  }\n\n  increment = () => {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  };\n\n  decrement = () => {\n    this.setState(prevState => ({ count: Math.max(0, prevState.count - 1) }));\n  };\n\n  render() {\n    return (\n      <div>\n        <h2>Legacy Counter</h2>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n        <button onClick={this.decrement}>Decrement</button>\n      </div>\n    );\n  }\n}\n*/\n\nfunction FunctionalCounter() {\n  // TODO: Implement state and lifecycle logging with hooks\n\n  return (\n    <div>\n      <h2>Functional Counter</h2>\n      {/* Your rendering logic here */}\n    </div>\n  );\n}\n\nexport default FunctionalCounter;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction FunctionalCounter() {\n  const [count, setCount] = useState(0);\n\n  // Effect for componentDidMount and componentDidUpdate logic\n  useEffect(() => {\n    if (count === 0) {\n      console.log('Functional: Component mounted, count:', count);\n    } else {\n      console.log('Functional: Component updated, count:', count);\n    }\n\n    // Cleanup function for componentWillUnmount\n    return () => {\n      console.log('Functional: Component unmounting, count (at unmount):', count);\n    };\n  }, [count]); // Re-run effect when count changes\n\n  const increment = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  const decrement = () => {\n    setCount(prevCount => Math.max(0, prevCount - 1));\n  };\n\n  return (\n    <div>\n      <h2>Functional Counter</h2>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n    </div>\n  );\n}\n\nexport default FunctionalCounter;\n",
          "testCases": [
            "On initial render, 'Functional: Component mounted, count: 0' should appear in the console.",
            "Clicking 'Increment' button: count should increase, and 'Functional: Component updated, count: [new count]' should appear in the console.",
            "Clicking 'Decrement' button: count should decrease (not below 0), and 'Functional: Component updated, count: [new count]' should appear in the console.",
            "Unmounting the component (e.g., navigating away or conditionally hiding it) should trigger 'Functional: Component unmounting, count (at unmount): [final count]' in the console."
          ],
          "hints": [
            "A single `useEffect` can handle both mount and update logic by checking dependencies.",
            "The `return` function inside `useEffect` is for cleanup (unmount logic).",
            "The `count` state variable should be included in the `useEffect`'s dependency array to trigger updates.",
            "For the initial mount log, you might check if `count` is `0` or use a `useRef` to track first render, though `count` in the dependency array often suffices for this simple case."
          ],
          "tags": [
            "React",
            "Hooks",
            "Refactoring",
            "useState",
            "useEffect",
            "Class Components",
            "Lifecycle",
            "Migration"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React_class_components_lifecycle",
            "React_hooks_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component Architecture",
            "State Management",
            "Side Effects"
          ]
        },
        {
          "id": "task_build_auth_ui",
          "title": "Build a User Authentication UI with Conditional Rendering",
          "description": "\nCreate a React functional component named `AuthStatus` that displays different UI elements based on a user's authentication status and role.\n\n1.  **State Management**: Use `useState` for `isLoggedIn` (boolean, default `false`), `userRole` (string, default 'guest'), and `showAdminPanel` (boolean, default `false`).\n2.  **Login/Logout**: Add buttons to toggle `isLoggedIn`. When logging in, set `userRole` to 'user' or 'admin' randomly for demonstration purposes. When logging out, reset `userRole` to 'guest'.\n3.  **Conditional UI**: Implement the following display logic:\n    *   If `isLoggedIn` is `false`, show a 'Login' button and a message 'Please log in to access features.'\n    *   If `isLoggedIn` is `true`:\n        *   Show a 'Logout' button and a 'Welcome, [Role]!' message.\n        *   If `userRole` is 'admin', also show a button 'Toggle Admin Panel'. Clicking this button should toggle the `showAdminPanel` state.\n        *   If `showAdminPanel` is `true` (and `userRole` is 'admin'), display a `div` with 'Admin Dashboard Controls'.\n        *   If `userRole` is 'user', show a simple 'User Dashboard' message.\n4.  **Techniques**: Use a mix of `if` statements, ternary operators, and logical `&&` operators where most appropriate for readability and conciseness.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\nfunction AuthStatus() {\n  // TODO: Implement state for isLoggedIn, userRole, showAdminPanel\n\n  // TODO: Implement login/logout logic\n\n  // TODO: Implement conditional rendering based on state\n\n  return (\n    <div style={{ border: '1px solid lightblue', padding: '20px', margin: '20px' }}>\n      <h2>Authentication Status</h2>\n      {/* Your conditional rendering logic here */}\n    </div>\n  );\n}\n\nexport default AuthStatus;\n",
          "solutionCode": "import React, { useState } from 'react';\n\nfunction AuthStatus() {\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const [userRole, setUserRole] = useState('guest'); // 'guest', 'user', 'admin'\n  const [showAdminPanel, setShowAdminPanel] = useState(false);\n\n  const handleLogin = () => {\n    setIsLoggedIn(true);\n    // Randomly assign user or admin role for demonstration\n    const roles = ['user', 'admin'];\n    const randomRole = roles[Math.floor(Math.random() * roles.length)];\n    setUserRole(randomRole);\n    console.log(`Logged in as: ${randomRole}`);\n  };\n\n  const handleLogout = () => {\n    setIsLoggedIn(false);\n    setUserRole('guest');\n    setShowAdminPanel(false); // Hide admin panel on logout\n    console.log('Logged out');\n  };\n\n  const toggleAdminPanel = () => {\n    setShowAdminPanel(prev => !prev);\n  };\n\n  return (\n    <div style={{ border: '1px solid lightblue', padding: '20px', margin: '20px' }}>\n      <h2>Authentication Status</h2>\n\n      {!isLoggedIn ? (\n        // Not logged in\n        <>\n          <p>Please log in to access features.</p>\n          <button onClick={handleLogin}>Login</button>\n        </>\n      ) : (\n        // Logged in\n        <>\n          <p>Welcome, {userRole.charAt(0).toUpperCase() + userRole.slice(1)}!</p>\n          <button onClick={handleLogout}>Logout</button>\n\n          {userRole === 'admin' && (\n            // Admin specific controls\n            <div style={{ marginTop: '10px' }}>\n              <button onClick={toggleAdminPanel}>\n                {showAdminPanel ? 'Hide Admin Panel' : 'Show Admin Panel'}\n              </button>\n              {showAdminPanel && (\n                <div style={{ border: '1px dashed grey', padding: '10px', marginTop: '10px' }}>\n                  <h3>Admin Dashboard Controls</h3>\n                  <p>Manage users, view reports, etc.</p>\n                </div>\n              )}\n            </div>\n          )}\n\n          {userRole === 'user' && (\n            // Regular user specific message\n            <p style={{ marginTop: '10px' }}>User Dashboard</p>\n          )}\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default AuthStatus;\n",
          "testCases": [
            "Initial state: 'Login' button and 'Please log in' message should be displayed.",
            "Click 'Login': User status should change to 'Welcome, User!' or 'Welcome, Admin!', and 'Logout' button appears.",
            "If logged in as 'admin': 'Toggle Admin Panel' button should appear.",
            "Click 'Toggle Admin Panel' (as admin): 'Admin Dashboard Controls' div should appear/disappear.",
            "Click 'Logout': UI should revert to initial 'Please log in' state, admin panel should be hidden if it was open."
          ],
          "hints": [
            "Use `useState` for `isLoggedIn`, `userRole`, and `showAdminPanel`.",
            "For login, you can randomly assign 'user' or 'admin' role using `Math.random()`.",
            "Combine ternary operators for the main `isLoggedIn` switch, and logical `&&` for conditionally showing the admin panel or admin-specific buttons.",
            "Ensure the `showAdminPanel` state is reset when `isLoggedIn` becomes `false`."
          ],
          "tags": [
            "React",
            "Conditional Rendering",
            "useState",
            "UI/UX",
            "Authentication",
            "State Management",
            "Dynamic UI"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React_functional_components",
            "Conditional_rendering_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "User Interface",
            "Role-Based Access Control"
          ]
        }
      ]
    }
  },
  {
    "id": "3ed597f2-5003-45ed-a919-b53494560025",
    "startLine": 5000,
    "endLine": 5099,
    "processedDate": "2025-06-17T09:23:21.675Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_testing_overview",
          "title": "React Component Testing Overview",
          "content": "Testing React components is crucial for ensuring the reliability, maintainability, and correctness of user interfaces. It helps catch bugs early in the development cycle, verifies that components behave as expected under various conditions, and provides confidence for future changes or refactoring. There are several approaches and libraries for testing React components, each with its own philosophy and strengths.\n\nKey aspects of React testing often involve:\n- **Rendering components:** Mounting components into a test environment.\n- **Finding elements:** Querying the rendered output to locate specific DOM nodes.\n- **Simulating user interactions:** Triggering events like clicks, input changes, or form submissions.\n- **Asserting component behavior:** Verifying that the component's state, rendered output, or side effects are correct.\n- **Mocking dependencies:** Isolating the component under test by replacing external dependencies (like API calls or third-party libraries) with controlled mock implementations.",
          "examples": [],
          "relatedQuestions": [
            "question_testing_general_1",
            "question_testing_general_2"
          ],
          "relatedTasks": [],
          "tags": [
            "react",
            "testing",
            "frontend-development",
            "best-practices"
          ],
          "technology": "React",
          "prerequisites": [
            "react_fundamentals",
            "javascript_fundamentals"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_advanced_topics",
            "component_library_development"
          ]
        },
        {
          "id": "theory_react_testing_library",
          "title": "React Testing Library (RTL)",
          "content": "React Testing Library (RTL) is a lightweight and opinionated testing utility for React that promotes testing components in a way that mimics how users interact with them. Its core philosophy is: 'The more your tests resemble the way your software is used, the more confidence they can give you.'\n\n## Key Concepts\n- **User-Centric Testing:** Instead of testing implementation details (like component internal state or methods), RTL encourages testing the public API of a component, specifically its output rendered to the DOM and how it responds to user interactions.\n- **Accessibility Focus:** RTL's querying methods prioritize finding elements in a way that is accessible to users, such as by `role`, `label text`, or `alt text`.\n- **`render` function:** Used to render a React component into a virtual DOM for testing.\n- **`screen` object:** Provides various query methods to find elements in the rendered DOM.\n- **`fireEvent`:** Used to simulate DOM events (e.g., `click`, `change`, `submit`).\n- **`waitFor`:** Essential for testing asynchronous operations, allowing tests to wait for elements to appear or disappear in the DOM.\n- **`@testing-library/jest-dom`:** Extends Jest's `expect` matchers with useful DOM-specific assertions (e.g., `toBeInTheDocument`, `toHaveTextContent`).\n\n## Query Priorities (Best to Worst)\n1.  **`getByRole`**: Finds elements by their ARIA role (e.g., `button`, `checkbox`, `textbox`). Most robust and accessible.\n2.  **`getByLabelText`**: Finds form elements by their associated label text.\n3.  **`getByPlaceholderText`**: Finds input elements by their placeholder text.\n4.  **`getByText`**: Finds elements containing specific text content. Useful for general text elements.\n5.  **`getByDisplayValue`**: Finds form elements by their current value.\n6.  **`getByAltText`**: Finds elements by their `alt` attribute (e.g., images).\n7.  **`getByTitle`**: Finds elements by their `title` attribute.\n8.  **`getByTestId`**: Finds elements by a `data-testid` attribute. This is a fallback and generally discouraged for user-facing elements, as it couples tests to implementation details, but can be useful for elements that are not user-facing or for debugging.\n\nFor asynchronous operations, `waitFor` or `findBy*` queries (which are `getBy*` variants that return a Promise and wait for the element to appear) are critical. Mocking API calls using Jest's `jest.mock` is common practice to isolate component tests from network dependencies.",
          "examples": [
            {
              "id": "example_rtl_counter_test",
              "title": "Basic Counter Component Test with RTL",
              "code": "import { render, screen, fireEvent } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport Counter from './Counter';\n\n// Assuming Counter.tsx looks like:\n// const Counter = () => {\n//   const [count, setCount] = useState(0);\n//   return (\n//     <div>\n//       <div data-testid=\"counter-value\">{count}</div>\n//       <button onClick={() => setCount(prev => prev + 1)}>Increment</button>\n//     </div>\n//   );\n// };\n\ntest('counter increments when button is clicked', () => {\n  // Render the component into the DOM\n  render(<Counter />);\n  \n  // Find elements using screen queries\n  // getByTestId is used here as 'counter-value' is not user-facing\n  const counterValue = screen.getByTestId('counter-value');\n  // getByRole is preferred for interactive elements like buttons\n  const incrementButton = screen.getByRole('button', { name: /increment/i });\n  \n  // Assert initial state\n  expect(counterValue).toHaveTextContent('0');\n  \n  // Interact with the component by simulating a click event\n  fireEvent.click(incrementButton);\n  \n  // Assert updated state after interaction\n  expect(counterValue).toHaveTextContent('1');\n});",
              "explanation": "This example demonstrates the core workflow of React Testing Library: rendering a component, querying for elements based on user-facing attributes (like button text or ARIA roles), simulating user interactions, and asserting the expected outcome in the DOM. The `fireEvent.click` simulates a user clicking the button, and `toHaveTextContent` asserts the visual change.",
              "language": "typescript"
            },
            {
              "id": "example_rtl_async_data_test",
              "title": "Testing Asynchronous Component with RTL",
              "code": "import { render, screen, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport UserData from './UserData';\n\n// Assuming UserData.tsx looks like:\n// import { useEffect, useState } from 'react';\n// import { fetchUserData } from '../api'; // This is mocked\n// const UserData = ({ userId }) => {\n//   const [user, setUser] = useState(null);\n//   const [loading, setLoading] = useState(true);\n//   useEffect(() => {\n//     fetchUserData(userId).then(data => {\n//       setUser(data);\n//       setLoading(false);\n//     });\n//   }, [userId]);\n//   if (loading) return <div>Loading...</div>;\n//   if (!user) return <div>No user found.</div>;\n//   return <div>{user.name}</div>;\n// };\n\n// Mock the API call using Jest's mocking capabilities\njest.mock('../api', () => ({\n  fetchUserData: jest.fn(() =>\n    Promise.resolve({ id: 1, name: 'John Doe' }) // Mocked successful response\n  ),\n}));\n\ntest('loads and displays user data', async () => {\n  render(<UserData userId={1} />);\n  \n  // Initially shows loading state while data is being fetched\n  expect(screen.getByText(/loading/i)).toBeInTheDocument();\n  \n  // Wait for the user data to load and appear in the DOM\n  // waitFor polls the DOM until the condition is met or timeout\n  await waitFor(() => {\n    expect(screen.getByText('John Doe')).toBeInTheDocument();\n  });\n  \n  // Ensure loading indicator is removed after data loads (optional, but good)\n  expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();\n});",
              "explanation": "This example demonstrates testing a component that fetches data asynchronously. `jest.mock` is used to intercept and control the `fetchUserData` function, ensuring the test doesn't rely on actual network requests. `waitFor` is crucial here; it allows the test to pause and wait for the component's state to update and for the expected content ('John Doe') to appear in the DOM, simulating the delay of an API call.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_rtl_1",
            "question_rtl_2",
            "question_rtl_3",
            "question_rtl_4",
            "question_rtl_5",
            "question_rtl_6",
            "question_rtl_7",
            "question_rtl_8",
            "question_rtl_9",
            "question_rtl_10",
            "question_rtl_11",
            "question_rtl_12"
          ],
          "relatedTasks": [
            "task_rtl_form_validation",
            "task_rtl_async_component"
          ],
          "tags": [
            "react",
            "testing",
            "react-testing-library",
            "rtl",
            "jest",
            "unit-testing",
            "integration-testing",
            "asynchronous-testing"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "jest_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "professional_react_development",
            "component_library_development"
          ]
        },
        {
          "id": "theory_enzyme",
          "title": "Enzyme",
          "content": "Enzyme is a JavaScript testing utility for React that makes it easier to test your React components' output. Developed by Airbnb, it provides a jQuery-like API for traversing, manipulating, and simulating runtime events on your React components' output. Unlike React Testing Library, Enzyme primarily focuses on testing component internals and implementation details.\n\n## Key Concepts\n- **Shallow Rendering (`shallow`):** Renders only the component itself, not its children. This is useful for unit testing a component in isolation, ensuring that changes to child components do not affect the parent component's tests. It does not interact with the DOM.\n- **Full DOM Rendering (`mount`):** Renders the component into a real DOM (JSDOM in Node.js environments). This is suitable for integration tests where you need to test component lifecycle methods, interactions with the DOM, or interactions between parent and child components.\n- **Static Markup Rendering (`render`):** Renders React components to static HTML strings. This is useful for checking the rendered HTML output of components.\n- **`wrapper` object:** The result of `shallow`, `mount`, or `render`. It provides methods to find elements (`.find()`), simulate events (`.simulate()`), access state/props (`.state()`, `.props()`), and debug (`.debug()`).\n- **Implementation-Specific Testing:** Enzyme allows direct access to a component's internal state, props, and methods, making it possible to test specific implementation details.\n\nWhile still used in many legacy projects, Enzyme has seen reduced development and community adoption in favor of React Testing Library due to RTL's emphasis on user-centric testing and better alignment with modern React practices.",
          "examples": [
            {
              "id": "example_enzyme_counter_test",
              "title": "Counter Component Test with Enzyme",
              "code": "import { shallow, mount } from 'enzyme';\nimport Counter from './Counter';\n\n// Assuming Counter.tsx looks like:\n// const Counter = () => {\n//   const [count, setCount] = useState(0);\n//   return (\n//     <div className=\"counter\">\n//       <div className=\"value\">{count}</div>\n//       <button className=\"increment\" onClick={() => setCount(prev => prev + 1)}>Increment</button>\n//     </div>\n//   );\n// };\n\ndescribe('Counter Component', () => {\n  it('renders correctly with shallow', () => {\n    // Shallow render the component, isolating it from child components\n    const wrapper = shallow(<Counter />);\n    expect(wrapper.find('.counter')).toHaveLength(1);\n    expect(wrapper.find('.value').text()).toEqual('0');\n  });\n\n  it('increments when button is clicked with mount', () => {\n    // Mount the component into a full DOM for interaction testing\n    const wrapper = mount(<Counter />);\n    // Find the button by its class name\n    wrapper.find('button.increment').simulate('click');\n    // Assert the text content of the value element\n    expect(wrapper.find('.value').text()).toEqual('1');\n  });\n});",
              "explanation": "This example demonstrates using both `shallow` and `mount` with Enzyme. `shallow` is used to test the component in isolation, verifying its structure and initial state without rendering its children. `mount` is used for interaction testing, allowing simulation of a click event on the button and then asserting the change in the displayed value. Enzyme's `.find()` uses CSS selectors, similar to jQuery, for locating elements.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_enzyme_1",
            "question_enzyme_2",
            "question_enzyme_3",
            "question_enzyme_4",
            "question_enzyme_5",
            "question_enzyme_6",
            "question_enzyme_7"
          ],
          "relatedTasks": [
            "task_enzyme_component_interaction",
            "task_enzyme_context_api"
          ],
          "tags": [
            "react",
            "testing",
            "enzyme",
            "jest",
            "unit-testing",
            "shallow-rendering",
            "full-dom-rendering"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "jest_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "maintaining_legacy_react_apps",
            "deep_understanding_of_react_lifecycle"
          ]
        },
        {
          "id": "theory_jest_snapshots",
          "title": "Jest Snapshot Testing",
          "content": "Jest's snapshot testing is a powerful tool designed to help ensure your UI (or any serializable data structure) doesn't change unexpectedly. It works by capturing a 'snapshot' of a rendered component (or a data structure) and saving it as a text file alongside your test. On subsequent test runs, Jest compares the new rendered output to the previously saved snapshot.\n\n## How It Works\n1.  **First Run:** When a snapshot test is run for the first time, Jest renders the component (e.g., using `react-test-renderer` or by React Testing Library's `render` which creates a DOM structure) and serializes its output into a human-readable `.snap` file.\n2.  **Subsequent Runs:** In subsequent runs, Jest re-renders the component and compares the new output against the existing snapshot file.\n3.  **Failure:** If the new output differs from the snapshot, the test fails, and Jest provides a diff, highlighting the changes.\n4.  **Updating Snapshots:** If the changes are intentional (e.g., a UI update), you can run Jest with the `-u` flag (`jest -u` or `npm test -- -u`) to update the snapshots.\n\n## Use Cases\n-   **UI Regression Testing:** Catching unintentional changes to the UI's structure or appearance.\n-   **Data Structure Consistency:** Testing that the output of a function or the structure of an object remains consistent.\n\n## Advantages\n-   **Quick Regression Detection:** Automatically highlights any visual or structural regressions.\n-   **Ease of Use:** Simple to set up and run.\n\n## Disadvantages/Considerations\n-   **False Positives:** Tests can fail even for intentional UI changes, requiring manual updates.\n-   **Brittleness:** Over-reliance can lead to snapshots becoming too large or difficult to review, making it hard to discern meaningful changes from trivial ones.\n-   **Not a Replacement for Functional Tests:** Snapshots only verify structure, not behavior. They don't replace tests that simulate user interactions or verify application logic.\n\nWhile the provided markdown only shows an `import React from 'react';`, a typical snapshot test would involve rendering a component and asserting its structure using `toMatchSnapshot()`.",
          "examples": [
            {
              "id": "example_jest_snapshot_basic",
              "title": "Basic Snapshot Test for a React Component",
              "code": "import React from 'react';\nimport renderer from 'react-test-renderer'; // Used for server-side rendering/snapshots\n\n// Assuming a simple Greeting component:\n// const Greeting = ({ name }) => <h1>Hello, {name}!</h1>;\n\n// Or, if using React Testing Library:\n// import { render } from '@testing-library/react';\n// const Greeting = ({ name }) => <h1>Hello, {name}!</h1>;\n\ndescribe('Greeting Component', () => {\n  it('renders correctly and matches snapshot using react-test-renderer', () => {\n    const tree = renderer.create(<Greeting name=\"World\" />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders correctly and matches snapshot using React Testing Library', () => {\n    // When using RTL, the default render output can also be snapshotted\n    const { asFragment } = render(<Greeting name=\"Jest\" />);\n    expect(asFragment()).toMatchSnapshot();\n  });\n});\n\n/* Example .snap file content:\n\nexports[`Greeting Component renders correctly and matches snapshot using react-test-renderer 1`] = `\n<h1>\n  Hello, \n  World\n  !\n</h1>\n`;\n\nexports[`Greeting Component renders correctly and matches snapshot using React Testing Library 1`] = `\n<DocumentFragment>\n  <h1>\n    Hello, \n    Jest\n    !\n  </h1>\n</DocumentFragment>\n`;\n*/",
              "explanation": "This example shows two ways to create a snapshot test for a simple `Greeting` component. The first uses `react-test-renderer`, which is commonly used for pure component snapshots outside of a browser environment. The second demonstrates how React Testing Library's `asFragment()` helper can also be used to create a DOM fragment suitable for snapshotting, ensuring consistency with your RTL tests. The `toMatchSnapshot()` matcher automatically handles the creation and comparison of the snapshot file.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_jest_snapshot_1",
            "question_jest_snapshot_2",
            "question_jest_snapshot_3",
            "question_jest_snapshot_4",
            "question_jest_snapshot_5",
            "question_jest_snapshot_6"
          ],
          "relatedTasks": [
            "task_jest_snapshot_component"
          ],
          "tags": [
            "jest",
            "snapshot-testing",
            "ui-testing",
            "regression-testing",
            "react"
          ],
          "technology": "Jest",
          "prerequisites": [
            "jest_basics",
            "react_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "ui_regression_prevention",
            "component_library_maintenance"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_testing_general_1",
          "topic": "Introduction to React Testing",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary benefit of writing tests for React components?",
          "answer": "Ensures reliability, catches bugs early, verifies behavior, and provides confidence for refactoring.",
          "options": [],
          "analysisPoints": [
            "Understanding the fundamental motivation for testing.",
            "Ability to articulate key advantages beyond just 'finding bugs'."
          ],
          "keyConcepts": [
            "software quality",
            "maintainability",
            "bug prevention",
            "refactoring confidence"
          ],
          "evaluationCriteria": [
            "Conceptual understanding",
            "Articulation of benefits"
          ],
          "example": "",
          "tags": [
            "testing",
            "react",
            "fundamentals"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_testing_general_2",
          "topic": "Mocking in Tests",
          "level": "medium",
          "type": "open",
          "question": "Explain the concept of 'mocking' in the context of component testing. Why is it important, especially for components that interact with external services?",
          "answer": "Mocking involves replacing real dependencies (like API calls, date functions, or third-party modules) with controlled, simulated versions during tests. It's crucial because:\n1.  **Isolation:** Mocks isolate the component under test from its dependencies, ensuring that the test fails only if there's a bug in the component itself, not in an external service.\n2.  **Predictability:** Mocks allow you to control the exact response of a dependency, making tests deterministic and reproducible, regardless of network conditions or external system states.\n3.  **Speed:** Mocked dependencies run instantly, avoiding the delays associated with real network requests or database queries.\n4.  **Edge Cases:** Mocks enable testing of various scenarios (e.g., successful response, error response, empty data) that might be difficult or impossible to simulate with real services.",
          "options": [],
          "analysisPoints": [
            "Definition of mocking.",
            "Reasons for its importance (isolation, predictability, speed, edge cases).",
            "Practical application in testing."
          ],
          "keyConcepts": [
            "mocking",
            "dependency injection",
            "unit testing",
            "isolation",
            "deterministic tests"
          ],
          "evaluationCriteria": [
            "Clear definition",
            "Comprehensive explanation of benefits",
            "Understanding of test isolation"
          ],
          "example": "",
          "tags": [
            "testing",
            "jest",
            "mocking",
            "api",
            "best-practices"
          ],
          "prerequisites": [
            "javascript_functions",
            "async_programming"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_1",
          "topic": "React Testing Library Philosophy",
          "level": "easy",
          "type": "mcq",
          "question": "What is the core philosophy behind React Testing Library (RTL)?",
          "answer": "The more your tests resemble the way your software is used, the more confidence they can give you.",
          "options": [
            "Focus on testing internal implementation details like component state and methods.",
            "The more your tests resemble the way your software is used, the more confidence they can give you.",
            "Ensure every line of code is covered by a test, regardless of user interaction.",
            "Prioritize speed of test execution over realistic user simulation."
          ],
          "analysisPoints": [
            "Understanding RTL's user-centric approach.",
            "Distinguishing RTL from implementation-detail focused libraries."
          ],
          "keyConcepts": [
            "RTL philosophy",
            "user-centric testing",
            "testing principles"
          ],
          "evaluationCriteria": [
            "Knowledge of RTL's core tenet"
          ],
          "example": "React Testing Library emphasizes interacting with the component's output (the DOM) in the same way a real user would, rather than poking into internal state or methods. This means querying for elements by accessible attributes like role, label, or text content.",
          "tags": [
            "react-testing-library",
            "rtl",
            "testing-philosophy"
          ],
          "prerequisites": [
            "react_testing_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_2",
          "topic": "React Testing Library Queries",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following `screen` queries is generally considered the **most preferred** for finding interactive elements in React Testing Library, due to its alignment with accessibility best practices?",
          "answer": "`getByRole`",
          "options": [
            "`getByTestId`",
            "`getByText`",
            "`getByRole`",
            "`getByClassName`"
          ],
          "analysisPoints": [
            "Knowledge of RTL query priority.",
            "Understanding of accessibility in testing.",
            "Distinguishing best practices from fallback options."
          ],
          "keyConcepts": [
            "RTL queries",
            "accessibility",
            "testing best practices",
            "DOM interaction"
          ],
          "evaluationCriteria": [
            "Understanding of RTL's query hierarchy",
            "Knowledge of accessible testing"
          ],
          "example": "The `getByRole` query is preferred because it mirrors how assistive technologies interact with the page. For example, a screen reader user navigates by roles (button, link, checkbox). Using `getByTestId` is generally a fallback when no other accessible query is suitable, as it ties your test to a specific non-user-facing attribute.",
          "tags": [
            "react-testing-library",
            "rtl",
            "queries",
            "accessibility"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_3",
          "topic": "React Testing Library Async",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following test scenario for an asynchronous component:\n\n```typescript\nimport { render, screen, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport UserProfile from './UserProfile';\n\njest.mock('../api', () => ({\n  fetchUserProfile: jest.fn(() =>\n    Promise.resolve({ name: 'Jane Doe', email: 'jane@example.com' })\n  ),\n}));\n\ntest('displays user profile after loading', async () => {\n  render(<UserProfile id={1} />);\n  \n  // A. What should be used here to wait for content?\n  // expect(screen.getByText(/loading/i)).toBeInTheDocument();\n  \n  // B. What should be asserted after content loads?\n});\n```\n\nWhich combination of code snippets correctly fills in `A` and `B` to properly test the asynchronous behavior?",
          "answer": "A: `expect(screen.getByText(/loading/i)).toBeInTheDocument();` B: `await waitFor(() => { expect(screen.getByText('Jane Doe')).toBeInTheDocument(); });`",
          "options": [
            "A: `expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();` B: `expect(screen.getByText('Jane Doe')).toBeInTheDocument();`",
            "A: `expect(screen.getByText(/loading/i)).toBeInTheDocument();` B: `await waitFor(() => { expect(screen.getByText('Jane Doe')).toBeInTheDocument(); });`",
            "A: `await waitFor(() => { expect(screen.getByText(/loading/i)).toBeInTheDocument(); });` B: `expect(screen.getByText('Jane Doe')).toBeInTheDocument();`",
            "A: `expect(screen.getByText('Jane Doe')).toBeInTheDocument();` B: `await waitFor(() => { expect(screen.getByText(/loading/i)).not.toBeInTheDocument(); });`"
          ],
          "analysisPoints": [
            "Understanding of initial loading state assertion.",
            "Correct use of `waitFor` for asynchronous updates.",
            "Knowledge of `getByText` vs `queryByText` for presence/absence.",
            "Order of assertions in async tests."
          ],
          "keyConcepts": [
            "async testing",
            "waitFor",
            "jest.mock",
            "screen.getByText",
            "screen.queryByText",
            "RTL queries"
          ],
          "evaluationCriteria": [
            "Ability to test asynchronous component behavior",
            "Correct use of RTL async utilities"
          ],
          "example": "In asynchronous tests, you first assert the initial state (e.g., 'Loading...'). Then, you use `await waitFor` to pause the test execution until the expected final state (e.g., the loaded data 'Jane Doe') appears in the DOM. `waitFor` repeatedly checks the callback until it no longer throws an error or a timeout occurs. Using `queryByText` for checking absence is also a good practice.",
          "tags": [
            "react-testing-library",
            "rtl",
            "asynchronous",
            "jest",
            "mocking"
          ],
          "prerequisites": [
            "theory_react_testing_library",
            "javascript_promises"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_4",
          "topic": "React Testing Library `fireEvent`",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of `fireEvent` in React Testing Library?",
          "answer": "`fireEvent` is used to simulate user interactions or DOM events (e.g., clicks, input changes, key presses) on elements rendered by a component.",
          "options": [],
          "analysisPoints": [
            "Understanding of `fireEvent`'s role.",
            "Ability to list types of interactions it can simulate."
          ],
          "keyConcepts": [
            "fireEvent",
            "user interaction",
            "DOM events",
            "RTL"
          ],
          "evaluationCriteria": [
            "Knowledge of core RTL utilities"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "rtl",
            "events"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_rtl_5",
          "topic": "RTL vs. Enzyme",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast React Testing Library and Enzyme. Discuss their different philosophies and when you might choose one over the other.",
          "answer": "**React Testing Library (RTL):**\n*   **Philosophy:** User-centric. Focuses on testing how users interact with your components (behavioral testing).\n*   **Methodology:** Works with the actual DOM (via JSDOM). Encourages querying elements by accessible attributes (role, label, text) rather than implementation details (component state, internal methods).\n*   **Strengths:** Higher confidence in tests because they resemble real usage, promotes accessibility, less brittle to refactoring internal component logic.\n*   **Weaknesses:** Can be harder to test specific internal state changes or call private methods (by design).\n*   **Use Cases:** Most common for modern React projects, integration tests, and ensuring user flows.\n\n**Enzyme:**\n*   **Philosophy:** Implementation-detail centric. Provides utilities to inspect and manipulate component internals.\n*   **Methodology:** Offers `shallow` rendering (component in isolation, no DOM) and `mount` rendering (full DOM). Provides a jQuery-like API (`find`, `simulate`) to interact with component instances.\n*   **Strengths:** Easy to access and assert on internal component state, props, and methods; convenient for unit testing individual components in isolation.\n*   **Weaknesses:** Tests can become brittle to internal refactoring; less emphasis on accessibility.\n*   **Use Cases:** Common in older React projects, specific unit tests where deep inspection of component internals is truly necessary.\n\n**When to choose:**\n*   **RTL:** For most modern React applications, especially when prioritizing user experience, accessibility, and robust integration tests. It's the recommended choice by the React team.\n*   **Enzyme:** If working with a legacy codebase that already uses Enzyme, or in very specific scenarios where deep inspection of component internals is unavoidable and justified (though often a sign of a testable component design issue).",
          "options": [],
          "analysisPoints": [
            "Ability to articulate the core philosophy of each library.",
            "Understanding their respective strengths and weaknesses.",
            "Providing clear scenarios for when to use each.",
            "Demonstrating knowledge of current industry trends (RTL being preferred)."
          ],
          "keyConcepts": [
            "RTL",
            "Enzyme",
            "user-centric testing",
            "implementation-detail testing",
            "shallow rendering",
            "full DOM rendering",
            "testing philosophy",
            "accessibility"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison",
            "Clear understanding of use cases",
            "Demonstration of expert knowledge"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "enzyme",
            "comparison",
            "testing-philosophy",
            "architecture"
          ],
          "prerequisites": [
            "theory_react_testing_library",
            "theory_enzyme"
          ],
          "complexity": 8,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_rtl_6",
          "topic": "RTL Query Methods",
          "level": "medium",
          "type": "mcq",
          "question": "You have a component displaying a list of items:\n\n```typescript\nfunction ItemList({ items }) {\n  return (\n    <div>\n      {items.length > 0 && \n        <ul data-testid=\"item-list\">\n          {items.map(item => <li key={item.id}>{item.name}</li>)}\n        </ul>\n      }\n    </div>\n  );\n}\n```\n\nWhich of the following would be the **most appropriate** way to check if the list itself (the `<ul>` element) is present in the document when `items` array is not empty, following RTL best practices?",
          "answer": "`expect(screen.getByTestId('item-list')).toBeInTheDocument();`",
          "options": [
            "`expect(screen.getByRole('list')).toBeInTheDocument();`",
            "`expect(screen.getByText('List')).toBeInTheDocument();`",
            "`expect(screen.getByTestId('item-list')).toBeInTheDocument();`",
            "`expect(screen.getByTagName('ul')).toBeInTheDocument();`"
          ],
          "analysisPoints": [
            "Understanding of `data-testid` usage as a fallback.",
            "Recognizing that `ul` element might not have a semantic role or accessible text by default for `getByRole` or `getByText` without additional props.",
            "Applying query priority knowledge correctly."
          ],
          "keyConcepts": [
            "RTL queries",
            "getByTestId",
            "getByRole",
            "accessibility vs testability",
            "DOM elements"
          ],
          "evaluationCriteria": [
            "Correct application of RTL query strategy",
            "Understanding of `data-testid` usage"
          ],
          "example": "While `getByRole('list')` might seem appropriate, an `<ul>` element often needs `role='list'` explicitly or a `role='listbox'` for more complex lists to be reliably found by `getByRole`. In this specific snippet, where `data-testid` is explicitly added for testing a non-interactive container element, `getByTestId` is the most direct and reliable way to target it without relying on potentially missing accessible attributes. `getByText('List')` would only work if 'List' was actual text content of the `<ul>` or an element within it.",
          "tags": [
            "react-testing-library",
            "rtl",
            "queries",
            "data-testid"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_7",
          "topic": "RTL `queryBy` vs `getBy` vs `findBy`",
          "level": "hard",
          "type": "open",
          "question": "React Testing Library provides `getBy*`, `queryBy*`, and `findBy*` variants for its queries. Explain the key differences between these variants and when you would use each one.",
          "answer": "**`getBy*`:**\n*   **Purpose:** Used to find an element that is expected to be present in the DOM *synchronously*. If the element is not found, it will throw an error immediately.\n*   **When to use:** For elements that are guaranteed to be in the document when the query is run (e.g., initial render content, static elements).\n*   **Example:** `screen.getByText('Submit Button')`\n\n**`queryBy*`:**\n*   **Purpose:** Used to find an element that may or may not be present in the DOM *synchronously*. If the element is not found, it returns `null` instead of throwing an error.\n*   **When to use:** For asserting the *absence* of an element (e.g., a loading spinner disappears, an error message is not shown) or when an element's presence is conditional and you want to handle both cases without an error.\n*   **Example:** `expect(screen.queryByText('Loading...')).not.toBeInTheDocument()`\n\n**`findBy*`:**\n*   **Purpose:** A combination of `getBy*` and `waitFor`. It returns a Promise that resolves when the element is found in the DOM (polling until found) or rejects if the element is not found within a default timeout (typically 1000ms).\n*   **When to use:** For elements that appear asynchronously (e.g., after an API call, a state update, or an animation completes). It implicitly uses `waitFor`.\n*   **Example:** `await screen.findByText('Loaded Data')`\n\nIn summary: `getBy` for synchronous presence, `queryBy` for synchronous absence, and `findBy` for asynchronous presence.",
          "options": [],
          "analysisPoints": [
            "Clear distinction between synchronous/asynchronous behavior.",
            "Correct use cases for each query type.",
            "Understanding of error handling (`getBy` throws, `queryBy` returns null, `findBy` returns Promise).",
            "Connection between `findBy` and `waitFor`."
          ],
          "keyConcepts": [
            "RTL queries",
            "synchronous testing",
            "asynchronous testing",
            "error handling",
            "waitFor"
          ],
          "evaluationCriteria": [
            "Depth of explanation",
            "Accuracy of usage scenarios",
            "Comprehensive comparison"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "rtl",
            "queries",
            "asynchronous",
            "error-handling"
          ],
          "prerequisites": [
            "theory_react_testing_library",
            "javascript_promises"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_rtl_8",
          "topic": "React Testing Library Test Structure",
          "level": "medium",
          "type": "code",
          "question": "You have a simple `ToggleButton` component that shows 'ON' or 'OFF' and toggles its state on click. Write a React Testing Library test to verify its initial state and that it toggles correctly when clicked.\n\n```typescript\nimport React, { useState } from 'react';\n\nconst ToggleButton = () => {\n  const [isOn, setIsOn] = useState(false);\n\n  return (\n    <button onClick={() => setIsOn(!isOn)}>\n      {isOn ? 'ON' : 'OFF'}\n    </button>\n  );\n};\n\nexport default ToggleButton;\n\n// Your test code here\n```",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly render the component.",
            "Use appropriate `screen` query for the button's text content.",
            "Assert initial state.",
            "Simulate click event using `fireEvent.click`.",
            "Assert updated state after interaction."
          ],
          "keyConcepts": [
            "RTL render",
            "screen queries",
            "fireEvent",
            "assertion"
          ],
          "evaluationCriteria": [
            "Correct test implementation",
            "Adherence to RTL best practices",
            "Handling state changes"
          ],
          "example": "```typescript\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport ToggleButton from './ToggleButton';\n\ntest('ToggleButton toggles state correctly on click', () => {\n  render(<ToggleButton />);\n  \n  // 1. Assert initial state: button should show 'OFF'\n  const toggleButton = screen.getByRole('button', { name: /off/i });\n  expect(toggleButton).toBeInTheDocument();\n  expect(toggleButton).toHaveTextContent('OFF');\n  \n  // 2. Simulate a click event\n  fireEvent.click(toggleButton);\n  \n  // 3. Assert updated state: button should now show 'ON'\n  // Re-querying is important as the text content has changed\n  const toggledButton = screen.getByRole('button', { name: /on/i });\n  expect(toggledButton).toBeInTheDocument();\n  expect(toggledButton).toHaveTextContent('ON');\n\n  // 4. Click again to ensure it toggles back to OFF\n  fireEvent.click(toggledButton);\n  expect(screen.getByRole('button', { name: /off/i })).toBeInTheDocument();\n});\n```",
          "tags": [
            "react-testing-library",
            "rtl",
            "code-challenge",
            "state-management",
            "events"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_9",
          "topic": "RTL Best Practices - `getByTestId`",
          "level": "medium",
          "type": "open",
          "question": "React Testing Library recommends using `getByTestId` as a last resort. Explain why this is the case and provide an example where using `getByTestId` might still be justified.",
          "answer": "Using `getByTestId` is generally discouraged in React Testing Library because it ties your tests to an implementation detail (`data-testid` attribute) that a user doesn't see or interact with. The core philosophy of RTL is to test components the way a user would. A user doesn't know or care about `data-testid` attributes; they interact with buttons, links, text, labels, etc.\n\n**Why it's a 'last resort':**\n*   **Breaks User-Centricity:** It deviates from testing the user experience.\n*   **Brittleness to Refactoring:** If you change the `data-testid` (e.g., during a refactor), the test breaks even if the user experience hasn't changed.\n*   **Promotes Bad Habits:** Encourages adding non-semantic attributes purely for testing, potentially cluttering the DOM.\n\n**When it might be justified:**\n`getByTestId` can be justified for elements that are not directly accessible or visible to the user, but are still critical for testing purposes. Examples include:\n1.  **Internal Debugging Elements:** Components that render complex internal structures, where a specific, non-user-facing node needs to be targeted for internal state verification or complex calculations.\n2.  **Third-Party Components:** When a third-party library's component doesn't expose accessible roles, labels, or text, and you need a reliable way to select a specific part of its rendered output.\n3.  **Complex SVG/Canvas Elements:** Elements where accessible text or roles are difficult to apply or change frequently, but you need a stable hook for testing specific regions or shapes.\n\n**Example:** Testing a hidden `<span>` element that holds a serialized JSON string for internal logging, or a complex chart canvas where individual data points aren't semantically addressable but have a unique `data-testid` for internal testing.",
          "options": [],
          "analysisPoints": [
            "Understanding of RTL philosophy vs. `data-testid`.",
            "Clear explanation of disadvantages.",
            "Providing valid, nuanced exceptions where it's acceptable.",
            "Demonstrating critical thinking beyond simply stating rules."
          ],
          "keyConcepts": [
            "RTL best practices",
            "data-testid",
            "accessibility",
            "implementation details",
            "user-centric testing",
            "refactoring"
          ],
          "evaluationCriteria": [
            "Depth of reasoning",
            "Quality of examples",
            "Nuanced understanding of testing trade-offs"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "rtl",
            "best-practices",
            "testing-strategy",
            "data-testid"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_rtl_10",
          "topic": "RTL Debugging",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the purpose of `screen.debug()` in React Testing Library?",
          "answer": "`screen.debug()` prints the current state of the rendered DOM to the console. It's useful for debugging tests, understanding what your component actually rendered, and verifying that queries are targeting the correct elements.",
          "options": [],
          "analysisPoints": [
            "Knowledge of RTL debugging tools.",
            "Understanding of how it helps in test development."
          ],
          "keyConcepts": [
            "RTL debugging",
            "screen.debug()",
            "DOM inspection"
          ],
          "evaluationCriteria": [
            "Knowledge of RTL utilities"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "rtl",
            "debugging"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_rtl_11",
          "topic": "RTL `waitFor` vs `findBy`",
          "level": "hard",
          "type": "flashcard",
          "question": "When would you explicitly use `waitFor` instead of a `findBy*` query for asynchronous assertions in RTL?",
          "answer": "You would use `waitFor` when your assertion is not about the presence of an element, but rather about a non-DOM side effect, a change in an element's attribute, or when you need to assert that something *disappears* asynchronously. `findBy*` queries are specifically for *finding* an element that appears asynchronously. For example, `waitFor` is used to check if a mock function was called after an async operation, or if an element's class name changed, or if an element is removed from the DOM (`expect(queryByText(...)).not.toBeInTheDocument()`).",
          "options": [],
          "analysisPoints": [
            "Understanding the specific use cases for `waitFor`.",
            "Distinguishing between asserting element presence and other asynchronous changes.",
            "Knowledge of when `findBy*` is insufficient."
          ],
          "keyConcepts": [
            "waitFor",
            "findBy",
            "asynchronous testing",
            "RTL queries",
            "side effects"
          ],
          "evaluationCriteria": [
            "Nuanced understanding of async utilities",
            "Ability to differentiate specific use cases"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "rtl",
            "asynchronous-testing"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_rtl_12",
          "topic": "RTL Role of `jest-dom`",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the role of `@testing-library/jest-dom/extend-expect` in a React Testing Library setup?",
          "answer": "It extends Jest's `expect` matchers with custom DOM-specific matchers from `@testing-library/jest-dom`. This provides more readable and semantically meaningful assertions for DOM elements, such as `toBeInTheDocument()`, `toHaveTextContent()`, `toBeVisible()`, `toBeDisabled()`, etc., making tests more expressive and easier to understand.",
          "options": [],
          "analysisPoints": [
            "Understanding the functionality of `jest-dom`.",
            "Knowledge of specific matchers it provides."
          ],
          "keyConcepts": [
            "jest-dom",
            "jest matchers",
            "RTL setup",
            "assertion"
          ],
          "evaluationCriteria": [
            "Knowledge of test environment setup",
            "Understanding of assertion libraries"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "jest",
            "setup"
          ],
          "prerequisites": [
            "theory_react_testing_library"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_1",
          "topic": "Enzyme Rendering Methods",
          "level": "medium",
          "type": "mcq",
          "question": "Which Enzyme rendering method would you use to test a component in isolation, without rendering its child components into a full DOM tree?",
          "answer": "`shallow`",
          "options": [
            "`mount`",
            "`render`",
            "`shallow`",
            "`static`"
          ],
          "analysisPoints": [
            "Understanding the purpose of `shallow` rendering.",
            "Distinguishing it from `mount` and `render`.",
            "Knowledge of isolation in unit testing."
          ],
          "keyConcepts": [
            "Enzyme",
            "shallow rendering",
            "unit testing",
            "component isolation"
          ],
          "evaluationCriteria": [
            "Knowledge of Enzyme's core utilities"
          ],
          "example": "```typescript\nimport { shallow } from 'enzyme';\nimport MyParentComponent from './MyParentComponent';\nimport MyChildComponent from './MyChildComponent';\n\ndescribe('MyParentComponent', () => {\n  it('renders MyChildComponent correctly', () => {\n    const wrapper = shallow(<MyParentComponent />);\n    // When using shallow, MyChildComponent is not fully rendered, only its JSX reference is present.\n    expect(wrapper.find(MyChildComponent)).toHaveLength(1);\n    // You cannot find elements *inside* MyChildComponent using shallow rendering of MyParentComponent.\n  });\n});\n```\nThis example shows that `shallow` allows you to assert that `MyParentComponent` renders `MyChildComponent`, but it doesn't delve into `MyChildComponent`'s own internal DOM structure, ensuring the test focuses solely on the parent.",
          "tags": [
            "enzyme",
            "shallow-rendering",
            "react-testing"
          ],
          "prerequisites": [
            "theory_enzyme"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_2",
          "topic": "Enzyme DOM Interaction",
          "level": "medium",
          "type": "mcq",
          "question": "You need to test a React component's lifecycle methods, direct DOM interactions (like focus or scroll), or how it interacts with its child components in a realistic browser-like environment. Which Enzyme rendering method is most suitable for this scenario?",
          "answer": "`mount`",
          "options": [
            "`shallow`",
            "`mount`",
            "`render`",
            "`staticRender`"
          ],
          "analysisPoints": [
            "Understanding the capabilities of `mount` rendering.",
            "Recognition of scenarios requiring a full DOM.",
            "Comparison with other Enzyme methods."
          ],
          "keyConcepts": [
            "Enzyme",
            "mount rendering",
            "full DOM",
            "integration testing",
            "lifecycle methods",
            "DOM interaction"
          ],
          "evaluationCriteria": [
            "Knowledge of Enzyme's core utilities",
            "Understanding of full DOM rendering use cases"
          ],
          "example": "```typescript\nimport { mount } from 'enzyme';\nimport UserForm from './UserForm';\n\ndescribe('UserForm', () => {\n  it('updates state on input change and submits', () => {\n    const wrapper = mount(<UserForm />);\n    const nameInput = wrapper.find('input[name=\"name\"]');\n    \n    nameInput.simulate('change', { target: { value: 'John Doe' } });\n    \n    // With mount, you can access the component's state directly\n    expect(wrapper.state('name')).toEqual('John Doe');\n    \n    wrapper.find('form').simulate('submit');\n    // Assertions on onSubmit handler or further state changes\n  });\n});\n```\n`mount` creates a full DOM environment, allowing you to simulate complex interactions, access component instances, and verify lifecycle behavior, making it suitable for integration-style tests.",
          "tags": [
            "enzyme",
            "mount-rendering",
            "react-testing",
            "integration-testing"
          ],
          "prerequisites": [
            "theory_enzyme"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_3",
          "topic": "Enzyme Assertion",
          "level": "easy",
          "type": "flashcard",
          "question": "How would you simulate a click event on a button with the class `submit-btn` using an Enzyme `wrapper`?",
          "answer": "`wrapper.find('.submit-btn').simulate('click');`",
          "options": [],
          "analysisPoints": [
            "Knowledge of Enzyme's `find` and `simulate` methods.",
            "Correct syntax for targeting elements by class and simulating events."
          ],
          "keyConcepts": [
            "Enzyme API",
            "simulate",
            "find",
            "event simulation"
          ],
          "evaluationCriteria": [
            "Practical application of Enzyme methods"
          ],
          "example": "",
          "tags": [
            "enzyme",
            "events",
            "simulation"
          ],
          "prerequisites": [
            "theory_enzyme"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_4",
          "topic": "Enzyme vs. RTL Philosophy",
          "level": "medium",
          "type": "open",
          "question": "Enzyme allows direct access to a component's internal state and props via methods like `wrapper.state()` and `wrapper.props()`. How does this align (or conflict) with the modern testing philosophy promoted by React Testing Library, and what are the implications?",
          "answer": "Enzyme's ability to directly access and manipulate a component's internal state and props via `wrapper.state()` and `wrapper.props()` conflicts with the modern testing philosophy promoted by React Testing Library. \n\n**Conflict:**\n*   **Implementation Details vs. User Behavior:** RTL advocates for testing components from the user's perspective, interacting with the rendered output (the DOM) rather than internal implementation details. Directly accessing state and props violates this principle by focusing on *how* a component works internally, not just *what* it renders or *how* it behaves from a user's viewpoint.\n*   **Brittleness:** Tests that rely on internal state are brittle. If you refactor a component to use a different state management pattern (e.g., move from `useState` to `useReducer`, or change state variable names), these tests will break even if the component's external behavior (what the user sees and interacts with) remains unchanged.\n\n**Implications:**\n*   **Test Maintenance:** Tests written with Enzyme's internal access methods often require more frequent updates as component internals evolve, leading to higher maintenance overhead.\n*   **Less Confidence:** Such tests provide less confidence that the component works for a real user, as they don't simulate actual user interaction paths.\n*   **Accessibility:** Less emphasis on accessible querying means tests might not naturally promote accessible component design.\n\nWhile direct access can be convenient for unit-testing isolated logic, it shifts the focus away from the component's public interface and user experience, which is the primary concern for frontend testing.",
          "options": [],
          "analysisPoints": [
            "Clearly articulate the conflict with RTL's philosophy.",
            "Explain the negative implications (brittleness, maintenance, confidence).",
            "Contrast internal vs. external behavior testing."
          ],
          "keyConcepts": [
            "Enzyme",
            "RTL",
            "testing philosophy",
            "internal state",
            "props",
            "brittleness",
            "user experience"
          ],
          "evaluationCriteria": [
            "Depth of understanding of testing principles",
            "Ability to analyze implications",
            "Clear articulation of differences"
          ],
          "example": "",
          "tags": [
            "enzyme",
            "react-testing-library",
            "testing-philosophy",
            "best-practices"
          ],
          "prerequisites": [
            "theory_enzyme",
            "theory_react_testing_library"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_enzyme_5",
          "topic": "Enzyme `render` method",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the primary use case for Enzyme's `render` method, and how does it differ from `shallow` and `mount`?",
          "answer": "Enzyme's `render` method renders React components to static HTML strings using Cheerio, which is a lightweight implementation of jQuery for the server. Its primary use case is to inspect the static HTML output of a component, especially for snapshot testing or for analyzing the full rendered tree of a component hierarchy without the overhead of a full DOM environment or component lifecycle methods. Unlike `shallow` (which doesn't render children fully) and `mount` (which renders to a full DOM with lifecycle), `render` provides a complete, static HTML representation.",
          "options": [],
          "analysisPoints": [
            "Understanding of `render`'s output type (static HTML).",
            "Key differences from `shallow` and `mount` (no lifecycle, no full DOM).",
            "Specific use cases like snapshot testing."
          ],
          "keyConcepts": [
            "Enzyme",
            "render",
            "static HTML",
            "snapshot testing",
            "Cheerio"
          ],
          "evaluationCriteria": [
            "Knowledge of Enzyme's rendering options",
            "Understanding of their specific contexts"
          ],
          "example": "",
          "tags": [
            "enzyme",
            "rendering",
            "static-html",
            "snapshot-testing"
          ],
          "prerequisites": [
            "theory_enzyme"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_6",
          "topic": "Enzyme Finders",
          "level": "medium",
          "type": "code",
          "question": "You have a component with a nested structure. Using Enzyme's `mount` method, how would you find a `<span>` element with the text 'Total:' inside a `<div>` with the class `summary-box`?\n\n```typescript\nimport React from 'react';\n\nconst Summary = ({ total }) => (\n  <div className=\"summary-box\">\n    <p>Report Summary</p>\n    <span>Total:</span>\n    <span className=\"total-value\">${total}</span>\n    <button>View Details</button>\n  </div>\n);\n\nexport default Summary;\n\n// Your test code here\n```",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correct use of `wrapper.find()` with CSS selectors.",
            "Ability to combine selectors for nested elements.",
            "Asserting text content."
          ],
          "keyConcepts": [
            "Enzyme find",
            "CSS selectors",
            "nested elements",
            "mount"
          ],
          "evaluationCriteria": [
            "Practical application of Enzyme selectors",
            "Accuracy of code snippet"
          ],
          "example": "```typescript\nimport { mount } from 'enzyme';\nimport Summary from './Summary';\n\ndescribe('Summary Component', () => {\n  it('displays the total correctly', () => {\n    const wrapper = mount(<Summary total={100} />);\n    \n    // Find the <span> element with 'Total:' text using a CSS selector for its parent.\n    const totalLabelSpan = wrapper.find('.summary-box span').at(0); // or filter by text\n    \n    // A more robust way to find by text if it's unique enough:\n    const totalLabelSpanByText = wrapper.find('span').filterWhere(n => n.text() === 'Total:');\n\n    expect(totalLabelSpan.text()).toEqual('Total:');\n    expect(totalLabelSpanByText).toHaveLength(1);\n\n    // You could also find the specific text node:\n    expect(wrapper.find('.summary-box').text()).toContain('Total:');\n  });\n});\n```",
          "tags": [
            "enzyme",
            "code-challenge",
            "selectors",
            "find"
          ],
          "prerequisites": [
            "theory_enzyme"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_enzyme_7",
          "topic": "Enzyme vs. RTL Ecosystem",
          "level": "hard",
          "type": "flashcard",
          "question": "Beyond their philosophical differences, what is a practical reason why React Testing Library has gained more traction and is often recommended over Enzyme for new React projects?",
          "answer": "A significant practical reason is that React Testing Library is actively maintained and evolves alongside React's development, particularly with Hooks. Enzyme, while once dominant, has seen slower updates and less active development, leading to compatibility issues with newer React features (like `act` for Hooks testing, or specific React 18 behaviors) and a smaller, less responsive community for newer issues. RTL's emphasis on DOM-based testing also means it's less affected by internal React rendering engine changes than Enzyme's component instance manipulation.",
          "options": [],
          "analysisPoints": [
            "Understanding of library maintenance and community support.",
            "Knowledge of compatibility with modern React features (Hooks, React 18).",
            "Recognition of the impact of internal React changes."
          ],
          "keyConcepts": [
            "RTL vs Enzyme",
            "maintenance",
            "community support",
            "React Hooks",
            "compatibility"
          ],
          "evaluationCriteria": [
            "Knowledge of the broader testing ecosystem",
            "Understanding of practical development concerns"
          ],
          "example": "",
          "tags": [
            "react-testing-library",
            "enzyme",
            "ecosystem",
            "trends"
          ],
          "prerequisites": [
            "theory_react_testing_library",
            "theory_enzyme"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_jest_snapshot_1",
          "topic": "Jest Snapshot Purpose",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of Jest snapshot testing?",
          "answer": "To ensure your UI doesn't change unexpectedly over time.",
          "options": [
            "To verify component internal state mutations.",
            "To ensure your UI doesn't change unexpectedly over time.",
            "To test complex user interaction flows asynchronously.",
            "To measure component rendering performance."
          ],
          "analysisPoints": [
            "Understanding the core goal of snapshot testing (regression detection).",
            "Distinguishing it from other types of tests."
          ],
          "keyConcepts": [
            "Jest snapshots",
            "regression testing",
            "UI testing"
          ],
          "evaluationCriteria": [
            "Knowledge of snapshot testing concept"
          ],
          "example": "Jest snapshot tests create a stored 'snapshot' of a component's rendered output (or any serializable data). In subsequent test runs, it compares the current output to the saved snapshot. If there's a difference, the test fails, alerting you to a potential unintended change in your UI.",
          "tags": [
            "jest",
            "snapshot-testing",
            "ui-testing"
          ],
          "prerequisites": [
            "theory_jest_snapshots"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_jest_snapshot_2",
          "topic": "Jest Snapshot Workflow",
          "level": "medium",
          "type": "flashcard",
          "question": "How do you update a failing Jest snapshot if the change in the UI was intentional?",
          "answer": "You can update a failing Jest snapshot by running Jest with the `-u` flag (e.g., `jest -u` or `npm test -- -u`). This will overwrite the old snapshot file with the new, desired output.",
          "options": [],
          "analysisPoints": [
            "Knowledge of the command to update snapshots.",
            "Understanding when to update (intentional changes)."
          ],
          "keyConcepts": [
            "Jest snapshots",
            "updating snapshots",
            "jest -u"
          ],
          "evaluationCriteria": [
            "Practical knowledge of Jest commands"
          ],
          "example": "",
          "tags": [
            "jest",
            "snapshot-testing",
            "workflow"
          ],
          "prerequisites": [
            "theory_jest_snapshots"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_jest_snapshot_3",
          "topic": "Jest Snapshot Pros and Cons",
          "level": "medium",
          "type": "open",
          "question": "Discuss the advantages and disadvantages of using Jest snapshot testing. When might it be a good choice, and when should you be cautious?",
          "answer": "**Advantages:**\n1.  **Quick Regression Detection:** Automatically catches unexpected UI changes or data structure regressions with minimal effort.\n2.  **Ease of Use:** Simple to set up and write basic snapshot tests.\n3.  **Comprehensive Coverage:** Can cover large parts of the UI with relatively few lines of test code.\n4.  **Documentation:** Snapshots serve as a form of documentation for the rendered output of components.\n\n**Disadvantages/Cautions:**\n1.  **Brittleness:** Snapshots can be brittle. Even intentional UI changes (e.g., a simple text update, a new prop) will cause tests to fail, requiring manual review and updates (`jest -u`). This can lead to 'false positives' and 'blindly updating' snapshots without proper review.\n2.  **Not a Functional Test:** Snapshots only verify the rendered structure, not the behavior or functionality. They don't test user interactions, data fetching, or complex logic. They should complement, not replace, behavioral tests.\n3.  **Readability/Review:** Large snapshots can be difficult to review in pull requests, making it hard to identify significant changes from minor ones.\n4.  **Over-reliance:** Over-reliance can lead to a false sense of security, as tests pass based on structure, not actual user experience.\n\n**When to use:**\n*   **Presentational Components:** Ideal for simple, 'dumb' components that primarily render UI based on props, with little to no internal state or complex logic.\n*   **Data Structures:** To ensure complex objects or API responses maintain a consistent structure.\n*   **Regression Guard:** As a quick guard against unintended structural changes, especially in areas of the UI that are not frequently interacted with or have minimal dynamic behavior.\n\n**When to be cautious:**\n*   **Highly Dynamic Components:** Components with frequent changes, animations, or dynamic content that makes snapshots constantly change.\n*   **Business Logic:** Never use snapshots as the sole test for critical business logic or user flows; functional tests are required for these.\n*   **Large Snapshots:** Be wary of excessively large snapshots that are hard to review.",
          "options": [],
          "analysisPoints": [
            "Comprehensive list of pros and cons.",
            "Clear distinction between structural and functional testing.",
            "Understanding of when snapshots are appropriate and when they are not.",
            "Mention of brittleness and maintenance overhead."
          ],
          "keyConcepts": [
            "Jest snapshots",
            "advantages",
            "disadvantages",
            "regression testing",
            "functional testing",
            "brittleness"
          ],
          "evaluationCriteria": [
            "Balanced perspective",
            "Practical advice",
            "Depth of analysis"
          ],
          "example": "",
          "tags": [
            "jest",
            "snapshot-testing",
            "best-practices",
            "testing-strategy"
          ],
          "prerequisites": [
            "theory_jest_snapshots"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_jest_snapshot_4",
          "topic": "Jest Snapshot vs. RTL",
          "level": "hard",
          "type": "open",
          "question": "Can Jest snapshot tests replace behavioral tests written with React Testing Library? Explain your reasoning.",
          "answer": "No, Jest snapshot tests cannot fully replace behavioral tests written with React Testing Library. While both are valuable tools in a testing strategy, they serve different purposes and provide different levels of confidence:\n\n*   **Jest Snapshots:** Primarily focus on **structural regression**. They capture the rendered output (HTML or a data structure) at a specific point in time and compare it against future renders. They tell you *what* the component looks like (its structure) but not *how* it behaves or *how* a user interacts with it.\n\n*   **React Testing Library (RTL):** Focuses on **behavioral testing** from a user's perspective. It enables you to simulate real user interactions (clicks, typing, form submissions) and assert that the component responds correctly in the DOM. RTL tests give confidence that the application works for a real user.\n\n**Reasoning:**\nAn application can render correctly (pass a snapshot test) but still be broken from a user's perspective. For example:\n*   A button might *look* like a button in the snapshot, but if its `onClick` handler is broken, a behavioral test simulating a click will fail, while a snapshot test might still pass.\n*   A form might have all its inputs present in the snapshot, but if the submission logic fails or the form doesn't display validation errors correctly after submission, a behavioral test will catch this, whereas a snapshot won't.\n\nTherefore, snapshots are a good complement to behavioral tests, providing a quick check for unintended UI changes, but they are not a substitute for verifying actual user flows and interactions.",
          "options": [],
          "analysisPoints": [
            "Clear distinction between structural and behavioral testing.",
            "Understanding the different types of confidence each provides.",
            "Providing concrete examples of why one cannot replace the other."
          ],
          "keyConcepts": [
            "Jest snapshots",
            "RTL",
            "behavioral testing",
            "structural testing",
            "regression testing",
            "complementary testing"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison",
            "Clear logical reasoning",
            "Understanding of different testing levels"
          ],
          "example": "",
          "tags": [
            "jest",
            "snapshot-testing",
            "react-testing-library",
            "testing-strategy",
            "comparison"
          ],
          "prerequisites": [
            "theory_jest_snapshots",
            "theory_react_testing_library"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_jest_snapshot_5",
          "topic": "Jest Snapshot Configuration",
          "level": "medium",
          "type": "flashcard",
          "question": "Which Jest matcher is used to create and compare snapshots?",
          "answer": "`toMatchSnapshot()`",
          "options": [],
          "analysisPoints": [
            "Knowledge of the specific Jest matcher for snapshots.",
            "Understanding its role in the snapshot testing process."
          ],
          "keyConcepts": [
            "Jest matchers",
            "toMatchSnapshot",
            "snapshot testing"
          ],
          "evaluationCriteria": [
            "Knowledge of Jest API"
          ],
          "example": "",
          "tags": [
            "jest",
            "snapshot-testing",
            "matchers"
          ],
          "prerequisites": [
            "theory_jest_snapshots"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_jest_snapshot_6",
          "topic": "Jest Snapshot `react-test-renderer`",
          "level": "medium",
          "type": "code",
          "question": "Write a Jest snapshot test for a simple functional component called `WelcomeMessage` that receives a `username` prop and displays 'Welcome, [username]!'. Use `react-test-renderer`.\n\n```typescript\nimport React from 'react';\n\nconst WelcomeMessage = ({ username }) => (\n  <h1>Welcome, {username}!</h1>\n);\n\nexport default WelcomeMessage;\n\n// Your test code here\n```",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correct import of `react-test-renderer`.",
            "Using `renderer.create()` to render the component.",
            "Calling `.toJSON()` on the renderer output.",
            "Applying `toMatchSnapshot()` matcher."
          ],
          "keyConcepts": [
            "Jest snapshots",
            "react-test-renderer",
            "toMatchSnapshot",
            "code-challenge"
          ],
          "evaluationCriteria": [
            "Correct implementation of snapshot test",
            "Adherence to `react-test-renderer` usage"
          ],
          "example": "```typescript\nimport React from 'react';\nimport renderer from 'react-test-renderer';\nimport WelcomeMessage from './WelcomeMessage';\n\ndescribe('WelcomeMessage Component', () => {\n  it('renders correctly and matches snapshot', () => {\n    // Create a Jest renderer tree of the WelcomeMessage component\n    const tree = renderer.create(<WelcomeMessage username=\"Alice\" />).toJSON();\n    \n    // Expect the tree to match the saved snapshot\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders with different username and matches snapshot', () => {\n    const tree = renderer.create(<WelcomeMessage username=\"Bob\" />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n});\n\n/* Example .snap file content (for the first test):\n\nexports[`WelcomeMessage Component renders correctly and matches snapshot 1`] = `\n<h1>\n  Welcome, \n  Alice\n  !\n</h1>\n`;\n\nexports[`WelcomeMessage Component renders with different username and matches snapshot 1`] = `\n<h1>\n  Welcome, \n  Bob\n  !\n</h1>\n`;\n\n*/\n```",
          "tags": [
            "jest",
            "snapshot-testing",
            "react-test-renderer",
            "code-challenge"
          ],
          "prerequisites": [
            "theory_jest_snapshots"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_rtl_form_validation",
          "title": "Implement and Test a Simple User Registration Form with RTL",
          "description": "\nImplement a `RegistrationForm` component that includes a 'Username' input, 'Password' input, and a 'Submit' button. The form should have basic client-side validation:\n\n1.  Username: Must be at least 3 characters long.\n2.  Password: Must be at least 6 characters long.\n\nYour task is to:\n-   Create the `RegistrationForm` component.\n-   Write a test suite using React Testing Library to cover the following scenarios:\n    -   Initial render: Ensure inputs and button are present and button is initially disabled.\n    -   Invalid input: Typing short username/password should keep the button disabled and display an error message for each field when inputs are touched/blurred.\n    -   Valid input: Typing valid username/password should enable the button and hide error messages.\n    -   Form submission: Submitting a valid form should call a mock `onSubmit` handler with the correct data.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// RegistrationForm.tsx\nconst RegistrationForm = ({ onSubmit }) => {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [usernameError, setUsernameError] = useState('');\n  const [passwordError, setPasswordError] = useState('');\n\n  const validateUsername = (value) => {\n    if (value.length < 3) {\n      setUsernameError('Username must be at least 3 characters.');\n      return false;\n    } else {\n      setUsernameError('');\n      return true;\n    }\n  };\n\n  const validatePassword = (value) => {\n    if (value.length < 6) {\n      setPasswordError('Password must be at least 6 characters.');\n      return false;\n    } else {\n      setPasswordError('');\n      return true;\n    }\n  };\n\n  const isFormValid = username.length >= 3 && password.length >= 6;\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (isFormValid) {\n      onSubmit({ username, password });\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"username-input\">Username:</label>\n        <input\n          id=\"username-input\"\n          type=\"text\"\n          value={username}\n          onChange={(e) => {\n            setUsername(e.target.value);\n            validateUsername(e.target.value);\n          }}\n          onBlur={() => validateUsername(username)} // Validate on blur too\n        />\n        {usernameError && <div data-testid=\"username-error\" style={{ color: 'red' }}>{usernameError}</div>}\n      </div>\n      <div>\n        <label htmlFor=\"password-input\">Password:</label>\n        <input\n          id=\"password-input\"\n          type=\"password\"\n          value={password}\n          onChange={(e) => {\n            setPassword(e.target.value);\n            validatePassword(e.target.value);\n          }}\n          onBlur={() => validatePassword(password)} // Validate on blur too\n        />\n        {passwordError && <div data-testid=\"password-error\" style={{ color: 'red' }}>{passwordError}</div>}\n      </div>\n      <button type=\"submit\" disabled={!isFormValid}>Register</button>\n    </form>\n  );\n};\n\nexport default RegistrationForm;\n\n// RegistrationForm.test.tsx\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport RegistrationForm from './RegistrationForm';\n\ndescribe('RegistrationForm', () => {\n  const mockOnSubmit = jest.fn();\n\n  beforeEach(() => {\n    mockOnSubmit.mockClear();\n  });\n\n  // TODO: Implement test cases\n});\n",
          "solutionCode": "import React, { useState } from 'react';\n\nconst RegistrationForm = ({ onSubmit }) => {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [usernameError, setUsernameError] = useState('');\n  const [passwordError, setPasswordError] = useState('');\n\n  const validateUsername = (value) => {\n    if (value.length < 3) {\n      setUsernameError('Username must be at least 3 characters.');\n      return false;\n    } else {\n      setUsernameError('');\n      return true;\n    }\n  };\n\n  const validatePassword = (value) => {\n    if (value.length < 6) {\n      setPasswordError('Password must be at least 6 characters.');\n      return false;\n    } else {\n      setPasswordError('');\n      return true;\n    }\n  };\n\n  const isFormValid = username.length >= 3 && password.length >= 6;\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (isFormValid) {\n      onSubmit({ username, password });\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor=\"username-input\">Username:</label>\n        <input\n          id=\"username-input\"\n          type=\"text\"\n          value={username}\n          onChange={(e) => {\n            setUsername(e.target.value);\n            // Validate immediately on change for responsiveness, but also on blur for final check\n            validateUsername(e.target.value); \n          }}\n          onBlur={() => validateUsername(username)} \n        />\n        {usernameError && <div data-testid=\"username-error\" style={{ color: 'red' }}>{usernameError}</div>}\n      </div>\n      <div>\n        <label htmlFor=\"password-input\">Password:</label>\n        <input\n          id=\"password-input\"\n          type=\"password\"\n          value={password}\n          onChange={(e) => {\n            setPassword(e.target.value);\n            // Validate immediately on change for responsiveness, but also on blur for final check\n            validatePassword(e.target.value); \n          }}\n          onBlur={() => validatePassword(password)} \n        />\n        {passwordError && <div data-testid=\"password-error\" style={{ color: 'red' }}>{passwordError}</div>}\n      </div>\n      <button type=\"submit\" disabled={!isFormValid}>Register</button>\n    </form>\n  );\n};\n\nexport default RegistrationForm;\n\n// RegistrationForm.test.tsx\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport RegistrationForm from './RegistrationForm';\n\ndescribe('RegistrationForm', () => {\n  const mockOnSubmit = jest.fn();\n\n  beforeEach(() => {\n    mockOnSubmit.mockClear();\n  });\n\n  it('renders with initial empty fields and disabled button', () => {\n    render(<RegistrationForm onSubmit={mockOnSubmit} />);\n    expect(screen.getByLabelText(/username/i)).toHaveValue('');\n    expect(screen.getByLabelText(/password/i)).toHaveValue('');\n    expect(screen.getByRole('button', { name: /register/i })).toBeDisabled();\n    expect(screen.queryByTestId('username-error')).not.toBeInTheDocument();\n    expect(screen.queryByTestId('password-error')).not.toBeInTheDocument();\n  });\n\n  it('shows error messages for invalid username on blur', async () => {\n    render(<RegistrationForm onSubmit={mockOnSubmit} />);\n    const usernameInput = screen.getByLabelText(/username/i);\n    fireEvent.change(usernameInput, { target: { value: 'ab' } }); // Less than 3 chars\n    fireEvent.blur(usernameInput);\n\n    await waitFor(() => {\n      expect(screen.getByTestId('username-error')).toHaveTextContent('Username must be at least 3 characters.');\n    });\n    expect(screen.getByRole('button', { name: /register/i })).toBeDisabled();\n  });\n\n  it('shows error messages for invalid password on blur', async () => {\n    render(<RegistrationForm onSubmit={mockOnSubmit} />);\n    const passwordInput = screen.getByLabelText(/password/i);\n    fireEvent.change(passwordInput, { target: { value: '123' } }); // Less than 6 chars\n    fireEvent.blur(passwordInput);\n\n    await waitFor(() => {\n      expect(screen.getByTestId('password-error')).toHaveTextContent('Password must be at least 6 characters.');\n    });\n    expect(screen.getByRole('button', { name: /register/i })).toBeDisabled();\n  });\n\n  it('enables button and hides errors with valid inputs', async () => {\n    render(<RegistrationForm onSubmit={mockOnSubmit} />);\n    const usernameInput = screen.getByLabelText(/username/i);\n    const passwordInput = screen.getByLabelText(/password/i);\n\n    fireEvent.change(usernameInput, { target: { value: 'validuser' } });\n    fireEvent.change(passwordInput, { target: { value: 'validpass' } });\n    \n    // Trigger blur to ensure errors are gone if they were previously shown\n    fireEvent.blur(usernameInput);\n    fireEvent.blur(passwordInput);\n\n    await waitFor(() => {\n      expect(screen.getByRole('button', { name: /register/i })).toBeEnabled();\n    });\n    expect(screen.queryByTestId('username-error')).not.toBeInTheDocument();\n    expect(screen.queryByTestId('password-error')).not.toBeInTheDocument();\n  });\n\n  it('calls onSubmit with correct data on valid submission', async () => {\n    render(<RegistrationForm onSubmit={mockOnSubmit} />);\n    const usernameInput = screen.getByLabelText(/username/i);\n    const passwordInput = screen.getByLabelText(/password/i);\n    const registerButton = screen.getByRole('button', { name: /register/i });\n\n    fireEvent.change(usernameInput, { target: { value: 'testuser' } });\n    fireEvent.change(passwordInput, { target: { value: 'testpassword' } });\n\n    // Ensure button is enabled before clicking\n    await waitFor(() => { expect(registerButton).toBeEnabled(); });\n    \n    fireEvent.click(registerButton);\n\n    expect(mockOnSubmit).toHaveBeenCalledTimes(1);\n    expect(mockOnSubmit).toHaveBeenCalledWith({ username: 'testuser', password: 'testpassword' });\n  });\n\n  it('does not call onSubmit on invalid submission', () => {\n    render(<RegistrationForm onSubmit={mockOnSubmit} />);\n    const usernameInput = screen.getByLabelText(/username/i);\n    const registerButton = screen.getByRole('button', { name: /register/i });\n\n    fireEvent.change(usernameInput, { target: { value: 'sh' } }); // Invalid username\n    expect(registerButton).toBeDisabled(); // Should remain disabled\n    fireEvent.click(registerButton);\n\n    expect(mockOnSubmit).not.toHaveBeenCalled();\n  });\n});\n",
          "testCases": [
            "Initial render: inputs are empty, button disabled, no errors shown.",
            "Invalid username (less than 3 chars): typing and blurring shows error, button remains disabled.",
            "Invalid password (less than 6 chars): typing and blurring shows error, button remains disabled.",
            "Valid username but invalid password: button disabled, both errors shown on blur.",
            "Valid password but invalid username: button disabled, both errors shown on blur.",
            "Both valid: button enabled, no errors shown.",
            "Submit valid form: onSubmit handler is called with correct data.",
            "Submit invalid form: onSubmit handler is NOT called."
          ],
          "hints": [
            "Use `screen.getByLabelText` to select form inputs.",
            "Use `fireEvent.change` to simulate typing into inputs.",
            "Use `fireEvent.blur` to trigger validation on blur.",
            "Use `expect(element).toBeDisabled()` and `toBeEnabled()` for button state.",
            "Use `expect(mockFunction).toHaveBeenCalledWith()` to verify form submission data.",
            "Remember to use `await waitFor` for checking error messages that appear after user interaction and state updates."
          ],
          "tags": [
            "react",
            "form",
            "validation",
            "react-testing-library",
            "rtl",
            "jest",
            "unit-testing"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_react_testing_library",
            "react_forms",
            "jest_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "form_handling",
            "state_management",
            "event_handling",
            "client_side_validation"
          ]
        },
        {
          "id": "task_rtl_async_component",
          "title": "Test an Asynchronous Data Fetching Component with RTL",
          "description": "\nCreate a `UserList` component that fetches a list of users from a simulated API call and displays them. During the loading process, it should show a 'Loading...' message, and if there's an error, it should display an 'Error: ...' message. Otherwise, it should display a list of user names.\n\nYour task is to:\n-   Implement the `UserList` component using `useState` and `useEffect`.\n-   Create a mock API function (`fetchUsers`) that simulates successful data fetching and also a scenario for API errors.\n-   Write a test suite using React Testing Library to cover:\n    -   Initial loading state.\n    -   Successful data fetching and displaying the list of users.\n    -   Error handling: Displaying an error message if the API call fails.\n    -   No users found state (e.g., if API returns an empty array).\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// Simulate API call (e.g., in api.js or in the test file)\nconst fetchUsers = async (shouldFail = false) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (shouldFail) {\n        reject(new Error('Failed to fetch users.'));\n      } else {\n        resolve([{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]);\n      }\n    }, 100);\n  });\n};\n\n// UserList.tsx\nconst UserList = () => {\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const loadUsers = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        const data = await fetchUsers(); // This will be mocked in tests\n        setUsers(data);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n    loadUsers();\n  }, []);\n\n  if (loading) {\n    return <div>Loading users...</div>;\n  }\n\n  if (error) {\n    return <div data-testid=\"error-message\">Error: {error}</div>;\n  }\n\n  if (users.length === 0) {\n    return <div>No users found.</div>;\n  }\n\n  return (\n    <div>\n      <h2>User List</h2>\n      <ul>\n        {users.map(user => <li key={user.id}>{user.name}</li>)}\n      </ul>\n    </div>\n  );\n};\n\nexport default UserList;\n\n// UserList.test.tsx\nimport { render, screen, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport UserList from './UserList';\n\n// Mock the fetchUsers API call globally or locally for tests\njest.mock('./UserList', () => ({\n  __esModule: true, // This is important for default exports\n  default: jest.fn(() => {\n    // Here you can control the mock behavior\n    return 'Mocked UserList'; // Placeholder, replace with actual component for testing\n  }),\n}));\n\ndescribe('UserList', () => {\n  // TODO: Implement test cases\n});\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// Simulate API call (e.g., in api.js or in the test file)\nconst fetchUsers = async (shouldFail = false, emptyResult = false) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (shouldFail) {\n        reject(new Error('Failed to fetch users.'));\n      } else if (emptyResult) {\n        resolve([]);\n      } else {\n        resolve([{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]);\n      }\n    }, 100);\n  });\n};\n\n// UserList.tsx\nconst UserList = () => {\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const loadUsers = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        // IMPORTANT: Use the actual fetchUsers function if it's imported correctly\n        // The test will mock this specific import path\n        const data = await fetchUsers(); \n        setUsers(data);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n    loadUsers();\n  }, []);\n\n  if (loading) {\n    return <div>Loading users...</div>;\n  }\n\n  if (error) {\n    return <div data-testid=\"error-message\">Error: {error}</div>;\n  }\n\n  if (users.length === 0) {\n    return <div>No users found.</div>;\n  }\n\n  return (\n    <div>\n      <h2>User List</h2>\n      <ul>\n        {users.map(user => <li key={user.id}>{user.name}</li>)}\n      </ul>\n    </div>\n  );\n};\n\nexport default UserList;\n\n// UserList.test.tsx\nimport { render, screen, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport UserList from './UserList';\n\n// Mock the specific `fetchUsers` function that UserList imports\n// We need to mock it in the context of the component under test.\n// The best way is to put fetchUsers in a separate file (e.g. api.ts) and mock that file.\n// For simplicity within a single file example, we can mock the module directly.\n\njest.mock('./UserList', () => {\n  // Get the actual module so we can mock specific functions within it\n  const originalModule = jest.requireActual('./UserList');\n  return {\n    __esModule: true,\n    ...originalModule,\n    fetchUsers: jest.fn(), // Mock the fetchUsers function imported by UserList\n  };\n});\n\n// If fetchUsers was in a separate file like `api.ts`:\n// import { fetchUsers } from '../api';\n// jest.mock('../api');\n\ndescribe('UserList', () => {\n  // Access the mocked function directly after mocking the module\n  const mockFetchUsers = require('./UserList').fetchUsers; // Adjust path if fetchUsers is elsewhere\n\n  beforeEach(() => {\n    mockFetchUsers.mockClear();\n  });\n\n  it('displays loading message initially', () => {\n    mockFetchUsers.mockReturnValueOnce(new Promise(() => {})); // Never resolve to keep loading\n    render(<UserList />);\n    expect(screen.getByText(/loading users/i)).toBeInTheDocument();\n  });\n\n  it('displays users after successful fetch', async () => {\n    const users = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n    mockFetchUsers.mockResolvedValueOnce(users);\n\n    render(<UserList />);\n    \n    // Wait for loading message to disappear and user names to appear\n    await waitFor(() => {\n      expect(screen.queryByText(/loading users/i)).not.toBeInTheDocument();\n      expect(screen.getByText('Alice')).toBeInTheDocument();\n      expect(screen.getByText('Bob')).toBeInTheDocument();\n    });\n    expect(screen.getByRole('heading', { name: /user list/i })).toBeInTheDocument();\n  });\n\n  it('displays error message on fetch failure', async () => {\n    mockFetchUsers.mockRejectedValueOnce(new Error('Network error!'));\n\n    render(<UserList />);\n\n    await waitFor(() => {\n      expect(screen.queryByText(/loading users/i)).not.toBeInTheDocument();\n      expect(screen.getByTestId('error-message')).toHaveTextContent('Error: Network error!');\n    });\n  });\n\n  it('displays no users found message when API returns empty array', async () => {\n    mockFetchUsers.mockResolvedValueOnce([]); // Mock an empty array response\n\n    render(<UserList />);\n\n    await waitFor(() => {\n      expect(screen.queryByText(/loading users/i)).not.toBeInTheDocument();\n      expect(screen.getByText('No users found.')).toBeInTheDocument();\n    });\n  });\n});\n",
          "testCases": [
            "Component renders 'Loading users...' initially.",
            "After successful API call, 'Loading users...' disappears and 'Alice' and 'Bob' are displayed.",
            "After API call fails, 'Loading users...' disappears and an 'Error: Failed to fetch users.' message is displayed.",
            "After API call returns an empty array, 'Loading users...' disappears and 'No users found.' message is displayed.",
            "Ensure `fetchUsers` mock is called exactly once for each test."
          ],
          "hints": [
            "Use `jest.mock()` to mock the `fetchUsers` function. Make sure to clear mocks (`mockClear()`) before each test.",
            "Use `mockResolvedValueOnce()` and `mockRejectedValueOnce()` to control the mock's return value for specific test cases.",
            "Employ `await waitFor()` to wait for asynchronous updates to the DOM, such as loading indicators disappearing or data appearing.",
            "Use `screen.queryByText()` to assert the *absence* of elements (like the loading message)."
          ],
          "tags": [
            "react",
            "asynchronous",
            "api-integration",
            "react-testing-library",
            "rtl",
            "jest",
            "mocking"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "theory_react_testing_library",
            "javascript_async",
            "jest_mocking"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "useEffect",
            "useState",
            "error_handling",
            "api_integration"
          ]
        },
        {
          "id": "task_enzyme_component_interaction",
          "title": "Implement and Test a Tabs Component with Enzyme",
          "description": "\nImplement a `Tabs` component that manages multiple tab panels. The component should:\n\n1.  Render a list of tab headers (e.g., 'Tab 1', 'Tab 2').\n2.  Initially, only the first tab's content should be visible.\n3.  Clicking a tab header should display its corresponding content and hide others.\n\nYour task is to:\n-   Create the `Tabs` component, which accepts `tabs` as a prop (an array of `{ title: string, content: ReactNode }`).\n-   Write a test suite using Enzyme's `mount` method to cover the following scenarios:\n    -   Initial render: Verify the first tab header is active and its content is visible, while other content is hidden.\n    -   Tab selection: Clicking a different tab header makes it active and displays its content, hiding previously active content.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// Tabs.tsx\nconst Tabs = ({ tabs }) => {\n  const [activeIndex, setActiveIndex] = useState(0);\n\n  return (\n    <div className=\"tabs-container\">\n      <div className=\"tab-headers\">\n        {tabs.map((tab, index) => (\n          <button\n            key={index}\n            className={`tab-header ${index === activeIndex ? 'active' : ''}`}\n            onClick={() => setActiveIndex(index)}\n          >\n            {tab.title}\n          </button>\n        ))}\n      </div>\n      <div className=\"tab-content\">\n        {tabs[activeIndex] && tabs[activeIndex].content}\n      </div>\n    </div>\n  );\n};\n\nexport default Tabs;\n\n// Tabs.test.tsx\nimport { mount } from 'enzyme';\nimport Tabs from './Tabs';\n\ndescribe('Tabs Component', () => {\n  const mockTabs = [\n    { title: 'Tab 1', content: <div>Content for Tab 1</div> },\n    { title: 'Tab 2', content: <div>Content for Tab 2</div> },\n    { title: 'Tab 3', content: <div>Content for Tab 3</div> },\n  ];\n\n  // TODO: Implement test cases\n});\n",
          "solutionCode": "import React, { useState } from 'react';\n\nconst Tabs = ({ tabs }) => {\n  const [activeIndex, setActiveIndex] = useState(0);\n\n  return (\n    <div className=\"tabs-container\">\n      <div className=\"tab-headers\">\n        {tabs.map((tab, index) => (\n          <button\n            key={index}\n            className={`tab-header ${index === activeIndex ? 'active' : ''}`}\n            onClick={() => setActiveIndex(index)}\n            data-testid={`tab-header-${index}`}\n          >\n            {tab.title}\n          </button>\n        ))}\n      </div>\n      <div className=\"tab-content\">\n        {tabs[activeIndex] && tabs[activeIndex].content}\n      </div>\n    </div>\n  );\n};\n\nexport default Tabs;\n\n// Tabs.test.tsx\nimport { mount } from 'enzyme';\nimport Tabs from './Tabs';\n\ndescribe('Tabs Component', () => {\n  const mockTabs = [\n    { title: 'Tab 1', content: <div data-testid=\"tab-content-0\">Content for Tab 1</div> },\n    { title: 'Tab 2', content: <div data-testid=\"tab-content-1\">Content for Tab 2</div> },\n    { title: 'Tab 3', content: <div data-testid=\"tab-content-2\">Content for Tab 3</div> },\n  ];\n\n  it('renders with the first tab active and its content visible initially', () => {\n    const wrapper = mount(<Tabs tabs={mockTabs} />);\n\n    // Check active header\n    expect(wrapper.find('.tab-header.active').text()).toEqual('Tab 1');\n    // Check visible content\n    expect(wrapper.find('[data-testid=\"tab-content-0\"]')).toHaveLength(1);\n    // Check other content is not visible\n    expect(wrapper.find('[data-testid=\"tab-content-1\"]')).toHaveLength(0);\n    expect(wrapper.find('[data-testid=\"tab-content-2\"]')).toHaveLength(0);\n  });\n\n  it('changes active tab and displays correct content on click', () => {\n    const wrapper = mount(<Tabs tabs={mockTabs} />);\n\n    // Simulate click on 'Tab 2'\n    wrapper.find('[data-testid=\"tab-header-1\"]').simulate('click');\n    \n    // Update wrapper's internal state (important for enzyme after state changes)\n    wrapper.update();\n\n    // Check active header\n    expect(wrapper.find('.tab-header.active').text()).toEqual('Tab 2');\n    // Check visible content\n    expect(wrapper.find('[data-testid=\"tab-content-1\"]')).toHaveLength(1);\n    // Check previous content is hidden\n    expect(wrapper.find('[data-testid=\"tab-content-0\"]')).toHaveLength(0);\n  });\n\n  it('handles clicking the already active tab (no change)', () => {\n    const wrapper = mount(<Tabs tabs={mockTabs} />);\n    \n    // Click on Tab 1 (already active)\n    wrapper.find('[data-testid=\"tab-header-0\"]').simulate('click');\n    wrapper.update();\n\n    expect(wrapper.find('.tab-header.active').text()).toEqual('Tab 1');\n    expect(wrapper.find('[data-testid=\"tab-content-0\"]')).toHaveLength(1);\n    expect(wrapper.find('[data-testid=\"tab-content-1\"]')).toHaveLength(0);\n  });\n});\n",
          "testCases": [
            "Initial state: First tab is active, its content is shown, others are hidden.",
            "Clicking Tab 2: Tab 2 becomes active, its content is shown, Tab 1's content is hidden.",
            "Clicking Tab 3: Tab 3 becomes active, its content is shown, Tab 2's content is hidden.",
            "Clicking an already active tab: State and content remain unchanged.",
            "No tabs provided: Component renders gracefully (e.g., empty state or message)."
          ],
          "hints": [
            "Use `mount` for full DOM rendering to test interactions and content visibility.",
            "Use `wrapper.find()` with class names or `data-testid` to locate tab headers and content.",
            "Simulate clicks using `wrapper.find('selector').simulate('click');`",
            "After a state update triggered by `simulate`, you might need `wrapper.update()` to re-render the wrapper and reflect changes before asserting, especially for `mount` tests.",
            "Assert active tab by checking class names (e.g., `active`).",
            "Assert content visibility by checking `toHaveLength(1)` for visible content and `toHaveLength(0)` for hidden content."
          ],
          "tags": [
            "react",
            "component-design",
            "tabs",
            "enzyme",
            "interaction-testing",
            "state-management"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "theory_enzyme",
            "react_state_props"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "conditional_rendering",
            "event_handling",
            "props_drilling"
          ]
        },
        {
          "id": "task_jest_snapshot_component",
          "title": "Create a Snapshot Test for a Card Component",
          "description": "\nImplement a `Card` component that displays a title, description, and an optional image. Then, write a Jest snapshot test for this component.\n\nYour task is to:\n-   Create a `Card` functional component that accepts `title`, `description`, and `imageUrl` (optional) props.\n-   Implement a basic snapshot test for the `Card` component using `react-test-renderer`.\n-   Include at least two snapshot tests: one for a card with an image and one for a card without an image.\n",
          "difficulty": "easy",
          "startingCode": "import React from 'react';\n\n// Card.tsx\nconst Card = ({ title, description, imageUrl }) => {\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '16px', margin: '8px', borderRadius: '8px' }}>\n      {imageUrl && <img src={imageUrl} alt={title} style={{ maxWidth: '100%', height: 'auto', marginBottom: '8px' }} />}\n      <h3>{title}</h3>\n      <p>{description}</p>\n    </div>\n  );\n};\n\nexport default Card;\n\n// Card.test.tsx\nimport React from 'react';\nimport renderer from 'react-test-renderer';\nimport Card from './Card';\n\ndescribe('Card Component', () => {\n  // TODO: Implement snapshot tests\n});\n",
          "solutionCode": "import React from 'react';\n\nconst Card = ({ title, description, imageUrl }) => {\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '16px', margin: '8px', borderRadius: '8px' }}>\n      {imageUrl && <img src={imageUrl} alt={title} style={{ maxWidth: '100%', height: 'auto', marginBottom: '8px' }} />}\n      <h3>{title}</h3>\n      <p>{description}</p>\n    </div>\n  );\n};\n\nexport default Card;\n\n// Card.test.tsx\nimport React from 'react';\nimport renderer from 'react-test-renderer';\nimport Card from './Card';\n\ndescribe('Card Component', () => {\n  it('renders correctly with an image and matches snapshot', () => {\n    const tree = renderer.create(\n      <Card \n        title=\"Product Title\"\n        description=\"This is a detailed description of the product.\"\n        imageUrl=\"https://example.com/image.jpg\"\n      />\n    ).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders correctly without an image and matches snapshot', () => {\n    const tree = renderer.create(\n      <Card \n        title=\"Another Product\"\n        description=\"This card has no image.\"\n      />\n    ).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders with long text content', () => {\n    const tree = renderer.create(\n      <Card\n        title=\"A Very Long Product Title That Wraps Across Multiple Lines\"\n        description=\"This is an extremely long description that might test how the card handles overflowing text content and ensures that the layout remains stable without breaking. It should demonstrate the component's robustness in various scenarios.\"\n      />\n    ).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n});\n",
          "testCases": [
            "Card with title, description, and image.",
            "Card with title and description only (no image).",
            "Card with very long title and description to check text wrapping.",
            "Card with empty title/description (if allowed by component)."
          ],
          "hints": [
            "Remember to import `renderer` from `react-test-renderer`.",
            "Use `renderer.create(<Component />).toJSON()` to get a serializable JSON tree.",
            "The Jest matcher for snapshots is `toMatchSnapshot()`.",
            "Run Jest with `-u` (`jest -u` or `npm test -- -u`) on the first run or when intentional changes occur to generate/update snapshots."
          ],
          "tags": [
            "react",
            "component",
            "jest",
            "snapshot-testing",
            "ui-testing"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_jest_snapshots",
            "react_props"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "conditional_rendering",
            "props_drilling"
          ]
        }
      ]
    }
  }
]