[
  {
    "id": "0ce2b077-a4ec-48ad-a2b6-9188b8c4f2de",
    "startLine": 1400,
    "endLine": 1499,
    "processedDate": "2025-06-17T07:53:41.754Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_array_iteration",
          "title": "Array Iteration Methods",
          "content": "JavaScript provides several ways to iterate over array elements, each with its own use cases and benefits. Understanding these methods is crucial for efficient data processing.\n\n## `Array.prototype.forEach()`\n`forEach` executes a provided function once for each array element. It's a high-order array method, meaning it takes a callback function as an argument. The callback function can access the current `item`, its `index`, and the `array` itself.\n\n**Characteristics:**\n-   Does not return a new array (unlike `map`, `filter`).\n-   Does not modify the original array unless the callback explicitly does so.\n-   Cannot be stopped or broken out of using `break` or `return` (it iterates over all elements).\n-   It's generally preferred for simple iteration where you just need to perform an action on each element.\n\n## `for...of` Loop\nThe `for...of` loop iterates over iterable objects (like Arrays, Strings, Maps, Sets, etc.), allowing you to access the *values* of properties. It provides a more modern and concise way to loop through elements compared to traditional `for` loops when you only need the value.\n\n**Characteristics:**\n-   Iterates directly over values, not indices.\n-   Supports `break`, `continue`, and `return` to control loop flow.\n-   Works with any iterable object, making it versatile.\n-   Generally preferred for simple iteration where the index is not needed, or when working with other iterable collections.\n\n## Traditional `for` Loop for Reverse Iteration\nThe traditional `for` loop offers the most control over the iteration process, including the ability to iterate in reverse or skip elements. It's particularly useful when you need to iterate backwards through an array, which can be important for algorithms that modify the array in place or when processing elements from the end.\n\n**Characteristics:**\n-   Provides full control over iteration start, end, and step.\n-   Allows direct access to elements by index.\n-   Can be used for forward, reverse, or stepped iteration.\n-   Useful when modifying an array while iterating (e.g., removing elements from the end to avoid index issues).\n\n",
          "examples": [
            {
              "id": "example_array_iteration_forEach",
              "title": "Using forEach",
              "code": "const array = ['apple', 'banana', 'cherry'];\n\narray.forEach((item, index) => {\n  console.log(`Element at index ${index}: ${item}`);\n});\n// Expected Output:\n// Element at index 0: apple\n// Element at index 1: banana\n// Element at index 2: cherry",
              "explanation": "This example demonstrates how `forEach` iterates over each item in the `array`, providing both the `item` and its `index` to the callback function. It's a clean way to perform an action for every element.",
              "language": "javascript"
            },
            {
              "id": "example_array_iteration_forOf",
              "title": "Using for...of",
              "code": "const array = ['red', 'green', 'blue'];\n\nfor (const item of array) {\n  console.log(`Color: ${item}`);\n}\n// Expected Output:\n// Color: red\n// Color: green\n// Color: blue",
              "explanation": "The `for...of` loop directly provides the value of each element in `array` without needing to access it via an index. This is simpler and more readable when only the value is required.",
              "language": "javascript"
            },
            {
              "id": "example_array_iteration_reverseForLoop",
              "title": "Reverse Array Iteration with for loop",
              "code": "const array = [10, 20, 30, 40];\n\nfor (let i = array.length - 1; i >= 0; i--) {\n  console.log(`Element from end: ${array[i]}`);\n}\n// Expected Output:\n// Element from end: 40\n// Element from end: 30\n// Element from end: 20\n// Element from end: 10",
              "explanation": "This traditional `for` loop iterates from the last element (length - 1) down to the first (index 0). It's crucial for scenarios where processing elements from end to start is necessary, for instance, when removing items from an array to avoid shifting indices.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_array_iteration_mcq_1",
            "question_array_iteration_code_1",
            "question_array_iteration_open_1",
            "question_array_iteration_flashcard_1"
          ],
          "relatedTasks": [
            "task_implement_array_reverse_log"
          ],
          "tags": [
            "Array Methods",
            "Iteration",
            "JavaScript Fundamentals",
            "ES6"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_basics",
            "functions"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_processing",
            "algorithm_design"
          ]
        },
        {
          "id": "theory_array_reordering",
          "title": "Array Manipulation and Reordering",
          "content": "Manipulating the order of elements within an array is a common task in programming. JavaScript provides built-in methods and patterns to achieve various reordering operations, from moving single items to completely randomizing the array or sorting it based on specific criteria.\n\n## Reordering a Single Item\nMoving an item from one position to another in an array often involves removing it from its current spot and inserting it into the new one. The `splice()` method is highly versatile for this purpose, as it can remove elements, insert elements, or both simultaneously.\n\n**`Array.prototype.splice(start, deleteCount, item1, item2, ...)`**\n-   `start`: Index at which to start changing the array.\n-   `deleteCount`: An integer indicating the number of elements to remove from `start`.\n-   `item1, item2, ...`: The elements to add to the array, starting at the `start` position.\n\nTo reorder an item: first, `splice(oldIndex, 1)` removes the item. Then, `splice(newIndex, 0, item)` inserts it at the desired position.\n\n## Shuffling an Array (Fisher-Yates Algorithm)\nShuffling an array means randomizing the order of its elements. The Fisher-Yates (also known as Knuth shuffle) algorithm is a widely accepted and efficient method for doing this, ensuring that all permutations are equally likely.\n\n**Algorithm Steps:**\n1.  Iterate backwards from the last element down to the second element (index 1).\n2.  In each iteration, generate a random index `j` such that `0 <= j <= i`.\n3.  Swap the element at the current index `i` with the element at the random index `j`.\n\nThis process ensures that each element has an equal chance of ending up in any position.\n\n## Sorting Array Elements\nSorting an array arranges its elements in a specific order (ascending, descending, alphabetical, numerical, etc.). JavaScript's `Array.prototype.sort()` method is used for this, but it requires careful handling, especially for non-string types.\n\n**`Array.prototype.sort(compareFunction)`**\n-   By default, `sort()` converts elements to strings and sorts them alphabetically (lexicographically).\n-   To sort numerically or by custom logic, you must provide a `compareFunction`.\n\n**`compareFunction(a, b)` rules:**\n-   If `compareFunction(a, b)` returns a value **less than 0**, `a` will come before `b`.\n-   If `compareFunction(a, b)` returns a value **greater than 0**, `b` will come before `a`.\n-   If `compareFunction(a, b)` returns **0**, the order of `a` and `b` remains unchanged.\n\n**Sorting Objects by Property:**\nWhen sorting an array of objects, the `compareFunction` is essential. You access the specific property of `a` and `b` (e.g., `a.age`, `b.name`) and then compare them. For strings, `localeCompare()` is recommended for accurate alphabetical sorting across different languages, as it handles Unicode characters and case sensitivity better than simple `<` or `>` comparisons.",
          "examples": [
            {
              "id": "example_array_reordering_item",
              "title": "Reordering an Array Item",
              "code": "function reorderItem(arr, oldIndex, newIndex) {\n  const item = arr.splice(oldIndex, 1)[0]; // Remove item\n  arr.splice(newIndex, 0, item);           // Insert item\n  return arr;\n}\n\nlet myArray = [10, 20, 30, 40, 50];\nconsole.log(reorderItem(myArray, 1, 3)); // Move 20 (index 1) to index 3\n// Expected Output: [10, 30, 40, 20, 50]\n\nmyArray = ['A', 'B', 'C', 'D'];\nconsole.log(reorderItem(myArray, 0, 2)); // Move 'A' (index 0) to index 2\n// Expected Output: ['B', 'C', 'A', 'D']",
              "explanation": "This function `reorderItem` demonstrates how to move an element within an array using two `splice` calls. The first `splice` removes the element, returning it as an array (hence `[0]` to get the element itself). The second `splice` then inserts that element at the specified new position without removing any existing elements.",
              "language": "javascript"
            },
            {
              "id": "example_array_reordering_shuffle",
              "title": "Shuffling an Array (Fisher-Yates)",
              "code": "function shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1)); // Random index from 0 to i\n    [array[i], array[j]] = [array[j], array[i]];   // Swap elements\n  }\n  return array;\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nconsole.log(shuffle(numbers)); // Example Output: [3, 5, 1, 2, 4] (will vary)",
              "explanation": "The `shuffle` function implements the Fisher-Yates algorithm. It iterates from the end of the array. In each step, it picks a random element from the un-shuffled portion (from index 0 to `i`) and swaps it with the current element at `i`. This ensures a truly random permutation. Array destructuring `[array[i], array[j]] = [array[j], array[i]]` is used for an elegant swap.",
              "language": "javascript"
            },
            {
              "id": "example_array_reordering_sort",
              "title": "Sorting Objects by Property",
              "code": "const users = [\n  { name: 'John', age: 25, city: 'New York' },\n  { name: 'Jane', age: 30, city: 'London' },\n  { name: 'Jim', age: 20, city: 'Paris' },\n  { name: 'Alice', age: 25, city: 'Berlin' }\n];\n\n// Sort by age ascending\nconst sortedByAge = [...users].sort((a, b) => a.age - b.age);\nconsole.log('Sorted by age:', sortedByAge);\n/* Output:\n[ { name: 'Jim', age: 20, city: 'Paris' },\n  { name: 'John', age: 25, city: 'New York' },\n  { name: 'Alice', age: 25, city: 'Berlin' },\n  { name: 'Jane', age: 30, city: 'London' } ]\n*/\n\n// Sort by name alphabetically (case-insensitive)\nconst sortedByName = [...users].sort((a, b) => a.name.localeCompare(b.name));\nconsole.log('Sorted by name:', sortedByName);\n/* Output:\n[ { name: 'Alice', age: 25, city: 'Berlin' },\n  { name: 'Jane', age: 30, city: 'London' },\n  { name: 'Jim', age: 20, city: 'Paris' },\n  { name: 'John', age: 25, city: 'New York' } ]\n*/\n\n// Sort by age descending, then by name ascending for ties\nconst sortedByAgeName = [...users].sort((a, b) => {\n  if (a.age !== b.age) {\n    return b.age - a.age; // Descending age\n  }\n  return a.name.localeCompare(b.name); // Ascending name for ties\n});\nconsole.log('Sorted by age desc, then name asc:', sortedByAgeName);\n/* Output:\n[ { name: 'Jane', age: 30, city: 'London' },\n  { name: 'Alice', age: 25, city: 'Berlin' },\n  { name: 'John', age: 25, city: 'New York' },\n  { name: 'Jim', age: 20, city: 'Paris' } ]\n*/",
              "explanation": "This example shows various sorting scenarios with `Array.prototype.sort()` and a `compareFunction`. For numerical sorting (`age`), simple subtraction `a.age - b.age` works (positive for `b` before `a`, negative for `a` before `b`). For string sorting (`name`), `localeCompare()` is used for robust alphabetical comparison. The last example demonstrates multi-level sorting, handling ties by introducing a secondary comparison criterion.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_array_reordering_mcq_1",
            "question_array_reordering_code_1",
            "question_array_reordering_open_1",
            "question_array_reordering_flashcard_1",
            "question_array_reordering_mcq_2"
          ],
          "relatedTasks": [
            "task_implement_array_reorder",
            "task_implement_custom_sort_utility"
          ],
          "tags": [
            "Array Methods",
            "Sorting",
            "Shuffling",
            "Algorithms",
            "Fisher-Yates",
            "splice"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "functions",
            "math_random"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_manipulation",
            "ui_interactions",
            "game_development"
          ]
        },
        {
          "id": "theory_array_destructuring",
          "title": "Array Destructuring",
          "content": "Array destructuring is an ES6 feature that allows you to extract values from arrays into distinct variables using a syntax that mirrors array literals. It provides a more concise and readable way to unpack values from arrays, making code cleaner and more expressive.\n\n## Basic Destructuring\nIn its simplest form, array destructuring assigns elements from an array to variables declared on the left side of the assignment operator. The order of variables matters, as they are matched by index.\n\n## Skipping Elements\nSometimes you don't need all elements from an array. You can skip elements during destructuring by leaving empty commas for the positions you want to ignore.\n\n## Rest Pattern\nThe rest pattern (`...`) allows you to collect the remaining elements of an array into a new array. It must be the last variable in the destructuring assignment.\n\n## Default Values\nYou can assign default values to variables during destructuring. If the corresponding element in the array is `undefined` (or missing), the default value will be used instead. This is useful for providing fallbacks.\n\n## Swapping Variables\nOne of the most elegant uses of array destructuring is swapping the values of two variables without needing a temporary variable. This is achieved by creating a new array literal on the right-hand side with the swapped values and then destructuring it back into the original variables.\n\n## Nested Destructuring\nDestructuring can also be applied to nested arrays. You can match the structure of the nested array on the left-hand side to extract values from within it.\n\n## Functions Returning Multiple Values\nFunctions in JavaScript can only return a single value. However, by returning an array, you can use destructuring to easily unpack these 'multiple' values into distinct variables, improving the readability and usability of function return values.",
          "examples": [
            {
              "id": "example_array_destructuring_basic",
              "title": "Basic Destructuring and Skipping Elements",
              "code": "// Basic destructuring\nconst [a, b, c] = [1, 2, 3];\nconsole.log(a, b, c); // Output: 1 2 3\n\n// Skip elements\nconst [first, , third] = ['apple', 'banana', 'cherry'];\nconsole.log(first, third); // Output: apple cherry",
              "explanation": "The first part shows basic destructuring where variables `a`, `b`, and `c` are assigned values based on their position in the array. The second part demonstrates skipping elements by using empty commas, assigning only `first` and `third` values.",
              "language": "javascript"
            },
            {
              "id": "example_array_destructuring_rest_default",
              "title": "Rest Pattern and Default Values",
              "code": "// Rest pattern\nconst [head, ...tail] = [10, 20, 30, 40, 50];\nconsole.log(head, tail); // Output: 10 [20, 30, 40, 50]\n\n// Default values\nconst [x = 100, y = 200, z = 300] = [1, undefined, 5];\nconsole.log(x, y, z); // Output: 1 200 5\n\nconst [p = 1, q = 2] = [];\nconsole.log(p, q); // Output: 1 2",
              "explanation": "The rest pattern collects all remaining elements into a new array (`tail`). Default values provide a fallback if an element is `undefined` or missing from the array during assignment. Note that `null` would not trigger the default value, only `undefined`.",
              "language": "javascript"
            },
            {
              "id": "example_array_destructuring_swap_nested_function",
              "title": "Swapping Variables, Nested Destructuring, and Function Returns",
              "code": "// Swapping variables\nlet val1 = 'Hello';\nlet val2 = 'World';\n[val1, val2] = [val2, val1];\nconsole.log(val1, val2); // Output: World Hello\n\n// Nested destructuring\nconst [itemA, [itemB, itemC]] = [1, [2, 3]];\nconsole.log(itemA, itemB, itemC); // Output: 1 2 3\n\n// Functions that return multiple values\nfunction getCoordinates() {\n  return [100, 200, 'px'];\n}\nconst [coordX, coordY, unit] = getCoordinates();\nconsole.log(`X: ${coordX}, Y: ${coordY}, Unit: ${unit}`); // Output: X: 100, Y: 200, Unit: px",
              "explanation": "This example illustrates three advanced uses. Swapping variables becomes concise and elegant. Nested destructuring allows drilling into complex array structures. Finally, destructuring enables functions to effectively return multiple logical values by packaging them in an array, which can then be easily unpacked by the caller.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_array_destructuring_mcq_1",
            "question_array_destructuring_code_1",
            "question_array_destructuring_open_1",
            "question_array_destructuring_flashcard_1"
          ],
          "relatedTasks": [
            "task_implement_config_parser"
          ],
          "tags": [
            "Array Methods",
            "ES6",
            "Destructuring",
            "Syntax",
            "JavaScript Fundamentals"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_variables",
            "javascript_arrays"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "react_hooks",
            "api_response_handling",
            "modern_javascript"
          ]
        },
        {
          "id": "theory_common_array_operations",
          "title": "Common Array Utility Operations",
          "content": "Beyond basic manipulation, several common operations are frequently performed on arrays to transform, filter, or analyze their content. JavaScript provides powerful built-in features to achieve these tasks efficiently.\n\n## Creating a Range of Numbers\nGenerating a sequence of numbers (a range) is a common requirement. `Array.from()` combined with a mapping function is an elegant way to achieve this. `Array.from()` can create a new `Array` instance from an array-like or iterable object. When provided with an object having a `length` property and a mapping function, it effectively generates an array with transformed elements.\n\n**`Array.from(arrayLike, mapFn)`**\n-   `arrayLike`: An array-like object or iterable object.\n-   `mapFn`: A function to call on every element of the array-like object. It receives `(element, index)`.\n\nBy passing `{ length: N }` as `arrayLike`, you create an array of `N` `undefined` values, which the `mapFn` then transforms into the desired sequence.\n\n## Removing Duplicates using Set\nRemoving duplicate elements from an array is a classic problem. The `Set` object, introduced in ES6, provides a straightforward and efficient solution. A `Set` is a collection of unique values; it automatically discards any duplicate values added to it.\n\n**Process:**\n1.  Create a new `Set` from the array. This automatically removes duplicates.\n2.  Convert the `Set` back into an array using the spread syntax (`...`).\n\n## Finding Maximum Value\nDetermining the maximum value in a numeric array can be done using `Math.max()`. This function takes a variable number of arguments. By combining it with the spread syntax (`...`), you can pass all elements of an array as individual arguments to `Math.max()`.\n\n**`Math.max(...array)`**\n-   The spread syntax unpacks the array elements into a comma-separated list of arguments.\n\n## Checking for Common Elements\nTo determine if two arrays share any common elements, you can use a combination of array iteration methods. `Array.prototype.some()` tests whether at least one element in the array passes the test implemented by the provided function. `Array.prototype.includes()` determines whether an array includes a certain value among its entries, returning `true` or `false`.\n\n**`Array.prototype.some(callbackFn)`**\n-   `callbackFn`: A function to execute on each element, taking `(element, index, array)`.\n\n**`Array.prototype.includes(valueToFind)`**\n-   Returns `true` if `valueToFind` is found in the array, `false` otherwise.\n\nBy iterating through one array with `some()` and checking if each element is `included()` in the second array, you can efficiently detect common elements.",
          "examples": [
            {
              "id": "example_common_array_operations_range",
              "title": "Creating a Range of Numbers",
              "code": "// Create a range from 1 to 5\nconst range1to5 = Array.from({ length: 5 }, (_, i) => i + 1);\nconsole.log(range1to5); // Output: [1, 2, 3, 4, 5]\n\n// Create a range of even numbers\nconst evenNumbers = Array.from({ length: 3 }, (_, i) => (i + 1) * 2);\nconsole.log(evenNumbers); // Output: [2, 4, 6]",
              "explanation": "This example uses `Array.from()` with an object `{ length: N }` to create an array of `N` elements. The second argument is a map function that transforms each (initially undefined) element. `i` represents the index, allowing for flexible number generation.",
              "language": "javascript"
            },
            {
              "id": "example_common_array_operations_duplicates_max",
              "title": "Removing Duplicates and Finding Maximum Value",
              "code": "// Remove duplicates using Set\nconst arrWithDuplicates = [1, 2, 2, 3, 4, 4, 5, 1];\nconst uniqueArr = [...new Set(arrWithDuplicates)];\nconsole.log(uniqueArr); // Output: [1, 2, 3, 4, 5]\n\n// Find maximum value\nconst numbers = [10, 5, 8, 20, 15];\nconst maxValue = Math.max(...numbers);\nconsole.log(maxValue); // Output: 20\n\nconst emptyArray = [];\nconsole.log(Math.max(...emptyArray)); // Output: -Infinity (edge case for Math.max on empty array)",
              "explanation": "The `Set` object inherently stores only unique values, making it ideal for duplicate removal. Spreading an array into a `Set` removes duplicates, and then spreading the `Set` back into an array converts it to an array. `Math.max` used with the spread operator (`...`) is the concise way to find the largest number in a numeric array.",
              "language": "javascript"
            },
            {
              "id": "example_common_array_operations_common_elements",
              "title": "Checking for Common Elements",
              "code": "function hasCommonElement(arr1, arr2) {\n  return arr1.some(item => arr2.includes(item));\n}\n\nconst arrayA = [1, 2, 3, 4];\nconst arrayB = [3, 5, 6, 7];\nconst arrayC = [8, 9, 10];\n\nconsole.log(hasCommonElement(arrayA, arrayB)); // Output: true (because of 3)\nconsole.log(hasCommonElement(arrayA, arrayC)); // Output: false\nconsole.log(hasCommonElement([], arrayB));     // Output: false (edge case: empty array)",
              "explanation": "The `hasCommonElement` function efficiently checks for shared elements. `arr1.some(...)` iterates over `arrayA`. For each `item` from `arrayA`, `arr2.includes(item)` checks if that `item` exists in `arrayB`. If `includes` returns `true` for any `item`, `some` immediately returns `true`, indicating a common element. This avoids iterating through the entire arrays unnecessarily once a common element is found.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_common_array_operations_mcq_1",
            "question_common_array_operations_code_1",
            "question_common_array_operations_open_1",
            "question_common_array_operations_flashcard_1",
            "question_common_array_operations_mcq_2"
          ],
          "relatedTasks": [
            "task_implement_array_utilities"
          ],
          "tags": [
            "Array Methods",
            "Set",
            "Math",
            "ES6",
            "Utility Functions",
            "Data Manipulation"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "es6_features",
            "higher_order_functions"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_transformation",
            "form_validation",
            "frontend_utilities"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_array_iteration_mcq_1",
          "topic": "Array Iteration Methods",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following array iteration methods does NOT allow you to easily stop or break out of the loop using `break` or `return`?",
          "answer": "forEach",
          "options": [
            "for...of",
            "for loop",
            "while loop",
            "forEach"
          ],
          "analysisPoints": [
            "Understanding of control flow within different loop types.",
            "Specific characteristics of `forEach` as a higher-order function."
          ],
          "keyConcepts": [
            "Array.prototype.forEach()",
            "for...of loop",
            "Traditional for loop",
            "Loop control statements"
          ],
          "evaluationCriteria": [
            "Recall of `forEach` limitations.",
            "Ability to differentiate loop types based on control flow."
          ],
          "example": "```javascript\nconst numbers = [1, 2, 3, 4, 5];\n\n// Using forEach (cannot break)\nlet sumForEach = 0;\nnumbers.forEach(num => {\n  sumForEach += num;\n  if (sumForEach > 6) { /* Cannot 'break' here */ }\n});\nconsole.log('ForEach sum:', sumForEach); // Will sum all numbers\n\n// Using for...of (can break)\nlet sumForOf = 0;\nfor (const num of numbers) {\n  sumForOf += num;\n  if (sumForOf > 6) {\n    break; // Loop stops here\n  }\n}\nconsole.log('For...of sum:', sumForOf); // Will sum up to 3 (1+2+3=6, next is 4 so 10 > 6, then breaks)\n\n// Using for loop (can break)\nlet sumFor = 0;\nfor (let i = 0; i < numbers.length; i++) {\n  sumFor += numbers[i];\n  if (sumFor > 6) {\n    break; // Loop stops here\n  }\n}\nconsole.log('For loop sum:', sumFor); // Will sum up to 3 (1+2+3=6, next is 4 so 10 > 6, then breaks)\n```\nThe `forEach` method is designed to iterate over all elements. While a `return` statement inside its callback will exit the *current* callback invocation, it will not stop the `forEach` loop from continuing to the next element. `break` is not allowed in `forEach` callbacks. In contrast, `for...of` and traditional `for` loops fully support `break` and `continue`.",
          "tags": [
            "Array Methods",
            "forEach",
            "for...of",
            "Loop Control"
          ],
          "prerequisites": [
            "javascript_arrays",
            "control_flow"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_iteration_code_1",
          "topic": "Array Iteration Methods",
          "level": "medium",
          "type": "code",
          "question": "Write a JavaScript function `logElementsInReverse` that takes an array as input and logs each element to the console, starting from the last element and ending with the first. You must use a traditional `for` loop for this task.",
          "answer": "```javascript\nfunction logElementsInReverse(arr) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    console.log(arr[i]);\n  }\n}\n\n// Test cases:\nlogElementsInReverse([1, 2, 3]);    // Expected: 3, 2, 1\nlogElementsInReverse(['a', 'b']);   // Expected: 'b', 'a'\nlogElementsInReverse([]);           // Expected: (no output)\nlogElementsInReverse([null, 'test']); // Expected: 'test', null\n```",
          "options": [],
          "analysisPoints": [
            "Correct initialization of loop counter (`arr.length - 1`).",
            "Correct loop condition (`i >= 0`).",
            "Correct decrement of loop counter (`i--`).",
            "Accessing array elements by index.",
            "Handling edge cases like empty arrays."
          ],
          "keyConcepts": [
            "Traditional for loop",
            "Reverse iteration",
            "Array indexing",
            "Edge case handling"
          ],
          "evaluationCriteria": [
            "Correctness of loop logic.",
            "Efficiency of the solution.",
            "Handling of boundary conditions."
          ],
          "example": "The solution correctly initializes the loop counter `i` to the last valid index (`arr.length - 1`). The loop continues as long as `i` is greater than or equal to `0`, covering all elements down to the first. `i--` ensures iteration in reverse order. Accessing `arr[i]` retrieves the element at the current index. For an empty array, `arr.length - 1` will be -1, causing the loop condition `i >= 0` to be immediately false, and thus no elements are logged, which is the correct behavior.",
          "tags": [
            "Array Iteration",
            "for loop",
            "Reverse",
            "Basic Algorithm"
          ],
          "prerequisites": [
            "javascript_arrays",
            "control_flow"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_iteration_open_1",
          "topic": "Array Iteration Methods",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast `Array.prototype.forEach()` and the `for...of` loop for iterating over arrays. Discuss their primary use cases, advantages, and disadvantages.",
          "answer": "### `Array.prototype.forEach()`\n**Use Cases:**\n-   When you need to execute a function for each element and potentially access the index or the original array.\n-   Performing side effects (e.g., logging, updating DOM elements) for each item.\n\n**Advantages:**\n-   **Concise and readable** for simple iterations where a function needs to be applied to each element.\n-   Provides access to `item`, `index`, and the `array` itself in the callback.\n-   Part of the Array prototype, aligning with functional programming paradigms.\n\n**Disadvantages:**\n-   **Cannot break or continue** the loop: `return` only exits the current callback, not the `forEach` iteration.\n-   **Synchronous**: It doesn't handle asynchronous operations well within the loop itself (e.g., `await` inside `forEach` callback won't wait for each promise to resolve before moving to the next iteration).\n-   Less control over iteration start, end, or step.\n\n### `for...of` Loop\n**Use Cases:**\n-   When you need to iterate directly over the *values* of an iterable (arrays, strings, Maps, Sets, NodeLists, etc.).\n-   When you need to use `break`, `continue`, or `return` to control the loop's flow.\n-   When working with asynchronous operations (e.g., `await` works correctly inside `for...of`).\n\n**Advantages:**\n-   **Direct access to values**: More semantic if you only need the element value.\n-   **Supports `break`, `continue`, and `return`**: Offers full control over loop execution.\n-   **Works with any iterable**: More general-purpose than `forEach`.\n-   **Handles asynchronous operations naturally**: `await` pauses the loop until the promise resolves.\n\n**Disadvantages:**\n-   **No direct index access**: You need a counter variable (`let i = 0; i++`) if you also need the index.\n-   Can be slightly more verbose than `forEach` for simple transformations if an index is explicitly added.\n\n**Comparison Summary:**\n-   `forEach` is a higher-order function, good for applying a function to each element. `for...of` is a loop construct, good for iterating over values of any iterable.\n-   `forEach` is synchronous and does not allow premature termination. `for...of` allows full control over loop flow with `break`/`continue` and supports `await`.\n-   `forEach` provides the index automatically; `for...of` requires manual index tracking if needed.\n\nChoose `forEach` for simple, complete iterations or side effects where control flow is not an issue. Choose `for...of` when you need loop control, asynchronous handling, or are iterating over non-array iterables or only need values.",
          "options": [],
          "analysisPoints": [
            "Ability to list advantages and disadvantages for both methods.",
            "Understanding of their respective control flow mechanisms.",
            "Knowledge of suitable use cases for each.",
            "Awareness of `forEach`'s limitations with `break`/`continue` and `async/await`.",
            "Understanding of `for...of`'s generality for iterables."
          ],
          "keyConcepts": [
            "Array.prototype.forEach()",
            "for...of loop",
            "Loop control statements",
            "Synchronous vs. Asynchronous iteration",
            "Higher-order functions",
            "Iterables"
          ],
          "evaluationCriteria": [
            "Depth of comparison.",
            "Accuracy of technical details.",
            "Clarity and structure of explanation.",
            "Demonstration of practical understanding."
          ],
          "example": "",
          "tags": [
            "Array Methods",
            "Iteration",
            "Comparison",
            "JavaScript Fundamentals",
            "ES6"
          ],
          "prerequisites": [
            "javascript_arrays",
            "control_flow",
            "functions",
            "async_javascript"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_iteration_flashcard_1",
          "topic": "Array Iteration Methods",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference between `array.forEach()` and `for...of` regarding element access?",
          "answer": "`array.forEach()` provides access to both the element `item` and its `index` (and the `array` itself) in its callback, whereas `for...of` directly provides only the element `value`.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "forEach",
            "for...of",
            "Array iteration",
            "Index access",
            "Value access"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "Array Methods",
            "Iteration",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_reordering_mcq_1",
          "topic": "Array Manipulation and Reordering",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following JavaScript code, what will be the output after executing `reorderItem(myArray, 2, 0)`?\n\n```javascript\nfunction reorderItem(arr, oldIndex, newIndex) {\n  const item = arr.splice(oldIndex, 1)[0];\n  arr.splice(newIndex, 0, item);\n  return arr;\n}\n\nlet myArray = ['A', 'B', 'C', 'D', 'E'];\n// console.log(reorderItem(myArray, 2, 0));\n```",
          "answer": "['C', 'A', 'B', 'D', 'E']",
          "options": [
            "['C', 'A', 'B', 'D', 'E']",
            "['A', 'B', 'D', 'C', 'E']",
            "['A', 'C', 'B', 'D', 'E']",
            "['A', 'B', 'C', 'D', 'E']"
          ],
          "analysisPoints": [
            "Understanding of `Array.prototype.splice()` behavior for removal.",
            "Understanding of `Array.prototype.splice()` behavior for insertion.",
            "Tracing the array state after each `splice` operation."
          ],
          "keyConcepts": [
            "Array.prototype.splice()",
            "Array reordering",
            "In-place modification"
          ],
          "evaluationCriteria": [
            "Ability to mentally trace array operations.",
            "Correct application of `splice` method arguments."
          ],
          "example": "Initial `myArray`: `['A', 'B', 'C', 'D', 'E']`\n\n1.  `const item = arr.splice(oldIndex, 1)[0];`\n    -   `oldIndex` is 2, so `arr.splice(2, 1)` removes `C`.\n    -   `item` becomes `'C'`.\n    -   `arr` becomes `['A', 'B', 'D', 'E']`.\n\n2.  `arr.splice(newIndex, 0, item);`\n    -   `newIndex` is 0, so `arr.splice(0, 0, 'C')` inserts `C` at index 0.\n    -   `arr` becomes `['C', 'A', 'B', 'D', 'E']`.\n\nTherefore, the final output is `['C', 'A', 'B', 'D', 'E']`.",
          "tags": [
            "Array Methods",
            "splice",
            "Reordering"
          ],
          "prerequisites": [
            "javascript_arrays",
            "array_splice"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_reordering_code_1",
          "topic": "Array Manipulation and Reordering",
          "level": "hard",
          "type": "code",
          "question": "Implement a function `sortUsersByMultipleCriteria(users)` that sorts an array of user objects. Each user object has `name` (string) and `score` (number) properties. The sorting should follow these rules:\n1.  Primary sort: Descending order by `score`.\n2.  Secondary sort (for ties in score): Ascending alphabetical order by `name`.\n\nYour function should return a *new* sorted array, leaving the original array unchanged.",
          "answer": "```javascript\nfunction sortUsersByMultipleCriteria(users) {\n  // Create a shallow copy to avoid modifying the original array\n  return [...users].sort((a, b) => {\n    // Primary sort: by score (descending)\n    if (a.score !== b.score) {\n      return b.score - a.score; // b - a for descending numerical sort\n    }\n    // Secondary sort: by name (ascending) for ties in score\n    return a.name.localeCompare(b.name); // a.localeCompare(b) for ascending alphabetical sort\n  });\n}\n\n// Test Cases:\nconst testUsers1 = [\n  { name: 'John', score: 85 },\n  { name: 'Jane', score: 90 },\n  { name: 'Jim', score: 85 },\n  { name: 'Alice', score: 90 },\n  { name: 'Bob', score: 70 }\n];\n\nconst sortedUsers1 = sortUsersByMultipleCriteria(testUsers1);\nconsole.log('Test Case 1 Sorted:', sortedUsers1);\n/* Expected Output:\n[\n  { name: 'Alice', score: 90 },\n  { name: 'Jane', score: 90 },\n  { name: 'Jim', score: 85 },\n  { name: 'John', score: 85 },\n  { name: 'Bob', score: 70 }\n]\n*/\n\nconsole.log('Original Array Unchanged:', testUsers1); // Should be the original order\n\nconst testUsers2 = [\n  { name: 'Zoe', score: 100 },\n  { name: 'Aaron', score: 100 }\n];\nconst sortedUsers2 = sortUsersByMultipleCriteria(testUsers2);\nconsole.log('Test Case 2 Sorted:', sortedUsers2);\n/* Expected Output:\n[\n  { name: 'Aaron', score: 100 },\n  { name: 'Zoe', score: 100 }\n]\n*/\n\nconst testUsers3 = [];\nconsole.log('Test Case 3 (Empty Array):', sortUsersByMultipleCriteria(testUsers3)); // Expected: []\n```",
          "options": [],
          "analysisPoints": [
            "Correct usage of `Array.prototype.sort()` with a custom comparison function.",
            "Implementing multi-criteria sorting logic (if-else or similar structure).",
            "Correctly handling numerical descending sort (`b.score - a.score`).",
            "Correctly handling string ascending sort (`a.name.localeCompare(b.name)`).",
            "Ensuring the original array is not mutated (using spread syntax for shallow copy)."
          ],
          "keyConcepts": [
            "Array.prototype.sort()",
            "Comparison function",
            "Multi-criteria sorting",
            "Immutability",
            "localeCompare()"
          ],
          "evaluationCriteria": [
            "Correctness of sorting logic.",
            "Adherence to immutability.",
            "Efficiency of the comparison function.",
            "Handling of edge cases (e.g., empty array, all scores tied)."
          ],
          "example": "The solution utilizes `[...users].sort()` to create a shallow copy of the array before sorting, thus preserving the original array's immutability. The `compareFunction` first checks if scores are different; if so, it sorts in descending order (`b.score - a.score`). If scores are equal, it proceeds to the secondary sort, using `a.name.localeCompare(b.name)` for ascending alphabetical order of names. This logic correctly implements the requested sorting rules.",
          "tags": [
            "Array Methods",
            "Sorting",
            "Algorithms",
            "Immutability",
            "Objects"
          ],
          "prerequisites": [
            "javascript_arrays",
            "functions",
            "object_properties"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_array_reordering_open_1",
          "topic": "Array Manipulation and Reordering",
          "level": "medium",
          "type": "open",
          "question": "Explain the Fisher-Yates shuffle algorithm. Why is it considered a good method for shuffling an array, and what are its key advantages over simpler approaches like `array.sort(() => Math.random() - 0.5)`?",
          "answer": "The Fisher-Yates shuffle (also known as the Knuth shuffle) is an algorithm for generating a random permutation of a finite sequence. The basic idea is to iterate the array from the last element down to the second (index 1). In each iteration, a random element from the *unshuffled* portion of the array (from index 0 up to the current index `i` inclusive) is selected and swapped with the element at the current index `i`.\n\n**Algorithm Steps (Backward Iteration):**\n1.  Start from the last element, `i = array.length - 1`.\n2.  Loop while `i > 0` (down to the second element).\n3.  Generate a random index `j` such that `0 <= j <= i`.\n4.  Swap `array[i]` and `array[j]`.\n5.  Decrement `i` and repeat.\n\n**Why it's good (Advantages):**\n1.  **Uniform Distribution**: The Fisher-Yates shuffle guarantees a perfectly uniform distribution, meaning every possible permutation of the array has an exactly equal probability of occurring. This is crucial for applications requiring true randomness, like card games.\n2.  **In-place**: It shuffles the array in-place, meaning it doesn't require creating a new array, thus being memory efficient (O(1) auxiliary space).\n3.  **Efficiency**: It has a time complexity of O(n), where n is the number of elements in the array, as it performs a constant number of operations for each element.\n\n**Disadvantages of `array.sort(() => Math.random() - 0.5)`:**\nThis simpler approach, while seemingly effective, is **flawed** because:\n1.  **Non-Uniform Distribution**: It does *not* produce a uniformly random permutation. The `sort` method's stability and how comparison functions are implemented can lead to certain elements having a higher or lower probability of ending up in specific positions. For small arrays, the bias might be less noticeable, but it becomes significant with larger arrays.\n2.  **Implementation-Dependent**: The exact behavior can vary across JavaScript engines because the `sort` algorithm itself is not strictly defined in the ECMAScript standard (though most modern engines use Timsort or similar, which are stable). This makes the randomness unpredictable and unreliable.\n3.  **Less Efficient**: `sort` typically has a time complexity of O(N log N), which is less efficient than the O(N) of Fisher-Yates, especially for large arrays.",
          "options": [],
          "analysisPoints": [
            "Detailed explanation of the Fisher-Yates algorithm steps.",
            "Discussion of uniform distribution as a key advantage.",
            "Comparison of Fisher-Yates vs. `sort(() => Math.random())` in terms of randomness and efficiency.",
            "Understanding the `sort` method's internal workings and why it's not suitable for shuffling."
          ],
          "keyConcepts": [
            "Fisher-Yates Shuffle",
            "Randomization",
            "Uniform Distribution",
            "In-place Algorithm",
            "Time Complexity",
            "Array.prototype.sort()",
            "Math.random()"
          ],
          "evaluationCriteria": [
            "Accuracy of algorithm description.",
            "Clarity of explanation regarding randomness and bias.",
            "Depth of comparative analysis.",
            "Understanding of algorithmic efficiency."
          ],
          "example": "",
          "tags": [
            "Algorithms",
            "Shuffling",
            "Randomness",
            "Array Methods",
            "Fisher-Yates",
            "Best Practices"
          ],
          "prerequisites": [
            "javascript_arrays",
            "math_random",
            "algorithms_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_array_reordering_flashcard_1",
          "topic": "Array Manipulation and Reordering",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the purpose of `localeCompare()` when sorting an array of strings or objects by a string property?",
          "answer": "`localeCompare()` is used for reliable alphabetical string comparison, especially for strings containing non-ASCII characters or needing case-insensitive sorting. It accounts for different language conventions, providing a more robust and accurate sort order compared to simple `<` or `>` operators.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "localeCompare",
            "String sorting",
            "Array.prototype.sort()",
            "Unicode",
            "Internationalization"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "Array Methods",
            "Sorting",
            "String",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_reordering_mcq_2",
          "topic": "Array Manipulation and Reordering",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following `Array.prototype.sort()` comparison functions would correctly sort an array of numbers `[3, 1, 4, 1, 5, 9]` in ascending order?",
          "answer": "`numbers.sort((a, b) => a - b);`",
          "options": [
            "`numbers.sort((a, b) => b - a);`",
            "`numbers.sort();`",
            "`numbers.sort((a, b) => a - b);`",
            "`numbers.sort((a, b) => (a > b ? 1 : -1));`"
          ],
          "analysisPoints": [
            "Understanding of `Array.prototype.sort()` default behavior (string comparison).",
            "Correct logic for numerical ascending sort (`a - b`).",
            "Correct logic for numerical descending sort (`b - a`).",
            "Recognition of the strict `1` or `-1` return values vs. numerical subtraction."
          ],
          "keyConcepts": [
            "Array.prototype.sort()",
            "Comparison function",
            "Numerical sorting",
            "Ascending order"
          ],
          "evaluationCriteria": [
            "Correct application of sort comparison rules.",
            "Ability to distinguish between default and custom sorting."
          ],
          "example": "The default `numbers.sort()` would convert numbers to strings and sort lexicographically (e.g., `[1, 1, 3, 4, 5, 9]` would become `[1, 1, 3, 4, 5, 9]` for this specific set, but for `[10, 2]` it would be `[10, 2]` because '10' comes before '2').\n\n-   `numbers.sort((a, b) => b - a);` would sort in descending order.\n-   `numbers.sort((a, b) => (a > b ? 1 : -1));` is an equivalent, but more verbose, way to sort in ascending order for primitive types, similar to `a - b`. However, `a - b` is the idiomatic and most concise way for numerical sorting.\n\nTherefore, `numbers.sort((a, b) => a - b);` is the correct and most common way to achieve ascending numerical sort.",
          "tags": [
            "Array Methods",
            "Sorting",
            "Numerical Sort"
          ],
          "prerequisites": [
            "javascript_arrays",
            "array_sort"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_destructuring_mcq_1",
          "topic": "Array Destructuring",
          "level": "easy",
          "type": "mcq",
          "question": "What will be the output of the following JavaScript code snippet?\n\n```javascript\nconst [x, y, ...z] = [10, 20, 30, 40, 50];\nconsole.log(x, y, z);\n```",
          "answer": "10 20 [30, 40, 50]",
          "options": [
            "10 20 30 40 50",
            "10 20 [30, 40, 50]",
            "10 20 30",
            "Error"
          ],
          "analysisPoints": [
            "Understanding of basic array destructuring.",
            "Correct application of the rest pattern (`...`)."
          ],
          "keyConcepts": [
            "Array Destructuring",
            "Rest Pattern",
            "ES6"
          ],
          "evaluationCriteria": [
            "Recall of destructuring syntax.",
            "Ability to predict output based on rest pattern."
          ],
          "example": "The code uses array destructuring with the rest pattern. `x` gets the first element (10), `y` gets the second (20), and `...z` collects all *remaining* elements into a new array `z`. Therefore, `z` will be `[30, 40, 50]`.",
          "tags": [
            "Destructuring",
            "ES6",
            "Rest Pattern"
          ],
          "prerequisites": [
            "javascript_arrays",
            "es6_features"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_array_destructuring_code_1",
          "topic": "Array Destructuring",
          "level": "medium",
          "type": "code",
          "question": "Write a function `processUserProfile` that accepts an array representing a user profile `[id, username, email, optionalRole = 'user']`. Use array destructuring to extract `id`, `username`, `email`, and `role` (with a default value of 'user' if not provided). The function should return an object with these properties. Handle cases where `optionalRole` might be missing.",
          "answer": "```javascript\nfunction processUserProfile(profileArray) {\n  const [id, username, email, role = 'user'] = profileArray;\n  return {\n    id,\n    username,\n    email,\n    role\n  };\n}\n\n// Test cases:\nconsole.log(processUserProfile([1, 'john_doe', 'john@example.com', 'admin']));\n// Expected: { id: 1, username: 'john_doe', email: 'john@example.com', role: 'admin' }\n\nconsole.log(processUserProfile([2, 'jane_smith', 'jane@example.com']));\n// Expected: { id: 2, username: 'jane_smith', email: 'jane@example.com', role: 'user' }\n\nconsole.log(processUserProfile([3, 'guest_user', 'guest@example.com', undefined]));\n// Expected: { id: 3, username: 'guest_user', email: 'guest@example.com', role: 'user' }\n\nconsole.log(processUserProfile([4, 'dev_user', 'dev@example.com', null]));\n// Expected: { id: 4, username: 'dev_user', email: 'dev@example.com', role: null } (Important: null is not undefined)\n```",
          "options": [],
          "analysisPoints": [
            "Correct application of array destructuring syntax.",
            "Proper use of default values in destructuring.",
            "Understanding that `null` is not `undefined` for default values.",
            "Creating and returning an object from destructured values."
          ],
          "keyConcepts": [
            "Array Destructuring",
            "Default Values",
            "ES6",
            "Function Parameters"
          ],
          "evaluationCriteria": [
            "Correctness of destructuring.",
            "Accuracy of default value handling.",
            "Clarity and conciseness of code."
          ],
          "example": "The solution uses array destructuring `[id, username, email, role = 'user'] = profileArray` directly within the function. The `role = 'user'` part ensures that if `profileArray[3]` is `undefined` (either omitted or explicitly passed as `undefined`), `role` will default to `'user'`. If `profileArray[3]` is `null`, `role` will be `null` because `null` is a distinct value and not `undefined`.",
          "tags": [
            "Destructuring",
            "ES6",
            "Functions",
            "Objects"
          ],
          "prerequisites": [
            "javascript_arrays",
            "es6_features",
            "javascript_objects"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_array_destructuring_open_1",
          "topic": "Array Destructuring",
          "level": "medium",
          "type": "open",
          "question": "Describe the benefits of using array destructuring in JavaScript code. Provide at least three distinct scenarios where it significantly improves code readability or functionality.",
          "answer": "Array destructuring in JavaScript provides a powerful and concise way to extract values from arrays. Its primary benefits revolve around improving code readability, reducing boilerplate, and enabling more expressive patterns.\n\n**Benefits:**\n1.  **Readability and Conciseness**: It allows developers to declare multiple variables and assign values from an array in a single, clear line of code, mirroring the structure of the array. This reduces the need for repetitive index-based access (`arr[0]`, `arr[1]`).\n2.  **Cleaner Variable Assignment**: It streamlines the process of extracting specific elements, making code easier to understand at a glance.\n3.  **Default Values**: The ability to set default values for variables extracted from the array simplifies handling optional or potentially missing elements, reducing verbose `if` statements or logical OR operators.\n4.  **Swapping Variables Elegantly**: It provides a remarkably clean syntax for swapping the values of two variables without needing a temporary variable.\n5.  **Improved Function Return Values**: Functions can return arrays of multiple related values, and destructuring makes consuming these values much cleaner and more explicit than relying on object properties or manual indexing.\n\n**Scenarios for Improvement:**\n1.  **Swapping Two Variables**: Instead of `let temp = a; a = b; b = temp;`, you can simply write `[a, b] = [b, a];`. This is highly intuitive and reduces a common boilerplate pattern.\n    ```javascript\n    let x = 5;\n    let y = 10;\n    [x, y] = [y, x]; // x is now 10, y is now 5\n    ```\n2.  **Extracting Specific Values from an API Response or Data Row**: When an API returns data as a fixed-length array (e.g., `[id, name, status, createdDate]`), destructuring allows for direct naming of these values, improving clarity compared to `response[0]`, `response[1]`, etc.\n    ```javascript\n    const userProfile = [101, 'Alice', 'active', '2023-01-15'];\n    const [userId, userName, userStatus, createdAt] = userProfile;\n    console.log(`User ${userName} (ID: ${userId}) is ${userStatus}.`);\n    ```\n3.  **Handling Multiple Return Values from a Function**: Functions often need to return more than one piece of information (e.g., coordinates, success status and error message). Returning an array and then destructuring it makes the intent clear and usage straightforward.\n    ```javascript\n    function parseCoordinates(input) {\n      // ... parsing logic\n      if (isValid) return [true, x, y];\n      return [false, 'Invalid format'];\n    }\n\n    const [success, ...data] = parseCoordinates('10,20');\n    if (success) {\n      const [x, y] = data; // Nested destructuring for returned array\n      console.log(`Parsed X: ${x}, Y: ${y}`);\n    } else {\n      const [errorMessage] = data;\n      console.log(`Error: ${errorMessage}`);\n    }\n    ```\n    This avoids returning an object when the order is clear or when a simple tuple-like structure is desired.",
          "options": [],
          "analysisPoints": [
            "Clear articulation of array destructuring's core benefits.",
            "Providing concrete, distinct examples for each scenario.",
            "Demonstrating improved code readability/functionality in examples.",
            "Understanding common pitfalls destructuring helps avoid (e.g., temporary variables, magic numbers for array indices)."
          ],
          "keyConcepts": [
            "Array Destructuring",
            "ES6",
            "Readability",
            "Conciseness",
            "Variable Swapping",
            "Function Return Values",
            "Default Values"
          ],
          "evaluationCriteria": [
            "Comprehensiveness of benefits listed.",
            "Relevance and clarity of examples.",
            "Depth of understanding demonstrated.",
            "Structure and coherence of the explanation."
          ],
          "example": "",
          "tags": [
            "Destructuring",
            "ES6",
            "Best Practices",
            "Code Quality",
            "Functions"
          ],
          "prerequisites": [
            "javascript_arrays",
            "es6_features"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_array_destructuring_flashcard_1",
          "topic": "Array Destructuring",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you skip elements when using array destructuring?",
          "answer": "You can skip elements by leaving empty commas for the positions you want to ignore in the destructuring pattern. For example, `const [first, , third] = [1, 2, 3];` would assign `1` to `first` and `3` to `third`, skipping `2`.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Array Destructuring",
            "Skipping Elements",
            "Syntax"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "Destructuring",
            "ES6",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_common_array_operations_mcq_1",
          "topic": "Common Array Utility Operations",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following methods is the most concise and idiomatic way to create an array of numbers from 0 up to (but not including) N, for example `[0, 1, 2]` for N=3?",
          "answer": "`Array.from({ length: N }, (_, i) => i);`",
          "options": [
            "`Array.from({ length: N }, (_, i) => i);`",
            "`new Array(N).fill(0).map((_, i) => i);`",
            "`[...Array(N).keys()];`",
            "`for (let i = 0; i < N; i++) { arr.push(i); }`"
          ],
          "analysisPoints": [
            "Understanding of `Array.from()` with a `length` property.",
            "Understanding of `Array.prototype.keys()`.",
            "Comparison of conciseness and common idioms."
          ],
          "keyConcepts": [
            "Array.from()",
            "Array.prototype.keys()",
            "Array generation",
            "Conciseness"
          ],
          "evaluationCriteria": [
            "Recognition of modern JavaScript array creation patterns.",
            "Ability to select the most idiomatic solution.",
            "Understanding of various approaches."
          ],
          "example": "While all options can achieve the result, `Array.from({ length: N }, (_, i) => i);` is widely considered the most modern, readable, and flexible way to create arrays with a sequence of values in JavaScript.\n\n-   `new Array(N).fill(0).map((_, i) => i);` also works, but `fill(0)` is an unnecessary step if the elements are immediately mapped.\n-   `[...Array(N).keys()];` is very concise and also correct, relying on `Array.prototype.keys()` which returns an iterator of keys (indices). This is also a strong candidate.\n-   The `for` loop is a traditional but more verbose imperative approach.\n\nBoth `Array.from({ length: N }, (_, i) => i);` and `[...Array(N).keys()];` are excellent. The first option is often slightly more versatile as it allows more complex mapping functions easily.",
          "tags": [
            "Array Creation",
            "Array.from",
            "ES6",
            "Utility"
          ],
          "prerequisites": [
            "javascript_arrays",
            "es6_features"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_common_array_operations_code_1",
          "topic": "Common Array Utility Operations",
          "level": "medium",
          "type": "code",
          "question": "Implement a function `getUniqueNumbers(numbers)` that takes an array of numbers (which may contain duplicates) and returns a new array containing only the unique numbers, maintaining their original order of appearance as much as possible. Do not use an additional loop beyond what's necessary for the primary operation.",
          "answer": "```javascript\nfunction getUniqueNumbers(numbers) {\n  // Using Set to remove duplicates while preserving order via Map\n  // A Map can store elements and maintain insertion order.\n  // Alternatively, LinkedHashSet in Java, but JS Set preserves insertion order for primitives.\n  return [...new Set(numbers)];\n}\n\n// Test cases:\nconsole.log(getUniqueNumbers([1, 2, 2, 3, 4, 4, 5, 1])); // Expected: [1, 2, 3, 4, 5]\nconsole.log(getUniqueNumbers([5, 4, 3, 2, 1, 5, 4])); // Expected: [5, 4, 3, 2, 1]\nconsole.log(getUniqueNumbers([]));                   // Expected: []\nconsole.log(getUniqueNumbers([10]));                  // Expected: [10]\nconsole.log(getUniqueNumbers([null, 1, null, 2]));    // Expected: [null, 1, 2]\n\n// Note on preserving order: For primitive types, Set guarantees insertion order.\n// For objects, this method removes duplicate references, not duplicate object values.\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `Set` for duplicate removal.",
            "Using the spread operator to convert `Set` back to an array.",
            "Understanding that `Set` preserves insertion order for primitives.",
            "Efficiency (O(N) time complexity).",
            "Handling edge cases like empty arrays."
          ],
          "keyConcepts": [
            "Set Object",
            "Spread Syntax",
            "Duplicate Removal",
            "ES6"
          ],
          "evaluationCriteria": [
            "Correctness and conciseness of the solution.",
            "Efficiency (avoiding nested loops).",
            "Understanding of `Set` behavior."
          ],
          "example": "The most straightforward and efficient way to get unique numbers while preserving their first-seen order is to leverage the `Set` object. A `Set` stores only unique values and maintains their insertion order. By creating a `new Set(numbers)` and then spreading it into a new array (`[...new Set(numbers)]`), we effectively remove duplicates and get the unique elements in their original relative order.",
          "tags": [
            "Array Methods",
            "Set",
            "Duplicates",
            "ES6",
            "Data Transformation"
          ],
          "prerequisites": [
            "javascript_arrays",
            "es6_features"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_common_array_operations_open_1",
          "topic": "Common Array Utility Operations",
          "level": "hard",
          "type": "open",
          "question": "You need to find the union of two arrays (all unique elements from both arrays) and the intersection of two arrays (only common elements found in both). Explain how you would implement both functions (`arrayUnion` and `arrayIntersection`) efficiently in JavaScript, focusing on modern approaches. Consider the performance implications.",
          "answer": "### `arrayUnion(arr1, arr2)`\nThe union of two arrays consists of all unique elements that are present in either array.\n\n**Implementation Strategy:**\n1.  Combine both arrays into a single array using the spread operator (`...`).\n2.  Use a `Set` to automatically filter out duplicate elements, as `Set` only stores unique values.\n3.  Convert the `Set` back into an array using the spread operator.\n\n**Code:**\n```javascript\nfunction arrayUnion(arr1, arr2) {\n  return [...new Set([...arr1, ...arr2])];\n}\n```\n\n**Performance Implications:**\n-   Time Complexity: O(M + N), where M and N are the lengths of `arr1` and `arr2`. This is because iterating through both arrays to build the combined array is O(M+N), and then adding elements to a `Set` (on average) takes O(1) time per element, making the `Set` creation O(M+N).\n-   Space Complexity: O(M + N) in the worst case (if all elements are unique and distinct across both arrays), as a new array and a `Set` are created.\n\n### `arrayIntersection(arr1, arr2)`\nThe intersection of two arrays consists of elements that are common to both arrays.\n\n**Implementation Strategy (using Set for efficiency):**\n1.  Convert one of the arrays (preferably the smaller one, if sizes vary significantly) into a `Set` for efficient lookups (average O(1) time complexity).\n2.  Filter the second array, keeping only elements that are present in the `Set` created from the first array.\n\n**Code:**\n```javascript\nfunction arrayIntersection(arr1, arr2) {\n  const set1 = new Set(arr1); // Create a Set from arr1 for O(1) average lookup\n  const intersection = arr2.filter(item => set1.has(item));\n  return [...new Set(intersection)]; // Optional: ensure uniqueness in result if arr2 had duplicates\n  // If arr1 and arr2 are guaranteed unique inputs, simply: \n  // return arr2.filter(item => set1.has(item));\n}\n\n// A slightly more robust version that ensures union/intersection uniqueness if source arrays aren't already unique\n// function arrayIntersection(arr1, arr2) {\n//   const uniqueArr1 = new Set(arr1);\n//   const uniqueArr2 = new Set(arr2);\n//   return [...uniqueArr2].filter(item => uniqueArr1.has(item));\n// }\n```\n\n**Performance Implications:**\n-   Time Complexity: O(M + N) on average. Creating the `Set` from `arr1` is O(M). Filtering `arr2` involves iterating through `N` elements and performing `has()` lookups, which are O(1) on average. Total: O(M + N).\n-   Space Complexity: O(M) for the `Set` (worst case, all unique elements from `arr1`) plus O(K) for the result array (K being the size of intersection).\n\n**Alternative for Intersection (Nested Loop - less efficient):**\nA naive approach would be nested loops, iterating through `arr1` and for each element, iterating through `arr2` using `includes()`. This would result in O(M*N) time complexity, which is significantly less efficient for large arrays compared to the Set-based approach.",
          "options": [],
          "analysisPoints": [
            "Clear definition of union and intersection.",
            "Demonstration of modern JavaScript `Set` for efficiency.",
            "Correct implementation of both functions.",
            "Accurate analysis of time and space complexity for both solutions.",
            "Comparison with less efficient methods (e.g., nested loops for intersection)."
          ],
          "keyConcepts": [
            "Set Object",
            "Spread Syntax",
            "Array.prototype.filter()",
            "Array.prototype.includes()",
            "Union",
            "Intersection",
            "Time Complexity",
            "Space Complexity",
            "ES6"
          ],
          "evaluationCriteria": [
            "Correctness of logic.",
            "Efficiency of chosen algorithms.",
            "Clarity of explanation.",
            "Depth of performance analysis."
          ],
          "example": "```javascript\nconst arr1 = [1, 2, 3, 4, 5];\nconst arr2 = [4, 5, 6, 7, 8];\nconst arr3 = [2, 3, 9, 10];\n\n// Union Examples\nconsole.log('Union of arr1 and arr2:', arrayUnion(arr1, arr2)); \n// Expected: [1, 2, 3, 4, 5, 6, 7, 8]\n\nconsole.log('Union of arr1 and arr3:', arrayUnion(arr1, arr3));\n// Expected: [1, 2, 3, 4, 5, 9, 10]\n\n// Intersection Examples\nconsole.log('Intersection of arr1 and arr2:', arrayIntersection(arr1, arr2));\n// Expected: [4, 5]\n\nconsole.log('Intersection of arr1 and arr3:', arrayIntersection(arr1, arr3));\n// Expected: [2, 3]\n\nconsole.log('Intersection of [1,2,2] and [2,3,3]:', arrayIntersection([1,2,2], [2,3,3]));\n// Expected: [2]\n```",
          "tags": [
            "Array Methods",
            "Set",
            "Algorithms",
            "Data Structures",
            "Performance",
            "ES6"
          ],
          "prerequisites": [
            "javascript_arrays",
            "es6_features",
            "data_structures_basics"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_common_array_operations_flashcard_1",
          "topic": "Common Array Utility Operations",
          "level": "easy",
          "type": "flashcard",
          "question": "How can you concisely remove duplicate primitive values from an array in JavaScript using a modern ES6 feature?",
          "answer": "You can convert the array to a `Set` (which automatically stores only unique values) and then convert the `Set` back into an array using the spread syntax. Example: `const unique = [...new Set(myArray)];`",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Set Object",
            "Spread Syntax",
            "Duplicate Removal",
            "ES6"
          ],
          "evaluationCriteria": [],
          "example": "",
          "tags": [
            "Array Methods",
            "Set",
            "Duplicates",
            "Flashcard"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_common_array_operations_mcq_2",
          "topic": "Common Array Utility Operations",
          "level": "medium",
          "type": "mcq",
          "question": "Given two arrays, `arr1 = [1, 2, 3]` and `arr2 = [3, 4, 5]`, what will be the result of `arr1.some(item => arr2.includes(item))`?",
          "answer": "true",
          "options": [
            "true",
            "false",
            "undefined",
            "Error"
          ],
          "analysisPoints": [
            "Understanding of `Array.prototype.some()`: checks if *any* element satisfies the condition.",
            "Understanding of `Array.prototype.includes()`: checks for element existence.",
            "Tracing the execution: `some` stops on the first `true`."
          ],
          "keyConcepts": [
            "Array.prototype.some()",
            "Array.prototype.includes()",
            "Boolean logic",
            "Common elements"
          ],
          "evaluationCriteria": [
            "Correctly applying the logic of `some` and `includes`.",
            "Ability to predict the output of combined array methods."
          ],
          "example": "```javascript\nconst arr1 = [1, 2, 3];\nconst arr2 = [3, 4, 5];\n\nconst result = arr1.some(item => arr2.includes(item));\n// Step-by-step:\n// 1. item = 1: arr2.includes(1) -> false\n// 2. item = 2: arr2.includes(2) -> false\n// 3. item = 3: arr2.includes(3) -> true\n//    Since `true` is returned for `item = 3`, `some()` immediately stops and returns `true`.\n\nconsole.log(result); // true\n```\n`arr1.some()` iterates through `arr1`. For the element `3` in `arr1`, `arr2.includes(3)` returns `true` because `3` is present in `arr2`. Since `some()` returns `true` as soon as its callback returns a truthy value, the overall result is `true`.",
          "tags": [
            "Array Methods",
            "some",
            "includes",
            "Boolean Logic"
          ],
          "prerequisites": [
            "javascript_arrays",
            "higher_order_functions"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_array_reverse_log",
          "title": "Reverse Array Logging with Specific Method",
          "description": "\nImplement a JavaScript function `logInReverseExceptMiddle` that takes an array of any type. The function should log each element to the console, starting from the last element and ending with the first, **excluding the middle element** if the array has an odd number of elements. If the array is empty or has only one element, it should log nothing.\n\n**Requirements:**\n1.  Must use a traditional `for` loop for iteration.\n2.  Log elements in reverse order.\n3.  Skip the exact middle element if `array.length` is odd.\n4.  Handle empty arrays and single-element arrays gracefully (no output).\n\n",
          "difficulty": "medium",
          "startingCode": "function logInReverseExceptMiddle(arr) {\n  // TODO: Implement the required functionality\n  // Consider edge cases:\n  // 1. Empty array\n  // 2. Single element array\n  // 3. Even length array\n  // 4. Odd length array (skip middle)\n\n  // Example usage:\n  // logInReverseExceptMiddle([1, 2, 3, 4, 5]); // Should log: 5, 4, 2, 1\n  // logInReverseExceptMiddle(['a', 'b', 'c', 'd']); // Should log: 'd', 'c', 'b', 'a'\n  // logInReverseExceptMiddle([]); // Should log nothing\n  // logInReverseExceptMiddle([7]); // Should log nothing\n}\n",
          "solutionCode": "function logInReverseExceptMiddle(arr) {\n  if (!arr || arr.length <= 1) {\n    return; // Handle empty or single-element arrays\n  }\n\n  const isOddLength = arr.length % 2 !== 0;\n  const middleIndex = isOddLength ? Math.floor(arr.length / 2) : -1; // Calculate middle index only if odd\n\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (isOddLength && i === middleIndex) {\n      continue; // Skip the middle element for odd length arrays\n    }\n    console.log(arr[i]);\n  }\n}\n",
          "testCases": [
            "logInReverseExceptMiddle([1, 2, 3, 4, 5]); // Expected: 5, 4, 2, 1 (3 is skipped)",
            "logInReverseExceptMiddle(['a', 'b', 'c', 'd']); // Expected: 'd', 'c', 'b', 'a' (no middle skip)",
            "logInReverseExceptMiddle([]); // Expected: No output",
            "logInReverseExceptMiddle([7]); // Expected: No output",
            "logInReverseExceptMiddle([10, 20, 30]); // Expected: 30, 10 (20 is skipped)",
            "logInReverseExceptMiddle(['hello']); // Expected: No output",
            "logInReverseExceptMiddle(['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig']); // Expected: fig, elderberry, date, cherry, banana, apple (no skip)"
          ],
          "hints": [
            "Start your loop counter `i` from `arr.length - 1`.",
            "The loop condition should be `i >= 0`.",
            "Use the modulo operator (`%`) to determine if the array length is odd.",
            "For odd length arrays, the middle index is `Math.floor(arr.length / 2)`.",
            "Use `continue` inside the loop to skip an iteration."
          ],
          "tags": [
            "Array Iteration",
            "for loop",
            "Algorithm",
            "Edge Cases"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "javascript_arrays",
            "control_flow",
            "math_floor"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Array.prototype.forEach()",
            "for...of loop",
            "Conditional Logic"
          ]
        },
        {
          "id": "task_implement_array_reorder",
          "title": "Dynamic Array Element Reorder and Remove",
          "description": "\nImplement a JavaScript class `DynamicList` that manages a list of items (strings). The class should have the following methods:\n\n1.  `constructor(initialItems)`: Initializes the list with an optional array of items.\n2.  `addItem(item)`: Adds an item to the end of the list.\n3.  `removeItem(item)`: Removes the first occurrence of an item from the list. Returns `true` if removed, `false` otherwise.\n4.  `moveItem(item, newIndex)`: Moves the *first occurrence* of a given `item` to a `newIndex`. If the item is not found, or `newIndex` is out of bounds, the list should remain unchanged. The `newIndex` can be negative, which should count from the end of the array (-1 is last, -2 is second to last, etc.). Return `true` if moved, `false` otherwise.\n5.  `getList()`: Returns a *copy* of the current list array to prevent external mutation.\n6.  `shuffle()`: Randomly shuffles the list using the Fisher-Yates algorithm.\n\n",
          "difficulty": "hard",
          "startingCode": "class DynamicList {\n  constructor(initialItems = []) {\n    this.items = [...initialItems]; // Ensure a copy to avoid external mutation\n  }\n\n  addItem(item) {\n    // TODO: Implement\n  }\n\n  removeItem(item) {\n    // TODO: Implement\n    // Hint: Find index, then splice.\n  }\n\n  moveItem(item, newIndex) {\n    // TODO: Implement\n    // Hint: Use splice twice. Handle negative newIndex.\n  }\n\n  getList() {\n    // TODO: Implement\n  }\n\n  shuffle() {\n    // TODO: Implement Fisher-Yates shuffle\n  }\n}\n\n// Example Usage (for testing):\n// const myList = new DynamicList(['apple', 'banana', 'cherry']);\n// console.log(myList.getList()); // ['apple', 'banana', 'cherry']\n// myList.moveItem('banana', 0);\n// console.log(myList.getList()); // ['banana', 'apple', 'cherry']\n// myList.removeItem('apple');\n// console.log(myList.getList()); // ['banana', 'cherry']\n// myList.shuffle();\n// console.log(myList.getList()); // Shuffled version\n",
          "solutionCode": "class DynamicList {\n  constructor(initialItems = []) {\n    this.items = [...initialItems];\n  }\n\n  addItem(item) {\n    this.items.push(item);\n  }\n\n  removeItem(item) {\n    const index = this.items.indexOf(item);\n    if (index > -1) {\n      this.items.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  moveItem(item, newIndex) {\n    const oldIndex = this.items.indexOf(item);\n    if (oldIndex === -1) {\n      return false; // Item not found\n    }\n\n    let normalizedNewIndex = newIndex;\n    if (newIndex < 0) {\n      normalizedNewIndex = this.items.length + newIndex; // Calculate index from end\n    }\n\n    // Clamp newIndex to valid bounds: [0, this.items.length - 1]\n    normalizedNewIndex = Math.max(0, Math.min(normalizedNewIndex, this.items.length - 1));\n\n    const [movedItem] = this.items.splice(oldIndex, 1); // Remove item\n    this.items.splice(normalizedNewIndex, 0, movedItem); // Insert at new position\n    return true;\n  }\n\n  getList() {\n    return [...this.items]; // Return a copy\n  }\n\n  shuffle() {\n    for (let i = this.items.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [this.items[i], this.items[j]] = [this.items[j], this.items[i]]; // Swap elements\n    }\n  }\n}\n",
          "testCases": [
            "const list1 = new DynamicList(['A', 'B', 'C', 'D']);",
            "list1.moveItem('B', 0); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"A\",\"C\",\"D\"]', 'Test 1 Failed: move B to 0');",
            "list1.moveItem('D', 1); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"D\",\"A\",\"C\"]', 'Test 2 Failed: move D to 1');",
            "list1.moveItem('C', 10); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"D\",\"A\",\"C\"]', 'Test 3 Failed: move C to out of bounds end');",
            "list1.moveItem('X', 1); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"D\",\"A\",\"C\"]', 'Test 4 Failed: move non-existent item');",
            "list1.moveItem('A', -1); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"D\",\"C\",\"A\"]', 'Test 5 Failed: move A to -1 (last)');",
            "list1.moveItem('B', -10); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"D\",\"C\",\"A\"]', 'Test 6 Failed: move B to out of bounds start');",
            "list1.removeItem('D'); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"C\",\"A\"]', 'Test 7 Failed: remove D');",
            "list1.removeItem('Z'); console.assert(list1.removeItem('Z') === false, 'Test 8 Failed: remove non-existent item return');",
            "list1.addItem('E'); console.assert(JSON.stringify(list1.getList()) === '[\"B\",\"C\",\"A\",\"E\"]', 'Test 9 Failed: add E');",
            "const list2 = new DynamicList(['X', 'Y', 'Z']); list2.shuffle(); console.assert(list2.getList().length === 3, 'Test 10 Failed: Shuffle preserves length'); console.log('Shuffled list2:', list2.getList());",
            "const list3 = new DynamicList(); console.assert(JSON.stringify(list3.getList()) === '[]', 'Test 11 Failed: Empty constructor'); list3.addItem('first'); console.assert(JSON.stringify(list3.getList()) === '[\"first\"]', 'Test 12 Failed: Add to empty list');",
            "const list4 = new DynamicList([1, 2, 3, 4, 5, 6, 7]); list4.moveItem(4, 2); console.assert(JSON.stringify(list4.getList()) === '[1,2,4,3,5,6,7]', 'Test 13 Failed: move item in longer array');"
          ],
          "hints": [
            "For `removeItem`, `indexOf()` can find the item's position, then `splice()` removes it.",
            "For `moveItem`, first find the `oldIndex` using `indexOf()`. Then, use two `splice()` calls: one to remove the item, and another to insert it. Remember to handle negative `newIndex` by converting it to a positive index relative to the end of the array, e.g., `length + newIndex`.",
            "Ensure `newIndex` is clamped within valid array bounds (between 0 and `length - 1`) to prevent errors if `newIndex` is too large or too small after conversion.",
            "For `shuffle`, accurately implement the Fisher-Yates algorithm using a `for` loop and array destructuring for swapping elements.",
            "Always return a *copy* of the array for `getList()` to maintain encapsulation and immutability from external changes.",
            "Think about edge cases for `moveItem` and `removeItem`: item not found, empty list, `newIndex` outside bounds."
          ],
          "tags": [
            "OOP",
            "Classes",
            "Array Methods",
            "splice",
            "indexOf",
            "Fisher-Yates",
            "Immutability",
            "Data Structures"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "javascript_arrays",
            "es6_classes",
            "array_splice",
            "array_indexOf",
            "math_random"
          ],
          "complexity": 9,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Array Manipulation and Reordering",
            "Encapsulation",
            "Data Structures"
          ]
        },
        {
          "id": "task_implement_config_parser",
          "title": "Configuration Parser with Destructuring",
          "description": "\nImplement a function `parseConfigString(configString)` that takes a string representing a configuration line. Each line has a fixed format but might have optional or variable parts. Your function should parse this string and return an object with specific properties.\n\n**Config String Format:**\n`'[ID]:[NAME]:[TYPE]:[STATUS?]:[...TAGS]'`\n\n-   `ID`: (Number) Always present, e.g., `101`.\n-   `NAME`: (String) Always present, e.g., `Service_A`.\n-   `TYPE`: (String) Always present, e.g., `API`.\n-   `STATUS`: (String, Optional) Can be `active`, `inactive`, or missing. If missing, default to `unknown`.\n-   `...TAGS`: (String Array, Optional) Zero or more additional tags separated by colons. If no tags, this part is empty.\n\nYour function must use **array destructuring** to parse the string parts. Return an object with `id`, `name`, `type`, `status`, and `tags` properties, with correct data types. Assume input strings are well-formed according to the basic format (i.e., will have at least ID, NAME, TYPE).\n\n",
          "difficulty": "hard",
          "startingCode": "function parseConfigString(configString) {\n  // TODO: Implement parsing using array destructuring\n  // Hint: Use String.prototype.split(':') to get an array of parts.\n  // Remember to convert ID to a Number.\n  // Handle optional STATUS with default values.\n  // Handle optional TAGS with the rest pattern.\n\n  // Example usage:\n  // parseConfigString('101:Service_A:API:active:tag1:tag2');\n  // parseConfigString('202:Database_B:DB');\n  // parseConfigString('303:Logging_C:Utility::debug:verbose'); // Empty status, then tags\n}\n",
          "solutionCode": "function parseConfigString(configString) {\n  const parts = configString.split(':');\n\n  // Use array destructuring with default values and rest pattern\n  const [\n    idStr,\n    name,\n    type,\n    status = 'unknown', // Default value for status if undefined/missing\n    ...tags               // Rest pattern collects remaining elements into an array\n  ] = parts;\n\n  return {\n    id: Number(idStr), // Convert ID to a number\n    name: name,\n    type: type,\n    status: status,\n    tags: tags\n  };\n}\n",
          "testCases": [
            "// Test Case 1: All fields present, multiple tags\nconsole.assert(JSON.stringify(parseConfigString('101:Service_A:API:active:tag1:tag2')) === '{\"id\":101,\"name\":\"Service_A\",\"type\":\"API\",\"status\":\"active\",\"tags\":[\"tag1\",\"tag2\"]}', 'Test Case 1 Failed');",
            "// Test Case 2: No status, no tags\nconsole.assert(JSON.stringify(parseConfigString('202:Database_B:DB')) === '{\"id\":202,\"name\":\"Database_B\",\"type\":\"DB\",\"status\":\"unknown\",\"tags\":[]}', 'Test Case 2 Failed');",
            "// Test Case 3: Explicitly empty status (becomes undefined, so default applies), with tags\nconsole.assert(JSON.stringify(parseConfigString('303:Logging_C:Utility::debug:verbose')) === '{\"id\":303,\"name\":\"Logging_C\",\"type\":\"Utility\",\"status\":\"unknown\",\"tags\":[\"debug\",\"verbose\"]}', 'Test Case 3 Failed');",
            "// Test Case 4: No tags, but status present\nconsole.assert(JSON.stringify(parseConfigString('404:Auth_Service:Security:inactive')) === '{\"id\":404,\"name\":\"Auth_Service\",\"type\":\"Security\",\"status\":\"inactive\",\"tags\":[]}', 'Test Case 4 Failed');",
            "// Test Case 5: Single tag\nconsole.assert(JSON.stringify(parseConfigString('505:Data_Processor:Job:active:process')) === '{\"id\":505,\"name\":\"Data_Processor\",\"type\":\"Job\",\"status\":\"active\",\"tags\":[\"process\"]}', 'Test Case 5 Failed');",
            "// Test Case 6: ID conversion check\nconsole.assert(typeof parseConfigString('606:Test:Type').id === 'number', 'Test Case 6 Failed: ID not a number');",
            "// Test Case 7: Only mandatory fields\nconsole.assert(JSON.stringify(parseConfigString('707:Minimal:App')) === '{\"id\":707,\"name\":\"Minimal\",\"type\":\"App\",\"status\":\"unknown\",\"tags\":[]}', 'Test Case 7 Failed');"
          ],
          "hints": [
            "Use `String.prototype.split(':')` to convert the input string into an array of parts.",
            "Remember that `split()` on a trailing delimiter (e.g., `'a:b:'`) can result in an empty string at the end of the array, which needs careful handling with destructuring.",
            "The rest pattern `...tags` must be the *last* element in your destructuring assignment.",
            "The `status` default value will only apply if the corresponding element in `parts` array is `undefined` or not present. An empty string (`''`) is not `undefined`."
          ],
          "tags": [
            "Destructuring",
            "String Manipulation",
            "Parsing",
            "ES6",
            "Configuration"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "javascript_strings",
            "javascript_arrays",
            "es6_features"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Array Destructuring",
            "Rest Parameters",
            "Default Parameters"
          ]
        },
        {
          "id": "task_implement_array_utilities",
          "title": "Essential Array Utility Functions",
          "description": "\nImplement a utility object `ArrayUtils` that encapsulates several common array manipulation functions.\n\n**`ArrayUtils` should have the following methods:**\n\n1.  `createRange(start, end, step = 1)`: Returns a new array of numbers from `start` to `end` (inclusive), with an optional `step`. If `start > end`, return an empty array. Assume `step` is always positive.\n    *   Example: `createRange(1, 5)` returns `[1, 2, 3, 4, 5]`\n    *   Example: `createRange(0, 10, 2)` returns `[0, 2, 4, 6, 8, 10]`\n\n2.  `getUniqueElements(arr)`: Returns a new array containing only the unique primitive elements from `arr`, preserving their original insertion order.\n    *   Example: `getUniqueElements([1, 2, 2, 3, 1])` returns `[1, 2, 3]`\n\n3.  `findMax(arr)`: Returns the maximum numeric value in `arr`. If `arr` is empty or non-numeric, return `null`.\n    *   Example: `findMax([10, 2, 8])` returns `10`\n    *   Example: `findMax([])` returns `null`\n    *   Example: `findMax(['a', 'b'])` returns `null`\n\n4.  `hasAnyCommonElement(arr1, arr2)`: Returns `true` if `arr1` and `arr2` share at least one common element, `false` otherwise. Both arrays contain primitive values.\n    *   Example: `hasAnyCommonElement([1, 2], [2, 3])` returns `true`\n    *   Example: `hasAnyCommonElement([1, 2], [3, 4])` returns `false`\n\n",
          "difficulty": "medium",
          "startingCode": "const ArrayUtils = {\n  createRange(start, end, step = 1) {\n    // TODO: Implement\n  },\n\n  getUniqueElements(arr) {\n    // TODO: Implement\n  },\n\n  findMax(arr) {\n    // TODO: Implement\n  },\n\n  hasAnyCommonElement(arr1, arr2) {\n    // TODO: Implement\n  }\n};\n\n// Example usage:\n// console.log(ArrayUtils.createRange(1, 5));\n// console.log(ArrayUtils.getUniqueElements([1, 2, 2, 3]));\n// console.log(ArrayUtils.findMax([10, 5, 20]));\n// console.log(ArrayUtils.hasAnyCommonElement([1, 2], [2, 4]));\n",
          "solutionCode": "const ArrayUtils = {\n  createRange(start, end, step = 1) {\n    if (start > end) {\n      return [];\n    }\n    const result = [];\n    for (let i = start; i <= end; i += step) {\n      result.push(i);\n    }\n    return result;\n    /* Alternative with Array.from:\n    const length = Math.floor((end - start) / step) + 1;\n    if (length <= 0) return [];\n    return Array.from({ length }, (_, i) => start + (i * step));\n    */\n  },\n\n  getUniqueElements(arr) {\n    // Handles non-array inputs or ensures it's an array for Set constructor\n    if (!Array.isArray(arr)) {\n      return [];\n    }\n    return [...new Set(arr)];\n  },\n\n  findMax(arr) {\n    if (!Array.isArray(arr) || arr.length === 0) {\n      return null;\n    }\n    // Check if all elements are numbers. If not, return null.\n    if (arr.some(isNaN) || arr.some(item => typeof item !== 'number')) {\n      return null; \n    }\n    return Math.max(...arr);\n  },\n\n  hasAnyCommonElement(arr1, arr2) {\n    if (!Array.isArray(arr1) || !Array.isArray(arr2) || arr1.length === 0 || arr2.length === 0) {\n      return false; // No common elements if either array is empty or not an array\n    }\n    const set1 = new Set(arr1);\n    return arr2.some(item => set1.has(item));\n  }\n};\n",
          "testCases": [
            "// createRange tests",
            "console.assert(JSON.stringify(ArrayUtils.createRange(1, 5)) === '[1,2,3,4,5]', 'createRange Test 1 Failed');",
            "console.assert(JSON.stringify(ArrayUtils.createRange(0, 10, 2)) === '[0,2,4,6,8,10]', 'createRange Test 2 Failed');",
            "console.assert(JSON.stringify(ArrayUtils.createRange(5, 1)) === '[]', 'createRange Test 3 Failed');",
            "console.assert(JSON.stringify(ArrayUtils.createRange(7, 7)) === '[7]', 'createRange Test 4 Failed');",
            "console.assert(JSON.stringify(ArrayUtils.createRange(1, 2, 0.5)) === '[1,1.5,2]', 'createRange Test 5 Failed (decimal step)');",
            "// getUniqueElements tests",
            "console.assert(JSON.stringify(ArrayUtils.getUniqueElements([1, 2, 2, 3, 1])) === '[1,2,3]', 'getUniqueElements Test 1 Failed');",
            "console.assert(JSON.stringify(ArrayUtils.getUniqueElements(['a', 'b', 'a', 'c'])) === '[\"a\",\"b\",\"c\"]', 'getUniqueElements Test 2 Failed');",
            "console.assert(JSON.stringify(ArrayUtils.getUniqueElements([])) === '[]', 'getUniqueElements Test 3 Failed');",
            "console.assert(JSON.stringify(ArrayUtils.getUniqueElements([1, null, 2, null])) === '[1,null,2]', 'getUniqueElements Test 4 Failed (null)');",
            "// findMax tests",
            "console.assert(ArrayUtils.findMax([10, 2, 8]) === 10, 'findMax Test 1 Failed');",
            "console.assert(ArrayUtils.findMax([-5, -1, -10]) === -1, 'findMax Test 2 Failed');",
            "console.assert(ArrayUtils.findMax([7]) === 7, 'findMax Test 3 Failed');",
            "console.assert(ArrayUtils.findMax([]) === null, 'findMax Test 4 Failed (empty)');",
            "console.assert(ArrayUtils.findMax([1, 'a', 3]) === null, 'findMax Test 5 Failed (non-numeric)');",
            "console.assert(ArrayUtils.findMax(null) === null, 'findMax Test 6 Failed (null input)');",
            "// hasAnyCommonElement tests",
            "console.assert(ArrayUtils.hasAnyCommonElement([1, 2], [2, 3]) === true, 'hasAnyCommonElement Test 1 Failed');",
            "console.assert(ArrayUtils.hasAnyCommonElement([1, 2], [3, 4]) === false, 'hasAnyCommonElement Test 2 Failed');",
            "console.assert(ArrayUtils.hasAnyCommonElement([], [1, 2]) === false, 'hasAnyCommonElement Test 3 Failed (empty arr1)');",
            "console.assert(ArrayUtils.hasAnyCommonElement([1, 2], []) === false, 'hasAnyCommonElement Test 4 Failed (empty arr2)');",
            "console.assert(ArrayUtils.hasAnyCommonElement(['a', 'b'], ['b', 'c']) === true, 'hasAnyCommonElement Test 5 Failed (strings)');",
            "console.assert(ArrayUtils.hasAnyCommonElement([null, 1], [1, 2]) === true, 'hasAnyCommonElement Test 6 Failed (null)');",
            "console.assert(ArrayUtils.hasAnyCommonElement([1, 2, 3], null) === false, 'hasAnyCommonElement Test 7 Failed (null input)');"
          ],
          "hints": [
            "For `createRange`, a simple `for` loop works, or `Array.from()` with a `length` property and a mapping function is an elegant alternative.",
            "For `getUniqueElements`, remember that `Set` objects automatically store only unique values and preserve insertion order for primitive types. Combine with the spread operator.",
            "For `findMax`, consider `Math.max()` with the spread operator. Don't forget edge cases like empty arrays or arrays containing non-numeric values. `isNaN()` and `typeof` checks might be useful.",
            "For `hasAnyCommonElement`, converting one array to a `Set` greatly improves performance for lookups (`Set.prototype.has()`). Then `Array.prototype.some()` can check for existence in the other array.",
            "Ensure all functions handle `null` or non-array inputs gracefully if they are expected to work with potentially invalid inputs."
          ],
          "tags": [
            "Array Methods",
            "Set",
            "Math",
            "Utility Functions",
            "ES6",
            "Data Transformation"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "javascript_arrays",
            "es6_features",
            "higher_order_functions",
            "math_object"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Common Array Utility Operations",
            "Functional Programming",
            "Data Validation"
          ]
        }
      ]
    }
  },
  {
    "id": "db25c3e5-24ef-4958-be3e-e589f32cd20e",
    "startLine": 1500,
    "endLine": 1599,
    "processedDate": "2025-06-17T07:55:50.581Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_array_group_by_reduce",
          "title": "Array Grouping with `reduce`",
          "content": "The `Array.prototype.reduce()` method is a powerful higher-order function in JavaScript that executes a user-supplied 'reducer' callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value.\n\n### `reduce` Parameters:\n- **`callback`**: A function to execute on each element in the array. It takes four arguments:\n    - **`accumulator`**: The accumulated value previously returned in the last invocation of the callback, or `initialValue`, if supplied.\n    - **`currentValue`**: The current element being processed in the array.\n    - **`currentIndex`** (Optional): The index of the current element being processed in the array. Starts from index 0 if an `initialValue` is provided. Otherwise, it starts from index 1.\n    - **`array`** (Optional): The array `reduce()` was called upon.\n- **`initialValue`** (Optional): A value to use as the first argument to the first call of the `callback`. If no `initialValue` is supplied, the first element in the array will be used as the `accumulator`'s initial value and `currentValue` will start from the second element.\n\n### Grouping Logic:\nThe provided `groupBy` function leverages `reduce` to categorize objects within an array based on a specified property (`key`). For each `item` in the `array`:\n1.  It checks if the `result` (the accumulator, which will become the grouped object) already has a property corresponding to `item[key]` (e.g., `item.age`).\n2.  If not, it initializes `result[item[key]]` as an empty array `[]`.\n3.  It then pushes the current `item` into this array.\n4.  Finally, it returns the `result` accumulator for the next iteration.\n\nThis pattern efficiently builds an object where keys are the unique values of the specified property, and values are arrays of objects sharing that property value.",
          "examples": [
            {
              "id": "example_group_by_1",
              "title": "Basic `groupBy` Implementation",
              "code": "function groupBy(array, key) {\n  return array.reduce((result, item) => {\n    // If the key doesn't exist in result, initialize it as an empty array\n    (result[item[key]] = result[item[key]] || []).push(item);\n    return result;\n  }, {}); // Initial accumulator is an empty object\n}\n\n// Grouped people by age\nconst peopleData = [\n  { name: 'Alice', age: 30 },\n  { name: 'Bob', age: 25 },\n  { name: 'Charlie', age: 30 },\n  { name: 'David', age: 25 }\n];\n\nconst groupedPeople = groupBy(peopleData, 'age');\nconsole.log(groupedPeople);\n// Expected Output:\n// {\n//   25: [{ name: 'Bob', age: 25 }, { name: 'David', age: 25 }],\n//   30: [{ name: 'Alice', age: 30 }, { name: 'Charlie', age: 30 }]\n// }",
              "explanation": "This example demonstrates the `groupBy` function in action, using `age` as the key to group the `peopleData` array. The `reduce` method iterates through each person, and if a group for their age doesn't exist in the `result` object, it creates an empty array for that age group before pushing the current person into it. The `{}` as the initial value ensures `result` starts as an empty object.",
              "language": "javascript"
            },
            {
              "id": "example_group_by_2",
              "title": "Grouping by Multiple Properties",
              "code": "function groupByMultipleKeys(array, keys) {\n  return array.reduce((result, item) => {\n    let currentGroup = result;\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const value = item[key];\n      if (!currentGroup[value]) {\n        currentGroup[value] = (i === keys.length - 1) ? [] : {};\n      }\n      currentGroup = currentGroup[value];\n    }\n    currentGroup.push(item);\n    return result;\n  }, {});\n}\n\nconst products = [\n  { id: 1, category: 'Electronics', brand: 'Sony' },\n  { id: 2, category: 'Electronics', brand: 'Samsung' },\n  { id: 3, category: 'Clothes', brand: 'Nike' },\n  { id: 4, category: 'Electronics', brand: 'Sony' },\n];\n\nconst groupedProducts = groupByMultipleKeys(products, ['category', 'brand']);\nconsole.log(JSON.stringify(groupedProducts, null, 2));\n// Expected Output:\n// {\n//   \"Electronics\": {\n//     \"Sony\": [\n//       { \"id\": 1, \"category\": \"Electronics\", \"brand\": \"Sony\" },\n//       { \"id\": 4, \"category\": \"Electronics\", \"brand\": \"Sony\" }\n//     ],\n//     \"Samsung\": [\n//       { \"id\": 2, \"category\": \"Electronics\", \"brand\": \"Samsung\" }\n//     ]\n//   },\n//   \"Clothes\": {\n//     \"Nike\": [\n//       { \"id\": 3, \"category\": \"Clothes\", \"brand\": \"Nike\" }\n//     ]\n//   }\n// }",
              "explanation": "This advanced example extends the grouping concept to support multiple nested keys. The `groupByMultipleKeys` function iterates through an array of keys, dynamically building a nested object structure. For each key, it creates a new level in the `result` object, ultimately pushing the original `item` into the innermost array. This demonstrates the versatility of `reduce` for complex data transformations.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_reduce_mcq_1",
            "question_group_by_open_1",
            "question_reduce_flashcard_1",
            "question_group_by_code_1",
            "question_reduce_mcq_2"
          ],
          "relatedTasks": [
            "task_implement_advanced_groupby"
          ],
          "tags": [
            "Array.prototype.reduce",
            "functional programming",
            "data transformation",
            "JavaScript",
            "array methods"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_arrays",
            "javascript_objects",
            "higher_order_functions"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "data_aggregation",
            "utility_functions",
            "functional_patterns"
          ]
        },
        {
          "id": "theory_asynchronous_javascript_callbacks",
          "title": "Asynchronous JavaScript: Callbacks",
          "content": "JavaScript is single-threaded, meaning it executes code sequentially. However, many operations, like fetching data from a server, reading files, or setting timers, are time-consuming and cannot block the main thread. Asynchronous JavaScript allows these operations to run in the background without freezing the user interface, and callbacks are a fundamental pattern for handling their results.\n\n### Callbacks Explained:\nA callback function is a function passed as an argument to another function, which is then invoked inside the outer function to complete some kind of routine or action. In asynchronous programming, the outer function starts an operation, and the callback function is executed only after that operation completes (or fails) at some later point in time.\n\n### Characteristics:\n-   **Non-blocking**: The main thread can continue executing other code while the asynchronous operation is pending.\n-   **Event-driven**: Often used with events (e.g., `setTimeout`, `addEventListener`, network requests).\n\n### The Problem: Callback Hell (Pyramid of Doom):\nWhile callbacks are effective for simple asynchronous operations, they can quickly lead to deeply nested, unreadable, and unmaintainable code when multiple asynchronous operations depend on the results of previous ones. This phenomenon is commonly known as 'callback hell' or 'pyramid of doom'.\n\n**Issues with Callback Hell:**\n1.  **Readability**: Code becomes difficult to follow due to excessive indentation and nesting.\n2.  **Error Handling**: Centralized error handling is challenging; errors need to be passed down or handled at each level.\n3.  **Maintainability**: Modifying or extending functionality becomes cumbersome.\n4.  **Inversion of Control**: The outer function takes control of when and how the callback is executed, which can lead to unpredictable behavior if not carefully managed.",
          "examples": [
            {
              "id": "example_callbacks_basic_1",
              "title": "Basic Callback Pattern",
              "code": "function fetchData(callback) {\n  console.log('Fetching data...');\n  setTimeout(() => {\n    const data = { name: 'John Doe', age: 30 };\n    console.log('Data fetched.');\n    callback(data); // Invoke the callback with the fetched data\n  }, 1000);\n}\n\nfunction displayData(data) {\n  console.log('Displaying data:', data);\n}\n\n// Call fetchData and pass displayData as the callback\nfetchData(displayData);\n// Expected output (after ~1 second):\n// Fetching data...\n// Data fetched.\n// Displaying data: { name: 'John Doe', age: 30 }",
              "explanation": "This example shows a simple asynchronous function `fetchData` that simulates an API call using `setTimeout`. After a delay, it calls the `callback` function (`displayData` in this case) and passes the fetched `data` to it. This demonstrates the non-blocking nature: `fetchData` returns immediately, and `displayData` is called later when the data is ready.",
              "language": "javascript"
            },
            {
              "id": "example_callbacks_hell_1",
              "title": "Callback Hell Demonstration",
              "code": "function fetchUser(userId, callback) {\n  setTimeout(() => {\n    console.log(`Fetched user ${userId}`);\n    callback({ id: userId, name: `User ${userId}` });\n  }, 500);\n}\n\nfunction fetchPosts(userId, callback) {\n  setTimeout(() => {\n    console.log(`Fetched posts for user ${userId}`);\n    callback([{ id: 101, title: 'Post 1' }, { id: 102, title: 'Post 2' }]);\n  }, 700);\n}\n\nfunction fetchComments(postId, callback) {\n  setTimeout(() => {\n    console.log(`Fetched comments for post ${postId}`);\n    callback([{ id: 201, text: 'Comment A' }, { id: 202, text: 'Comment B' }]);\n  }, 600);\n}\n\n// Callback hell in action:\nfetchUser(1, (user) => {\n  fetchPosts(user.id, (posts) => {\n    if (posts.length > 0) {\n      fetchComments(posts[0].id, (comments) => {\n        console.log('Final data received:');\n        console.log('User:', user);\n        console.log('First Post:', posts[0]);\n        console.log('Comments:', comments);\n        // More nested callbacks could follow...\n      });\n    } else {\n      console.log('No posts found for user.');\n    }\n  });\n});",
              "explanation": "This example illustrates 'callback hell'. To fetch a user, then their posts, then comments for the first post, functions are deeply nested. This creates a pyramid-like structure that is hard to read, debug, and manage, especially when error handling or more sequential operations are added. It highlights the primary motivation for introducing Promises and async/await.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_callbacks_mcq_1",
            "question_callbacks_open_1",
            "question_callbacks_flashcard_1",
            "question_callbacks_code_1",
            "question_callbacks_mcq_2"
          ],
          "relatedTasks": [
            "task_callback_to_promise"
          ],
          "tags": [
            "asynchronous JavaScript",
            "callbacks",
            "callback hell",
            "event loop",
            "non-blocking"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "javascript_functions",
            "setTimeout"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "understanding_async_history",
            "legacy_codebases",
            "event_listeners"
          ]
        },
        {
          "id": "theory_asynchronous_javascript_promises",
          "title": "Asynchronous JavaScript: Promises",
          "content": "Promises are a fundamental concept in modern asynchronous JavaScript, offering a cleaner and more robust way to handle asynchronous operations compared to traditional callbacks. A Promise is an object representing the eventual completion (or failure) of an asynchronous operation and its resulting value.\n\n### Promise States:\nA Promise can be in one of three states:\n1.  **Pending**: The initial state; neither fulfilled nor rejected.\n2.  **Fulfilled** (or Resolved): The operation completed successfully, and the promise has a resulting value.\n3.  **Rejected**: The operation failed, and the promise has a reason for the failure (an error object).\n\nA Promise is said to be *settled* when it is either fulfilled or rejected. Once a promise is settled, it cannot change its state.\n\n### Using Promises:\n-   **`new Promise(executor)`**: The `Promise` constructor takes an `executor` function with two arguments: `resolve` and `reject`. You call `resolve(value)` when the async operation succeeds and `reject(error)` when it fails.\n-   **`.then(onFulfilled, onRejected)`**: Used to register callbacks to be invoked when the promise is fulfilled (`onFulfilled`) or rejected (`onRejected`). It always returns a *new* promise, enabling chaining.\n-   **`.catch(onRejected)`**: A shorthand for `.then(null, onRejected)`. Primarily used for error handling at any point in a promise chain.\n-   **`.finally(onFinally)`**: Introduced in ES2018. Registers a callback to be invoked when the promise is settled (either fulfilled or rejected). The callback doesn't receive any arguments and is useful for cleanup operations regardless of the outcome.\n\n### Solving Callback Hell:\nPromises address callback hell by allowing you to chain asynchronous operations sequentially, making the code much more readable and manageable. Each `.then()` returns a new promise, allowing subsequent `.then()` calls to be attached to the result of the previous one, creating a flat structure instead of nested callbacks.\n\n### Static Promise Methods:\n-   **`Promise.all(iterable)`**: Takes an iterable (e.g., an array) of promises as input. It returns a single Promise that resolves when all of the input promises have resolved, or rejects immediately upon the first promise that rejects. The resolved value is an array of the resolved values of the input promises, in the same order.\n-   **`Promise.race(iterable)`**: Also takes an iterable of promises. It returns a single Promise that resolves or rejects as soon as one of the input promises resolves or rejects, with the value or reason from that promise.\n-   **`Promise.allSettled(iterable)`** (ES2020): Returns a promise that resolves after all of the given promises have either fulfilled or rejected, with an array of objects describing the outcome of each promise.\n-   **`Promise.any(iterable)`** (ES2021): Takes an iterable of promises and returns a single promise that resolves with the value of the first promise in the iterable to fulfill. If all of the input promises reject, then the returned promise rejects with an `AggregateError` containing an array of rejection reasons.",
          "examples": [
            {
              "id": "example_promises_basic_1",
              "title": "Creating and Using a Promise",
              "code": "const myPromise = new Promise((resolve, reject) => {\n  const success = Math.random() > 0.5; // Simulate async operation success/failure\n  setTimeout(() => {\n    if (success) {\n      resolve('Data successfully loaded!');\n    } else {\n      reject(new Error('Failed to load data.'));\n    }\n  }, 1500);\n});\n\nconsole.log('Promise pending...');\n\nmyPromise\n  .then(message => {\n    console.log('Success:', message); // Executed if promise is fulfilled\n    return 'Further processing: ' + message;\n  })\n  .then(nextMessage => {\n    console.log(nextMessage); // Chained .then() receives value from previous .then()\n  })\n  .catch(error => {\n    console.error('Error:', error.message); // Executed if any promise in chain is rejected\n  })\n  .finally(() => {\n    console.log('Promise operation finished.'); // Always executed, regardless of outcome\n  });\n\nconsole.log('Other synchronous code continues...');",
              "explanation": "This example illustrates the full lifecycle of a Promise. It shows how to create a promise using `new Promise` with `resolve` and `reject` functions. It then demonstrates promise chaining with `.then()` for success handling, `.catch()` for error handling, and `.finally()` for cleanup. Notice how `console.log('Other synchronous code continues...');` runs immediately, highlighting the non-blocking nature.",
              "language": "javascript"
            },
            {
              "id": "example_promises_all_race",
              "title": "Promise.all and Promise.race",
              "code": "// --- Example for Promise.all ---\nconst promise1 = Promise.resolve(3);\nconst promise2 = 42;\nconst promise3 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 100, 'foo');\n});\n\nPromise.all([promise1, promise2, promise3])\n  .then((values) => {\n    console.log('Promise.all results:', values); // [3, 42, 'foo']\n  })\n  .catch(error => {\n    console.error('Promise.all failed:', error);\n  });\n\n// --- Example for Promise.race ---\nconst fetchUserData = new Promise(resolve => setTimeout(() => resolve('User Data'), 200));\nconst fetchProductData = new Promise(resolve => setTimeout(() => resolve('Product Data'), 100));\nconst fetchTimeout = new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout!')), 50));\n\nPromise.race([fetchUserData, fetchProductData, fetchTimeout])\n  .then((value) => {\n    console.log('Promise.race winner:', value); // Error: Timeout! (because fetchTimeout resolves/rejects first)\n  })\n  .catch(error => {\n    console.error('Promise.race rejected:', error.message); // Output: Promise.race rejected: Timeout!\n  });",
              "explanation": "`Promise.all` is used when you need all asynchronous operations to complete successfully before proceeding. It resolves with an array of results or rejects if any single promise fails. `Promise.race` is useful when you only care about the result of the first promise to settle (either fulfill or reject). In the example, `fetchTimeout` is designed to reject quickly, demonstrating how `Promise.race` immediately adopts its state.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_promises_mcq_1",
            "question_promises_open_1",
            "question_promises_flashcard_1",
            "question_promises_code_1",
            "question_promises_mcq_2",
            "question_promises_all_race_mcq_1",
            "question_promises_then_catch_flashcard",
            "question_promises_static_methods_mcq"
          ],
          "relatedTasks": [
            "task_callback_to_promise",
            "task_concurrent_api_calls"
          ],
          "tags": [
            "asynchronous JavaScript",
            "Promises",
            "Promise.all",
            "Promise.race",
            "promise chaining",
            "error handling",
            "async/await prerequisites"
          ],
          "technology": "JavaScript",
          "prerequisites": [
            "callbacks",
            "event_loop"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "modern_async_programming",
            "async_await",
            "fetch_api",
            "complex_data_flows"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_reduce_mcq_1",
          "topic": "Array.prototype.reduce",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary purpose of the `reduce()` method in JavaScript arrays?",
          "answer": "To condense an array's elements into a single value.",
          "options": [
            "To filter elements based on a condition.",
            "To transform each element into a new array.",
            "To condense an array's elements into a single value.",
            "To sort array elements in a specific order."
          ],
          "analysisPoints": [
            "`reduce()` is designed for aggregation, where you process each element to build up a single result (e.g., sum, object, flattened array).",
            "Filtering is done with `filter()`, transforming with `map()`, and sorting with `sort()`."
          ],
          "keyConcepts": [
            "Array.prototype.reduce",
            "Aggregation",
            "Higher-order functions"
          ],
          "evaluationCriteria": [
            "Understanding of `reduce`'s core functionality",
            "Ability to differentiate `reduce` from other array methods"
          ],
          "example": "The `reduce` method is incredibly versatile. For instance, to sum all numbers in an array: `[1, 2, 3].reduce((sum, num) => sum + num, 0);` returns `6`. It processes each element (`num`) and accumulates the `sum` from the `initialValue` (0).",
          "tags": [
            "array methods",
            "reduce",
            "JavaScript basics",
            "functional programming"
          ],
          "prerequisites": [
            "javascript_arrays",
            "javascript_functions"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_group_by_open_1",
          "topic": "Array Grouping",
          "level": "medium",
          "type": "open",
          "question": "Explain how the `reduce` method in the provided `groupBy` function works to create the grouped object, focusing on the role of the `accumulator` and the `initialValue`.",
          "answer": "The `reduce` method iterates over each `item` in the input `array`. The `accumulator` (`result` in the code) starts as an empty object (`{}`), which is provided as the `initialValue`. In each iteration, `item[key]` (e.g., `item.age`) is used as a key to access a property on the `result` object. If `result[item[key]]` is falsy (meaning this group hasn't been created yet), it's initialized to an empty array `[]`. Then, the current `item` is `push`ed into `result[item[key]]`. The `result` object is returned from the callback, becoming the `accumulator` for the next iteration. This process continues until all items are processed, resulting in a single object where keys are the grouping values and values are arrays of corresponding items.",
          "analysisPoints": [
            "Clear explanation of `accumulator`'s role as the `result` object.",
            "Correct identification of `{}` as the `initialValue` and its importance.",
            "Detailed breakdown of `(result[item[key]] = result[item[key]] || []).push(item);` statement.",
            "Understanding of how the `result` object is built up incrementally.",
            "Ability to explain the flow of `reduce` with a specific use case."
          ],
          "keyConcepts": [
            "Array.prototype.reduce",
            "Accumulator",
            "Initial Value",
            "Object manipulation",
            "Conditional assignment"
          ],
          "evaluationCriteria": [
            "Depth of understanding of `reduce` parameters and execution flow",
            "Clarity and accuracy of explanation",
            "Ability to relate concepts to the specific code provided"
          ],
          "example": null,
          "tags": [
            "array methods",
            "reduce",
            "grouping",
            "JavaScript",
            "functional programming"
          ],
          "prerequisites": [
            "theory_array_group_by_reduce"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_reduce_flashcard_1",
          "topic": "Array.prototype.reduce",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the role of the `initialValue` argument in the `Array.prototype.reduce()` method?",
          "answer": "The `initialValue` serves as the initial value of the `accumulator` for the first call to the `callback` function. If not provided, the first element of the array is used as the initial accumulator, and iteration starts from the second element.",
          "analysisPoints": [],
          "keyConcepts": [
            "Array.prototype.reduce",
            "accumulator",
            "initialValue"
          ],
          "evaluationCriteria": [
            "Recall of `reduce` signature",
            "Understanding of `initialValue` impact"
          ],
          "example": null,
          "tags": [
            "array methods",
            "reduce",
            "JavaScript basics"
          ],
          "prerequisites": [
            "javascript_arrays"
          ],
          "complexity": 2,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_group_by_code_1",
          "topic": "Array Grouping",
          "level": "medium",
          "type": "code",
          "question": "Write a JavaScript function called `countOccurrences` that takes an array and a `key` (string) as input. The function should return an object where keys are the unique values of the specified `key` from the array elements, and values are the count of how many times each unique value appears. Use the `reduce` method.",
          "answer": "```javascript\nfunction countOccurrences(array, key) {\n  return array.reduce((acc, item) => {\n    const value = item[key];\n    acc[value] = (acc[value] || 0) + 1;\n    return acc;\n  }, {});\n}\n\n// Example usage:\nconst fruits = [\n  { name: 'Apple', color: 'Red' },\n  { name: 'Banana', color: 'Yellow' },\n  { name: 'Cherry', color: 'Red' },\n  { name: 'Orange', color: 'Orange' }\n];\n\nconsole.log(countOccurrences(fruits, 'color'));\n// Expected output: { Red: 2, Yellow: 1, Orange: 1 }\n\nconst numbers = [1, 2, 2, 3, 3, 3];\nconsole.log(countOccurrences(numbers.map(num => ({value: num})), 'value'));\n// Expected output: { '1': 1, '2': 2, '3': 3 }\n```",
          "options": [],
          "analysisPoints": [
            "Correct use of `reduce` to iterate and aggregate.",
            "Proper initialization of the `accumulator` (empty object).",
            "Correctly handling the increment logic (`acc[value] = (acc[value] || 0) + 1;`).",
            "Handling edge cases like empty arrays or non-existent keys gracefully (inherent in `|| 0`)."
          ],
          "keyConcepts": [
            "Array.prototype.reduce",
            "Object property access",
            "Counting occurrences",
            "Default values"
          ],
          "evaluationCriteria": [
            "Correct implementation of `reduce` for counting",
            "Code efficiency and readability",
            "Handling of potential undefined values gracefully"
          ],
          "example": null,
          "tags": [
            "array methods",
            "reduce",
            "coding challenge",
            "data aggregation"
          ],
          "prerequisites": [
            "theory_array_group_by_reduce"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_reduce_mcq_2",
          "topic": "Array.prototype.reduce",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following JavaScript code snippet:\n```javascript\nconst data = ['a', 'b', 'c', 'a', 'd', 'b'];\nconst result = data.reduce((acc, char) => {\n  acc[char] = (acc[char] || 0) + 1;\n  return acc;\n}, {});\nconsole.log(result);\n```\nWhat will be the output of `console.log(result)`?",
          "answer": "{ a: 2, b: 2, c: 1, d: 1 }",
          "options": [
            "['a', 'b', 'c', 'd']",
            "{ '0': 'a', '1': 'b', '2': 'c', '3': 'a', '4': 'd', '5': 'b' }",
            "{ a: 2, b: 2, c: 1, d: 1 }",
            "Error: Cannot read property of undefined"
          ],
          "analysisPoints": [
            "Tests understanding of `reduce`'s accumulator behavior.",
            "Confirms knowledge of how to count occurrences using an object as accumulator.",
            "Ensures the candidate understands the `(acc[char] || 0) + 1` pattern."
          ],
          "keyConcepts": [
            "Array.prototype.reduce",
            "Object as accumulator",
            "Counting occurrences",
            "Conditional (OR) assignment"
          ],
          "evaluationCriteria": [
            "Accurate prediction of `reduce` output",
            "Knowledge of common `reduce` patterns"
          ],
          "example": "The code iterates through the `data` array. The `acc` starts as `{}`. When 'a' is encountered the first time, `acc['a']` is `undefined`, so `(undefined || 0)` evaluates to `0`, and `acc['a']` becomes `1`. When 'a' is encountered again, `acc['a']` is `1`, so `(1 || 0)` evaluates to `1`, and `acc['a']` becomes `2`. This process correctly counts all unique characters.",
          "tags": [
            "array methods",
            "reduce",
            "MCQ",
            "JavaScript"
          ],
          "prerequisites": [
            "theory_array_group_by_reduce"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_callbacks_mcq_1",
          "topic": "Callbacks",
          "level": "easy",
          "type": "mcq",
          "question": "What is a callback function in JavaScript?",
          "answer": "A function passed as an argument to another function, to be executed later.",
          "options": [
            "A function that returns another function.",
            "A function passed as an argument to another function, to be executed later.",
            "A function that is immediately invoked after its definition.",
            "A function that only operates on synchronous code."
          ],
          "analysisPoints": [
            "Correctly defines a callback function.",
            "Distinguishes it from immediately invoked function expressions (IIFE) or higher-order functions that *return* functions."
          ],
          "keyConcepts": [
            "Callbacks",
            "Higher-order functions",
            "Asynchronous programming"
          ],
          "evaluationCriteria": [
            "Basic understanding of callback definition",
            "Ability to distinguish core concept"
          ],
          "example": "In `setTimeout(() => console.log('Hello'), 1000);`, the arrow function `() => console.log('Hello')` is a callback. It is passed to `setTimeout` and executed after a 1000ms delay.",
          "tags": [
            "callbacks",
            "JavaScript basics",
            "asynchronous"
          ],
          "prerequisites": [
            "javascript_functions"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_callbacks_open_1",
          "topic": "Callback Hell",
          "level": "medium",
          "type": "open",
          "question": "Describe 'callback hell' and explain at least two problems it creates in JavaScript code. How do Promises help mitigate these issues?",
          "answer": "'Callback hell' (or 'pyramid of doom') refers to the situation where multiple asynchronous operations are deeply nested using callbacks, leading to excessively indented, hard-to-read, and difficult-to-maintain code.\n\n**Problems it creates:**\n1.  **Readability/Maintainability**: The deep nesting makes the code very hard to follow, understand, and debug. Modifying or adding new steps to the sequence becomes a complex task.\n2.  **Error Handling**: Propagating errors through multiple layers of nested callbacks is cumbersome. Each callback typically needs its own error handling logic, or errors need to be explicitly passed down, leading to duplicated code and potential missed errors.\n3.  **Inversion of Control**: When you pass a callback to an asynchronous function, you lose direct control over when and how that callback is executed. The outer function decides when to invoke it, which can make debugging and reasoning about the flow challenging.\n\n**How Promises help:**\nPromises mitigate these issues by introducing a sequential, chainable mechanism (`.then()`, `.catch()`, `.finally()`). Instead of nesting functions, each asynchronous step returns a new Promise, allowing subsequent operations to be attached in a flat structure. This improves readability, provides a centralized and standard way to handle errors (using `.catch()` at any point in the chain), and restores some control to the developer as the chain explicitly defines the flow.",
          "analysisPoints": [
            "Accurate definition of callback hell.",
            "Clear explanation of at least two problems (readability, error handling, inversion of control).",
            "Concise explanation of how Promises (chaining, `.catch()`) solve these specific problems.",
            "Demonstrates understanding of the historical context and evolution of async JS."
          ],
          "keyConcepts": [
            "Callback hell",
            "Asynchronous programming",
            "Promises",
            "Promise chaining",
            "Error handling"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of callback hell's problems",
            "Ability to articulate Promise solutions effectively",
            "Clarity and structure of the explanation"
          ],
          "example": null,
          "tags": [
            "callbacks",
            "callback hell",
            "promises",
            "asynchronous",
            "architecture"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_callbacks",
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_callbacks_flashcard_1",
          "topic": "Asynchronous JavaScript",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the main advantage of asynchronous operations using callbacks over synchronous operations?",
          "answer": "Asynchronous operations allow the main thread to remain unblocked, preventing the application from freezing and improving user experience, especially for long-running tasks like network requests.",
          "analysisPoints": [],
          "keyConcepts": [
            "asynchronous",
            "synchronous",
            "callbacks",
            "non-blocking",
            "event loop"
          ],
          "evaluationCriteria": [
            "Recall of fundamental async benefits"
          ],
          "example": null,
          "tags": [
            "callbacks",
            "asynchronous",
            "performance"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_callbacks"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_callbacks_code_1",
          "topic": "Callbacks",
          "level": "easy",
          "type": "code",
          "question": "Implement a function `simulateLogin` that takes a `username`, `password`, and a `callback` function. Inside `simulateLogin`, use `setTimeout` to simulate an asynchronous login process. If `username` is 'admin' and `password` is 'password123', call the callback with `true` (success). Otherwise, call the callback with `false` (failure).",
          "answer": "```javascript\nfunction simulateLogin(username, password, callback) {\n  console.log(`Attempting login for user: ${username}...`);\n  setTimeout(() => {\n    if (username === 'admin' && password === 'password123') {\n      console.log('Login successful!');\n      callback(true);\n    } else {\n      console.log('Login failed: Invalid credentials.');\n      callback(false);\n    }\n  }, 1500); // Simulate network delay\n}\n\n// Usage example:\nsimulateLogin('admin', 'password123', (success) => {\n  if (success) {\n    console.log('User redirected to dashboard.');\n  } else {\n    console.log('Displaying login error message.');\n  }\n});\n\nsimulateLogin('guest', 'wrongpass', (success) => {\n  if (success) {\n    console.log('This should not happen for guest.');\n  } else {\n    console.log('Guest login attempt failed, as expected.');\n  }\n});\n```",
          "options": [],
          "analysisPoints": [
            "Correctly defines a function that accepts a callback.",
            "Uses `setTimeout` to simulate asynchronous behavior.",
            "Passes the result of the async operation (true/false) to the callback.",
            "Demonstrates basic conditional logic within the async function."
          ],
          "keyConcepts": [
            "Callbacks",
            "Asynchronous simulation",
            "setTimeout",
            "Conditional logic"
          ],
          "evaluationCriteria": [
            "Correct implementation of callback pattern",
            "Adherence to asynchronous behavior simulation",
            "Handling of success/failure conditions"
          ],
          "example": null,
          "tags": [
            "callbacks",
            "asynchronous",
            "coding challenge",
            "setTimeout"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_callbacks"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_callbacks_mcq_2",
          "topic": "Callbacks and Asynchronicity",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following code:\n```javascript\nconsole.log('Start');\n\nfunction processData(data, callback) {\n  setTimeout(() => {\n    console.log('Processing:', data);\n    callback('Processed ' + data);\n  }, 0);\n}\n\nprocessData('input', (result) => {\n  console.log('Result:', result);\n});\n\nconsole.log('End');\n```\nWhat is the exact order of the console outputs?",
          "answer": "Start, End, Processing: input, Result: Processed input",
          "options": [
            "Start, Processing: input, Result: Processed input, End",
            "Start, End, Processing: input, Result: Processed input",
            "Processing: input, Start, End, Result: Processed input",
            "Start, Result: Processed input, Processing: input, End"
          ],
          "analysisPoints": [
            "Tests understanding of the JavaScript event loop and `setTimeout(..., 0)`.",
            "Confirms that `setTimeout` always defers execution to the next tick of the event loop, even with a 0ms delay.",
            "Distinguishes between synchronous and asynchronous execution order."
          ],
          "keyConcepts": [
            "Event Loop",
            "setTimeout",
            "Callbacks",
            "Synchronous vs. Asynchronous"
          ],
          "evaluationCriteria": [
            "Accurate prediction of execution order",
            "Understanding of microtasks/macrotasks (implicitly `setTimeout` is a macrotask)"
          ],
          "example": "Even though `setTimeout` has a 0ms delay, it's still an asynchronous operation. This means `console.log('Start')` executes first, then `processData` is called and registers its callback to be run *after* the current synchronous execution stack is empty. Therefore, `console.log('End')` executes immediately after `processData` is *called* (not after its callback runs). Only then, the event loop picks up the `setTimeout` callback.",
          "tags": [
            "callbacks",
            "asynchronous",
            "event loop",
            "setTimeout",
            "MCQ"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_callbacks"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_promises_mcq_1",
          "topic": "Promises",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following are the three states a Promise can be in?",
          "answer": "Pending, Fulfilled, Rejected",
          "options": [
            "Running, Paused, Stopped",
            "Pending, Fulfilled, Rejected",
            "Active, Inactive, Completed",
            "Created, Resolved, Failed"
          ],
          "analysisPoints": [
            "Tests basic knowledge of Promise states.",
            "Ensures correct terminology is used."
          ],
          "keyConcepts": [
            "Promises",
            "Promise states"
          ],
          "evaluationCriteria": [
            "Recall of fundamental Promise concepts"
          ],
          "example": "When you create a new Promise, it starts in the `pending` state. If the asynchronous operation succeeds, you `resolve` it, and it moves to the `fulfilled` state. If it fails, you `reject` it, and it moves to the `rejected` state. Once `fulfilled` or `rejected`, the promise is `settled` and its state cannot change.",
          "tags": [
            "promises",
            "asynchronous",
            "JavaScript basics"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_promises_open_1",
          "topic": "Promises and Error Handling",
          "level": "medium",
          "type": "open",
          "question": "Explain the role of `.catch()` in a Promise chain and why it is generally preferred over passing a second argument to `.then()` for error handling. Provide a code example demonstrating a common anti-pattern with `.then()` for error handling and its `.catch()` alternative.",
          "answer": "The `.catch()` method in a Promise chain is used to register a callback that will be invoked only if the Promise chain encounters a rejection (an error). It's essentially a shorthand for `.then(null, onRejected)`.\n\n**Why `.catch()` is preferred over `then(success, error)`:**\n1.  **Readability**: Using `.catch()` explicitly separates error handling logic from success handling, making the code clearer and easier to read. A `.catch()` block visually signals that it's dealing with errors.\n2.  **Centralized Error Handling**: A single `.catch()` at the end of a Promise chain can catch errors from *any* preceding promise in that chain, including errors thrown within any `.then()` block. If you use `then(success, error)` for each step, you would have to duplicate error handling logic or manually re-throw errors to be caught by the next `onRejected`.\n3.  **Catches Errors in `.then()` callbacks**: Crucially, `.catch()` will also catch synchronous errors (exceptions) thrown within any `onFulfilled` callback of a preceding `.then()` in the chain. Passing `onRejected` to `then()` as a second argument would *not* catch errors thrown in the *first* argument's callback (the `onFulfilled` handler) of the *same* `.then()` call; it would only catch rejections from the *preceding* promise.\n\n**Anti-pattern with `.then()` for error handling:**\n```javascript\nfunction fetchData() {\n  return new Promise((resolve, reject) => {\n    // Simulate success/failure\n    const success = Math.random() > 0.5;\n    setTimeout(() => {\n      if (success) {\n        resolve('Data fetched');\n      } else {\n        reject(new Error('Network error'));\n      }\n    }, 500);\n  });\n}\n\nfetchData()\n  .then(data => {\n    console.log(data);\n    throw new Error('Error in processing data'); // This error will NOT be caught by the second arg of this .then()\n    return 'Processed ' + data;\n  }, error => { // Anti-pattern: error handler here\n    console.error('Caught error in first .then() (anti-pattern):', error.message);\n    // This handler only catches errors from fetchData(), not from the .then() callback itself\n  })\n  .then(processedData => {\n    console.log(processedData);\n  })\n  .catch(finalError => {\n    console.error('Caught by final .catch():', finalError.message); // This will catch 'Error in processing data'\n  });\n```\n\n**Preferred `.catch()` alternative:**\n```javascript\nfetchData()\n  .then(data => {\n    console.log(data);\n    throw new Error('Error in processing data'); // This error WILL be caught by the .catch() below\n    return 'Processed ' + data;\n  })\n  .then(processedData => {\n    console.log(processedData);\n  })\n  .catch(error => { // Preferred: Centralized error handling\n    console.error('Caught by .catch():', error.message);\n  })\n  .finally(() => {\n    console.log('Cleanup finished.');\n  });\n```",
          "analysisPoints": [
            "Correctly defines `.catch()` as a specialized `.then()` for errors.",
            "Clearly explains readability benefits.",
            "Highlights the key advantage: catching errors from any *previous* promise in the chain, including synchronous errors thrown in `.then()` callbacks.",
            "Provides a relevant and clear code example demonstrating the anti-pattern and the preferred solution."
          ],
          "keyConcepts": [
            "Promises",
            "Promise chaining",
            ".then()",
            ".catch()",
            "Error handling",
            "Synchronous errors in async chains"
          ],
          "evaluationCriteria": [
            "Thorough understanding of Promise error handling mechanisms",
            "Ability to articulate best practices with justification",
            "Provision of accurate and illustrative code examples"
          ],
          "example": null,
          "tags": [
            "promises",
            "error handling",
            "best practices",
            "asynchronous"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_promises_flashcard_1",
          "topic": "Promises",
          "level": "easy",
          "type": "flashcard",
          "question": "When does a Promise transition from 'pending' to 'settled'?",
          "answer": "A Promise transitions from 'pending' to 'settled' when it either moves to the 'fulfilled' state (due to `resolve()`) or the 'rejected' state (due to `reject()`).",
          "analysisPoints": [],
          "keyConcepts": [
            "promises",
            "promise states",
            "resolve",
            "reject",
            "settled"
          ],
          "evaluationCriteria": [
            "Recall of Promise state transitions"
          ],
          "example": null,
          "tags": [
            "promises",
            "asynchronous",
            "JavaScript"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_promises_code_1",
          "topic": "Promises",
          "level": "medium",
          "type": "code",
          "question": "Refactor the following callback-based function `getUserData` into a Promise-based version called `getUserDataPromise`. The new function should return a Promise that resolves with the user data or rejects with an error message.",
          "answer": "```javascript\n// Original callback-based function:\nfunction getUserDataCallback(userId, successCallback, errorCallback) {\n  console.log(`Fetching user ${userId} via callback...`);\n  setTimeout(() => {\n    if (userId === 123) {\n      successCallback({ id: 123, name: 'Alice', email: 'alice@example.com' });\n    } else {\n      errorCallback('User not found');\n    }\n  }, 1000);\n}\n\n// Refactored Promise-based function:\nfunction getUserDataPromise(userId) {\n  return new Promise((resolve, reject) => {\n    console.log(`Fetching user ${userId} via Promise...`);\n    setTimeout(() => {\n      if (userId === 123) {\n        resolve({ id: 123, name: 'Alice', email: 'alice@example.com' });\n      } else {\n        reject(new Error('User not found: ' + userId));\n      }\n    }, 1000);\n  });\n}\n\n// Usage of Promise-based version:\ngetUserDataPromise(123)\n  .then(user => {\n    console.log('Promise Success:', user);\n  })\n  .catch(error => {\n    console.error('Promise Error:', error.message);\n  });\n\ngetUserDataPromise(456)\n  .then(user => {\n    console.log('Promise Success (should not happen):', user);\n  })\n  .catch(error => {\n    console.error('Promise Error:', error.message);\n  });\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses the `new Promise()` constructor.",
            "Maps `successCallback` to `resolve` and `errorCallback` to `reject`.",
            "Ensures the Promise resolves with the correct data and rejects with an appropriate error object.",
            "Demonstrates the cleaner syntax of Promise consumption (`.then().catch()`)."
          ],
          "keyConcepts": [
            "Promises",
            "Callback to Promise conversion",
            "Asynchronous operations",
            "resolve/reject"
          ],
          "evaluationCriteria": [
            "Accurate conversion from callback to Promise pattern",
            "Proper use of `resolve` and `reject`",
            "Code adheres to Promise best practices"
          ],
          "example": null,
          "tags": [
            "promises",
            "callbacks",
            "refactoring",
            "coding challenge",
            "asynchronous"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_callbacks",
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_promises_mcq_2",
          "topic": "Promises Chaining",
          "level": "medium",
          "type": "mcq",
          "question": "What is the key benefit of chaining `.then()` calls when working with Promises, compared to nested callbacks?",
          "answer": "It flattens the code structure, improving readability and making error handling more centralized.",
          "options": [
            "It allows synchronous code to run faster.",
            "It flattens the code structure, improving readability and making error handling more centralized.",
            "It automatically retries failed operations without explicit code.",
            "It directly converts synchronous code into asynchronous."
          ],
          "analysisPoints": [
            "Highlights the solution to 'callback hell' (flattened structure).",
            "Emphasizes the improved readability and centralized error handling (`.catch()` at the end of chain).",
            "Incorrect options refer to unrelated or false benefits."
          ],
          "keyConcepts": [
            "Promises",
            "Promise chaining",
            "Callback hell",
            "Readability",
            "Error handling"
          ],
          "evaluationCriteria": [
            "Understanding of Promise chaining advantages",
            "Ability to compare Promises vs. Callbacks"
          ],
          "example": "Instead of `fetchUser(cb => fetchPosts(cb => fetchComments(cb => ...)))`, promise chaining looks like `fetchUser().then(user => fetchPosts(user.id)).then(posts => fetchComments(posts[0].id)).then(comments => ...)`. This flatter structure is much easier to read and manage.",
          "tags": [
            "promises",
            "promise chaining",
            "asynchronous",
            "best practices"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_promises_all_race_mcq_1",
          "topic": "Promise.all vs. Promise.race",
          "level": "hard",
          "type": "mcq",
          "question": "You need to fetch data from three different API endpoints concurrently. If *all* requests must succeed to proceed, which `Promise` static method should you use? If you only need the result from the *fastest* successful or failed request, which method should you use?",
          "answer": "`Promise.all` for all requests to succeed; `Promise.race` for the fastest request.",
          "options": [
            "`Promise.any` for all requests; `Promise.allSettled` for the fastest.",
            "`Promise.resolve` for all requests; `Promise.reject` for the fastest.",
            "`Promise.all` for all requests to succeed; `Promise.race` for the fastest request.",
            "`Promise.race` for all requests to succeed; `Promise.all` for the fastest request."
          ],
          "analysisPoints": [
            "Accurate distinction between `Promise.all` and `Promise.race` use cases.",
            "`Promise.all` waits for all to fulfill, or one to reject.",
            "`Promise.race` settles as soon as *any* promise settles (fulfills or rejects).",
            "Avoids confusion with `Promise.any` (first *fulfilled*) or `Promise.allSettled` (all settle, return status for each)."
          ],
          "keyConcepts": [
            "Promise.all",
            "Promise.race",
            "Concurrent operations",
            "Asynchronous patterns"
          ],
          "evaluationCriteria": [
            "Deep understanding of `Promise.all` and `Promise.race` behavior",
            "Ability to select appropriate Promise method for specific scenarios"
          ],
          "example": "If fetching user data, posts, and comments are all essential for displaying a profile, use `Promise.all`. If you have multiple image sources and just want to display the first one that loads, use `Promise.race`.",
          "tags": [
            "promises",
            "Promise.all",
            "Promise.race",
            "asynchronous patterns",
            "concurrency"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_promises_then_catch_flashcard",
          "topic": "Promises",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the return value of a `.then()` call in a Promise chain, and how does it enable chaining?",
          "answer": "A `.then()` call always returns a *new* Promise. This new Promise is resolved with the value returned by the callback passed to `.then()`, or rejected if an error is thrown within the callback or if the value returned is a rejected Promise. This consistent return of a new Promise is what allows subsequent `.then()` or `.catch()` calls to be chained.",
          "analysisPoints": [],
          "keyConcepts": [
            "promises",
            "promise chaining",
            ".then()",
            "return value"
          ],
          "evaluationCriteria": [
            "Recall of Promise chaining mechanism",
            "Understanding of return types"
          ],
          "example": null,
          "tags": [
            "promises",
            "asynchronous",
            "chaining"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_promises_static_methods_mcq",
          "topic": "Promise Static Methods",
          "level": "hard",
          "type": "mcq",
          "question": "Consider a scenario where you have multiple asynchronous operations, and you want to wait for all of them to complete, regardless of whether they succeed or fail. You then need to inspect the individual outcome (fulfilled or rejected) of each operation. Which `Promise` static method is best suited for this task?",
          "answer": "`Promise.allSettled`",
          "options": [
            "`Promise.all`",
            "`Promise.race`",
            "`Promise.any`",
            "`Promise.allSettled`"
          ],
          "analysisPoints": [
            "Tests knowledge of `Promise.allSettled`'s unique use case.",
            "Distinguishes `allSettled` from `all` (which rejects on first failure) and `race`/`any` (which resolve/reject on first settlement/fulfillment).",
            "Emphasizes the requirement to inspect *all* outcomes, regardless of success or failure."
          ],
          "keyConcepts": [
            "Promise.allSettled",
            "Promise.all",
            "Promise.race",
            "Promise.any",
            "Asynchronous patterns",
            "Error handling"
          ],
          "evaluationCriteria": [
            "Advanced understanding of Promise static methods",
            "Ability to choose the most appropriate method for a complex scenario"
          ],
          "example": "If you're making multiple API calls for different widgets on a dashboard, and you want to display all results (even if some widgets fail to load), `Promise.allSettled` is perfect. It will return an array like `[{status: 'fulfilled', value: data}, {status: 'rejected', reason: error}]`, allowing you to handle each outcome individually.",
          "tags": [
            "promises",
            "Promise.allSettled",
            "asynchronous patterns",
            "error handling",
            "advanced JavaScript"
          ],
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_advanced_groupby",
          "title": "Implement a Generic `groupBy` Function with Custom Key Extraction",
          "description": "\nImplement a JavaScript function `advancedGroupBy(array, keyExtractor)` that groups elements of an array based on a custom key. Instead of a simple string `key`, the function should accept a `keyExtractor` argument which can be:\n\n1.  **A string**: In this case, `advancedGroupBy` should behave like the original `groupBy` function, using the string as the property name to group by.\n2.  **A function**: If `keyExtractor` is a function, it should be called for each item in the array, and its return value should be used as the grouping key.\n\nYour implementation must use `Array.prototype.reduce()`.\n\n**Requirements:**\n*   The function signature should be `advancedGroupBy(array, keyExtractor)`.\n*   Handle both string and function `keyExtractor` types.\n*   Return an object where keys are the extracted group values and values are arrays of items belonging to that group.\n*   Ensure the function is robust and handles edge cases like empty arrays or `null`/`undefined` items.\n",
          "difficulty": "medium",
          "startingCode": "function advancedGroupBy(array, keyExtractor) {\n  // TODO: Implement the required functionality\n  // Consider keyExtractor being a string or a function.\n  // Use Array.prototype.reduce()\n\n  return array.reduce((acc, item) => {\n    // Your grouping logic here\n    return acc;\n  }, {});\n}\n\n// Example usage (for testing):\n// const users = [\n//   { id: 1, name: 'Alice', role: 'admin', lastLogin: new Date('2023-01-15') },\n//   { id: 2, name: 'Bob', role: 'user', lastLogin: new Date('2023-01-10') },\n//   { id: 3, name: 'Charlie', role: 'admin', lastLogin: new Date('2023-02-01') },\n//   { id: 4, name: 'David', role: 'user', lastLogin: new Date('2023-01-20') },\n// ];\n//\n// // Group by string key 'role'\n// console.log('Grouped by role:', advancedGroupBy(users, 'role'));\n//\n// // Group by function (e.g., login month)\n// console.log('Grouped by login month:', advancedGroupBy(users, user => user.lastLogin.getMonth() + 1));\n",
          "solutionCode": "function advancedGroupBy(array, keyExtractor) {\n  if (!Array.isArray(array)) {\n    throw new Error('Input must be an array.');\n  }\n\n  return array.reduce((acc, item) => {\n    if (item === null || typeof item === 'undefined') {\n      // Optionally handle null/undefined items, e.g., skip them or group under a special key\n      return acc;\n    }\n\n    let key;\n    if (typeof keyExtractor === 'string') {\n      key = item[keyExtractor];\n    } else if (typeof keyExtractor === 'function') {\n      key = keyExtractor(item);\n    } else {\n      throw new Error('keyExtractor must be a string or a function.');\n    }\n\n    // Handle cases where the extracted key itself might be null or undefined\n    const groupKey = (key === null || typeof key === 'undefined') ? 'null_undefined_group' : key;\n\n    (acc[groupKey] = acc[groupKey] || []).push(item);\n    return acc;\n  }, {});\n}\n",
          "testCases": [
            "Test with string key: `advancedGroupBy([{id: 1, type: 'A'}, {id: 2, type: 'B'}, {id: 3, type: 'A'}], 'type')` should return `{ A: [{id: 1, type: 'A'}, {id: 3, type: 'A'}], B: [{id: 2, type: 'B'}] }`",
            "Test with function key: `advancedGroupBy([{val: 1}, {val: 2}, {val: 3}], item => item.val % 2 === 0 ? 'even' : 'odd')` should return `{ odd: [{val: 1}, {val: 3}], even: [{val: 2}] }`",
            "Test with empty array: `advancedGroupBy([], 'type')` should return `{}`",
            "Test with mixed types for key: `advancedGroupBy([{value: 1}, {value: '2'}, {value: true}], item => typeof item.value)` should group by 'number', 'string', 'boolean'.",
            "Test with null/undefined values for grouping key: `advancedGroupBy([{val:1}, {val:null}, {val:2}], 'val')` should group `null` into a specific key or handle as required.",
            "Test with `keyExtractor` returning `null`/`undefined`: `advancedGroupBy([{a:1}, {a:null}], item => item.a)` should correctly handle null as a key.",
            "Test with invalid `keyExtractor` type: `advancedGroupBy([{a:1}], 123)` should throw an error."
          ],
          "hints": [
            "Check the `typeof` `keyExtractor` inside the `reduce` callback to determine how to extract the key.",
            "Remember the `(result[key] = result[key] || []).push(item)` pattern from the initial example.",
            "Consider how to handle cases where `item[keyExtractor]` or `keyExtractor(item)` might return `null` or `undefined`."
          ],
          "tags": [
            "Array.prototype.reduce",
            "functional programming",
            "data transformation",
            "utility functions",
            "higher-order functions"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_array_group_by_reduce"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "hof",
            "polymorphism",
            "data_structures"
          ]
        },
        {
          "id": "task_callback_to_promise",
          "title": "Refactor Callback-based API to Promise-based with Chaining",
          "description": "\nYou are given a set of callback-based asynchronous functions that simulate API calls. Your task is to refactor them into Promise-based functions and then chain them together to perform a sequence of operations.\n\n**Given Callback Functions (DO NOT MODIFY THESE):**\n```javascript\nfunction fetchUserData(userId, callback) {\n  console.log(`[CB] Fetching user ${userId}...`);\n  setTimeout(() => {\n    if (userId === 1) {\n      callback(null, { id: 1, name: 'Alice', email: 'alice@example.com' });\n    } else {\n      callback(new Error('User not found'), null);\n    }\n  }, 500);\n}\n\nfunction fetchUserPosts(userId, callback) {\n  console.log(`[CB] Fetching posts for user ${userId}...`);\n  setTimeout(() => {\n    if (userId === 1) {\n      callback(null, [{ postId: 101, title: 'My First Post' }, { postId: 102, title: 'My Second Post' }]);\n    } else {\n      callback(new Error('No posts found for user'), null);\n    }\n  }, 700);\n}\n\nfunction fetchPostComments(postId, callback) {\n  console.log(`[CB] Fetching comments for post ${postId}...`);\n  setTimeout(() => {\n    if (postId === 101) {\n      callback(null, [{ commentId: 201, text: 'Great post!' }, { commentId: 202, text: 'Awesome!' }]);\n    } else {\n      callback(new Error('No comments found for post'), null);\n    }\n  }, 600);\n}\n```\n\n**Requirements:**\n1.  **Create Promise-based equivalents**: For each `fetch*` function above, create a new function (e.g., `fetchUserDataPromise`, `fetchUserPostsPromise`, `fetchPostCommentsPromise`) that returns a Promise. The Promise should `resolve` with the data on success and `reject` with an `Error` object on failure.\n2.  **Chain Operations**: Use your new Promise-based functions to fetch the following sequence for `userId = 1`:\n    *   User Data\n    *   Then, Posts for that user\n    *   Then, Comments for the *first* post of that user.\n3.  **Error Handling**: Implement proper error handling using `.catch()` to log any errors that occur at any stage of the chain.\n4.  **Final Cleanup**: Use `.finally()` to log a message indicating the entire process has finished, regardless of success or failure.\n",
          "difficulty": "medium",
          "startingCode": "// Given Callback Functions (DO NOT MODIFY THESE):\nfunction fetchUserData(userId, callback) {\n  console.log(`[CB] Fetching user ${userId}...`);\n  setTimeout(() => {\n    if (userId === 1) {\n      callback(null, { id: 1, name: 'Alice', email: 'alice@example.com' });\n    } else {\n      callback(new Error('User not found'), null);\n    }\n  }, 500);\n}\n\nfunction fetchUserPosts(userId, callback) {\n  console.log(`[CB] Fetching posts for user ${userId}...`);\n  setTimeout(() => {\n    if (userId === 1) {\n      callback(null, [{ postId: 101, title: 'My First Post' }, { postId: 102, title: 'My Second Post' }]);\n    } else {\n      callback(new Error('No posts found for user'), null);\n    }\n  }, 700);\n}\n\nfunction fetchPostComments(postId, callback) {\n  console.log(`[CB] Fetching comments for post ${postId}...`);\n  setTimeout(() => {\n    if (postId === 101) {\n      callback(null, [{ commentId: 201, text: 'Great post!' }, { commentId: 202, text: 'Awesome!' }]);\n    } else {\n      callback(new Error('No comments found for post'), null);\n    }\n  }, 600);\n}\n\n// TODO: Implement Promise-based equivalents and chain them\n// function fetchUserDataPromise(userId) { /* ... */ }\n// function fetchUserPostsPromise(userId) { /* ... */ }\n// function fetchPostCommentsPromise(postId) { /* ... */ }\n\n// Your Promise chain for userId = 1 here:\n",
          "solutionCode": "// Given Callback Functions (DO NOT MODIFY THESE):\nfunction fetchUserData(userId, callback) {\n  console.log(`[CB] Fetching user ${userId}...`);\n  setTimeout(() => {\n    if (userId === 1) {\n      callback(null, { id: 1, name: 'Alice', email: 'alice@example.com' });\n    } else {\n      callback(new Error('User not found'), null);\n    }\n  }, 500);\n}\n\nfunction fetchUserPosts(userId, callback) {\n  console.log(`[CB] Fetching posts for user ${userId}...`);\n  setTimeout(() => {\n    if (userId === 1) {\n      callback(null, [{ postId: 101, title: 'My First Post' }, { postId: 102, title: 'My Second Post' }]);\n    } else {\n      callback(new Error('No posts found for user'), null);\n    }\n  }, 700);\n}\n\nfunction fetchPostComments(postId, callback) {\n  console.log(`[CB] Fetching comments for post ${postId}...`);\n  setTimeout(() => {\n    if (postId === 101) {\n      callback(null, [{ commentId: 201, text: 'Great post!' }, { commentId: 202, text: 'Awesome!' }]);\n    } else {\n      callback(new Error('No comments found for post'), null);\n    }\n  }, 600);\n}\n\n// 1. Create Promise-based equivalents\nfunction fetchUserDataPromise(userId) {\n  return new Promise((resolve, reject) => {\n    fetchUserData(userId, (error, data) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\nfunction fetchUserPostsPromise(userId) {\n  return new Promise((resolve, reject) => {\n    fetchUserPosts(userId, (error, data) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\nfunction fetchPostCommentsPromise(postId) {\n  return new Promise((resolve, reject) => {\n    fetchPostComments(postId, (error, data) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\n// 2. Chain Operations, 3. Error Handling, 4. Final Cleanup\nconst TARGET_USER_ID = 1;\n\nconsole.log('--- Starting Promise Chain ---');\nfetchUserDataPromise(TARGET_USER_ID)\n  .then(user => {\n    console.log('[P] User Data:', user);\n    return fetchUserPostsPromise(user.id);\n  })\n  .then(posts => {\n    console.log('[P] User Posts:', posts);\n    if (posts.length > 0) {\n      return fetchPostCommentsPromise(posts[0].postId);\n    } else {\n      throw new Error('No posts available to fetch comments for.');\n    }\n  })\n  .then(comments => {\n    console.log('[P] First Post Comments:', comments);\n    console.log('--- All operations succeeded! ---');\n  })\n  .catch(error => {\n    console.error('[P] An error occurred in the chain:', error.message);\n  })\n  .finally(() => {\n    console.log('--- Promise chain process finished. ---');\n  });\n\n// Test case for a user not found to demonstrate error handling\nconst NON_EXISTENT_USER_ID = 999;\nconsole.log('\\n--- Starting Promise Chain for non-existent user ---');\nfetchUserDataPromise(NON_EXISTENT_USER_ID)\n  .then(user => {\n    console.log('[P] User Data (should not happen):', user);\n  })\n  .catch(error => {\n    console.error('[P] Error for non-existent user:', error.message);\n  })\n  .finally(() => {\n    console.log('--- Promise chain for non-existent user finished. ---');\n  });\n\n// Test case for no posts found\nconst USER_ID_NO_POSTS = 2; // Assuming userId 2 would yield no posts from CB function logic\n// (Note: The given CB functions only have logic for userId 1)\n// For a proper test, fetchUserPosts or fetchUserData would need to be modified\n// to return specific errors or empty arrays for userId 2.\n// As per the original problem statement, we stick to the provided CBs.\n// Let's simulate a case where fetchUserPosts would return an empty array if userId != 1\n// This specific test case might not work with the given CBs as they only handle userId === 1 for success.\n// To test 'no posts found', the `fetchUserPosts` callback logic would need modification.\n// For now, the non-existent user test covers the rejection path.\n\n",
          "testCases": [
            "Successful chain for `userId = 1`: User data, posts, and comments for post 101 should be logged.",
            "Error handling for non-existent user: `fetchUserDataPromise(999)` should trigger the `.catch()` block.",
            "Error handling for no posts: (Requires modification to `fetchUserPosts` to return `null` or empty array based on user ID). If `fetchUserPostsPromise` rejects, the `.catch()` should be hit.",
            "Error handling for no comments: (Requires modification to `fetchPostComments` to reject for specific `postId`). If `fetchPostCommentsPromise` rejects, the `.catch()` should be hit.",
            "Verify `.finally()` is always executed, whether success or failure.",
            "Ensure no callback hell is present in the solution."
          ],
          "hints": [
            "Remember that the `Promise` constructor takes a function with `resolve` and `reject` arguments.",
            "The `error` argument in the original callback functions should map to `reject(new Error(error_message))`, and the `data` argument should map to `resolve(data)`.",
            "When chaining, remember that a `.then()` callback should return a *new* promise if the next operation is asynchronous, or a value if it's synchronous.",
            "Use `if (posts.length > 0)` before attempting to access `posts[0]` to prevent errors if no posts are returned."
          ],
          "tags": [
            "promises",
            "refactoring",
            "asynchronous",
            "promise chaining",
            "error handling",
            "callback hell solution"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "theory_asynchronous_javascript_callbacks",
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "async_await",
            "fetch_api"
          ]
        },
        {
          "id": "task_concurrent_api_calls",
          "title": "Perform Concurrent API Calls with Success/Failure Aggregation",
          "description": "\nYou need to fetch data from multiple independent API endpoints concurrently. Your application requires knowing the outcome of *all* requests (whether they succeeded or failed) and then processing their results.\n\n**Given Mock API Functions (DO NOT MODIFY THESE):**\n```javascript\nfunction mockFetch(url, delay, success = true) {\n  return new Promise((resolve, reject) => {\n    console.log(`Fetching from ${url} (simulating ${success ? 'success' : 'failure'})...`);\n    setTimeout(() => {\n      if (success) {\n        resolve(`Data from ${url}`);\n      } else {\n        reject(new Error(`Failed to fetch from ${url}`));\n      }\n    }, delay);\n  });\n}\n```\n\n**Requirements:**\n1.  **Concurrent Execution**: Make three concurrent calls using `mockFetch`:\n    *   `mockFetch('/api/users', 800, true)`\n    *   `mockFetch('/api/products', 1200, false)` (simulate failure)\n    *   `mockFetch('/api/orders', 600, true)`\n2.  **Aggregate All Outcomes**: Use the appropriate `Promise` static method to wait for *all* these promises to settle (either fulfill or reject).\n3.  **Process Results**: After all promises have settled, iterate through their outcomes and log whether each operation was `fulfilled` or `rejected`, along with its value or reason. Format the output clearly.\n4.  **No Early Exit**: Ensure that even if one promise rejects, the entire operation continues until all promises have completed.\n",
          "difficulty": "hard",
          "startingCode": "function mockFetch(url, delay, success = true) {\n  return new Promise((resolve, reject) => {\n    console.log(`Fetching from ${url} (simulating ${success ? 'success' : 'failure'})...`);\n    setTimeout(() => {\n      if (success) {\n        resolve(`Data from ${url}`);\n      } else {\n        reject(new Error(`Failed to fetch from ${url}`));\n      }\n    }, delay);\n  });\n}\n\n// TODO: Implement the concurrent calls and process results\n// const promise1 = mockFetch('/api/users', 800, true);\n// const promise2 = mockFetch('/api/products', 1200, false);\n// const promise3 = mockFetch('/api/orders', 600, true);\n\n// Use the appropriate Promise static method here...\n",
          "solutionCode": "function mockFetch(url, delay, success = true) {\n  return new Promise((resolve, reject) => {\n    console.log(`Fetching from ${url} (simulating ${success ? 'success' : 'failure'})...`);\n    setTimeout(() => {\n      if (success) {\n        resolve(`Data from ${url}`);\n      } else {\n        reject(new Error(`Failed to fetch from ${url}`));\n      }\n    }, delay);\n  });\n}\n\n// 1. Concurrent Execution\nconst promise1 = mockFetch('/api/users', 800, true);\nconst promise2 = mockFetch('/api/products', 1200, false); // Simulate failure\nconst promise3 = mockFetch('/api/orders', 600, true);\n\n// 2. Aggregate All Outcomes using Promise.allSettled\nconsole.log('--- Starting Concurrent Fetches ---');\nPromise.allSettled([promise1, promise2, promise3])\n  .then(results => {\n    console.log('\\n--- All Promises Settled ---');\n    results.forEach((result, index) => {\n      console.log(`Promise ${index + 1} (${result.status}):`);\n      if (result.status === 'fulfilled') {\n        console.log(`  Value: ${result.value}`);\n      } else {\n        console.error(`  Reason: ${result.reason.message}`);\n      }\n    });\n    console.log('--- Processing complete ---');\n  })\n  .catch(error => {\n    // This catch block will typically not be hit by Promise.allSettled\n    // unless there's an error in the .then() callback itself, or if the input isn't iterable.\n    console.error('Unexpected error during allSettled:', error.message);\n  });\n",
          "testCases": [
            "All three `mockFetch` calls should initiate concurrently.",
            "`Promise.allSettled` should resolve only after the longest-running promise (`/api/products` at 1200ms) has settled.",
            "The `results` array should contain three objects, each with a `status` property (`fulfilled` or `rejected`).",
            "The object for `/api/users` should have `status: 'fulfilled'` and `value: 'Data from /api/users'`.",
            "The object for `/api/products` should have `status: 'rejected'` and `reason: Error('Failed to fetch from /api/products')`.",
            "The object for `/api/orders` should have `status: 'fulfilled'` and `value: 'Data from /api/orders'`.",
            "The output should clearly indicate the status and result/reason for each individual promise.",
            "The `.catch()` block should *not* be triggered by the rejection of `promise2` (as `Promise.allSettled` doesn't reject)."
          ],
          "hints": [
            "Consider which `Promise` static method resolves *after all promises settle*, regardless of individual success or failure.",
            "The result of this specific static method is an array of objects, where each object describes the outcome of a promise (e.g., `{ status: 'fulfilled', value: data }` or `{ status: 'rejected', reason: error }`).",
            "Iterate through the results array and use conditional logic to log based on `status`."
          ],
          "tags": [
            "promises",
            "Promise.allSettled",
            "asynchronous",
            "concurrent programming",
            "error handling",
            "API calls"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "theory_asynchronous_javascript_promises"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "async_await",
            "fetch_api",
            "concurrency"
          ]
        }
      ]
    }
  }
]