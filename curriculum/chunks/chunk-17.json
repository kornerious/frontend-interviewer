[
  {
    "id": "95c3d04e-9528-42b0-bc0d-990dd359c4ab",
    "startLine": 3500,
    "endLine": 3599,
    "processedDate": "2025-06-17T08:46:57.355Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_immutable_state_updates",
          "title": "Immutable State Updates for Objects and Nested Objects in React",
          "content": "In React, direct modification of state can lead to unexpected behavior and make debugging difficult. React relies on state immutability to optimize re-renders and ensure predictable data flow. When updating state that contains objects or arrays, you should always create a *new* object or array rather than mutating the existing one. The spread syntax (`...`) is a powerful tool for achieving this.\n\n## Updating Top-Level Object Properties\nWhen a state variable is an object, and you need to update one of its properties, you should spread the existing state object into a new object, and then override the specific property you want to change. This creates a new object with the desired update, preserving the other properties.\n\n## Updating Nested Object Properties\nFor nested objects, the principle remains the same: immutability at every level. You need to create a new object for each level of nesting that you are modifying. This often involves multiple spread operations, working from the outermost object inwards to the property being updated.",
          "examples": [
            {
              "id": "example_immutable_state_1",
              "title": "Updating a Top-Level Object Property",
              "code": "import React, { useState } from 'react';\n\nfunction UserProfileEditor() {\n  const [user, setUser] = useState({\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com'\n  });\n\n  const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    // Create a new user object, spreading the old properties\n    // and overriding 'name'\n    setUser({\n      ...user,\n      name: event.target.value\n    });\n  };\n\n  return (\n    <div>\n      <label>Name:</label>\n      <input type=\"text\" value={user.name} onChange={handleNameChange} />\n      <p>Current Name: {user.name}</p>\n      <p>Age: {user.age}</p>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates how to immutably update the `name` property of the `user` state object. `...user` copies all existing properties, and `name: event.target.value` then overwrites the `name` property in the new object. This ensures other properties like `age` and `email` remain unchanged without direct mutation.",
              "language": "typescript"
            },
            {
              "id": "example_immutable_state_2",
              "title": "Updating a Nested Object Property",
              "code": "import React, { useState } from 'react';\n\nfunction UserPreferencesEditor() {\n  const [user, setUser] = useState({\n    name: 'Bob',\n    preferences: {\n      newsletter: false,\n      notifications: true\n    }\n  });\n\n  const toggleNewsletter = () => {\n    // To update 'newsletter', we need to create new objects for:\n    // 1. the 'preferences' object\n    // 2. the top-level 'user' object\n    setUser({\n      ...user, // Copy existing user properties\n      preferences: {\n        ...user.preferences, // Copy existing preferences properties\n        newsletter: !user.preferences.newsletter // Override newsletter\n      }\n    });\n  };\n\n  return (\n    <div>\n      <p>Newsletter Subscription: {user.preferences.newsletter ? 'Subscribed' : 'Not Subscribed'}</p>\n      <button onClick={toggleNewsletter}>Toggle Newsletter</button>\n    </div>\n  );\n}",
              "explanation": "This example shows how to update a nested property (`newsletter`) within the `preferences` object. Notice the nested spread operations: `...user.preferences` creates a new `preferences` object, and then `...user` creates a new `user` object containing the newly created `preferences` object. This ensures immutability at all levels.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_immutable_state_1",
            "question_immutable_state_2",
            "question_immutable_state_3",
            "question_immutable_state_4",
            "question_immutable_state_5"
          ],
          "relatedTasks": [
            "task_user_profile_form"
          ],
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "JavaScript",
            "ES6"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript_Objects",
            "JavaScript_Spread_Syntax",
            "React_useState"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Redux",
            "Context_API",
            "Performance_Optimization"
          ]
        },
        {
          "id": "theory_multiple_state_variables",
          "title": "Managing Multiple State Variables with `useState` Hook",
          "content": "When managing component state in React functional components, developers often face a choice: use a single `useState` call with an object to hold all related state, or use multiple `useState` calls for individual state variables. Both approaches have their merits and can be appropriate depending on the specific use case.\n\n## Single State Object with `useState`\nThis approach involves declaring a single state variable that holds an object. All related pieces of state are properties within this object. When updating any part of this object, you must use the immutable update pattern (spreading the old object and then overwriting the specific property). This can lead to more complex update logic for nested properties but keeps all related state grouped together.\n\n## Multiple `useState` Calls\nThis approach involves declaring a separate `useState` call for each distinct piece of state. For example, `[name, setName]` for a user's name and `[email, setEmail]` for their email. This simplifies individual updates as you just call the corresponding setter function. However, it can lead to many `useState` calls if a component has a large number of independent state variables.\n\n## When to choose which approach?\n*   **Single State Object:** Prefer this when state variables are highly related, frequently updated together, or form a complex, hierarchical data structure. It can make the state more cohesive.\n*   **Multiple `useState` Calls:** Prefer this when state variables are mostly independent, updated separately, and are of simple types (strings, numbers, booleans). It often leads to cleaner update logic for individual pieces of state and can prevent unnecessary re-renders if the `set` function is called with the exact same value.",
          "examples": [
            {
              "id": "example_multiple_state_1",
              "title": "Single State Object Approach",
              "code": "import React, { useState } from 'react';\n\nfunction UserFormSingleState() {\n  const [user, setUser] = useState({\n    name: '',\n    email: '',\n    preferences: {\n      newsletter: false,\n      notifications: true\n    }\n  });\n\n  const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setUser({ ...user, name: event.target.value });\n  };\n\n  const handleEmailChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setUser({ ...user, email: event.target.value });\n  };\n\n  const toggleNewsletter = () => {\n    setUser({\n      ...user,\n      preferences: {\n        ...user.preferences,\n        newsletter: !user.preferences.newsletter\n      }\n    });\n  };\n\n  return (\n    <form>\n      <input type=\"text\" value={user.name} onChange={handleNameChange} placeholder=\"Name\" />\n      <input type=\"email\" value={user.email} onChange={handleEmailChange} placeholder=\"Email\" />\n      <label>\n        <input type=\"checkbox\" checked={user.preferences.newsletter} onChange={toggleNewsletter} />\n        Subscribe to Newsletter\n      </label>\n      <p>Name: {user.name}, Email: {user.email}, Newsletter: {user.preferences.newsletter.toString()}</p>\n    </form>\n  );\n}",
              "explanation": "This example uses a single `user` object to hold all form data. Updates for `name` and `email` are simple, but `newsletter` requires nested spread syntax as seen in the previous theory block. This approach groups related data.",
              "language": "typescript"
            },
            {
              "id": "example_multiple_state_2",
              "title": "Multiple `useState` Calls Approach",
              "code": "import React, { useState } from 'react';\n\nfunction UserFormMultipleState() {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n  const [preferences, setPreferences] = useState({\n    newsletter: false,\n    notifications: true\n  });\n\n  const toggleNewsletter = () => {\n    setPreferences({ ...preferences, newsletter: !preferences.newsletter });\n  };\n\n  return (\n    <form>\n      <input type=\"text\" value={name} onChange={(e) => setName(e.target.value)} placeholder=\"Name\" />\n      <input type=\"email\" value={email} onChange={(e) => setEmail(e.target.value)} placeholder=\"Email\" />\n      <label>\n        <input type=\"checkbox\" checked={preferences.newsletter} onChange={toggleNewsletter} />\n        Subscribe to Newsletter\n      </label>\n      <p>Name: {name}, Email: {email}, Newsletter: {preferences.newsletter.toString()}</p>\n    </form>\n  );\n}",
              "explanation": "Here, `name`, `email`, and `preferences` are separate state variables. Each has its own setter, making individual updates straightforward (`setName`, `setEmail`). The `preferences` object still requires immutable updates, but it's isolated to that specific state variable.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_multiple_state_1",
            "question_multiple_state_2",
            "question_multiple_state_3",
            "question_multiple_state_4"
          ],
          "relatedTasks": [
            "task_user_profile_form"
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "State Management",
            "Performance"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Functional_Components",
            "React_useState"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "React_Forms",
            "Complex_UIs"
          ]
        },
        {
          "id": "theory_immutable_array_manipulation",
          "title": "Immutable Array Manipulation in React State",
          "content": "Just like objects, arrays in React state should be treated immutably. Modifying an array directly (e.g., using `push`, `pop`, `splice`) will not trigger a re-render and can lead to bugs because React's shallow comparison might not detect the change. Instead, you should always return a *new* array with the desired modifications.\n\n## Common Immutable Array Operations\n*   **Adding Elements:** Use the spread syntax (`...`) to create a new array with existing elements and the new element(s). Example: `[...oldArray, newElement]` or `[newElement, ...oldArray]`.\n*   **Removing Elements:** Use the `filter()` method, which always returns a new array containing only the elements that pass a provided test. This is ideal for removing items by index or by a specific property (like an ID).\n*   **Updating Elements:** Use `map()` to iterate over the array and return a new array with the updated element(s). Example: `oldArray.map(item => item.id === idToUpdate ? { ...item, updatedProp: newValue } : item)`.\n*   **Concatenating Arrays:** Use `concat()` or spread syntax. Example: `array1.concat(array2)` or `[...array1, ...array2]`.\n*   **Sorting Arrays:** Create a shallow copy first using `slice()` or spread syntax before calling `sort()`. Example: `[...oldArray].sort((a,b) => a.value - b.value)`.",
          "examples": [
            {
              "id": "example_immutable_array_1",
              "title": "Removing an Array Element by Index (Filter)",
              "code": "import React, { useState } from 'react';\n\nfunction ItemListByIndex() {\n  const [data, setData] = useState(['Apple', 'Banana', 'Cherry', 'Date']);\n\n  const removeItemByIndex = (indexToRemove: number) => {\n    setData(\n      data.filter((_, i) => i !== indexToRemove) // Filter out the item at the specified index\n    );\n  };\n\n  return (\n    <div>\n      <h3>Items:</h3>\n      <ul>\n        {data.map((item, index) => (\n          <li key={index}>\n            {item}\n            <button onClick={() => removeItemByIndex(index)}>Remove</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
              "explanation": "This example demonstrates removing an element by its index using `filter`. The `filter` method iterates over the array and creates a new array containing all elements except the one at `indexToRemove`. This is an immutable operation.",
              "language": "typescript"
            },
            {
              "id": "example_immutable_array_2",
              "title": "Removing an Array Element by ID (Filter)",
              "code": "import React, { useState } from 'react';\n\ninterface Item { id: number; name: string; }\n\nfunction ItemListById() {\n  const [data, setData] = useState<Item[]>([\n    { id: 1, name: 'Laptop' },\n    { id: 2, name: 'Keyboard' },\n    { id: 3, name: 'Mouse' }\n  ]);\n\n  const removeItemById = (idToRemove: number) => {\n    setData(\n      data.filter(item => item.id !== idToRemove) // Filter out the item with the specified ID\n    );\n  };\n\n  return (\n    <div>\n      <h3>Products:</h3>\n      <ul>\n        {data.map(item => (\n          <li key={item.id}>\n            {item.name}\n            <button onClick={() => removeItemById(item.id)}>Remove</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
              "explanation": "Similar to removing by index, `filter` is used here to remove an item based on a unique `id` property. This is a common and robust way to remove items from an array in a React application, ensuring state immutability.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_immutable_array_1",
            "question_immutable_array_2",
            "question_immutable_array_3",
            "question_immutable_array_4"
          ],
          "relatedTasks": [
            "task_todo_list_manager"
          ],
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Array Methods",
            "JavaScript"
          ],
          "technology": "React",
          "prerequisites": [
            "JavaScript_Arrays",
            "JavaScript_Array_Methods",
            "React_useState"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Complex_Lists",
            "Data_Manipulation"
          ]
        },
        {
          "id": "theory_refs_dom_manipulation",
          "title": "Direct DOM Manipulation with Refs in React",
          "content": "While React encourages a declarative approach to UI development, there are scenarios where direct interaction with the DOM element is necessary. These include managing focus, text selection, media playback, triggering imperative animations, or integrating with third-party DOM libraries. React provides `refs` (short for 'references') for this purpose.\n\n## Refs in Class Components\nIn class components, refs are typically created using `React.createRef()` in the constructor or a callback ref. The ref is then attached to an element's `ref` attribute in the `render` method. The current DOM node can be accessed via `this.refName.current` after the component has mounted (e.g., in `componentDidMount`). Callback refs give more fine-grained control, allowing a function to be executed directly with the DOM node as an argument.\n\n## Refs in Functional Components (with `useRef`)\nIn functional components, the `useRef` hook provides a way to create a mutable `ref` object. This object will persist for the full lifetime of the component. The `ref` object has a `current` property that initially holds `null` and will point to the DOM element once it's rendered. To trigger actions after the component mounts or updates, `useEffect` is typically used in conjunction with `useRef`.\n\n## When to Use Refs?\n*   Managing focus, text selection, or media playback.\n*   Triggering imperative animations.\n*   Integrating with third-party DOM libraries.\n*   Measuring the size or position of a DOM element.\n\n**Avoid using refs for anything that can be done declaratively.** For example, don't use refs to change styling or content if state and props can achieve the same result.",
          "examples": [
            {
              "id": "example_refs_class_component",
              "title": "Focusing Input using Class Component Ref",
              "code": "import React from 'react';\n\nclass AutoFocusFormClass extends React.Component {\n  private nameInput: HTMLInputElement | null = null; // Declare type for better safety\n\n  componentDidMount() {\n    // Focus the input element when component mounts\n    if (this.nameInput) {\n      this.nameInput.focus();\n    }\n  }\n\n  render() {\n    return (\n      <form>\n        <p>Class Component Example:</p>\n        <input \n          ref={(input) => { this.nameInput = input; }} // Callback Ref\n          defaultValue=\"Will be focused on load (Class)\"\n        />\n      </form>\n    );\n  }\n}",
              "explanation": "This example uses a callback ref in a class component. The `ref` attribute is assigned a function that receives the DOM element (`input`) as an argument. This element is then stored in `this.nameInput`. In `componentDidMount`, after the component is rendered and the DOM element is available, `focus()` is called on it.",
              "language": "typescript"
            },
            {
              "id": "example_refs_functional_component",
              "title": "Focusing Input using Functional Component Ref with `useRef`",
              "code": "import React, { useRef, useEffect } from 'react';\n\nfunction AutoFocusFormHooks() {\n  const inputRef = useRef<HTMLInputElement>(null); // Initialize with null, specify type\n  \n  useEffect(() => {\n    // Focus the input element when component mounts\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Empty dependency array means this runs once on mount\n  \n  return (\n    <form>\n      <p>Functional Component Example:</p>\n      <input \n        ref={inputRef} // Assign the ref object to the element\n        defaultValue=\"Will be focused on load (Hooks)\"\n      />\n    </form>\n  );\n}",
              "explanation": "This example uses the `useRef` hook in a functional component. `inputRef` is a mutable object whose `current` property will hold the DOM node. `useEffect` with an empty dependency array ensures the `focus()` call happens only once after the initial render, when `inputRef.current` has been assigned the actual DOM input element.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_refs_1",
            "question_refs_2",
            "question_refs_3",
            "question_refs_4"
          ],
          "relatedTasks": [
            "task_autofocus_input",
            "task_media_player_control"
          ],
          "tags": [
            "React",
            "Refs",
            "DOM Manipulation",
            "Hooks",
            "useEffect",
            "useRef"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Components_Lifecycle",
            "React_Hooks_Fundamentals"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Accessibility",
            "Integration_with_Legacy_Code"
          ]
        },
        {
          "id": "theory_https_development",
          "title": "Using HTTPS in Development",
          "content": "While often overlooked during local development, using HTTPS (Hypertext Transfer Protocol Secure) is crucial for a complete and secure development experience, especially when dealing with APIs, authentication, or features that require a secure context (like Geolocation, Service Workers, WebAuthn, or certain browser APIs).\n\n## Why Use HTTPS in Development?\n1.  **Security Consistency:** Mirrors production environment more closely, preventing issues that might arise only when switching from HTTP to HTTPS (e.g., mixed content warnings, API endpoint discrepancies).\n2.  **API Compatibility:** Many modern APIs (especially payment gateways, authentication providers, or services requiring OAuth) mandate secure contexts and will refuse to work over plain HTTP.\n3.  **Browser Features:** Features like Service Workers (for Progressive Web Apps), Web Push Notifications, Geolocation, or `navigator.clipboard.writeText()` often require a secure context. Using HTTPS locally enables you to test these features fully.\n4.  **Cookie Security:** `Secure` and `SameSite=None` cookies only work over HTTPS. If your application relies on these, developing with HTTP can lead to unexpected behavior.\n5.  **Avoiding Mixed Content:** If your frontend is served over HTTPS in production but fetches resources (images, scripts, API calls) from HTTP endpoints, browsers will block these requests as 'mixed content', leading to broken functionality. Developing with HTTPS helps catch such issues early.\n\n## How to Enable HTTPS for Local Development?\nMost modern frontend development tools and frameworks provide built-in ways to enable HTTPS, often using self-signed certificates. These certificates are generated locally and are trusted by your browser during development (though they'll show a warning initially, which you can usually bypass for local domains).\n\n*   **Create React App (CRA):** Set the `HTTPS` environment variable to `true` when starting the development server. E.g., `HTTPS=true npm start`.\n*   **Next.js:** Next.js doesn't have a built-in `HTTPS` flag for `next dev`. You typically need to use a proxy, a tool like `mkcert`, or a custom server configuration to serve it over HTTPS.\n*   **Vite:** Configure `server.https: true` in your `vite.config.ts`. You might also need to install `@vitejs/plugin-basic-ssl` or use `mkcert`.\n*   **Vue CLI:** Similar to CRA, you can usually pass a `--https` flag or configure `vue.config.js`.\n*   **`mkcert`:** A simple tool to create locally trusted development certificates. You can use it to generate certificates for `localhost` and then configure your development server (e.g., Webpack Dev Server, Express server) to use these certificates.\n\n```bash\n# Example using mkcert\nbrew install mkcert # on macOS, or follow instructions for your OS\nmkcert -install\nmkcert localhost 127.0.0.1 ::1 myapp.local\n# This generates localhost.pem and localhost-key.pem (or similar) in your current directory\n# Then configure your dev server (e.g., in webpack.config.js or express server):\n```\n\n```javascript\n// Example: Using generated certificates with an Express server\nconst express = require('express');\nconst https = require('https');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\nconst port = 3000;\n\n// Point to your generated certificates\nconst options = {\n  key: fs.readFileSync(path.resolve(__dirname, 'localhost-key.pem')),\n  cert: fs.readFileSync(path.resolve(__dirname, 'localhost.pem'))\n};\n\napp.get('/', (req, res) => {\n  res.send('Hello from HTTPS!');\n});\n\nhttps.createServer(options, app).listen(port, () => {\n  console.log(`HTTPS server running on https://localhost:${port}`);\n});\n```",
          "examples": [],
          "relatedQuestions": [
            "question_https_dev_1",
            "question_https_dev_2",
            "question_https_dev_3"
          ],
          "relatedTasks": [
            "task_setup_https_dev"
          ],
          "tags": [
            "HTTPS",
            "Development",
            "Security",
            "Web_Development",
            "Browser_APIs",
            "Tooling"
          ],
          "technology": "Web Development",
          "prerequisites": [
            "Networking_Basics",
            "Web_Servers"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "PWA_Development",
            "Authentication_Systems",
            "API_Integration"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_immutable_state_1",
          "topic": "Immutable State Updates",
          "level": "easy",
          "type": "flashcard",
          "question": "Why is it important to update React state immutably, especially for objects and arrays?",
          "answer": "Updating state immutably ensures that React's shallow comparison (used for performance optimizations like `PureComponent` or `React.memo`) correctly detects changes and triggers re-renders. It also prevents unexpected side effects and makes debugging easier by ensuring a predictable state flow.",
          "analysisPoints": [
            "React's rendering mechanism relies on reference equality.",
            "Prevents side effects and promotes predictable state.",
            "Enables performance optimizations like `PureComponent` and `React.memo`."
          ],
          "keyConcepts": [
            "Immutability",
            "React State",
            "Performance"
          ],
          "evaluationCriteria": [
            "Understanding of React's rendering mechanism",
            "Awareness of side effects"
          ],
          "example": "",
          "tags": [
            "React",
            "State Management",
            "Immutability"
          ],
          "prerequisites": [
            "React_State_Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_state_2",
          "topic": "Immutable State Updates",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following React component state, which of the following is the correct way to update only the `city` property within the `address` object without mutating the original state?",
          "answer": "Option A",
          "options": [
            "A. `setUser(prevUser => ({ ...prevUser, address: { ...prevUser.address, city: 'New York' } }));`",
            "B. `user.address.city = 'New York'; setUser(user);`",
            "C. `setUser({ ...user, city: 'New York' });`",
            "D. `setUser(user.address.city = 'New York');`"
          ],
          "analysisPoints": [
            "Correctly identifies the need for nested spread syntax.",
            "Understands that direct mutation (Option B) is incorrect.",
            "Recognizes that `city` is nested, so updating at the top level (Option C) is incorrect.",
            "Option D attempts to assign a value directly to a nested property as the new state, which is syntactically and logically wrong."
          ],
          "keyConcepts": [
            "Immutability",
            "Nested State Updates",
            "Spread Syntax",
            "React State"
          ],
          "evaluationCriteria": [
            "Ability to apply immutable update patterns.",
            "Understanding of object spread syntax.",
            "Distinguishing between mutable and immutable operations."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction UserProfile() {\n  const [user, setUser] = useState({\n    name: 'Jane Doe',\n    address: {\n      street: '123 Main St',\n      city: 'Anytown',\n      zip: '12345'\n    }\n  });\n\n  const updateCity = () => {\n    setUser(prevUser => ({\n      ...prevUser, // Spread the top-level user object\n      address: {\n        ...prevUser.address, // Spread the nested address object\n        city: 'New York' // Override the city property\n      }\n    }));\n  };\n\n  return (\n    <div>\n      <p>Current City: {user.address.city}</p>\n      <button onClick={updateCity}>Move to New York</button>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "MCQ"
          ],
          "prerequisites": [
            "JavaScript_Objects",
            "React_useState"
          ],
          "complexity": 6,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_state_3",
          "topic": "Immutable State Updates",
          "level": "hard",
          "type": "code",
          "question": "Implement a `handleFormChange` function for a complex form state. The function should take an `event` object (from an input change) and immutably update the state. The state can have nested objects. Assume input `name` attributes map directly to state paths (e.g., `name=\"user.address.street\"` for `state.user.address.street`). You may need to parse the `name` attribute to correctly update the nested property. If the name is simple (e.g., `name=\"firstName\"`), treat it as a top-level property.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Ability to handle dynamic updates for nested state.",
            "Correct use of recursion or iterative approach for deep updates.",
            "Maintaining immutability at all levels.",
            "Handling edge cases like non-existent paths or top-level properties."
          ],
          "keyConcepts": [
            "Immutability",
            "Dynamic State Updates",
            "Nested Objects",
            "Recursion",
            "Spread Syntax"
          ],
          "evaluationCriteria": [
            "Correctness of the immutable update logic.",
            "Efficiency of path parsing and state update.",
            "Robustness to different `name` attribute formats.",
            "Readability and maintainability of code."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction ComplexForm() {\n  const [formData, setFormData] = useState({\n    personal: {\n      firstName: '',\n      lastName: '',\n      age: 0\n    },\n    contact: {\n      email: '',\n      phone: ''\n    },\n    address: {\n      street: '',\n      city: '',\n      zip: ''\n    }\n  });\n\n  const handleFormChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const { name, value } = event.target;\n\n    setFormData(prevFormData => {\n      const keys = name.split('.');\n      let newFormData = { ...prevFormData };\n      let currentLevel: any = newFormData;\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (i === keys.length - 1) {\n          // Last key, update the value\n          currentLevel[key] = value;\n        } else {\n          // Not the last key, deep copy the nested object\n          currentLevel[key] = { ...currentLevel[key] };\n          currentLevel = currentLevel[key];\n        }\n      }\n      return newFormData;\n    });\n  };\n\n  return (\n    <form>\n      <h3>Personal Info</h3>\n      <input name=\"personal.firstName\" value={formData.personal.firstName} onChange={handleFormChange} placeholder=\"First Name\" />\n      <input name=\"personal.lastName\" value={formData.personal.lastName} onChange={handleFormChange} placeholder=\"Last Name\" />\n      <input name=\"personal.age\" type=\"number\" value={formData.personal.age} onChange={handleFormChange} placeholder=\"Age\" />\n\n      <h3>Contact Info</h3>\n      <input name=\"contact.email\" value={formData.contact.email} onChange={handleFormChange} placeholder=\"Email\" />\n      <input name=\"contact.phone\" value={formData.contact.phone} onChange={handleFormChange} placeholder=\"Phone\" />\n\n      <h3>Address</h3>\n      <input name=\"address.street\" value={formData.address.street} onChange={handleFormChange} placeholder=\"Street\" />\n      <input name=\"address.city\" value={formData.address.city} onChange={handleFormChange} placeholder=\"City\" />\n      <input name=\"address.zip\" value={formData.address.zip} onChange={handleFormChange} placeholder=\"Zip Code\" />\n\n      <pre>{JSON.stringify(formData, null, 2)}</pre>\n    </form>\n  );\n}\n```",
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Coding Challenge",
            "Advanced"
          ],
          "prerequisites": [
            "JavaScript_Objects",
            "JavaScript_Array_Methods",
            "React_useState"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_immutable_state_4",
          "topic": "Immutable State Updates",
          "level": "medium",
          "type": "open",
          "question": "Discuss the potential performance implications of incorrect state updates (i.e., mutating state directly) versus correct immutable state updates in a large React application. How does React's reconciliation process relate to this?",
          "answer": "Directly mutating state can lead to several performance issues. React's reconciliation algorithm relies on shallow comparisons of state and props to determine if a component needs to re-render. If you mutate an object or array directly, its reference in memory remains the same, even though its contents have changed. React's shallow comparison will then incorrectly assume that the state has not changed, leading to: \n1. **Missed Re-renders:** Components that *should* update based on the mutated data might not, causing UI inconsistencies.\n2. **Unnecessary Re-renders (less common but possible):** If a parent component re-renders for another reason, the child might still re-render even if its props/state *appear* unchanged to React, but the underlying mutated data might cause issues.\n\nImmutable updates, by contrast, always create new references for changed data. This allows React's shallow comparison to accurately detect that the state (or props derived from state) has changed, triggering the necessary re-renders and enabling optimizations like `PureComponent` or `React.memo` (which internally use shallow comparisons) to prevent unnecessary re-renders for components whose props/state truly haven't changed. This predictable behavior is crucial for performance in complex applications.",
          "analysisPoints": [
            "Explain React's shallow comparison.",
            "Describe how direct mutation fools the reconciliation.",
            "Explain how immutable updates provide new references for comparison.",
            "Mention performance benefits (or pitfalls) with `PureComponent`/`React.memo`."
          ],
          "keyConcepts": [
            "React Reconciliation",
            "Shallow Comparison",
            "Immutability",
            "Performance Optimization",
            "PureComponent",
            "React.memo"
          ],
          "evaluationCriteria": [
            "Depth of understanding of React's internal mechanisms.",
            "Ability to link abstract concepts to practical performance implications.",
            "Clarity and completeness of explanation."
          ],
          "example": "",
          "tags": [
            "React",
            "Performance",
            "State Management",
            "Immutability",
            "Open-Ended"
          ],
          "prerequisites": [
            "React_Reconciliation",
            "React_Optimization"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_immutable_state_5",
          "topic": "Immutable State Updates",
          "level": "easy",
          "type": "flashcard",
          "question": "What JavaScript syntax is commonly used for immutably updating objects and arrays in React state?",
          "answer": "The spread syntax (`...`) is commonly used for immutably updating objects and arrays.",
          "analysisPoints": [
            "Identifies the primary JavaScript syntax.",
            "Connects syntax to the concept of immutability."
          ],
          "keyConcepts": [
            "Spread Syntax",
            "Immutability",
            "JavaScript"
          ],
          "evaluationCriteria": [
            "Recall of key syntax"
          ],
          "example": "",
          "tags": [
            "React",
            "JavaScript",
            "Flashcard"
          ],
          "prerequisites": [
            "JavaScript_ES6"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_multiple_state_1",
          "topic": "Managing Multiple State Variables",
          "level": "easy",
          "type": "flashcard",
          "question": "What are two common ways to manage multiple related pieces of state in a React functional component using the `useState` hook?",
          "answer": "1. Using a single `useState` call with an object to hold all related state.\n2. Using multiple separate `useState` calls for individual state variables.",
          "analysisPoints": [
            "Identifies both major patterns.",
            "Distinguishes between object-based and individual `useState`."
          ],
          "keyConcepts": [
            "useState",
            "State Management",
            "React Hooks"
          ],
          "evaluationCriteria": [
            "Recall of common patterns"
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Flashcard"
          ],
          "prerequisites": [
            "React_useState"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_multiple_state_2",
          "topic": "Managing Multiple State Variables",
          "level": "medium",
          "type": "mcq",
          "question": "Consider a form with `firstName`, `lastName`, and `email` fields. Which `useState` approach is generally simpler for updating *individual* fields, and why?",
          "answer": "B. Multiple `useState` calls, because each field has its own dedicated setter function, simplifying updates.",
          "options": [
            "A. A single `useState` object, because all related data is grouped.",
            "B. Multiple `useState` calls, because each field has its own dedicated setter function, simplifying updates.",
            "C. A single `useState` object, because it reduces the number of hook calls.",
            "D. Multiple `useState` calls, because it forces immutable updates automatically."
          ],
          "analysisPoints": [
            "Correctly identifies that multiple `useState` calls simplify individual updates.",
            "Understands that while a single object groups data, it complicates individual updates due to spread syntax.",
            "Clarifies that immutability is a developer responsibility, not automatically enforced by the choice of `useState` structure.",
            "Option C is a valid point about reducing hook calls, but B directly answers 'simpler for updating *individual* fields'."
          ],
          "keyConcepts": [
            "useState",
            "State Management",
            "Form Handling",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Understanding of practical implications of each `useState` pattern.",
            "Ability to weigh pros and cons for specific scenarios."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nfunction SimpleForm() {\n  const [firstName, setFirstName] = useState('');\n  const [lastName, setLastName] = useState('');\n\n  // To update firstName:\n  // setName(e.target.value); // Simple and direct\n\n  // If it was a single object: { name: { first, last } }\n  // setFormData(prev => ({ ...prev, name: { ...prev.name, first: e.target.value } })); // More verbose\n\n  return (\n    <form>\n      <input type=\"text\" value={firstName} onChange={(e) => setFirstName(e.target.value)} placeholder=\"First Name\" />\n      <input type=\"text\" value={lastName} onChange={(e) => setLastName(e.target.value)} placeholder=\"Last Name\" />\n    </form>\n  );\n}\n```",
          "tags": [
            "React",
            "Hooks",
            "State Management",
            "MCQ"
          ],
          "prerequisites": [
            "React_useState"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_multiple_state_3",
          "topic": "Managing Multiple State Variables",
          "level": "medium",
          "type": "open",
          "question": "In what scenarios would using a single state object with `useState` be more advantageous than using multiple individual `useState` calls? Provide an example.",
          "answer": "A single state object with `useState` is more advantageous when:\n\n1.  **Related Data:** The pieces of state are logically grouped and frequently updated together as a cohesive unit. For instance, a user's entire profile information (name, age, address, preferences) often makes sense as one object.\n2.  **Complex or Nested Structures:** When the state has a deep or hierarchical structure (e.g., a form with sections and sub-sections), managing it as one object can sometimes make it easier to reason about the overall data structure, even if individual updates require nested spreads.\n3.  **Reducer Pattern:** If the state updates become complex and involve multiple related changes, converting to `useReducer` later is often smoother when the state is already structured as a single object.\n\n**Example:** Consider a drawing application where the state represents the current drawing canvas, including active tool, brush size, color, and a list of drawn shapes. These are all tightly coupled to the drawing context.\n\n```typescript\nimport React, { useState } from 'react';\n\ninterface DrawingState {\n  activeTool: 'pen' | 'eraser' | 'fill';\n  brushSize: number;\n  color: string;\n  shapes: { id: string; type: string; coordinates: number[]; color: string; }[];\n}\n\nfunction DrawingCanvas() {\n  const [drawingState, setDrawingState] = useState<DrawingState>({\n    activeTool: 'pen',\n    brushSize: 5,\n    color: '#000000',\n    shapes: []\n  });\n\n  const changeTool = (tool: DrawingState['activeTool']) => {\n    setDrawingState(prev => ({ ...prev, activeTool: tool }));\n  };\n\n  const addShape = (newShape: DrawingState['shapes'][0]) => {\n    setDrawingState(prev => ({ ...prev, shapes: [...prev.shapes, newShape] }));\n  };\n\n  return (\n    <div>\n      {/* UI for tools, brush size, color */}\n      <button onClick={() => changeTool('eraser')}>Eraser</button>\n      <button onClick={() => addShape({ id: 's1', type: 'circle', coordinates: [10, 20, 5], color: drawingState.color })}>Add Circle</button>\n      <p>Active Tool: {drawingState.activeTool}</p>\n      <p>Shapes count: {drawingState.shapes.length}</p>\n    </div>\n  );\n}\n```\nIn this example, `activeTool`, `brushSize`, `color`, and `shapes` are all part of the `drawingState` context. While individual updates are possible, keeping them within one object reflects their conceptual relationship to the drawing canvas.",
          "analysisPoints": [
            "Identify scenarios for single object (related data, complex structure).",
            "Provide a clear, relevant example demonstrating the advantage.",
            "Discuss `useReducer` as a natural progression."
          ],
          "keyConcepts": [
            "useState",
            "State Management Patterns",
            "useReducer",
            "Cohesion"
          ],
          "evaluationCriteria": [
            "Ability to identify appropriate use cases.",
            "Demonstration of understanding through examples.",
            "Logical reasoning for architectural choices."
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "State Management",
            "Open-Ended"
          ],
          "prerequisites": [
            "React_useState"
          ],
          "complexity": 7,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_multiple_state_4",
          "topic": "Managing Multiple State Variables",
          "level": "easy",
          "type": "flashcard",
          "question": "What is a potential downside of using a single state object for many unrelated state variables in a React functional component?",
          "answer": "A potential downside is that updates to any single property within the object require spreading the entire object, which can lead to more verbose update logic, especially for deeply nested properties. It can also potentially cause unnecessary re-renders if not handled carefully, though React's batching helps mitigate this for simple cases.",
          "analysisPoints": [
            "Focus on the verbosity of updates.",
            "Mention potential re-render issues (less critical with modern React, but still a conceptual point)."
          ],
          "keyConcepts": [
            "useState",
            "State Management",
            "Immutability",
            "Verbosity"
          ],
          "evaluationCriteria": [
            "Recall of disadvantages"
          ],
          "example": "",
          "tags": [
            "React",
            "Hooks",
            "Flashcard"
          ],
          "prerequisites": [
            "React_useState"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_array_1",
          "topic": "Immutable Array Manipulation",
          "level": "easy",
          "type": "flashcard",
          "question": "Which JavaScript array method is commonly used to immutably remove elements from an array?",
          "answer": "The `filter()` method is commonly used to immutably remove elements from an array.",
          "analysisPoints": [
            "Correctly identifies `filter`.",
            "Connects `filter` to immutability."
          ],
          "keyConcepts": [
            "Array Methods",
            "Immutability",
            "filter"
          ],
          "evaluationCriteria": [
            "Recall of key array methods"
          ],
          "example": "",
          "tags": [
            "JavaScript",
            "Arrays",
            "Flashcard"
          ],
          "prerequisites": [
            "JavaScript_Arrays"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_immutable_array_2",
          "topic": "Immutable Array Manipulation",
          "level": "medium",
          "type": "mcq",
          "question": "You have a list of `todos` as a state variable: `const [todos, setTodos] = useState([{ id: 1, text: 'Learn React' }, { id: 2, text: 'Build Project' }]);`. Which code snippet correctly removes the todo with `id: 1` immutably?",
          "answer": "B. `setTodos(todos.filter(todo => todo.id !== 1));`",
          "options": [
            "A. `todos.splice(0, 1); setTodos(todos);`",
            "B. `setTodos(todos.filter(todo => todo.id !== 1));`",
            "C. `setTodos([...todos.slice(1)]);`",
            "D. `const newTodos = todos; newTodos.pop(); setTodos(newTodos);`"
          ],
          "analysisPoints": [
            "Option A mutates the original array and then sets the same reference, leading to potential issues.",
            "Option B correctly uses `filter` to create a new array without the specified item.",
            "Option C would remove the first element by index, not by ID, and is not a general solution for removing a specific item.",
            "Option D mutates the array via `pop()` and then sets the same reference, which is incorrect for immutability.",
            "Emphasizes the use of `filter` for conditional removal."
          ],
          "keyConcepts": [
            "Immutability",
            "Array Methods",
            "filter",
            "React State"
          ],
          "evaluationCriteria": [
            "Ability to choose the correct immutable array operation.",
            "Understanding of side effects of mutable array methods."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\ninterface Todo { id: number; text: string; completed: boolean; }\n\nfunction TodoList() {\n  const [todos, setTodos] = useState<Todo[]>([\n    { id: 1, text: 'Learn React', completed: false },\n    { id: 2, text: 'Build Project', completed: false },\n    { id: 3, text: 'Deploy App', completed: false }\n  ]);\n\n  const removeTodo = (idToRemove: number) => {\n    setTodos(todos.filter(todo => todo.id !== idToRemove));\n  };\n\n  return (\n    <div>\n      {todos.map(todo => (\n        <div key={todo.id}>\n          {todo.text}\n          <button onClick={() => removeTodo(todo.id)}>X</button>\n        </div>\n      ))}\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "MCQ",
            "Arrays"
          ],
          "prerequisites": [
            "JavaScript_Arrays",
            "React_useState"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutable_array_3",
          "topic": "Immutable Array Manipulation",
          "level": "hard",
          "type": "code",
          "question": "You have a list of `products` in state, each with an `id`, `name`, and `price`. Implement a function `updateProductPrice(id: number, newPrice: number)` that immutably updates the price of a specific product by its ID. Also, implement `sortProductsByName()` that immutably sorts the products alphabetically by name.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly uses `map()` for updating an item in an array.",
            "Correctly uses spread syntax to update the item object itself within `map()`.",
            "Correctly uses `slice()` or spread `[...]` to create a shallow copy before sorting.",
            "Demonstrates understanding of immutable array operations for both modification and reordering."
          ],
          "keyConcepts": [
            "Immutability",
            "Array Methods",
            "map",
            "sort",
            "React State"
          ],
          "evaluationCriteria": [
            "Correctness and immutability of `updateProductPrice`.",
            "Correctness and immutability of `sortProductsByName`.",
            "Efficiency of the operations.",
            "Readability of the code."
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\ninterface Product { id: number; name: string; price: number; }\n\nfunction ProductCatalog() {\n  const [products, setProducts] = useState<Product[]>([\n    { id: 1, name: 'Laptop', price: 1200 },\n    { id: 2, name: 'Mouse', price: 25 },\n    { id: 3, name: 'Keyboard', price: 75 }\n  ]);\n\n  const updateProductPrice = (id: number, newPrice: number) => {\n    setProducts(products.map(product => \n      product.id === id \n        ? { ...product, price: newPrice } // Create new product object with updated price\n        : product // Return original product if not the one to update\n    ));\n  };\n\n  const sortProductsByName = () => {\n    setProducts([...products].sort((a, b) => a.name.localeCompare(b.name))); // Create shallow copy before sorting\n  };\n\n  return (\n    <div>\n      <button onClick={() => updateProductPrice(1, 1250)}>Update Laptop Price</button>\n      <button onClick={sortProductsByName}>Sort by Name</button>\n      <h3>Products:</h3>\n      <ul>\n        {products.map(product => (\n          <li key={product.id}>\n            {product.name} - ${product.price}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Coding Challenge",
            "Arrays"
          ],
          "prerequisites": [
            "JavaScript_Arrays",
            "React_useState"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_immutable_array_4",
          "topic": "Immutable Array Manipulation",
          "level": "medium",
          "type": "open",
          "question": "Explain the difference between `array.sort()` and `[...array].sort()` in the context of React state updates. Why is the latter generally preferred?",
          "answer": "`array.sort()` is a **mutable** array method. It sorts the array *in place*, meaning it modifies the original array and returns a reference to that same modified array. If you use `array.sort()` directly on a state array in React, you are mutating the state without changing its reference. React's shallow comparison will not detect a change, and therefore, the component might not re-render, leading to an inconsistent UI.\n\n`[...array].sort()` on the other hand, first uses the spread syntax (`...`) to create a **shallow copy** of the original array. Then, the `sort()` method is called on this *new* copy. This means the original array in state remains untouched, and a brand new array (the sorted copy) is returned. When this new array is set as the state, React's shallow comparison detects a change in the array's reference, triggering a re-render and ensuring the UI reflects the sorted data.\n\nThe latter (`[...array].sort()`) is preferred because it adheres to React's principle of immutability, ensuring predictable state updates and proper re-rendering behavior.",
          "analysisPoints": [
            "Clearly differentiate mutable (`array.sort()`) vs. immutable (`[...array].sort()`).",
            "Explain the effect on array reference and React's reconciliation.",
            "Emphasize why immutability is important for `sort`."
          ],
          "keyConcepts": [
            "Immutability",
            "Array Methods",
            "sort",
            "Spread Syntax",
            "React Reconciliation"
          ],
          "evaluationCriteria": [
            "Clear explanation of mutable vs. immutable array operations.",
            "Understanding of how these relate to React's rendering."
          ],
          "example": "",
          "tags": [
            "React",
            "JavaScript",
            "Arrays",
            "Immutability",
            "Open-Ended"
          ],
          "prerequisites": [
            "JavaScript_Arrays",
            "React_State_Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_refs_1",
          "topic": "Direct DOM Manipulation with Refs",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of `refs` in React?",
          "answer": "The primary purpose of `refs` in React is to provide a way to access DOM nodes or React elements created in the `render` method imperatively. They are typically used for direct DOM manipulation when declarative approaches are not sufficient.",
          "analysisPoints": [
            "Defines the core function of refs.",
            "Highlights the imperative nature."
          ],
          "keyConcepts": [
            "Refs",
            "DOM Manipulation",
            "Imperative Programming"
          ],
          "evaluationCriteria": [
            "Recall of fundamental concept"
          ],
          "example": "",
          "tags": [
            "React",
            "Refs",
            "Flashcard"
          ],
          "prerequisites": [
            "React_Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_refs_2",
          "topic": "Direct DOM Manipulation with Refs",
          "level": "medium",
          "type": "mcq",
          "question": "When should you generally *avoid* using `refs` in React?",
          "answer": "C. To change the appearance or content of a component based on state or props.",
          "options": [
            "A. When you need to manage focus, text selection, or media playback.",
            "B. When integrating with third-party DOM libraries.",
            "C. To change the appearance or content of a component based on state or props.",
            "D. When triggering imperative animations on a DOM element."
          ],
          "analysisPoints": [
            "Options A, B, and D describe valid use cases for refs (imperative scenarios).",
            "Option C describes a declarative task (UI changes based on data) that should be handled with state and props, not direct DOM manipulation via refs.",
            "Reinforces the 'declarative first' principle in React."
          ],
          "keyConcepts": [
            "Refs",
            "Declarative vs Imperative",
            "React Best Practices",
            "State vs. Props"
          ],
          "evaluationCriteria": [
            "Understanding of appropriate and inappropriate ref usage.",
            "Adherence to React's declarative paradigm."
          ],
          "example": "```typescript\n// Avoid using refs for this:\n// function MyComponent() {\n//   const divRef = useRef(null);\n//   useEffect(() => {\n//     if (someCondition) {\n//       divRef.current.style.backgroundColor = 'red'; // Bad practice for simple styling\n//     }\n//   }, [someCondition]);\n//   return <div ref={divRef}>Hello</div>;\n// }\n\n// Do this instead:\nfunction MyComponent({ someCondition }: { someCondition: boolean }) {\n  const backgroundColor = someCondition ? 'red' : 'blue';\n  return <div style={{ backgroundColor }}>Hello</div>;\n}\n```",
          "tags": [
            "React",
            "Refs",
            "Best Practices",
            "MCQ"
          ],
          "prerequisites": [
            "React_State_Props"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_refs_3",
          "topic": "Direct DOM Manipulation with Refs",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast how refs are created and accessed in class components versus functional components. Include a discussion of the lifecycle implications for accessing the DOM node.",
          "answer": "### Class Components\n*   **Creation:** Refs can be created using `React.createRef()` in the constructor and assigned to an instance property (e.g., `this.myRef = React.createRef();`). Alternatively, a 'callback ref' can be used, where the `ref` attribute is set to a function that receives the DOM node (or component instance) directly (e.g., `<input ref={node => this.myInput = node} />`).\n*   **Access:** The DOM node is accessed via `this.myRef.current` for `createRef` or directly via the instance property (e.g., `this.myInput`) for callback refs.\n*   **Lifecycle Implications:** The ref's `current` property is guaranteed to be populated with the DOM node after the component has mounted. Therefore, you should typically access refs in `componentDidMount` for initial interactions, and potentially in `componentDidUpdate` if the ref itself or related props change.\n\n### Functional Components\n*   **Creation:** Refs are created using the `useRef` hook: `const myRef = useRef(null);`. `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument (`null` in this case). This object persists across re-renders.\n*   **Access:** The DOM node is accessed via `myRef.current`.\n*   **Lifecycle Implications:** `myRef.current` is guaranteed to be assigned the DOM node *after* the component has rendered. Therefore, to perform actions that require the DOM node (like focusing an input), you should wrap the logic in a `useEffect` hook. If the effect needs to run only once on mount, use an empty dependency array (`[]`). If it needs to re-run when specific dependencies change, include them in the dependency array.\n\n**Comparison:**\n*   **Syntax:** Class components use `React.createRef()` or callback functions; functional components use `useRef`.\n*   **Access Pattern:** Both eventually provide a `.current` property that holds the DOM node, but class components can store it directly on `this`, while functional components rely on the `ref` object returned by `useRef`.\n*   **Lifecycle Integration:** Class components use lifecycle methods (`componentDidMount`, `componentDidUpdate`) to interact with refs. Functional components use the `useEffect` hook to achieve similar timing and side-effect management.",
          "analysisPoints": [
            "Detail ref creation methods for both component types.",
            "Explain how to access the ref's current value.",
            "Discuss appropriate lifecycle methods/hooks for ref interaction.",
            "Summarize key differences in a comparative manner."
          ],
          "keyConcepts": [
            "Refs",
            "Class Components",
            "Functional Components",
            "useRef",
            "useEffect",
            "Lifecycle Methods",
            "DOM Manipulation"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison of ref mechanisms.",
            "Accurate explanation of lifecycle integration.",
            "Clarity and structure of the answer."
          ],
          "example": "",
          "tags": [
            "React",
            "Refs",
            "Hooks",
            "Class Components",
            "Open-Ended"
          ],
          "prerequisites": [
            "React_Components",
            "React_Lifecycle",
            "React_Hooks"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_refs_4",
          "topic": "Direct DOM Manipulation with Refs",
          "level": "hard",
          "type": "code",
          "question": "Implement a custom React hook `usePrevious` that stores the previous value of a prop or state. Then, use this hook and a `useRef` to create a `ScrollableDiv` component that automatically scrolls to the bottom when its content height changes (e.g., when new messages are added to a chat).",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly implements `usePrevious` using `useRef` and `useEffect`.",
            "Correctly uses `useRef` to get a reference to the scrollable div.",
            "Compares current scroll height to previous scroll height to detect content change.",
            "Applies `scrollTop` property correctly for auto-scrolling.",
            "Handles edge cases like initial render or when content is smaller than div."
          ],
          "keyConcepts": [
            "Refs",
            "useRef",
            "useEffect",
            "Custom Hooks",
            "DOM Manipulation",
            "Scroll Management"
          ],
          "evaluationCriteria": [
            "Correct implementation of `usePrevious` hook.",
            "Effective use of `useRef` for DOM element access.",
            "Logical application of `useEffect` for side effects.",
            "Correct implementation of auto-scrolling logic.",
            "Handling of dependencies in `useEffect`."
          ],
          "example": "```typescript\nimport React, { useRef, useEffect, useState } from 'react';\n\n// Custom hook to get the previous value of a state or prop\nfunction usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\ninterface ScrollableDivProps {\n  children: React.ReactNode;\n}\n\nfunction ScrollableDiv({ children }: ScrollableDivProps) {\n  const scrollRef = useRef<HTMLDivElement>(null);\n  const prevChildren = usePrevious(children);\n\n  useEffect(() => {\n    if (scrollRef.current) {\n      // Only scroll to bottom if content has changed (e.g., new messages)\n      // A more robust check might compare actual message count or scroll height\n      // For simplicity, we check if children ref has changed, meaning content likely did\n      if (prevChildren !== children) {\n         scrollRef.current.scrollTop = scrollRef.current.scrollHeight;\n      }\n    }\n  }, [children, prevChildren]); // Re-run when children content changes\n\n  return (\n    <div\n      ref={scrollRef}\n      style={{\n        height: '200px',\n        overflowY: 'auto',\n        border: '1px solid #ccc',\n        padding: '10px',\n        display: 'flex',\n        flexDirection: 'column'\n      }}\n    >\n      {children}\n    </div>\n  );\n}\n\n// Example Usage:\nfunction ChatWindow() {\n  const [messages, setMessages] = useState<string[]>([\n    \"Hello!\",\n    \"Welcome to the chat.\"\n  ]);\n\n  const addMessage = () => {\n    setMessages(prev => [...prev, `New message at ${new Date().toLocaleTimeString()}`]);\n  };\n\n  return (\n    <div>\n      <ScrollableDiv>\n        {messages.map((msg, index) => (\n          <p key={index}>{msg}</p>\n        ))}\n      </ScrollableDiv>\n      <button onClick={addMessage}>Add Message</button>\n    </div>\n  );\n}\n```",
          "tags": [
            "React",
            "Hooks",
            "useRef",
            "useEffect",
            "Custom Hooks",
            "DOM Manipulation",
            "Coding Challenge"
          ],
          "prerequisites": [
            "React_Hooks",
            "JavaScript_DOM_Basics"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "expert"
        },
        {
          "id": "question_https_dev_1",
          "topic": "Using HTTPS in Development",
          "level": "easy",
          "type": "flashcard",
          "question": "Name two reasons why it's beneficial to use HTTPS even in local development.",
          "answer": "1. To mirror the production environment more closely and prevent mixed content issues.\n2. To enable browser features that require a secure context (e.g., Geolocation, Service Workers, WebAuthn).",
          "analysisPoints": [
            "Identifies common reasons for HTTPS in dev.",
            "Highlights consistency and feature access."
          ],
          "keyConcepts": [
            "HTTPS",
            "Development Environment",
            "Security"
          ],
          "evaluationCriteria": [
            "Recall of key benefits"
          ],
          "example": "",
          "tags": [
            "Web_Development",
            "Security",
            "Flashcard"
          ],
          "prerequisites": [
            "Networking_Basics"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_https_dev_2",
          "topic": "Using HTTPS in Development",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following browser features or API requirements *typically* mandate a secure context (HTTPS) to function correctly?",
          "answer": "D. All of the above.",
          "options": [
            "A. Service Workers for Progressive Web Apps (PWAs).",
            "B. Geolocation API (`navigator.geolocation`).",
            "C. Web Push Notifications.",
            "D. All of the above."
          ],
          "analysisPoints": [
            "Identifies that all listed options require HTTPS.",
            "Understands the concept of 'secure context' in modern web development."
          ],
          "keyConcepts": [
            "HTTPS",
            "Secure Context",
            "Browser APIs",
            "PWA"
          ],
          "evaluationCriteria": [
            "Knowledge of secure context requirements for web features."
          ],
          "example": "",
          "tags": [
            "Web_Development",
            "Security",
            "Browser APIs",
            "MCQ"
          ],
          "prerequisites": [
            "Networking_Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_https_dev_3",
          "topic": "Using HTTPS in Development",
          "level": "open",
          "type": "open",
          "question": "Describe the concept of 'mixed content' in web development and explain how using HTTPS in development helps to mitigate issues related to it.",
          "answer": "Mixed content occurs when an initial HTML page is loaded over a secure HTTPS connection, but other resources (like images, videos, stylesheets, scripts, or API calls) on that same page are loaded over an insecure HTTP connection. This poses a security risk because even though the main page is encrypted, the insecure resources can be intercepted, modified, or expose sensitive information.\n\nBrowsers have strict policies against mixed content. They typically:\n*   **Block active mixed content:** Scripts, iframes, stylesheets that are loaded over HTTP on an HTTPS page are usually blocked entirely, leading to broken functionality or UI.\n*   **Warn about passive mixed content:** Images, audio, and video loaded over HTTP might be displayed, but the browser will show a warning in the console or address bar, indicating a potential security vulnerability.\n\nUsing HTTPS in development helps mitigate these issues by:\n1.  **Early Detection:** By developing with HTTPS, your local environment mirrors production. If you accidentally reference an HTTP resource (e.g., an image from an external HTTP server or a local API not served over HTTPS), the browser will immediately flag it as mixed content during development. This allows developers to catch and fix these issues before deployment.\n2.  **Consistent Testing:** It ensures that your application behaves consistently across environments. Features that might work locally over HTTP but fail in production due to mixed content (e.g., fetching data from an external non-HTTPS API) will break during development, prompting necessary adjustments.",
          "analysisPoints": [
            "Define mixed content (secure page, insecure resources).",
            "Explain the security implications (interception, modification).",
            "Describe browser behavior (blocking vs. warning).",
            "Explain how dev HTTPS helps (early detection, consistent testing)."
          ],
          "keyConcepts": [
            "HTTPS",
            "Mixed Content",
            "Security",
            "Browser Security",
            "Development Practices"
          ],
          "evaluationCriteria": [
            "Clear and accurate definition of mixed content.",
            "Thorough explanation of its implications.",
            "Detailed description of how dev HTTPS addresses the problem."
          ],
          "example": "",
          "tags": [
            "Web_Development",
            "Security",
            "Browser",
            "Open-Ended"
          ],
          "prerequisites": [
            "Networking_Basics",
            "HTTP_HTTPS"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_user_profile_form",
          "title": "Build a User Profile Form with Immutable State Management",
          "description": "\nCreate a React functional component `UserProfileForm` that manages a user's profile information. The form should include:\n\n1.  **Basic Fields:** `firstName`, `lastName`, `email`.\n2.  **Nested Preference:** An object `preferences` containing `newsletterSubscription` (boolean) and `smsNotifications` (boolean).\n\n**Requirements:**\n*   Use **a single `useState` object** to manage the entire form's state.\n*   Implement `onChange` handlers for all input fields (text and checkboxes) to update the state **immutably**.\n*   Ensure updates to nested properties (`newsletterSubscription`, `smsNotifications`) are also immutable.\n*   Display the current state below the form in a readable JSON format (`<pre>`).\n*   The form should reflect state changes immediately.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\ninterface UserProfile {\n  firstName: string;\n  lastName: string;\n  email: string;\n  preferences: {\n    newsletterSubscription: boolean;\n    smsNotifications: boolean;\n  };\n}\n\nfunction UserProfileForm() {\n  const [user, setUser] = useState<UserProfile>({\n    firstName: '',\n    lastName: '',\n    email: '',\n    preferences: {\n      newsletterSubscription: false,\n      smsNotifications: false,\n    },\n  });\n\n  // TODO: Implement handleInputChange for text fields\n  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    // ... your implementation for text inputs\n  };\n\n  // TODO: Implement handleCheckboxChange for checkboxes\n  const handleCheckboxChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    // ... your implementation for checkboxes, especially nested ones\n  };\n\n  return (\n    <div>\n      <h2>User Profile Editor</h2>\n      <form>\n        <label>\n          First Name:\n          <input\n            type=\"text\"\n            name=\"firstName\"\n            value={user.firstName}\n            onChange={handleInputChange}\n          />\n        </label>\n        <br />\n        <label>\n          Last Name:\n          <input\n            type=\"text\"\n            name=\"lastName\"\n            value={user.lastName}\n            onChange={handleInputChange}\n          />\n        </label>\n        <br />\n        <label>\n          Email:\n          <input\n            type=\"email\"\n            name=\"email\"\n            value={user.email}\n            onChange={handleInputChange}\n          />\n        </label>\n        <br />\n        <h3>Preferences</h3>\n        <label>\n          <input\n            type=\"checkbox\"\n            name=\"newsletterSubscription\"\n            checked={user.preferences.newsletterSubscription}\n            onChange={handleCheckboxChange}\n          />\n          Newsletter Subscription\n        </label>\n        <br />\n        <label>\n          <input\n            type=\"checkbox\"\n            name=\"smsNotifications\"\n            checked={user.preferences.smsNotifications}\n            onChange={handleCheckboxChange}\n          />\n          SMS Notifications\n        </label>\n      </form>\n      <h3>Current State:</h3>\n      <pre>{JSON.stringify(user, null, 2)}</pre>\n    </div>\n  );\n}\n\nexport default UserProfileForm;\n",
          "solutionCode": "import React, { useState } from 'react';\n\ninterface UserProfile {\n  firstName: string;\n  lastName: string;\n  email: string;\n  preferences: {\n    newsletterSubscription: boolean;\n    smsNotifications: boolean;\n  };\n}\n\nfunction UserProfileForm() {\n  const [user, setUser] = useState<UserProfile>({\n    firstName: '',\n    lastName: '',\n    email: '',\n    preferences: {\n      newsletterSubscription: false,\n      smsNotifications: false,\n    },\n  });\n\n  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const { name, value } = event.target;\n    setUser(prevUser => ({\n      ...prevUser,\n      [name]: value, // Update top-level properties dynamically\n    }));\n  };\n\n  const handleCheckboxChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const { name, checked } = event.target;\n    // For nested preferences, we need nested spread\n    setUser(prevUser => ({\n      ...prevUser,\n      preferences: {\n        ...prevUser.preferences,\n        [name]: checked,\n      },\n    }));\n  };\n\n  return (\n    <div>\n      <h2>User Profile Editor</h2>\n      <form>\n        <label>\n          First Name:\n          <input\n            type=\"text\"\n            name=\"firstName\"\n            value={user.firstName}\n            onChange={handleInputChange}\n          />\n        </label>\n        <br />\n        <label>\n          Last Name:\n          <input\n            type=\"text\"\n            name=\"lastName\"\n            value={user.lastName}\n            onChange={handleInputChange}\n          />\n        </label>\n        <br />\n        <label>\n          Email:\n          <input\n            type=\"email\"\n            name=\"email\"\n            value={user.email}\n            onChange={handleInputChange}\n          />\n        </label>\n        <br />\n        <h3>Preferences</h3>\n        <label>\n          <input\n            type=\"checkbox\"\n            name=\"newsletterSubscription\"\n            checked={user.preferences.newsletterSubscription}\n            onChange={handleCheckboxChange}\n          />\n          Newsletter Subscription\n        </label>\n        <br />\n        <label>\n          <input\n            type=\"checkbox\"\n            name=\"smsNotifications\"\n            checked={user.preferences.smsNotifications}\n            onChange={handleCheckboxChange}\n          />\n          SMS Notifications\n        </label>\n      </form>\n      <h3>Current State:</h3>\n      <pre>{JSON.stringify(user, null, 2)}</pre>\n    </div>\n  );\n}\n\nexport default UserProfileForm;\n",
          "testCases": [
            "Entering text in 'First Name' should update `user.firstName`.",
            "Entering text in 'Last Name' should update `user.lastName`.",
            "Entering text in 'Email' should update `user.email`.",
            "Toggling 'Newsletter Subscription' checkbox should immutably update `user.preferences.newsletterSubscription`.",
            "Toggling 'SMS Notifications' checkbox should immutably update `user.preferences.smsNotifications`.",
            "Verify that unrelated properties remain unchanged after an update (e.g., changing first name doesn't affect preferences).",
            "Initial state should match the `useState` initialization."
          ],
          "hints": [
            "For the `handleInputChange` function, you can use computed property names `[name]: value` with the spread operator.",
            "For `handleCheckboxChange`, remember that `event.target.checked` provides the boolean value for checkboxes.",
            "Updating nested objects requires spreading at each level to create new references."
          ],
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Forms",
            "Hooks"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React_useState",
            "JavaScript_Objects",
            "JavaScript_Spread_Syntax"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_immutable_state_updates",
            "theory_multiple_state_variables"
          ]
        },
        {
          "id": "task_todo_list_manager",
          "title": "Implement an Immutable Todo List Manager",
          "description": "\nCreate a React functional component `TodoListManager` that allows users to add, delete, and toggle the completion status of todo items. All state manipulations must be **immutable**.\n\n**Requirements:**\n1.  **Add Todo:** An input field and a button to add new todo items. Each todo should have a unique `id` (e.g., using `Date.now()`), `text`, and `completed` status (default `false`).\n2.  **Delete Todo:** A button next to each todo item to remove it from the list.\n3.  **Toggle Complete:** A checkbox next to each todo item to toggle its `completed` status.\n4.  **Display:** List all todos, showing their text and completion status. Completed todos can have a strikethrough style.\n\n**Constraints:**\n*   Use `useState` for managing the list of todos.\n*   All array modifications (add, delete, update) must be done immutably.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nfunction TodoListManager() {\n  const [todos, setTodos] = useState<Todo[]>([]);\n  const [newTodoText, setNewTodoText] = useState('');\n\n  const handleAddTodo = () => {\n    if (newTodoText.trim() === '') return;\n    // TODO: Add new todo immutably\n    setNewTodoText('');\n  };\n\n  const handleDeleteTodo = (id: number) => {\n    // TODO: Delete todo immutably\n  };\n\n  const handleToggleComplete = (id: number) => {\n    // TODO: Toggle completion status immutably\n  };\n\n  return (\n    <div>\n      <h2>Todo List Manager</h2>\n      <div>\n        <input\n          type=\"text\"\n          value={newTodoText}\n          onChange={(e) => setNewTodoText(e.target.value)}\n          placeholder=\"Add a new todo\"\n        />\n        <button onClick={handleAddTodo}>Add Todo</button>\n      </div>\n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id} style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => handleToggleComplete(todo.id)}\n            />\n            {todo.text}\n            <button onClick={() => handleDeleteTodo(todo.id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default TodoListManager;\n",
          "solutionCode": "import React, { useState } from 'react';\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nfunction TodoListManager() {\n  const [todos, setTodos] = useState<Todo[]>([]);\n  const [newTodoText, setNewTodoText] = useState('');\n\n  const handleAddTodo = () => {\n    if (newTodoText.trim() === '') return;\n    const newTodo: Todo = {\n      id: Date.now(), // Simple unique ID\n      text: newTodoText.trim(),\n      completed: false,\n    };\n    setTodos(prevTodos => [...prevTodos, newTodo]); // Add immutably\n    setNewTodoText('');\n  };\n\n  const handleDeleteTodo = (id: number) => {\n    setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id)); // Delete immutably using filter\n  };\n\n  const handleToggleComplete = (id: number) => {\n    setTodos(prevTodos =>\n      prevTodos.map(todo =>\n        todo.id === id ? { ...todo, completed: !todo.completed } : todo\n      ) // Update immutably using map\n    );\n  };\n\n  return (\n    <div>\n      <h2>Todo List Manager</h2>\n      <div>\n        <input\n          type=\"text\"\n          value={newTodoText}\n          onChange={(e) => setNewTodoText(e.target.value)}\n          placeholder=\"Add a new todo\"\n        />\n        <button onClick={handleAddTodo}>Add Todo</button>\n      </div>\n      <ul>\n        {todos.map(todo => (\n          <li key={todo.id} style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n            <input\n              type=\"checkbox\"\n              checked={todo.completed}\n              onChange={() => handleToggleComplete(todo.id)}\n            />\n            {todo.text}\n            <button onClick={() => handleDeleteTodo(todo.id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default TodoListManager;\n",
          "testCases": [
            "Adding a new todo should append it to the list with `completed: false`.",
            "Adding an empty todo text should do nothing.",
            "Deleting a todo should remove it from the list.",
            "Toggling a todo's checkbox should change its `completed` status and its strikethrough style.",
            "Deleting a non-existent todo should not cause errors and leave the list unchanged.",
            "Adding multiple todos and ensuring they have unique IDs."
          ],
          "hints": [
            "For adding, use the spread syntax `[...]` to create a new array.",
            "For deleting, the `filter()` method is ideal as it returns a new array.",
            "For toggling completion, `map()` allows you to iterate and create a new array, selectively updating only the target item's properties using object spread."
          ],
          "tags": [
            "React",
            "State Management",
            "Immutability",
            "Arrays",
            "Hooks"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React_useState",
            "JavaScript_Array_Methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_immutable_array_manipulation"
          ]
        },
        {
          "id": "task_autofocus_input",
          "title": "Auto-Focus Input on Component Mount using `useRef`",
          "description": "\nCreate a React functional component `AutoFocusInput` that automatically focuses an input field when the component mounts.\n\n**Requirements:**\n*   Use the `useRef` hook to create a ref for the input element.\n*   Use the `useEffect` hook to perform the focus action.\n*   Ensure the `focus()` call happens only once when the component first mounts.\n*   Include a button that conditionally renders `AutoFocusInput` to demonstrate the auto-focus behavior upon mounting.\n",
          "difficulty": "easy",
          "startingCode": "import React, { useRef, useEffect, useState } from 'react';\n\nfunction AutoFocusInput() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // TODO: Implement focusing logic here\n  }, []); // Dependency array for 'mount only'\n\n  return (\n    <div>\n      <p>This input should auto-focus on load:</p>\n      <input ref={inputRef} type=\"text\" placeholder=\"Type here...\" />\n    </div>\n  );\n}\n\nfunction App() {\n  const [showInput, setShowInput] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setShowInput(!showInput)}>\n        {showInput ? 'Hide Input' : 'Show Input'}\n      </button>\n      {showInput && <AutoFocusInput />}\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { useRef, useEffect, useState } from 'react';\n\nfunction AutoFocusInput() {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    // Check if the ref.current is not null before focusing\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, []); // Empty dependency array ensures this runs only once on mount\n\n  return (\n    <div>\n      <p>This input should auto-focus on load:</p>\n      <input ref={inputRef} type=\"text\" placeholder=\"Type here...\" />\n    </div>\n  );\n}\n\nfunction App() {\n  const [showInput, setShowInput] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setShowInput(!showInput)}>\n        {showInput ? 'Hide Input' : 'Show Input'}\n      </button>\n      {showInput && <AutoFocusInput />}\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "When the 'Show Input' button is clicked, the input field inside `AutoFocusInput` should gain focus.",
            "When the 'Hide Input' button is clicked, the `AutoFocusInput` component should unmount.",
            "When 'Show Input' is clicked again, the input should re-focus."
          ],
          "hints": [
            "The `useEffect` hook with an empty dependency array `[]` runs once after the initial render, which is the perfect time to access the DOM node via ref.",
            "Remember to check if `inputRef.current` is not `null` before trying to call `focus()` on it, as the ref might not be attached immediately.",
            "The `inputRef.current` will be the actual DOM element for the `<input>` tag."
          ],
          "tags": [
            "React",
            "Refs",
            "Hooks",
            "useRef",
            "useEffect",
            "DOM Manipulation"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "React_Hooks_Fundamentals",
            "JavaScript_DOM_Basics"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_refs_dom_manipulation"
          ]
        },
        {
          "id": "task_media_player_control",
          "title": "Implement a Video Player with Play/Pause Control using `useRef`",
          "description": "\nCreate a React functional component `VideoPlayer` that displays a simple video and provides 'Play' and 'Pause' buttons to control it. The video control must be done imperatively using `useRef`.\n\n**Requirements:**\n*   Use a `<video>` HTML element.\n*   Use `useRef` to get a reference to the video DOM element.\n*   Implement `playVideo()` and `pauseVideo()` functions that use the ref to call the `play()` and `pause()` methods directly on the video element.\n*   Provide buttons labeled 'Play' and 'Pause' that trigger these functions.\n*   Choose a small, publicly available video URL for demonstration.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useRef } from 'react';\n\nfunction VideoPlayer() {\n  const videoRef = useRef(null);\n  const videoSrc = \"https://www.w3schools.com/html/mov_bbb.mp4\"; // Example public video URL\n\n  const playVideo = () => {\n    // TODO: Play the video using the ref\n  };\n\n  const pauseVideo = () => {\n    // TODO: Pause the video using the ref\n  };\n\n  return (\n    <div>\n      <h2>Simple Video Player</h2>\n      <video ref={videoRef} width=\"320\" height=\"240\" controls>\n        <source src={videoSrc} type=\"video/mp4\" />\n        Your browser does not support the video tag.\n      </video>\n      <div>\n        <button onClick={playVideo}>Play</button>\n        <button onClick={pauseVideo}>Pause</button>\n      </div>\n    </div>\n  );\n}\n\nexport default VideoPlayer;\n",
          "solutionCode": "import React, { useRef } from 'react';\n\nfunction VideoPlayer() {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const videoSrc = \"https://www.w3schools.com/html/mov_bbb.mp4\"; // Example public video URL\n\n  const playVideo = () => {\n    if (videoRef.current) {\n      videoRef.current.play();\n    }\n  };\n\n  const pauseVideo = () => {\n    if (videoRef.current) {\n      videoRef.current.pause();\n    }\n  };\n\n  return (\n    <div>\n      <h2>Simple Video Player</h2>\n      <video ref={videoRef} width=\"320\" height=\"240\" controls>\n        <source src={videoSrc} type=\"video/mp4\" />\n        Your browser does not support the video tag.\n      </video>\n      <div>\n        <button onClick={playVideo}>Play</button>\n        <button onClick={pauseVideo}>Pause</button>\n      </div>\n    </div>\n  );\n}\n\nexport default VideoPlayer;\n",
          "testCases": [
            "Clicking 'Play' button should start the video.",
            "Clicking 'Pause' button should pause the video.",
            "Video should load correctly from the `videoSrc`.",
            "The component should render without errors."
          ],
          "hints": [
            "The `HTMLVideoElement` has `play()` and `pause()` methods.",
            "Remember to check if `videoRef.current` is not `null` before calling methods on it.",
            "You don't need `useEffect` for these simple imperative calls triggered by user interaction, as `videoRef.current` will be available after the initial render."
          ],
          "tags": [
            "React",
            "Refs",
            "Hooks",
            "useRef",
            "DOM Manipulation",
            "Media"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "React_Hooks_Fundamentals",
            "JavaScript_DOM_Basics"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_refs_dom_manipulation"
          ]
        },
        {
          "id": "task_setup_https_dev",
          "title": "Configure a React Dev Server for HTTPS",
          "description": "\nDemonstrate how to configure a typical React development environment (e.g., using Create React App's built-in server or a simple Node.js Express server) to serve content over HTTPS during local development. You don't need to build a complex React app, just show the setup.\n\n**Requirements:**\n*   **Option A (CRA):** Show the command-line approach to start a CRA project with HTTPS.\n*   **Option B (Express):** Set up a minimal Node.js Express server that serves a simple HTML/React build over HTTPS using self-signed certificates (e.g., generated with `mkcert`). Provide instructions for generating the certificates.\n\n**Choose ONE option** to implement and provide the necessary code/commands. Explain why this setup is useful.\n",
          "difficulty": "medium",
          "startingCode": "```bash\n# OPTION A: Create React App (CRA)\n# No starting code, provide the command to run it with HTTPS\n\n# OPTION B: Node.js Express Server\n# Create a directory for your project:\n# mkdir my-https-app\n# cd my-https-app\n# npm init -y\n# npm install express\n# npm install -g mkcert # if you don't have it\n\n# Provide a simple index.html or React build placeholder\n# Then, your server.js setup...\n```\n",
          "solutionCode": "```bash\n# OPTION A: Create React App (CRA)\n# 1. Create a new React App (if you don't have one):\n#    npx create-react-app my-https-cra --template typescript\n#    cd my-https-cra\n\n# 2. To run the Create React App development server with HTTPS, use:\nHTTPS=true npm start\n# Or, for Windows PowerShell:\n# $env:HTTPS=\"true\"; npm start\n\n# Explanation:\n# Create React App provides a convenient environment variable, `HTTPS`, which when set to `true`, instructs the underlying webpack-dev-server to serve the application over HTTPS. It automatically generates and uses a self-signed certificate, which your browser might initially warn you about, but you can proceed past the warning for `localhost`.\n```\n\n```javascript\n// OPTION B: Node.js Express Server with mkcert\n\n// Step 1: Install mkcert (if you haven't already)\n// On macOS (using Homebrew): brew install mkcert\n// On Linux (using Homebrew): brew install mkcert\n// On Windows: choco install mkcert (or follow instructions on mkcert GitHub)\n\n// Step 2: Install mkcert locally (this will add a CA to your system's trust store)\n// mkcert -install\n\n// Step 3: Generate certificates for localhost (run this in your project root)\n// mkcert localhost 127.0.0.1 ::1\n// This will create files like `localhost.pem` and `localhost-key.pem`\n\n// Step 4: Create a server.js file\n// (Make sure you have `npm install express`)\n\n// server.js\nconst express = require('express');\nconst https = require('https');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\nconst PORT = 3000;\n\n// Serve static files (e.g., your React build output in a 'build' folder)\n// If you have a React app, run `npm run build` and then point this to the 'build' folder.\n// For simplicity, let's just serve a simple HTML file.\napp.use(express.static(path.join(__dirname, 'public'))); // Assuming a 'public' directory with index.html\n\n// Certificate files generated by mkcert\nconst options = {\n  key: fs.readFileSync('localhost-key.pem'),\n  cert: fs.readFileSync('localhost.pem')\n};\n\n// Create HTTPS server\nhttps.createServer(options, app).listen(PORT, () => {\n  console.log(`HTTPS server running on https://localhost:${PORT}`);\n  console.log('You might need to accept a security warning in your browser for the self-signed certificate.');\n});\n\n// Example public/index.html:\n// <!DOCTYPE html>\n// <html>\n// <head><title>HTTPS Dev</title></head>\n// <body><h1>Hello from HTTPS Development!</h1></body>\n// </html>\n```\n\n**Explanation:**\nThis setup allows you to simulate a production-like secure environment locally. By running your development server over HTTPS, you can:\n*   **Test browser features** that require a secure context (e.g., service workers, geolocation, WebAuthn).\n*   **Prevent mixed content warnings/errors** that can occur when an HTTPS page tries to load HTTP resources.\n*   **Debug API calls** that might behave differently or be blocked over HTTP (e.g., certain OAuth flows, secure cookie attributes).\nThis helps catch potential production issues early in the development cycle.\n",
          "testCases": [
            "The development server should start successfully.",
            "Navigating to `https://localhost:[PORT]` (e.g., `https://localhost:3000`) in the browser should load the application.",
            "The browser should show a 'secure' connection indicator (possibly after accepting a self-signed certificate warning).",
            "No mixed content warnings should appear if all resources are served from HTTPS."
          ],
          "hints": [
            "For CRA, environment variables are often the easiest way. Check CRA documentation for how to set `HTTPS=true` for your specific shell.",
            "For a custom Node.js server, you'll need the `https` built-in module and `fs` to read the certificate files.",
            "`mkcert` is a very convenient tool for generating locally trusted development certificates. Follow its installation instructions carefully.",
            "Ensure the certificate files (`.pem`, `.key`) are accessible by your Node.js server."
          ],
          "tags": [
            "HTTPS",
            "Development",
            "Security",
            "Node.js",
            "Express",
            "React",
            "Tooling"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Node.js_Basics",
            "NPM_Yarn",
            "Basic_Web_Concepts"
          ],
          "complexity": 7,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "theory_https_development"
          ]
        }
      ]
    }
  }
]