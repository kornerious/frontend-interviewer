[
  {
    "id": "ccff1b1a-8105-4c5d-814d-851301c7bcee",
    "startLine": 6000,
    "endLine": 6099,
    "processedDate": "2025-06-17T09:50:22.862Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_portals",
          "title": "React Portals",
          "content": "React Portals provide a way to render children into a DOM node that exists outside the DOM hierarchy of the parent component. This allows components to break out of their parent's DOM tree, which is particularly useful for dealing with modals, tooltips, dialogs, and other overlays that need to be positioned outside the normal document flow (e.g., to avoid `overflow: hidden` issues or to manage `z-index`).\n\n### How to use React Portals\nTo create a portal, you use `ReactDOM.createPortal(child, container)`. \n- `child`: This is any renderable React child, such as an element, string, or fragment.\n- `container`: This is a DOM element. The `child` will be mounted into this DOM element.\n\nTypically, the `container` DOM element for portals is a dedicated `div` element at the root level of your `public/index.html` (e.g., `<div id=\"modal-root\"></div>`), separate from your main React application's root element.\n\n### Important Portal Characteristics\n1.  **Event Bubbling:** Events fired inside a portal will still propagate up the React component tree, even if the portal's DOM elements are not direct ancestors in the DOM tree. This means that an event handler attached to a parent component (e.g., `App`) will still catch events from a child rendered via a portal, maintaining React's synthetic event system behavior.\n2.  **DOM Structure vs. React Component Hierarchy:** Portals only alter the physical DOM structure. They do not change the logical React component hierarchy. Components rendered within a portal still behave like normal React children within the context of the React tree (e.g., context consumption, state management).\n3.  **Context Providers:** Context providers defined in ancestor components *above* the portal will still be accessible to components rendered inside the portal. This is because, as mentioned, portals maintain the React component hierarchy for context flow, despite DOM placement.",
          "examples": [
            {
              "id": "example_react_portals_1",
              "title": "Basic Modal Implementation with Portal",
              "code": "import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\n// 1. Create a dedicated DOM node in public/index.html:\n// <div id=\"modal-root\"></div>\n\n// 2. Define a reusable Modal component using createPortal\nfunction Modal({ children, onClose }) {\n  const modalRoot = document.getElementById('modal-root');\n  if (!modalRoot) {\n    // In a real application, you might throw an error or handle this more gracefully\n    console.error(\"The DOM element with ID 'modal-root' was not found.\");\n    return null;\n  }\n  return ReactDOM.createPortal(\n    <div className=\"modal-backdrop\" onClick={onClose}>\n      <div className=\"modal-content\" onClick={e => e.stopPropagation()}>\n        {children}\n        <button onClick={onClose}>Close Modal</button>\n      </div>\n    </div>,\n    modalRoot\n  );\n}\n\n// 3. Use the Modal component in your App\nfunction App() {\n  const [showModal, setShowModal] = useState(false);\n\n  return (\n    <div className=\"app-container\" style={{ border: '2px solid blue', padding: '20px' }}>\n      <h1>My Application Content</h1>\n      <p>This content is part of the regular DOM hierarchy.</p>\n      <button onClick={() => setShowModal(true)}>Show Modal</button>\n      \n      {showModal && (\n        <Modal onClose={() => setShowModal(false)}>\n          <h2>Modal Title</h2>\n          <p>This modal content is rendered into '#modal-root', outside the 'app-container' DOM node.</p>\n        </Modal>\n      )}\n      <p>More app content below the button.</p>\n    </div>\n  );\n}\n\n// Typical root rendering\n// ReactDOM.render(<App />, document.getElementById('root'));",
              "explanation": "This example demonstrates how to create and use a React Portal for a modal. The `Modal` component uses `ReactDOM.createPortal` to render its children (the modal content) into a specific DOM node (`modal-root`) that is outside the main application's root. This helps in managing z-index and overflow issues, ensuring the modal always appears on top. Despite being rendered elsewhere in the DOM, the `onClick` event on the 'Close Modal' button still correctly triggers the `setShowModal(false)` function in the `App` component due to event bubbling through the React component hierarchy.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_portal_1",
            "question_react_portal_2",
            "question_react_portal_3",
            "question_react_portal_4"
          ],
          "relatedTasks": [
            "task_implement_modal_with_portal"
          ],
          "tags": [
            "React",
            "Portals",
            "DOM",
            "Event Bubbling",
            "Context",
            "UI/UX",
            "Advanced React"
          ],
          "technology": "React",
          "prerequisites": [
            "react_components",
            "react_state",
            "react_props",
            "dom_manipulation_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "complex_ui_patterns",
            "component_library_development"
          ]
        },
        {
          "id": "theory_error_boundaries",
          "title": "React Error Boundaries",
          "content": "Error Boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the entire application. They are designed to encapsulate errors, preventing a single component's crash from bringing down the whole UI. This is crucial for building robust and user-friendly applications.\n\n### How to Implement an Error Boundary\nA class component becomes an error boundary if it defines either (or both) of the following lifecycle methods:\n\n1.  `static getDerivedStateFromError(error)`:\n    *   This static method is invoked after an error has been thrown by a descendant component.\n    *   It receives the `error` as an argument.\n    *   Its purpose is to update state so that the next render shows a fallback UI. It should return an object to update state, or `null` to not update state.\n\n2.  `componentDidCatch(error, info)`:\n    *   This method is invoked after an error has been thrown by a descendant component.\n    *   It receives two arguments: `error` (the error that was thrown) and `info` (an object with a `componentStack` key containing component stack trace information).\n    *   Its purpose is to perform side effects, such as logging the error to an error reporting service.\n\n### What Error Boundaries Catch\nError boundaries catch errors that occur during:\n*   Rendering\n*   In lifecycle methods\n*   In constructors of the whole tree below them.\n\n### What Error Boundaries Do NOT Catch\nError boundaries do *not* catch errors for:\n*   **Event handlers:** React does not catch errors inside event handlers because event handlers don't happen during rendering. If you need to catch errors in event handlers, use a regular JavaScript `try/catch` block inside the event handler itself.\n*   **Asynchronous code:** Errors inside `setTimeout`, `requestAnimationFrame`, or other asynchronous callbacks (like `fetch` requests) are not caught by error boundaries.\n*   **Server-side rendering:** Errors during server-side rendering are handled differently.\n*   **Errors thrown in the error boundary itself:** An error boundary can only catch errors in its children. If the error boundary's `render` method or `componentDidCatch` method throws an error, it will not catch it.\n\n### Usage\nOnce defined, an error boundary is used by wrapping it around the components you want to protect. A single error boundary can protect multiple components or even the entire application.",
          "examples": [
            {
              "id": "example_error_boundaries_1",
              "title": "Basic Error Boundary Component",
              "code": "import React from 'react';\n\n// A service to log errors (e.g., Sentry, Bugsnag)\nfunction logErrorToMyService(error, info) {\n  console.error(\"Error caught by ErrorBoundary:\", error, info);\n  // In a real app, you would send this to an external logging service\n}\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render shows the fallback UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    // You can also log the error to an error reporting service\n    this.setState({\n      error: error,\n      errorInfo: info\n    });\n    logErrorToMyService(error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return (\n        <div style={{ border: '1px solid red', padding: '10px', margin: '10px' }}>\n          <h2>Something went wrong.</h2>\n          <details style={{ whiteSpace: 'pre-wrap' }}>\n            {this.state.error && this.state.error.toString()}\n            <br />\n            {this.state.errorInfo && this.state.errorInfo.componentStack}\n          </details>\n          <p>Please refresh the page or try again later.</p>\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n\n// Example Component that might throw an error\nfunction BuggyCounter() {\n  const [counter, setCounter] = React.useState(0);\n\n  const handleClick = () => {\n    if (counter === 5) {\n      // This error will be caught by the ErrorBoundary during render\n      throw new Error('I crashed at 5!');\n    }\n    setCounter(c => c + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {counter}</p>\n      <button onClick={handleClick}>Increment</button>\n    </div>\n  );\n}\n\n// Usage in the App component\nfunction App() {\n  return (\n    <div>\n      <h1>Error Boundary Demo</h1>\n      <p>Click the counter until it crashes. The error boundary should catch it.</p>\n      \n      {/* Wrapping the BuggyCounter with the ErrorBoundary */}\n      <ErrorBoundary>\n        <BuggyCounter />\n      </ErrorBoundary>\n      \n      <p>This part of the app remains unaffected.</p>\n      <BuggyCounter /> {/* This one is not wrapped, will crash the whole app */}\n    </div>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));",
              "explanation": "This example shows a full implementation of an Error Boundary. The `ErrorBoundary` class component uses `static getDerivedStateFromError` to update its internal state (`hasError`), which triggers a re-render to display the fallback UI. `componentDidCatch` is used to log the error information to a hypothetical service. The `BuggyCounter` component is designed to throw an error when its internal `counter` reaches 5 during its render cycle. When `BuggyCounter` is wrapped by `ErrorBoundary`, the error is caught, and only the `BuggyCounter` part of the UI is replaced with the fallback, while the rest of the application remains functional. The second `BuggyCounter` is left unwrapped to illustrate that an unhandled error will crash the entire React component tree.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_error_boundary_1",
            "question_error_boundary_2",
            "question_error_boundary_3",
            "question_error_boundary_4",
            "question_error_boundary_5",
            "question_error_boundary_6"
          ],
          "relatedTasks": [
            "task_implement_error_boundary"
          ],
          "tags": [
            "React",
            "Error Handling",
            "Error Boundaries",
            "Lifecycle Methods",
            "Reliability",
            "Debugging"
          ],
          "technology": "React",
          "prerequisites": [
            "react_class_components",
            "react_state",
            "react_lifecycle"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "robust_application_development",
            "production_ready_react_apps"
          ]
        },
        {
          "id": "theory_react_strictmode",
          "title": "React.StrictMode",
          "content": "React.StrictMode is a developer tool designed to highlight potential problems in a React application. It activates additional checks and warnings for its descendants during development, but it does not render any visible UI itself and has no effect on the production build. Its primary goal is to help developers identify and fix common issues, deprecated features, and potential side effects before they become problems in production.\n\n### Key Benefits and Checks Activated by StrictMode:\n1.  **Identifying components with unsafe lifecycle methods**: It warns about components using legacy or unsafe lifecycle methods (e.g., `componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate`) that are considered problematic for async rendering and are slated for removal or deprecation in future React versions.\n2.  **Warning about legacy string ref API usage**: It helps update code to use the newer and recommended callback refs or `React.createRef()` APIs instead of string refs (e.g., `<input ref=\"myInput\" />`).\n3.  **Detecting unexpected side effects**: It intentionally double-invokes functions like component constructors, `render` methods, and `setState` updaters in development mode. This helps to highlight potential side effects that might occur during unexpected multiple renders or when React's upcoming concurrent mode features are enabled. Pure functions should not produce side effects.\n4.  **Detecting legacy context API**: It warns about deprecated `contextTypes` and `getChildContext` usage, encouraging migration to the newer `React.createContext` API.\n5.  **Ensuring reusable state**: It helps identify state that isn't properly reset between renders, particularly when React is simulating unmounting and remounting components (e.g., when preserving state across different UI trees).\n6.  **Warning about deprecated findDOMNode usage**: It warns if `findDOMNode` is used, which is being phased out as it prevents certain performance optimizations in concurrent mode.\n\n### When to Use StrictMode:\n*   **New applications**: It is highly recommended to wrap the entire application in `StrictMode` when starting a new React project to catch issues early.\n*   **Legacy code maintenance**: When updating or maintaining older codebases, apply `StrictMode` to portions of the application or specific components as you refactor them to ensure they adhere to modern React practices.\n*   **Component library development**: If you are developing a reusable component library, using `StrictMode` helps ensure your components have clean implementations, are free of deprecated patterns, and are ready for future React features.\n\n### Important Notes:\n*   `StrictMode` only runs in **development mode** and has no performance impact or effect on the production build of your application.\n*   It doesn't render any visible UI. Its purpose is purely for warning and debugging.",
          "examples": [
            {
              "id": "example_react_strictmode_1",
              "title": "Applying React.StrictMode to an Application",
              "code": "import React from 'react';\nimport ReactDOM from 'react-dom';\n\n// Example of a component that might trigger StrictMode warnings\nclass UnsafeComponent extends React.Component {\n  // This lifecycle method is considered unsafe and will cause a warning in StrictMode\n  UNSAFE_componentWillMount() {\n    console.log('UNSAFE_componentWillMount called');\n  }\n\n  constructor(props) {\n    super(props);\n    console.log('UnsafeComponent constructor called'); // Will be double-invoked\n    this.state = { count: 0 };\n  }\n\n  render() {\n    console.log('UnsafeComponent render called'); // Will be double-invoked\n    return (\n      <div>\n        <p>Unsafe Component Count: {this.state.count}</p>\n        <button onClick={() => this.setState(prev => ({ count: prev.count + 1 }))}>Increment (watch console)</button>\n      </div>\n    );\n  }\n}\n\n// Example of a functional component with potential side effect in render\nfunction FunctionalSideEffectComponent() {\n  // This side effect will be more noticeable with StrictMode's double invocation\n  console.log('FunctionalSideEffectComponent rendered'); \n  \n  // This would be bad practice if it modified global state or DOM directly\n  // document.title = 'Side Effect!'; \n  \n  return <p>Functional Component with potential side effects.</p>;\n}\n\nfunction App() {\n  return (\n    // Wrap your application or parts of it with StrictMode\n    <React.StrictMode>\n      <div>\n        <h1>App with Strict Mode</h1>\n        <p>Check your browser's console for warnings and double invocations.</p>\n        <UnsafeComponent />\n        <FunctionalSideEffectComponent />\n      </div>\n    </React.StrictMode>\n  );\n}\n\n// ReactDOM.render(<App />, document.getElementById('root'));",
              "explanation": "This example demonstrates how to apply `React.StrictMode` to a React application. By wrapping the `App` component's children with `<React.StrictMode>`, React activates additional checks. In this specific example, the `UnsafeComponent` uses `UNSAFE_componentWillMount`, which will trigger a warning in the console. Furthermore, both the constructor and `render` method of `UnsafeComponent`, as well as the functional component's render log, will be called twice in development mode, highlighting that these should ideally be pure functions without side effects. This double invocation helps developers identify potential issues that might arise in future concurrent React modes.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_strictmode_1",
            "question_react_strictmode_2",
            "question_react_strictmode_3",
            "question_react_strictmode_4",
            "question_react_strictmode_5",
            "question_react_strictmode_6"
          ],
          "relatedTasks": [
            "task_demonstrate_strictmode_effects"
          ],
          "tags": [
            "React",
            "StrictMode",
            "Development Tools",
            "Debugging",
            "Lifecycle Methods",
            "Best Practices",
            "Performance"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "react_lifecycle",
            "react_functional_components"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "robust_application_development",
            "modern_react_patterns"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_react_portal_1",
          "topic": "React Portals",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of React Portals?",
          "answer": "To render children into a DOM node that exists outside the DOM hierarchy of the parent component.",
          "options": [],
          "analysisPoints": [
            "Focuses on the core definition of Portals.",
            "Highlights the key benefit of rendering outside the parent's DOM hierarchy."
          ],
          "keyConcepts": [
            "React Portals",
            "DOM Hierarchy",
            "Rendering"
          ],
          "evaluationCriteria": [
            "Ability to define React Portals"
          ],
          "example": "Portals are particularly useful for modals, tooltips, and popovers to manage z-index and overflow issues.",
          "tags": [
            "React",
            "Portals",
            "Basics"
          ],
          "prerequisites": [
            "react_components"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_portal_2",
          "topic": "React Portals",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements about event bubbling with React Portals is true?",
          "answer": "Events fired inside a portal will propagate to ancestors in the React component tree, even if those elements are not ancestors in the DOM tree.",
          "options": [
            "Events fired inside a portal only propagate within the portal's DOM hierarchy.",
            "Events fired inside a portal will propagate to ancestors in the React component tree, even if those elements are not ancestors in the DOM tree.",
            "Event bubbling is completely disabled for elements rendered via portals.",
            "Events from portals are caught by the nearest DOM ancestor only, not React ancestors."
          ],
          "analysisPoints": [
            "Tests understanding of a key characteristic of Portals.",
            "Distinguishes between DOM hierarchy and React component hierarchy.",
            "Highlights how React's synthetic event system behaves with Portals."
          ],
          "keyConcepts": [
            "React Portals",
            "Event Bubbling",
            "DOM Tree",
            "React Component Tree"
          ],
          "evaluationCriteria": [
            "Understanding of Portal mechanics.",
            "Ability to differentiate between DOM and React hierarchy effects."
          ],
          "example": "```jsx\n// App component\nfunction App() {\n  const handleClick = () => console.log('App click handled');\n  return (\n    <div onClick={handleClick}>\n      <Modal>\n        <button>Click Me</button> {/* This button's click will bubble up to App */}\n      </Modal>\n    </div>\n  );\n}\n\n// Modal component uses createPortal\n```\nExplanation: Even though the button is rendered in a separate DOM node via `ReactDOM.createPortal`, its click event will still be caught by the `onClick` handler on the `div` in the `App` component, demonstrating that event bubbling respects the React component tree, not just the DOM tree.",
          "tags": [
            "React",
            "Portals",
            "Event Handling"
          ],
          "prerequisites": [
            "react_events",
            "react_dom_integration"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_portal_3",
          "topic": "React Portals",
          "level": "medium",
          "type": "open",
          "question": "Explain how React Portals impact the DOM structure versus the React component hierarchy. Provide an example where this distinction is crucial.",
          "answer": "React Portals allow child components to be rendered into a DOM node that exists outside the parent component's DOM hierarchy. This means that while the rendered HTML element might appear in a completely different part of the document tree (e.g., a modal div at the body root), its logical position within the React component tree remains the same. The component rendered via a portal is still a child of its React parent component.\n\nThis distinction is crucial for:\n\n1.  **Event Bubbling:** As discussed, events (like clicks) still bubble up through the *React component hierarchy*. An event handler on a parent component will catch events from a child rendered in a portal, even if the DOM elements are not nested.\n2.  **Context API:** Components rendered inside a portal can still access Context Providers defined by their ancestors in the *React component hierarchy*. For example, if a ThemeContext is provided by the `App` component, a component inside a portal can consume that context, demonstrating that the context flow follows the React tree, not the DOM tree.\n\n**Example Scenario:** Building a global notification system. You want notification messages to appear always on top of everything, regardless of where they are triggered. You can use a portal to render these notifications directly into a `div` at the very end of `body`. Even though they are visually detached, if a notification component needs to dispatch an action to a Redux store or access user data from a React Context provided by the main `App` component, it can still do so because its connection to the React component tree is preserved.",
          "options": [],
          "analysisPoints": [
            "Evaluates the understanding of the core concept: separation of DOM and React trees.",
            "Requires explanation of how event bubbling and context API are affected (or not affected).",
            "Demands a practical example to illustrate the importance of this concept."
          ],
          "keyConcepts": [
            "React Portals",
            "DOM Hierarchy",
            "React Component Hierarchy",
            "Event Bubbling",
            "Context API"
          ],
          "evaluationCriteria": [
            "Clarity of explanation.",
            "Correctness of technical details.",
            "Relevance and aptness of the example."
          ],
          "example": "See the detailed answer above.",
          "tags": [
            "React",
            "Portals",
            "Advanced",
            "Context",
            "Event Handling"
          ],
          "prerequisites": [
            "react_context_api",
            "react_events"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_portal_4",
          "topic": "React Portals",
          "level": "easy",
          "type": "flashcard",
          "question": "What function is used to create a React Portal?",
          "answer": "`ReactDOM.createPortal(child, container)`",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of the specific API for creating portals."
          ],
          "keyConcepts": [
            "React Portals",
            "ReactDOM.createPortal"
          ],
          "evaluationCriteria": [
            "Recall of API signature"
          ],
          "example": "```javascript\nimport ReactDOM from 'react-dom';\n// ...\nReactDOM.createPortal(\n  <p>Hello from portal!</p>,\n  document.getElementById('some-dom-node')\n);\n```",
          "tags": [
            "React",
            "Portals",
            "API"
          ],
          "prerequisites": [
            "react_dom_basics"
          ],
          "complexity": 2,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_error_boundary_1",
          "topic": "Error Boundaries",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary function of a React Error Boundary?",
          "answer": "To catch JavaScript errors anywhere in its child component tree, log them, and display a fallback UI.",
          "options": [],
          "analysisPoints": [
            "Focuses on the core definition and purpose.",
            "Emphasizes error containment and user experience."
          ],
          "keyConcepts": [
            "Error Boundaries",
            "Error Handling",
            "Fallback UI"
          ],
          "evaluationCriteria": [
            "Ability to define Error Boundaries"
          ],
          "example": "Error Boundaries prevent a single component crash from breaking the entire application.",
          "tags": [
            "React",
            "Error Handling",
            "Basics"
          ],
          "prerequisites": [
            "react_components"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_error_boundary_2",
          "topic": "Error Boundaries",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following methods are used to implement a React Error Boundary?",
          "answer": "Both `static getDerivedStateFromError(error)` and `componentDidCatch(error, info)`",
          "options": [
            "`componentDidMount()` and `componentWillUnmount()`",
            "`render()` and `setState()`",
            "`static getDerivedStateFromError(error)` only",
            "Both `static getDerivedStateFromError(error)` and `componentDidCatch(error, info)`"
          ],
          "analysisPoints": [
            "Tests knowledge of the specific lifecycle methods for error boundaries.",
            "Distinguishes between methods for fallback UI vs. side effects/logging."
          ],
          "keyConcepts": [
            "Error Boundaries",
            "Lifecycle Methods",
            "getDerivedStateFromError",
            "componentDidCatch"
          ],
          "evaluationCriteria": [
            "Identification of correct API for error boundaries"
          ],
          "example": "```javascript\nclass MyErrorBoundary extends React.Component {\n  static getDerivedStateFromError(error) {\n    return { hasError: true }; // To render fallback UI\n  }\n  componentDidCatch(error, info) {\n    logErrorToMyService(error, info); // To log errors\n  }\n  // ... render method ...\n}\n```",
          "tags": [
            "React",
            "Error Handling",
            "API",
            "Lifecycle"
          ],
          "prerequisites": [
            "react_class_components",
            "react_lifecycle"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_3",
          "topic": "Error Boundaries",
          "level": "hard",
          "type": "open",
          "question": "List and explain at least three types of errors that React Error Boundaries do NOT catch. How would you handle these types of errors in a React application?",
          "answer": "React Error Boundaries are designed to catch JavaScript errors that occur during rendering, in lifecycle methods, and in constructors of their child component tree. However, they do not catch all types of errors. Here are three common types they do NOT catch and how to handle them:\n\n1.  **Errors inside event handlers:** Event handlers (e.g., `onClick`, `onChange`) do not occur during the rendering phase of React. Therefore, errors thrown within them are outside the scope of Error Boundaries. \n    *   **Handling:** Use standard JavaScript `try...catch` blocks directly within the event handler function where the error might occur.\n    \n    ```javascript\n    function MyComponent() {\n      const handleClick = () => {\n        try {\n          // Potentially erroneous code\n          throw new Error('Error in click handler');\n        } catch (error) {\n          console.error('Caught error in event handler:', error);\n          // Optionally, update component state to show a local error message\n        }\n      };\n      return <button onClick={handleClick}>Click Me</button>;\n    }\n    ```\n\n2.  **Asynchronous code (e.g., `setTimeout`, `fetch`, `Promise` callbacks):** Errors in asynchronous operations are typically detached from the rendering cycle. \n    *   **Handling:** Use `.catch()` blocks on Promises, `try...catch` with `async/await`, or `try...catch` inside the async callback functions. Global error handling (e.g., `window.addEventListener('unhandledrejection')`) can also be used for unhandled promise rejections.\n    \n    ```javascript\n    async function fetchData() {\n      try {\n        const response = await fetch('/api/data');\n        if (!response.ok) {\n          throw new Error('Network response not ok');\n        }\n        const data = await response.json();\n        // Process data\n      } catch (error) {\n        console.error('Error fetching data:', error);\n      }\n    }\n    ```\n\n3.  **Errors thrown in the Error Boundary itself:** An Error Boundary can only catch errors in its children. If the `render` method of the Error Boundary itself, or its `componentDidCatch` method, throws an error, that error will not be caught by the same boundary. This is to prevent an infinite loop of errors.\n    *   **Handling:** Ensure the code within your Error Boundary's `render` and `componentDidCatch` methods is robust and free of potential errors. Keep the logic simple and isolated. For critical applications, you might consider having a nested or higher-level 'meta' error boundary, but this is usually overkill.\n\n4.  **(Bonus) Server-side rendering (SSR) errors:** Errors that occur during server-side rendering are typically handled by the server framework (e.g., Next.js, Express) and require specific server-side error handling mechanisms rather than React Error Boundaries.",
          "options": [],
          "analysisPoints": [
            "Tests a deep understanding of Error Boundary limitations.",
            "Requires knowledge of alternative error handling strategies.",
            "Assesses ability to provide practical code examples for different error types."
          ],
          "keyConcepts": [
            "Error Boundaries",
            "Event Handlers",
            "Asynchronous Code",
            "Try/Catch",
            "Promise Catch"
          ],
          "evaluationCriteria": [
            "Completeness and accuracy of error types.",
            "Correctness and clarity of handling strategies.",
            "Quality of code examples."
          ],
          "example": "See the detailed answer above.",
          "tags": [
            "React",
            "Error Handling",
            "Advanced",
            "JavaScript",
            "Asynchronous"
          ],
          "prerequisites": [
            "react_error_boundaries",
            "javascript_error_handling"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_error_boundary_4",
          "topic": "Error Boundaries",
          "level": "medium",
          "type": "mcq",
          "question": "What is the primary responsibility of `static getDerivedStateFromError(error)` in an Error Boundary?",
          "answer": "To update the state to render a fallback UI.",
          "options": [
            "To log the error to an external service.",
            "To update the state to render a fallback UI.",
            "To perform side effects after an error occurs.",
            "To re-render the child components with corrected props."
          ],
          "analysisPoints": [
            "Distinguishes `getDerivedStateFromError` from `componentDidCatch`.",
            "Focuses on its role in UI rendering after an error."
          ],
          "keyConcepts": [
            "Error Boundaries",
            "getDerivedStateFromError",
            "Fallback UI",
            "State Management"
          ],
          "evaluationCriteria": [
            "Understanding of lifecycle method responsibilities"
          ],
          "example": "```javascript\nclass ErrorBoundary extends React.Component {\n  static getDerivedStateFromError(error) {\n    // This is where you would return { hasError: true }\n    // to trigger a re-render with the fallback UI.\n    return { hasError: true };\n  }\n  // ... other methods ...\n}\n```",
          "tags": [
            "React",
            "Error Handling",
            "Lifecycle",
            "API"
          ],
          "prerequisites": [
            "react_lifecycle"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_5",
          "topic": "Error Boundaries",
          "level": "easy",
          "type": "flashcard",
          "question": "Can functional components be React Error Boundaries?",
          "answer": "No, currently Error Boundaries must be class components that define `static getDerivedStateFromError` or `componentDidCatch`.",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of the current limitation of Error Boundaries.",
            "Reinforces that specific lifecycle methods are required."
          ],
          "keyConcepts": [
            "Error Boundaries",
            "Functional Components",
            "Class Components",
            "Limitations"
          ],
          "evaluationCriteria": [
            "Recall of API restrictions"
          ],
          "example": "There are no hooks equivalent to `componentDidCatch` or `getDerivedStateFromError` for functional components.",
          "tags": [
            "React",
            "Error Handling",
            "Components"
          ],
          "prerequisites": [
            "react_components_types"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_error_boundary_6",
          "topic": "Error Boundaries",
          "level": "medium",
          "type": "code",
          "question": "Implement a simple React Error Boundary component that displays a generic error message 'Something went wrong.' when an error occurs in its children. The error boundary should also log the error to the console.",
          "answer": "```typescript\nimport React from 'react';\n\nclass SimpleErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render shows the fallback UI.\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // You can also log the error to an error reporting service here.\n    console.error(\"Caught by SimpleErrorBoundary:\", error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // Render any custom fallback UI.\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children;\n  }\n}\n\n// Example usage:\n// function BuggyComponent() {\n//   throw new Error('I am a buggy component!');\n// }\n\n// function App() {\n//   return (\n//     <SimpleErrorBoundary>\n//       <BuggyComponent />\n//     </SimpleErrorBoundary>\n//   );\n// }\n```",
          "options": [],
          "analysisPoints": [
            "Correct implementation of `static getDerivedStateFromError` to manage `hasError` state.",
            "Correct implementation of `componentDidCatch` for logging.",
            "Proper conditional rendering of fallback UI.",
            "Understanding of `this.props.children` usage."
          ],
          "keyConcepts": [
            "Error Boundaries",
            "Class Components",
            "Lifecycle Methods",
            "State Management",
            "Fallback UI"
          ],
          "evaluationCriteria": [
            "Functional correctness.",
            "Adherence to React Error Boundary API.",
            "Code readability."
          ],
          "example": "See the `answer` field for the code example.",
          "tags": [
            "React",
            "Error Handling",
            "Coding Challenge"
          ],
          "prerequisites": [
            "react_class_components",
            "react_lifecycle"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_strictmode_1",
          "topic": "React.StrictMode",
          "level": "easy",
          "type": "flashcard",
          "question": "Does React.StrictMode affect the production build of an application?",
          "answer": "No, React.StrictMode only runs in development mode and has no effect on production builds.",
          "options": [],
          "analysisPoints": [
            "Tests knowledge of StrictMode's runtime environment.",
            "Highlights its debugging/development-only nature."
          ],
          "keyConcepts": [
            "React.StrictMode",
            "Development Mode",
            "Production Build"
          ],
          "evaluationCriteria": [
            "Recall of StrictMode's scope"
          ],
          "example": "Strict Mode is purely a development tool, it doesn't add any overhead to your production code.",
          "tags": [
            "React",
            "StrictMode",
            "Development Tools"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_strictmode_2",
          "topic": "React.StrictMode",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is NOT a benefit or check performed by React.StrictMode?",
          "answer": "Minimizing bundle size by removing unused code.",
          "options": [
            "Identifying components with unsafe lifecycle methods.",
            "Warning about legacy string ref API usage.",
            "Minimizing bundle size by removing unused code.",
            "Detecting unexpected side effects by double-invoking functions."
          ],
          "analysisPoints": [
            "Tests comprehensive knowledge of StrictMode's capabilities.",
            "Distinguishes its role from build optimization tools."
          ],
          "keyConcepts": [
            "React.StrictMode",
            "Development Tools",
            "Lifecycle Methods",
            "Side Effects",
            "Refs",
            "Bundle Size"
          ],
          "evaluationCriteria": [
            "Ability to identify core functions of StrictMode.",
            "Distinguishing between development tools and build optimizations."
          ],
          "example": "Strict Mode focuses on runtime checks and warnings during development, not build-time optimizations like tree-shaking or minification.",
          "tags": [
            "React",
            "StrictMode",
            "Benefits"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_strictmode_3",
          "topic": "React.StrictMode",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose and mechanism behind React.StrictMode's 'detecting unexpected side effects' check. Provide an example of how this might help a developer.",
          "answer": "React.StrictMode helps in 'detecting unexpected side effects' by intentionally double-invoking certain functions during development mode. These functions include:\n*   Class component `constructor` methods\n*   `render` methods (for both class and functional components)\n*   `setState` updater functions\n*   `useReducer` reducer functions\n\nThe **purpose** of this double invocation is to ensure that these functions are pure functions and do not produce any unintended side effects. In future versions of React with concurrent rendering, React might pause and resume rendering, or even start rendering multiple times. If these functions have side effects (e.g., modifying global variables, making network requests, directly manipulating the DOM), those side effects could be executed multiple times, leading to inconsistent UI or bugs.\n\n**Mechanism:** When StrictMode is active, React calls these functions twice. If there are side effects, running them twice will often expose an issue (e.g., an element being appended twice, a state update occurring unexpectedly, a subscription being created twice). React then discards the result of the first invocation and uses the second, or simply discards the side effect for functions that should be pure.\n\n**Example:** Consider a component that fetches data inside its `render` method (a common anti-pattern):\n\n```jsx\nfunction MyDataComponent() {\n  // Bad practice: Side effect (fetch) in render\n  fetch('/api/data').then(res => res.json()).then(data => console.log(data));\n  return <div>Data Loading...</div>;\n}\n\nfunction App() {\n  return (\n    <React.StrictMode>\n      <MyDataComponent />\n    </React.StrictMode>\n  );\n}\n```\n\nWithout StrictMode, `fetch` would be called once per render. With StrictMode, `fetch` would be called twice during the initial mount. This double network request would immediately alert the developer to an unexpected side effect, prompting them to move the `fetch` call to a `useEffect` hook (for functional components) or `componentDidMount` (for class components) with proper cleanup, ensuring it runs only once and at the appropriate time.",
          "options": [],
          "analysisPoints": [
            "Explains the 'why' (purity, future concurrent mode).",
            "Details the 'how' (double invocation of specific functions).",
            "Provides a clear and relevant example demonstrating the benefit."
          ],
          "keyConcepts": [
            "React.StrictMode",
            "Side Effects",
            "Pure Functions",
            "Concurrent Mode",
            "Double Invocation",
            "Debugging"
          ],
          "evaluationCriteria": [
            "Accuracy of explanation.",
            "Completeness of functions affected.",
            "Effectiveness of the example."
          ],
          "example": "See the detailed answer above.",
          "tags": [
            "React",
            "StrictMode",
            "Advanced",
            "Debugging",
            "Best Practices"
          ],
          "prerequisites": [
            "react_lifecycle",
            "react_functional_components",
            "javascript_side_effects"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_strictmode_4",
          "topic": "React.StrictMode",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you enable React.StrictMode in your application?",
          "answer": "By wrapping the components you want to check with `<React.StrictMode></React.StrictMode>`.",
          "options": [],
          "analysisPoints": [
            "Tests basic syntax for StrictMode integration."
          ],
          "keyConcepts": [
            "React.StrictMode",
            "Usage",
            "Wrapper Component"
          ],
          "evaluationCriteria": [
            "Recall of usage syntax"
          ],
          "example": "```jsx\nfunction App() {\n  return (\n    <React.StrictMode>\n      <MyComponent />\n    </React.StrictMode>\n  );\n}\n```",
          "tags": [
            "React",
            "StrictMode",
            "Usage"
          ],
          "prerequisites": [
            "react_components"
          ],
          "complexity": 2,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_strictmode_5",
          "topic": "React.StrictMode",
          "level": "medium",
          "type": "open",
          "question": "When should you consider using React.StrictMode? Provide at least two scenarios where it is particularly beneficial.",
          "answer": "React.StrictMode is a valuable tool for maintaining code quality and preparing for future React features. Here are two scenarios where it's particularly beneficial:\n\n1.  **Starting a New React Application:** When beginning a new React project, it's highly recommended to wrap the entire application's root component (e.g., `App` component) with `<React.StrictMode>`. This ensures that all components, from the very beginning, are developed following modern best practices. It helps catch unsafe lifecycle methods, deprecated APIs, and accidental side effects early in the development cycle, preventing them from becoming deeply ingrained issues that are harder to refactor later. This promotes cleaner, more predictable code.\n\n2.  **Maintaining or Updating Legacy Codebases:** For existing applications, especially those that might have been started with older versions of React or have not consistently followed the latest recommendations, applying `StrictMode` can be immensely beneficial. Developers can incrementally wrap specific sections or components that are being refactored or actively worked on. This helps identify and migrate away from deprecated features (like string refs or legacy context API) and fix potential side effects that might not be obvious until explicitly highlighted by StrictMode's checks. It's a strategic way to gradually modernize an application without needing a complete rewrite.\n\n**Bonus:** **Developing Component Libraries:** When creating reusable UI component libraries, using `StrictMode` during development is crucial. It ensures that the components are robust, free from deprecated patterns, and compatible with future React behaviors, making them reliable for consumers of the library.",
          "options": [],
          "analysisPoints": [
            "Identifies practical use cases for StrictMode.",
            "Explains the benefits in each scenario (proactive error prevention, refactoring).",
            "Demonstrates an understanding of the development lifecycle."
          ],
          "keyConcepts": [
            "React.StrictMode",
            "Best Practices",
            "New Applications",
            "Legacy Code",
            "Refactoring",
            "Component Libraries"
          ],
          "evaluationCriteria": [
            "Relevance of scenarios.",
            "Clarity of explanation for benefits in each case."
          ],
          "example": "See the detailed answer above.",
          "tags": [
            "React",
            "StrictMode",
            "Usage",
            "Best Practices"
          ],
          "prerequisites": [
            "react_project_structure"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_strictmode_6",
          "topic": "React.StrictMode",
          "level": "medium",
          "type": "code",
          "question": "Consider the following component. Explain what `React.StrictMode` would warn about and how you would refactor it to remove the warning.",
          "answer": "```javascript\nimport React from 'react';\n\nclass LegacyComponent extends React.Component {\n  // This method is considered unsafe and will cause a warning in StrictMode.\n  // It's deprecated for async rendering modes.\n  UNSAFE_componentWillMount() {\n    console.log('LegacyComponent: UNSAFE_componentWillMount called');\n    // Any state updates or side effects here could be problematic.\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = { data: null };\n    console.log('LegacyComponent: Constructor called'); // Will be double-invoked by StrictMode\n  }\n\n  render() {\n    console.log('LegacyComponent: Render called'); // Will be double-invoked by StrictMode\n    return <div>Legacy Component Content</div>;\n  }\n}\n\n// How StrictMode would warn:\n// 1. Warning about `UNSAFE_componentWillMount` usage. React will suggest migrating to `componentDidMount` or `constructor`.\n// 2. The console logs for 'Constructor called' and 'Render called' will appear twice, indicating double invocation to highlight potential side effects.\n\n// Refactored Component:\nclass ModernComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null };\n    console.log('ModernComponent: Constructor called'); // Still double-invoked, but no unsafe method warning.\n  }\n\n  componentDidMount() {\n    // Preferred place for side effects that need to run once after mount\n    console.log('ModernComponent: componentDidMount called');\n    // Example: fetch data here\n    // fetch('/api/data').then(...)\n  }\n\n  render() {\n    console.log('ModernComponent: Render called'); // Still double-invoked, pure function expected\n    return <div>Modern Component Content</div>;\n  }\n}\n\n// Functional Component Refactor (even better for new code):\nfunction ModernFunctionalComponent() {\n  const [data, setData] = React.useState(null);\n\n  React.useEffect(() => {\n    console.log('ModernFunctionalComponent: useEffect called'); // Runs only once after initial render (if dependencies are empty array)\n    // Fetch data here:\n    // fetch('/api/data').then(res => res.json()).then(setData);\n\n    return () => {\n      console.log('ModernFunctionalComponent: useEffect cleanup'); // Cleanup for subscriptions/timers\n    };\n  }, []); // Empty dependency array means this runs once on mount\n\n  console.log('ModernFunctionalComponent: Render called'); // Still double-invoked in StrictMode\n\n  return <div>Modern Functional Component Content: {data}</div>;\n}\n\n// Usage with StrictMode:\n// function App() {\n//   return (\n//     <React.StrictMode>\n//       <ModernComponent />\n//       <ModernFunctionalComponent />\n//     </React.StrictMode>\n//   );\n// }\n```",
          "options": [],
          "analysisPoints": [
            "Identifies the `UNSAFE_componentWillMount` as the primary warning.",
            "Explains the double-invocation behavior for constructor and render.",
            "Provides a correct refactoring using `componentDidMount`.",
            "Optionally provides a functional component refactor using `useEffect` for better modern React practices."
          ],
          "keyConcepts": [
            "React.StrictMode",
            "Unsafe Lifecycle Methods",
            "Double Invocation",
            "Refactoring",
            "componentDidMount",
            "useEffect"
          ],
          "evaluationCriteria": [
            "Correct identification of warnings.",
            "Accurate refactoring to remove warnings.",
            "Understanding of modern React patterns."
          ],
          "example": "See the `answer` field for the code example and explanation.",
          "tags": [
            "React",
            "StrictMode",
            "Code Refactoring",
            "Lifecycle Methods",
            "Functional Components"
          ],
          "prerequisites": [
            "react_lifecycle",
            "react_hooks",
            "react_class_components"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_modal_with_portal",
          "title": "Implement a Reusable Modal Component with React Portals",
          "description": "\nCreate a reusable `Modal` component in React that utilizes `ReactDOM.createPortal`. The modal should:\n\n1.  Render its children (content) into a specific DOM node outside the main React app's root (e.g., a `div` with `id=\"modal-root\"` in `public/index.html`).\n2.  Include a semi-transparent backdrop that covers the entire screen.\n3.  Allow closing the modal by clicking on the backdrop or by clicking a 'Close' button within the modal content.\n4.  Prevent events from inside the modal content from bubbling to the backdrop when clicking on the content itself.\n5.  Be usable from an `App` component by simply conditionally rendering it.\n\n**Requirements:**\n-   Use `ReactDOM.createPortal`.\n-   The modal should receive `children` for its content and an `onClose` callback.\n-   Ensure proper event handling for closing and content interaction.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\n// You will need to add <div id=\"modal-root\"></div> to your public/index.html body.\n\n// --- Modal Component (Implement this) ---\nfunction Modal({ children, onClose }) {\n  // TODO: Implement portal logic and modal structure\n  const modalRoot = document.getElementById('modal-root');\n  if (!modalRoot) {\n    console.error(\"Missing #modal-root in index.html\");\n    return null;\n  }\n\n  return ReactDOM.createPortal(\n    <div className=\"modal-backdrop\" style={{ \n      position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,\n      backgroundColor: 'rgba(0,0,0,0.5)', display: 'flex',\n      justifyContent: 'center', alignItems: 'center', zIndex: 1000\n    }} onClick={onClose}>\n      <div className=\"modal-content\" style={{ \n        background: 'white', padding: '20px', borderRadius: '5px',\n        minWidth: '300px', maxWidth: '80%', boxShadow: '0 4px 8px rgba(0,0,0,0.2)'\n      }} onClick={e => e.stopPropagation()}>\n        {children}\n        <button onClick={onClose} style={{ marginTop: '15px', padding: '8px 15px' }}>Close</button>\n      </div>\n    </div>,\n    modalRoot\n  );\n}\n\n// --- App Component (Use the Modal here) ---\nfunction App() {\n  const [showModal, setShowModal] = useState(false);\n\n  return (\n    <div style={{ padding: '20px', textAlign: 'center' }}>\n      <h1>React Portal Modal Demo</h1>\n      <p>Click the button below to open the modal.</p>\n      <button onClick={() => setShowModal(true)} style={{ padding: '10px 20px', fontSize: '16px' }}>\n        Show Portal Modal\n      </button>\n      \n      {showModal && (\n        <Modal onClose={() => setShowModal(false)}>\n          <h2>Welcome to the Modal!</h2>\n          <p>This content is rendered outside the main app DOM.</p>\n          <p>Click outside or the close button to dismiss.</p>\n        </Modal>\n      )}\n      \n      <div style={{ height: '1000px', background: '#f0f0f0', marginTop: '20px', overflow: 'auto' }}>\n        <p>Scrollable background content to demonstrate modal positioning.</p>\n        {Array.from({ length: 50 }).map((_, i) => (\n          <p key={i}>Scroll item {i + 1}</p>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nfunction Modal({ children, onClose }) {\n  const modalRoot = document.getElementById('modal-root');\n  if (!modalRoot) {\n    // Fallback or error handling if modal-root doesn't exist\n    console.error(\"The DOM element with ID 'modal-root' was not found. Please add <div id=\\\"modal-root\\\"></div> to your public/index.html\");\n    return null;\n  }\n\n  return ReactDOM.createPortal(\n    <div className=\"modal-backdrop\" \n         onClick={onClose} \n         style={{\n           position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,\n           backgroundColor: 'rgba(0,0,0,0.5)', display: 'flex',\n           justifyContent: 'center', alignItems: 'center', zIndex: 1000\n         }}>\n      <div className=\"modal-content\" \n           onClick={e => e.stopPropagation()} \n           style={{\n             background: 'white', padding: '20px', borderRadius: '5px',\n             minWidth: '300px', maxWidth: '80%', boxShadow: '0 4px 8px rgba(0,0,0,0.2)'\n           }}>\n        {children}\n        <button onClick={onClose} style={{ marginTop: '15px', padding: '8px 15px', cursor: 'pointer' }}>Close</button>\n      </div>\n    </div>,\n    modalRoot\n  );\n}\n\nfunction App() {\n  const [showModal, setShowModal] = useState(false);\n\n  return (\n    <div style={{ padding: '20px', textAlign: 'center' }}>\n      <h1>React Portal Modal Demo</h1>\n      <p>Click the button below to open the modal.</p>\n      <button onClick={() => setShowModal(true)} style={{ padding: '10px 20px', fontSize: '16px', cursor: 'pointer' }}>\n        Show Portal Modal\n      </button>\n      \n      {showModal && (\n        <Modal onClose={() => setShowModal(false)}>\n          <h2>Welcome to the Modal!</h2>\n          <p>This content is rendered outside the main app DOM.</p>\n          <p>Click outside or the close button to dismiss.</p>\n        </Modal>\n      )}\n      \n      <div style={{ height: '1000px', background: '#f0f0f0', marginTop: '20px', overflow: 'auto' }}>\n        <p>Scrollable background content to demonstrate modal positioning.</p>\n        {Array.from({ length: 50 }).map((_, i) => (\n          <p key={i}>Scroll item {i + 1}</p>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Modal opens when 'Show Portal Modal' button is clicked.",
            "Modal closes when the 'Close' button inside the modal is clicked.",
            "Modal closes when the semi-transparent backdrop is clicked.",
            "Modal does NOT close when the content inside the modal (e.g., text, inner elements) is clicked.",
            "Modal appears correctly positioned and centered, even when the background content is scrolled.",
            "Application remains responsive and interactive (apart from the modal) while the modal is open.",
            "Verify in browser developer tools that the modal element is appended to `#modal-root` (or the specified container) and not within the main `#root` div."
          ],
          "hints": [
            "Remember to create a dedicated DOM element (e.g., `<div id=\"modal-root\"></div>`) in your `public/index.html` file where the portal will render its content.",
            "Use `e.stopPropagation()` on the modal content's click handler to prevent clicks inside the modal from bubbling up to the backdrop.",
            "Consider using `position: fixed` for the backdrop to cover the entire viewport."
          ],
          "tags": [
            "React",
            "Portals",
            "UI Components",
            "Modals",
            "DOM Manipulation",
            "Event Handling"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_state",
            "react_props",
            "dom_basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "react_state_management",
            "event_bubbling",
            "css_positioning"
          ]
        },
        {
          "id": "task_implement_error_boundary",
          "title": "Implement and Demonstrate a React Error Boundary",
          "description": "\nImplement a React Error Boundary component and demonstrate its functionality by wrapping a child component that deliberately throws an error. The task requires:\n\n1.  **Create an `ErrorBoundary` class component**: This component must catch JavaScript errors in its children.\n    *   It should use `static getDerivedStateFromError(error)` to update state to trigger a fallback UI.\n    *   It should use `componentDidCatch(error, info)` to log the error to the console (simulating an error reporting service).\n    *   Its `render` method should conditionally display either its `children` or a fallback UI (e.g., 'Something went wrong.').\n2.  **Create a `BuggyComponent` functional component**: This component should throw an error under a specific condition (e.g., when a counter reaches a certain number, or a prop is missing).\n3.  **Demonstrate usage in `App`**: Wrap one instance of `BuggyComponent` with your `ErrorBoundary` and place another instance of `BuggyComponent` outside the `ErrorBoundary` to show the difference in behavior (one gracefully handles the error, the other crashes the app).\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\n// --- ErrorBoundary Component (Implement this) ---\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  // TODO: Implement static getDerivedStateFromError\n\n  // TODO: Implement componentDidCatch\n\n  render() {\n    // TODO: Conditionally render fallback UI or children\n    if (this.state.hasError) {\n      return (\n        <div style={{ border: '1px solid red', padding: '10px', margin: '10px' }}>\n          <h2>Something went wrong.</h2>\n          {/* Optional: display error details in development */}\n          {this.state.error && this.state.errorInfo && (\n            <details style={{ whiteSpace: 'pre-wrap' }}>\n              {this.state.error.toString()}\n              <br />\n              {this.state.errorInfo.componentStack}\n            </details>\n          )}\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n\n// --- Buggy Component (Implement this) ---\nfunction BuggyComponent() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    // TODO: Make this component throw an error under a condition\n    setCount(prevCount => prevCount + 1);\n  };\n\n  if (count > 5) {\n    // Example: Throw an error during render if count exceeds 5\n    // throw new Error('I crashed due to count exceeding 5!');\n  }\n\n  return (\n    <div style={{ border: '1px solid gray', padding: '10px', margin: '10px' }}>\n      <p>Buggy Counter: {count}</p>\n      <button onClick={handleClick}>Increment Buggy Counter</button>\n    </div>\n  );\n}\n\n// --- App Component (Use the components here) ---\nfunction App() {\n  return (\n    <div>\n      <h1>Error Boundary Demonstration</h1>\n      <p>The first counter is wrapped in an Error Boundary. The second is not.</p>\n      \n      {/* Wrapped BuggyComponent */}\n      <ErrorBoundary>\n        <BuggyComponent />\n      </ErrorBoundary>\n\n      <hr />\n      \n      {/* Unwrapped BuggyComponent (will crash the app) */}\n      <h2>Unwrapped Component:</h2>\n      <BuggyComponent />\n    </div>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { useState } from 'react';\n\n// --- ErrorBoundary Component ---\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render shows the fallback UI.\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // You can also log the error to an error reporting service here.\n    console.error(\"Caught by ErrorBoundary:\", error, errorInfo);\n    this.setState({\n      error: error,\n      errorInfo: errorInfo\n    });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // Render any custom fallback UI.\n      return (\n        <div style={{ border: '1px solid red', padding: '10px', margin: '10px', backgroundColor: '#ffe6e6' }}>\n          <h2>Something went wrong in this section.</h2>\n          <p>We are sorry for the inconvenience.</p>\n          {/* Display error details in development for debugging */}\n          {this.state.error && this.state.errorInfo && (\n            <details style={{ whiteSpace: 'pre-wrap', fontSize: '0.8em', color: '#cc0000' }}>\n              {this.state.error.toString()}\n              <br />\n              {this.state.errorInfo.componentStack}\n            </details>\n          )}\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n\n// --- Buggy Component ---\nfunction BuggyComponent() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  if (count === 5) {\n    // This error will be caught by the ErrorBoundary if wrapped\n    throw new Error('BuggyComponent crashed at count 5!');\n  }\n\n  return (\n    <div style={{ border: '1px solid gray', padding: '10px', margin: '10px', backgroundColor: '#f9f9f9' }}>\n      <p>Current Count: {count}</p>\n      <button onClick={handleClick}>Increment Counter</button>\n      <p>Keep clicking to see the error!</p>\n    </div>\n  );\n}\n\n// --- App Component ---\nfunction App() {\n  return (\n    <div style={{ fontFamily: 'Arial, sans-serif', maxWidth: '800px', margin: '20px auto', padding: '20px', border: '1px solid #eee', boxShadow: '2px 2px 5px rgba(0,0,0,0.1)' }}>\n      <h1 style={{ textAlign: 'center' }}>React Error Boundary Demonstration</h1>\n      <p>This example demonstrates how Error Boundaries help prevent an entire application crash. The first counter is wrapped in an Error Boundary, while the second is not.</p>\n      \n      <h2 style={{ color: '#0056b3' }}>Wrapped Component:</h2>\n      <ErrorBoundary>\n        <BuggyComponent />\n      </ErrorBoundary>\n\n      <hr style={{ margin: '30px 0' }}/>\n      \n      <h2 style={{ color: '#cc0000' }}>Unwrapped Component (will crash the app):</h2>\n      <BuggyComponent />\n      \n      <p style={{ marginTop: '40px', fontSize: '0.9em', color: '#666' }}>Note: The unwrapped component will cause the entire React application to unmount and display a blank page or a development error overlay when it crashes.</p>\n    </div>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "The first `BuggyComponent` (wrapped) displays the 'Something went wrong.' fallback UI when it throws an error (e.g., count reaches 5).",
            "The browser's console shows the error logged by `componentDidCatch` when the wrapped `BuggyComponent` crashes.",
            "The second `BuggyComponent` (unwrapped) causes the entire React application to crash or show the development error overlay when it throws an error.",
            "The 'Something went wrong.' message is displayed only where the error occurred, not affecting other parts of the application if the error is within a boundary.",
            "No errors are thrown in the ErrorBoundary component itself."
          ],
          "hints": [
            "Remember to use `static getDerivedStateFromError` for state updates and `componentDidCatch` for side effects like logging.",
            "Ensure the error in `BuggyComponent` is thrown during rendering or a lifecycle method (not inside an event handler) for the Error Boundary to catch it.",
            "You can throw a simple `new Error('Your custom error message');` from `BuggyComponent`.",
            "The `render` method of the `ErrorBoundary` should check `this.state.hasError` to conditionally render the fallback UI or `this.props.children`."
          ],
          "tags": [
            "React",
            "Error Handling",
            "Class Components",
            "Lifecycle Methods",
            "Debugging"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_class_components",
            "react_state",
            "react_lifecycle"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "react_component_lifecycle",
            "state_management",
            "error_logging"
          ]
        },
        {
          "id": "task_demonstrate_strictmode_effects",
          "title": "Demonstrate React.StrictMode's Effects on Component Lifecycle",
          "description": "\nThis task involves demonstrating the effect of `React.StrictMode` on component lifecycle methods and render functions.\n\n1.  **Create a `StrictModeDemoComponent` (Class Component)**:\n    *   Include a `constructor` that logs a message.\n    *   Include a `render` method that logs a message.\n    *   Optionally, include an `UNSAFE_componentWillMount()` method that logs a message to observe a specific StrictMode warning.\n2.  **Create a `FunctionalStrictModeDemo` (Functional Component)**:\n    *   Include a `console.log` directly in the component body (which runs during render).\n    *   Include a `useEffect` hook that logs a message once on mount.\n3.  **Wrap your components in `App` with `React.StrictMode`**.\n4.  **Run the application and observe the console output.** Document which logs appear twice (due to double invocation) and any specific warnings from StrictMode.\n5.  **Explain the observations:** Why do certain logs appear twice? What does this imply about the purity of `render` methods and constructors?\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// --- StrictModeDemoComponent (Class Component) ---\nclass StrictModeDemoComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    console.log('StrictModeDemoComponent: Constructor called');\n    this.state = { count: 0 };\n  }\n\n  // Optional: Add UNSAFE_componentWillMount() for a specific StrictMode warning\n  // UNSAFE_componentWillMount() {\n  //   console.log('StrictModeDemoComponent: UNSAFE_componentWillMount called');\n  // }\n\n  render() {\n    console.log('StrictModeDemoComponent: Render called');\n    return (\n      <div style={{ border: '1px dashed blue', padding: '10px', margin: '10px' }}>\n        <h3>Class Component Demo</h3>\n        <p>Check console for logs.</p>\n        <button onClick={() => this.setState(prev => ({ count: prev.count + 1 }))}>Increment (Affects Render)</button>\n      </div>\n    );\n  }\n}\n\n// --- FunctionalStrictModeDemo (Functional Component) ---\nfunction FunctionalStrictModeDemo() {\n  console.log('FunctionalStrictModeDemo: Component body (render) called');\n\n  useEffect(() => {\n    console.log('FunctionalStrictModeDemo: useEffect (mount) called');\n    // This should only run once on mount\n    return () => {\n      console.log('FunctionalStrictModeDemo: useEffect (cleanup) called');\n    };\n  }, []); // Empty dependency array means run once on mount and cleanup on unmount\n\n  return (\n    <div style={{ border: '1px dashed green', padding: '10px', margin: '10px' }}>\n      <h3>Functional Component Demo</h3>\n      <p>Check console for logs.</p>\n    </div>\n  );\n}\n\n// --- App Component ---\nfunction App() {\n  return (\n    <React.StrictMode>\n      <div style={{ fontFamily: 'Arial, sans-serif', maxWidth: '800px', margin: '20px auto', padding: '20px', border: '1px solid #eee', boxShadow: '2px 2px 5px rgba(0,0,0,0.1)' }}>\n        <h1>React.StrictMode Demonstration</h1>\n        <p>Open your browser's developer console to observe the logs and warnings from StrictMode.</p>\n        <p>Notice how certain messages might appear twice.</p>\n\n        <StrictModeDemoComponent />\n        <FunctionalStrictModeDemo />\n\n      </div>\n    </React.StrictMode>\n  );\n}\n\nexport default App;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\n// --- StrictModeDemoComponent (Class Component) ---\nclass StrictModeDemoComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    console.log('StrictModeDemoComponent: Constructor called (should be double-invoked in StrictMode)');\n    this.state = { count: 0 };\n  }\n\n  // This lifecycle method is considered unsafe and will cause a warning in StrictMode.\n  UNSAFE_componentWillMount() {\n    console.log('StrictModeDemoComponent: UNSAFE_componentWillMount called (Strict Mode Warning!)');\n  }\n\n  componentDidMount() {\n    console.log('StrictModeDemoComponent: componentDidMount called (should be single-invoked)');\n  }\n\n  render() {\n    console.log('StrictModeDemoComponent: Render called (should be double-invoked in StrictMode)');\n    return (\n      <div style={{ border: '1px dashed blue', padding: '10px', margin: '10px', backgroundColor: '#e6f0ff' }}>\n        <h3>Class Component Demo</h3>\n        <p>Check console for logs.</p>\n        <p>Count: {this.state.count}</p>\n        <button onClick={() => this.setState(prev => ({ count: prev.count + 1 }))}>Increment (Affects Render)</button>\n      </div>\n    );\n  }\n}\n\n// --- FunctionalStrictModeDemo (Functional Component) ---\nfunction FunctionalStrictModeDemo() {\n  console.log('FunctionalStrictModeDemo: Component body (render) called (should be double-invoked in StrictMode)');\n\n  useEffect(() => {\n    console.log('FunctionalStrictModeDemo: useEffect (mount) called (should be single-invoked)');\n    // This should only run once on mount\n    return () => {\n      console.log('FunctionalStrictModeDemo: useEffect (cleanup) called (should run on unmount/re-mount)');\n    };\n  }, []); // Empty dependency array means run once on mount and cleanup on unmount\n\n  return (\n    <div style={{ border: '1px dashed green', padding: '10px', margin: '10px', backgroundColor: '#e6ffe6' }}>\n      <h3>Functional Component Demo</h3>\n      <p>Check console for logs.</p>\n    </div>\n  );\n}\n\n// --- App Component ---\nfunction App() {\n  return (\n    <React.StrictMode>\n      <div style={{ fontFamily: 'Arial, sans-serif', maxWidth: '800px', margin: '20px auto', padding: '20px', border: '1px solid #eee', boxShadow: '2px 2px 5px rgba(0,0,0,0.1)' }}>\n        <h1>React.StrictMode Demonstration</h1>\n        <p>Open your browser's developer console to observe the logs and warnings from StrictMode.</p>\n        <p>Notice how certain messages might appear twice, indicating checks for unexpected side effects.</p>\n        <p>Also, look for warnings about deprecated lifecycle methods.</p>\n\n        <StrictModeDemoComponent />\n        <FunctionalStrictModeDemo />\n\n        <div style={{ marginTop: '30px', borderTop: '1px solid #eee', paddingTop: '20px' }}>\n          <h3>Observations Explanation:</h3>\n          <ul>\n            <li>The <b>Constructor</b> and <b>Render</b> methods (both class and functional component bodies) are logged twice. This is StrictMode's way of detecting potential side effects. If these methods were not pure (e.g., directly modifying the DOM or global state), running them twice could lead to bugs.</li>\n            <li><code>UNSAFE_componentWillMount</code> (if uncommented) will trigger a warning. StrictMode helps identify legacy and problematic lifecycle methods.</li>\n            <li><code>componentDidMount</code> and <code>useEffect</code> with an empty dependency array (`[]`) are logged only once. These are the correct places for side effects that should run only once after a component mounts, as React ensures they are not double-invoked.</li>\n          </ul>\n        </div>\n\n      </div>\n    </React.StrictMode>\n  );\n}\n\nexport default App;\n",
          "testCases": [
            "Browser console shows `StrictModeDemoComponent: Constructor called` twice on initial render.",
            "Browser console shows `StrictModeDemoComponent: Render called` twice on initial render and any state updates.",
            "Browser console shows `FunctionalStrictModeDemo: Component body (render) called` twice on initial render.",
            "Browser console shows `StrictModeDemoComponent: UNSAFE_componentWillMount called` once AND a React warning about its usage.",
            "Browser console shows `StrictModeDemoComponent: componentDidMount called` only once.",
            "Browser console shows `FunctionalStrictModeDemo: useEffect (mount) called` only once.",
            "The application renders without errors, and the console clearly shows the intended StrictMode behaviors (double invocations, warnings)."
          ],
          "hints": [
            "Remember that `React.StrictMode` only affects development mode, so these logs and warnings will not appear in a production build.",
            "The double invocation for `render` and constructors is a key aspect of StrictMode's 'detecting unexpected side effects' check.",
            "Side effects that should only run once (like data fetching or subscriptions) should be placed in `componentDidMount` (for class components) or `useEffect` with an empty dependency array (for functional components), as these are explicitly designed to be safe from double invocation."
          ],
          "tags": [
            "React",
            "StrictMode",
            "Debugging",
            "Lifecycle Methods",
            "Functional Components",
            "Class Components"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "react_lifecycle",
            "react_hooks",
            "react_functional_components",
            "react_class_components"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "pure_functions",
            "side_effects",
            "concurrent_mode",
            "component_purity"
          ]
        }
      ]
    }
  },
  {
    "id": "f6c5f866-13e0-4184-98a2-063323ed2131",
    "startLine": 6100,
    "endLine": 6199,
    "processedDate": "2025-06-17T09:52:07.119Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_strict_mode",
          "title": "React StrictMode",
          "content": "React's `StrictMode` is a development-only tool that helps developers identify potential problems in an application. It activates additional checks and warnings for its descendants. It does not render any visible UI and does not impact the production build.\n\n## Purpose of StrictMode\n- **Identifying Side Effects**: StrictMode helps detect unintended side effects by deliberately double-invoking certain functions (like `render` method, `useState` updater functions, `useEffect` cleanup and setup functions). If a function is pure, calling it twice should not change the application state or behavior, making side effects obvious.\n- **Preparing for Future React Features**: It helps your code be more resilient to future changes in React, especially related to concurrent rendering. Features like concurrent mode or automatic batching rely on components being pure and side-effect free.\n- **Deprecation Warnings**: It warns about deprecated lifecycle methods or API usages.\n- **Legacy Context API**: Warns about unsafe lifecycles, and usage of the legacy context API.\n- **Finding unexpected side effects**: It checks for unexpected side effects during component rendering, state updates, and lifecycle methods.\n\n## Double-Invocation Mechanism\nStrictMode intentionally double-invokes methods or functions such as:\n- Component `render` method.\n- `useState`, `useReducer` updater functions.\n- `useEffect` cleanup and setup functions.\n- Class component `constructor`, `render`, `shouldComponentUpdate`, `getDerivedStateFromProps`, `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`.\n\nIf your components are pure and free of side effects, this double invocation will not cause any issues. If there are side effects (e.g., mutating external state in a `render` method), the double invocation will make them more apparent during development, aiding in debugging and fixing them.\n\n## Usage\nTo use `StrictMode`, wrap any part of your application with `<React.StrictMode>`.",
          "examples": [
            {
              "id": "example_strict_mode_1",
              "title": "Basic StrictMode Usage",
              "code": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\n\nfunction MyComponent() {\n  // In StrictMode, if this console.log had side effects, \n  // it would be more apparent due to double invocation.\n  console.log('MyComponent is rendering');\n  return <h1>Hello from MyComponent</h1>;\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <MyComponent />\n  </React.StrictMode>\n);",
              "explanation": "This example shows how to wrap a component with `React.StrictMode`. During development, `MyComponent`'s `console.log` might appear twice, indicating the double invocation of the render method and prompting developers to ensure their components' render logic is pure.",
              "language": "typescript"
            },
            {
              "id": "example_strict_mode_2",
              "title": "StrictMode with useState and useEffect",
              "code": "import React, { useState, useEffect } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Effect setup run, count:', count);\n    return () => {\n      console.log('Effect cleanup run, count:', count);\n    };\n  }, [count]);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <React.StrictMode>\n      <Counter />\n    </React.StrictMode>\n  );\n}\n\nexport default App;",
              "explanation": "In this example, when `Counter` mounts or `count` changes in StrictMode, you will see the effect setup and cleanup functions log twice. This is React helping ensure that your effects are idempotent and handle cleanup correctly, which is crucial for future concurrent features.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_strict_mode_1",
            "question_strict_mode_2",
            "question_strict_mode_3",
            "question_strict_mode_4",
            "question_strict_mode_5"
          ],
          "relatedTasks": [
            "task_strict_mode_1"
          ],
          "tags": [
            "React",
            "StrictMode",
            "Development",
            "Debugging",
            "Side Effects",
            "Performance"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Component_Lifecycle",
            "React_Hooks_Basics"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Concurrent_React",
            "Advanced_Debugging"
          ]
        },
        {
          "id": "theory_error_handling_boundaries",
          "title": "React Error Boundaries",
          "content": "React 16 introduced the concept of **Error Boundaries** to gracefully handle JavaScript errors in components. An Error Boundary is a React component that **catches JavaScript errors anywhere in its child component tree, logs those errors, and displays a fallback UI** instead of crashing the entire application.\n\n## Why Error Boundaries?\nWithout error boundaries, a JavaScript error in a component's render method would unmount the entire React component tree, leading to a blank screen or a broken UI. Error boundaries provide a way to 'catch' these errors and render a meaningful fallback UI, preventing the entire application from crashing.\n\n## How to Create an Error Boundary\nAn error boundary is a class component that implements at least one of two new lifecycle methods:\n\n1.  `static getDerivedStateFromError(error)`:\n    - This static method is called after an error has been thrown by a descendant component.\n    - It receives the `error` that was thrown.\n    - It should return an object to update state (e.g., `{ hasError: true }`) which will then trigger a re-render of the boundary component with the fallback UI.\n    - Its primary purpose is to render a fallback UI after an error.\n\n2.  `componentDidCatch(error, info)`:\n    - This method is called after an error has been thrown by a descendant component.\n    - It receives two arguments: `error` (the error object) and `info` (an object with a `componentStack` property containing the component stack trace).\n    - It's primarily used for side effects, such as logging the error to an error reporting service (e.g., Sentry, Bugsnag).\n\n## What Errors Do Error Boundaries Catch?\nError boundaries catch errors that occur during:\n-   Rendering (`render` method)\n-   Lifecycle methods (e.g., `componentDidMount`, `componentDidUpdate`)\n-   Constructors of the whole tree below them.\n\n## What Errors Do Error Boundaries NOT Catch?\nError boundaries **do not** catch errors for:\n-   **Event handlers**: Errors inside event handlers (e.g., `onClick`, `onChange`) do not break the entire application and can be caught with regular `try...catch` blocks within the handler itself.\n-   **Asynchronous code**: Errors inside `setTimeout` or `requestAnimationFrame` callbacks, or in `Promise` callbacks (e.g., `fetch` or `axios` requests).\n-   **Server-side rendering**: Errors that occur during server-side rendering.\n-   **Errors thrown in the error boundary itself**: An error boundary cannot catch errors within itself. If the error boundary's `render` method or lifecycle methods throw an error, React will unmount the entire component tree. This is why the fallback UI should be very simple and error-free.\n\n## Placement of Error Boundaries\nYou can place error boundaries anywhere in your component tree. They are most effective when placed around logical blocks of components, allowing you to show specific fallback UIs for different parts of your application.",
          "examples": [
            {
              "id": "example_error_boundary_1",
              "title": "Basic Error Boundary Implementation",
              "code": "import React from 'react';\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state to display fallback UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    // Log the error to an error reporting service\n    console.error(\"Error caught by boundary:\", error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children;\n  }\n}\n\n// Example usage:\nfunction BuggyCounter() {\n  const [count, setCount] = React.useState(0);\n  const handleClick = () => setCount(count + 1);\n\n  if (count === 5) {\n    // Simulate an error when count reaches 5\n    throw new Error('I crashed!');\n  }\n\n  return <h1 onClick={handleClick}>{count}</h1>;\n}\n\nfunction App() {\n  return (\n    <div>\n      <h2>Click the numbers to increment. Click the number that will crash.</h2>\n      <ErrorBoundary>\n        <p>This is a buggy counter:</p>\n        <BuggyCounter />\n      </ErrorBoundary>\n      <p>This is another counter, unaffected by the first:</p>\n      <BuggyCounter />\n    </div>\n  );\n}",
              "explanation": "This example demonstrates a typical Error Boundary component. When `BuggyCounter`'s `count` reaches 5, it throws an error. The `ErrorBoundary` catches this error, updates its state via `getDerivedStateFromError` to `hasError: true`, and then renders its fallback UI ('Something went wrong.'). `componentDidCatch` logs the error for debugging. Notice how the second `BuggyCounter` remains unaffected because it's not wrapped by the crashing boundary, illustrating localized error handling.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_error_boundary_1",
            "question_error_boundary_2",
            "question_error_boundary_3",
            "question_error_boundary_4",
            "question_error_boundary_5",
            "question_error_boundary_6"
          ],
          "relatedTasks": [
            "task_error_boundary_1"
          ],
          "tags": [
            "React",
            "Error Handling",
            "Error Boundaries",
            "Component Lifecycle",
            "Debugging"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Class_Components",
            "React_Lifecycle_Methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Robust_Applications",
            "Production_Ready_Apps"
          ]
        },
        {
          "id": "theory_react_router",
          "title": "React Router: v5 vs v6",
          "content": "React Router is the de-facto standard library for declarative routing in React applications. It enables single-page applications to have multiple views or 'pages' without requiring a full page reload from the server. It keeps the UI in sync with the URL.\n\n## React Router v6 (Latest)\nReact Router v6 was a significant rewrite focusing on smaller bundle sizes, hooks-based API, and improved performance. It introduces a more declarative and nested approach to routing.\n\n### Key Components in v6\n-   `<BrowserRouter>`: Uses the HTML5 history API (`pushState`, `replaceState`, `popstate`) to keep your UI in sync with the URL.\n-   `<Routes>`: Replaces `Switch` from v5. It is a container for all `<Route>` elements. It selects the best match among its children.\n-   `<Route>`: Declares a route. It takes a `path` prop and an `element` prop which renders the component for that route.\n-   `useRoutes`: A hook-based alternative to `<Routes>` that allows you to define routes as JavaScript objects.\n-   `useNavigate`, `useParams`, `useLocation`, `useMatch`: New hooks for programmatically navigating, accessing URL parameters, current location, and route matching information.\n\n```typescript\n// Basic routing setup in React Router v6\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nfunction Home() { return <h2>Home Page</h2>; }\nfunction About() { return <h2>About Us</h2>; }\nfunction Users() { return <h2>Users Section</h2>; }\nfunction UserDetails() { return <h3>User Details Page</h3>; }\nfunction NoMatch() { return <h2>404 - Page Not Found</h2>; }\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"about\" element={<About />} />\n        <Route path=\"users\" element={<Users />}> {/* Parent route */}\n          <Route path=\":userId\" element={<UserDetails />} /> {/* Nested route */}\n        </Route>\n        <Route path=\"*\" element={<NoMatch />} /> {/* 404 route */}\n      </Routes>\n    </BrowserRouter>\n  );\n}\n```\n\n## React Router v5\nReact Router v5 was widely used and provided robust routing capabilities. While still functional, it's considered legacy for new projects.\n\n### Key Components in v5\n-   `<BrowserRouter>` (or `<Router>` as alias): Similar to v6.\n-   `<Switch>`: Ensures that only the *first* matching `<Route>` is rendered. If multiple routes match, only the first one defined will be rendered.\n-   `<Route>`: Declares a route. It takes a `path` prop and a `component` prop (or `render` or `children`) which renders the component for that route.\n-   `exact` prop: Used on `<Route>` to ensure the path matches the URL exactly.\n\n```typescript\n// Basic routing setup in React Router v5\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nfunction Home() { return <h2>Home Page</h2>; }\nfunction About() { return <h2>About Us</h2>; }\nfunction UserDetails() { return <h3>User Details Page</h3>; }\nfunction NoMatch() { return <h2>404 - Page Not Found</h2>; }\n\nfunction App() {\n  return (\n    <Router>\n      <Switch>\n        <Route exact path=\"/\" component={Home}/>\n        <Route path=\"/about\" component={About}/>\n        <Route path=\"/users/:userId\" component={UserDetails}/>\n        <Route path=\"*\" component={NoMatch}/> {/* 404 route */}\n      </Switch>\n    </Router>\n  );\n}\n```\n\n## Key Differences between v5 and v6\n\n1.  **`Switch` renamed to `Routes`**\n    -   **v5**: Uses `<Switch>` to render the *first* child `<Route>` or `<Redirect>` that matches the location.\n    -   **v6**: Uses `<Routes>`. It's an improved version that is more intelligent about matching routes, ranking them by specificity and choosing the best match rather than just the first one. It also enables nested routing more intuitively.\n\n2.  **`component={Component}` changed to `element={<Component />}`**\n    -   **v5**: `component={MyComponent}` was used to render a component. This would implicitly create a new component instance with route props (`history`, `location`, `match`).\n    -   **v6**: `element={<MyComponent />}` is used. This allows you to pass props directly to the component, making it more explicit and flexible. It's a standard React element, which aligns with how React typically renders components and helps with optimizations.\n\n3.  **Nested routes are declared more naturally**\n    -   **v5**: Nested routes often required props drilling or complex rendering logic (`render` prop) within the parent component to render child routes.\n    -   **v6**: Nested routes are declared directly as children of their parent `<Route>` in the `Routes` component. The parent route specifies a partial path, and child routes append to it. A parent route rendering its children uses an `<Outlet>` component (not shown in basic example, but essential for nested layouts).\n\n4.  **`exact` prop is no longer needed**\n    -   **v5**: The `exact` prop was crucial to prevent partial matches, ensuring that `/` didn't also match `/about`.\n    -   **v6**: The `exact` prop is deprecated. Routes are now matched by their specificity (ranking algorithm) by default, meaning `/` will only match exactly `/`, and `/about` will match `/about` but not `/`. This makes routing more intuitive and less error-prone.\n\n5.  **Route path patterns are more robust and flexible**\n    -   **v6**: Supports more advanced pattern matching capabilities, including optional segments (`/users/:userId?`), wildcard segments (`/*`), and more dynamic segment definitions. This allows for more expressive and concise routing logic.\n\n6.  **Relative routes and links**\n    -   **v6**: Introduces relative paths for `Route` and `Link` components. This means you can specify paths relative to the current URL, making it easier to build modular applications, especially with nested routing. For example, a `Link to=\"details\"` within a `/users` route will navigate to `/users/details`.\n\n7.  **Hooks-based API**: v6 heavily relies on hooks (`useNavigate`, `useParams`, `useLocation`, `useMatch`) for programmatic navigation and accessing route information, making it more functional and aligned with modern React practices.",
          "examples": [
            {
              "id": "example_react_router_v6_nested",
              "title": "React Router v6 Nested Routing with Outlet",
              "code": "import React from 'react';\nimport { BrowserRouter, Routes, Route, Link, Outlet, useParams, useNavigate } from 'react-router-dom';\n\nfunction Dashboard() {\n  return (\n    <div>\n      <h2>Dashboard</h2>\n      <nav>\n        <Link to=\"./profile\">Profile</Link> |\n        <Link to=\"./settings\">Settings</Link>\n      </nav>\n      <Outlet /> {/* Renders child routes here */}\n    </div>\n  );\n}\n\nfunction Profile() { return <h3>Profile Page</h3>; }\nfunction Settings() { return <h3>Settings Page</h3>; }\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <h1>App Header</h1>\n      <nav>\n        <Link to=\"/\">Home</Link> | <Link to=\"/dashboard\">Dashboard</Link>\n      </nav>\n      <Routes>\n        <Route path=\"/\" element={<h2>Welcome Home!</h2>} />\n        <Route path=\"/dashboard\" element={<Dashboard />}>\n          <Route path=\"profile\" element={<Profile />} />\n          <Route path=\"settings\" element={<Settings />} />\n          <Route index element={<h4>Select an option</h4>} /> {/* Default child route */}\n        </Route>\n        <Route path=\"*\" element={<h2>404 - Not Found</h2>} />\n      </Routes>\n    </BrowserRouter>\n  );\n}",
              "explanation": "This example showcases React Router v6's powerful nested routing. The `Dashboard` component contains an `<Outlet />`, which acts as a placeholder for its child routes (`Profile`, `Settings`, and a default `index` route). Links within `Dashboard` use relative paths (`./profile`), simplifying navigation within a nested context.",
              "language": "typescript"
            },
            {
              "id": "example_react_router_v6_hooks",
              "title": "React Router v6 Hooks Usage",
              "code": "import React from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\n\nfunction UserProfile() {\n  const { userId } = useParams();\n  const navigate = useNavigate();\n\n  const goToHome = () => {\n    navigate('/');\n  };\n\n  return (\n    <div>\n      <h2>User Profile for ID: {userId}</h2>\n      <button onClick={goToHome}>Go to Home</button>\n    </div>\n  );\n}\n\n// (Assume BrowserRouter and Routes are set up higher in the component tree)\n// <Route path=\"/users/:userId\" element={<UserProfile />} />",
              "explanation": "This example demonstrates two key React Router v6 hooks: `useParams` to extract dynamic segments from the URL (like `userId` from `/users/123`), and `useNavigate` for programmatic navigation (e.g., navigating to the home page on button click). These hooks provide a modern, functional way to interact with the router.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_router_1",
            "question_react_router_2",
            "question_react_router_3",
            "question_react_router_4",
            "question_react_router_5",
            "question_react_router_6",
            "question_react_router_7",
            "question_react_router_8"
          ],
          "relatedTasks": [
            "task_react_router_1"
          ],
          "tags": [
            "React",
            "React Router",
            "Routing",
            "Frontend",
            "SPA",
            "Navigation"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Components",
            "JavaScript_ES6"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Complex_SPAs",
            "Fullstack_Applications"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_strict_mode_1",
          "topic": "React StrictMode",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of React's StrictMode?",
          "answer": "To help identify potential problems and side effects in a React application during development.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "StrictMode",
            "Development Mode"
          ],
          "evaluationCriteria": [
            "Basic understanding of StrictMode's goal"
          ],
          "example": "",
          "tags": [
            "React",
            "StrictMode",
            "Development"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_strict_mode_2",
          "topic": "React StrictMode",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following statements about React.StrictMode is TRUE?",
          "answer": "It is only active in development mode and does not affect the production build.",
          "options": [
            "It is only active in development mode and does not affect the production build.",
            "It adds extra runtime overhead to production builds for better debugging.",
            "It prevents all side effects from occurring in your React application.",
            "It enables concurrent rendering features automatically in production."
          ],
          "analysisPoints": [
            "StrictMode is a development-only tool.",
            "It helps *identify* side effects, not *prevent* all of them.",
            "It *prepares* for concurrent rendering but doesn't enable it automatically in production.",
            "No production overhead."
          ],
          "keyConcepts": [
            "StrictMode",
            "Development vs Production",
            "Side Effects"
          ],
          "evaluationCriteria": [
            "Understanding of StrictMode's operational scope.",
            "Distinguishing development from production features."
          ],
          "example": "StrictMode is designed to be a developer aid, running checks that might be too expensive for a production environment, ensuring that your final build remains performant.",
          "tags": [
            "React",
            "StrictMode",
            "Development",
            "Production"
          ],
          "prerequisites": [
            "React_Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_strict_mode_3",
          "topic": "React StrictMode",
          "level": "medium",
          "type": "open",
          "question": "Explain how StrictMode helps detect unexpected side effects, particularly mentioning the 'double-invocation' mechanism. Provide a small code snippet where this behavior would be noticeable.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Mentioning double-invocation of render, useState/useReducer updaters, useEffect setup/cleanup.",
            "Explaining that pure functions should yield the same result on double invocation, while side effects become apparent.",
            "Providing a relevant code example that shows a console log or state mutation issue."
          ],
          "keyConcepts": [
            "StrictMode",
            "Side Effects",
            "Double Invocation",
            "Pure Functions"
          ],
          "evaluationCriteria": [
            "Clarity of explanation on double-invocation.",
            "Ability to connect double-invocation to side effect detection.",
            "Correctness and relevance of the code snippet."
          ],
          "example": "```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction ComponentWithSideEffect() {\n  const [value, setValue] = useState(0);\n\n  // This effect runs twice in StrictMode on mount\n  useEffect(() => {\n    console.log('Effect mounted/updated:', value);\n    // Simulating a side effect that would be noticeable if run twice unintentionally\n    // For instance, if you were appending to a global array here without cleanup.\n    return () => {\n      console.log('Effect cleanup:', value);\n    };\n  }, [value]);\n\n  return (\n    <div>\n      <p>Value: {value}</p>\n      <button onClick={() => setValue(value + 1)}>Increment</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <React.StrictMode>\n      <ComponentWithSideEffect />\n    </React.StrictMode>\n  );\n}\n\nexport default App;\n```\n\n**Explanation:**\nIn StrictMode, `useEffect`'s setup and cleanup functions are run an additional time during development. When `ComponentWithSideEffect` mounts, you'd typically expect 'Effect mounted/updated: 0' once. However, in StrictMode, you'll see 'Effect setup run: 0', then 'Effect cleanup run: 0', and then 'Effect setup run: 0' again. This highlights that your effects should be robust enough to handle being cleaned up and re-set up immediately, encouraging idempotent effects and proper cleanup, which is crucial for features like Fast Refresh and future concurrent rendering.",
          "tags": [
            "React",
            "StrictMode",
            "Side Effects",
            "Debugging",
            "Hooks"
          ],
          "prerequisites": [
            "React_Hooks",
            "Component_Lifecycle"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_strict_mode_4",
          "topic": "React StrictMode",
          "level": "easy",
          "type": "flashcard",
          "question": "Does StrictMode enhance performance in production applications?",
          "answer": "No, StrictMode is a development-only tool and has no impact on production performance or bundle size.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "StrictMode",
            "Production Performance"
          ],
          "evaluationCriteria": [
            "Understanding StrictMode's scope"
          ],
          "example": "",
          "tags": [
            "React",
            "StrictMode",
            "Performance"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_strict_mode_5",
          "topic": "React StrictMode",
          "level": "medium",
          "type": "code",
          "question": "Consider the following component. Explain what logs you would see in the console when this component mounts inside `React.StrictMode` and when the button is clicked once. What if `StrictMode` was not used?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly identifies the double invocation of `useEffect` setup and cleanup on mount in StrictMode.",
            "Correctly identifies the single invocation of `useEffect` setup and cleanup on update in StrictMode.",
            "Correctly identifies the single invocation of `useEffect` setup and cleanup on mount and update without StrictMode.",
            "Explains the purpose behind StrictMode's behavior.",
            "Predicts exact console output order."
          ],
          "keyConcepts": [
            "StrictMode",
            "useEffect",
            "Component Lifecycle",
            "Side Effects",
            "Double Invocation"
          ],
          "evaluationCriteria": [
            "Ability to trace execution flow with StrictMode.",
            "Understanding of `useEffect` lifecycle.",
            "Comparison of behavior with and without StrictMode."
          ],
          "example": "```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction LoggerComponent() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log(`Effect: Setup for count ${count}`);\n    return () => {\n      console.log(`Effect: Cleanup for count ${count}`);\n    };\n  }, [count]);\n\n  console.log(`Render: count ${count}`);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\n// Assume App wraps LoggerComponent with React.StrictMode or not\n// For example: \n// ReactDOM.createRoot(...).render(<React.StrictMode><LoggerComponent /></React.StrictMode>);\n```\n\n**Expected Console Output:**\n\n**1. With `React.StrictMode` (on initial mount):**\n```\nRender: count 0\nRender: count 0\nEffect: Setup for count 0\nEffect: Cleanup for count 0\nEffect: Setup for count 0\n```\n**Explanation:**\n- `Render: count 0` appears twice because StrictMode double-invokes the render function to check for side effects.\n- `Effect: Setup for count 0` runs once for the initial mount.\n- `Effect: Cleanup for count 0` runs immediately after the first setup, simulating a remount.\n- `Effect: Setup for count 0` runs again for the 'actual' mount, ensuring the effect is resilient to double-execution and cleanup.\n\n**2. With `React.StrictMode` (after clicking increment button once, `count` becomes 1):**\n```\nRender: count 1\nRender: count 1\nEffect: Cleanup for count 0\nEffect: Setup for count 1\nEffect: Cleanup for count 1\nEffect: Setup for count 1\n```\n**Explanation:**\n- `Render: count 1` appears twice as the component re-renders and StrictMode checks for side effects.\n- `Effect: Cleanup for count 0` runs because the `count` dependency changed from 0 to 1, triggering cleanup for the previous `count` value.\n- `Effect: Setup for count 1` runs for the new `count` value (1).\n- Similar to mount, cleanup and setup run again to simulate re-execution (`Effect: Cleanup for count 1` then `Effect: Setup for count 1`).\n\n**3. Without `React.StrictMode` (on initial mount):**\n```\nRender: count 0\nEffect: Setup for count 0\n```\n**Explanation:**\n- `Render: count 0` appears once.\n- `Effect: Setup for count 0` runs once for the initial mount.\n\n**4. Without `React.StrictMode` (after clicking increment button once, `count` becomes 1):**\n```\nRender: count 1\nEffect: Cleanup for count 0\nEffect: Setup for count 1\n```\n**Explanation:**\n- `Render: count 1` appears once.\n- `Effect: Cleanup for count 0` runs when `count` changes from 0 to 1.\n- `Effect: Setup for count 1` runs for the new `count` value.\n",
          "tags": [
            "React",
            "StrictMode",
            "useEffect",
            "Debugging",
            "Side Effects"
          ],
          "prerequisites": [
            "React_Hooks_useEffect",
            "React_Component_Lifecycle"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_error_boundary_1",
          "topic": "React Error Boundaries",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary function of a React Error Boundary?",
          "answer": "To catch JavaScript errors in its child component tree, log them, and display a fallback UI instead of crashing the entire application.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Error Boundary",
            "Error Handling",
            "Fallback UI"
          ],
          "evaluationCriteria": [
            "Basic definition of Error Boundary"
          ],
          "example": "",
          "tags": [
            "React",
            "Error Handling",
            "Error Boundaries"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_2",
          "topic": "React Error Boundaries",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following lifecycle methods are essential for creating a React Error Boundary?",
          "answer": "static getDerivedStateFromError and componentDidCatch",
          "options": [
            "componentDidMount and componentWillUnmount",
            "render and componentDidUpdate",
            "static getDerivedStateFromError and componentDidCatch",
            "constructor and shouldComponentUpdate"
          ],
          "analysisPoints": [
            "`getDerivedStateFromError` is for updating state for fallback UI.",
            "`componentDidCatch` is for logging errors and side effects.",
            "Other options are standard lifecycle methods but not specific to error boundaries."
          ],
          "keyConcepts": [
            "Error Boundary",
            "Lifecycle Methods",
            "getDerivedStateFromError",
            "componentDidCatch"
          ],
          "evaluationCriteria": [
            "Knowledge of Error Boundary specific lifecycle methods.",
            "Distinguishing relevant from irrelevant lifecycle methods for this purpose."
          ],
          "example": "The `static getDerivedStateFromError` method is responsible for returning a new state object that will trigger a re-render of the error boundary with its fallback UI. The `componentDidCatch` method is used for side effects, such as sending error reports to an analytics service.",
          "tags": [
            "React",
            "Error Boundaries",
            "Lifecycle Methods"
          ],
          "prerequisites": [
            "React_Class_Components",
            "React_Lifecycle_Methods"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_3",
          "topic": "React Error Boundaries",
          "level": "medium",
          "type": "open",
          "question": "Describe the distinct roles of `static getDerivedStateFromError(error)` and `componentDidCatch(error, info)` within an error boundary. When would you use each?",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Explain `getDerivedStateFromError`'s role: to update state to trigger re-render of fallback UI, it's static and returns state object.",
            "Explain `componentDidCatch`'s role: for side effects like logging errors to external services, it receives `error` and `info`.",
            "Provide clear use cases for each method."
          ],
          "keyConcepts": [
            "Error Boundary",
            "getDerivedStateFromError",
            "componentDidCatch",
            "State Update",
            "Side Effects",
            "Error Logging"
          ],
          "evaluationCriteria": [
            "Accurate distinction between the two methods' purposes.",
            "Correct understanding of their parameters and return values (for `getDerivedStateFromError`).",
            "Practical use case examples."
          ],
          "example": "The `static getDerivedStateFromError(error)` method is a static lifecycle method called after an error is thrown. Its sole purpose is to return a state update object (`{ hasError: true }`) that will be used to re-render the Error Boundary's UI, typically displaying a fallback message. It should be a pure function and should not cause side effects.\n\nConversely, `componentDidCatch(error, info)` is a non-static lifecycle method that is called after an error has been thrown and allows for side effects. It's the ideal place to log error information to an external service (e.g., Sentry, Bugsnag) using `console.error` or an API call. It receives the `error` object and an `info` object containing the `componentStack`, which is useful for debugging.\n\nIn summary, `getDerivedStateFromError` is for **rendering fallback UI**, while `componentDidCatch` is for **logging errors and other side effects**.",
          "tags": [
            "React",
            "Error Boundaries",
            "Lifecycle Methods"
          ],
          "prerequisites": [
            "React_Class_Components",
            "React_Lifecycle_Methods"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_4",
          "topic": "React Error Boundaries",
          "level": "hard",
          "type": "mcq",
          "question": "Which of the following scenarios is **NOT** typically caught by a React Error Boundary?",
          "answer": "An error thrown inside an event handler (e.g., `onClick`).",
          "options": [
            "An error thrown during a component's render method.",
            "An error thrown inside `componentDidMount`.",
            "An error thrown inside `static getDerivedStateFromError`.",
            "An error thrown inside an event handler (e.g., `onClick`)."
          ],
          "analysisPoints": [
            "Error Boundaries specifically catch errors in render, lifecycle methods, and constructors of child components.",
            "They do not catch errors in event handlers because event handlers are not part of the rendering pipeline. These errors bubble up through the browser's event system.",
            "Errors in `static getDerivedStateFromError` would mean the boundary itself failed, which it cannot catch."
          ],
          "keyConcepts": [
            "Error Boundary Limitations",
            "Error Handling Scope",
            "Event Handlers"
          ],
          "evaluationCriteria": [
            "In-depth understanding of what error boundaries cover and what they don't.",
            "Ability to differentiate error types and their handling mechanisms."
          ],
          "example": "React Error Boundaries are designed to protect the rendering process. Errors in event handlers do not fall under this category as they are synchronous calls outside of React's rendering phase. Such errors can and should be caught using standard JavaScript `try...catch` blocks within the event handler function itself if specific error handling is needed for that interaction.",
          "tags": [
            "React",
            "Error Boundaries",
            "Limitations",
            "Event Handling"
          ],
          "prerequisites": [
            "React_Error_Handling",
            "JavaScript_Error_Handling"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_error_boundary_5",
          "topic": "React Error Boundaries",
          "level": "easy",
          "type": "flashcard",
          "question": "Can a functional component be an Error Boundary?",
          "answer": "No, Error Boundaries must be class components because they need to implement lifecycle methods like `static getDerivedStateFromError` or `componentDidCatch`.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "Error Boundary",
            "Class Components",
            "Functional Components",
            "Lifecycle Methods"
          ],
          "evaluationCriteria": [
            "Basic knowledge of Error Boundary requirements"
          ],
          "example": "",
          "tags": [
            "React",
            "Error Boundaries",
            "Functional Components",
            "Class Components"
          ],
          "prerequisites": [
            "React_Components"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_error_boundary_6",
          "topic": "React Error Boundaries",
          "level": "medium",
          "type": "code",
          "question": "Given the `BuggyComponent` below, write an `App` component that uses an `ErrorBoundary` (provided) to prevent the entire application from crashing when `BuggyComponent` throws an error. Demonstrate what happens when the error is thrown.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly wraps `BuggyComponent` with `ErrorBoundary`.",
            "Demonstrates the effect of the error boundary catching the error.",
            "Shows how other parts of the application remain functional.",
            "The provided `ErrorBoundary` class is correctly utilized."
          ],
          "keyConcepts": [
            "Error Boundary Usage",
            "Fallback UI",
            "Component Isolation"
          ],
          "evaluationCriteria": [
            "Ability to apply Error Boundary correctly.",
            "Understanding of localized error handling.",
            "Functional code example."
          ],
          "example": "```typescript\nimport React from 'react';\n\n// Assume ErrorBoundary is provided like so:\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    console.error(\"Error caught by boundary:\", error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1>Oops! Something went wrong in this section.</h1>;\n    }\n    return this.props.children;\n  }\n}\n\n// Component that might throw an error\nfunction BuggyComponent({ throwError }) {\n  if (throwError) {\n    throw new Error('This component crashed!');\n  }\n  return <p>I am a stable component.</p>;\n}\n\n// Your task is to complete the App component:\nfunction App() {\n  const [shouldCrash, setShouldCrash] = React.useState(false);\n\n  return (\n    <div>\n      <h1>Application Header</h1>\n      <button onClick={() => setShouldCrash(true)}>\n        Trigger Crash in Buggy Section\n      </button>\n      <hr />\n\n      <ErrorBoundary>\n        {/* This is the section where the error will be caught */}\n        <h2>Buggy Section:</h2>\n        <BuggyComponent throwError={shouldCrash} />\n      </ErrorBoundary>\n\n      <hr />\n      <h2>Normal Section:</h2>\n      <p>This part of the application remains functional.</p>\n      <button onClick={() => console.log('Normal section button clicked')}>\n        Click Me\n      </button>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n**Explanation:**\nWhen the 'Trigger Crash in Buggy Section' button is clicked, `shouldCrash` becomes true, causing `BuggyComponent` to throw an error during its render. The `ErrorBoundary` component, which wraps `BuggyComponent`, catches this error. Instead of crashing the entire application, the `ErrorBoundary` displays its fallback UI ('Oops! Something went wrong in this section.'). The 'Normal Section' of the application remains fully interactive and functional, demonstrating the isolation provided by error boundaries.",
          "tags": [
            "React",
            "Error Boundaries",
            "Debugging",
            "Error Handling"
          ],
          "prerequisites": [
            "React_Class_Components",
            "React_State_Hooks"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_router_1",
          "topic": "React Router v5 vs v6",
          "level": "easy",
          "type": "flashcard",
          "question": "In React Router v6, which component replaces `Switch` from v5?",
          "answer": "`Routes`",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Router",
            "Routes",
            "Switch"
          ],
          "evaluationCriteria": [
            "Basic knowledge of React Router version differences"
          ],
          "example": "",
          "tags": [
            "React Router",
            "v6",
            "v5",
            "Routing"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_router_2",
          "topic": "React Router v5 vs v6",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is the correct way to render a component for a route in React Router v6?",
          "answer": "`<Route path=\"/home\" element={<HomePage />} />`",
          "options": [
            "`<Route path=\"/home\" component={HomePage} />`",
            "`<Route path=\"/home\" render={HomePage} />`",
            "`<Route path=\"/home\" element={HomePage} />`",
            "`<Route path=\"/home\" element={<HomePage />} />`"
          ],
          "analysisPoints": [
            "v6 uses `element` prop.",
            "The `element` prop expects a React element (JSX), not just a component reference.",
            "Options A and B are from v5.",
            "Option C passes the component reference, not a React element."
          ],
          "keyConcepts": [
            "React Router v6",
            "Route Props",
            "element prop"
          ],
          "evaluationCriteria": [
            "Understanding of v6 API changes.",
            "Correct syntax for rendering components in routes."
          ],
          "example": "In React Router v6, the `element` prop is used to pass a React element (JSX) to be rendered when the route matches. This allows for passing props directly to the component, unlike the `component` prop in v5 which implicitly received routing props.",
          "tags": [
            "React Router",
            "v6",
            "Routing Syntax"
          ],
          "prerequisites": [
            "React_Basics",
            "React_Router_Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_router_3",
          "topic": "React Router v5 vs v6",
          "level": "medium",
          "type": "open",
          "question": "Explain why the `exact` prop is no longer needed in React Router v6, and how v6 handles route matching differently from v5's `Switch` component.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Explain that v5's `exact` prop was needed to prevent partial matches with `Switch`.",
            "Describe v6's `Routes` component's matching algorithm (specificity, ranking, best match).",
            "Contrast v5's 'first match wins' with v6's 'best match wins'.",
            "Mention how v6 handles `/` path differently (only matches exactly `/`)."
          ],
          "keyConcepts": [
            "React Router v6",
            "exact prop",
            "Routes vs Switch",
            "Route Matching",
            "Specificity"
          ],
          "evaluationCriteria": [
            "Clear explanation of `exact` deprecation.",
            "Accurate description of v6's route matching logic.",
            "Effective comparison between v5 and v6 approaches."
          ],
          "example": "In React Router v5, the `<Switch>` component would render the *first* `<Route>` that partially or exactly matched the current URL. This made the `exact` prop crucial for paths like `/` to prevent them from also matching `/about` or `/users`. Without `exact`, `/` would always match first, blocking other routes.\n\nReact Router v6 replaces `<Switch>` with `<Routes>`. The `Routes` component uses a smarter, more sophisticated ranking algorithm to determine the *best* match among its children, regardless of their order. It prioritizes more specific routes over less specific ones. For example, a route for `/users/:id` is considered more specific than `/users`. As a result, the `exact` prop becomes redundant because v6 inherently handles precise matching based on path specificity, making the routing configuration more intuitive and less prone to unexpected matches.",
          "tags": [
            "React Router",
            "v6",
            "Route Matching",
            "exact prop"
          ],
          "prerequisites": [
            "React_Router_Basics"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_router_4",
          "topic": "React Router v6",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the purpose of the `<Outlet />` component in React Router v6?",
          "answer": "The `<Outlet />` component is used within a parent route's element to render the matched child route's element, enabling nested layouts and routing.",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Router v6",
            "Outlet",
            "Nested Routing",
            "Layouts"
          ],
          "evaluationCriteria": [
            "Understanding of nested routing mechanics"
          ],
          "example": "",
          "tags": [
            "React Router",
            "v6",
            "Nested Routing"
          ],
          "prerequisites": [
            "React_Router_v6_Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_router_5",
          "topic": "React Router v6",
          "level": "medium",
          "type": "code",
          "question": "You have a component rendered at `/dashboard`. You want to navigate to `/dashboard/settings` programmatically when a button is clicked. How would you achieve this using a React Router v6 hook? Provide a code snippet.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly identifies and uses the `useNavigate` hook.",
            "Demonstrates programmatic navigation.",
            "Uses a relative path for navigation to `settings` from `dashboard`.",
            "Includes a button click handler for triggering navigation."
          ],
          "keyConcepts": [
            "React Router v6",
            "useNavigate Hook",
            "Programmatic Navigation",
            "Relative Paths"
          ],
          "evaluationCriteria": [
            "Correct application of `useNavigate`.",
            "Understanding of relative path navigation.",
            "Functional code example."
          ],
          "example": "```typescript\nimport React from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nfunction DashboardSettingsButton() {\n  const navigate = useNavigate();\n\n  const goToSettings = () => {\n    // Using a relative path 'settings' from the current route (/dashboard)\n    // This will navigate to /dashboard/settings\n    navigate('settings'); \n  };\n\n  return (\n    <div>\n      <h3>Dashboard Content</h3>\n      <button onClick={goToSettings}>Go to Settings</button>\n    </div>\n  );\n}\n\n// Example of how this might be used in a route setup:\n// <Route path=\"/dashboard\" element={<DashboardLayout />}> \n//   <Route index element={<DashboardHome />} />\n//   <Route path=\"settings\" element={<DashboardSettingsButton />} />\n// </Route>\n```\n**Explanation:**\nThe `useNavigate` hook provides a function (`navigate`) that allows you to change the current URL programmatically. When called with a string, it will push a new entry onto the history stack. In this example, `navigate('settings')` is a relative path. If the current URL is `/dashboard`, it will navigate to `/dashboard/settings`. This is particularly useful for building flexible and maintainable nested navigation within your application.",
          "tags": [
            "React Router",
            "v6",
            "Hooks",
            "Navigation",
            "Programmatic"
          ],
          "prerequisites": [
            "React_Hooks",
            "React_Router_Basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_router_6",
          "topic": "React Router v6",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is **NOT** a new feature or significant change introduced in React Router v6 compared to v5?",
          "answer": "The primary routing mechanism using HTML5 History API (`BrowserRouter`).",
          "options": [
            "The primary routing mechanism using HTML5 History API (`BrowserRouter`).",
            "Introduction of `useRoutes` hook for defining routes as objects.",
            "Relative routes and links are supported by default.",
            "Route path patterns are more robust and flexible, supporting optional segments."
          ],
          "analysisPoints": [
            "`BrowserRouter` (using HTML5 History API) has been a core mechanism in both v5 and v6, so it's not a *new* feature of v6.",
            "`useRoutes`, relative paths, and enhanced path patterns are distinct new features/changes in v6."
          ],
          "keyConcepts": [
            "React Router v6",
            "React Router v5",
            "New Features",
            "BrowserRouter"
          ],
          "evaluationCriteria": [
            "Ability to distinguish core, long-standing features from new version-specific features.",
            "Comprehensive knowledge of v6 advancements."
          ],
          "example": "While `BrowserRouter` is fundamental to React Router, its underlying mechanism using the HTML5 History API has been consistent across major versions. The other options represent significant advancements and new API paradigms that differentiate v6 from v5, making routing more declarative, flexible, and hooks-friendly.",
          "tags": [
            "React Router",
            "v6",
            "Differences",
            "Features"
          ],
          "prerequisites": [
            "React_Router_Version_History"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_router_7",
          "topic": "React Router v6",
          "level": "hard",
          "type": "code",
          "question": "You are building a user profile section using React Router v6. Implement a setup where `'/users'` displays a list of users, and `'/users/:userId'` displays details for a specific user. The user details component should be nested within the users component using an `<Outlet />`. Also, create a link that navigates to `/users/123` from the user list. Assume `UserList` and `UserDetails` components exist.",
          "answer": "",
          "options": [],
          "analysisPoints": [
            "Correctly uses `<BrowserRouter>` and `<Routes>`.",
            "Sets up a parent route for `/users`.",
            "Defines a nested route `':userId'` within the parent `/users` route.",
            "Includes `<Outlet />` in the `UserList` component to render nested `UserDetails`.",
            "Uses `<Link>` to navigate to a specific user ID.",
            "Demonstrates understanding of nested routing in v6.",
            "Assumes valid functional components for UserList and UserDetails."
          ],
          "keyConcepts": [
            "React Router v6",
            "Nested Routing",
            "Outlet",
            "Path Params",
            "Link"
          ],
          "evaluationCriteria": [
            "Ability to construct a complex nested routing structure.",
            "Correct usage of `Outlet` and `Link`.",
            "Demonstrates practical application of v6 features."
          ],
          "example": "```typescript\nimport React from 'react';\nimport { BrowserRouter, Routes, Route, Link, Outlet, useParams } from 'react-router-dom';\n\nfunction UserList() {\n  // In a real app, you'd fetch users here\n  const users = [\n    { id: '101', name: 'Alice' },\n    { id: '102', name: 'Bob' },\n    { id: '103', name: 'Charlie' }\n  ];\n\n  return (\n    <div>\n      <h2>User List</h2>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>\n            <Link to={user.id}>{user.name}</Link>\n          </li>\n        ))}\n      </ul>\n      <Link to=\"123\">Go to User 123 (Example Link)</Link>\n      <hr/>\n      {/* This is where the nested route content will be rendered */}\n      <Outlet /> \n    </div>\n  );\n}\n\nfunction UserDetails() {\n  const { userId } = useParams();\n  return (\n    <div>\n      <h3>Details for User ID: {userId}</h3>\n      <p>This is where details for user {userId} would be displayed.</p>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <h1>User Management App</h1>\n      <Routes>\n        <Route path=\"/\" element={<h2>Welcome!</h2>} />\n        <Route path=\"/users\" element={<UserList />}> {/* Parent route */}\n          {/* Nested route: matches /users/:userId */}\n          <Route path=\":userId\" element={<UserDetails />} /> \n          {/* Optional: Default content for /users if no child route matches */}\n          <Route index element={<h4>Select a user to view details.</h4>} />\n        </Route>\n        <Route path=\"*\" element={<h2>404 - Page Not Found</h2>} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n```\n\n**Explanation:**\n- `BrowserRouter` sets up the history API for routing.\n- The first `Route` is for the home page.\n- The `'/users'` `Route` renders `UserList`. Critically, it has a child `Route` with `path=\":userId\"`.\n- `UserList` component contains an `<Outlet />`. When the URL matches `/users/101`, `UserList` renders, and then `UserDetails` (for `userId=101`) is rendered *inside* the `UserList` component at the position of the `<Outlet />`.\n- The `Link to={user.id}` within `UserList` uses a relative path, seamlessly navigating to `/users/101`, `/users/102`, etc., making the nesting intuitive. The example link `to=\"123\"` demonstrates navigating to a hardcoded user ID.\n",
          "tags": [
            "React Router",
            "v6",
            "Nested Routing",
            "Hooks",
            "SPA",
            "Advanced Routing"
          ],
          "prerequisites": [
            "React_Components",
            "React_Hooks_Basics"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_router_8",
          "topic": "React Router v6",
          "level": "easy",
          "type": "flashcard",
          "question": "Which React Router v6 hook would you use to get URL parameters like `:id` from a route path `/users/:id`?",
          "answer": "`useParams()`",
          "options": [],
          "analysisPoints": [],
          "keyConcepts": [
            "React Router v6",
            "useParams",
            "URL Parameters"
          ],
          "evaluationCriteria": [
            "Knowledge of common React Router hooks"
          ],
          "example": "",
          "tags": [
            "React Router",
            "v6",
            "Hooks"
          ],
          "prerequisites": [
            "React_Hooks_Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_strict_mode_1",
          "title": "Demonstrate StrictMode Side Effect Detection",
          "description": "\nImplement a React functional component `MyCounter` that uses `useState` and `useEffect`.\n\n**Requirements:**\n1.  The component should have a counter state that increments on a button click.\n2.  Inside a `useEffect` that runs on mount and whenever the counter changes, log a message to the console. Make sure this effect has a cleanup function that also logs a message.\n3.  Wrap `MyCounter` in `React.StrictMode` in your `App` component.\n4.  Observe the console logs when the `App` mounts and when the increment button is clicked. Explain the difference in console output with and without `StrictMode`.\n\nYour goal is to clearly show how `StrictMode`'s double-invocation affects the `useEffect` lifecycle.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom/client';\n\nfunction MyCounter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    // TODO: Add setup log here\n    console.log(`Effect: Setup for count ${count}`);\n\n    return () => {\n      // TODO: Add cleanup log here\n      console.log(`Effect: Cleanup for count ${count}`);\n    };\n  }, [count]);\n\n  // TODO: Add render log here\n  console.log(`Render: count ${count}`);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(prevCount => prevCount + 1)}>Increment</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    // TODO: Wrap MyCounter in StrictMode\n    <React.StrictMode>\n      <MyCounter />\n    </React.StrictMode>\n  );\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom/client';\n\nfunction MyCounter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log(`Effect: Setup for count ${count}`);\n\n    return () => {\n      console.log(`Effect: Cleanup for count ${count}`);\n    };\n  }, [count]);\n\n  console.log(`Render: count ${count}`);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(prevCount => prevCount + 1)}>Increment</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <React.StrictMode>\n      <MyCounter />\n    </React.StrictMode>\n  );\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n\n/*\nExpected Console Output with StrictMode:\n\nOn initial mount:\nRender: count 0\nRender: count 0\nEffect: Setup for count 0\nEffect: Cleanup for count 0\nEffect: Setup for count 0\n\nAfter clicking Increment button once (count becomes 1):\nRender: count 1\nRender: count 1\nEffect: Cleanup for count 0\nEffect: Setup for count 1\nEffect: Cleanup for count 1\nEffect: Setup for count 1\n\nExpected Console Output without StrictMode (if you comment out <React.StrictMode>):\n\nOn initial mount:\nRender: count 0\nEffect: Setup for count 0\n\nAfter clicking Increment button once (count becomes 1):\nRender: count 1\nEffect: Cleanup for count 0\nEffect: Setup for count 1\n*/\n",
          "testCases": [
            "Verify `Render` message appears twice on initial mount in StrictMode.",
            "Verify `Effect: Setup` and `Effect: Cleanup` logs appear twice (setup, cleanup, setup) on initial mount in StrictMode.",
            "Verify `Render` message appears twice on state update in StrictMode.",
            "Verify `Effect: Cleanup` for old state and `Effect: Setup` for new state appear twice (cleanup_old, setup_new, cleanup_new, setup_new) on state update in StrictMode.",
            "Describe console output differences if `StrictMode` is removed."
          ],
          "hints": [
            "Remember that `StrictMode` specifically double-invokes render methods, `useState` updater functions, and `useEffect` setup/cleanup functions.",
            "Pay close attention to the order of logs, especially the cleanup and setup for `useEffect`.",
            "The logs will help you visualize the 'simulated remounting' behavior."
          ],
          "tags": [
            "React",
            "StrictMode",
            "Hooks",
            "Debugging",
            "Side Effects",
            "Development"
          ],
          "timeEstimate": 40,
          "prerequisites": [
            "React_Hooks_useState",
            "React_Hooks_useEffect"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Pure_Components",
            "Idempotent_Operations"
          ]
        },
        {
          "id": "task_error_boundary_1",
          "title": "Implement a Generic Error Boundary and Test It",
          "description": "\nImplement a reusable `ErrorBoundary` class component and demonstrate its usage by wrapping a 'buggy' child component that throws an error.\n\n**Requirements:**\n1.  Create a `ErrorBoundary` class component that implements `static getDerivedStateFromError` to update its state (`hasError`) and `componentDidCatch` to log the error to the console.\n2.  When `hasError` is `true`, the `ErrorBoundary` should render a simple fallback UI (e.g., `<h1>Something went wrong.</h1>`). Otherwise, it should render its children.\n3.  Create a functional component `CrashingComponent` that takes a `shouldCrash` prop. If `shouldCrash` is true, it should throw an error during its render phase.\n4.  In your `App` component, render `CrashingComponent` wrapped by `ErrorBoundary`.\n5.  Add a button in `App` that, when clicked, sets the `shouldCrash` prop to `true`, triggering the error.\n6.  Include another simple component (e.g., `NormalComponent`) *outside* the `ErrorBoundary` to demonstrate that the rest of the application remains functional.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom/client';\n\n// TODO: Implement ErrorBoundary class component\nclass ErrorBoundary extends React.Component {\n  // constructor\n  // static getDerivedStateFromError\n  // componentDidCatch\n  // render\n}\n\nfunction CrashingComponent({ shouldCrash }) {\n  if (shouldCrash) {\n    // TODO: Throw an error here\n    throw new Error('CrashingComponent failed!');\n  }\n  return <p>I am a stable component (for now).</p>;\n}\n\nfunction NormalComponent() {\n  return <p>I am a normal component, always working.</p>;\n}\n\nfunction App() {\n  const [triggerCrash, setTriggerCrash] = useState(false);\n\n  return (\n    <div>\n      <h1>Error Boundary Demo</h1>\n      <button onClick={() => setTriggerCrash(true)}>\n        Trigger Error in Crashing Component\n      </button>\n      <hr />\n\n      {/* TODO: Wrap CrashingComponent with ErrorBoundary */}\n      <div>\n        <h2>Wrapped Component:</h2>\n        <CrashingComponent shouldCrash={triggerCrash} />\n      </div>\n\n      <hr />\n      <h2>Unwrapped Component:</h2>\n      <NormalComponent />\n    </div>\n  );\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom/client';\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state to display fallback UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    // Log the error to an error reporting service\n    console.error(\"Error caught by boundary:\", error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children;\n  }\n}\n\nfunction CrashingComponent({ shouldCrash }) {\n  if (shouldCrash) {\n    throw new Error('CrashingComponent failed!');\n  }\n  return <p>I am a stable component (for now).</p>;\n}\n\nfunction NormalComponent() {\n  return <p>I am a normal component, always working.</p>;\n}\n\nfunction App() {\n  const [triggerCrash, setTriggerCrash] = useState(false);\n\n  return (\n    <div>\n      <h1>Error Boundary Demo</h1>\n      <button onClick={() => setTriggerCrash(true)}>\n        Trigger Error in Crashing Component\n      </button>\n      <hr />\n\n      <ErrorBoundary>\n        <h2>Wrapped Component:</h2>\n        <CrashingComponent shouldCrash={triggerCrash} />\n      </ErrorBoundary>\n\n      <hr />\n      <h2>Unwrapped Component:</h2>\n      <NormalComponent />\n    </div>\n  );\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n",
          "testCases": [
            "Initial render: `CrashingComponent` should display its default message, `NormalComponent` should display its message.",
            "Clicking the 'Trigger Error' button: `CrashingComponent` should be replaced by `ErrorBoundary`'s fallback UI ('Something went wrong.').",
            "Clicking the 'Trigger Error' button: An error message should be logged to the console by `componentDidCatch`.",
            "Clicking the 'Trigger Error' button: `NormalComponent` should remain visible and functional, demonstrating isolation.",
            "Attempt to throw an error in `ErrorBoundary`'s render: Verify that the application crashes (as expected, error boundaries cannot catch errors within themselves)."
          ],
          "hints": [
            "Remember that `getDerivedStateFromError` is `static` and only returns state updates, while `componentDidCatch` is for side effects like logging.",
            "Errors thrown in event handlers are *not* caught by error boundaries. Ensure `CrashingComponent` throws the error during render for the boundary to catch it.",
            "Use `console.error` in `componentDidCatch` to see the error details in your browser's console."
          ],
          "tags": [
            "React",
            "Error Handling",
            "Error Boundaries",
            "Class Components",
            "Debugging"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React_Class_Components",
            "React_State",
            "React_Lifecycle_Methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Fallback_UI",
            "Component_Isolation"
          ]
        },
        {
          "id": "task_react_router_1",
          "title": "Build a Simple Blog with Nested React Router v6",
          "description": "\nCreate a multi-page application for a simple blog using React Router v6. It should include a home page, an 'about' page, a main blog posts list, and nested individual post detail pages.\n\n**Requirements:**\n1.  Set up `BrowserRouter` and `Routes` in your main `App` component.\n2.  Define the following routes:\n    -   `/`: Home Page (`HomePage` component)\n    -   `/about`: About Page (`AboutPage` component)\n    -   `/posts`: Blog Posts List (`PostsLayout` component which contains `<Outlet />`)\n    -   `/posts/:postId`: Individual Post Details (`PostDetails` component, nested under `/posts`)\n3.  Create simple functional components for `HomePage`, `AboutPage`, `PostsLayout`, and `PostDetails`.\n4.  `PostsLayout` should display a list of dummy blog posts (e.g., using `Link` components) and also contain an `<Outlet />` to render the `PostDetails` component.\n5.  `PostDetails` should use `useParams()` to display the `postId` from the URL.\n6.  Include a basic navigation menu at the top of the `App` component with `Link` components to Home, About, and Posts.\n7.  Add a 404 Not Found route (`*`) with a `NotFoundPage` component.\n",
          "difficulty": "hard",
          "startingCode": "import React from 'react';\nimport { BrowserRouter, Routes, Route, Link, Outlet, useParams } from 'react-router-dom';\nimport ReactDOM from 'react-dom/client';\n\n// TODO: Create HomePage, AboutPage, PostsLayout, PostDetails, NotFoundPage components\n// Example structure:\nfunction HomePage() {\n  return <h2>Welcome to the Blog!</h2>;\n}\n\nfunction AboutPage() {\n  return <h2>About Us</h2>;\n}\n\nfunction PostsLayout() {\n  // Dummy posts data\n  const posts = [\n    { id: '1', title: 'First Blog Post' },\n    { id: '2', title: 'Second Blog Post' },\n  ];\n\n  return (\n    <div>\n      <h2>Blog Posts</h2>\n      <ul>\n        {posts.map(post => (\n          <li key={post.id}>\n            {/* TODO: Add Link to individual post */}\n            <Link to={post.id}>{post.title}</Link>\n          </li>\n        ))}\n      </ul>\n      <hr />\n      {/* TODO: Add Outlet for nested routes */}\n    </div>\n  );\n}\n\nfunction PostDetails() {\n  // TODO: Get postId from URL params and display it\n  const { postId } = useParams();\n  return <h3>Details for Post: {postId}</h3>;\n}\n\nfunction NotFoundPage() {\n  return <h2>404 - Page Not Found</h2>;\n}\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <nav>\n        {/* TODO: Add navigation links */}\n        <Link to=\"/\">Home</Link> | \n        <Link to=\"/about\">About</Link> | \n        <Link to=\"/posts\">Posts</Link>\n      </nav>\n\n      {/* TODO: Define Routes */}\n      <Routes>\n        {/* Home Route */}\n        {/* About Route */}\n        {/* Posts Parent Route with nested PostDetails */}\n        {/* 404 Route */}\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n",
          "solutionCode": "import React from 'react';\nimport { BrowserRouter, Routes, Route, Link, Outlet, useParams } from 'react-router-dom';\nimport ReactDOM from 'react-dom/client';\n\nfunction HomePage() {\n  return <h2>Welcome to the Blog!</h2>;\n}\n\nfunction AboutPage() {\n  return <h2>About Us</h2>;\n}\n\nfunction PostsLayout() {\n  const posts = [\n    { id: '1', title: 'First Blog Post' },\n    { id: '2', title: 'Second Blog Post' },\n    { id: '3', title: 'Third Blog Post' },\n  ];\n\n  return (\n    <div>\n      <h2>Blog Posts</h2>\n      <ul>\n        {posts.map(post => (\n          <li key={post.id}>\n            <Link to={post.id}>{post.title}</Link>\n          </li>\n        ))}\n      </ul>\n      <hr />\n      {/* This is where the nested route content will be rendered */}\n      <Outlet /> \n    </div>\n  );\n}\n\nfunction PostDetails() {\n  const { postId } = useParams();\n  return (\n    <div>\n      <h3>Details for Post: {postId}</h3>\n      <p>This is the full content for post #{postId}.</p>\n    </div>\n  );\n}\n\nfunction NotFoundPage() {\n  return <h2>404 - Page Not Found</h2>;\n}\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <nav style={{ padding: '10px 0', borderBottom: '1px solid #ccc' }}>\n        <Link to=\"/\" style={{ margin: '0 10px' }}>Home</Link> \n        <Link to=\"/about\" style={{ margin: '0 10px' }}>About</Link> \n        <Link to=\"/posts\" style={{ margin: '0 10px' }}>Posts</Link>\n      </nav>\n      <div style={{ padding: '20px' }}>\n        <Routes>\n          <Route path=\"/\" element={<HomePage />} />\n          <Route path=\"/about\" element={<AboutPage />} />\n          \n          {/* Parent route for blog posts */}\n          <Route path=\"/posts\" element={<PostsLayout />}>\n            {/* Nested route for individual post details */}\n            <Route path=\":postId\" element={<PostDetails />} />\n            {/* Optional: default content when only /posts is matched */}\n            <Route index element={<h4>Select a post to read details.</h4>} />\n          </Route>\n          \n          {/* 404 Not Found route */}\n          <Route path=\"*\" element={<NotFoundPage />} />\n        </Routes>\n      </div>\n    </BrowserRouter>\n  );\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<App />);\n",
          "testCases": [
            "Navigate to `/`: Expect `HomePage` to render.",
            "Navigate to `/about`: Expect `AboutPage` to render.",
            "Navigate to `/posts`: Expect `PostsLayout` to render with the list of posts and 'Select a post to read details.' message.",
            "Click on a post link (e.g., 'First Blog Post'): Expect the URL to become `/posts/1` and `PostDetails` to render with 'Details for Post: 1' below the list of posts.",
            "Manually navigate to `/posts/999`: Expect `PostDetails` to render with 'Details for Post: 999'.",
            "Navigate to `/non-existent-path`: Expect `NotFoundPage` to render ('404 - Page Not Found')."
          ],
          "hints": [
            "Remember that `<Routes>` is the container for all `Route` elements in v6.",
            "For nested routes, the parent `Route` uses its `element` prop to define the layout component (e.g., `PostsLayout`), and this layout component must include an `<Outlet />` where its child routes will render.",
            "Dynamic segments in routes are defined with a colon, e.g., `:postId`.",
            "`useParams()` is the hook to extract these dynamic segments.",
            "Relative links work seamlessly in nested contexts; for example, from `/posts`, a `Link to=\"1\"` will lead to `/posts/1`."
          ],
          "tags": [
            "React Router",
            "v6",
            "Routing",
            "Nested Routing",
            "Hooks",
            "SPA",
            "Frontend"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React_Components",
            "React_Hooks_Basics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "SPA_Architecture",
            "Declarative_Routing",
            "URL_Parameters"
          ]
        }
      ]
    }
  },
  {
    "id": "950c4a88-f279-4690-8ffd-642c55c97fdb",
    "startLine": 6200,
    "endLine": 6299,
    "processedDate": "2025-06-17T09:53:48.601Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_react_router_v6_navigation",
          "title": "React Router v6 Navigation Essentials",
          "content": "React Router v6 introduces streamlined APIs for navigation, moving away from some older concepts in v5. The core components for navigation remain `Link` and `NavLink`, while programmatic navigation is handled exclusively via the `useNavigate` hook.\n\n## Key Components and Hooks:\n\n### 1. `Link` Component\n- The `Link` component is the primary way to enable client-side navigation within a React application.\n- It renders an `<a>` tag in the DOM, but it prevents the default browser behavior of a full page reload.\n- Instead of reloading, it uses React Router to update the URL and render the corresponding component without a full page refresh, making the user experience faster and smoother.\n- **Usage:** `<Link to=\"/path\">Link Text</Link>`\n\n### 2. `NavLink` Component\n- `NavLink` is a special version of `Link` that is designed to add styling attributes to the rendered element when it matches the current URL.\n- This is particularly useful for navigation menus where you want to highlight the currently active link.\n- **Active Styling in v6:** Unlike `v5`'s `activeClassName`, `NavLink` in `v6` uses a functional `style` or `className` prop to determine active status. This function receives an object `{ isActive: boolean }` as an argument.\n- **Usage (with functional style):**\n```jsx\n<NavLink to=\"/about\" style={({ isActive }) => isActive ? { fontWeight: 'bold', color: 'blue' } : undefined}>\n  About\n</NavLink>\n```\n- **Usage (with functional className):**\n```jsx\n<NavLink to=\"/dashboard\" className={({ isActive }) => isActive ? 'active-link' : ''}>\n  Dashboard\n</NavLink>\n```\n\n### 3. `useNavigate` Hook\n- The `useNavigate` hook is the recommended way to perform imperative or programmatic navigation in React Router v6.\n- It returns a function that allows you to navigate to different routes, replace entries in the history stack, or navigate relative to the current route.\n- It replaces the `useHistory` hook from v5.\n- **Basic Usage:** `navigate('/some/path')`\n- **Navigating Back/Forward:** `navigate(-1)` (back one step), `navigate(1)` (forward one step).\n- **Replacing History Entry:** `navigate('/some/path', { replace: true })` - This replaces the current entry in the history stack instead of adding a new one, useful for redirects after login.\n- **State Passing:** `navigate('/users/123', { state: { from: 'dashboard' } })` - You can pass state to the new location, which can be accessed via `useLocation().state`.\n\nThese tools provide a robust and flexible way to manage navigation in modern React applications using React Router v6.",
          "examples": [
            {
              "id": "example_v6_nav_1",
              "title": "Basic v6 Navigation Component",
              "code": "import { Link, NavLink, useNavigate } from 'react-router-dom';\n\nfunction NavigationV6() {\n  const navigate = useNavigate();\n\n  return (\n    <nav>\n      <ul>\n        <li><Link to=\"/\">Home</Link></li>\n        <li>\n          <NavLink \n            to=\"/about\" \n            style={({ isActive }) => \n              isActive ? { fontWeight: 'bold', color: 'darkred' } : undefined\n            }\n          >\n            About\n          </NavLink>\n        </li>\n        <li>\n          <button onClick={() => navigate('/contact')}>Contact Us</button>\n        </li>\n        <li>\n          <button onClick={() => navigate(-1)}>Go Back</button>\n        </li>\n      </ul>\n    </nav>\n  );\n}\n\n// To use this, you'd typically wrap your App component in a <BrowserRouter>\n// import { BrowserRouter, Routes, Route } from 'react-router-dom';\n// function App() {\n//   return (\n//     <BrowserRouter>\n//       <NavigationV6 />\n//       <Routes>\n//         <Route path=\"/\" element={<div>Home Page</div>} />\n//         <Route path=\"/about\" element={<div>About Page</div>} />\n//         <Route path=\"/contact\" element={<div>Contact Page</div>} />\n//       </Routes>\n//     </BrowserRouter>\n//   );\n// }\n",
              "explanation": "This example demonstrates a navigation bar using React Router v6 components. `Link` is used for basic navigation. `NavLink` shows how to apply dynamic styling based on the `isActive` state for the current route. A button uses `useNavigate` for programmatic redirection to the '/contact' route and also to go back one step in history.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_nav_v6_link_navlink_diff",
            "question_nav_v6_usenavigate_purpose",
            "question_nav_v6_functional_navlink_style",
            "question_nav_v6_navigate_replace",
            "question_nav_v6_mcq_navlink_styling"
          ],
          "relatedTasks": [
            "task_v6_dynamic_navbar"
          ],
          "tags": [
            "React Router",
            "v6",
            "Navigation",
            "Link",
            "NavLink",
            "useNavigate",
            "Hooks"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "React Hooks",
            "Client-Side Routing Concepts"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced Routing",
            "Authentication Flows",
            "Dynamic Navigation"
          ]
        },
        {
          "id": "theory_react_router_v5_navigation",
          "title": "React Router v5 Navigation Essentials (Legacy)",
          "content": "React Router v5 represented a stable version of the library, with similar concepts to v6 but distinct API differences, especially concerning programmatic navigation and active link styling. While v6 is now the standard, understanding v5 can be useful for maintaining older projects or understanding the evolution of the library.\n\n## Key Components and Hooks:\n\n### 1. `Link` Component\n- Identical in purpose to `v6`'s `Link`, it provides client-side navigation without full page reloads.\n- It renders an `<a>` tag.\n- **Usage:** `<Link to=\"/path\">Link Text</Link>`\n\n### 2. `NavLink` Component\n- Similar to `v6`'s `NavLink`, it applies styling to the active link.\n- **Active Styling in v5:** In `v5`, `NavLink` used the `activeClassName` prop to apply a CSS class when the link was active. It also had an `activeStyle` prop for inline styles.\n- **Usage (with `activeClassName`):**\n```jsx\n<NavLink to=\"/about\" activeClassName=\"active-link-style\">\n  About\n</NavLink>\n```\n- **Usage (with `activeStyle`):**\n```jsx\n<NavLink to=\"/dashboard\" activeStyle={{ fontWeight: 'bold' }}>\n  Dashboard\n</NavLink>\n```\n\n### 3. `useHistory` Hook\n- The `useHistory` hook was the primary way to access the history instance and perform imperative navigation in React Router v5.\n- It allowed pushing new entries onto the history stack (`history.push`), replacing entries (`history.replace`), and navigating back/forward (`history.goBack`, `history.goForward`).\n- **Usage:**\n```javascript\nconst history = useHistory();\nhistory.push('/some/path');\nhistory.goBack();\n```\n\n### 4. `withRouter` Higher-Order Component (HOC)\n- Before hooks, `withRouter` was used to inject `history`, `location`, and `match` props into a component that wasn't directly rendered by a `Route`.\n- With the advent of hooks like `useHistory`, `withRouter` became less common but is still found in older class components.\n\n**Note:** While understanding v5 is valuable, new projects should prioritize v6 due to its improved APIs and ongoing support.",
          "examples": [
            {
              "id": "example_v5_nav_1",
              "title": "Basic v5 Navigation Component",
              "code": "import { Link, NavLink, useHistory } from 'react-router-dom';\n\nfunction NavigationV5() {\n  const history = useHistory();\n\n  return (\n    <nav>\n      <ul>\n        <li><Link to=\"/\">Home</Link></li>\n        <li><NavLink to=\"/about\" activeClassName=\"v5-active-link\">About</NavLink></li>\n        <li><button onClick={() => history.push('/contact')}>Contact</button></li>\n      </ul>\n    </nav>\n  );\n}\n\n/*\n// To use this, you'd typically wrap your App component in a <BrowserRouter>\n// and define Routes using <Switch> and <Route> from 'react-router-dom' v5\n// Example structure:\n// import { BrowserRouter, Route, Switch } from 'react-router-dom';\n// function App() {\n//   return (\n//     <BrowserRouter>\n//       <NavigationV5 />\n//       <Switch>\n//         <Route path=\"/\" exact component={HomePage} />\n//         <Route path=\"/about\" component={AboutPage} />\n//         <Route path=\"/contact\" component={ContactPage} />\n//       </Switch>\n//     </BrowserRouter>\n//   );\n// }\n*/",
              "explanation": "This example showcases a navigation bar using React Router v5. `Link` provides basic client-side routing. `NavLink` uses `activeClassName` to apply a CSS class when the link is active. The `useHistory` hook is utilized for programmatic navigation when the 'Contact' button is clicked.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_nav_v5_v6_diff_navlink",
            "question_nav_v5_usehistory_purpose",
            "question_nav_v5_withrouter"
          ],
          "relatedTasks": [],
          "tags": [
            "React Router",
            "v5",
            "Legacy",
            "Navigation",
            "Link",
            "NavLink",
            "useHistory",
            "Hooks",
            "Deprecated"
          ],
          "technology": "React",
          "prerequisites": [
            "React Basics",
            "React Hooks",
            "Client-Side Routing Concepts"
          ],
          "complexity": 5,
          "interviewRelevance": 6,
          "learningPath": "intermediate",
          "requiredFor": [
            "Maintenance of Legacy Applications",
            "Understanding API Evolution"
          ]
        },
        {
          "id": "theory_programmatic_navigation",
          "title": "Programmatic and Declarative Navigation",
          "content": "Navigation in React Router can be achieved in two main ways: declaratively using components like `Link` or `NavLink`, and programmatically (or imperatively) using hooks or components for redirects.\n\n## Imperative Navigation (Hooks):\n\n### React Router v6: `useNavigate`\n- As discussed, `useNavigate` provides a function to navigate programmatically.\n- **`navigate(to, options)`:**\n    - `to`: The path to navigate to (e.g., `'/dashboard'`, `'/users/123'`). Can also be a number for relative navigation (`-1` for back, `1` for forward).\n    - `options.replace`: `boolean` - If `true`, the current entry in the history stack will be replaced instead of pushing a new one. Useful for redirects (e.g., after login to prevent going back to the login page).\n    - `options.state`: `any` - Data to pass to the new location, accessible via `useLocation().state`.\n\n```javascript\nimport { useNavigate } from 'react-router-dom';\n\nfunction LoginButton() {\n  const navigate = useNavigate();\n\n  const handleLogin = () => {\n    // ... authentication logic ...\n    const isAuthenticated = true; // Assume successful login\n    if (isAuthenticated) {\n      navigate('/dashboard', { replace: true, state: { user: 'admin' } });\n    }\n  };\n\n  return <button onClick={handleLogin}>Login</button>;\n}\n```\n\n### React Router v5: `useHistory`\n- The `useHistory` hook provided similar capabilities in v5.\n- **`history.push(path, state)`:** Adds a new entry to the history stack.\n- **`history.replace(path, state)`:** Replaces the current entry in the history stack.\n- **`history.goBack()` / `history.goForward()` / `history.go(n)`:** Navigate relative to the current position.\n\n```javascript\nimport { useHistory } from 'react-router-dom';\n\nfunction LoginButtonV5() {\n  const history = useHistory();\n\n  const handleLogin = () => {\n    // ... authentication logic ...\n    const isAuthenticated = true; // Assume successful login\n    if (isAuthenticated) {\n      history.push('/dashboard'); // or history.replace('/dashboard');\n    }\n  };\n\n  return <button onClick={handleLogin}>Login</button>;\n}\n```\n\n## Declarative Navigation (Components):\n\n### React Router v6: `<Navigate>` Component\n- React Router v6 introduces the `<Navigate>` component for declarative redirects. It is typically used for conditional redirects, like after a form submission or if a user tries to access a protected route without authentication.\n- It renders a redirect immediately.\n- **Usage:**\n```jsx\nimport { Navigate } from 'react-router-dom';\n\nfunction ProtectedRoute({ isAuthenticated }) {\n  if (!isAuthenticated) {\n    return <Navigate to=\"/login\" replace />; // Redirects to login and replaces history entry\n  }\n  return <div>Welcome to the protected area!</div>;\n}\n```\n\n### React Router v5: `<Redirect>` Component\n- In v5, the `<Redirect>` component served the same purpose as `<Navigate>` in v6.\n- It's a component that, when rendered, performs a navigation to the specified `to` prop.\n- **`to`:** The path to redirect to.\n- **`push`:** `boolean` - If `true`, a new entry will be pushed onto the history stack; otherwise, it replaces the current entry (default behavior).\n- **Usage:**\n```jsx\nimport { Redirect } from 'react-router-dom';\n\nfunction OldRoute() {\n  // For example, redirecting from an old URL to a new one\n  return <Redirect to=\"/new-path\" />;\n}\n```\n\nProgrammatic navigation is essential for scenarios where navigation is triggered by logic rather than a direct user click on a link, such as form submissions, authentication flows, or error handling.",
          "examples": [
            {
              "id": "example_programmatic_login_v5",
              "title": "Login Component with Redirect (v5)",
              "code": "import React, { Component } from 'react';\nimport { Redirect } from 'react-router-dom';\n\nexport default class LoginComponentV5 extends Component {\n  state = {\n    username: '',\n    password: '',\n    isLoggedIn: false,\n    error: null\n  };\n  \n  handleInputChange = (e) => {\n    this.setState({\n      [e.target.name]: e.target.value\n    });\n  };\n  \n  handleSubmit = (e) => {\n    e.preventDefault();\n    // Authentication logic here\n    if (this.state.username === 'user' && this.state.password === 'pass') {\n      // Simulate successful login\n      this.setState({ isLoggedIn: true });\n    } else {\n      this.setState({ error: 'Invalid username or password' });\n    }\n  };\n  \n  render() {\n    // Redirect if logged in\n    if (this.state.isLoggedIn) {\n      return <Redirect to=\"/dashboard\" />; // Declarative redirect\n    }\n    \n    return (\n      <div>\n        <h2>Login (v5 Example)</h2>\n        {this.state.error && <p className=\"error\" style={{color: 'red'}}>{this.state.error}</p>}\n        <form onSubmit={this.handleSubmit}>\n          <div>\n            <label>Username:</label>\n            <input\n              type=\"text\"\n              name=\"username\"\n              value={this.state.username}\n              onChange={this.handleInputChange}\n            />\n          </div>\n          <div>\n            <label>Password:</label>\n            <input\n              type=\"password\"\n              name=\"password\"\n              value={this.state.password}\n              onChange={this.handleInputChange}\n            />\n          </div>\n          <button type=\"submit\">Log In</button>\n        </form>\n      </div>\n    );\n  }\n}\n",
              "explanation": "This example demonstrates programmatic navigation using the `Redirect` component in React Router v5. After a simulated successful login (when username 'user' and password 'pass' are entered), the `isLoggedIn` state is set to `true`, which causes the component to render a `<Redirect>` component, effectively navigating the user to the `/dashboard` route.",
              "language": "typescript"
            },
            {
              "id": "example_programmatic_login_v6",
              "title": "Login Component with Programmatic Navigation (v6)",
              "code": "import React, { useState } from 'react';\nimport { useNavigate, Navigate } from 'react-router-dom';\n\nfunction LoginComponentV6() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const [error, setError] = useState(null);\n  const navigate = useNavigate();\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (username === 'user' && password === 'pass') {\n      setIsLoggedIn(true);\n      // Imperative navigation after successful login, replacing history entry\n      navigate('/dashboard', { replace: true }); \n    } else {\n      setError('Invalid username or password');\n    }\n  };\n  \n  // Declarative navigation alternative (if not using navigate hook)\n  // if (isLoggedIn) {\n  //   return <Navigate to=\"/dashboard\" replace />;\n  // }\n\n  return (\n    <div>\n      <h2>Login (v6 Example)</h2>\n      {error && <p className=\"error\" style={{color: 'red'}}>{error}</p>}\n      <form onSubmit={handleSubmit}>\n        <div>\n          <label>Username:</label>\n          <input\n            type=\"text\"\n            name=\"username\"\n            value={username}\n            onChange={(e) => setUsername(e.target.value)}\n          />\n        </div>\n        <div>\n          <label>Password:</label>\n          <input\n            type=\"password\"\n            name=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n          />\n        </div>\n        <button type=\"submit\">Log In</button>\n      </form>\n    </div>\n  );\n}\n",
              "explanation": "This v6 equivalent of the login component uses the `useNavigate` hook for programmatic redirection. Upon successful login, `navigate('/dashboard', { replace: true })` is called, which pushes the user to the dashboard and prevents them from navigating back to the login page using the browser's back button. The commented out `<Navigate>` component shows the declarative alternative in v6.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_programmatic_vs_declarative_nav",
            "question_usenavigate_options",
            "question_programmatic_login_scenario",
            "question_redirect_vs_navigate"
          ],
          "relatedTasks": [
            "task_auth_redirect_flow"
          ],
          "tags": [
            "React Router",
            "Programmatic Navigation",
            "Declarative Navigation",
            "useNavigate",
            "useHistory",
            "Redirect",
            "Navigate",
            "Authentication"
          ],
          "technology": "React",
          "prerequisites": [
            "React Hooks",
            "State Management",
            "Event Handling",
            "React Router Basics"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "intermediate",
          "requiredFor": [
            "Complex User Flows",
            "Authentication and Authorization",
            "Form Handling"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_nav_v6_link_navlink_diff",
          "topic": "React Router v6 Link vs NavLink",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference between `<Link>` and `<NavLink>` components in React Router v6?",
          "answer": "`<NavLink>` provides additional features over `<Link>` to style or add classes to the link when it matches the current URL (i.e., is active). `<Link>` is for basic navigation only.",
          "analysisPoints": [
            "Identifies the core functionality difference.",
            "Understands the concept of an 'active' link."
          ],
          "keyConcepts": [
            "Link Component",
            "NavLink Component",
            "Active State",
            "Client-side Navigation"
          ],
          "evaluationCriteria": [
            "Ability to distinguish between similar React Router components.",
            "Understanding of their intended use cases."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v6",
            "Link",
            "NavLink",
            "Basic Navigation"
          ],
          "prerequisites": [
            "React Router Basics"
          ],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_nav_v6_mcq_navlink_styling",
          "topic": "React Router v6 NavLink Styling",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following is the correct way to apply a bold font style to an active `<NavLink>` in React Router v6?",
          "answer": "```jsx\n<NavLink to=\"/products\" style={({ isActive }) => isActive ? { fontWeight: 'bold' } : undefined}>\n  Products\n</NavLink>\n```",
          "options": [
            "```jsx\n<NavLink to=\"/products\" activeClassName=\"bold-link\">\n  Products\n</NavLink>\n```",
            "```jsx\n<Link to=\"/products\" activeStyle={{ fontWeight: 'bold' }}>\n  Products\n</Link>\n```",
            "```jsx\n<NavLink to=\"/products\" style={({ isActive }) => isActive ? { fontWeight: 'bold' } : undefined}>\n  Products\n</NavLink>\n```",
            "```jsx\n<NavLink to=\"/products\" className={isActive => isActive ? 'bold-link' : ''}>\n  Products\n</NavLink>\n```"
          ],
          "analysisPoints": [
            "Tests understanding of NavLink's `style` prop in v6.",
            "Distinguishes v6 API from v5 (`activeClassName`, `activeStyle`).",
            "Recognizes that `Link` does not have active styling properties."
          ],
          "keyConcepts": [
            "NavLink Component",
            "React Router v6",
            "Functional Style Prop",
            "Active State"
          ],
          "evaluationCriteria": [
            "Knowledge of React Router v6 specific APIs.",
            "Ability to correctly implement conditional styling."
          ],
          "example": "In React Router v6, `NavLink`'s `style` and `className` props accept a function that receives an object with an `isActive` boolean. This allows for dynamic styling based on the link's active state. Options A and B use v5 syntax or incorrect components. Option D is valid for `className` but the question asks about `style` specifically.",
          "tags": [
            "React Router",
            "v6",
            "NavLink",
            "Styling",
            "MCQ"
          ],
          "prerequisites": [
            "React Router v6 basics",
            "CSS-in-JS (optional, but understanding style prop)"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_nav_v6_usenavigate_purpose",
          "topic": "React Router v6 useNavigate Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of the `useNavigate` hook in React Router v6?",
          "answer": "The `useNavigate` hook is used for programmatic (imperative) navigation, allowing you to change routes based on logic (e.g., after form submission, successful login) rather than a direct user click on a `Link` or `NavLink`.",
          "analysisPoints": [
            "Defines programmatic navigation.",
            "Contrasts with declarative navigation."
          ],
          "keyConcepts": [
            "useNavigate Hook",
            "Programmatic Navigation",
            "Imperative Navigation",
            "React Router v6"
          ],
          "evaluationCriteria": [
            "Understanding of React Router hooks.",
            "Ability to differentiate navigation types."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v6",
            "useNavigate",
            "Hooks",
            "Navigation"
          ],
          "prerequisites": [
            "React Hooks",
            "React Router Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_nav_v6_navigate_replace",
          "topic": "useNavigate Options (replace)",
          "level": "medium",
          "type": "open",
          "question": "Explain the significance of the `{ replace: true }` option when using `navigate('/path', { replace: true })` in React Router v6. Provide a common use case.",
          "answer": "`{ replace: true }` tells React Router to replace the current entry in the browser's history stack with the new path, instead of pushing a new entry onto the stack. This means that if a user clicks the back button after this navigation, they will go to the page *before* the replaced entry, not the page that was just replaced.\n\nA common use case is after a successful login or a sensitive operation (like submitting an order). For example, after a user successfully logs in and is redirected from `/login` to `/dashboard`, you typically don't want them to be able to hit the browser's back button and return to the `/login` page without logging out. By using `navigate('/dashboard', { replace: true })`, the `/login` page is removed from the history stack, and pressing back will take them to whatever page they were on *before* they landed on `/login` (or simply exit the application if `/login` was the first page they visited).",
          "analysisPoints": [
            "Defines `replace` functionality accurately.",
            "Explains the impact on browser history.",
            "Provides a clear and relevant real-world use case (login/redirect)."
          ],
          "keyConcepts": [
            "useNavigate",
            "Browser History",
            "History Stack",
            "Authentication Flow",
            "Programmatic Navigation"
          ],
          "evaluationCriteria": [
            "Detailed explanation of an important React Router API option.",
            "Ability to connect technical details to practical application scenarios.",
            "Understanding of user experience implications of navigation choices."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v6",
            "useNavigate",
            "History Management",
            "Authentication"
          ],
          "prerequisites": [
            "React Router useNavigate",
            "Browser History API"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_nav_v5_v6_diff_navlink",
          "topic": "React Router v5 vs v6 NavLink",
          "level": "medium",
          "type": "open",
          "question": "Describe the main difference in how `NavLink` handles active styling between React Router v5 and v6. Why might the v6 approach be considered more flexible?",
          "answer": "In React Router v5, `NavLink` primarily used the `activeClassName` prop (e.g., `<NavLink to='/about' activeClassName='my-active-class'>`) to apply a CSS class to the active link. It also had an `activeStyle` prop for inline styles.\n\nIn React Router v6, `activeClassName` and `activeStyle` props were removed. Instead, `NavLink`'s `className` and `style` props now accept a function. This function receives an object with an `isActive` boolean property (`({ isActive }) => ...`). This allows developers to dynamically return a CSS class string or a style object based on the `isActive` state.\n\nThe v6 approach is considered more flexible because:\n1.  **Direct Conditional Logic:** It allows for more complex conditional styling directly within the component's JSX, without needing separate CSS classes for every minor variation. You can combine multiple conditions or return different styles/classes based on other props or state.\n2.  **CSS-in-JS Compatibility:** It integrates more smoothly with CSS-in-JS libraries (like Styled Components, Emotion) where you might want to compute styles dynamically based on props, including `isActive`.\n3.  **Encourages Functional Approach:** It aligns with React's functional component and hooks paradigm, encouraging a more direct manipulation of props based on component state/context.",
          "analysisPoints": [
            "Clearly states the syntax difference (`activeClassName` vs functional `className`/`style`).",
            "Explains *why* the v6 approach is more flexible (dynamic logic, CSS-in-JS, functional paradigm).",
            "Demonstrates understanding of API evolution."
          ],
          "keyConcepts": [
            "NavLink",
            "React Router v5",
            "React Router v6",
            "Active Styling",
            "API Evolution"
          ],
          "evaluationCriteria": [
            "Detailed comparison of API versions.",
            "Ability to articulate reasons for design changes.",
            "Comprehension of broader React ecosystem trends (e.g., CSS-in-JS)."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v5",
            "v6",
            "NavLink",
            "Styling",
            "API Changes"
          ],
          "prerequisites": [
            "React Router v5 and v6 basics"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_programmatic_login_scenario",
          "topic": "Programmatic Navigation in Authentication Flow",
          "level": "hard",
          "type": "code",
          "question": "You are building a login form in a React application using React Router v6. After a successful login, you need to redirect the user to a `/dashboard` page. Additionally, users should not be able to navigate back to the `/login` page using the browser's back button after logging in.\n\nImplement the `handleLoginSubmit` function within the `LoginForm` component to achieve this behavior. Assume `performLogin(username, password)` is an async function that returns `true` on success and `false` otherwise.",
          "answer": "```typescript\nimport React, { useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\n// Assume this function exists and simulates an API call\nconst performLogin = async (username: string, password: string): Promise<boolean> => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      if (username === 'test' && password === 'password') {\n        resolve(true);\n      } else {\n        resolve(false);\n      }\n    }, 500);\n  });\n};\n\nfunction LoginForm() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [error, setError] = useState('');\n  const navigate = useNavigate();\n\n  const handleLoginSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setError('');\n\n    try {\n      const success = await performLogin(username, password);\n      if (success) {\n        // Redirect to dashboard and replace history entry\n        navigate('/dashboard', { replace: true });\n      } else {\n        setError('Invalid credentials');\n      }\n    } catch (err) {\n      setError('Login failed. Please try again.');\n    }\n  };\n\n  return (\n    <div>\n      <h2>Login</h2>\n      {error && <p style={{ color: 'red' }}>{error}</p>}\n      <form onSubmit={handleLoginSubmit}>\n        <div>\n          <label>Username:</label>\n          <input\n            type=\"text\"\n            value={username}\n            onChange={(e) => setUsername(e.target.value)}\n          />\n        </div>\n        <div>\n          <label>Password:</label>\n          <input\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n          />\n        </div>\n        <button type=\"submit\">Log In</button>\n      </form>\n    </div>\n  );\n}\n\n// To test this component, you'd set up your React Router routes:\n// <BrowserRouter>\n//   <Routes>\n//     <Route path=\"/login\" element={<LoginForm />} />\n//     <Route path=\"/dashboard\" element={<div>Welcome to Dashboard!</div>} />\n//     <Route path=\"/\" element={<div>Home Page</div>} />\n//   </Routes>\n// </BrowserRouter>\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `useNavigate` for programmatic navigation.",
            "Applies the `replace: true` option to prevent returning to the login page.",
            "Handles asynchronous login logic with `async/await`.",
            "Includes basic error handling.",
            "Demonstrates understanding of form submission handling (`e.preventDefault()`)."
          ],
          "keyConcepts": [
            "useNavigate Hook",
            "Programmatic Navigation",
            "Authentication Flow",
            "History Management",
            "Form Handling",
            "Asynchronous JavaScript"
          ],
          "evaluationCriteria": [
            "Correct implementation of React Router v6 navigation.",
            "Proper use of `replace` option.",
            "Ability to integrate routing with business logic (authentication).",
            "Clean and functional code structure.",
            "Error handling considerations."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v6",
            "Authentication",
            "Programmatic Navigation",
            "Code Challenge",
            "Hooks"
          ],
          "prerequisites": [
            "React Hooks",
            "Asynchronous JavaScript",
            "React Router useNavigate"
          ],
          "complexity": 8,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_programmatic_vs_declarative_nav",
          "topic": "Programmatic vs. Declarative Navigation",
          "level": "medium",
          "type": "open",
          "question": "Contrast programmatic (imperative) navigation with declarative navigation in React Router. Provide examples for each type in a React Router v6 context, and explain when to prefer one over the other.",
          "answer": "**Declarative Navigation** involves using React components to describe the desired navigation. When these components are rendered, they instruct React Router to navigate. It's often preferred for static links or simple conditional rendering.\n*   **Example (v6):** `<Link to=\"/dashboard\">Go to Dashboard</Link>` or `<NavLink to=\"/profile\">Profile</NavLink>`.\n*   **When to prefer:** For standard clickable links in navigation menus, buttons that directly correspond to a route, or simple conditional redirects using `<Navigate>` where the condition is based purely on rendered state (e.g., if a user is logged in, show dashboard, else redirect to login).\n\n**Programmatic (Imperative) Navigation** involves using JavaScript code (hooks) to trigger navigation based on some logic or event that isn't a direct click on a `Link` component. This is useful when navigation depends on an action's outcome, such as form submission, API call success, or a timeout.\n*   **Example (v6):**\n    ```typescript\n    import { useNavigate } from 'react-router-dom';\n    function MyForm() {\n      const navigate = useNavigate();\n      const handleSubmit = () => {\n        // ... form submission logic ...\n        if (success) {\n          navigate('/success'); // Imperatively navigate\n        }\n      };\n      return <form onSubmit={handleSubmit}>...</form>;\n    }\n    ```\n*   **When to prefer:** After successful form submissions, after an API call completes, based on complex state logic, redirecting to a previous page (`navigate(-1)`), or for non-link elements that trigger navigation (e.g., buttons, dropdown selections).\n\n**In summary:** Use declarative navigation for 'what you want to render' (visual links), and programmatic navigation for 'what you want to do' (logic-driven redirects or history manipulation).",
          "analysisPoints": [
            "Clearly defines both types of navigation.",
            "Provides accurate v6 examples for both.",
            "Articulates appropriate use cases and preferences for each.",
            "Highlights the 'what to render' vs 'what to do' distinction."
          ],
          "keyConcepts": [
            "Declarative Navigation",
            "Programmatic Navigation",
            "Imperative Navigation",
            "Link Component",
            "NavLink Component",
            "useNavigate Hook",
            "Navigate Component",
            "React Router v6"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of React Router navigation paradigms.",
            "Ability to provide relevant code examples.",
            "Practical understanding of when to apply each method.",
            "Clear and concise explanations."
          ],
          "example": "",
          "tags": [
            "React Router",
            "Navigation Patterns",
            "v6",
            "Declarative",
            "Imperative",
            "Concepts"
          ],
          "prerequisites": [
            "React Router Basics",
            "React Hooks"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redirect_vs_navigate",
          "topic": "Redirect vs Navigate Component",
          "level": "medium",
          "type": "flashcard",
          "question": "What is the React Router v6 equivalent of the `<Redirect>` component from v5, and how is it used?",
          "answer": "The React Router v6 equivalent of the `<Redirect>` component is the `<Navigate>` component. It is used for declarative redirects, typically within a `return` statement of a component to conditionally navigate based on state. For example: `if (!user) { return <Navigate to=\"/login\" replace />; }`",
          "analysisPoints": [
            "Identifies the correct v6 component.",
            "Explains its purpose (declarative redirect).",
            "Provides a concise usage example."
          ],
          "keyConcepts": [
            "Redirect Component",
            "Navigate Component",
            "React Router v5",
            "React Router v6",
            "Declarative Navigation"
          ],
          "evaluationCriteria": [
            "Knowledge of API changes between React Router versions.",
            "Understanding of declarative routing components."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v5",
            "v6",
            "Redirect",
            "Navigate",
            "Components"
          ],
          "prerequisites": [
            "React Router Components"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_nav_v5_usehistory_purpose",
          "topic": "React Router v5 useHistory Hook",
          "level": "easy",
          "type": "flashcard",
          "question": "What was the primary purpose of the `useHistory` hook in React Router v5, and what replaced it in v6?",
          "answer": "The `useHistory` hook in React Router v5 provided access to the `history` object, allowing for programmatic navigation (e.g., `history.push('/path')`, `history.replace('/path')`, `history.goBack()`). It was replaced by the `useNavigate` hook in React Router v6.",
          "analysisPoints": [
            "Correctly identifies `useHistory`'s function.",
            "Names its v6 replacement.",
            "Understands deprecation and evolution."
          ],
          "keyConcepts": [
            "useHistory Hook",
            "useNavigate Hook",
            "React Router v5",
            "React Router v6",
            "Programmatic Navigation"
          ],
          "evaluationCriteria": [
            "Knowledge of historical React Router APIs.",
            "Awareness of API evolution."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v5",
            "useHistory",
            "Hooks",
            "Legacy"
          ],
          "prerequisites": [
            "React Router Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "intermediate"
        },
        {
          "id": "question_nav_v5_withrouter",
          "topic": "React Router v5 withRouter HOC",
          "level": "medium",
          "type": "open",
          "question": "Before React Hooks, how did React Router v5 provide routing-related props (like `history`, `location`, `match`) to components that were not directly rendered by a `<Route>`? What is the modern equivalent in v6?",
          "answer": "In React Router v5 (and earlier versions), the `withRouter` Higher-Order Component (HOC) was used to inject `history`, `location`, and `match` props into any component, regardless of whether it was directly rendered by a `<Route>`.\n\nExample usage:\n```jsx\nimport { withRouter } from 'react-router-dom';\n\nclass MyComponent extends React.Component {\n  // this.props.history, this.props.location, this.props.match are available\n  render() {\n    return <button onClick={() => this.props.history.push('/some-path')}>Navigate</button>;\n  }\n}\n\nexport default withRouter(MyComponent);\n```\n\nThe modern equivalent in React Router v6 (and generally with React Hooks) are individual hooks: `useNavigate` (for `history`), `useLocation` (for `location`), and `useParams` (for `match.params`). These hooks can be used directly in functional components without the need for HOCs, offering a cleaner and more direct API.",
          "analysisPoints": [
            "Identifies `withRouter` as the v5 solution.",
            "Explains its purpose (injecting routing props).",
            "Provides a basic example of `withRouter` usage.",
            "Correctly identifies `useNavigate`, `useLocation`, `useParams` as v6 equivalents.",
            "Highlights the shift from HOCs to Hooks."
          ],
          "keyConcepts": [
            "withRouter HOC",
            "Higher-Order Components",
            "React Router v5",
            "React Router v6",
            "useNavigate",
            "useLocation",
            "useParams",
            "React Hooks"
          ],
          "evaluationCriteria": [
            "Knowledge of both legacy and modern React Router APIs.",
            "Understanding of the role of HOCs vs. Hooks.",
            "Ability to explain API evolution and reasoning.",
            "Clarity of explanation and examples."
          ],
          "example": "",
          "tags": [
            "React Router",
            "v5",
            "v6",
            "HOC",
            "Hooks",
            "API Changes",
            "Legacy"
          ],
          "prerequisites": [
            "React Hooks",
            "React Router Hooks",
            "Higher-Order Components"
          ],
          "complexity": 7,
          "interviewFrequency": 5,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_v6_dynamic_navbar",
          "title": "Build a Responsive Navigation Bar with React Router v6",
          "description": "\nCreate a `NavBar` React component that utilizes React Router v6 for navigation. The component should meet the following requirements:\n\n1.  **Home Link:** A simple link to the root path (`/`) using `<Link>`.\n2.  **About Link:** A link to `/about` using `<NavLink>`. This link should have its text color changed to `blue` and font weight set to `bold` when it's the active route.\n3.  **Contact Button:** A button that navigates programmatically to `/contact` when clicked. Use the `useNavigate` hook.\n4.  **Go Back Button:** Another button that uses `useNavigate` to go back one step in the browser history.\n5.  **Basic Structure:** Use `<ul>` and `<li>` for the navigation items.\n\nYour solution should be functional within a basic React Router v6 setup (`BrowserRouter`, `Routes`, `Route`).\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport { Link, NavLink, useNavigate } from 'react-router-dom';\n\nfunction NavBar() {\n  // TODO: Initialize useNavigate hook\n\n  return (\n    <nav style={{\n      backgroundColor: '#f0f0f0',\n      padding: '10px',\n      borderRadius: '5px',\n      display: 'flex',\n      justifyContent: 'center',\n      gap: '20px'\n    }}>\n      <ul style={{\n        listStyle: 'none',\n        padding: 0,\n        margin: 0,\n        display: 'flex',\n        gap: '20px',\n        alignItems: 'center'\n      }}>\n        <li>\n          {/* TODO: Add Link to Home */}\n        </li>\n        <li>\n          {/* TODO: Add NavLink to About with active styling */}\n        </li>\n        <li>\n          {/* TODO: Add Contact button with programmatic navigation */}\n        </li>\n        <li>\n          {/* TODO: Add Go Back button with programmatic navigation */}\n        </li>\n      </ul>\n    </nav>\n  );\n}\n\nexport default NavBar;\n\n/*\n// Example App.js to test NavBar:\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport NavBar from './NavBar';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <NavBar />\n      <div style={{ marginTop: '20px', textAlign: 'center' }}>\n        <Routes>\n          <Route path=\"/\" element={<h2>Home Page</h2>} />\n          <Route path=\"/about\" element={<h2>About Us Page</h2>} />\n          <Route path=\"/contact\" element={<h2>Contact Us Page</h2>} />\n          <Route path=\"/test-history\" element={<h2>History Test Page</h2>} />\n        </Routes>\n      </div>\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n*/\n",
          "solutionCode": "import React from 'react';\nimport { Link, NavLink, useNavigate } from 'react-router-dom';\n\nfunction NavBar() {\n  const navigate = useNavigate();\n\n  return (\n    <nav style={{\n      backgroundColor: '#f0f0f0',\n      padding: '10px',\n      borderRadius: '5px',\n      display: 'flex',\n      justifyContent: 'center',\n      gap: '20px'\n    }}>\n      <ul style={{\n        listStyle: 'none',\n        padding: 0,\n        margin: 0,\n        display: 'flex',\n        gap: '20px',\n        alignItems: 'center'\n      }}>\n        <li>\n          <Link to=\"/\" style={{ textDecoration: 'none', color: 'black' }}>Home</Link>\n        </li>\n        <li>\n          <NavLink \n            to=\"/about\" \n            style={({ isActive }) => \n              isActive ? { fontWeight: 'bold', color: 'blue', textDecoration: 'none' } : { color: 'black', textDecoration: 'none' }\n            }\n          >\n            About\n          </NavLink>\n        </li>\n        <li>\n          <button \n            onClick={() => navigate('/contact')}\n            style={{ padding: '8px 12px', border: 'none', borderRadius: '4px', cursor: 'pointer', backgroundColor: '#add8e6' }}\n          >\n            Contact\n          </button>\n        </li>\n        <li>\n          <button \n            onClick={() => navigate(-1)}\n            style={{ padding: '8px 12px', border: 'none', borderRadius: '4px', cursor: 'pointer', backgroundColor: '#add8e6' }}\n          >\n            Go Back\n          </button>\n        </li>\n      </ul>\n    </nav>\n  );\n}\n\nexport default NavBar;\n",
          "testCases": [
            "Navigate to '/', then '/about', then '/contact'. Verify 'About' link changes style when active.",
            "Click 'Contact' button and verify navigation to '/contact'.",
            "Click 'Go Back' button from '/contact' page. Verify navigation to the previous page (e.g., '/about').",
            "Click 'Go Back' button from the initial page (e.g., '/'). Verify graceful handling (no error, or stays on current page if no history).",
            "Ensure all links and buttons are clickable and functional without full page reloads."
          ],
          "hints": [
            "Remember that `NavLink`'s `style` prop in v6 takes a function that receives `{ isActive }`.",
            "The `useNavigate` hook returns a function that can accept a path string or a number (for relative history navigation).",
            "Make sure to import all necessary components and hooks from `react-router-dom`."
          ],
          "tags": [
            "React Router",
            "v6",
            "Navigation Bar",
            "Link",
            "NavLink",
            "useNavigate",
            "Hooks",
            "Frontend Development"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "React Basics",
            "React Hooks",
            "React Router Fundamentals"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Client-Side Routing",
            "Dynamic Styling",
            "Imperative Navigation"
          ]
        },
        {
          "id": "task_auth_redirect_flow",
          "title": "Implement a Secure Login Flow with Redirect",
          "description": "\nDevelop a `LoginComponent` that handles user authentication and redirects the user upon successful login using React Router v6. The component should:\n\n1.  **Authentication Simulation:** Simulate a login attempt using a placeholder `fakeLoginApi` function (provided). This function should return a Promise that resolves to `true` for successful login (e.g., `username: 'user', password: 'password'`) and `false` otherwise after a short delay.\n2.  **Form Handling:** Manage username and password input fields using React state.\n3.  **Programmatic Redirect:** Upon successful login, programmatically navigate the user to a `/dashboard` route.\n4.  **History Management:** Ensure that the user *cannot* go back to the `/login` page using the browser's back button after successfully logging in. This requires replacing the history entry.\n5.  **Error Handling:** Display an error message if login fails.\n6.  **Declarative Redirect (Bonus/Alternative):** As an alternative, demonstrate how the `<Navigate>` component could be used for the same redirect behavior if the login state was managed at a higher level.\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\nimport { useNavigate, Navigate } from 'react-router-dom';\n\n// Simulate an API call for login\nconst fakeLoginApi = async (username, password) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      if (username === 'user' && password === 'password') {\n        resolve(true); // Simulate successful login\n      } else {\n        resolve(false); // Simulate failed login\n      }\n    }, 700);\n  });\n};\n\nfunction LoginComponent() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [error, setError] = useState('');\n  const [isLoggedIn, setIsLoggedIn] = useState(false); // To track login state\n\n  // TODO: Initialize useNavigate hook\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    setError(''); // Clear previous errors\n    // TODO: Implement login logic and redirect\n  };\n\n  // TODO (Bonus): Optionally use <Navigate> for declarative redirect based on isLoggedIn state\n\n  return (\n    <div style={{ padding: '20px', maxWidth: '400px', margin: '50px auto', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <h2>Login</h2>\n      {error && <p style={{ color: 'red' }}>{error}</p>}\n      <form onSubmit={handleSubmit}>\n        <div style={{ marginBottom: '10px' }}>\n          <label htmlFor=\"username\" style={{ display: 'block', marginBottom: '5px' }}>Username:</label>\n          <input\n            type=\"text\"\n            id=\"username\"\n            value={username}\n            onChange={(e) => setUsername(e.target.value)}\n            style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}\n          />\n        </div>\n        <div style={{ marginBottom: '20px' }}>\n          <label htmlFor=\"password\" style={{ display: 'block', marginBottom: '5px' }}>Password:</label>\n          <input\n            type=\"password\"\n            id=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}\n          />\n        </div>\n        <button \n          type=\"submit\" \n          style={{ width: '100%', padding: '10px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}\n        >\n          Log In\n        </button>\n      </form>\n    </div>\n  );\n}\n\nexport default LoginComponent;\n\n/*\n// Example App.js to test LoginComponent:\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport LoginComponent from './LoginComponent';\n\nfunction DashboardPage() {\n  return <h2 style={{ textAlign: 'center', marginTop: '50px' }}>Welcome to the Dashboard!</h2>;\n}\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/login\" element={<LoginComponent />} />\n        <Route path=\"/dashboard\" element={<DashboardPage />} />\n        <Route path=\"/\" element={<h2 style={{ textAlign: 'center', marginTop: '50px' }}>Home Page (Access Login at /login)</h2>} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n*/",
          "solutionCode": "import React, { useState } from 'react';\nimport { useNavigate, Navigate } from 'react-router-dom';\n\n// Simulate an API call for login\nconst fakeLoginApi = async (username, password) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      if (username === 'user' && password === 'password') {\n        resolve(true); // Simulate successful login\n      } else {\n        resolve(false); // Simulate failed login\n      }\n    }, 700);\n  });\n};\n\nfunction LoginComponent() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [error, setError] = useState('');\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const navigate = useNavigate(); // Initialize useNavigate hook\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    setError(''); // Clear previous errors\n\n    const success = await fakeLoginApi(username, password);\n    if (success) {\n      setIsLoggedIn(true); // Update state to reflect login status\n      // Programmatic redirect to dashboard and replace history entry\n      navigate('/dashboard', { replace: true });\n    } else {\n      setError('Invalid username or password. Try 'user' / 'password'.');\n    }\n  };\n\n  // Optional: Declarative redirect using <Navigate> (if login state handled externally/globally)\n  // if (isLoggedIn) {\n  //   return <Navigate to=\"/dashboard\" replace />;\n  // }\n\n  return (\n    <div style={{ padding: '20px', maxWidth: '400px', margin: '50px auto', border: '1px solid #ccc', borderRadius: '8px' }}>\n      <h2>Login</h2>\n      {error && <p style={{ color: 'red' }}>{error}</p>}\n      <form onSubmit={handleSubmit}>\n        <div style={{ marginBottom: '10px' }}>\n          <label htmlFor=\"username\" style={{ display: 'block', marginBottom: '5px' }}>Username:</label>\n          <input\n            type=\"text\"\n            id=\"username\"\n            value={username}\n            onChange={(e) => setUsername(e.target.value)}\n            style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}\n          />\n        </div>\n        <div style={{ marginBottom: '20px' }}>\n          <label htmlFor=\"password\" style={{ display: 'block', marginBottom: '5px' }}>Password:</label>\n          <input\n            type=\"password\"\n            id=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            style={{ width: '100%', padding: '8px', boxSizing: 'border-box' }}\n          />\n        </div>\n        <button \n          type=\"submit\" \n          style={{ width: '100%', padding: '10px', backgroundColor: '#007bff', color: 'white', border: 'none', borderRadius: '5px', cursor: 'pointer' }}\n        >\n          Log In\n        </button>\n      </form>\n    </div>\n  );\n}\n\nexport default LoginComponent;\n",
          "testCases": [
            "**Successful Login:** Enter 'user' for username and 'password' for password. Verify redirection to '/dashboard' and that using the browser's back button does NOT return to '/login'.",
            "**Failed Login:** Enter incorrect credentials (e.g., 'wrong' / 'pass'). Verify an error message is displayed and no redirection occurs.",
            "**Empty Input:** Submit the form with empty username/password. Verify the login attempt fails (as `fakeLoginApi` would return false) and an appropriate error message is shown.",
            "**Form Resilience:** Ensure `e.preventDefault()` is correctly used to prevent full page reloads on form submission."
          ],
          "hints": [
            "The `useNavigate` hook is crucial for imperative navigation.",
            "To prevent going back to the login page, investigate the `options` object available with `navigate`.",
            "Remember to use `async/await` when dealing with the `fakeLoginApi` Promise.",
            "State management (`useState`) is needed for form inputs and `isLoggedIn` status."
          ],
          "tags": [
            "React Router",
            "v6",
            "Authentication",
            "Programmatic Navigation",
            "History Management",
            "Forms",
            "Hooks"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Hooks",
            "Form Handling in React",
            "Asynchronous JavaScript",
            "React Router useNavigate"
          ],
          "complexity": 8,
          "interviewRelevance": 10,
          "learningPath": "advanced",
          "relatedConcepts": [
            "User Experience",
            "Security Best Practices (for redirects)",
            "API Integration"
          ]
        }
      ]
    }
  }
]