[
  {
    "id": "8a9ce561-4860-4372-a2b6-889b2e9662bb",
    "startLine": 4800,
    "endLine": 4899,
    "processedDate": "2025-06-17T09:18:34.805Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_lifecycle_best_practices",
          "title": "React Class Component Lifecycle Best Practices",
          "content": "React class components provide a set of lifecycle methods that allow you to execute code at specific points during a component's life: when it's created, updated, or destroyed. Understanding and correctly using these methods is crucial for building robust and performant React applications.\n\n## When to Make HTTP Requests\nIt is highly recommended to make HTTP requests inside the `componentDidMount` lifecycle method. This ensures that the component has been rendered to the DOM before the data fetching begins. Fetching data here prevents issues like trying to update state on an unmounted component or causing unnecessary re-renders during the initial render phase. It also guarantees that the data fetching only happens once when the component is initially mounted.\n\n## Updating State Based on Props\nDirectly using props to set state within `componentDidUpdate` without a condition can lead to infinite loops. This happens because `setState` triggers a re-render, which in turn calls `componentDidUpdate` again, creating a cycle. To avoid this, always compare current props (`this.props`) with previous props (`prevProps`) before updating state.\n\nFor deriving state from props, especially when the derived state needs to be re-calculated only when specific props change, `static getDerivedStateFromProps` is the appropriate lifecycle method. It is a static method, meaning it does not have access to `this` (the component instance), and it should return an object to update the state or `null` to indicate no state change. It's called right before `render`, on both initial mount and subsequent updates.\n\n## Optimizing Renders with `shouldComponentUpdate`\nBy default, React components re-render whenever their parent re-renders, or when their own state or props change. `shouldComponentUpdate` is a lifecycle method that allows you to control whether a component re-renders. It receives `nextProps` and `nextState` as arguments and should return `true` if the component should re-render, or `false` if it should not. This method is a powerful tool for performance optimization, especially for complex components or large lists, by preventing unnecessary re-renders. However, it requires careful implementation to avoid bugs from missed updates.",
          "examples": [
            {
              "id": "example_lifecycle_http_request",
              "title": "Making HTTP Requests in componentDidMount",
              "code": "import React, { Component } from 'react';\n\ninterface DataState {\n  data: any[] | null;\n  loading: boolean;\n  error: Error | null;\n}\n\nclass DataFetcher extends Component<{}, DataState> {\n  constructor(props: {}) {\n    super(props);\n    this.state = {\n      data: null,\n      loading: true,\n      error: null,\n    };\n  }\n\n  componentDidMount() {\n    console.log('ComponentDidMount: Fetching data...');\n    fetch('https://jsonplaceholder.typicode.com/posts?_limit=3')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then(data => {\n        this.setState({ data, loading: false });\n        console.log('Data fetched successfully:', data);\n      })\n      .catch(error => {\n        this.setState({ error, loading: false });\n        console.error('Error fetching data:', error);\n      });\n  }\n\n  render() {\n    const { data, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading data...</div>;\n    }\n    if (error) {\n      return <div>Error: {error.message}</div>;\n    }\n    if (!data || data.length === 0) {\n        return <div>No data available.</div>;\n    }\n\n    return (\n      <div>\n        <h2>Fetched Data:</h2>\n        <ul>\n          {data.map((item: any) => (\n            <li key={item.id}>{item.title}</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\n// Usage:\n// <DataFetcher />\n",
              "explanation": "This example demonstrates fetching data within `componentDidMount`. The component's `loading` state is set to `true` initially and then updated to `false` (along with the fetched data or error) once the fetch operation completes. This ensures the data is only fetched once the component is ready to display it, preventing unnecessary network requests or state updates during the initial render cycle.",
              "language": "typescript"
            },
            {
              "id": "example_lifecycle_update_props",
              "title": "Updating State from Props Safely (componentDidUpdate vs. getDerivedStateFromProps)",
              "code": "import React, { Component } from 'react';\n\ninterface Item {\n  id: number;\n  name: string;\n  active: boolean;\n}\n\ninterface FilteredListProps {\n  items: Item[];\n}\n\ninterface FilteredListState {\n  filteredItems: Item[];\n  prevItems: Item[] | null; // Used with getDerivedStateFromProps\n}\n\n// Approach 1: Using componentDidUpdate safely\nclass FilteredListA extends Component<FilteredListProps, FilteredListState> {\n  constructor(props: FilteredListProps) {\n    super(props);\n    this.state = {\n      filteredItems: this.props.items.filter(item => item.active),\n      prevItems: null\n    };\n  }\n\n  componentDidUpdate(prevProps: FilteredListProps) {\n    // GOOD: Check if props actually changed to avoid infinite loop\n    if (prevProps.items !== this.props.items) {\n      console.log('FilteredListA: Items prop changed, updating state via componentDidUpdate');\n      this.setState({\n        filteredItems: this.props.items.filter(item => item.active)\n      });\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Filtered List (componentDidUpdate)</h3>\n        <ul>\n          {this.state.filteredItems.map(item => (\n            <li key={item.id}>{item.name} (Active: {String(item.active)})</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\n// Approach 2: Using static getDerivedStateFromProps (Recommended for prop-derived state)\nclass FilteredListB extends Component<FilteredListProps, FilteredListState> {\n  constructor(props: FilteredListProps) {\n    super(props);\n    this.state = {\n      filteredItems: [], // Initial state, will be updated by getDerivedStateFromProps\n      prevItems: null,   // Store previous items to detect changes\n    };\n  }\n\n  static getDerivedStateFromProps(props: FilteredListProps, state: FilteredListState) {\n    // Check if the items prop has changed since the last render\n    if (props.items !== state.prevItems) {\n      console.log('FilteredListB: Items prop changed, deriving new state via getDerivedStateFromProps');\n      return {\n        filteredItems: props.items.filter(item => item.active),\n        prevItems: props.items, // Update prevItems for the next comparison\n      };\n    }\n    // No change in props, no state update needed\n    return null;\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>Filtered List (getDerivedStateFromProps)</h3>\n        <ul>\n          {this.state.filteredItems.map(item => (\n            <li key={item.id}>{item.name} (Active: {String(item.active)})</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\n// Usage example (e.g., in a parent component):\n/*\nconst allItems = [\n  { id: 1, name: 'Apple', active: true },\n  { id: 2, name: 'Banana', active: false },\n  { id: 3, name: 'Cherry', active: true },\n];\n\n<FilteredListA items={allItems} />\n<FilteredListB items={allItems} />\n*/\n",
              "explanation": "This example compares two approaches for updating state based on prop changes. `FilteredListA` uses `componentDidUpdate` with a crucial `if (prevProps.items !== this.props.items)` check to prevent an infinite loop. `FilteredListB` uses the static `getDerivedStateFromProps`, which is the preferred way to derive state from props. It's a pure function that returns the new state object or `null` if no update is needed. Notice how `prevItems` is stored in state to track changes for `getDerivedStateFromProps`.",
              "language": "typescript"
            },
            {
              "id": "example_lifecycle_should_component_update",
              "title": "Optimizing Renders with shouldComponentUpdate",
              "code": "import React, { Component } from 'react';\n\ninterface OptimizableComponentProps {\n  id: number;\n  name: string;\n  value: number;\n}\n\ninterface OptimizableComponentState {\n  counter: number;\n}\n\nclass OptimizableComponent extends Component<OptimizableComponentProps, OptimizableComponentState> {\n  constructor(props: OptimizableComponentProps) {\n    super(props);\n    this.state = { counter: 0 };\n  }\n\n  shouldComponentUpdate(nextProps: OptimizableComponentProps, nextState: OptimizableComponentState): boolean {\n    // Only re-render if 'id' prop or 'counter' state changes.\n    // 'name' and 'value' prop changes will NOT trigger a re-render.\n    if (nextProps.id !== this.props.id || nextState.counter !== this.state.counter) {\n      console.log(`OptimizableComponent (${this.props.name}): Re-rendering due to relevant change.`);\n      return true;\n    }\n    console.log(`OptimizableComponent (${this.props.name}): Skipping re-render (no relevant change).`);\n    return false;\n  }\n\n  render() {\n    console.log(`OptimizableComponent (${this.props.name}): Rendered.`);\n    return (\n      <div style={{ border: '1px solid gray', padding: '10px', margin: '5px' }}>\n        <h4>Optimized Component: {this.props.name} (ID: {this.props.id})</h4>\n        <p>Prop Value: {this.props.value}</p>\n        <p>State Counter: {this.state.counter}</p>\n        <button onClick={() => this.setState(prevState => ({ counter: prevState.counter + 1 }))}>\n          Increment Counter\n        </button>\n      </div>\n    );\n  }\n}\n\n// Usage example (e.g., in a parent component):\n/*\ninterface AppState {\n    id: number;\n    name: string;\n    value: number;\n    triggerRender: boolean;\n}\n\nclass App extends Component<{}, AppState> {\n    state = {\n        id: 1,\n        name: 'Component A',\n        value: 10,\n        triggerRender: false,\n    };\n\n    render() {\n        return (\n            <div>\n                <button onClick={() => this.setState(prev => ({ value: prev.value + 1 }))}>\n                    Change Irrelevant Prop (Value)\n                </button>\n                <button onClick={() => this.setState(prev => ({ id: prev.id + 1 }))}>\n                    Change Relevant Prop (ID)\n                </button>\n                <OptimizableComponent id={this.state.id} name={this.state.name} value={this.state.value} />\n            </div>\n        );\n    }\n}\n*/\n",
              "explanation": "This example shows how `shouldComponentUpdate` can prevent unnecessary renders. The component only re-renders if its `id` prop or `counter` state changes. Changes to the `name` or `value` props will not trigger a re-render because they are explicitly ignored in the `shouldComponentUpdate` logic. This can significantly improve performance for components that receive frequently changing props, but only a subset of those props affects their visual output.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_lifecycle_http_location",
            "question_lifecycle_getderivedstatefromprops_usage",
            "question_lifecycle_shouldcomponentupdate_function",
            "question_lifecycle_anti_pattern",
            "question_lifecycle_infinite_loop_fix",
            "question_lifecycle_gdsfp_side_effects",
            "question_lifecycle_shouldcomponentupdate_caution",
            "question_lifecycle_order_of_methods",
            "question_lifecycle_api_call_why_cdm",
            "question_lifecycle_props_to_state_pattern"
          ],
          "relatedTasks": [
            "task_data_fetching_component",
            "task_filterable_list_gdsfp",
            "task_optimize_component_scu"
          ],
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "componentDidMount",
            "componentDidUpdate",
            "getDerivedStateFromProps",
            "shouldComponentUpdate",
            "Performance Optimization",
            "State Management"
          ],
          "technology": "React",
          "prerequisites": [
            "React Class Components",
            "State and Props",
            "JavaScript Promises/Fetch API"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced React Components",
            "Performance Tuning"
          ]
        },
        {
          "id": "theory_pure_component",
          "title": "React.PureComponent for Performance Optimization",
          "content": "React.PureComponent is a base class that extends `React.Component` but includes a built-in implementation of `shouldComponentUpdate`. Instead of requiring you to write custom logic in `shouldComponentUpdate`, `PureComponent` automatically performs a shallow comparison of the component's props and state. If this shallow comparison reveals no changes, `PureComponent` prevents the component from re-rendering.\n\n## How Shallow Comparison Works\n*   **Props**: It compares the current props with the next props. For primitive values (numbers, strings, booleans, null, undefined), it checks for equality (`===`). For objects and arrays, it checks if the *references* are the same. If the reference is different, it assumes the content might have changed and triggers a re-render. It does *not* deep-compare the contents of objects or arrays.\n*   **State**: Similar to props, it performs a shallow comparison of the current state with the next state.\n\n## Benefits and Limitations\n**Benefits:**\n*   **Reduced Boilerplate**: Eliminates the need to manually implement `shouldComponentUpdate` for many common use cases.\n*   **Performance Improvement**: Prevents unnecessary re-renders, leading to better performance in applications with many components or frequently updated parent components.\n\n**Limitations:**\n*   **Deeply Nested Data**: If your props or state contain deeply nested objects or arrays, `PureComponent`'s shallow comparison might miss changes within those nested structures. In such cases, you might still need to implement a custom `shouldComponentUpdate` or use immutable data structures.\n*   **Functions**: Functions passed as props are often re-created on every render in the parent component. Since `PureComponent` does a shallow comparison, a new function reference will always be considered a 'change', potentially nullifying the optimization unless memoized with `useCallback` (in functional components) or bound once in the constructor (in class components).\n\n`PureComponent` is most effective when your component's props and state are simple, or when you are using immutable data patterns.",
          "examples": [
            {
              "id": "example_pure_component",
              "title": "Using React.PureComponent",
              "code": "import React, { PureComponent } from 'react';\n\ninterface DisplayValueProps {\n  id: number;\n  value: string;\n  data: { timestamp: number }; // Object prop\n}\n\nclass MyPureComponent extends PureComponent<DisplayValueProps> {\n  render() {\n    console.log(`MyPureComponent (${this.props.id}): Rendered. Value: ${this.props.value}`);\n    return (\n      <div style={{ border: '1px dashed blue', margin: '5px', padding: '5px' }}>\n        <h3>Pure Component (ID: {this.props.id})</h3>\n        <p>Value: {this.props.value}</p>\n        <p>Timestamp in data: {this.props.data.timestamp}</p>\n      </div>\n    );\n  }\n}\n\n// Usage example (e.g., in a parent component):\n/*\nimport React, { Component } from 'react';\n\ninterface AppState {\n  counter: number;\n  text: string;\n  objData: { timestamp: number };\n}\n\nclass App extends Component<{}, AppState> {\n  state = {\n    counter: 0,\n    text: 'Initial Text',\n    objData: { timestamp: Date.now() },\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={() => this.setState(prevState => ({\n            counter: prevState.counter + 1,\n            // NOTE: Updating objData by creating a NEW object reference\n            objData: { timestamp: Date.now() } \n        }))}>\n          Update State & Object Prop (Triggers PureComponent)\n        </button>\n        <button onClick={() => this.setState(prevState => ({\n            // This won't trigger PureComponent if only 'text' changes\n            // because 'id' and 'objData' (shallow) haven't changed yet.\n            text: prevState.text === 'Initial Text' ? 'Changed Text' : 'Initial Text'\n        }))}>\n          Update Text Prop (Won't trigger if other props don't change)\n        </button>\n        <MyPureComponent id={1} value={this.state.text} data={this.state.objData} />\n        <p>App Counter: {this.state.counter}</p>\n      </div>\n    );\n  }\n}\n*/\n",
              "explanation": "This example shows `MyPureComponent` which extends `React.PureComponent`. When the `App` component updates its state:\n1.  If `objData` is updated by creating a *new object reference* (e.g., `{ timestamp: Date.now() }`), `MyPureComponent` will re-render because the shallow comparison detects a change in the `data` prop's reference.\n2.  If only the `text` state is updated in the `App` component, and `objData` remains the *same object reference*, `MyPureComponent` will *not* re-render because `id`, `value` (if the string content is the same), and `data` (object reference) are shallowly equal. This demonstrates the automatic `shouldComponentUpdate` behavior.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_purecomponent_definition",
            "question_purecomponent_vs_component",
            "question_purecomponent_shallow_comparison",
            "question_purecomponent_deep_objects",
            "question_purecomponent_when_to_use",
            "question_purecomponent_function_prop",
            "question_purecomponent_benefits",
            "question_purecomponent_limitations"
          ],
          "relatedTasks": [
            "task_purecomponent_demonstration"
          ],
          "tags": [
            "React",
            "PureComponent",
            "Performance Optimization",
            "Shallow Comparison",
            "Class Components"
          ],
          "technology": "React",
          "prerequisites": [
            "React Class Components",
            "State and Props",
            "shouldComponentUpdate"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "requiredFor": [
            "Performance Tuning",
            "Optimized React Development"
          ]
        },
        {
          "id": "theory_react_memo",
          "title": "React.memo (Functional Component Memoization)",
          "content": "React.memo is a higher-order component (HOC) introduced in React 16.6 that serves a similar purpose to `React.PureComponent` but for functional components. It memoizes the component's render output and will only re-render the component if its props have shallowly changed.\n\n## Basic Usage\nWhen you wrap a functional component with `React.memo`, React will perform a shallow comparison of its props. If the new props are shallowly equal to the previous props, React will skip rendering the component and reuse the last rendered result.\n\n## Custom Comparison Function\nBy default, `React.memo` performs a shallow comparison. However, you can provide a custom comparison function as the second argument to `React.memo`. This function receives `prevProps` and `nextProps` as arguments. Unlike `shouldComponentUpdate` (which returns `true` to re-render), this comparison function should return `true` if the props are *equal* (meaning, no re-render is needed) and `false` if they are *different* (meaning, a re-render is needed).\n\nThis custom comparison is useful when:\n*   You need to perform a deep comparison for specific props.\n*   You want to ignore certain props when determining if a re-render is necessary.\n*   You have complex object props that are not stable (e.g., new object reference every render) but their relevant content hasn't changed.\n\n## Relationship with `useCallback` and `useMemo`\nFor `React.memo` to be effective with props that are functions or objects/arrays created in the parent component's render, you often need to use `useCallback` for functions and `useMemo` for objects/arrays. These hooks memoize the function or object itself, ensuring that its reference remains stable across renders, thus allowing `React.memo`'s shallow comparison to work as intended.",
          "examples": [
            {
              "id": "example_react_memo_basic",
              "title": "Basic Usage of React.memo",
              "code": "import React from 'react';\n\ninterface DisplayMessageProps {\n  message: string;\n  count: number;\n}\n\nconst MessageDisplay: React.FC<DisplayMessageProps> = ({ message, count }) => {\n  console.log(`MessageDisplay (basic memo): Rendered with message \"${message}\", count: ${count}`);\n  return (\n    <div style={{ border: '1px solid green', margin: '5px', padding: '5px' }}>\n      <h4>Memoized Component (Basic)</h4>\n      <p>Message: {message}</p>\n      <p>Count: {count}</p>\n    </div>\n  );\n};\n\n// Wrap the component with React.memo\nconst MemoizedMessageDisplay = React.memo(MessageDisplay);\n\n// Usage example (e.g., in a parent component):\n/*\nimport React, { useState } from 'react';\n\nfunction App() {\n  const [value, setValue] = useState(0);\n  const [text, setText] = useState('Hello');\n\n  return (\n    <div>\n      <button onClick={() => setValue(value + 1)}>\n        Update Counter (Triggers Parent, but not MemoizedMessageDisplay if text is stable)\n      </button>\n      <button onClick={() => setText(text === 'Hello' ? 'World' : 'Hello')}>\n        Update Text (Triggers MemoizedMessageDisplay)\n      </button>\n      <MemoizedMessageDisplay message={text} count={value} />\n    </div>\n  );\n}\n*/\n",
              "explanation": "This example shows `React.memo` in its basic form. `MemoizedMessageDisplay` will only re-render if its `message` or `count` props shallowly change. If the parent component (`App` in the commented usage) re-renders, but `text` and `value` props passed to `MemoizedMessageDisplay` are referentially equal to their previous values, the memoized component will not re-render, thus saving computation.",
              "language": "typescript"
            },
            {
              "id": "example_react_memo_custom_comparison",
              "title": "React.memo with Custom Comparison Function",
              "code": "import React from 'react';\n\ninterface UserProfileProps {\n  user: {\n    id: number;\n    name: string;\n    email: string;\n    lastLogin: Date; // A prop that might frequently change but not impact display\n  };\n}\n\nconst UserProfile: React.FC<UserProfileProps> = ({ user }) => {\n  console.log(`UserProfile (custom memo): Rendered for user ${user.name} (ID: ${user.id})`);\n  return (\n    <div style={{ border: '1px solid orange', margin: '5px', padding: '5px' }}>\n      <h4>Memoized User Profile (Custom Comparison)</h4>\n      <p>ID: {user.id}</p>\n      <p>Name: {user.name}</p>\n      <p>Email: {user.email}</p>\n      <p>Last Login: {user.lastLogin.toLocaleTimeString()}</p>\n    </div>\n  );\n};\n\n// Custom comparison function for React.memo\n// Returns true if props are EQUAL (i.e., no re-render needed)\n// We want to re-render ONLY if id, name, or email changes, ignoring lastLogin.\nconst arePropsEqual = (prevProps: UserProfileProps, nextProps: UserProfileProps): boolean => {\n  return (\n    prevProps.user.id === nextProps.user.id &&\n    prevProps.user.name === nextProps.user.name &&\n    prevProps.user.email === nextProps.user.email\n    // We explicitly IGNORE prevProps.user.lastLogin === nextProps.user.lastLogin\n    // This means changes to lastLogin won't trigger a re-render.\n  );\n};\n\nconst MemoizedUserProfile = React.memo(UserProfile, arePropsEqual);\n\n// Usage example (e.g., in a parent component):\n/*\nimport React, { useState, useEffect } from 'react';\n\nfunction App() {\n  const [currentUser, setCurrentUser] = useState({\n    id: 1,\n    name: 'Alice',\n    email: 'alice@example.com',\n    lastLogin: new Date(),\n  });\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      // This updates 'lastLogin' frequently, but won't cause UserProfile to re-render\n      // because of the custom comparison function.\n      setCurrentUser(prevUser => ({\n        ...prevUser,\n        lastLogin: new Date(), // New object reference and new date, but ignored by memo\n      }));\n    }, 2000);\n    return () => clearInterval(intervalId);\n  }, []);\n\n  const changeUserName = () => {\n    setCurrentUser(prevUser => ({ ...prevUser, name: prevUser.name === 'Alice' ? 'Bob' : 'Alice' }));\n  };\n\n  return (\n    <div>\n      <button onClick={changeUserName}>Change User Name (Triggers Re-render)</button>\n      <MemoizedUserProfile user={currentUser} />\n      <p>App will update lastLogin every 2 seconds, but UserProfile should only render if name/id/email changes.</p>\n    </div>\n  );\n}\n*/\n",
              "explanation": "This example demonstrates `React.memo` with a custom comparison function (`arePropsEqual`). The `UserProfile` component receives a `user` object with `lastLogin` which might change frequently (e.g., an 'online status' timestamp). The `arePropsEqual` function is designed to return `true` (skip re-render) if `id`, `name`, and `email` are the same, explicitly ignoring the `lastLogin` property. This prevents unnecessary re-renders when only `lastLogin` changes, optimizing performance while still ensuring updates for relevant data.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_react_memo_purpose",
            "question_react_memo_vs_purecomponent",
            "question_react_memo_custom_comparison_return",
            "question_react_memo_when_to_use",
            "question_react_memo_with_usecallback_usememo",
            "question_react_memo_functional_equivalent",
            "question_react_memo_nested_objects",
            "question_react_memo_function_prop_issue"
          ],
          "relatedTasks": [
            "task_memoized_counter_display",
            "task_custom_memoization_user_card"
          ],
          "tags": [
            "React",
            "React.memo",
            "Functional Components",
            "Higher-Order Components (HOC)",
            "Performance Optimization",
            "Memoization",
            "Shallow Comparison",
            "Custom Comparison"
          ],
          "technology": "React",
          "prerequisites": [
            "React Functional Components",
            "Props in React",
            "Basic JavaScript Functions"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Performance Tuning",
            "Hooks Best Practices",
            "Optimized React Development"
          ]
        },
        {
          "id": "theory_hooks_replacing_lifecycles",
          "title": "Replacing Class Lifecycle Methods with React Hooks",
          "content": "With the introduction of React Hooks, much of the functionality traditionally handled by class component lifecycle methods can now be achieved in functional components, often with more concise and readable code. The primary hook for managing side effects (which include data fetching, subscriptions, and manually changing the DOM) is `useEffect`.\n\n## `useEffect` as a Replacement\n`useEffect` can replace `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`.\n\n*   **`componentDidMount` equivalent**: If you provide an empty dependency array (`[]`) as the second argument to `useEffect`, the effect will run only once after the initial render, similar to `componentDidMount`.\n    ```typescript\n    useEffect(() => {\n      // Runs once after initial render\n      console.log('Component Mounted (via useEffect)');\n      // Fetch data, set up subscriptions, etc.\n    }, []); // Empty dependency array\n    ```\n\n*   **`componentDidUpdate` equivalent**: If you omit the dependency array, the effect will run after every render (after every mount and update). This is generally not recommended as it can lead to performance issues or infinite loops if not carefully managed.\n    ```typescript\n    useEffect(() => {\n      // Runs after every render\n      console.log('Component Updated (via useEffect - no dependency array)');\n    }); // No dependency array\n    ```\n    To mimic `componentDidUpdate` for specific prop/state changes, you provide those values in the dependency array. The effect will re-run only when any of the values in the array change.\n    ```typescript\n    useEffect(() => {\n      // Runs when `someProp` or `someState` changes\n      console.log('Prop or State Updated (via useEffect)');\n    }, [someProp, someState]); // Dependency array with specific values\n    ```\n\n*   **`componentWillUnmount` equivalent**: `useEffect` can return a cleanup function. This function will run right before the component unmounts, and also before the effect re-runs (if dependencies change) to clean up the previous effect's setup.\n    ```typescript\n    useEffect(() => {\n      const subscription = subscribeToData();\n      return () => {\n        // Cleanup function: runs on unmount or before next effect run\n        unsubscribeFromData(subscription);\n        console.log('Cleanup performed (via useEffect return)');\n      };\n    }, []); // Empty dependency array for mount/unmount cleanup\n    ```\n\n## `useMemo` and `useCallback` for Optimization\nWhile not direct replacements for lifecycle methods, `useMemo` and `useCallback` are crucial for performance optimization in functional components, analogous to how `shouldComponentUpdate` and `PureComponent` work. They help in preventing unnecessary re-renders of child components that are wrapped in `React.memo` by providing stable references for props.\n*   **`useCallback`**: Memoizes functions. Prevents functions from being re-created on every render, which is vital when passing functions as props to memoized child components.\n*   **`useMemo`**: Memoizes values. Prevents expensive calculations from being re-run on every render and provides stable object/array references to memoized child components.",
          "examples": [
            {
              "id": "example_hooks_data_fetching",
              "title": "Data Fetching with useEffect (componentDidMount equivalent)",
              "code": "import React, { useState, useEffect } from 'react';\n\ninterface Post {\n  id: number;\n  title: string;\n  body: string;\n}\n\nconst PostsFetcher: React.FC = () => {\n  const [posts, setPosts] = useState<Post[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    console.log('useEffect: Component Mounted, fetching posts...');\n    const fetchPosts = async () => {\n      try {\n        const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5');\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data: Post[] = await response.json();\n        setPosts(data);\n      } catch (err) {\n        setError(err as Error);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchPosts();\n\n    // Optional: Cleanup function if there was a subscription or timer\n    return () => {\n      console.log('useEffect: Cleanup on unmount (e.g., abort fetch request)');\n      // Example: If using AbortController for fetch cleanup:\n      // controller.abort(); \n    };\n  }, []); // Empty dependency array means run once on mount and cleanup on unmount\n\n  if (loading) return <div>Loading posts...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n\n  return (\n    <div>\n      <h2>Blog Posts (Fetched with useEffect)</h2>\n      <ul>\n        {posts.map(post => (\n          <li key={post.id}>\n            <strong>{post.title}</strong>\n            <p>{post.body.substring(0, 50)}...</p>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\n// Usage:\n// <PostsFetcher />\n",
              "explanation": "`useEffect` with an empty dependency array (`[]`) replicates `componentDidMount`. The `fetchPosts` function runs once when the component mounts. The optional return function from `useEffect` acts as `componentWillUnmount`, allowing for cleanup operations like canceling network requests or removing event listeners.",
              "language": "typescript"
            },
            {
              "id": "example_hooks_update_and_cleanup",
              "title": "Updating with useEffect (componentDidUpdate/WillUnmount equivalent)",
              "code": "import React, { useState, useEffect } from 'react';\n\nconst DebouncedInput: React.FC = () => {\n  const [inputValue, setInputValue] = useState('');\n  const [debouncedValue, setDebouncedValue] = useState('');\n\n  useEffect(() => {\n    console.log(`useEffect: Input value changed to \"${inputValue}\", setting up debounce...`);\n    // Set up a debounce timer\n    const timerId = setTimeout(() => {\n      setDebouncedValue(inputValue);\n      console.log(`Debounced value set to: \"${inputValue}\"`);\n    }, 500);\n\n    // Cleanup function: Clear the previous timer if inputValue changes before timer fires\n    return () => {\n      console.log(`useEffect: Cleaning up previous debounce timer for \"${inputValue}\"`);\n      clearTimeout(timerId);\n    };\n  }, [inputValue]); // Dependency array: re-run effect when inputValue changes\n\n  return (\n    <div style={{ border: '1px solid purple', margin: '5px', padding: '5px' }}>\n      <h4>Debounced Input (useEffect for Updates & Cleanup)</h4>\n      <input\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) => setInputValue(e.target.value)}\n        placeholder=\"Type something...\"\n      />\n      <p>Current Input: {inputValue}</p>\n      <p>Debounced Value: {debouncedValue}</p>\n    </div>\n  );\n};\n\n// Usage:\n// <DebouncedInput />\n",
              "explanation": "This example shows `useEffect` acting as both `componentDidUpdate` and `componentWillUnmount`. The effect runs whenever `inputValue` changes (due to `[inputValue]` in the dependency array). Inside the effect, a debounce timer is set. The return function (`clearTimeout(timerId)`) acts as a cleanup mechanism. If `inputValue` changes again before the 500ms timer elapses, the previous timer is cleared, preventing outdated `debouncedValue` updates. This pattern is common for search inputs, auto-save features, etc.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_hooks_effect_empty_array",
            "question_hooks_effect_no_array",
            "question_hooks_effect_dependency_array",
            "question_hooks_effect_cleanup",
            "question_hooks_useeffect_replacements",
            "question_hooks_usecallback_usememo_role",
            "question_hooks_lifecycle_mapping",
            "question_hooks_state_from_props_equivalent",
            "question_hooks_render_optimization"
          ],
          "relatedTasks": [
            "task_refactor_class_to_hooks_counter",
            "task_refactor_class_to_hooks_data_fetch"
          ],
          "tags": [
            "React",
            "React Hooks",
            "useEffect",
            "useCallback",
            "useMemo",
            "Functional Components",
            "Lifecycle Mapping",
            "Side Effects",
            "Cleanup"
          ],
          "technology": "React",
          "prerequisites": [
            "React Functional Components",
            "State Hook (useState)",
            "JavaScript Closures"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "requiredFor": [
            "Modern React Development",
            "Hooks Best Practices",
            "State Management with Hooks"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_lifecycle_http_location",
          "topic": "Lifecycle Methods: HTTP Requests",
          "level": "easy",
          "type": "mcq",
          "question": "In a React class component, which lifecycle method is the recommended place to make HTTP requests?",
          "answer": "`componentDidMount`",
          "options": [
            "`constructor`",
            "`render`",
            "`componentDidMount`",
            "`componentDidUpdate`"
          ],
          "analysisPoints": [
            "`constructor`: Only for initializing state and binding methods. Side effects like data fetching are not suitable here because the component has not yet mounted to the DOM.",
            "`render`: Should be a pure function that only returns JSX. Making HTTP requests here would cause side effects during rendering, potentially leading to infinite loops or unexpected behavior as it runs on every re-render.",
            "`componentDidMount`: Guarantees the component is mounted to the DOM, making it safe to interact with the DOM or initiate network requests. It runs only once after the initial render.",
            "`componentDidUpdate`: Runs after every update. Making initial HTTP requests here would require complex conditional logic to prevent re-fetching on every update, and it's generally not the primary place for initial data loads."
          ],
          "keyConcepts": [
            "componentDidMount",
            "Lifecycle Methods",
            "Side Effects",
            "Data Fetching"
          ],
          "evaluationCriteria": [
            "Understanding of lifecycle method purposes",
            "Knowledge of best practices for data fetching"
          ],
          "example": "```typescript\nimport React, { Component } from 'react';\n\nclass MyComponent extends Component {\n  componentDidMount() {\n    // This is the best place to make API calls\n    fetch('https://api.example.com/data')\n      .then(response => response.json())\n      .then(data => this.setState({ data }))\n      .catch(error => console.error(error));\n  }\n  render() {\n    return <div>My Component</div>;\n  }\n}\n```",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "componentDidMount",
            "HTTP"
          ],
          "prerequisites": [
            "React Class Components",
            "Basic API calls"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_lifecycle_anti_pattern",
          "topic": "Lifecycle Methods: Updating State from Props",
          "level": "medium",
          "type": "code",
          "question": "The following `componentDidUpdate` implementation leads to an infinite loop. Explain why this happens and provide the corrected version.",
          "answer": "The provided `componentDidUpdate` causes an infinite loop because `this.setState` triggers a re-render, which in turn calls `componentDidUpdate` again, leading to a continuous cycle. The corrected version adds a condition to check if `this.props.items` has actually changed before calling `this.setState`.",
          "options": [],
          "analysisPoints": [
            "Identify the anti-pattern: Calling `setState` unconditionally in `componentDidUpdate`.",
            "Explain the loop mechanism: `setState` -> re-render -> `componentDidUpdate` -> `setState`...",
            "Provide the correct conditional logic: `if (prevProps.items !== this.props.items)`.",
            "Explain `getDerivedStateFromProps` as the preferred modern approach for deriving state from props."
          ],
          "keyConcepts": [
            "componentDidUpdate",
            "setState",
            "Infinite Loop",
            "Props vs State",
            "getDerivedStateFromProps"
          ],
          "evaluationCriteria": [
            "Ability to debug React lifecycle issues",
            "Knowledge of correct state update patterns",
            "Understanding of component re-rendering flow"
          ],
          "example": "```typescript\n// Original problematic code:\nclass MyComponent extends React.Component<{ items: any[] }, { filteredItems: any[] }> {\n  state = { filteredItems: [] };\n\n  componentDidUpdate(prevProps: { items: any[] }) {\n    // PROBLEM: This causes an infinite loop!\n    this.setState({ filteredItems: this.props.items.filter(item => item.active) });\n  }\n  render() { /* ... */ }\n}\n\n// Corrected version using componentDidUpdate:\nclass MyComponentCorrected extends React.Component<{ items: any[] }, { filteredItems: any[] }> {\n  state = { filteredItems: [] };\n\n  componentDidUpdate(prevProps: { items: any[] }) {\n    if (prevProps.items !== this.props.items) {\n      this.setState({ filteredItems: this.props.items.filter(item => item.active) });\n    }\n  }\n  render() { /* ... */ }\n}\n\n// Preferred modern approach using getDerivedStateFromProps:\nclass MyComponentGDSP extends React.Component<{ items: any[] }, { filteredItems: any[]; prevItems: any[] | null }> {\n  constructor(props: { items: any[] }) {\n    super(props);\n    this.state = { filteredItems: [], prevItems: null };\n  }\n\n  static getDerivedStateFromProps(props: { items: any[] }, state: { prevItems: any[] | null }) {\n    if (props.items !== state.prevItems) {\n      return {\n        filteredItems: props.items.filter(item => item.active),\n        prevItems: props.items\n      };\n    }\n    return null;\n  }\n  render() { /* ... */ }\n}\n```",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "componentDidUpdate",
            "State Management",
            "Debugging"
          ],
          "prerequisites": [
            "React Class Components",
            "State and Props"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_getderivedstatefromprops_usage",
          "topic": "Lifecycle Methods: getDerivedStateFromProps",
          "level": "medium",
          "type": "open",
          "question": "Explain the purpose and correct usage of `static getDerivedStateFromProps(props, state)`. What must it return, and what kind of side effects, if any, are allowed within it?",
          "answer": "The `static getDerivedStateFromProps(props, state)` lifecycle method is used to update the component's state based on changes in props. Its primary purpose is to derive new state values from props before a re-render. It is a static method, meaning it does not have access to the component instance (`this`).\n\nIt *must* return an object to update the state, or `null` if no state update is needed. This method is pure; it should not cause any side effects (like network requests, DOM manipulations, or calling `setState`). Its only role is to calculate and return the new state based on props and the current state.",
          "analysisPoints": [
            "Purpose: Derive state from props, triggered on mount and update.",
            "Static nature: No access to `this`.",
            "Return value: An object to update state, or `null` to do nothing.",
            "Purity: Must be side-effect free. No `setState`, no network calls, no DOM interaction."
          ],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "Static Methods",
            "Pure Functions",
            "State Derivation",
            "Lifecycle Methods"
          ],
          "evaluationCriteria": [
            "Detailed explanation of `getDerivedStateFromProps`'s role",
            "Correct understanding of its static nature and return value",
            "Awareness of allowed/disallowed operations (purity)"
          ],
          "example": "```typescript\nimport React, { Component } from 'react';\n\ninterface MyComponentProps {\n  value: number;\n}\n\ninterface MyComponentState {\n  derivedValue: number;\n  lastValue: number | null;\n}\n\nclass MyComponent extends Component<MyComponentProps, MyComponentState> {\n  constructor(props: MyComponentProps) {\n    super(props);\n    this.state = {\n      derivedValue: props.value * 2,\n      lastValue: props.value,\n    };\n  }\n\n  static getDerivedStateFromProps(nextProps: MyComponentProps, prevState: MyComponentState) {\n    // Only update derivedValue if the 'value' prop has actually changed\n    if (nextProps.value !== prevState.lastValue) {\n      return {\n        derivedValue: nextProps.value * 2,\n        lastValue: nextProps.value,\n      };\n    }\n    // No change in 'value' prop, so no state update is needed\n    return null;\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Original Value: {this.props.value}</p>\n        <p>Derived Value (from state): {this.state.derivedValue}</p>\n      </div>\n    );\n  }\n}\n```",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "getDerivedStateFromProps",
            "State Management"
          ],
          "prerequisites": [
            "React Class Components",
            "State and Props"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_shouldcomponentupdate_function",
          "topic": "Lifecycle Methods: shouldComponentUpdate",
          "level": "medium",
          "type": "mcq",
          "question": "Consider a React class component `MyComponent`. If `shouldComponentUpdate` is implemented as shown below, when will `MyComponent` re-render?\n\n```typescript\nclass MyComponent extends React.Component<{ id: number, name: string }, { count: number }> {\n  shouldComponentUpdate(nextProps: { id: number, name: string }, nextState: { count: number }) {\n    return nextProps.id !== this.props.id || nextState.count !== this.state.count;\n  }\n\n  render() {\n    console.log('MyComponent Rendered');\n    return <div>{this.props.name} - {this.props.id} - {this.state.count}</div>;\n  }\n}\n```\n\nA. When `id` prop changes or `count` state changes.\nB. When `name` prop changes or `count` state changes.\nC. Only when `id` prop changes.\nD. When `id`, `name` props or `count` state changes.",
          "answer": "A. When `id` prop changes or `count` state changes.",
          "options": [
            "A. When `id` prop changes or `count` state changes.",
            "B. When `name` prop changes or `count` state changes.",
            "C. Only when `id` prop changes.",
            "D. When `id`, `name` props or `count` state changes."
          ],
          "analysisPoints": [
            "The `shouldComponentUpdate` method explicitly checks `nextProps.id !== this.props.id` and `nextState.count !== this.state.count`.",
            "The `||` (OR) operator means the component will re-render if *either* condition is true.",
            "The `name` prop is explicitly *not* included in the comparison, so changes to `name` alone will *not* trigger a re-render.",
            "This demonstrates how `shouldComponentUpdate` provides granular control over re-rendering."
          ],
          "keyConcepts": [
            "shouldComponentUpdate",
            "Performance Optimization",
            "Component Re-rendering",
            "Props Comparison",
            "State Comparison"
          ],
          "evaluationCriteria": [
            "Understanding of `shouldComponentUpdate`'s return logic",
            "Ability to interpret conditional rendering logic"
          ],
          "example": "The code snippet provided in the question perfectly illustrates the concept. It shows that only explicitly checked props/state changes lead to a re-render.",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "shouldComponentUpdate",
            "Performance"
          ],
          "prerequisites": [
            "React Class Components",
            "Props and State"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_purecomponent_definition",
          "topic": "PureComponent",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference between `React.Component` and `React.PureComponent`?",
          "answer": "`React.PureComponent` automatically implements `shouldComponentUpdate` with a shallow comparison of props and state, whereas `React.Component` does not, always re-rendering by default when parent renders or state/props change.",
          "analysisPoints": [],
          "keyConcepts": [
            "PureComponent",
            "shouldComponentUpdate",
            "Shallow Comparison"
          ],
          "evaluationCriteria": [
            "Recall of core difference"
          ],
          "example": "",
          "tags": [
            "React",
            "PureComponent",
            "Performance"
          ],
          "prerequisites": [
            "React Class Components"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_purecomponent_shallow_comparison",
          "topic": "PureComponent: Shallow Comparison",
          "level": "medium",
          "type": "mcq",
          "question": "A `PureComponent` receives `props.data = { value: 10 }`. In the next render, the parent component passes `props.data = { value: 10 }` again. Will the `PureComponent` re-render if `props.data` refers to a *new* object (even with the same content)?\n\n```typescript\nimport React, { PureComponent } from 'react';\n\ninterface MyProps {\n  data: { value: number };\n}\n\nclass MyPureComponent extends PureComponent<MyProps> {\n  render() {\n    console.log('MyPureComponent Rendered');\n    return <div>Value: {this.props.data.value}</div>;\n  }\n}\n\n// Parent component example:\nclass Parent extends React.Component<{}, { obj: { value: number } }> {\n  state = { obj: { value: 10 } };\n\n  render() {\n    return (\n      <div>\n        <button onClick={() => this.setState({ obj: { value: this.state.obj.value } })}>Update (new object reference)</button>\n        <MyPureComponent data={this.state.obj} />\n      </div>\n    );\n  }\n}\n```\n\nA. No, because the `value` property is the same (10).\nB. Yes, because `PureComponent` performs a deep comparison.\nC. Yes, because `PureComponent` performs a shallow comparison, and the object reference has changed.\nD. No, `PureComponent` would only re-render if the primitive `value` itself changed.",
          "answer": "C. Yes, because `PureComponent` performs a shallow comparison, and the object reference has changed.",
          "options": [
            "A. No, because the `value` property is the same (10).",
            "B. Yes, because `PureComponent` performs a deep comparison.",
            "C. Yes, because `PureComponent` performs a shallow comparison, and the object reference has changed.",
            "D. No, `PureComponent` would only re-render if the primitive `value` itself changed."
          ],
          "analysisPoints": [
            "`PureComponent` relies on shallow comparison.",
            "For objects and arrays, shallow comparison checks if the references are identical (`===`).",
            "Even if the *content* of the object is the same, if it's a *new object instance* (different reference), `PureComponent` considers it a change and re-renders.",
            "This is a common gotcha with `PureComponent` and `React.memo` when dealing with non-primitive props."
          ],
          "keyConcepts": [
            "PureComponent",
            "Shallow Comparison",
            "Object References",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Understanding of shallow comparison for objects",
            "Recognition of reference vs. value equality"
          ],
          "example": "The provided code snippet and explanation clearly demonstrate this behavior.",
          "tags": [
            "React",
            "PureComponent",
            "Shallow Comparison",
            "Performance",
            "Gotchas"
          ],
          "prerequisites": [
            "PureComponent",
            "JavaScript Object References"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_memo_purpose",
          "topic": "React.memo",
          "level": "easy",
          "type": "flashcard",
          "question": "What is `React.memo` used for, and what type of components does it optimize?",
          "answer": "`React.memo` is a Higher-Order Component (HOC) used for memoizing functional components. It optimizes performance by preventing unnecessary re-renders of functional components if their props have not shallowly changed.",
          "analysisPoints": [],
          "keyConcepts": [
            "React.memo",
            "Memoization",
            "Functional Components",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Recall of purpose and target components"
          ],
          "example": "",
          "tags": [
            "React",
            "React.memo",
            "Functional Components",
            "Performance"
          ],
          "prerequisites": [
            "React Functional Components"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_react_memo_vs_purecomponent",
          "topic": "React.memo vs. PureComponent",
          "level": "medium",
          "type": "open",
          "question": "Compare `React.memo` and `React.PureComponent`. What are their similarities and key differences, particularly regarding the components they apply to and their underlying optimization mechanism?",
          "answer": "### Similarities:\n*   Both `React.memo` and `React.PureComponent` are used for performance optimization in React by preventing unnecessary re-renders.\n*   Both implement a default *shallow comparison* of props (and state for `PureComponent`) to determine if a re-render is necessary. If the props/state are shallowly equal, the render is skipped.\n\n### Key Differences:\n*   **Component Type:** `React.PureComponent` is a base class used for *class components*. `React.memo` is a Higher-Order Component (HOC) used for *functional components*.\n*   **State Comparison:** `React.PureComponent` performs a shallow comparison on *both props and state*. `React.memo` *only* performs a shallow comparison on *props* (functional components manage state with hooks like `useState`, which inherently handles state updates efficiently).\n*   **Custom Comparison:** `React.PureComponent` can be overridden by implementing `shouldComponentUpdate` manually. `React.memo` allows for a custom comparison function as its second argument, which offers similar granular control.\n\nIn essence, `React.memo` is the functional component equivalent to `React.PureComponent`'s default behavior.",
          "analysisPoints": [
            "Similarities: Performance optimization, shallow comparison.",
            "Differences: Class vs. functional components.",
            "Differences: PureComponent checks state and props, memo only props (as state is managed differently).",
            "Differences: How custom comparison/rendering logic is applied (shouldComponentUpdate vs. second arg to memo)."
          ],
          "keyConcepts": [
            "React.memo",
            "PureComponent",
            "Shallow Comparison",
            "Functional Components",
            "Class Components",
            "Higher-Order Components",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Clear distinction between class and functional component application",
            "Accurate explanation of shallow comparison scope",
            "Understanding of their respective roles in optimization"
          ],
          "example": "```typescript\n// PureComponent (Class Component)\nclass MyClassComponent extends React.PureComponent<{ value: number }> {\n  render() { return <div>Class Value: {this.props.value}</div>; }\n}\n\n// React.memo (Functional Component)\nconst MyFunctionComponent = React.memo((props: { value: number }) => {\n  return <div>Function Value: {props.value}</div>;\n});\n```",
          "tags": [
            "React",
            "React.memo",
            "PureComponent",
            "Comparison",
            "Functional Components",
            "Class Components"
          ],
          "prerequisites": [
            "React Class Components",
            "React Functional Components",
            "Memoization"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_memo_custom_comparison_return",
          "topic": "React.memo: Custom Comparison",
          "level": "medium",
          "type": "mcq",
          "question": "When providing a custom comparison function to `React.memo`, what should the function return to prevent the component from re-rendering?",
          "answer": "True",
          "options": [
            "True",
            "False",
            "Null",
            "Undefined"
          ],
          "analysisPoints": [
            "The custom comparison function for `React.memo` (`(prevProps, nextProps) => boolean`) returns `true` if the props are *equal*, meaning React should *skip* the re-render.",
            "This is the opposite logic of `shouldComponentUpdate` which returns `true` to *allow* a re-render.",
            "Understanding this inverse logic is crucial to correctly implementing custom memoization."
          ],
          "keyConcepts": [
            "React.memo",
            "Custom Comparison",
            "Memoization",
            "Performance Optimization",
            "shouldComponentUpdate vs. React.memo callback"
          ],
          "evaluationCriteria": [
            "Knowledge of `React.memo`'s custom comparison signature",
            "Correct interpretation of its return value for re-rendering control"
          ],
          "example": "```typescript\nconst MyComponent = React.memo(\n  function MyComponent(props: { id: number; name: string }) {\n    console.log('MyComponent Rendered');\n    return <div>{props.name} - {props.id}</div>;\n  },\n  // Returns true if props are EQUAL (skip re-render), false if DIFFERENT (re-render)\n  (prevProps, nextProps) => prevProps.id === nextProps.id && prevProps.name === nextProps.name\n);\n```",
          "tags": [
            "React",
            "React.memo",
            "Custom Comparison",
            "Functional Components"
          ],
          "prerequisites": [
            "React.memo"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_effect_empty_array",
          "topic": "Hooks: useEffect",
          "level": "easy",
          "type": "flashcard",
          "question": "How do you use `useEffect` to replicate the behavior of `componentDidMount` in a functional component?",
          "answer": "By providing an empty dependency array (`[]`) as the second argument to `useEffect`. This ensures the effect runs only once after the initial render.",
          "analysisPoints": [],
          "keyConcepts": [
            "useEffect",
            "componentDidMount",
            "Dependency Array",
            "Hooks"
          ],
          "evaluationCriteria": [
            "Recall of basic useEffect usage"
          ],
          "example": "```typescript\nimport React, { useEffect } from 'react';\n\nfunction MyComponent() {\n  useEffect(() => {\n    console.log('Component Mounted!');\n    // This code runs once, similar to componentDidMount\n  }, []); // Empty dependency array\n  return <div>Hello</div>;\n}\n```",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "componentDidMount"
          ],
          "prerequisites": [
            "React Functional Components"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_hooks_effect_cleanup",
          "topic": "Hooks: useEffect Cleanup",
          "level": "medium",
          "type": "open",
          "question": "Explain how `useEffect` can be used to perform cleanup operations, similar to `componentWillUnmount`. Provide a simple code example.",
          "answer": "`useEffect` can perform cleanup operations by returning a function from the effect callback. This returned function will be executed when the component unmounts, or before the effect re-runs due to a change in its dependencies. This mechanism is ideal for unsubscribing from event listeners, clearing timers, or canceling network requests to prevent memory leaks or unexpected behavior.\n\nExample:\n```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction TimerComponent() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Setting up timer...');\n    const intervalId = setInterval(() => {\n      setCount(prevCount => prevCount + 1);\n    }, 1000);\n\n    // Cleanup function: runs on unmount or before the effect re-runs\n    return () => {\n      console.log('Cleaning up timer...');\n      clearInterval(intervalId);\n    };\n  }, []); // Empty dependency array means the effect runs once on mount, and cleanup on unmount\n\n  return <div>Timer: {count}</div>;\n}\n```\nIn this example, `clearInterval(intervalId)` will be called when `TimerComponent` is unmounted from the DOM, preventing the timer from continuing to run in the background and updating state on a non-existent component, which would lead to memory leaks.",
          "analysisPoints": [
            "Cleanup is done by returning a function from the `useEffect` callback.",
            "This function runs on unmount and before subsequent effect re-runs.",
            "Common use cases: unsubscribing, clearing timers, canceling requests.",
            "Prevents memory leaks and side effects on unmounted components."
          ],
          "keyConcepts": [
            "useEffect",
            "Cleanup Function",
            "componentWillUnmount",
            "Side Effects",
            "Memory Leaks"
          ],
          "evaluationCriteria": [
            "Correct understanding of `useEffect`'s return value for cleanup",
            "Ability to provide a relevant code example",
            "Explanation of the benefits of cleanup"
          ],
          "example": "The code snippet provided in the answer serves as the example.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Cleanup",
            "componentWillUnmount",
            "Memory Management"
          ],
          "prerequisites": [
            "React Functional Components",
            "useState"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_lifecycle_mapping",
          "topic": "Hooks: Lifecycle Mapping",
          "level": "hard",
          "type": "code",
          "question": "Given the following class component with various lifecycle methods, refactor it into a functional component using React Hooks, specifically `useState`, `useEffect`, `useCallback`, and `useMemo` where appropriate. Explain how each original lifecycle responsibility is mapped to hooks.\n\n```typescript\nimport React, { Component } from 'react';\n\ninterface ClassComponentProps {\n  userId: number;\n  onUserClick: (id: number) => void;\n}\n\ninterface ClassComponentState {\n  userData: any | null;\n  loading: boolean;\n  internalCounter: number;\n}\n\nclass MyComplexClassComponent extends Component<ClassComponentProps, ClassComponentState> {\n  private intervalId: number | undefined;\n\n  constructor(props: ClassComponentProps) {\n    super(props);\n    this.state = {\n      userData: null,\n      loading: true,\n      internalCounter: 0,\n    };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  componentDidMount() {\n    console.log('ClassComponent: componentDidMount - Fetching data');\n    this.fetchUserData(this.props.userId);\n    this.intervalId = window.setInterval(() => {\n      this.setState(prevState => ({ internalCounter: prevState.internalCounter + 1 }));\n    }, 1000);\n  }\n\n  componentDidUpdate(prevProps: ClassComponentProps, prevState: ClassComponentState) {\n    console.log('ClassComponent: componentDidUpdate');\n    if (prevProps.userId !== this.props.userId) {\n      console.log('ClassComponent: userId changed, re-fetching data');\n      this.fetchUserData(this.props.userId);\n    }\n    if (prevState.internalCounter !== this.state.internalCounter) {\n      console.log(`ClassComponent: Counter updated to ${this.state.internalCounter}`);\n    }\n  }\n\n  componentWillUnmount() {\n    console.log('ClassComponent: componentWillUnmount - Clearing interval');\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  fetchUserData = async (userId: number) => {\n    this.setState({ loading: true });\n    try {\n      const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);\n      const data = await response.json();\n      this.setState({ userData: data, loading: false });\n    } catch (error) {\n      console.error('Error fetching user data:', error);\n      this.setState({ loading: false, userData: null });\n    }\n  };\n\n  handleClick() {\n    this.props.onUserClick(this.props.userId);\n  }\n\n  render() {\n    const { userData, loading, internalCounter } = this.state;\n    const { userId } = this.props;\n\n    if (loading) return <div>Loading user data...</div>;\n    if (!userData) return <div>Failed to load user data.</div>;\n\n    return (\n      <div style={{ border: '2px solid navy', padding: '15px', margin: '15px' }}>\n        <h3>User Profile (Class Component)</h3>\n        <p>User ID: {userId}</p>\n        <p>Name: {userData.name}</p>\n        <p>Email: {userData.email}</p>\n        <p>Counter: {internalCounter}</p>\n        <button onClick={this.handleClick}>View Details (Class)</button>\n      </div>\n    );\n  }\n}\n```",
          "answer": "```typescript\nimport React, { useState, useEffect, useCallback, useMemo } from 'react';\n\ninterface FunctionalComponentProps {\n  userId: number;\n  onUserClick: (id: number) => void;\n}\n\nconst MyComplexFunctionalComponent: React.FC<FunctionalComponentProps> = ({ userId, onUserClick }) => {\n  const [userData, setUserData] = useState<any | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [internalCounter, setInternalCounter] = useState(0);\n\n  // componentDidMount + componentDidUpdate (for userId change) + Cleanup\n  useEffect(() => {\n    console.log('FunctionalComponent: useEffect for data fetching (mount + userId change)');\n    const fetchUserData = async () => {\n      setLoading(true);\n      try {\n        const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        setUserData(data);\n      } catch (error) {\n        console.error('Error fetching user data:', error);\n        setUserData(null);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchUserData();\n\n    // Cleanup for data fetching (e.g., abort controller if fetch was cancellable)\n    // For this simple fetch, no explicit cleanup needed, but conceptually it would be here.\n\n  }, [userId]); // Dependency array: re-run effect when userId changes\n\n  // componentDidMount + componentWillUnmount (for interval)\n  useEffect(() => {\n    console.log('FunctionalComponent: useEffect for interval (mount + unmount cleanup)');\n    const intervalId = window.setInterval(() => {\n      setInternalCounter(prevCount => prevCount + 1);\n    }, 1000);\n\n    // Cleanup function: clears interval on unmount or before re-running (if dependencies existed)\n    return () => {\n      console.log('FunctionalComponent: Clearing interval on unmount');\n      clearInterval(intervalId);\n    };\n  }, []); // Empty dependency array: runs once on mount, cleanup on unmount\n\n  // Mimic componentDidUpdate for internalCounter for logging purposes (optional)\n  useEffect(() => {\n    if (internalCounter > 0) { // To prevent running on initial mount\n        console.log(`FunctionalComponent: Counter updated to ${internalCounter}`);\n    }\n  }, [internalCounter]);\n\n  // Memoize handleClick function to prevent unnecessary re-creation\n  // Similar to binding in constructor, but for functional components\n  const handleClick = useCallback(() => {\n    onUserClick(userId);\n  }, [onUserClick, userId]); // Dependencies for useCallback\n\n  // Memoize derived data or expensive calculations if needed (not strictly required here)\n  const displayUserName = useMemo(() => {\n      if (!userData) return 'N/A';\n      console.log('FunctionalComponent: Recomputing display user name');\n      return userData.name.toUpperCase(); // Example of expensive computation\n  }, [userData]); // Recompute only if userData changes\n\n  if (loading) return <div>Loading user data...</div>;\n  if (!userData) return <div>Failed to load user data.</div>;\n\n  return (\n    <div style={{ border: '2px solid green', padding: '15px', margin: '15px' }}>\n      <h3>User Profile (Functional Component - Hooks)</h3>\n      <p>User ID: {userId}</p>\n      <p>Name: {displayUserName}</p>\n      <p>Email: {userData.email}</p>\n      <p>Counter: {internalCounter}</p>\n      <button onClick={handleClick}>View Details (Hooks)</button>\n    </div>\n  );\n};\n```\n\n### Mapping Explanation:\n*   **State (`userData`, `loading`, `internalCounter`)**: All state variables are managed using the `useState` hook. Each call to `useState` initializes a piece of state and provides a setter function.\n*   **`componentDidMount` (Initial Data Fetching & Interval Setup)**:\n    *   The data fetching logic is moved into a `useEffect` hook with `[userId]` as its dependency array. On initial mount, `userId` is available, so it fetches the data. If `userId` ever changes, it re-runs, serving as the `componentDidUpdate` equivalent for `userId` changes.\n    *   The `setInterval` logic is placed in a separate `useEffect` hook with an empty dependency array (`[]`). This ensures it runs only once after the initial render. Its cleanup function (`return () => clearInterval(intervalId);`) handles `componentWillUnmount` behavior for the interval.\n*   **`componentDidUpdate` (Conditional Data Re-fetching)**: This responsibility is integrated into the first `useEffect` hook by including `userId` in its dependency array. The effect will re-run whenever `userId` changes, effectively replacing the `if (prevProps.userId !== this.props.userId)` check.\n*   **`componentWillUnmount` (Clearing Interval)**: The cleanup function returned by the second `useEffect` hook (the one managing the interval) directly replaces `componentWillUnmount`'s responsibility for clearing the interval.\n*   **Method Binding (`handleClick`)**: In class components, `this.handleClick = this.handleClick.bind(this)` is often used for method binding. In functional components, `useCallback` is used to memoize functions (`handleClick` in this case). This prevents the function from being re-created on every render, which is beneficial when passing it as a prop to child components (especially memoized ones) to prevent unnecessary re-renders of children.\n*   **Derived Data/Expensive Calculations (e.g., `displayUserName`)**: While not explicitly in the original class component's lifecycle methods, for optimizing derived values or expensive computations that depend on specific state/props, `useMemo` is used. It memoizes the result and only re-computes if its dependencies change, similar to `shouldComponentUpdate` for values.",
          "analysisPoints": [
            "Correctly identifies `useState` for all state variables.",
            "Maps `componentDidMount` to `useEffect` with `[]`.",
            "Maps `componentDidUpdate` conditional logic to `useEffect` with specific dependencies.",
            "Maps `componentWillUnmount` to `useEffect`'s cleanup return function.",
            "Uses `useCallback` for memoizing event handlers.",
            "Uses `useMemo` for memoizing derived values (optional but good practice for completeness).",
            "Explains the rationale for each hook mapping.",
            "Handles the interval cleanup correctly."
          ],
          "keyConcepts": [
            "React Hooks",
            "useState",
            "useEffect",
            "useCallback",
            "useMemo",
            "Class to Functional Component Refactoring",
            "Lifecycle Methods",
            "Side Effects",
            "Memoization"
          ],
          "evaluationCriteria": [
            "Accuracy of hook usage for lifecycle responsibilities",
            "Correct handling of dependencies in `useEffect` and `useCallback`/`useMemo`",
            "Clarity of explanation for mapping concepts",
            "Ability to implement practical, performant hooks solution"
          ],
          "example": "The provided refactored code and detailed explanation.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "useState",
            "useCallback",
            "useMemo",
            "Refactoring",
            "Class Components",
            "Functional Components",
            "Advanced"
          ],
          "prerequisites": [
            "All React Hooks",
            "Class Component Lifecycles"
          ],
          "complexity": 9,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_lifecycle_order_of_methods",
          "topic": "Lifecycle Methods Order",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following represents the correct order of execution for these React class component lifecycle methods during the initial mounting phase?",
          "answer": "constructor -> static getDerivedStateFromProps -> render -> componentDidMount",
          "options": [
            "constructor -> render -> componentDidMount -> componentDidUpdate",
            "constructor -> static getDerivedStateFromProps -> render -> componentDidMount",
            "static getDerivedStateFromProps -> constructor -> render -> componentDidMount",
            "render -> componentDidMount -> constructor -> componentDidUpdate"
          ],
          "analysisPoints": [
            "During mounting, the sequence starts with `constructor` for initialization.",
            "Then `static getDerivedStateFromProps` is called to update state based on props before rendering.",
            "`render` is then called to create the React elements.",
            "Finally, `componentDidMount` is called after the component has been rendered to the DOM.",
            "`componentDidUpdate` is not part of the initial mounting phase."
          ],
          "keyConcepts": [
            "Lifecycle Methods",
            "Mounting Phase",
            "constructor",
            "getDerivedStateFromProps",
            "render",
            "componentDidMount"
          ],
          "evaluationCriteria": [
            "Knowledge of React component lifecycle phases",
            "Correct ordering of mounting lifecycle methods"
          ],
          "example": "```typescript\nimport React, { Component } from 'react';\n\nclass LifecycleOrderComponent extends Component {\n  constructor(props: {}) {\n    super(props);\n    console.log('1. Constructor');\n    this.state = {};\n  }\n\n  static getDerivedStateFromProps(props: {}, state: {}) {\n    console.log('2. static getDerivedStateFromProps');\n    return null; // Or return state update\n  }\n\n  componentDidMount() {\n    console.log('4. componentDidMount');\n  }\n\n  render() {\n    console.log('3. Render');\n    return <div>Check console for order.</div>;\n  }\n}\n// When <LifecycleOrderComponent /> is mounted, the console will show the expected order.\n```",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "Mounting"
          ],
          "prerequisites": [
            "React Class Components"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_api_call_why_cdm",
          "topic": "Lifecycle Methods: Data Fetching Rationale",
          "level": "medium",
          "type": "open",
          "question": "Why is `componentDidMount` considered the 'best place' for API calls in a React class component, rather than the `constructor` or `render` method?",
          "answer": "`componentDidMount` is the best place for API calls because:\n1.  **Component is Mounted:** At this point, the component has been rendered to the DOM, and it's safe to perform operations that interact with the DOM or require the component to be fully initialized.\n2.  **Prevents Unnecessary Renders/Loops:** Unlike `render`, which runs on every update, `componentDidMount` runs only once after the initial render. Placing API calls here prevents the component from re-fetching data on every re-render (which `render` would do) or getting into infinite loops (`setState` in `render` or unconditional `setState` in `componentDidUpdate`).\n3.  **State Available:** You can safely call `this.setState` within `componentDidMount` to update the component's state with the fetched data, triggering a re-render with the new data. In the `constructor`, `setState` is not available, and directly modifying `this.state` outside of `constructor` is an anti-pattern.\n\nIn contrast:\n*   **`constructor`**: Used only for initial state setup and method binding. The component is not yet mounted to the DOM, so side effects like API calls are inappropriate and cannot update the rendered UI immediately.\n*   **`render`**: Must be a pure function. Side effects like API calls are prohibited as they can lead to unpredictable behavior, performance issues, and infinite re-render loops.",
          "analysisPoints": [
            "Component mounted status.",
            "Prevention of infinite loops/unnecessary fetches.",
            "Availability of `setState`.",
            "Purity of `render` method.",
            "Limitations of `constructor` for side effects."
          ],
          "keyConcepts": [
            "componentDidMount",
            "constructor",
            "render",
            "Side Effects",
            "Data Fetching",
            "Lifecycle Phases",
            "Performance"
          ],
          "evaluationCriteria": [
            "Comprehensive explanation of reasons for `componentDidMount`",
            "Clear contrast with `constructor` and `render`",
            "Understanding of side effects in React"
          ],
          "example": "See `theory_lifecycle_best_practices` and `example_lifecycle_http_request` for context.",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "componentDidMount",
            "Data Fetching",
            "Best Practices"
          ],
          "prerequisites": [
            "React Class Components",
            "Lifecycle Overview"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_lifecycle_props_to_state_pattern",
          "topic": "Lifecycle Methods: Prop-to-State Derivation",
          "level": "medium",
          "type": "flashcard",
          "question": "You have a class component where part of its state should be derived from props, and updated whenever those props change. What is the recommended lifecycle method for this pattern, and why not use `componentDidUpdate` unconditionally?",
          "answer": "The recommended lifecycle method is `static getDerivedStateFromProps`. You should not use `componentDidUpdate` unconditionally because calling `this.setState` inside it without a condition comparing `prevProps` to `this.props` would lead to an infinite re-render loop.",
          "analysisPoints": [],
          "keyConcepts": [
            "getDerivedStateFromProps",
            "componentDidUpdate",
            "Prop-Derived State",
            "Infinite Loop",
            "Lifecycle Patterns"
          ],
          "evaluationCriteria": [
            "Recall of recommended pattern and anti-pattern"
          ],
          "example": "See `example_lifecycle_update_props` for reference.",
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "getDerivedStateFromProps",
            "componentDidUpdate",
            "State Management"
          ],
          "prerequisites": [
            "React Class Components",
            "State and Props"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_hooks_effect_no_array",
          "topic": "Hooks: useEffect without Dependency Array",
          "level": "easy",
          "type": "mcq",
          "question": "What is the behavior of a `useEffect` hook if no dependency array is provided?",
          "answer": "It runs after every render, on both mount and every update.",
          "options": [
            "It runs only once on mount, like `componentDidMount`.",
            "It runs after every render, on both mount and every update.",
            "It throws an error, as a dependency array is always required.",
            "It only runs if the component's state changes, but not if props change."
          ],
          "analysisPoints": [
            "Omitting the dependency array means the effect runs after *every* successful render cycle.",
            "This is generally discouraged due to potential performance issues or infinite loops if the effect modifies state without a proper condition."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Side Effects",
            "Performance"
          ],
          "evaluationCriteria": [
            "Understanding of `useEffect`'s default behavior",
            "Knowledge of dependency array's importance"
          ],
          "example": "```typescript\nimport React, { useEffect, useState } from 'react';\n\nfunction LoggerComponent() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Effect without dependency array (runs on every render)');\n  }); // No dependency array\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\n      <p>Count: {count}</p>\n    </div>\n  );\n}\n// Every click will cause 'Effect without dependency array' to log.\n```",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Dependency Array"
          ],
          "prerequisites": [
            "React Hooks"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_hooks_effect_dependency_array",
          "topic": "Hooks: useEffect with Dependency Array",
          "level": "medium",
          "type": "open",
          "question": "Describe the role of the dependency array in `useEffect`. How does it influence when the effect function executes, and what is the consequence of incorrectly specifying or omitting dependencies?",
          "answer": "The dependency array (the second argument to `useEffect`) controls when the effect function re-executes. React will re-run the effect only if any of the values in the dependency array have changed between renders (compared using strict equality, `===`).\n\n*   **Empty array (`[]`)**: The effect runs only once after the initial render and the cleanup function runs only on unmount. This is similar to `componentDidMount`.\n*   **No array (omitted)**: The effect runs after every render (mount and all updates). This is rarely what you want and can lead to performance issues or infinite loops.\n*   **Array with values (`[dep1, dep2]`)**: The effect runs after the initial render and then re-runs whenever `dep1` or `dep2` (or both) change. The cleanup function runs before the new effect is applied and also on unmount.\n\n**Consequences of incorrect dependencies:**\n*   **Omitting a dependency that *is* used inside the effect**: Leads to stale closures. The effect might capture old values of state or props from the render when it was first created, even if those values have since changed. This can result in bugs, incorrect calculations, or outdated UI.\n*   **Including too many dependencies**: Causes the effect to run more often than necessary, potentially leading to performance bottlenecks from unnecessary re-renders or side effects. This can negate the benefits of memoization.",
          "analysisPoints": [
            "Control execution frequency based on changes.",
            "Behavior with empty array (`[]`).",
            "Behavior with no array.",
            "Behavior with specific dependencies.",
            "Consequence of missing dependencies (stale closures).",
            "Consequence of too many dependencies (over-rendering)."
          ],
          "keyConcepts": [
            "useEffect",
            "Dependency Array",
            "Stale Closures",
            "Performance Optimization",
            "Side Effects",
            "Hooks Best Practices"
          ],
          "evaluationCriteria": [
            "Thorough explanation of dependency array's role",
            "Clear differentiation of behaviors based on array content",
            "Accurate description of consequences of incorrect dependencies"
          ],
          "example": "See `theory_hooks_replacing_lifecycles` for code examples.",
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Dependency Array",
            "Best Practices",
            "Debugging"
          ],
          "prerequisites": [
            "React Hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_hooks_usecallback_usememo_role",
          "topic": "Hooks: useCallback and useMemo",
          "level": "medium",
          "type": "open",
          "question": "Explain the role of `useCallback` and `useMemo` in conjunction with `React.memo` for optimizing functional components. When and why would you use them?",
          "answer": "`useCallback` and `useMemo` are memoization hooks that work in tandem with `React.memo` to optimize functional components by ensuring stable references for functions and values, respectively.\n\n*   **`useCallback`**: This hook memoizes a *function*. When a functional component re-renders, any function defined inside it is re-created, leading to a new reference. If this function is passed as a prop to a child component wrapped in `React.memo`, the child would unnecessarily re-render because `React.memo`'s shallow comparison would see a new function reference. `useCallback` returns a memoized version of the callback function that only changes if one of its dependencies has changed. This prevents child components from re-rendering just because a function prop's reference changed.\n    *   **When to use**: When passing callback functions to optimized child components (e.g., `React.memo`, `PureComponent`), or when a function is a dependency of another `useEffect` or `useMemo` hook.\n\n*   **`useMemo`**: This hook memoizes a *value* (the result of a computation). Similar to functions, objects and arrays created inline during a render will have a new reference on every re-render, even if their content is identical. If such an object/array is passed as a prop to a `React.memo`'d child, it would cause an unnecessary re-render. `useMemo` computes its value only when one of its dependencies changes. It returns the memoized value.\n    *   **When to use**: For expensive calculations whose results are stable across renders, or when passing objects/arrays as props to optimized child components to ensure a stable reference.\n\n**Why use them?** They prevent `React.memo` (and `PureComponent`) from failing its shallow comparison due to constantly changing references of non-primitive props (functions, objects, arrays), thereby ensuring that memoized components only re-render when their *relevant* props truly change, leading to better performance.",
          "analysisPoints": [
            "Define `useCallback` (memoizes functions).",
            "Define `useMemo` (memoizes values/results).",
            "Explain how they prevent reference changes from triggering `React.memo` re-renders.",
            "Provide clear use cases for each.",
            "Emphasize their role in conjunction with `React.memo` for effective optimization."
          ],
          "keyConcepts": [
            "useCallback",
            "useMemo",
            "React.memo",
            "Memoization",
            "Performance Optimization",
            "Stable References",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Accurate definitions and distinctions between the two hooks",
            "Clear explanation of their purpose in optimization",
            "Understanding of their relationship with `React.memo`"
          ],
          "example": "See `theory_hooks_replacing_lifecycles` for example snippets.",
          "tags": [
            "React",
            "Hooks",
            "useCallback",
            "useMemo",
            "React.memo",
            "Performance",
            "Optimization"
          ],
          "prerequisites": [
            "React Hooks",
            "React.memo"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_data_fetching_component",
          "title": "Implement a Basic Data Fetching Component (Class Component)",
          "description": "\nCreate a React class component that fetches a list of items from a public API (`https://jsonplaceholder.typicode.com/todos?_limit=5`) and displays them. The component should:\n\n1.  Initialize state to handle `todos` (an empty array), `loading` (true), and `error` (null).\n2.  Perform the API call in the correct lifecycle method.\n3.  Update the state based on the fetch result (success or error).\n4.  Render a 'Loading...' message while fetching.\n5.  Render an 'Error: [message]' if the fetch fails.\n6.  Render the list of fetched todo titles once successful.\n",
          "difficulty": "medium",
          "startingCode": "import React, { Component } from 'react';\n\ninterface Todo {\n  userId: number;\n  id: number;\n  title: string;\n  completed: boolean;\n}\n\ninterface TodoListState {\n  todos: Todo[];\n  loading: boolean;\n  error: Error | null;\n}\n\nclass TodoListFetcher extends Component<{}, TodoListState> {\n  constructor(props: {}) {\n    super(props);\n    this.state = {\n      todos: [],\n      loading: true,\n      error: null,\n    };\n  }\n\n  // TODO: Implement componentDidMount for API call\n\n  render() {\n    const { todos, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading todos...</div>;\n    }\n\n    if (error) {\n      return <div>Error: {error.message}</div>;\n    }\n\n    return (\n      <div>\n        <h2>Fetched Todos</h2>\n        <ul>\n          {todos.map(todo => (\n            <li key={todo.id}>{todo.title}</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\nexport default TodoListFetcher;\n",
          "solutionCode": "import React, { Component } from 'react';\n\ninterface Todo {\n  userId: number;\n  id: number;\n  title: string;\n  completed: boolean;\n}\n\ninterface TodoListState {\n  todos: Todo[];\n  loading: boolean;\n  error: Error | null;\n}\n\nclass TodoListFetcher extends Component<{}, TodoListState> {\n  constructor(props: {}) {\n    super(props);\n    this.state = {\n      todos: [],\n      loading: true,\n      error: null,\n    };\n  }\n\n  componentDidMount() {\n    console.log('Fetching todos...');\n    fetch('https://jsonplaceholder.typicode.com/todos?_limit=5')\n      .then(response => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then((data: Todo[]) => {\n        this.setState({ todos: data, loading: false });\n        console.log('Todos fetched successfully.');\n      })\n      .catch(error => {\n        this.setState({ error, loading: false });\n        console.error('Error fetching todos:', error);\n      });\n  }\n\n  render() {\n    const { todos, loading, error } = this.state;\n\n    if (loading) {\n      return <div>Loading todos...</div>;\n    }\n\n    if (error) {\n      return <div>Error: {error.message}</div>;\n    }\n\n    return (\n      <div>\n        <h2>Fetched Todos</h2>\n        <ul>\n          {todos.map(todo => (\n            <li key={todo.id}>{todo.title}</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\nexport default TodoListFetcher;\n",
          "testCases": [
            "Component should display 'Loading todos...' initially.",
            "After successful fetch, component should display 5 todo titles.",
            "If fetch fails (e.g., API returns 404), component should display an error message.",
            "Network request should only occur once upon component mount."
          ],
          "hints": [
            "Remember to place network requests in `componentDidMount`.",
            "Handle both success (`.then()`) and error (`.catch()`) cases for the `fetch` promise.",
            "Update the `loading` state to `false` in both success and error handlers.",
            "Ensure `this.setState` is used correctly to update state."
          ],
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "componentDidMount",
            "Data Fetching",
            "State Management"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "React Class Components",
            "Fetch API",
            "State and Props"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "beginner",
          "relatedConcepts": [
            "componentDidMount",
            "State Management",
            "Error Handling"
          ]
        },
        {
          "id": "task_filterable_list_gdsfp",
          "title": "Implement a Filterable List with Prop-Derived State (Class Component)",
          "description": "\nCreate a React class component named `FilterableItemList` that displays a filtered list of items. The component should:\n\n1.  Accept an array of `items` as a prop. Each item has `id: number`, `name: string`, and `isActive: boolean`.\n2.  Maintain a state variable `filteredItems` that contains only the `isActive: true` items from the `items` prop.\n3.  Use `static getDerivedStateFromProps` to update `filteredItems` whenever the `items` prop changes. Ensure it correctly handles initial mount and subsequent prop updates.\n4.  The component should only re-derive state if the `items` prop array reference itself changes. You'll need to store the previous `items` prop in state to achieve this correctly.\n5.  Render the `filteredItems`.\n",
          "difficulty": "medium",
          "startingCode": "import React, { Component } from 'react';\n\ninterface Item {\n  id: number;\n  name: string;\n  isActive: boolean;\n}\n\ninterface FilterableItemListProps {\n  items: Item[];\n}\n\ninterface FilterableItemListState {\n  filteredItems: Item[];\n  // TODO: Add state to track previous items prop for comparison\n  prevItemsProp: Item[] | null;\n}\n\nclass FilterableItemList extends Component<FilterableItemListProps, FilterableItemListState> {\n  constructor(props: FilterableItemListProps) {\n    super(props);\n    this.state = {\n      filteredItems: [],\n      prevItemsProp: null,\n    };\n  }\n\n  // TODO: Implement static getDerivedStateFromProps\n  // It should update filteredItems ONLY if props.items has changed\n  // Remember to store the current props.items for the next comparison\n\n  render() {\n    return (\n      <div>\n        <h3>Filtered Items</h3>\n        {this.state.filteredItems.length === 0 ? (\n          <p>No active items.</p>\n        ) : (\n          <ul>\n            {this.state.filteredItems.map(item => (\n              <li key={item.id}>{item.name}</li>\n            ))}\n          </ul>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default FilterableItemList;\n",
          "solutionCode": "import React, { Component } from 'react';\n\ninterface Item {\n  id: number;\n  name: string;\n  isActive: boolean;\n}\n\ninterface FilterableItemListProps {\n  items: Item[];\n}\n\ninterface FilterableItemListState {\n  filteredItems: Item[];\n  prevItemsProp: Item[] | null; // Used to track previous items prop\n}\n\nclass FilterableItemList extends Component<FilterableItemListProps, FilterableItemListState> {\n  constructor(props: FilterableItemListProps) {\n    super(props);\n    this.state = {\n      filteredItems: [],\n      prevItemsProp: null,\n    };\n  }\n\n  static getDerivedStateFromProps(nextProps: FilterableItemListProps, prevState: FilterableItemListState) {\n    // Check if the items prop has changed (by reference)\n    if (nextProps.items !== prevState.prevItemsProp) {\n      console.log('getDerivedStateFromProps: Items prop changed, recalculating filteredItems');\n      return {\n        filteredItems: nextProps.items.filter(item => item.isActive),\n        prevItemsProp: nextProps.items, // Update prevItemsProp for the next comparison\n      };\n    }\n    // If items prop has not changed, return null to indicate no state update\n    return null;\n  }\n\n  render() {\n    return (\n      <div style={{ border: '1px solid gray', padding: '10px', margin: '10px' }}>\n        <h3>Filtered Items (Active)</h3>\n        {this.state.filteredItems.length === 0 ? (\n          <p>No active items.</p>\n        ) : (\n          <ul>\n            {this.state.filteredItems.map(item => (\n              <li key={item.id}>{item.name}</li>\n            ))}\n          </ul>\n        )}\n      </div>\n    );\n  }\n}\n\nexport default FilterableItemList;\n",
          "testCases": [
            "Initial render: If `items` prop contains active items, `filteredItems` should correctly reflect them.",
            "Prop update (same reference): If parent re-renders passing the *same* `items` array reference, `getDerivedStateFromProps` should return `null` and not re-calculate.",
            "Prop update (new reference): If parent passes a *new* `items` array reference (even if contents are similar), `getDerivedStateFromProps` should correctly re-filter and update `filteredItems`.",
            "Prop update (no active items): If the new `items` prop contains no active items, `filteredItems` should be empty and display 'No active items.'",
            "Prop update (all active items): If the new `items` prop contains all active items, all items should be displayed."
          ],
          "hints": [
            "Remember that `getDerivedStateFromProps` is a `static` method.",
            "It receives `nextProps` and `prevState` as arguments.",
            "It must return an object to update state, or `null` if no update is needed.",
            "To detect changes in the `items` prop, you'll need to store the *previous* `items` prop in the component's state and compare against it."
          ],
          "tags": [
            "React",
            "Class Components",
            "Lifecycle Methods",
            "getDerivedStateFromProps",
            "State Management",
            "Props"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Class Components",
            "State and Props",
            "JavaScript Array Methods"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "getDerivedStateFromProps",
            "State Derivation",
            "Prop Immutability"
          ]
        },
        {
          "id": "task_optimize_component_scu",
          "title": "Optimize a Component with shouldComponentUpdate or PureComponent",
          "description": "\nCreate two React components: `ParentComponent` and `ChildComponent`.\n\n`ParentComponent` should:\n1.  Maintain a state `counter` and `statusMessage`.\n2.  Render `ChildComponent` and pass `counter` as an `id` prop and `statusMessage` as a `message` prop.\n3.  Have a button to increment `counter`.\n4.  Have a button to change `statusMessage`.\n\n`ChildComponent` should initially be a regular `React.Component` that logs 'ChildComponent Rendered' on every render. Your task is to optimize `ChildComponent` so that:\n\n1.  It *only* re-renders when its `id` prop changes, and *not* when its `message` prop changes.\n2.  You can achieve this using either `shouldComponentUpdate` or by extending `React.PureComponent` (if PureComponent meets the requirement, explain why/why not).\n\nIf using `shouldComponentUpdate`, implement the custom logic. If using `PureComponent`, explain why it does or does not meet the specific requirement of ignoring `message` prop changes.",
          "difficulty": "medium",
          "startingCode": "import React, { Component } from 'react';\n\ninterface ChildProps {\n  id: number;\n  message: string;\n}\n\n// ChildComponent (initially a regular Component)\nclass ChildComponent extends Component<ChildProps> {\n  render() {\n    console.log(`ChildComponent (ID: ${this.props.id}, Message: ${this.props.message}): Rendered`);\n    return (\n      <div style={{ border: '1px solid lightblue', padding: '10px', margin: '5px' }}>\n        <h4>Child Component</h4>\n        <p>ID: {this.props.id}</p>\n        <p>Message: {this.props.message}</p>\n      </div>\n    );\n  }\n}\n\ninterface ParentState {\n  counter: number;\n  statusMessage: string;\n}\n\nclass ParentComponent extends Component<{}, ParentState> {\n  state = {\n    counter: 0,\n    statusMessage: 'Initial Status',\n  };\n\n  render() {\n    return (\n      <div style={{ border: '1px solid darkblue', padding: '10px', margin: '10px' }}>\n        <h2>Parent Component</h2>\n        <button onClick={() => this.setState(prevState => ({ counter: prevState.counter + 1 }))}>\n          Increment Counter (Changes ID Prop)\n        </button>\n        <button onClick={() => this.setState({ statusMessage: `Status Update ${Math.random().toFixed(2)}` })}>\n          Change Status Message (Changes Message Prop)\n        </button>\n        <p>Parent Counter: {this.state.counter}</p>\n        <ChildComponent id={this.state.counter} message={this.state.statusMessage} />\n      </div>\n    );\n  }\n}\n\nexport default ParentComponent;\n",
          "solutionCode": "import React, { Component, PureComponent } from 'react';\n\ninterface ChildProps {\n  id: number;\n  message: string;\n}\n\n// Option 1: Using shouldComponentUpdate\nclass OptimizedChildComponentSCU extends Component<ChildProps> {\n  shouldComponentUpdate(nextProps: ChildProps, nextState: {}) {\n    // Only re-render if 'id' prop changes, ignore 'message' prop changes\n    const shouldUpdate = nextProps.id !== this.props.id;\n    console.log(`OptimizedChildComponentSCU (ID: ${this.props.id}, Message: ${this.props.message}): shouldComponentUpdate returned ${shouldUpdate}`);\n    return shouldUpdate;\n  }\n\n  render() {\n    console.log(`OptimizedChildComponentSCU (ID: ${this.props.id}, Message: ${this.props.message}): Rendered`);\n    return (\n      <div style={{ border: '1px solid lightgreen', padding: '10px', margin: '5px' }}>\n        <h4>Optimized Child (using shouldComponentUpdate)</h4>\n        <p>ID: {this.props.id}</p>\n        <p>Message: {this.props.message}</p>\n      </div>\n    );\n  }\n}\n\n// Option 2: Using PureComponent (and explaining its behavior for this specific case)\nclass OptimizedChildComponentPure extends PureComponent<ChildProps> {\n  render() {\n    console.log(`OptimizedChildComponentPure (ID: ${this.props.id}, Message: ${this.props.message}): Rendered`);\n    return (\n      <div style={{ border: '1px solid lightcoral', padding: '10px', margin: '5px' }}>\n        <h4>Optimized Child (using PureComponent)</h4>\n        <p>ID: {this.props.id}</p>\n        <p>Message: {this.props.message}</p>\n      </div>\n    );\n  }\n}\n/*\nExplanation for PureComponent:\nPureComponent performs a shallow comparison of ALL props. In this case, if 'message' prop changes, \nPureComponent WILL detect that change (since 'message' is a string, a primitive, it will be referentially different)\nand WILL trigger a re-render. Therefore, PureComponent does NOT meet the specific requirement of \n*only* re-rendering when 'id' changes and ignoring 'message'. For that specific control, \nshouldComponentUpdate with custom logic is necessary.\n*/\n\ninterface ParentState {\n  counter: number;\n  statusMessage: string;\n}\n\nclass ParentComponent extends Component<{}, ParentState> {\n  state = {\n    counter: 0,\n    statusMessage: 'Initial Status',\n  };\n\n  render() {\n    return (\n      <div style={{ border: '1px solid darkblue', padding: '10px', margin: '10px' }}>\n        <h2>Parent Component</h2>\n        <button onClick={() => this.setState(prevState => ({ counter: prevState.counter + 1 }))}>\n          Increment Counter (Changes ID Prop)\n        </button>\n        <button onClick={() => this.setState({ statusMessage: `Status Update ${Math.random().toFixed(2)}` })}>\n          Change Status Message (Changes Message Prop)\n        </button>\n        <p>Parent Counter: {this.state.counter}</p>\n        \n        {/* Choose one of the optimized child components */}\n        <OptimizedChildComponentSCU id={this.state.counter} message={this.state.statusMessage} />\n        {/* <OptimizedChildComponentPure id={this.state.counter} message={this.state.statusMessage} /> */}\n      </div>\n    );\n  }\n}\n\nexport default ParentComponent;\n",
          "testCases": [
            "Initial render: `ChildComponent` should render once.",
            "Changing `statusMessage`: `ChildComponent` should NOT re-render (only `ParentComponent` and its children that are not optimized, or where the optimization fails).",
            "Changing `counter`: `ChildComponent` SHOULD re-render.",
            "Verify console logs to confirm render behavior for both test cases.",
            "If `PureComponent` is used, explain why it will re-render for `statusMessage` changes."
          ],
          "hints": [
            "The `shouldComponentUpdate` method receives `nextProps` and `nextState`.",
            "It should return `true` to allow a re-render, `false` to prevent it.",
            "Think carefully about what exact condition will prevent re-renders when only `message` changes but allow them when `id` changes.",
            "Consider how `PureComponent`'s shallow comparison works for primitive values like strings. Does it meet the specific requirement of ignoring *certain* prop changes?"
          ],
          "tags": [
            "React",
            "Class Components",
            "Performance Optimization",
            "shouldComponentUpdate",
            "PureComponent"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Class Components",
            "State and Props",
            "Component Re-rendering"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "shouldComponentUpdate",
            "PureComponent",
            "Shallow Comparison",
            "Performance Tuning"
          ]
        },
        {
          "id": "task_purecomponent_demonstration",
          "title": "Demonstrate React.PureComponent Behavior",
          "description": "\nCreate a `ParentComponent` and two child components: `RegularChild` (extending `React.Component`) and `PureChild` (extending `React.PureComponent`).\n\n`ParentComponent` should:\n1.  Maintain a state variable `data` which is an object with a `value` property (e.g., `{ value: 'initial' }`).\n2.  Maintain another state variable `updateCount` which is a number.\n3.  Render both `RegularChild` and `PureChild`, passing the `data` object as a prop to both.\n4.  Include two buttons:\n    a.  One button to update `updateCount` (e.g., `this.setState({ updateCount: this.state.updateCount + 1 })`). This will cause the `ParentComponent` to re-render, but does not change the `data` object prop passed to children.\n    b.  Another button to update the `data` object, but *crucially*, recreate the object reference while keeping the `value` property the same (e.g., `this.setState({ data: { value: this.state.data.value } })`).\n\nBoth `RegularChild` and `PureChild` should:\n*   Simply display the `value` from their `data` prop.\n*   Log 'RegularChild Rendered' or 'PureChild Rendered' respectively in their `render` method.\n\nObserve and explain the differences in console logs when each button is clicked, highlighting how `PureComponent` behaves due to shallow comparison of the object prop.\n",
          "difficulty": "medium",
          "startingCode": "import React, { Component, PureComponent } from 'react';\n\ninterface ChildProps {\n  data: { value: string };\n}\n\n// Regular Child Component\nclass RegularChild extends Component<ChildProps> {\n  render() {\n    console.log('RegularChild Rendered');\n    return (\n      <div style={{ border: '1px solid gray', padding: '10px', margin: '5px' }}>\n        <h3>Regular Child</h3>\n        <p>Value: {this.props.data.value}</p>\n      </div>\n    );\n  }\n}\n\n// Pure Child Component\nclass PureChild extends PureComponent<ChildProps> {\n  render() {\n    console.log('PureChild Rendered');\n    return (\n      <div style={{ border: '1px solid lightgreen', padding: '10px', margin: '5px' }}>\n        <h3>Pure Child</h3>\n        <p>Value: {this.props.data.value}</p>\n      </div>\n    );\n  }\n}\n\ninterface ParentState {\n  data: { value: string };\n  updateCount: number;\n}\n\nclass ParentComponent extends Component<{}, ParentState> {\n  state = {\n    data: { value: 'initial' },\n    updateCount: 0,\n  };\n\n  render() {\n    return (\n      <div style={{ border: '1px solid darkblue', padding: '10px', margin: '10px' }}>\n        <h2>Parent Component</h2>\n        <button onClick={() => this.setState(prevState => ({ updateCount: prevState.updateCount + 1 }))}>\n          Update Parent (No Prop Change to Data)\n        </button>\n        <button onClick={() => this.setState(prevState => ({\n          // TODO: Recreate 'data' object reference but keep 'value' same\n          data: { value: prevState.data.value }\n        }))}>\n          Update Data Prop (New Reference)\n        </button>\n        <p>Parent Update Count: {this.state.updateCount}</p>\n        <RegularChild data={this.state.data} />\n        <PureChild data={this.state.data} />\n      </div>\n    );\n  }\n}\n\nexport default ParentComponent;\n",
          "solutionCode": "import React, { Component, PureComponent } from 'react';\n\ninterface ChildProps {\n  data: { value: string };\n}\n\n// Regular Child Component\nclass RegularChild extends Component<ChildProps> {\n  render() {\n    console.log('RegularChild Rendered');\n    return (\n      <div style={{ border: '1px solid gray', padding: '10px', margin: '5px' }}>\n        <h3>Regular Child</h3>\n        <p>Value: {this.props.data.value}</p>\n      </div>\n    );\n  }\n}\n\n// Pure Child Component\nclass PureChild extends PureComponent<ChildProps> {\n  render() {\n    console.log('PureChild Rendered');\n    return (\n      <div style={{ border: '1px solid lightgreen', padding: '10px', margin: '5px' }}>\n        <h3>Pure Child</h3>\n        <p>Value: {this.props.data.value}</p>\n      </div>\n    );\n  }\n}\n\ninterface ParentState {\n  data: { value: string };\n  updateCount: number;\n}\n\nclass ParentComponent extends Component<{}, ParentState> {\n  state = {\n    data: { value: 'initial' },\n    updateCount: 0,\n  };\n\n  render() {\n    return (\n      <div style={{ border: '1px solid darkblue', padding: '10px', margin: '10px' }}>\n        <h2>Parent Component</h2>\n        <button onClick={() => this.setState(prevState => ({ updateCount: prevState.updateCount + 1 }))}>\n          Update Parent (No Prop Change to Data)\n        </button>\n        <button onClick={() => this.setState(prevState => ({\n          // Recreate 'data' object reference but keep 'value' same\n          data: { value: prevState.data.value }\n        }))}>\n          Update Data Prop (New Reference)\n        </button>\n        <p>Parent Update Count: {this.state.updateCount}</p>\n        <RegularChild data={this.state.data} />\n        <PureChild data={this.state.data} />\n      </div>\n    );\n  }\n}\n\nexport default ParentComponent;\n",
          "testCases": [
            "Initial Render: Both children should render and log to console.",
            "Click 'Update Parent (No Prop Change to Data)': Only `RegularChild` should re-render. `PureChild` should NOT re-render because its `data` prop reference remains the same.",
            "Click 'Update Data Prop (New Reference)': Both `RegularChild` and `PureChild` should re-render. `PureChild` re-renders because even though the *content* of `data.value` is the same, the *reference* to the `data` object itself has changed, triggering its shallow comparison.",
            "Verify console logs match expected render behavior."
          ],
          "hints": [
            "Focus on the concept of 'shallow comparison' for `PureComponent`.",
            "Remember that for objects (like `data`), shallow comparison checks if the memory address (reference) of the object is the same, not its deep content.",
            "To test `PureComponent`'s behavior, ensure you create a *new* object when updating the `data` prop, even if its internal `value` remains the same.",
            "A regular `Component` will always re-render if its parent re-renders, regardless of prop changes, unless `shouldComponentUpdate` is explicitly implemented."
          ],
          "tags": [
            "React",
            "PureComponent",
            "Shallow Comparison",
            "Performance Optimization",
            "Class Components"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Class Components",
            "State and Props",
            "JavaScript Object References"
          ],
          "complexity": 6,
          "interviewRelevance": 7,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "PureComponent",
            "Shallow Comparison",
            "Component Re-rendering"
          ]
        },
        {
          "id": "task_memoized_counter_display",
          "title": "Implement a Memoized Counter Display (Functional Component)",
          "description": "\nCreate two functional components: `ParentCounter` and `DisplayCount`.\n\n`ParentCounter` should:\n1.  Maintain two state variables: `totalCount` (a number) and `message` (a string).\n2.  Have a button to increment `totalCount`.\n3.  Have a button to change `message` to a random string.\n4.  Render `DisplayCount` component, passing `totalCount` as `count` prop and `message` as `status` prop.\n\n`DisplayCount` should initially be a regular functional component. Your task is to:\n\n1.  Wrap `DisplayCount` with `React.memo`.\n2.  Ensure `DisplayCount` only re-renders when its `count` prop changes, and *not* when its `status` prop changes.\n3.  You will need to use a custom comparison function for `React.memo` to achieve this specific behavior.\n4.  Add a `console.log` inside `DisplayCount`'s render to confirm its render behavior.",
          "difficulty": "medium",
          "startingCode": "import React, { useState } from 'react';\n\ninterface DisplayCountProps {\n  count: number;\n  status: string;\n}\n\nconst DisplayCount: React.FC<DisplayCountProps> = ({ count, status }) => {\n  // TODO: Add console.log here\n  return (\n    <div style={{ border: '1px solid lightcoral', padding: '10px', margin: '5px' }}>\n      <h4>Display Count Component</h4>\n      <p>Count: {count}</p>\n      <p>Status: {status}</p>\n    </div>\n  );\n};\n\n// TODO: Wrap DisplayCount with React.memo and a custom comparison function\n// const MemoizedDisplayCount = React.memo(DisplayCount, customComparisonFunction);\n\nconst ParentCounter: React.FC = () => {\n  const [totalCount, setTotalCount] = useState(0);\n  const [message, setMessage] = useState('Idle');\n\n  return (\n    <div style={{ border: '1px solid darkblue', padding: '10px', margin: '10px' }}>\n      <h2>Parent Counter</h2>\n      <button onClick={() => setTotalCount(prev => prev + 1)}>\n        Increment Count (Changes 'count' prop)\n      </button>\n      <button onClick={() => setMessage(`Message ${Math.random().toFixed(2)}`)}>\n        Change Message (Changes 'status' prop)\n      </button>\n      <p>Total Count: {totalCount}</p>\n      {/* Use the memoized component here */}\n      <DisplayCount count={totalCount} status={message} />\n    </div>\n  );\n};\n\nexport default ParentCounter;\n",
          "solutionCode": "import React, { useState } from 'react';\n\ninterface DisplayCountProps {\n  count: number;\n  status: string;\n}\n\nconst DisplayCount: React.FC<DisplayCountProps> = ({ count, status }) => {\n  console.log(`DisplayCount (Count: ${count}, Status: ${status}): Rendered`);\n  return (\n    <div style={{ border: '1px solid lightcoral', padding: '10px', margin: '5px' }}>\n      <h4>Display Count Component</h4>\n      <p>Count: {count}</p>\n      <p>Status: {status}</p>\n    </div>\n  );\n};\n\n// Custom comparison function for React.memo\n// Returns true if props are EQUAL (i.e., no re-render needed)\n// We want to re-render ONLY if 'count' changes, ignoring 'status'.\nconst areDisplayCountPropsEqual = (prevProps: DisplayCountProps, nextProps: DisplayCountProps): boolean => {\n  return prevProps.count === nextProps.count;\n};\n\nconst MemoizedDisplayCount = React.memo(DisplayCount, areDisplayCountPropsEqual);\n\nconst ParentCounter: React.FC = () => {\n  const [totalCount, setTotalCount] = useState(0);\n  const [message, setMessage] = useState('Idle');\n\n  return (\n    <div style={{ border: '1px solid darkblue', padding: '10px', margin: '10px' }}>\n      <h2>Parent Counter</h2>\n      <button onClick={() => setTotalCount(prev => prev + 1)}>\n        Increment Count (Changes 'count' prop)\n      </button>\n      <button onClick={() => setMessage(`Message ${Math.random().toFixed(2)}`)}>\n        Change Message (Changes 'status' prop)\n      </button>\n      <p>Total Count: {totalCount}</p>\n      <MemoizedDisplayCount count={totalCount} status={message} />\n    </div>\n  );\n};\n\nexport default ParentCounter;\n",
          "testCases": [
            "Initial Render: `DisplayCount` should render once.",
            "Click 'Change Message': `DisplayCount` should NOT re-render (only `ParentCounter` should).",
            "Click 'Increment Count': `DisplayCount` SHOULD re-render.",
            "Verify console logs to confirm render behavior for both test cases.",
            "Ensure `MemoizedDisplayCount` is used in the `ParentCounter`."
          ],
          "hints": [
            "The second argument to `React.memo` is the custom comparison function.",
            "This comparison function receives `prevProps` and `nextProps`.",
            "Crucially, it should return `true` if the component should *not* re-render (i.e., the props are considered 'equal' for rendering purposes), and `false` if it *should* re-render.",
            "You only need to compare the `count` prop in your custom function."
          ],
          "tags": [
            "React",
            "React.memo",
            "Functional Components",
            "Performance Optimization",
            "Custom Comparison"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Functional Components",
            "useState",
            "React.memo"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "React.memo",
            "Custom Comparison",
            "Memoization"
          ]
        },
        {
          "id": "task_custom_memoization_user_card",
          "title": "Build a User Card with Custom `React.memo` Comparison",
          "description": "\nCreate a functional component `UserCard` that displays user information. The `UserCard` receives a `user` object as a prop, which includes `id`, `name`, `email`, and `lastActivity` (a `Date` object).\n\nYour task is to:\n1.  Define the `UserCard` component to display the user's `name`, `email`, and `lastActivity` time.\n2.  Wrap `UserCard` with `React.memo`.\n3.  Provide a custom comparison function to `React.memo` such that `UserCard` *only* re-renders if the `id`, `name`, or `email` properties of the `user` object change. Changes to `lastActivity` should *not* trigger a re-render.\n4.  Create a `ParentUserDashboard` component that displays the `UserCard`.\n5.  `ParentUserDashboard` should have a button to 'Update Last Activity' that updates the `user.lastActivity` property to the current time, ensuring a new `user` object reference is passed down (e.g., `{ ...currentUser, lastActivity: new Date() }`).\n6.  `ParentUserDashboard` should also have a button to 'Change User Name' that updates `user.name`.\n7.  Add console logs to `UserCard`'s render method to confirm when it renders.",
          "difficulty": "hard",
          "startingCode": "import React, { useState } from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  lastActivity: Date;\n}\n\ninterface UserCardProps {\n  user: User;\n}\n\nconst UserCard: React.FC<UserCardProps> = ({ user }) => {\n  // TODO: Add console.log for rendering\n  return (\n    <div style={{ border: '1px solid orange', padding: '15px', margin: '10px' }}>\n      <h3>User Card</h3>\n      <p>ID: {user.id}</p>\n      <p>Name: {user.name}</p>\n      <p>Email: {user.email}</p>\n      <p>Last Activity: {user.lastActivity.toLocaleTimeString()}</p>\n    </div>\n  );\n};\n\n// TODO: Define custom comparison function and wrap UserCard with React.memo\n// const MemoizedUserCard = React.memo(UserCard, yourCustomComparisonFunction);\n\nconst ParentUserDashboard: React.FC = () => {\n  const [currentUser, setCurrentUser] = useState<User>({\n    id: 1,\n    name: 'Alice',\n    email: 'alice@example.com',\n    lastActivity: new Date(),\n  });\n\n  const updateLastActivity = () => {\n    setCurrentUser(prevUser => ({\n      ...prevUser,\n      lastActivity: new Date(), // New Date object, new 'user' object reference\n    }));\n  };\n\n  const changeUserName = () => {\n    setCurrentUser(prevUser => ({\n      ...prevUser,\n      name: prevUser.name === 'Alice' ? 'Bob' : 'Alice', // New 'user' object reference\n    }));\n  };\n\n  return (\n    <div style={{ border: '1px solid purple', padding: '15px', margin: '15px' }}>\n      <h2>User Dashboard</h2>\n      <button onClick={updateLastActivity}>Update Last Activity (Should NOT Re-render UserCard)</button>\n      <button onClick={changeUserName}>Change User Name (SHOULD Re-render UserCard)</button>\n      <MemoizedUserCard user={currentUser} />\n    </div>\n  );\n};\n\nexport default ParentUserDashboard;\n",
          "solutionCode": "import React, { useState } from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  lastActivity: Date;\n}\n\ninterface UserCardProps {\n  user: User;\n}\n\nconst UserCard: React.FC<UserCardProps> = ({ user }) => {\n  console.log(`UserCard (User ID: ${user.id}, Name: ${user.name}): Rendered`);\n  return (\n    <div style={{ border: '1px solid orange', padding: '15px', margin: '10px' }}>\n      <h3>User Card</h3>\n      <p>ID: {user.id}</p>\n      <p>Name: {user.name}</p>\n      <p>Email: {user.email}</p>\n      <p>Last Activity: {user.lastActivity.toLocaleTimeString()}</p>\n    </div>\n  );\n};\n\n// Custom comparison function for React.memo\n// Returns true if props are EQUAL (i.e., no re-render needed)\n// We want to re-render ONLY if id, name, or email changes, ignoring lastActivity.\nconst areUserCardPropsEqual = (prevProps: UserCardProps, nextProps: UserCardProps): boolean => {\n  return (\n    prevProps.user.id === nextProps.user.id &&\n    prevProps.user.name === nextProps.user.name &&\n    prevProps.user.email === nextProps.user.email\n    // We explicitly IGNORE prevProps.user.lastActivity === nextProps.user.lastActivity\n    // This means changes to lastActivity won't trigger a re-render.\n  );\n};\n\nconst MemoizedUserCard = React.memo(UserCard, areUserCardPropsEqual);\n\nconst ParentUserDashboard: React.FC = () => {\n  const [currentUser, setCurrentUser] = useState<User>({\n    id: 1,\n    name: 'Alice',\n    email: 'alice@example.com',\n    lastActivity: new Date(),\n  });\n\n  const updateLastActivity = () => {\n    setCurrentUser(prevUser => ({\n      ...prevUser,\n      lastActivity: new Date(), // New Date object, new 'user' object reference\n    }));\n  };\n\n  const changeUserName = () => {\n    setCurrentUser(prevUser => ({\n      ...prevUser,\n      name: prevUser.name === 'Alice' ? 'Bob' : 'Alice', // New 'user' object reference\n    }));\n  };\n\n  return (\n    <div style={{ border: '1px solid purple', padding: '15px', margin: '15px' }}>\n      <h2>User Dashboard</h2>\n      <button onClick={updateLastActivity}>Update Last Activity (Should NOT Re-render UserCard)</button>\n      <button onClick={changeUserName}>Change User Name (SHOULD Re-render UserCard)</button>\n      <MemoizedUserCard user={currentUser} />\n    </div>\n  );\n};\n\nexport default ParentUserDashboard;\n",
          "testCases": [
            "Initial Render: `UserCard` should render once.",
            "Click 'Update Last Activity': `UserCard` should NOT re-render. Only the `ParentUserDashboard` re-renders. Verify console logs.",
            "Click 'Change User Name': `UserCard` SHOULD re-render. Verify console logs.",
            "Ensure the `lastActivity` time displayed in the `UserCard` updates when 'Update Last Activity' is clicked, even if the component itself doesn't re-render (as it's referencing the new `user` object). This confirms the data itself changes, but rendering is controlled by memoization."
          ],
          "hints": [
            "Remember that the custom comparison function passed to `React.memo` returns `true` if React should *skip* the re-render (i.e., the props are considered equal for rendering purposes).",
            "You need to compare `prevProps.user.id`, `prevProps.user.name`, and `prevProps.user.email` with their `nextProps` counterparts.",
            "Explicitly exclude `lastActivity` from your comparison logic.",
            "Even though `lastActivity` changes and the `user` object reference changes, your custom comparison should ignore the `lastActivity` difference."
          ],
          "tags": [
            "React",
            "React.memo",
            "Functional Components",
            "Custom Comparison",
            "Performance Optimization",
            "Memoization"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Functional Components",
            "useState",
            "React.memo"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "React.memo",
            "Custom Comparison",
            "Shallow vs Deep Comparison",
            "Immutable Updates"
          ]
        },
        {
          "id": "task_refactor_class_to_hooks_counter",
          "title": "Refactor a Class Counter to Functional Component with Hooks",
          "description": "\nRefactor the following simple React class component into a functional component using `useState` and `useEffect`.\n\nOriginal Class Component:\n```typescript\nimport React, { Component } from 'react';\n\nclass ClassCounter extends Component<{}, { count: number }> {\n  private intervalId: number | undefined;\n\n  constructor(props: {}) {\n    super(props);\n    this.state = { count: 0 };\n    this.increment = this.increment.bind(this);\n  }\n\n  componentDidMount() {\n    console.log('ClassCounter: Mounted');\n    this.intervalId = window.setInterval(() => {\n      this.setState(prevState => ({ count: prevState.count + 1 }));\n    }, 1000);\n  }\n\n  componentDidUpdate(prevProps: {}, prevState: { count: number }) {\n    if (prevState.count !== this.state.count) {\n      console.log(`ClassCounter: Count updated to ${this.state.count}`);\n    }\n  }\n\n  componentWillUnmount() {\n    console.log('ClassCounter: Unmounted, clearing interval');\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  increment() {\n    this.setState(prevState => ({ count: prevState.count + 1 }));\n  }\n\n  render() {\n    return (\n      <div style={{ border: '1px solid blue', padding: '10px' }}>\n        <h3>Class Counter: {this.state.count}</h3>\n        <button onClick={this.increment}>Increment Manually</button>\n      </div>\n    );\n  }\n}\n```\n\nYour functional component should:\n1.  Manage the `count` state using `useState`.\n2.  Implement the automatic incrementing interval using `useEffect` to mimic `componentDidMount` and `componentWillUnmount`.\n3.  Add a `useEffect` to log when `count` updates, mimicking `componentDidUpdate`.\n4.  Provide a manual increment button.",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\n// TODO: Refactor the ClassCounter component into a functional component here\n\n// Your refactored functional component should look something like this structure:\n// function FunctionalCounter() {\n//   const [count, setCount] = useState(0);\n\n//   // Effect for auto-incrementing interval (componentDidMount + componentWillUnmount)\n//   useEffect(() => {\n//     // TODO: Implement interval logic\n//     return () => { /* TODO: Cleanup */ };\n//   }, []);\n\n//   // Effect for logging count updates (componentDidUpdate)\n//   useEffect(() => {\n//     // TODO: Implement logging logic\n//   }, [count]);\n\n//   const incrementManually = () => {\n//     setCount(prev => prev + 1);\n//   };\n\n//   return (\n//     <div style={{ border: '1px solid green', padding: '10px' }}>\n//       <h3>Functional Counter: {count}</h3>\n//       <button onClick={incrementManually}>Increment Manually</button>\n//     </div>\n//   );\n// }\n\n// export default FunctionalCounter;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction FunctionalCounter() {\n  const [count, setCount] = useState(0);\n\n  // Effect for auto-incrementing interval (componentDidMount + componentWillUnmount)\n  useEffect(() => {\n    console.log('FunctionalCounter: Setting up auto-increment interval (mount)');\n    const intervalId = window.setInterval(() => {\n      setCount(prev => prev + 1);\n    }, 1000);\n\n    // Cleanup function: clears interval on unmount\n    return () => {\n      console.log('FunctionalCounter: Clearing interval (unmount)');\n      clearInterval(intervalId);\n    };\n  }, []); // Empty dependency array: runs once on mount, cleanup on unmount\n\n  // Effect for logging count updates (componentDidUpdate for 'count' state)\n  useEffect(() => {\n    // Only log if count has changed from its initial value (after initial mount)\n    if (count > 0) { \n        console.log(`FunctionalCounter: Count updated to ${count}`);\n    }\n  }, [count]); // Dependency array: re-run effect when 'count' changes\n\n  const incrementManually = () => {\n    setCount(prev => prev + 1);\n  };\n\n  return (\n    <div style={{ border: '1px solid green', padding: '10px' }}>\n      <h3>Functional Counter: {count}</h3>\n      <button onClick={incrementManually}>Increment Manually</button>\n    </div>\n  );\n}\n\nexport default FunctionalCounter;\n",
          "testCases": [
            "Component should start at `count: 0`.",
            "Count should automatically increment every second.",
            "Clicking 'Increment Manually' should increase the count.",
            "Console should log 'FunctionalCounter: Setting up auto-increment interval (mount)' once on mount.",
            "Console should log 'FunctionalCounter: Count updated to [new count]' whenever count changes (either automatically or manually).",
            "When the component is unmounted (e.g., by conditional rendering in a parent), 'FunctionalCounter: Clearing interval (unmount)' should be logged and the interval should stop."
          ],
          "hints": [
            "Use `useState` for the `count` variable.",
            "For `componentDidMount` and `componentWillUnmount` behavior, `useEffect` with an empty dependency array (`[]`) and a cleanup return function is key.",
            "For `componentDidUpdate` behavior based on `count`, use `useEffect` with `[count]` in the dependency array.",
            "Remember that `setCount` in `setInterval` should use the functional update form (`prev => prev + 1`) to avoid stale closures."
          ],
          "tags": [
            "React",
            "Hooks",
            "Refactoring",
            "useState",
            "useEffect",
            "Class Components",
            "Functional Components"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "React Class Components",
            "React Hooks basics"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "useState",
            "useEffect",
            "Lifecycle Mapping"
          ]
        },
        {
          "id": "task_refactor_class_to_hooks_data_fetch",
          "title": "Refactor a Class Data Fetcher to Functional Component with Hooks",
          "description": "\nRefactor the following React class component that fetches and displays user data into a functional component using `useState` and `useEffect`.\n\nOriginal Class Component:\n```typescript\nimport React, { Component } from 'react';\n\ninterface UserData {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface ClassUserFetcherProps {\n  userId: number;\n}\n\ninterface ClassUserFetcherState {\n  user: UserData | null;\n  loading: boolean;\n  error: string | null;\n}\n\nclass ClassUserFetcher extends Component<ClassUserFetcherProps, ClassUserFetcherState> {\n  constructor(props: ClassUserFetcherProps) {\n    super(props);\n    this.state = {\n      user: null,\n      loading: true,\n      error: null,\n    };\n  }\n\n  componentDidMount() {\n    this.fetchUser(this.props.userId);\n  }\n\n  componentDidUpdate(prevProps: ClassUserFetcherProps) {\n    if (prevProps.userId !== this.props.userId) {\n      this.fetchUser(this.props.userId);\n    }\n  }\n\n  fetchUser = async (id: number) => {\n    this.setState({ loading: true, error: null });\n    try {\n      const response = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch user ${id}: ${response.statusText}`);\n      }\n      const data: UserData = await response.json();\n      this.setState({ user: data, loading: false });\n    } catch (err: any) {\n      this.setState({ error: err.message, loading: false, user: null });\n    }\n  };\n\n  render() {\n    const { user, loading, error } = this.state;\n\n    if (loading) return <div>Loading user {this.props.userId}...</div>;\n    if (error) return <div>Error: {error}</div>;\n    if (!user) return <div>No user data.</div>;\n\n    return (\n      <div style={{ border: '1px solid brown', padding: '15px' }}>\n        <h3>User Details (Class Component)</h3>\n        <p>ID: {user.id}</p>\n        <p>Name: {user.name}</p>\n        <p>Email: {user.email}</p>\n      </div>\n    );\n  }\n}\n```\n\nYour functional component should:\n1.  Manage `user`, `loading`, and `error` states using `useState`.\n2.  Implement the data fetching logic using `useEffect` to handle initial mount (`componentDidMount` equivalent) and re-fetching when `userId` prop changes (`componentDidUpdate` equivalent).\n3.  Ensure proper loading and error states are displayed.",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\ninterface UserData {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface FunctionalUserFetcherProps {\n  userId: number;\n}\n\nconst FunctionalUserFetcher: React.FC<FunctionalUserFetcherProps> = ({ userId }) => {\n  // TODO: Manage user, loading, error states with useState\n  // const [user, setUser] = useState<UserData | null>(null);\n  // const [loading, setLoading] = useState(true);\n  // const [error, setError] = useState<string | null>(null);\n\n  // TODO: Implement data fetching with useEffect\n  // This effect should run on mount AND when userId changes\n  // useEffect(() => {\n  //   const fetchUser = async () => {\n  //     // ... fetching logic, updating states\n  //   };\n  //   fetchUser();\n  // }, [/* TODO: Add dependencies */]);\n\n  // TODO: Render loading, error, or user data\n  return <div>{/* Your JSX here */}</div>;\n};\n\n// export default FunctionalUserFetcher;\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\ninterface UserData {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface FunctionalUserFetcherProps {\n  userId: number;\n}\n\nconst FunctionalUserFetcher: React.FC<FunctionalUserFetcherProps> = ({ userId }) => {\n  const [user, setUser] = useState<UserData | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    console.log(`FunctionalUserFetcher: Fetching user ${userId}...`);\n    const fetchUser = async () => {\n      setLoading(true);\n      setError(null); // Clear previous errors\n      try {\n        const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);\n        if (!response.ok) {\n          throw new Error(`Failed to fetch user ${userId}: ${response.statusText}`);\n        }\n        const data: UserData = await response.json();\n        setUser(data);\n      } catch (err: any) {\n        console.error('Error in fetch:', err);\n        setError(err.message || 'An unknown error occurred');\n        setUser(null); // Clear user data on error\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchUser();\n\n    // Optional: Cleanup function if fetch was cancellable (e.g., AbortController)\n    return () => {\n        // console.log(`Cleanup for user ${userId} fetch`);\n        // if (controller) controller.abort();\n    };\n  }, [userId]); // Dependency array: re-run effect when userId changes\n\n  if (loading) return <div>Loading user {userId}...</div>;\n  if (error) return <div>Error: {error}</div>;\n  if (!user) return <div>No user data for ID: {userId}.</div>;\n\n  return (\n    <div style={{ border: '1px solid orange', padding: '15px' }}>\n      <h3>User Details (Functional Component)</h3>\n      <p>ID: {user.id}</p>\n      <p>Name: {user.name}</p>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n};\n\nexport default FunctionalUserFetcher;\n",
          "testCases": [
            "Initial render: Component should display 'Loading user [ID]...' and then user data for the initial `userId`.",
            "Change `userId` prop (e.g., from a parent component): Component should re-fetch data for the new `userId` and update the display.",
            "Simulate an API error (e.g., by trying to fetch `userId=99999`): Component should display the error message.",
            "Verify network requests happen only on mount and when `userId` changes."
          ],
          "hints": [
            "Each distinct piece of state (user data, loading status, error) should have its own `useState` call.",
            "The `useEffect` hook should contain the `fetch` logic.",
            "The `userId` prop needs to be in the `useEffect`'s dependency array so that the effect re-runs when `userId` changes.",
            "Remember to set `loading` and `error` states appropriately before and after the fetch operation.",
            "You might need to make the `fetchUser` function `async` and use `await` for cleaner async code inside `useEffect`."
          ],
          "tags": [
            "React",
            "Hooks",
            "Refactoring",
            "useState",
            "useEffect",
            "Data Fetching",
            "Class Components",
            "Functional Components"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Functional Components",
            "useState",
            "useEffect",
            "Fetch API",
            "Async/Await"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "useEffect",
            "Lifecycle Mapping",
            "Asynchronous Operations"
          ]
        }
      ]
    }
  }
]