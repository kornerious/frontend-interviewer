[
  {
    "id": "26a4487d-c86e-4363-99b5-742b685fa2f4",
    "startLine": 8900,
    "endLine": 8999,
    "processedDate": "2025-06-17T10:50:13.156Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_redux_core_concepts",
          "title": "Redux Core Concepts: Store, Reducers, Actions",
          "content": "Redux is a predictable state container for JavaScript applications. It helps you write applications that behave consistently across different environments (client, server, and native) and are easy to test. The core principles of Redux include:\n\n1.  **Single Source of Truth:** The state of your whole application is stored in an object tree within a single *store*.\n2.  **State is Read-Only:** The only way to change the state is to emit an *action*, an object describing what happened.\n3.  **Changes are Made with Pure Functions:** To specify how the state tree is transformed by actions, you write *reducers*, which are pure functions.\n\n### The Redux Store\n\nThe Redux store holds the entire state tree of your application. It is created using `createStore` from the `redux` library. The store has a few responsibilities:\n\n*   Holds the application state.\n*   Allows access to the state via `getState()`.\n*   Allows the state to be updated via `dispatch(action)`.\n*   Registers listener callbacks via `subscribe(listener)`.\n*   Handles unregistering of listeners via the function returned by `subscribe(listener)`.\n\n### Reducers\n\nReducers are pure functions that take the current state and an action as arguments, and return a *new* state. They never mutate the original state directly. A reducer typically uses a `switch` statement to handle different action types. Each reducer manages a specific slice of the overall state.\n\n### Actions\n\nActions are plain JavaScript objects that have a `type` property, indicating the type of action performed. They are the only way to send data from your application to the Redux store. Actions often have a `payload` property to carry any relevant data.\n",
          "examples": [
            {
              "id": "example_redux_core_1",
              "title": "Basic Redux Store and Reducer",
              "code": "import { createStore } from 'redux';\n\n// Action types\nconst ADD_TASK = 'ADD_TASK';\nconst TOGGLE_TASK = 'TOGGLE_TASK';\n\n// Initial state for a task list\nconst initialTasksState = {\n  tasks: []\n};\n\n// Task Reducer\nfunction tasksReducer(state = initialTasksState, action) {\n  switch (action.type) {\n    case ADD_TASK:\n      return {\n        ...state,\n        tasks: [...state.tasks, { id: Date.now(), text: action.payload, completed: false }]\n      };\n    case TOGGLE_TASK:\n      return {\n        ...state,\n        tasks: state.tasks.map(task =>\n          task.id === action.payload\n            ? { ...task, completed: !task.completed }\n            : task\n        )\n      };\n    default:\n      return state;\n  }\n}\n\n// Create the store\nconst store = createStore(tasksReducer);\n\n// Dispatch actions\nstore.dispatch({ type: ADD_TASK, payload: 'Learn Redux' });\nstore.dispatch({ type: ADD_TASK, payload: 'Build a Redux App' });\n\nconsole.log('Current State after adding tasks:', store.getState());\n\nconst firstTask = store.getState().tasks[0];\nif (firstTask) {\n  store.dispatch({ type: TOGGLE_TASK, payload: firstTask.id });\n}\n\nconsole.log('Current State after toggling task:', store.getState());",
              "explanation": "This example demonstrates a basic Redux setup. It defines action types, an initial state, and a simple `tasksReducer` that handles adding and toggling tasks immutably. The `createStore` function initializes the Redux store, and `dispatch` is used to send actions that modify the state. `getState()` retrieves the current state.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_redux_core_mcq_1",
            "question_redux_core_open_1",
            "question_redux_core_flashcard_1",
            "question_redux_core_code_1"
          ],
          "relatedTasks": [
            "task_implement_simple_redux"
          ],
          "tags": [
            "Redux",
            "State Management",
            "Core Concepts",
            "Store",
            "Reducer",
            "Action"
          ],
          "technology": "Redux",
          "prerequisites": [
            "JavaScript_ES6",
            "Functional_Programming_Basics"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Redux_Toolkit",
            "React_Redux_Integration",
            "Redux_Middleware"
          ]
        },
        {
          "id": "theory_combine_reducers",
          "title": "Scaling Redux with combineReducers",
          "content": "As applications grow, managing the entire state within a single, monolithic reducer can become unwieldy and hard to maintain. Redux provides the `combineReducers` utility to help organize your reducer logic by splitting it into separate functions, each managing its own slice of the global state.\n\n### How `combineReducers` Works\n\n`combineReducers` takes an object where each key is a part of your state tree, and its value is a corresponding reducer function. For instance, if you have `userReducer` managing `userState` and `uiReducer` managing `uiState`, `combineReducers` will create a root reducer that calls `userReducer` with `state.userState` and `uiReducer` with `state.uiState`.\n\nThe global state object produced by `combineReducers` will have keys that match the keys you passed to it. So, if you combine `userState: userReducer` and `uiState: uiReducer`, your global state will look like this:\n\n```json\n{\n  \"userState\": { /* state managed by userReducer */ },\n  \"uiState\": { /* state managed by uiReducer */ }\n}\n```\n\nEach individual reducer passed to `combineReducers` receives only its slice of the state. For example, `userReducer` will receive `state.userState` as its `state` argument, not the entire global state.\n\n### Accessing Combined State in Components\n\nWhen connecting a React component to the Redux store (e.g., using `react-redux`'s `mapStateToProps`), you access the state using the keys defined in `combineReducers`.\n\nFor example, if your root reducer is defined as:\n\n```typescript\nconst rootReducer = combineReducers({\n  userState: userReducer,\n  uiState: uiReducer\n});\n```\n\nThen in `mapStateToProps`, you would access `state.userState.users` or `state.uiState.theme`.\n",
          "examples": [
            {
              "id": "example_combine_reducers_1",
              "title": "Combining Multiple Reducers",
              "code": "import { createStore, combineReducers } from 'redux';\n\n// User reducer manages user-related state\nconst initialUserState = {\n  users: [],\n  currentUser: null,\n  isLoading: false\n};\n\nfunction userReducer(state = initialUserState, action) {\n  switch (action.type) {\n    case 'FETCH_USERS_SUCCESS':\n      return {\n        ...state,\n        users: action.payload,\n        isLoading: false\n      };\n    case 'SET_CURRENT_USER':\n      return {\n        ...state,\n        currentUser: action.payload\n      };\n    default:\n      return state;\n  }\n}\n\n// UI reducer manages UI state\nconst initialUiState = {\n  theme: 'light',\n  sidebarOpen: false,\n  notifications: []\n};\n\nfunction uiReducer(state = initialUiState, action) {\n  switch (action.type) {\n    case 'TOGGLE_THEME':\n      return {\n        ...state,\n        theme: state.theme === 'light' ? 'dark' : 'light'\n      };\n    case 'TOGGLE_SIDEBAR':\n      return {\n        ...state,\n        sidebarOpen: !state.sidebarOpen\n      };\n    default:\n      return state;\n  }\n}\n\n// Combine reducers\nconst rootReducer = combineReducers({\n  userState: userReducer,\n  uiState: uiReducer\n});\n\n// Create the store with the combined reducer\nconst store = createStore(rootReducer);\n\n// Example dispatching actions and accessing state\nstore.dispatch({ type: 'FETCH_USERS_SUCCESS', payload: [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }] });\nstore.dispatch({ type: 'SET_CURRENT_USER', payload: { id: 1, name: 'Alice' } });\nstore.dispatch({ type: 'TOGGLE_THEME' });\nstore.dispatch({ type: 'TOGGLE_SIDEBAR' });\n\nconsole.log('Current combined state:', store.getState());\n/* Expected output structure:\n{\n  userState: { users: [...], currentUser: {id: 1, name: 'Alice'}, isLoading: false },\n  uiState: { theme: 'dark', sidebarOpen: true, notifications: [] }\n}\n*/\n\n// In a connected component (conceptual example):\nfunction mapStateToProps(state) {\n  return {\n    users: state.userState.users,\n    theme: state.uiState.theme,\n    sidebarOpen: state.uiState.sidebarOpen\n  };\n}\n\nconst stateFromMapStateToProps = mapStateToProps(store.getState());\nconsole.log('State extracted by mapStateToProps:', stateFromMapStateToProps);\n",
              "explanation": "This example showcases `combineReducers` in action. `userReducer` and `uiReducer` manage distinct parts of the application state. `combineReducers` merges them into a single `rootReducer`, structuring the global state with `userState` and `uiState` keys. The `mapStateToProps` snippet illustrates how components would then access this nested state.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_combine_reducers_mcq_1",
            "question_combine_reducers_open_1",
            "question_combine_reducers_flashcard_1",
            "question_combine_reducers_code_1",
            "question_combine_reducers_open_2"
          ],
          "relatedTasks": [
            "task_refactor_with_combine_reducers"
          ],
          "tags": [
            "Redux",
            "State Management",
            "combineReducers",
            "Reducer Composition",
            "Architecture"
          ],
          "technology": "Redux",
          "prerequisites": [
            "Redux_Core_Concepts"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Large_Scale_Redux_Applications",
            "Redux_Toolkit_Configuration"
          ]
        },
        {
          "id": "theory_reducer_immutability",
          "title": "Reducer Immutability: Pure Functions in Redux",
          "content": "A fundamental principle in Redux is that reducers must be pure functions. This means they must:\n\n1.  **Return the same output for the same input:** Given the same `state` and `action`, a reducer should always produce the identical next `state`.\n2.  **Have no side effects:** They should not perform any operations that affect the outside world (e.g., API calls, modifying browser storage, generating random numbers).\n3.  **Never mutate their arguments:** Crucially, a reducer must *not* directly modify the `state` object or `action` object it receives. Instead, it must return a *new* state object with the desired changes.\n\n### Why Immutability is Crucial\n\n*   **Predictability:** Ensures that state changes are explicit and traceable, making debugging easier.\n*   **Performance:** React and Redux rely on shallow comparisons to detect state changes. If you mutate the original object, React/Redux might not detect a change, leading to components not re-rendering when they should, or re-rendering unnecessarily.\n*   **Time-Travel Debugging:** Tools like Redux DevTools rely on immutability to replay actions and inspect state at different points in time.\n*   **Concurrency:** Immutable data structures are inherently thread-safe (though less of a concern in single-threaded JavaScript, it promotes good patterns).\n\n### Common Mutation Anti-Patterns and Correct Approaches\n\nThe example `badReducer` demonstrates common ways to accidentally mutate state:\n\n*   **Direct array modification:** `state.push()` or `state.splice()` directly alter the original array. Use `[...state, newItem]` or `state.filter()` instead.\n*   **Direct object property modification:** `item.text = action.text` directly alters a property of an object already in the state. Use object spread `...` or `Object.assign()` to create a new object.\n\nWhen updating nested state, remember to copy every level of the nested structure that you are modifying.\n",
          "examples": [
            {
              "id": "example_immutability_1",
              "title": "Incorrect: Impure Reducer Mutating State",
              "code": "// ❌ INCORRECT: Impure reducer that mutates state\nfunction badReducer(state = [], action) {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      // This directly modifies the original state array!\n      state.push({ id: action.id, text: action.text });\n      return state;\n    case 'UPDATE_ITEM':\n      // This modifies properties of objects in the original state\n      const item = state.find(i => i.id === action.id);\n      if (item) {\n        item.text = action.text;\n      }\n      return state;\n    default:\n      return state;\n  }\n}",
              "explanation": "This `badReducer` violates immutability. `state.push()` modifies the `state` array in place. Similarly, finding an `item` and directly setting `item.text` modifies an object that is part of the original state array. This leads to unpredictable behavior and can break Redux's change detection.",
              "language": "typescript"
            },
            {
              "id": "example_immutability_2",
              "title": "Correct: Pure Reducer Maintaining Immutability",
              "code": "// ✅ CORRECT: Pure reducer that maintains immutability\nfunction goodReducer(state = [], action) {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      // Returns a new array with the new item\n      return [\n        ...state,\n        { id: action.id, text: action.text, completed: false }\n      ];\n    case 'UPDATE_ITEM':\n      // Returns a new array with a new object for the updated item\n      return state.map(item =>\n        item.id === action.id\n          ? { ...item, text: action.text }\n          : item\n      );\n    case 'DELETE_ITEM':\n      // Returns a new array, excluding the deleted item\n      return state.filter(item => item.id !== action.id);\n    case 'TOGGLE_COMPLETED':\n      // Returns a new array with a new object for the toggled item\n      return state.map(item => \n        item.id === action.id\n          ? { ...item, completed: !item.completed }\n          : item\n      );\n    default:\n      return state;\n  }\n}",
              "explanation": "This `goodReducer` adheres to immutability. For `ADD_ITEM`, it uses the spread syntax (`...state`) to create a new array. For `UPDATE_ITEM` and `TOGGLE_COMPLETED`, it uses `map()` to return a *new* array, and for the modified item within the array, it uses object spread (`...item`) to create a *new* item object with the updated property. `DELETE_ITEM` uses `filter()` to return a new array. This ensures that the original state is never modified.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_immutability_mcq_1",
            "question_immutability_open_1",
            "question_immutability_flashcard_1",
            "question_immutability_code_1"
          ],
          "relatedTasks": [
            "task_fix_impure_reducer"
          ],
          "tags": [
            "Redux",
            "Immutability",
            "Pure Functions",
            "Reducer",
            "Best Practices",
            "Debugging"
          ],
          "technology": "Redux",
          "prerequisites": [
            "Functional_Programming_Basics",
            "JavaScript_Object_Array_Spread"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Robust_Redux_Applications",
            "Debugging_Redux_State"
          ]
        },
        {
          "id": "theory_redux_selectors_reselect",
          "title": "Redux Selectors and Reselect",
          "content": "### Redux Selectors\n\nSelectors are functions that take the Redux state as an argument and return some derived data from that state. They serve several important purposes:\n\n*   **Encapsulation:** They abstract away the state shape from components, making components more resilient to changes in state structure.\n*   **Reusability:** A single selector can be used by multiple components.\n*   **Performance:** When combined with memoization libraries, selectors can prevent unnecessary re-renders of components by ensuring that derived data is only recomputed when its dependencies change.\n\n### Reselect for Memoization\n\n`Reselect` is a popular library for creating memoized selectors. A memoized selector will only recompute its output if its input arguments (the values returned by its 'input selectors') have changed. If the inputs are the same as the last time the selector was run, it returns the previously computed result, saving computation time.\n\n`Reselect` provides `createSelector` which takes an array of input selectors and a result function. The input selectors retrieve specific slices or pieces of state, and their results are passed as arguments to the result function.\n",
          "examples": [
            {
              "id": "example_selectors_1",
              "title": "Basic Selector Example",
              "code": "// Assuming a state structure like:\n// {\n//   userState: {\n//     users: [{id: 1, name: 'Alice', isActive: true}, {id: 2, name: 'Bob', isActive: false}],\n//     currentUser: {id: 1, name: 'Alice'}\n//   }\n// }\n\n// A simple selector to get all users\nconst getUsers = (state) => state.userState.users;\n\n// A selector to get the current user\nconst getCurrentUser = (state) => state.userState.currentUser;\n\n// A selector to get only active users\nconst getActiveUsers = (state) => {\n  const users = getUsers(state); // Re-uses the getUsers selector\n  return users.filter(user => user.isActive);\n};\n\n// Example usage with a dummy state\nconst dummyState = {\n  userState: {\n    users: [{id: 1, name: 'Alice', isActive: true}, {id: 2, name: 'Bob', isActive: false}],\n    currentUser: {id: 1, name: 'Alice'}\n  }\n};\n\nconsole.log('All Users:', getUsers(dummyState));\nconsole.log('Active Users:', getActiveUsers(dummyState));",
              "explanation": "This example shows simple selectors. `getUsers` and `getCurrentUser` directly pull data from the state. `getActiveUsers` demonstrates how selectors can compose by calling other selectors to derive more complex data. This keeps the logic for accessing and transforming state centralized.",
              "language": "typescript"
            },
            {
              "id": "example_selectors_2",
              "title": "Reselect Memoized Selector Example",
              "code": "import { createSelector } from 'reselect';\n\n// Input Selectors\nconst getUsers = (state) => state.userState.users;\nconst getSearchTerm = (state) => state.uiState.searchTerm;\n\n// Memoized Selector for filtered users\nconst getFilteredUsers = createSelector(\n  [getUsers, getSearchTerm], // Array of input selectors\n  (users, searchTerm) => {   // Result function, receives results of input selectors\n    console.log('Recalculating filtered users...'); // This will only log if inputs change\n    if (!searchTerm) {\n      return users;\n    }\n    return users.filter(user => \n      user.name.toLowerCase().includes(searchTerm.toLowerCase())\n    );\n  }\n);\n\n// Example usage with a dummy state\nconst state1 = {\n  userState: { users: [{id: 1, name: 'Alice'}, {id: 2, name: 'Bob'}] },\n  uiState: { searchTerm: 'a' }\n};\n\nconst state2 = {\n  userState: { users: [{id: 1, name: 'Alice'}, {id: 2, name: 'Bob'}] },\n  uiState: { searchTerm: 'a' }\n};\n\nconst state3 = {\n  userState: { users: [{id: 1, name: 'Alice'}, {id: 2, name: 'Bob'}] },\n  uiState: { searchTerm: 'b' }\n};\n\nconsole.log('1st call:', getFilteredUsers(state1));\nconsole.log('2nd call (same inputs):', getFilteredUsers(state2)); // 'Recalculating...' will not log again\nconsole.log('3rd call (different inputs):', getFilteredUsers(state3)); // 'Recalculating...' will log\n",
              "explanation": "This example uses `createSelector` from `reselect`. `getUsers` and `getSearchTerm` are input selectors. `getFilteredUsers` is a memoized selector; its result function (`(users, searchTerm) => { ... }`) only runs if `users` or `searchTerm` (as returned by their respective input selectors) have changed. This prevents expensive re-computations when unrelated parts of the state change.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_selectors_mcq_1",
            "question_selectors_open_1",
            "question_selectors_flashcard_1"
          ],
          "relatedTasks": [
            "task_implement_redux_selectors"
          ],
          "tags": [
            "Redux",
            "Selectors",
            "Reselect",
            "Memoization",
            "Performance",
            "State Derivation"
          ],
          "technology": "Redux",
          "prerequisites": [
            "Redux_Core_Concepts",
            "Functional_Programming_Basics"
          ],
          "complexity": 8,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "Optimized_Redux_Applications",
            "Complex_State_Derivation"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_redux_core_mcq_1",
          "topic": "Redux Core Principles",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is NOT a core principle of Redux?",
          "answer": "State can be directly modified by components.",
          "options": [
            "The state of your whole application is stored in a single store.",
            "The only way to change the state is to emit an action.",
            "Changes to the state tree are made with pure functions (reducers).",
            "State can be directly modified by components."
          ],
          "analysisPoints": [
            "This question tests understanding of Redux's fundamental tenets.",
            "The 'single source of truth' principle dictates all state resides in one store.",
            "Immutability and actions as the sole means of state change are critical for predictability.",
            "Direct state modification by components bypasses Redux's architecture and leads to unpredictable behavior."
          ],
          "keyConcepts": [
            "Redux Store",
            "Redux Actions",
            "Redux Reducers",
            "Immutability",
            "Single Source of Truth"
          ],
          "evaluationCriteria": [
            "Recall of Redux's three core principles",
            "Ability to identify anti-patterns in Redux state management"
          ],
          "example": "Redux emphasizes a strict unidirectional data flow. Components dispatch actions, which are then processed by reducers to produce a new state. Components never directly alter the state object.",
          "tags": [
            "Redux",
            "Core Concepts",
            "Principles",
            "MCQ"
          ],
          "prerequisites": [
            "Redux_Core_Concepts"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_redux_core_open_1",
          "topic": "Redux Store Responsibilities",
          "level": "medium",
          "type": "open",
          "question": "Describe the main responsibilities of the Redux store. How do other parts of a Redux application interact with it?",
          "answer": "The Redux store has four main responsibilities:\n\n1.  **Holds the application state:** It is the single source of truth for the entire application's state.\n2.  **Allows access to the state:** Components or other parts of the application can retrieve the current state using the `store.getState()` method.\n3.  **Allows the state to be updated:** The only way to change the state is by dispatching an action using the `store.dispatch(action)` method.\n4.  **Registers listener callbacks:** Components can subscribe to state changes using `store.subscribe(listener)`. The provided listener function will be called whenever the state changes. It also allows unregistering listeners by returning a function from `subscribe` that, when called, unsubscribes the listener.\n\nOther parts of a Redux application interact with the store as follows:\n\n*   **Components:** Read state using `getState()` (or `mapStateToProps` in React-Redux) and trigger state changes by calling `dispatch()`.\n*   **Actions:** Are dispatched to the store to describe what happened.\n*   **Reducers:** Are the functions that the store uses internally to calculate the next state based on the current state and a dispatched action. The store passes the current state and action to the root reducer.",
          "analysisPoints": [
            "Evaluates comprehensive understanding of the Redux store's role.",
            "Checks knowledge of key methods (`getState`, `dispatch`, `subscribe`).",
            "Assesses understanding of interaction flow between store, actions, reducers, and components."
          ],
          "keyConcepts": [
            "Redux Store",
            "getState()",
            "dispatch()",
            "subscribe()",
            "Unidirectional Data Flow"
          ],
          "evaluationCriteria": [
            "Completeness of responsibilities listed",
            "Accuracy of interaction descriptions",
            "Clarity and conciseness of explanation"
          ],
          "example": null,
          "tags": [
            "Redux",
            "Store",
            "Core Concepts",
            "Open-ended"
          ],
          "prerequisites": [
            "Redux_Core_Concepts"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_redux_core_flashcard_1",
          "topic": "Redux Actions",
          "level": "easy",
          "type": "flashcard",
          "question": "What is an action in Redux, and what is its primary purpose?",
          "answer": "An action in Redux is a plain JavaScript object that describes 'what happened'. Its primary purpose is to carry information from your application to the Redux store, being the *only* way to trigger a state change.",
          "analysisPoints": [
            "Tests recall of action definition.",
            "Tests understanding of action's role in state updates."
          ],
          "keyConcepts": [
            "Redux Actions",
            "State Mutation"
          ],
          "evaluationCriteria": [
            "Accuracy of definition",
            "Clarity of purpose"
          ],
          "example": null,
          "tags": [
            "Redux",
            "Action",
            "Flashcard"
          ],
          "prerequisites": [
            "Redux_Core_Concepts"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_redux_core_code_1",
          "topic": "Redux Reducer Implementation",
          "level": "medium",
          "type": "code",
          "question": "Implement a Redux reducer for managing a list of `products`. The reducer should handle two action types: `ADD_PRODUCT` (payload: `{ id, name, price }`) and `REMOVE_PRODUCT` (payload: `productId`). Ensure immutability.",
          "answer": "```typescript\nconst initialProductsState = {\n  products: []\n};\n\nfunction productsReducer(state = initialProductsState, action) {\n  switch (action.type) {\n    case 'ADD_PRODUCT':\n      return {\n        ...state,\n        products: [...state.products, action.payload]\n      };\n    case 'REMOVE_PRODUCT':\n      return {\n        ...state,\n        products: state.products.filter(product => product.id !== action.payload)\n      };\n    default:\n      return state;\n  }\n}\n\n// Example Usage (for testing):\n// const store = createStore(productsReducer);\n// console.log('Initial state:', store.getState());\n// store.dispatch({ type: 'ADD_PRODUCT', payload: { id: 1, name: 'Laptop', price: 1200 } });\n// store.dispatch({ type: 'ADD_PRODUCT', payload: { id: 2, name: 'Mouse', price: 25 } });\n// console.log('After add:', store.getState());\n// store.dispatch({ type: 'REMOVE_PRODUCT', payload: 1 });\n// console.log('After remove:', store.getState());\n```",
          "analysisPoints": [
            "Tests ability to define initial state.",
            "Tests correct usage of `switch` statement for action types.",
            "Tests understanding and application of immutability principles using spread syntax for arrays and objects (`...state`, `...state.products`).",
            "Tests common array manipulation methods like `filter` for removal and `[...]` for addition without mutation."
          ],
          "keyConcepts": [
            "Redux Reducer",
            "Immutability",
            "Initial State",
            "Actions",
            "Array Manipulation"
          ],
          "evaluationCriteria": [
            "Correctness of reducer logic for both action types",
            "Adherence to immutability (no direct state mutation)",
            "Proper structure of the returned state object"
          ],
          "example": null,
          "tags": [
            "Redux",
            "Reducer",
            "Code Challenge",
            "Immutability"
          ],
          "prerequisites": [
            "Redux_Core_Concepts",
            "JavaScript_ES6"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_combine_reducers_mcq_1",
          "topic": "`combineReducers` Functionality",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following Redux setup:\n\n```typescript\n// userReducer manages { isAuthenticated: boolean, data: {} }\n// productReducer manages { list: [], isLoading: boolean }\n\nconst rootReducer = combineReducers({\n  user: userReducer,\n  products: productReducer\n});\n\nconst store = createStore(rootReducer);\n```\n\nIf you want to access the list of products from the Redux state in a connected React component, which of the following `mapStateToProps` implementations is correct?",
          "answer": "```typescript\nconst mapStateToProps = (state) => ({\n  productList: state.products.list\n});\n```",
          "options": [
            "```typescript\nconst mapStateToProps = (state) => ({\n  productList: state.list\n});\n```",
            "```typescript\nconst mapStateToProps = (state) => ({\n  productList: state.productReducer.list\n});\n```",
            "```typescript\nconst mapStateToProps = (state) => ({\n  productList: state.products.list\n});\n```",
            "```typescript\nconst mapStateToProps = (state) => ({\n  productList: state.rootReducer.products.list\n});\n```"
          ],
          "analysisPoints": [
            "Tests understanding of how `combineReducers` structures the global state.",
            "Emphasizes that keys passed to `combineReducers` become the keys in the top-level state object.",
            "Distinguishes between the reducer function name and the state slice name.",
            "Highlights the correct path to nested state managed by individual reducers."
          ],
          "keyConcepts": [
            "combineReducers",
            "State Structure",
            "mapStateToProps",
            "Nested State"
          ],
          "evaluationCriteria": [
            "Correct identification of state path after `combineReducers`.",
            "Understanding of the relationship between reducer keys and state keys."
          ],
          "example": "When `combineReducers` is called with an object `{ key1: reducer1, key2: reducer2 }`, the global state object will have properties `key1` and `key2`. To access data managed by `reducer1`, you'd typically go `state.key1.dataProperty`.",
          "tags": [
            "Redux",
            "combineReducers",
            "State Access",
            "MCQ"
          ],
          "prerequisites": [
            "Redux_Core_Concepts",
            "React_Redux_Integration"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_combine_reducers_open_1",
          "topic": "Benefits of `combineReducers`",
          "level": "medium",
          "type": "open",
          "question": "Explain the primary benefits of using `combineReducers` in a Redux application. When would you typically choose to use it over a single root reducer?",
          "answer": "The primary benefits of using `combineReducers` are:\n\n1.  **Modularity and Organization:** It allows you to split your reducer logic into smaller, more manageable functions, each responsible for a specific slice of the state. This makes the codebase easier to understand, navigate, and maintain.\n2.  **Encapsulation:** Each reducer is concerned only with its own part of the state, reducing cognitive load and preventing accidental side effects on other parts of the state.\n3.  **Scalability:** As an application grows and its state becomes more complex, `combineReducers` provides a structured way to scale the state management logic without creating a monolithic reducer.\n4.  **Team Collaboration:** Different team members can work on different parts of the application's state and corresponding reducers independently, minimizing merge conflicts.\n\nYou would typically choose to use `combineReducers` when:\n\n*   Your application state can be logically divided into distinct, independent domains (e.g., `user`, `products`, `ui`, `cart`).\n*   Your single root reducer starts becoming too large and complex, handling too many action types and nested state structures.\n*   You want to promote a clearer separation of concerns within your Redux logic.\n\nEven for relatively small applications, it's often good practice to start with `combineReducers` as it sets a good foundation for future growth.",
          "analysisPoints": [
            "Tests understanding of architectural patterns in Redux.",
            "Evaluates awareness of `combineReducers` benefits beyond just technical functionality.",
            "Assesses ability to provide practical scenarios for its use."
          ],
          "keyConcepts": [
            "combineReducers",
            "Redux Architecture",
            "Code Organization",
            "Scalability",
            "Modular Design"
          ],
          "evaluationCriteria": [
            "Comprehensiveness of listed benefits",
            "Relevance of use cases provided",
            "Clarity and structure of the explanation"
          ],
          "example": null,
          "tags": [
            "Redux",
            "combineReducers",
            "Architecture",
            "Open-ended"
          ],
          "prerequisites": [
            "Redux_Core_Concepts"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_combine_reducers_flashcard_1",
          "topic": "`combineReducers` Input and Output",
          "level": "easy",
          "type": "flashcard",
          "question": "What does `combineReducers` take as input, and what does it return?",
          "answer": "`combineReducers` takes an object whose keys represent state slices and whose values are individual reducer functions. It returns a single root reducer function that can be passed to `createStore`.",
          "analysisPoints": [
            "Tests basic recall of `combineReducers` signature and purpose.",
            "Ensures understanding of the transition from multiple reducers to a single root reducer."
          ],
          "keyConcepts": [
            "combineReducers",
            "Root Reducer",
            "State Slices"
          ],
          "evaluationCriteria": [
            "Accuracy of input and output description."
          ],
          "example": null,
          "tags": [
            "Redux",
            "combineReducers",
            "Flashcard"
          ],
          "prerequisites": [
            "Redux_Core_Concepts"
          ],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_combine_reducers_code_1",
          "topic": "State Structure with `combineReducers`",
          "level": "medium",
          "type": "code",
          "question": "Given the following reducers and their initial states:\n\n```typescript\n// authReducer initial state: { isAuthenticated: false, user: null }\n// settingsReducer initial state: { theme: 'light', notificationsEnabled: true }\n\n// Assume authReducer and settingsReducer are correctly implemented pure functions.\n```\n\nWrite the `combineReducers` call and then describe the structure of the Redux state object if these reducers are combined as `auth: authReducer` and `appSettings: settingsReducer`.",
          "answer": "```typescript\nimport { combineReducers } from 'redux';\n\n// Assume authReducer and settingsReducer are defined elsewhere\nfunction authReducer(state = { isAuthenticated: false, user: null }, action) {\n  // ... (reducer logic)\n  return state;\n}\n\nfunction settingsReducer(state = { theme: 'light', notificationsEnabled: true }, action) {\n  // ... (reducer logic)\n  return state;\n}\n\nconst rootReducer = combineReducers({\n  auth: authReducer,\n  appSettings: settingsReducer\n});\n\n// Example of what the state structure would look like:\nconst exampleState = {\n  auth: { isAuthenticated: false, user: null },\n  appSettings: { theme: 'light', notificationsEnabled: true }\n};\n\n// You can verify this using a store:\n// import { createStore } from 'redux';\n// const store = createStore(rootReducer);\n// console.log(store.getState());\n```\n\nThe Redux state object would have the following structure:\n\n```json\n{\n  \"auth\": {\n    \"isAuthenticated\": false,\n    \"user\": null\n  },\n  \"appSettings\": {\n    \"theme\": \"light\",\n    \"notificationsEnabled\": true\n  }\n}\n```",
          "analysisPoints": [
            "Tests practical application of `combineReducers`.",
            "Verifies understanding of how `combineReducers` maps reducer keys to state slice keys.",
            "Assesses ability to predict the resulting state shape."
          ],
          "keyConcepts": [
            "combineReducers",
            "State Structure",
            "Initial State",
            "Reducer Composition"
          ],
          "evaluationCriteria": [
            "Correct `combineReducers` syntax.",
            "Accurate representation of the resulting global state shape."
          ],
          "example": null,
          "tags": [
            "Redux",
            "combineReducers",
            "Code Challenge",
            "State Structure"
          ],
          "prerequisites": [
            "Redux_Core_Concepts"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_combine_reducers_open_2",
          "topic": "Reducer State Argument with `combineReducers`",
          "level": "hard",
          "type": "open",
          "question": "When using `combineReducers`, how does the `state` argument passed to an individual reducer (e.g., `userReducer`) differ from the `state` argument passed to the root reducer created by `combineReducers`? Explain why this distinction is important for reducer design.",
          "answer": "When using `combineReducers`:\n\n1.  **`state` argument for the `rootReducer` (returned by `combineReducers`):** This is the **entire global Redux state object**. It contains all the slices of state managed by each individual reducer, structured according to the keys provided to `combineReducers`.\n    *   Example: If `rootReducer = combineReducers({ user: userReducer, ui: uiReducer })`, the `state` argument to `rootReducer` would look like `{ user: { /* user state */ }, ui: { /* ui state */ } }`.\n\n2.  **`state` argument for an `individualReducer` (e.g., `userReducer`):** This is only the **slice of the global state that the individual reducer is responsible for managing**. `combineReducers` is responsible for extracting the correct slice from the global state and passing it to the corresponding reducer.\n    *   Example: For `userReducer`, the `state` argument will be `state.user` (assuming `user` was the key used in `combineReducers`). It will *not* receive the `ui` slice or any other part of the global state.\n\n**Why this distinction is important for reducer design:**\n\n*   **Separation of Concerns:** Each individual reducer can be designed to be completely unaware of other parts of the application's state. It only needs to know about the slice of state it manages. This makes reducers simpler, more focused, and easier to test in isolation.\n*   **Prevents Accidental Cross-Slice Dependencies:** If individual reducers received the entire global state, there's a risk of them accidentally or unintentionally modifying or depending on state managed by other reducers, leading to hard-to-trace bugs and violating the principle of single responsibility.\n*   **Easier Reasoning:** When debugging or understanding a state change, you only need to look at the specific reducer responsible for that slice, rather than needing to understand how a large, complex global state is being manipulated by a single function.",
          "analysisPoints": [
            "Tests deep understanding of `combineReducers` internal workings.",
            "Evaluates comprehension of scope for state arguments in different reducer contexts.",
            "Assesses ability to articulate the architectural implications and benefits of this design choice."
          ],
          "keyConcepts": [
            "combineReducers",
            "State Slices",
            "Root Reducer",
            "Individual Reducer",
            "Separation of Concerns",
            "Encapsulation"
          ],
          "evaluationCriteria": [
            "Accurate description of `state` argument for both root and individual reducers.",
            "Clear explanation of the importance of this design for maintainability and debugging.",
            "Demonstrates advanced knowledge of Redux internal mechanisms."
          ],
          "example": null,
          "tags": [
            "Redux",
            "combineReducers",
            "Reducer Design",
            "Advanced Redux",
            "Open-ended"
          ],
          "prerequisites": [
            "Redux_Core_Concepts",
            "combineReducers"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_immutability_mcq_1",
          "topic": "Reducer Immutability",
          "level": "medium",
          "type": "mcq",
          "question": "Given the following Redux reducer attempting to add a new item:\n\n```typescript\nfunction itemsReducer(state = [], action) {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      state.push(action.payload); // Line A\n      return state;               // Line B\n    default:\n      return state;\n  }\n}\n```\n\nWhich statement best describes the issue with this `itemsReducer` in the context of Redux principles?",
          "answer": "It mutates the original `state` array directly, violating Redux's immutability principle.",
          "options": [
            "It correctly adds an item and follows Redux's immutability rules.",
            "It mutates the original `state` array directly, violating Redux's immutability principle.",
            "It should use `Object.assign()` instead of `push()` for arrays.",
            "The `action.payload` is not correctly structured for adding an item."
          ],
          "analysisPoints": [
            "Directly targets the mutation anti-pattern in reducers.",
            "Tests understanding of array mutation methods (`push`) vs. immutable updates (e.g., spread syntax).",
            "Reinforces the core Redux principle that state must never be mutated."
          ],
          "keyConcepts": [
            "Reducer Immutability",
            "Pure Functions",
            "State Mutation",
            "Array Immutability"
          ],
          "evaluationCriteria": [
            "Identification of the specific mutation.",
            "Understanding of the violated Redux principle."
          ],
          "example": "To correctly add an item to an array immutably, you should return a *new* array: `return [...state, action.payload];` This creates a new array instance, leaving the original `state` array untouched.",
          "tags": [
            "Redux",
            "Immutability",
            "Reducer",
            "MCQ"
          ],
          "prerequisites": [
            "Reducer_Immutability",
            "JavaScript_ES6"
          ],
          "complexity": 5,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutability_open_1",
          "topic": "Why Immutability in Redux?",
          "level": "hard",
          "type": "open",
          "question": "Why is it critically important for Redux reducers to be pure functions and to maintain immutability? Discuss at least three practical implications if reducers were to mutate state directly.",
          "answer": "It is critically important for Redux reducers to be pure functions and to maintain immutability for several reasons:\n\n1.  **Predictability:** Pure functions, by definition, always produce the same output for the same input and have no side effects. This makes Redux state changes predictable and easy to reason about. You know exactly what the next state will be given the current state and an action.\n2.  **Simplified Debugging and Time Travel:** Redux DevTools heavily relies on immutability. If state is never mutated, every state snapshot represents a distinct point in time. This allows for 'time-travel debugging,' where you can replay actions, revert to previous states, and inspect the state tree at any point, which would be impossible if state was mutated in place.\n3.  **Performance Optimization in UI Frameworks (e.g., React):** Libraries like React (especially when using `PureComponent`, `React.memo`, or `shouldComponentUpdate`) and `react-redux` (via `connect` or `useSelector`) perform shallow comparisons to determine if components need to re-render. If you mutate an object or array, its reference remains the same, even if its contents change. A shallow comparison would then incorrectly conclude that the state (or prop) hasn't changed, preventing the component from re-rendering and leading to UI bugs. By returning new objects/arrays, Redux ensures that references *do* change when content changes, correctly triggering updates.\n4.  **Concurrency Safety (Conceptual):** While JavaScript is single-threaded, the principles of immutable data structures lend themselves well to concurrent environments, as multiple threads can read data without needing locks, since the data never changes after creation.\n\n**Practical implications if reducers mutated state directly:**\n\n1.  **Unpredictable UI Behavior:** Components relying on state updates might not re-render because shallow equality checks would fail to detect changes in mutated objects/arrays. This leads to stale UI that doesn't reflect the true application state.\n2.  **Broken Time-Travel Debugging:** Redux DevTools would lose its ability to show state history or replay actions, as previous state snapshots would be corrupted by subsequent mutations.\n3.  **Difficult to Debug and Test:** Tracking down bugs would become extremely challenging. A state change might have originated from an unexpected reducer mutating an object that was supposed to be owned by another. Testing reducers in isolation would also be harder as they wouldn't consistently produce the same output for the same input.",
          "analysisPoints": [
            "Tests deep understanding of Redux principles and their practical impact.",
            "Evaluates ability to connect immutability to debugging, performance, and predictability.",
            "Requires critical thinking about the consequences of violating core principles."
          ],
          "keyConcepts": [
            "Reducer Immutability",
            "Pure Functions",
            "Time-Travel Debugging",
            "React Performance",
            "Shallow Comparison",
            "Predictability"
          ],
          "evaluationCriteria": [
            "Comprehensiveness of reasons for immutability.",
            "Accuracy and detail of practical implications.",
            "Clarity and logical flow of explanation."
          ],
          "example": null,
          "tags": [
            "Redux",
            "Immutability",
            "Pure Functions",
            "Performance",
            "Debugging",
            "Open-ended"
          ],
          "prerequisites": [
            "Reducer_Immutability",
            "React_Redux_Integration"
          ],
          "complexity": 9,
          "interviewFrequency": 10,
          "learningPath": "advanced"
        },
        {
          "id": "question_immutability_flashcard_1",
          "topic": "Mutating Arrays in Redux",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the immutable way to add an item to an array in a Redux reducer?",
          "answer": "The immutable way to add an item to an array is to return a *new* array using the spread syntax: `return [...state.arrayName, newItem];` or `return state.concat(newItem);`.",
          "analysisPoints": [
            "Tests recall of immutable array operations.",
            "Focuses on a common pattern in reducers."
          ],
          "keyConcepts": [
            "Immutability",
            "Array Spread Syntax",
            "Array.prototype.concat"
          ],
          "evaluationCriteria": [
            "Correct immutable array operation."
          ],
          "example": null,
          "tags": [
            "Redux",
            "Immutability",
            "Array",
            "Flashcard"
          ],
          "prerequisites": [
            "Reducer_Immutability"
          ],
          "complexity": 4,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_immutability_code_1",
          "topic": "Correcting an Impure Reducer",
          "level": "medium",
          "type": "code",
          "question": "The following `cartReducer` is impure. Refactor it to ensure all state updates are immutable. It should handle `ADD_ITEM` (payload: `{id, name, quantity}`) and `UPDATE_ITEM_QUANTITY` (payload: `{id, quantity}` actions).\n\n```typescript\nconst initialCartState = { items: [], total: 0 };\n\nfunction cartReducer(state = initialCartState, action) {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      const existingItem = state.items.find(item => item.id === action.payload.id);\n      if (existingItem) {\n        // IMPURE: Mutating existing item directly\n        existingItem.quantity += action.payload.quantity;\n      } else {\n        // IMPURE: Mutating array directly\n        state.items.push(action.payload);\n      }\n      // IMPURE: Recalculating total based on mutated state\n      state.total = state.items.reduce((acc, item) => acc + (item.quantity * item.price), 0);\n      return state;\n\n    case 'UPDATE_ITEM_QUANTITY':\n      const itemToUpdate = state.items.find(item => item.id === action.payload.id);\n      if (itemToUpdate) {\n        // IMPURE: Mutating existing item directly\n        itemToUpdate.quantity = action.payload.quantity;\n      }\n      // IMPURE: Recalculating total based on mutated state\n      state.total = state.items.reduce((acc, item) => acc + (item.quantity * item.price), 0);\n      return state;\n\n    default:\n      return state;\n  }\n}\n```",
          "answer": "```typescript\nconst initialCartState = { items: [], total: 0 };\n\nfunction calculateTotal(items) {\n  return items.reduce((acc, item) => acc + (item.quantity * item.price), 0);\n}\n\nfunction cartReducer(state = initialCartState, action) {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      const newItem = action.payload;\n      const existingItemIndex = state.items.findIndex(item => item.id === newItem.id);\n\n      let updatedItemsForAdd;\n      if (existingItemIndex > -1) {\n        updatedItemsForAdd = state.items.map((item, index) =>\n          index === existingItemIndex\n            ? { ...item, quantity: item.quantity + newItem.quantity } // Create new item object\n            : item\n        );\n      } else {\n        updatedItemsForAdd = [...state.items, newItem]; // Create new array\n      }\n      return {\n        ...state,\n        items: updatedItemsForAdd,\n        total: calculateTotal(updatedItemsForAdd) // Calculate total based on new items array\n      };\n\n    case 'UPDATE_ITEM_QUANTITY':\n      const { id, quantity } = action.payload;\n      const updatedItemsForUpdate = state.items.map(item =>\n        item.id === id\n          ? { ...item, quantity: quantity } // Create new item object\n          : item\n      );\n      return {\n        ...state,\n        items: updatedItemsForUpdate,\n        total: calculateTotal(updatedItemsForUpdate) // Calculate total based on new items array\n      };\n\n    default:\n      return state;\n  }\n}\n\n// Example Usage (for testing):\n// import { createStore } from 'redux';\n// const store = createStore(cartReducer);\n// console.log('Initial:', store.getState());\n// store.dispatch({ type: 'ADD_ITEM', payload: { id: 1, name: 'Apple', price: 1.0, quantity: 2 } });\n// store.dispatch({ type: 'ADD_ITEM', payload: { id: 2, name: 'Banana', price: 0.5, quantity: 3 } });\n// console.log('After initial adds:', store.getState());\n// store.dispatch({ type: 'ADD_ITEM', payload: { id: 1, name: 'Apple', price: 1.0, quantity: 1 } }); // Add more Apple\n// console.log('After adding more Apple:', store.getState());\n// store.dispatch({ type: 'UPDATE_ITEM_QUANTITY', payload: { id: 2, quantity: 5 } });\n// console.log('After updating Banana quantity:', store.getState());\n```",
          "analysisPoints": [
            "Tests ability to identify and correct multiple types of mutations (array push, object property assignment).",
            "Requires using `map` for updating items within an array immutably.",
            "Requires using spread syntax (`...`) for creating new objects and arrays.",
            "Tests recalculating derived state (`total`) based on the newly created immutable state.",
            "Demonstrates handling existing items vs. new items for `ADD_ITEM`.",
            "Introduces a helper function (`calculateTotal`) for cleaner code and reusability."
          ],
          "keyConcepts": [
            "Reducer Immutability",
            "Array.prototype.map",
            "Array.prototype.findIndex",
            "Object Spread Syntax",
            "Array Spread Syntax",
            "Derived State"
          ],
          "evaluationCriteria": [
            "All mutations are removed.",
            "New arrays and objects are returned for all state modifications.",
            "Correct logic for adding new items vs. updating existing items.",
            "Total is correctly recalculated based on the new `items` array."
          ],
          "example": null,
          "tags": [
            "Redux",
            "Immutability",
            "Code Challenge",
            "Reducer",
            "Complex State"
          ],
          "prerequisites": [
            "Reducer_Immutability",
            "JavaScript_ES6"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_selectors_mcq_1",
          "topic": "Selectors Purpose",
          "level": "easy",
          "type": "mcq",
          "question": "What is the primary benefit of using a selector in Redux?",
          "answer": "To extract and transform specific pieces of state for components, encapsulating state shape details.",
          "options": [
            "To perform asynchronous operations before dispatching actions.",
            "To mutate the Redux state directly in a controlled way.",
            "To define initial state for reducers.",
            "To extract and transform specific pieces of state for components, encapsulating state shape details."
          ],
          "analysisPoints": [
            "Tests basic understanding of a selector's role.",
            "Distinguishes selectors from other Redux concepts (middleware, reducers, initial state).",
            "Highlights encapsulation and reusability as key benefits."
          ],
          "keyConcepts": [
            "Redux Selectors",
            "State Access",
            "Encapsulation",
            "Reusability"
          ],
          "evaluationCriteria": [
            "Correct identification of selector's primary function."
          ],
          "example": null,
          "tags": [
            "Redux",
            "Selectors",
            "MCQ"
          ],
          "prerequisites": [
            "Redux_Core_Concepts"
          ],
          "complexity": 4,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_selectors_open_1",
          "topic": "Reselect and Memoization",
          "level": "medium",
          "type": "open",
          "question": "Explain what memoization is in the context of Redux selectors and why `Reselect` is a valuable tool for this. Provide a scenario where `Reselect` would significantly improve application performance.",
          "answer": "### Memoization in Redux Selectors\n\nMemoization is an optimization technique used to speed up computer programs by caching the results of expensive function calls and returning the cached result when the same inputs occur again. In the context of Redux selectors, it means:\n\n*   A selector will re-calculate its derived value *only* if its input values have changed.\n*   If the inputs are the same as the last time the selector was called, it returns the previously computed result without re-executing the computation logic.\n\n### Why `Reselect` is Valuable\n\n`Reselect` provides the `createSelector` utility, which makes it easy to create memoized selectors. It takes an array of 'input selectors' (which extract specific pieces of state) and a 'result function' (which performs the actual computation based on the inputs). `Reselect` automatically handles the memoization logic, comparing the results of the input selectors by reference.\n\n`Reselect` is valuable because it:\n\n1.  **Prevents Unnecessary Re-computations:** Costly data transformations (filtering, sorting, mapping large arrays) are only performed when necessary, avoiding redundant work.\n2.  **Optimizes Component Re-renders:** If a component receives data from a memoized selector, and the selector returns the same *reference* (because inputs didn't change), then `React.memo` or `PureComponent` can efficiently skip re-rendering that component, leading to better UI performance.\n3.  **Composability:** `createSelector` allows you to compose complex selectors from simpler ones, while still maintaining memoization.\n\n### Scenario for Performance Improvement\n\nConsider an e-commerce application with a large list of products (e.g., thousands) and various filters (category, price range, search term).\n\n**Without Reselect:**\nEvery time *any* part of the Redux state changes (e.g., user logs in, a notification appears), if a component connects directly to the `products` state and then filters/sorts it in `mapStateToProps` or directly in the component, this filtering/sorting operation would run again, even if the `products` list or the filters haven't changed. This would be a very expensive operation, leading to UI jank or slow interactions.\n\n**With Reselect:**\n\n```typescript\nimport { createSelector } from 'reselect';\n\nconst getAllProducts = (state) => state.products.list;\nconst getSelectedCategory = (state) => state.filters.category;\nconst getSearchQuery = (state) => state.filters.searchQuery;\n\nconst getFilteredAndSortedProducts = createSelector(\n  [getAllProducts, getSelectedCategory, getSearchQuery],\n  (products, category, searchQuery) => {\n    console.log('--- Recalculating filtered/sorted products ---');\n    let result = products;\n    if (category) {\n      result = result.filter(p => p.category === category);\n    }\n    if (searchQuery) {\n      result = result.filter(p => p.name.includes(searchQuery));\n    }\n    // Add sorting logic if needed\n    return result.sort((a, b) => a.name.localeCompare(b.name));\n  }\n);\n```\n\nIn this scenario, `getFilteredAndSortedProducts` will *only* re-run its expensive filtering and sorting logic if `products.list`, `filters.category`, or `filters.searchQuery` change. If, for example, only `user.loggedInStatus` changes, the selector will return the cached result, and the component displaying the product list will not re-render unnecessarily, leading to a much smoother user experience.",
          "analysisPoints": [
            "Tests definition and purpose of memoization.",
            "Evaluates understanding of `Reselect`'s role in implementing memoization.",
            "Assesses ability to apply theoretical concepts to a practical, performance-critical scenario.",
            "Checks understanding of how `Reselect` inputs and outputs relate."
          ],
          "keyConcepts": [
            "Memoization",
            "Reselect",
            "Selectors",
            "Performance Optimization",
            "Derived State",
            "Pure Functions",
            "Shallow Comparison"
          ],
          "evaluationCriteria": [
            "Accurate definition of memoization.",
            "Clear explanation of `Reselect`'s mechanism and benefits.",
            "A realistic and well-explained performance scenario.",
            "Demonstrates advanced knowledge of Redux optimization."
          ],
          "example": null,
          "tags": [
            "Redux",
            "Selectors",
            "Reselect",
            "Performance",
            "Memoization",
            "Open-ended"
          ],
          "prerequisites": [
            "Redux_Core_Concepts",
            "Reducer_Immutability"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_selectors_flashcard_1",
          "topic": "Selectors and State Shape",
          "level": "medium",
          "type": "flashcard",
          "question": "How do selectors contribute to making components more resilient to changes in Redux state shape?",
          "answer": "Selectors encapsulate the logic for accessing and transforming specific pieces of state. If the state shape changes, only the selector needs to be updated, not every component that consumes that piece of state. This centralizes state access logic, reducing refactoring effort.",
          "analysisPoints": [
            "Tests understanding of the 'encapsulation' benefit of selectors.",
            "Highlights the maintenance advantage."
          ],
          "keyConcepts": [
            "Redux Selectors",
            "Encapsulation",
            "State Shape",
            "Maintainability"
          ],
          "evaluationCriteria": [
            "Accurate explanation of resilience contribution."
          ],
          "example": null,
          "tags": [
            "Redux",
            "Selectors",
            "Flashcard"
          ],
          "prerequisites": [
            "Redux_Core_Concepts"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        }
      ],
      "tasks": [
        {
          "id": "task_implement_simple_redux",
          "title": "Build a Simple Redux Counter with Logs",
          "description": "Implement a basic Redux store and reducer for a counter application. The reducer should handle two actions: `INCREMENT` and `DECREMENT`. Log the state after each action dispatch to demonstrate state changes. Your solution should use `createStore` and ensure the reducer is pure.\n\n**Requirements:**\n1.  Define initial state for the counter (e.g., `count: 0`).\n2.  Create a `counterReducer` that handles `INCREMENT` (adds 1 to count) and `DECREMENT` (subtracts 1 from count) actions.\n3.  Create a Redux store using `createStore` with your reducer.\n4.  Dispatch `INCREMENT` and `DECREMENT` actions multiple times.\n5.  After each dispatch, log the current state using `store.getState()`.",
          "difficulty": "easy",
          "startingCode": "import { createStore } from 'redux';\n\n// 1. Define initial state\nconst initialState = {\n  // TODO: Add initial count property\n};\n\n// 2. Create the counterReducer\nfunction counterReducer(state = initialState, action) {\n  switch (action.type) {\n    // TODO: Handle INCREMENT action (add 1 to count, immutably)\n    // TODO: Handle DECREMENT action (subtract 1 from count, immutably)\n    default:\n      return state;\n  }\n}\n\n// 3. Create the Redux store\nconst store = createStore(counterReducer);\n\n// 4. Dispatch actions and log state\nconsole.log('Initial state:', store.getState());\n\n// TODO: Dispatch INCREMENT and log state\n\n// TODO: Dispatch DECREMENT and log state\n\n// TODO: Dispatch INCREMENT multiple times and log state\n",
          "solutionCode": "import { createStore } from 'redux';\n\nconst initialState = {\n  count: 0\n};\n\nfunction counterReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return {\n        ...state,\n        count: state.count + 1\n      };\n    case 'DECREMENT':\n      return {\n        ...state,\n        count: state.count - 1\n      };\n    default:\n      return state;\n  }\n}\n\nconst store = createStore(counterReducer);\n\nconsole.log('Initial state:', store.getState()); // Expected: { count: 0 }\n\nstore.dispatch({ type: 'INCREMENT' });\nconsole.log('State after INCREMENT:', store.getState()); // Expected: { count: 1 }\n\nstore.dispatch({ type: 'DECREMENT' });\nconsole.log('State after DECREMENT:', store.getState()); // Expected: { count: 0 }\n\nstore.dispatch({ type: 'INCREMENT' });\nstore.dispatch({ type: 'INCREMENT' });\nstore.dispatch({ type: 'INCREMENT' });\nconsole.log('State after multiple INCREMENTS:', store.getState()); // Expected: { count: 3 }\n\nstore.dispatch({ type: 'UNKNOWN_ACTION' });\nconsole.log('State after unknown action:', store.getState()); // Expected: { count: 3 } (state should not change)",
          "testCases": [
            "Initial state should be `{ count: 0 }`.",
            "After one `INCREMENT`, state should be `{ count: 1 }`.",
            "After one `DECREMENT` from `{ count: 1 }`, state should be `{ count: 0 }`.",
            "Dispatching multiple actions (e.g., 3 INCREMENTS) should result in the correct final count (e.g., `{ count: 3 }`).",
            "Dispatching an unknown action type should not change the state."
          ],
          "hints": [
            "Remember to return a *new* state object using the spread syntax (`...state`) to maintain immutability.",
            "The `default` case in the reducer is crucial to return the current state for unhandled actions."
          ],
          "tags": [
            "Redux",
            "Beginner",
            "Store",
            "Reducer",
            "Actions",
            "Immutability"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "JavaScript_ES6",
            "Redux_Core_Concepts"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "Redux_Core_Concepts",
            "Reducer_Immutability"
          ]
        },
        {
          "id": "task_refactor_with_combine_reducers",
          "title": "Refactor a Global Reducer with combineReducers",
          "description": "You are given a single Redux reducer that manages both user authentication and application UI settings. Your task is to refactor this into two separate reducers (`authReducer` and `uiReducer`) and then combine them using `combineReducers`. Demonstrate how to access properties from the combined state.\n\n**Initial Global Reducer (Do NOT modify this directly, use it as source for refactoring):**\n```typescript\nconst initialGlobalState = {\n  isAuthenticated: false,\n  userProfile: null,\n  theme: 'light',\n  sidebarOpen: false\n};\n\nfunction globalReducer(state = initialGlobalState, action) {\n  switch (action.type) {\n    case 'LOGIN_SUCCESS':\n      return { ...state, isAuthenticated: true, userProfile: action.payload };\n    case 'LOGOUT':\n      return { ...state, isAuthenticated: false, userProfile: null };\n    case 'TOGGLE_THEME':\n      return { ...state, theme: state.theme === 'light' ? 'dark' : 'light' };\n    case 'TOGGLE_SIDEBAR':\n      return { ...state, sidebarOpen: !state.sidebarOpen };\n    default:\n      return state;\n  }\n}\n// const store = createStore(globalReducer);\n```\n\n**Requirements:**\n1.  Create `authReducer` to manage `isAuthenticated` and `userProfile`.\n2.  Create `uiReducer` to manage `theme` and `sidebarOpen`.\n3.  Combine `authReducer` and `uiReducer` into a `rootReducer` using `combineReducers`. Choose meaningful keys for each slice (e.g., `auth`, `ui`).\n4.  Create a Redux store with the `rootReducer`.\n5.  Dispatch actions for both `auth` and `ui` parts.\n6.  After dispatches, log the entire combined state and then log specific properties (e.g., `store.getState().auth.isAuthenticated`, `store.getState().ui.theme`) to demonstrate correct state access.",
          "difficulty": "medium",
          "startingCode": "import { createStore, combineReducers } from 'redux';\n\n// Initial Global Reducer (for reference, do not modify directly)\n// const initialGlobalState = {\n//   isAuthenticated: false,\n//   userProfile: null,\n//   theme: 'light',\n//   sidebarOpen: false\n// };\n// function globalReducer(state = initialGlobalState, action) { /* ... */ }\n\n// 1. Create authReducer\nconst initialAuthState = {\n  isAuthenticated: false,\n  userProfile: null\n};\n\nfunction authReducer(state = initialAuthState, action) {\n  switch (action.type) {\n    // TODO: Implement LOGIN_SUCCESS and LOGOUT actions\n    default:\n      return state;\n  }\n}\n\n// 2. Create uiReducer\nconst initialUiState = {\n  theme: 'light',\n  sidebarOpen: false\n};\n\nfunction uiReducer(state = initialUiState, action) {\n  switch (action.type) {\n    // TODO: Implement TOGGLE_THEME and TOGGLE_SIDEBAR actions\n    default:\n      return state;\n  }\n}\n\n// 3. Combine reducers into rootReducer\nconst rootReducer = combineReducers({\n  // TODO: Map your reducers to state keys here\n});\n\n// 4. Create the Redux store\nconst store = createStore(rootReducer);\n\n// 5. Dispatch actions and 6. Log state\nconsole.log('Initial Combined State:', store.getState());\n\n// TODO: Dispatch LOGIN_SUCCESS action\n// TODO: Log relevant auth state part\n\n// TODO: Dispatch TOGGLE_THEME action\n// TODO: Log relevant ui state part\n\n// TODO: Dispatch LOGOUT action\n// TODO: Log relevant auth state part\n\n// TODO: Log final combined state\n",
          "solutionCode": "import { createStore, combineReducers } from 'redux';\n\n// 1. Create authReducer\nconst initialAuthState = {\n  isAuthenticated: false,\n  userProfile: null\n};\n\nfunction authReducer(state = initialAuthState, action) {\n  switch (action.type) {\n    case 'LOGIN_SUCCESS':\n      return { ...state, isAuthenticated: true, userProfile: action.payload };\n    case 'LOGOUT':\n      return { ...state, isAuthenticated: false, userProfile: null };\n    default:\n      return state;\n  }\n}\n\n// 2. Create uiReducer\nconst initialUiState = {\n  theme: 'light',\n  sidebarOpen: false\n};\n\nfunction uiReducer(state = initialUiState, action) {\n  switch (action.type) {\n    case 'TOGGLE_THEME':\n      return { ...state, theme: state.theme === 'light' ? 'dark' : 'light' };\n    case 'TOGGLE_SIDEBAR':\n      return { ...state, sidebarOpen: !state.sidebarOpen };\n    default:\n      return state;\n  }\n}\n\n// 3. Combine reducers into rootReducer\nconst rootReducer = combineReducers({\n  auth: authReducer,\n  ui: uiReducer\n});\n\n// 4. Create the Redux store\nconst store = createStore(rootReducer);\n\n// 5. Dispatch actions and 6. Log state\nconsole.log('Initial Combined State:', store.getState());\n/* Expected:\n{ auth: { isAuthenticated: false, userProfile: null }, ui: { theme: 'light', sidebarOpen: false } }\n*/\n\nstore.dispatch({ type: 'LOGIN_SUCCESS', payload: { name: 'John Doe', email: 'john@example.com' } });\nconsole.log('Auth state after LOGIN_SUCCESS:', store.getState().auth);\n/* Expected:\n{ isAuthenticated: true, userProfile: { name: 'John Doe', email: 'john@example.com' } }\n*/\n\nstore.dispatch({ type: 'TOGGLE_THEME' });\nconsole.log('UI state after TOGGLE_THEME:', store.getState().ui);\n/* Expected:\n{ theme: 'dark', sidebarOpen: false }\n*/\n\nstore.dispatch({ type: 'TOGGLE_SIDEBAR' });\nconsole.log('UI state after TOGGLE_SIDEBAR:', store.getState().ui);\n/* Expected:\n{ theme: 'dark', sidebarOpen: true }\n*/\n\nstore.dispatch({ type: 'LOGOUT' });\nconsole.log('Auth state after LOGOUT:', store.getState().auth);\n/* Expected:\n{ isAuthenticated: false, userProfile: null }\n*/\n\nconsole.log('Final Combined State:', store.getState());\n/* Expected:\n{ auth: { isAuthenticated: false, userProfile: null }, ui: { theme: 'dark', sidebarOpen: true } }\n*/",
          "testCases": [
            "Initial combined state should reflect initial states of both reducers under their respective keys.",
            "Dispatching a `LOGIN_SUCCESS` action should only affect the `auth` slice of state, and `isAuthenticated` should become `true` with `userProfile` set.",
            "Dispatching a `TOGGLE_THEME` action should only affect the `ui` slice of state, and `theme` should toggle.",
            "Dispatching a `TOGGLE_SIDEBAR` action should only affect the `ui` slice of state, and `sidebarOpen` should toggle.",
            "Dispatching a `LOGOUT` action should reset `isAuthenticated` to `false` and `userProfile` to `null` within the `auth` slice.",
            "Ensure no cross-reducer state mutation occurs (e.g., `authReducer` shouldn't affect `ui` state)."
          ],
          "hints": [
            "Each new reducer will receive only its slice of the state as its `state` argument.",
            "When using `combineReducers`, the keys you provide (e.g., `auth`, `ui`) become the property names in the global state object.",
            "Remember to handle the `default` case in each reducer to return the current state."
          ],
          "tags": [
            "Redux",
            "combineReducers",
            "Refactoring",
            "State Management",
            "Architecture"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "Redux_Core_Concepts",
            "Reducer_Immutability"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "combineReducers",
            "Redux_Core_Concepts"
          ]
        },
        {
          "id": "task_fix_impure_reducer",
          "title": "Fix an Impure Todo List Reducer",
          "description": "You are provided with an impure Redux reducer for managing a list of todo items. It currently mutates the state directly, which is against Redux principles. Your task is to refactor this reducer to make it pure and ensure all state updates are immutable. The reducer should handle `ADD_TODO`, `TOGGLE_TODO`, and `DELETE_TODO` actions.\n\n**Initial Impure Reducer (Do NOT modify this directly, use it as source for refactoring):**\n```typescript\nconst initialTodosState = {\n  todos: []\n};\n\nfunction todosReducerImpure(state = initialTodosState, action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      state.todos.push({ id: Date.now(), text: action.payload, completed: false }); // MUTATION\n      return state;\n    case 'TOGGLE_TODO':\n      const todoToToggle = state.todos.find(todo => todo.id === action.payload);\n      if (todoToToggle) {\n        todoToToggle.completed = !todoToToggle.completed; // MUTATION\n      }\n      return state;\n    case 'DELETE_TODO':\n      state.todos = state.todos.filter(todo => todo.id !== action.payload); // Still a mutation of `state.todos` reference\n      return state;\n    default:\n      return state;\n  }\n}\n// const store = createStore(todosReducerImpure);\n```\n\n**Requirements:**\n1.  Create a new `todosReducer` function based on the impure one.\n2.  Ensure that `ADD_TODO` action returns a new state object with a new `todos` array containing the new todo.\n3.  Ensure that `TOGGLE_TODO` action returns a new state object with a new `todos` array where the specific todo item's `completed` status is toggled, and that specific todo item is also a new object.\n4.  Ensure that `DELETE_TODO` action returns a new state object with a new `todos` array excluding the deleted todo.\n5.  Create a store and dispatch various actions to test your pure reducer.",
          "difficulty": "medium",
          "startingCode": "import { createStore } from 'redux';\n\nconst initialTodosState = {\n  todos: []\n};\n\nfunction todosReducer(state = initialTodosState, action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      // TODO: Implement immutable add\n      return state;\n    case 'TOGGLE_TODO':\n      // TODO: Implement immutable toggle\n      return state;\n    case 'DELETE_TODO':\n      // TODO: Implement immutable delete\n      return state;\n    default:\n      return state;\n  }\n}\n\n// Create the store\nconst store = createStore(todosReducer);\n\n// Test actions\nconsole.log('Initial state:', store.getState());\n\nstore.dispatch({ type: 'ADD_TODO', payload: 'Learn Redux' });\nconsole.log('After add 1:', store.getState());\n\nconst todoId1 = store.getState().todos[0].id;\nstore.dispatch({ type: 'TOGGLE_TODO', payload: todoId1 });\nconsole.log('After toggle 1:', store.getState());\n\nstore.dispatch({ type: 'ADD_TODO', payload: 'Build a Redux App' });\nconsole.log('After add 2:', store.getState());\n\nconst todoId2 = store.getState().todos[1].id;\nstore.dispatch({ type: 'TOGGLE_TODO', payload: todoId2 });\nconsole.log('After toggle 2:', store.getState());\n\nstore.dispatch({ type: 'DELETE_TODO', payload: todoId1 });\nconsole.log('After delete 1:', store.getState());\n",
          "solutionCode": "import { createStore } from 'redux';\n\nconst initialTodosState = {\n  todos: []\n};\n\nfunction todosReducer(state = initialTodosState, action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return {\n        ...state, // Return a new state object\n        todos: [...state.todos, { id: Date.now(), text: action.payload, completed: false }] // Return a new todos array\n      };\n    case 'TOGGLE_TODO':\n      return {\n        ...state,\n        todos: state.todos.map(todo =>\n          todo.id === action.payload\n            ? { ...todo, completed: !todo.completed } // Return a new todo object for the changed one\n            : todo\n        ) // Return a new todos array\n      };\n    case 'DELETE_TODO':\n      return {\n        ...state,\n        todos: state.todos.filter(todo => todo.id !== action.payload) // Return a new todos array\n      };\n    default:\n      return state;\n  }\n}\n\nconst store = createStore(todosReducer);\n\nconsole.log('Initial state:', store.getState());\n\nstore.dispatch({ type: 'ADD_TODO', payload: 'Learn Redux' });\nconsole.log('After add 1:', store.getState());\n\nconst todoId1 = store.getState().todos[0].id;\nstore.dispatch({ type: 'TOGGLE_TODO', payload: todoId1 });\nconsole.log('After toggle 1:', store.getState());\n\nstore.dispatch({ type: 'ADD_TODO', payload: 'Build a Redux App' });\nconsole.log('After add 2:', store.getState());\n\nconst todoId2 = store.getState().todos[1].id;\nstore.dispatch({ type: 'TOGGLE_TODO', payload: todoId2 });\nconsole.log('After toggle 2:', store.getState());\n\nstore.dispatch({ type: 'DELETE_TODO', payload: todoId1 });\nconsole.log('After delete 1:', store.getState());\n\nstore.dispatch({ type: 'TOGGLE_TODO', payload: todoId2 });\nconsole.log('After toggling remaining todo:', store.getState());\n",
          "testCases": [
            "Adding a todo: Initial state `{ todos: [] }` -> after `ADD_TODO`, should be `{ todos: [{id: ..., text: '...', completed: false}] }` with new object/array references.",
            "Toggling a todo: Toggling a specific todo's `completed` status should change that property, but the `todos` array and the modified todo object should have new references, while other todos remain with old references.",
            "Deleting a todo: Deleting a todo should result in a new `todos` array without the deleted item, and a new state object.",
            "Handling unknown actions: Dispatching an unknown action should return the exact same state object reference.",
            "Multiple operations: Perform a sequence of add, toggle, delete, and verify the final state reflects all changes correctly and immutably."
          ],
          "hints": [
            "To add to an array immutably, use `[...array, newItem]`.",
            "To update an item in an array immutably, use `array.map(item => item.id === targetId ? {...item, updatedProp: newValue} : item)`.",
            "To delete an item from an array immutably, use `array.filter(item => item.id !== targetId)`.",
            "Remember to always return a *new* overall state object (`{...state, ...}`) even if only a nested part has changed."
          ],
          "tags": [
            "Redux",
            "Immutability",
            "Reducer",
            "Refactoring",
            "Best Practices",
            "Coding Challenge"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "Reducer_Immutability",
            "JavaScript_ES6"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Reducer_Immutability",
            "Redux_Core_Concepts"
          ]
        },
        {
          "id": "task_implement_redux_selectors",
          "title": "Implement Memoized Selectors with Reselect for a Product List",
          "description": "You have a Redux store containing a list of products and a search term. Implement three selectors:\n1.  A basic selector to get all products.\n2.  A basic selector to get the current search term.\n3.  A memoized selector using `Reselect` that filters the products based on the search term. This selector should only re-compute when either the product list or the search term changes.\n\n**Requirements:**\n1.  Set up a simple Redux store with a reducer that manages a `products` array and a `searchTerm` string.\n2.  Implement `getAllProductsSelector` to return `state.products.items`.\n3.  Implement `getSearchTermSelector` to return `state.products.searchTerm`.\n4.  Implement `getFilteredProductsSelector` using `createSelector` from `reselect`. It should depend on `getAllProductsSelector` and `getSearchTermSelector`.\n5.  Demonstrate the memoization by dispatching an action that *doesn't* affect products or search term, and observe that `getFilteredProductsSelector` does not re-compute (add a `console.log` inside its result function). Then dispatch an action that *does* affect one of its inputs and observe re-computation.\n",
          "difficulty": "hard",
          "startingCode": "import { createStore, combineReducers } from 'redux';\nimport { createSelector } from 'reselect';\n\n// Reducer for products and search term\nconst initialProductsState = {\n  items: [\n    { id: 1, name: 'Laptop', category: 'Electronics', price: 1200 },\n    { id: 2, name: 'Keyboard', category: 'Electronics', price: 75 },\n    { id: 3, name: 'Mouse', category: 'Electronics', price: 25 },\n    { id: 4, name: 'Desk Chair', category: 'Furniture', price: 300 },\n    { id: 5, name: 'Monitor', category: 'Electronics', price: 250 }\n  ],\n  searchTerm: ''\n};\n\nfunction productsReducer(state = initialProductsState, action) {\n  switch (action.type) {\n    case 'SET_SEARCH_TERM':\n      return { ...state, searchTerm: action.payload };\n    // For demonstration of memoization, add a dummy action\n    case 'DUMMY_ACTION':\n      return { ...state }; // Returns new state object, but no input for selector changes\n    default:\n      return state;\n  }\n}\n\n// Dummy reducer for other state part to show independent updates\nconst initialUiState = { theme: 'light' };\nfunction uiReducer(state = initialUiState, action) {\n  if (action.type === 'TOGGLE_THEME') {\n    return { ...state, theme: state.theme === 'light' ? 'dark' : 'light' };\n  }\n  return state;\n}\n\nconst rootReducer = combineReducers({\n  products: productsReducer,\n  ui: uiReducer\n});\n\nconst store = createStore(rootReducer);\n\n// 1. Basic selector to get all products\nconst getAllProductsSelector = (state) => {\n  // TODO: Implement\n};\n\n// 2. Basic selector to get the current search term\nconst getSearchTermSelector = (state) => {\n  // TODO: Implement\n};\n\n// 3. Memoized selector using Reselect for filtered products\nconst getFilteredProductsSelector = createSelector(\n  // TODO: Define input selectors\n  // TODO: Define result function (add console.log inside to see re-computations)\n);\n\n// Demonstrate usage and memoization\nconsole.log('--- Initial State ---');\nconsole.log('Filtered Products:', getFilteredProductsSelector(store.getState()));\n\nconsole.log('\\n--- Dispatching DUMMY_ACTION (should not re-compute filtered products) ---');\nstore.dispatch({ type: 'DUMMY_ACTION' });\nconsole.log('Filtered Products (after dummy):', getFilteredProductsSelector(store.getState()));\n\nconsole.log('\\n--- Dispatching TOGGLE_THEME (should not re-compute filtered products) ---');\nstore.dispatch({ type: 'TOGGLE_THEME' });\nconsole.log('Filtered Products (after theme toggle):', getFilteredProductsSelector(store.getState()));\n\nconsole.log('\\n--- Dispatching SET_SEARCH_TERM (should re-compute filtered products) ---');\nstore.dispatch({ type: 'SET_SEARCH_TERM', payload: 'mouse' });\nconsole.log('Filtered Products (after search term):', getFilteredProductsSelector(store.getState()));\n\nconsole.log('\\n--- Dispatching SET_SEARCH_TERM with same value (should not re-compute filtered products) ---');\nstore.dispatch({ type: 'SET_SEARCH_TERM', payload: 'mouse' });\nconsole.log('Filtered Products (same search term):', getFilteredProductsSelector(store.getState()));\n",
          "solutionCode": "import { createStore, combineReducers } from 'redux';\nimport { createSelector } from 'reselect';\n\nconst initialProductsState = {\n  items: [\n    { id: 1, name: 'Laptop', category: 'Electronics', price: 1200 },\n    { id: 2, name: 'Keyboard', category: 'Electronics', price: 75 },\n    { id: 3, name: 'Mouse', category: 'Electronics', price: 25 },\n    { id: 4, name: 'Desk Chair', category: 'Furniture', price: 300 },\n    { id: 5, name: 'Monitor', category: 'Electronics', price: 250 }\n  ],\n  searchTerm: ''\n};\n\nfunction productsReducer(state = initialProductsState, action) {\n  switch (action.type) {\n    case 'SET_SEARCH_TERM':\n      return { ...state, searchTerm: action.payload };\n    case 'DUMMY_ACTION':\n      return { ...state }; \n    default:\n      return state;\n  }\n}\n\nconst initialUiState = { theme: 'light' };\nfunction uiReducer(state = initialUiState, action) {\n  if (action.type === 'TOGGLE_THEME') {\n    return { ...state, theme: state.theme === 'light' ? 'dark' : 'light' };\n  }\n  return state;\n}\n\nconst rootReducer = combineReducers({\n  products: productsReducer,\n  ui: uiReducer\n});\n\nconst store = createStore(rootReducer);\n\n// 1. Basic selector to get all products\nconst getAllProductsSelector = (state) => state.products.items;\n\n// 2. Basic selector to get the current search term\nconst getSearchTermSelector = (state) => state.products.searchTerm;\n\n// 3. Memoized selector using Reselect for filtered products\nconst getFilteredProductsSelector = createSelector(\n  [getAllProductsSelector, getSearchTermSelector], // Input selectors\n  (products, searchTerm) => {   // Result function\n    console.log('--- RECOMPUTING FILTERED PRODUCTS ---'); // Log to observe memoization\n    if (!searchTerm) {\n      return products;\n    }\n    return products.filter(product =>\n      product.name.toLowerCase().includes(searchTerm.toLowerCase())\n    );\n  }\n);\n\nconsole.log('--- Initial State ---');\nconsole.log('Filtered Products:', getFilteredProductsSelector(store.getState()));\n\nconsole.log('\\n--- Dispatching DUMMY_ACTION (should NOT re-compute filtered products) ---');\nstore.dispatch({ type: 'DUMMY_ACTION' }); // State object reference changes, but relevant selector inputs don't\nconsole.log('Filtered Products (after dummy):', getFilteredProductsSelector(store.getState()));\n\nconsole.log('\\n--- Dispatching TOGGLE_THEME (should NOT re-compute filtered products) ---');\nstore.dispatch({ type: 'TOGGLE_THEME' }); // Affects 'ui' slice, not 'products' slice\nconsole.log('Filtered Products (after theme toggle):', getFilteredProductsSelector(store.getState()));\n\nconsole.log('\\n--- Dispatching SET_SEARCH_TERM (should RE-COMPUTE filtered products) ---');\nstore.dispatch({ type: 'SET_SEARCH_TERM', payload: 'mouse' });\nconsole.log('Filtered Products (after search term):', getFilteredProductsSelector(store.getState()));\n\nconsole.log('\\n--- Dispatching SET_SEARCH_TERM with same value (should NOT re-compute filtered products) ---');\nstore.dispatch({ type: 'SET_SEARCH_TERM', payload: 'mouse' });\nconsole.log('Filtered Products (same search term):', getFilteredProductsSelector(store.getState()));\n",
          "testCases": [
            "Initial call to `getFilteredProductsSelector` should compute and log '--- RECOMPUTING FILTERED PRODUCTS ---'.",
            "Dispatching `DUMMY_ACTION` (which updates `products` state but doesn't change `items` or `searchTerm` references) should *not* cause `getFilteredProductsSelector` to re-compute.",
            "Dispatching `TOGGLE_THEME` (which updates an unrelated state slice) should *not* cause `getFilteredProductsSelector` to re-compute.",
            "Dispatching `SET_SEARCH_TERM` with a *new* value should cause `getFilteredProductsSelector` to re-compute and log.",
            "Dispatching `SET_SEARCH_TERM` with the *same* value as the previous dispatch should *not* cause `getFilteredProductsSelector` to re-compute (demonstrating memoization)."
          ],
          "hints": [
            "Remember that `createSelector` expects an array of input selectors as its first argument, and a result function as its second.",
            "The arguments to the result function of `createSelector` are the results of the input selectors, in order.",
            "Place a `console.log` inside the result function of your memoized selector to clearly see when it re-computes."
          ],
          "tags": [
            "Redux",
            "Selectors",
            "Reselect",
            "Memoization",
            "Performance",
            "Coding Challenge"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "Redux_Core_Concepts",
            "Reducer_Immutability",
            "Functional_Programming_Basics"
          ],
          "complexity": 9,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Redux_Selectors_Reselect",
            "Performance_Optimization"
          ]
        }
      ]
    }
  },
  {
    "id": "8971a1bf-00f9-490a-8b78-52fe32f8460c",
    "startLine": 9000,
    "endLine": 9099,
    "processedDate": "2025-06-17T10:53:30.438Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_redux_selectors_basics",
          "title": "Basic Redux Selectors",
          "content": "Redux selectors are simple JavaScript functions that take the Redux state as an argument and return a specific piece of that state or derived data. They serve as a crucial abstraction layer between the Redux store's raw state and the React components (or any other part of the application) that consume the state.\n\n## Key Concepts\n*   **State Extraction**: Selectors provide a standardized way to pull specific data out of the complex, often nested, Redux state tree.\n*   **Encapsulation**: By using selectors, components don't need to know the exact structure of the state. If the state shape changes, only the selector needs to be updated, not every component that uses that piece of data. This promotes maintainability and reduces coupling.\n*   **Reusability**: A single selector can be used by multiple components or in different parts of the application that require the same data slice.\n\n## Implementation\nA basic selector is typically a pure function that takes the `state` object and returns the desired data.",
          "examples": [
            {
              "id": "example_redux_selectors_basics_1",
              "title": "Getting User Data from State",
              "code": "const getUserData = state => state.user.data;\n\n// Example usage in a component:\n// const userData = getUserData(store.getState());",
              "explanation": "This selector `getUserData` directly accesses the `user.data` property from the Redux state. If `state.user.data` holds the user's details, this function encapsulates that path, so any component needing user data just calls `getUserData(state)` without knowing the full path.",
              "language": "javascript"
            },
            {
              "id": "example_redux_selectors_basics_2",
              "title": "Getting Derived Data",
              "code": "const getActiveTodosCount = state => state.todos.filter(todo => !todo.completed).length;\n\n// Example usage:\n// const activeTodosCount = getActiveTodosCount(store.getState());",
              "explanation": "This selector not only extracts data but also derives a new value by filtering the `todos` array and counting active (uncompleted) items. It demonstrates how selectors can perform simple transformations.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "Redux",
            "Selectors",
            "State Management",
            "Data Extraction",
            "Encapsulation"
          ],
          "technology": "Redux",
          "prerequisites": [
            "Redux Basics",
            "JavaScript Functions"
          ],
          "complexity": 4,
          "interviewRelevance": 7,
          "learningPath": "beginner"
        },
        {
          "id": "theory_reselect_memoized_selectors",
          "title": "Reselect: Memoized Selectors for Performance",
          "content": "Reselect is a popular selector library for Redux that introduces **memoization** to optimize the computation of derived data. While basic selectors are simple functions, Reselect enhances them by caching their output and only re-calculating when their inputs change.\n\n## What is Reselect and How It Works?\nReselect uses memoization to prevent unnecessary re-computations of derived data. It keeps a copy of the last inputs and the last computed output. When a selector is called, it first checks if its inputs have changed from the last call. If the inputs are the same (a shallow comparison by default), it returns the cached output immediately without re-executing the potentially expensive computation logic. If any input has changed, it re-computes the result, caches it, and then returns it.\n\nThis behavior is crucial for performance in applications where state transformations or derivations might be computationally expensive, or when components re-render frequently, even if the underlying data they depend on hasn't logically changed.\n\n## Key Concepts\n*   **`createSelector`**: The core function in Reselect. It takes one or more \"input selectors\" as its first arguments, followed by a \"result function\" as the last argument.\n    *   **Input Selectors**: These are regular (often basic) selectors that extract specific pieces of the state. Their return values become the arguments to the result function.\n    *   **Result Function**: This function receives the outputs of the input selectors as its arguments and performs the actual calculation or transformation to derive the final data.\n*   **Memoization**: The caching mechanism applied by `createSelector`. It ensures the result function only runs when the values returned by the input selectors change.\n\n## Benefits of Using Reselect\n1.  **Performance Improvement**: Prevents re-computation of expensive derived data, especially critical for large datasets or complex calculations, thus avoiding unnecessary component re-renders if the derived data remains the same.\n2.  **Encapsulates State Shape**: Like basic selectors, Reselect selectors abstract away the state structure from components.\n3.  **Increased Reusability**: Memoized selectors can be reused throughout the application, ensuring consistent data derivation and performance benefits everywhere they are used.\n4.  **Enhanced Testability**: Reselect selectors are pure functions (input selectors + result function), making them easy to test in isolation by providing mock inputs.\n\n## Customization\nReselect's memoization and cache are fully customizable, allowing developers to define their own equality checks or caching strategies if the default shallow comparison is not sufficient.",
          "examples": [
            {
              "id": "example_reselect_shopping_cart",
              "title": "Shopping Cart Calculation with Reselect",
              "code": "import { createSelector } from 'reselect';\n\n// 1. Basic input selectors (non-memoized)\nconst shopItemsSelector = state => state.shop.items;\nconst taxPercentSelector = state => state.shop.taxPercent;\n\n// 2. Memoized selector for subtotal\nconst subtotalSelector = createSelector(\n  shopItemsSelector, // Input selector 1\n  items => items.reduce((acc, item) => acc + item.value, 0) // Result function\n);\n\n// 3. Memoized selector for tax\nconst taxSelector = createSelector(\n  subtotalSelector,   // Input selector 1 (output of another selector)\n  taxPercentSelector, // Input selector 2\n  (subtotal, taxPercent) => subtotal * (taxPercent / 100) // Result function\n);\n\n// 4. Memoized selector for total\nexport const totalSelector = createSelector(\n  subtotalSelector, // Input selector 1\n  taxSelector,      // Input selector 2\n  (subtotal, tax) => ({ total: subtotal + tax }) // Result function\n);\n\n// Example State Structure:\n/*\n{\n  shop: {\n    items: [{ id: 1, value: 100 }, { id: 2, value: 50 }],\n    taxPercent: 10\n  }\n}\n*/\n\n// Usage:\n// const state = { shop: { items: [{ id: 1, value: 100 }, { id: 2, value: 50 }], taxPercent: 10 } };\n// const total = totalSelector(state); // { total: 165 }",
              "explanation": "This example demonstrates a chain of memoized selectors. `subtotalSelector` memoizes the sum of item values. `taxSelector` then depends on `subtotalSelector` and `taxPercentSelector`. Finally, `totalSelector` combines the results of `subtotalSelector` and `taxSelector`. Each selector will only re-calculate if its specific input selectors return different values (by reference). For instance, if only `shopItemsSelector`'s output changes, `subtotalSelector`, `taxSelector`, and `totalSelector` will re-calculate. If only `taxPercentSelector`'s output changes, `taxSelector` and `totalSelector` will re-calculate, but `subtotalSelector` will return its cached value.",
              "language": "typescript"
            },
            {
              "id": "example_reselect_complex_filter",
              "title": "Filtering Data with Reselect",
              "code": "import { createSelector } from 'reselect';\n\nconst getProducts = state => state.products.list;\nconst getSearchTerm = state => state.products.searchTerm;\n\nexport const getFilteredProducts = createSelector(\n  getProducts,\n  getSearchTerm,\n  (products, searchTerm) => {\n    if (!searchTerm) {\n      return products;\n    }\n    return products.filter(product =>\n      product.name.toLowerCase().includes(searchTerm.toLowerCase())\n    );\n  }\n);\n\n// Example State Structure:\n/*\n{\n  products: {\n    list: [{ id: 1, name: 'Apple' }, { id: 2, name: 'Banana' }, { id: 3, name: 'Orange' }],\n    searchTerm: 'Ap'\n  }\n}\n*/\n\n// Usage:\n// const state = { products: { list: [{ id: 1, name: 'Apple' }, { id: 2, name: 'Banana' }], searchTerm: 'Ap' } };\n// const filtered = getFilteredProducts(state); // Returns [{ id: 1, name: 'Apple' }]\n\n// If searchTerm changes from 'Ap' to 'Ban', it re-filters.\n// If products list or searchTerm don't change, it returns the cached filtered list.",
              "explanation": "This selector filters a list of products based on a search term. The `getFilteredProducts` selector will only re-run its filtering logic if either the `products.list` array (by reference) or the `products.searchTerm` string changes. This prevents expensive re-filtering operations on every component re-render if the relevant data hasn't changed.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "Redux",
            "Reselect",
            "Memoization",
            "Performance",
            "Selectors",
            "Optimization"
          ],
          "technology": "Redux",
          "prerequisites": [
            "Redux Selectors",
            "JavaScript Pure Functions",
            "Array Methods"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "theory_react_redux_connect",
          "title": "Connecting React Components to Redux with `connect`",
          "content": "To integrate React components with a Redux store, the `react-redux` library provides the `connect()` Higher-Order Component (HOC). `connect()` does not modify the component class passed to it; instead, it returns a new, connected component class that wraps the original component. This wrapper component handles the interaction with the Redux store and passes relevant state data and dispatch functions as props to your original component.\n\n## Basic Connection Pattern\nThe `connect` function takes two optional arguments: `mapStateToProps` and `mapDispatchToProps`, and returns a function that you then call with your React component.\n\n`connect(mapStateToProps?, mapDispatchToProps?)(YourComponent)`\n\n### `mapStateToProps(state, [ownProps])`\nThis function is used to define which parts of the Redux state tree your component needs to access. It takes the entire Redux `state` as its first argument (and optionally `ownProps` as the second, which are the props passed to the connected component). It should return a plain object, where each key-value pair will become a prop passed to your component. Whenever the Redux state changes, `mapStateToProps` is re-run, and if the shallow comparison of the returned object indicates changes, your component will re-render with the new props.\n\n### `mapDispatchToProps(dispatch, [ownProps])`\nThis function is used to define which Redux action creators your component can dispatch. It takes the Redux `dispatch` function as its first argument (and optionally `ownProps` as the second). It should return a plain object, where each key-value pair will become a prop passed to your component. The values of this object should typically be functions that call `dispatch` with an action.\n\nThere are two primary ways to define `mapDispatchToProps`:\n\n1.  **Object Shorthand**: This is the simplest and recommended way. You pass an object where keys are prop names and values are Redux action creators. `react-redux` automatically wraps these action creators in `dispatch()`, so you can call them directly as props (e.g., `this.props.addTodo('text')`).\n    ```javascript\n    import { addTodo, toggleTodo } from './actions';\n\n    const mapDispatchToProps = {\n      addTodo,      // Becomes this.props.addTodo(payload)\n      toggleTodo    // Becomes this.props.toggleTodo(id)\n    };\n    ```\n\n2.  **Function Form (with `dispatch`)**: This form gives you full control over how actions are dispatched. You receive the `dispatch` function as an argument and manually bind your action creators or create wrapper functions that call `dispatch`.\n    ```javascript\n    import { addTodo, toggleTodo } from './actions';\n\n    const mapDispatchToProps = (dispatch) => ({\n      addTodo: (text) => dispatch(addTodo(text)),\n      toggleTodo: (id) => dispatch(toggleTodo(id))\n      // You can also add custom dispatch logic here\n    });\n    ```\n\n    *(Note: A third, less common form involves `bindActionCreators` from Redux, but the object shorthand is generally preferred for simplicity and the functional form for custom logic.)*\n\n## How `connect` Works (Conceptual)\n`connect` acts as a subscribe mechanism. It subscribes to the Redux store. When the store's state changes, `mapStateToProps` is called. If the props returned by `mapStateToProps` are different from the previous props, the connected component re-renders. `mapDispatchToProps` is typically only called once when the component mounts, unless `ownProps` are used and change, or if it's defined as a function that relies on `ownProps`.\n\n## Benefits\n*   **Separation of Concerns**: Components remain focused on rendering UI, while `connect` handles data fetching and action dispatching logic.\n*   **Performance Optimization**: `connect` includes built-in optimizations to prevent unnecessary re-renders by shallowly comparing the props returned by `mapStateToProps` and `mapDispatchToProps`.\n*   **Predictable Data Flow**: Enforces a unidirectional data flow typical of Redux applications.\n*   **Reusability**: Allows components to be easily reused with different state mappings or dispatch functions by simply wrapping them with different `connect` configurations.",
          "examples": [
            {
              "id": "example_react_redux_connect_basic",
              "title": "Basic TodoList Component Connection",
              "code": "import React from 'react';\nimport { connect } from 'react-redux';\nimport { addTodo, toggleTodo } from './actions';\n\n// Regular React component\nclass TodoList extends React.Component {\n  render() {\n    return (\n      <div>\n        <button onClick={() => this.props.addTodo('New task')}>Add Task</button>\n        <ul>\n          {this.props.todos.map(todo => (\n            <li\n              key={todo.id}\n              onClick={() => this.props.toggleTodo(todo.id)}\n              style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}\n            >\n              {todo.text}\n            </li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n\n// mapStateToProps defines which parts of the state to pass to the component\nconst mapStateToProps = (state) => ({\n  todos: state.todos // assuming state.todos is an array of todo objects\n});\n\n// mapDispatchToProps defines which action creators to pass to the component\n// Using the object shorthand form\nconst mapDispatchToProps = {\n  addTodo,\n  toggleTodo\n};\n\n// connect creates a new component that wraps TodoList\nexport default connect(mapStateToProps, mapDispatchToProps)(TodoList);",
              "explanation": "This example shows a `TodoList` component connected to Redux. `mapStateToProps` provides the `todos` array from the Redux state as `this.props.todos`. `mapDispatchToProps` (using the object shorthand) makes `addTodo` and `toggleTodo` action creators available as `this.props.addTodo` and `this.props.toggleTodo`. The component can then directly call these props to interact with the Redux store without needing to explicitly `dispatch`.",
              "language": "javascript"
            },
            {
              "id": "example_react_redux_connect_function_mapDispatchToProps",
              "title": "Using Function Form for `mapDispatchToProps`",
              "code": "import React from 'react';\nimport { connect } from 'react-redux';\nimport { addTodo, toggleTodo } from './actions';\n\nclass TodoForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { taskText: '' };\n  }\n\n  handleChange = (e) => {\n    this.setState({ taskText: e.target.value });\n  }\n\n  handleSubmit = () => {\n    if (this.state.taskText.trim()) {\n      this.props.addTask(this.state.taskText);\n      this.setState({ taskText: '' });\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <input type=\"text\" value={this.state.taskText} onChange={this.handleChange} />\n        <button onClick={this.handleSubmit}>Add New Task</button>\n      </div>\n    );\n  }\n}\n\nconst mapDispatchToProps = (dispatch) => ({\n  addTask: (text) => {\n    // Here you can add custom logic before dispatching, if needed\n    console.log('Dispatching new task:', text);\n    dispatch(addTodo(text));\n  },\n  // You could also map toggleTodo if needed here explicitly\n  // toggleExistingTodo: (id) => dispatch(toggleTodo(id))\n});\n\nexport default connect(null, mapDispatchToProps)(TodoForm); // null for mapStateToProps if not needed",
              "explanation": "This example illustrates the function form of `mapDispatchToProps`. It receives the `dispatch` function directly. This allows for more complex logic before or after dispatching, or combining multiple dispatches into a single prop function (e.g., `addTask` here includes a `console.log`). `mapStateToProps` is set to `null` because `TodoForm` doesn't need data from the Redux state, only the ability to dispatch actions.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [],
          "relatedTasks": [],
          "tags": [
            "React",
            "Redux",
            "react-redux",
            "connect",
            "mapStateToProps",
            "mapDispatchToProps",
            "Higher-Order Component"
          ],
          "technology": "React",
          "prerequisites": [
            "React Components",
            "Redux Store",
            "Redux Actions",
            "JavaScript Functions"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate"
        }
      ],
      "questions": [
        {
          "id": "question_selector_basics_1",
          "topic": "Basic Redux Selectors",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary purpose of a basic Redux selector?",
          "answer": "To extract a specific piece of data or derived data from the Redux state, and to encapsulate the state's structure from components.",
          "analysisPoints": [
            "Focuses on data extraction and encapsulation.",
            "Highlights the selector's role in abstracting state shape."
          ],
          "keyConcepts": [
            "Redux Selectors",
            "State Management",
            "Encapsulation"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental selector concept.",
            "Ability to articulate the benefit of encapsulation."
          ],
          "tags": [
            "Redux",
            "Selectors"
          ],
          "prerequisites": [
            "Redux Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_selector_basics_2",
          "topic": "Basic Redux Selectors",
          "level": "medium",
          "type": "mcq",
          "question": "Which of the following best describes the benefit of using basic selectors in a Redux application?",
          "answer": "They encapsulate the state shape, meaning components don't need to know the exact structure of the state.",
          "options": [
            "They automatically memoize complex calculations to prevent re-renders.",
            "They connect React components directly to the Redux store without `react-redux`.",
            "They replace Redux reducers by handling state updates directly.",
            "They encapsulate the state shape, meaning components don't need to know the exact structure of the state."
          ],
          "analysisPoints": [
            "Option A is incorrect; memoization is a feature of Reselect, not basic selectors.",
            "Option B is incorrect; `react-redux`'s `connect` or `useSelector` hook is needed.",
            "Option C is incorrect; reducers handle state updates, selectors extract data.",
            "Option D correctly identifies encapsulation as a key benefit of selectors."
          ],
          "keyConcepts": [
            "Redux Selectors",
            "Encapsulation",
            "State Shape"
          ],
          "evaluationCriteria": [
            "Distinguishing basic selectors from advanced techniques like memoization.",
            "Understanding the architectural benefits of selectors."
          ],
          "example": "Basic selectors simplify component logic by abstracting data access. If `state.user.profile.firstName` changes to `state.userDetails.profile.givenName`, only the selector needs updating, not every component using `firstName`.",
          "tags": [
            "Redux",
            "Selectors",
            "MCQ"
          ],
          "prerequisites": [
            "Redux Basics"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_reselect_1",
          "topic": "Reselect and Memoization",
          "level": "easy",
          "type": "flashcard",
          "question": "What core technique does Reselect use to optimize selector performance?",
          "answer": "Memoization.",
          "analysisPoints": [
            "Tests basic recall of Reselect's fundamental optimization strategy."
          ],
          "keyConcepts": [
            "Reselect",
            "Memoization",
            "Performance"
          ],
          "evaluationCriteria": [
            "Recall of key Reselect feature."
          ],
          "tags": [
            "Redux",
            "Reselect",
            "Memoization"
          ],
          "prerequisites": [
            "Reselect Introduction"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_reselect_2",
          "topic": "Reselect and Memoization",
          "level": "medium",
          "type": "open",
          "question": "Explain how Reselect's memoization works and why it's beneficial in a Redux application.",
          "answer": "Reselect's memoization works by caching the last inputs and the last computed output of a selector. When the selector is called again, it performs a shallow comparison of the new inputs against the cached inputs. If all inputs are strictly equal (`===`), Reselect returns the cached output without re-executing the result function. If any input has changed, the result function is re-computed, and the new inputs and output are cached.\n\nThis is beneficial because it prevents redundant and potentially expensive calculations of derived data, especially in scenarios where components re-render frequently (e.g., due to unrelated state changes) but the specific data they consume has not logically changed. It reduces unnecessary work and optimizes performance, leading to a smoother user experience and less CPU utilization.",
          "analysisPoints": [
            "Detailed explanation of memoization mechanism (caching inputs/outputs, shallow comparison, re-computation condition).",
            "Clear articulation of the performance benefits and how it impacts re-renders.",
            "Understanding the 'why' behind using Reselect."
          ],
          "keyConcepts": [
            "Reselect",
            "Memoization",
            "Performance Optimization",
            "Pure Functions",
            "Shallow Comparison"
          ],
          "evaluationCriteria": [
            "Clarity and accuracy of the explanation.",
            "Ability to connect the technical mechanism to its practical benefits.",
            "Demonstrates a deeper understanding beyond just knowing the term 'memoization'."
          ],
          "tags": [
            "Redux",
            "Reselect",
            "Memoization",
            "Performance",
            "Open-Ended"
          ],
          "prerequisites": [
            "Reselect Concepts"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_reselect_3",
          "topic": "Reselect `createSelector`",
          "level": "hard",
          "type": "code",
          "question": "Given the following Redux state structure and selectors, write a `createSelector` that calculates the total number of unread messages across all users. The selector should be memoized.",
          "answer": "```javascript\nimport { createSelector } from 'reselect';\n\n// Input Selectors\nconst getAllUsers = state => state.users.list;\n\n// Memoized Selector\nexport const getTotalUnreadMessages = createSelector(\n  getAllUsers,\n  (users) => {\n    return users.reduce((total, user) => {\n      return total + user.messages.filter(msg => !msg.read).length;\n    }, 0);\n  }\n);\n\n// Example Usage:\nconst initialState = {\n  users: {\n    list: [\n      { id: 1, name: 'Alice', messages: [{ id: 101, text: 'Hi', read: true }, { id: 102, text: 'Hello', read: false }] },\n      { id: 2, name: 'Bob', messages: [{ id: 201, text: 'Meeting', read: false }, { id: 202, text: 'Report', read: false }, { id: 203, text: 'Urgent', read: true }] }\n    ]\n  }\n};\n\nconst totalUnread = getTotalUnreadMessages(initialState); // Expected: 3\n```",
          "analysisPoints": [
            "Correctly identifies and uses input selectors (`getAllUsers`).",
            "Implements the reduction logic correctly within the result function to sum unread messages.",
            "Properly uses `createSelector` to ensure memoization.",
            "Handles nested data structures and array filtering."
          ],
          "keyConcepts": [
            "Reselect",
            "createSelector",
            "Memoization",
            "Array Methods (reduce, filter)"
          ],
          "evaluationCriteria": [
            "Ability to apply `createSelector` for complex derived data.",
            "Correct use of JavaScript array methods.",
            "Understanding of memoization benefits in a practical scenario."
          ],
          "example": "```javascript\n// State structure example:\n// const state = {\n//   users: {\n//     list: [\n//       { id: 'u1', name: 'User A', messages: [{id: 'm1', text: 'hi', read: false}, {id: 'm2', text: 'bye', read: true}] },\n//       { id: 'u2', name: 'User B', messages: [{id: 'm3', text: 'hey', read: false}] }\n//     ]\n//   }\n// };\n```",
          "tags": [
            "Redux",
            "Reselect",
            "Coding Challenge",
            "Selectors",
            "Hard"
          ],
          "prerequisites": [
            "Reselect Concepts",
            "JavaScript Array Methods"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_reselect_4",
          "topic": "Reselect Input Selectors",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following Reselect selector:\n\n```javascript\nimport { createSelector } from 'reselect';\n\nconst getItems = state => state.cart.items;\nconst getCurrency = state => state.settings.currency;\n\nconst getFormattedTotal = createSelector(\n  getItems,\n  getCurrency,\n  (items, currency) => {\n    const total = items.reduce((sum, item) => sum + item.price, 0);\n    return `${currency} ${total.toFixed(2)}`;\n  }\n);\n```\n\nUnder what condition will `getFormattedTotal` re-calculate its value?",
          "answer": "When the array returned by `getItems` changes its reference, or the string returned by `getCurrency` changes its value.",
          "options": [
            "Every time `getFormattedTotal` is called, regardless of input changes.",
            "Only when the `price` of an item within the `items` array changes, even if the array reference is the same.",
            "When the array returned by `getItems` changes its reference, or the string returned by `getCurrency` changes its value.",
            "When any part of the Redux state changes, even if `state.cart.items` or `state.settings.currency` remain the same."
          ],
          "analysisPoints": [
            "Reselect's memoization uses shallow comparison on the *outputs* of input selectors.",
            "Option A is incorrect; it defeats the purpose of memoization.",
            "Option B is incorrect; Reselect only checks if the `items` array *reference* has changed, not deep changes within the array elements. If an item's price changes, the `items` array reference must also change (e.g., by creating a new array in the reducer) for Reselect to detect it.",
            "Option C correctly identifies that memoization triggers on changes to the *references* of objects/arrays returned by input selectors or values of primitives. If `getItems` returns a new array reference (even if content is similar) or `getCurrency` returns a different string, re-calculation occurs.",
            "Option D is incorrect; Reselect only cares about the specific inputs defined, not the entire state.",
            "This question tests understanding of shallow comparison and how it interacts with immutable updates."
          ],
          "keyConcepts": [
            "Reselect",
            "Memoization",
            "Shallow Comparison",
            "Input Selectors",
            "Immutability"
          ],
          "evaluationCriteria": [
            "Understanding of Reselect's memoization mechanism and its reliance on input selector outputs.",
            "Knowledge of how immutability patterns in Redux interact with selector re-computation."
          ],
          "example": "```javascript\n// Scenario where it re-calculates (new array reference):\nconst state1 = { cart: { items: [{ price: 10 }] }, settings: { currency: '$' } };\nconst state2 = { cart: { items: [{ price: 10 }] }, settings: { currency: '$' } };\n\nconst total1 = getFormattedTotal(state1); // Calculates and caches\nconst total2 = getFormattedTotal(state1); // Returns cached value (items and currency references are same)\n\n// Now, new state where items array reference changes (e.g., due to reducer creating new array)\nconst state3 = { cart: { items: [{ price: 20 }] }, settings: { currency: '$' } };\nconst total3 = getFormattedTotal(state3); // Recalculates because state.cart.items is a new array reference\n\n// If only an item's property changes WITHOUT changing the array reference, it won't re-calculate:\n// (This is why immutability is important in Redux/React)\nconst item = { price: 10 };\nconst state4 = { cart: { items: [item] }, settings: { currency: '$' } };\nconst total4 = getFormattedTotal(state4); // Calculates\nitem.price = 15; // Directly mutating, state4.cart.items reference is still the same array!\nconst total5 = getFormattedTotal(state4); // Returns cached value, WRONG! (Because mutation was not detected)\n// This highlights why reducers must return new objects/arrays for changes.\n```",
          "tags": [
            "Redux",
            "Reselect",
            "Memoization",
            "Immutability",
            "MCQ"
          ],
          "prerequisites": [
            "Reselect Concepts",
            "Redux Immutability"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_redux_connect_1",
          "topic": "`react-redux` `connect`",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the role of `connect()` in `react-redux`?",
          "answer": "It is a Higher-Order Component (HOC) that connects a React component to the Redux store, injecting state and action creators as props.",
          "analysisPoints": [
            "Identifies `connect` as a HOC.",
            "States its purpose: connecting to store and injecting props."
          ],
          "keyConcepts": [
            "react-redux",
            "connect",
            "Higher-Order Component",
            "Redux Integration"
          ],
          "evaluationCriteria": [
            "Basic understanding of `connect`'s function."
          ],
          "tags": [
            "React",
            "Redux",
            "connect"
          ],
          "prerequisites": [
            "React Basics",
            "Redux Basics"
          ],
          "complexity": 3,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_react_redux_connect_2",
          "topic": "`mapStateToProps`",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `mapStateToProps` function:\n\n```javascript\nconst mapStateToProps = (state, ownProps) => ({\n  post: state.posts.find(p => p.id === ownProps.postId),\n  userStatus: state.auth.status\n});\n```\n\nIf a connected component using this `mapStateToProps` receives new `ownProps.postId` but `state.posts` and `state.auth.status` remain unchanged, what will happen?",
          "answer": "The `mapStateToProps` function will re-run, and if the `post` prop's value changes, the component will re-render.",
          "options": [
            "The component will not re-render because only `ownProps` changed, not the Redux state.",
            "The `mapStateToProps` function will not re-run if `state.posts` and `state.auth.status` are the same.",
            "The `mapStateToProps` function will re-run, and if the `post` prop's value changes, the component will re-render.",
            "The component will re-render, but `mapStateToProps` will return cached values."
          ],
          "analysisPoints": [
            "The `mapStateToProps` function runs when the Redux store state changes *or* when the `ownProps` of the connected component change.",
            "Option A is incorrect; `connect` specifically checks `ownProps` changes as well.",
            "Option B is incorrect; `mapStateToProps` is called when `ownProps` change.",
            "Option C is correct. The `find` operation relies on `ownProps.postId`, so a change there will likely result in a new `post` object being returned (or a different reference), triggering a re-render. Even if the found post object is the same, `connect` would still re-run `mapStateToProps` and then shallow compare the resulting props.",
            "Option D is incorrect; `mapStateToProps` will be re-run to produce new props based on the new `ownProps`."
          ],
          "keyConcepts": [
            "mapStateToProps",
            "react-redux",
            "Component Re-render",
            "ownProps"
          ],
          "evaluationCriteria": [
            "Understanding of `mapStateToProps` arguments and re-execution conditions.",
            "Ability to predict component behavior based on prop changes.",
            "Knowledge of `connect`'s internal logic for re-rendering."
          ],
          "example": "This scenario emphasizes that `mapStateToProps` isn't solely dependent on Redux state changes. Changes in props passed *to the connected component itself* can also trigger its re-execution, which is important for dynamically fetching data or filtering based on component-specific inputs.",
          "tags": [
            "React",
            "Redux",
            "mapStateToProps",
            "MCQ"
          ],
          "prerequisites": [
            "React Components",
            "Redux State"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_redux_connect_3",
          "topic": "`mapDispatchToProps`",
          "level": "medium",
          "type": "open",
          "question": "Compare and contrast the two common ways to define `mapDispatchToProps`: the object shorthand and the function form. When would you prefer one over the other?",
          "answer": "**1. Object Shorthand:**\n   ```javascript\n   const mapDispatchToProps = {\n     addTodo,\n     deleteTodo\n   };\n   ```\n   *   **Pros**: Most concise and simplest to write. `react-redux` automatically wraps each action creator in `dispatch()`, so `this.props.addTodo()` directly dispatches the action.\n   *   **Cons**: Offers no direct access to `dispatch` or `ownProps` within `mapDispatchToProps`. You cannot add custom logic (e.g., logging, conditional dispatch) before dispatching the action from inside `mapDispatchToProps` itself.\n\n**2. Function Form:**\n   ```javascript\n   const mapDispatchToProps = (dispatch, ownProps) => ({\n     addTodo: (text) => {\n       // Custom logic here\n       console.log('Adding:', text);\n       dispatch(addTodo(text));\n     },\n     deleteTodo: (id) => dispatch(deleteTodo(id))\n   });\n   ```\n   *   **Pros**: Provides full control. You get direct access to the `dispatch` function and `ownProps`. This allows for custom logic, dispatching multiple actions in one prop function, or using `dispatch` for asynchronous actions (though Redux Thunk/Saga are typically used for that).\n   *   **Cons**: More verbose than the object shorthand. Requires manual wrapping of action creators in `dispatch()`.\n\n**When to Prefer Which:**\n*   **Prefer Object Shorthand**: For most common use cases where you just need to bind action creators to props and don't require any custom pre-dispatch logic or access to `ownProps` within `mapDispatchToProps`. It keeps the code cleaner and less error-prone.\n*   **Prefer Function Form**: When you need fine-grained control over the dispatch process, such as:\n    *   Adding custom logic before an action is dispatched.\n    *   Dispatching multiple actions in response to a single prop function call.\n    *   Binding a prop that dispatches an action based on `ownProps`.\n    *   Using `dispatch` for more advanced middleware scenarios (though often this logic moves into action creators themselves if using Redux Thunk/Saga).\n\nIn general, start with the object shorthand due to its simplicity, and switch to the function form only if specific requirements necessitate the additional control it offers.",
          "analysisPoints": [
            "Clearly defines both forms with code examples.",
            "Lists pros and cons for each.",
            "Provides practical scenarios for when to use each form, demonstrating a nuanced understanding.",
            "Mentions the role of `dispatch` and `ownProps` in the function form."
          ],
          "keyConcepts": [
            "mapDispatchToProps",
            "Object Shorthand",
            "Function Form",
            "Redux Actions",
            "dispatch",
            "react-redux"
          ],
          "evaluationCriteria": [
            "Comprehensive comparison of different `mapDispatchToProps` styles.",
            "Ability to articulate trade-offs and best practices.",
            "Practical application knowledge."
          ],
          "tags": [
            "React",
            "Redux",
            "mapDispatchToProps",
            "Open-Ended"
          ],
          "prerequisites": [
            "Redux Actions",
            "react-redux connect"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_redux_connect_4",
          "topic": "Connecting React Components",
          "level": "hard",
          "type": "code",
          "question": "You have a `ProductDetail` component that needs to display product information and allow adding the product to a cart. The component receives a `productId` via its own props. The Redux state has a `products` array and a `cart` array.\n\nImplement the `mapStateToProps` and `mapDispatchToProps` functions, and then use `connect` to wire up the `ProductDetail` component. The `addToCart` action creator takes a `product` object.",
          "answer": "```javascript\nimport React from 'react';\nimport { connect } from 'react-redux';\n\n// --- Mock Actions (replace with actual actions) ---\nconst selectProduct = (productId) => ({ type: 'SELECT_PRODUCT', payload: productId });\nconst addToCart = (product) => ({ type: 'ADD_TO_CART', payload: product });\n\n// --- Mock Redux State Structure ---\n// state = {\n//   products: [\n//     { id: 'p1', name: 'Laptop', price: 1200 },\n//     { id: 'p2', name: 'Mouse', price: 25 }\n//   ],\n//   cart: []\n// };\n\n// ProductDetail Component\nclass ProductDetail extends React.Component {\n  render() {\n    const { product, addToCart } = this.props;\n\n    if (!product) {\n      return <div>Loading product details...</div>;\n    }\n\n    return (\n      <div>\n        <h2>{product.name}</h2>\n        <p>Price: ${product.price}</p>\n        <button onClick={() => addToCart(product)}>Add to Cart</button>\n      </div>\n    );\n  }\n}\n\n// mapStateToProps: extracts product details based on ownProps.productId\nconst mapStateToProps = (state, ownProps) => {\n  const productId = ownProps.productId;\n  return {\n    product: state.products.find(p => p.id === productId)\n  };\n};\n\n// mapDispatchToProps: provides addToCart action\n// Using object shorthand for simplicity here\nconst mapDispatchToProps = {\n  addToCart\n};\n\n// Connect the component\nexport default connect(mapStateToProps, mapDispatchToProps)(ProductDetail);\n```",
          "analysisPoints": [
            "Correctly uses `ownProps` in `mapStateToProps` to find the specific product.",
            "Demonstrates understanding of how `mapStateToProps` should return an object that becomes props.",
            "Correctly maps `addToCart` action creator using the object shorthand of `mapDispatchToProps`.",
            "Shows the final `connect` call with both mapping functions.",
            "The component effectively uses the props provided by `connect`."
          ],
          "keyConcepts": [
            "connect",
            "mapStateToProps",
            "mapDispatchToProps",
            "ownProps",
            "Redux Actions",
            "React Component"
          ],
          "evaluationCriteria": [
            "Ability to correctly implement `mapStateToProps` with `ownProps`.",
            "Correctly implementing `mapDispatchToProps`.",
            "Properly connecting a React component to Redux.",
            "Practical application of `react-redux` concepts."
          ],
          "example": "```javascript\n// How to use the connected component:\n// <ProductDetail productId=\"p1\" />\n\n// Expected output in console when 'Add to Cart' is clicked for product 'p1':\n// { type: 'ADD_TO_CART', payload: { id: 'p1', name: 'Laptop', price: 1200 } }\n```",
          "tags": [
            "React",
            "Redux",
            "connect",
            "Coding Challenge",
            "Hard"
          ],
          "prerequisites": [
            "React Components",
            "Redux State",
            "Redux Actions",
            "mapStateToProps",
            "mapDispatchToProps"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_reselect_5",
          "topic": "Reselect and Performance",
          "level": "medium",
          "type": "open",
          "question": "Imagine you have a large list of items in your Redux store, and you need to display only the 'active' items, which requires filtering and sorting. If you fetch this 'active' list directly in `mapStateToProps` without Reselect, what potential performance issue might arise? How would Reselect mitigate this?",
          "answer": "If the filtering and sorting of a large list are done directly within `mapStateToProps` without Reselect, a potential performance issue is that this expensive calculation will be re-executed on every single Redux state change, regardless of whether the `items` list itself (or the criteria for 'active') has actually changed. For example, if a completely unrelated part of the state (like `auth.user`) updates, `mapStateToProps` would still re-run, re-filter, and re-sort the entire list, leading to unnecessary CPU cycles and potentially janky UI performance.\n\nReselect mitigates this using memoization. When you define your 'active' items selector with `createSelector`:\n\n```javascript\nconst getItems = state => state.items.list;\nconst getFilterCriteria = state => state.filter.criteria;\n\nconst getActiveItems = createSelector(\n  getItems,\n  getFilterCriteria,\n  (items, criteria) => {\n    // Expensive filtering and sorting logic here\n    return items.filter(...).sort(...);\n  }\n);\n```\n\nThe `getActiveItems` selector will only re-execute its expensive filtering and sorting logic if either `state.items.list` (its reference) or `state.filter.criteria` (its value) changes. If only other parts of the Redux state change, `getItems` and `getFilterCriteria` will return the same references/values, and `getActiveItems` will return its previously cached result immediately, avoiding the re-computation. This significantly improves performance by reducing redundant calculations and preventing unnecessary component re-renders.",
          "analysisPoints": [
            "Identifies the core performance problem: repeated expensive computations on unrelated state changes.",
            "Explains *why* this happens without memoization.",
            "Describes how Reselect's `createSelector` specifically addresses this by tying re-computation to *relevant* input changes.",
            "Provides a clear code example demonstrating the Reselect solution.",
            "Connects the technical solution back to practical benefits like smoother UI."
          ],
          "keyConcepts": [
            "Reselect",
            "Memoization",
            "Performance",
            "mapStateToProps",
            "Derived Data",
            "Optimization"
          ],
          "evaluationCriteria": [
            "Ability to diagnose performance issues in Redux.",
            "Comprehensive explanation of Reselect as a solution.",
            "Clarity in connecting theory to practical application."
          ],
          "tags": [
            "Redux",
            "Reselect",
            "Performance",
            "Optimization",
            "Open-Ended"
          ],
          "prerequisites": [
            "Reselect Concepts",
            "Redux Performance"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_react_redux_connect_5",
          "topic": "Component Re-rendering",
          "level": "medium",
          "type": "mcq",
          "question": "A React functional component `MyComponent` is connected to Redux using `connect`. Its `mapStateToProps` is defined as:\n\n```javascript\nconst mapStateToProps = (state) => ({\n  data: state.items.data,\n  timestamp: Date.now() // !!! Important: This will be a new value on every mapStateToProps call\n});\n```\n\nAssuming `state.items.data` never changes, how often will `MyComponent` re-render if the Redux state is updated by an unrelated action (e.g., `SET_USER_NAME`)?",
          "answer": "Every time the Redux state is updated, `MyComponent` will re-render because `timestamp` always returns a new reference.",
          "options": [
            "Never, because `state.items.data` remains unchanged.",
            "Only when `state.items.data` changes.",
            "Every time the Redux state is updated, `MyComponent` will re-render because `timestamp` always returns a new reference.",
            "Only if `MyComponent`'s own props change."
          ],
          "analysisPoints": [
            "Tests understanding of `connect`'s re-render logic, specifically shallow comparison.",
            "Option A and B are incorrect because `mapStateToProps` is re-run on any state change, and the `timestamp` will always be a new value.",
            "Option C is correct. `connect` performs a shallow comparison of the object returned by `mapStateToProps`. Since `Date.now()` is called every time `mapStateToProps` runs, `timestamp` will always be a new primitive value. This new value will cause the shallow comparison to fail, triggering a re-render of `MyComponent` even if `state.items.data` is identical.",
            "Option D is incorrect; `connect` also re-renders on state changes, not just `ownProps`."
          ],
          "keyConcepts": [
            "connect",
            "mapStateToProps",
            "Shallow Comparison",
            "Component Re-render",
            "Performance Pitfalls"
          ],
          "evaluationCriteria": [
            "Ability to identify subtle performance issues related to `mapStateToProps`.",
            "Deep understanding of how `connect`'s re-render mechanism works with shallow comparison.",
            "Knowledge of common anti-patterns in Redux state mapping."
          ],
          "example": "This is a classic performance pitfall. While `Date.now()` is a simple example, similar issues can arise if you create new object or array literals (`{}` or `[]`) directly within `mapStateToProps` on every call, even if their content is derived from unchanging state. The solution is to ensure `mapStateToProps` returns referentially stable objects/primitives when their underlying data hasn't changed, often by using Reselect.",
          "tags": [
            "React",
            "Redux",
            "mapStateToProps",
            "Performance",
            "MCQ"
          ],
          "prerequisites": [
            "react-redux connect",
            "Shallow Comparison"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_basic_selector_implementation",
          "title": "Implement Basic Redux Selectors",
          "description": "\nCreate basic Redux selectors to extract specific data from a mock Redux state. Your selectors should encapsulate the state shape.\n\n**Requirements:**\n1.  Create a selector `getAuthStatus` that returns the value of `state.auth.isAuthenticated`.\n2.  Create a selector `getNotificationsCount` that returns the length of the `state.notifications.list` array.\n3.  Create a selector `getErrorMessage` that returns the value of `state.app.error` or an empty string if it doesn't exist.\n4.  Demonstrate the usage of each selector with the provided `mockState`.\n",
          "difficulty": "easy",
          "startingCode": "const mockState = {\n  auth: {\n    isAuthenticated: true,\n    user: { id: 'u1', name: 'John Doe' }\n  },\n  notifications: {\n    list: [\n      { id: 1, message: 'New message' },\n      { id: 2, message: 'Task completed' }\n    ],\n    unreadCount: 2\n  },\n  app: {\n    loading: false,\n    error: 'Failed to fetch data'\n  }\n};\n\n// TODO: Implement getAuthStatus selector\n// const getAuthStatus = (state) => { /* ... */ };\n\n// TODO: Implement getNotificationsCount selector\n// const getNotificationsCount = (state) => { /* ... */ };\n\n// TODO: Implement getErrorMessage selector\n// const getErrorMessage = (state) => { /* ... */ };\n\n// Test your selectors\n// console.log('Auth Status:', getAuthStatus(mockState));\n// console.log('Notifications Count:', getNotificationsCount(mockState));\n// console.log('Error Message:', getErrorMessage(mockState));",
          "solutionCode": "const mockState = {\n  auth: {\n    isAuthenticated: true,\n    user: { id: 'u1', name: 'John Doe' }\n  },\n  notifications: {\n    list: [\n      { id: 1, message: 'New message' },\n      { id: 2, message: 'Task completed' }\n    ],\n    unreadCount: 2\n  },\n  app: {\n    loading: false,\n    error: 'Failed to fetch data'\n  }\n};\n\n// 1. Selector for authentication status\nconst getAuthStatus = (state) => state.auth.isAuthenticated;\n\n// 2. Selector for notifications count\nconst getNotificationsCount = (state) => state.notifications.list.length;\n\n// 3. Selector for error message with default fallback\nconst getErrorMessage = (state) => state.app.error || '';\n\n// Test your selectors\nconsole.log('Auth Status:', getAuthStatus(mockState)); // Expected: true\nconsole.log('Notifications Count:', getNotificationsCount(mockState)); // Expected: 2\nconsole.log('Error Message:', getErrorMessage(mockState)); // Expected: 'Failed to fetch data'\n\nconst mockStateNoErrors = {\n  ...mockState,\n  app: {\n    loading: false,\n    error: null\n  }\n};\nconsole.log('Error Message (no error):', getErrorMessage(mockStateNoErrors)); // Expected: ''\n",
          "testCases": [
            "Test `getAuthStatus` with `isAuthenticated: true`.",
            "Test `getAuthStatus` with `isAuthenticated: false`.",
            "Test `getNotificationsCount` with a non-empty list.",
            "Test `getNotificationsCount` with an empty list.",
            "Test `getErrorMessage` when `state.app.error` has a string value.",
            "Test `getErrorMessage` when `state.app.error` is `null` or `undefined`."
          ],
          "hints": [
            "Remember that basic selectors are just pure functions that take the state.",
            "For `getErrorMessage`, consider using the `||` operator for a default value."
          ],
          "tags": [
            "Redux",
            "Selectors",
            "Basic",
            "State Management"
          ],
          "timeEstimate": 20,
          "prerequisites": [
            "Redux Basics"
          ],
          "complexity": 3,
          "interviewRelevance": 6,
          "relatedConcepts": [
            "State Encapsulation",
            "Pure Functions"
          ]
        },
        {
          "id": "task_reselect_complex_calculation",
          "title": "Implement Memoized Selector for User Statistics",
          "description": "\nYour Redux store holds data for multiple users, each with a list of tasks that have a `completed` status. You need to display a dashboard that shows user statistics, specifically the percentage of tasks completed by a specific user.\n\n**Requirements:**\n1.  Create an input selector `getAllUsers` that returns the `state.users.list` array.\n2.  Create an input selector `getCurrentUserId` that returns `state.app.currentUserId`.\n3.  Implement a memoized selector `getUserCompletionPercentage` using `createSelector`.\n    *   This selector should take `getAllUsers` and `getCurrentUserId` as input selectors.\n    *   Its result function should calculate the completion percentage for the `currentUserId`:\n        *   Find the user from `getAllUsers` based on `getCurrentUserId`.\n        *   If the user is not found or has no tasks, return 0.\n        *   Otherwise, calculate `(completed_tasks / total_tasks) * 100`.\n4.  Demonstrate the selector's usage with the provided `mockState`.\n",
          "difficulty": "medium",
          "startingCode": "import { createSelector } from 'reselect';\n\nconst mockState = {\n  users: {\n    list: [\n      { id: 'u1', name: 'Alice', tasks: [{ id: 1, completed: true }, { id: 2, completed: false }] },\n      { id: 'u2', name: 'Bob', tasks: [{ id: 3, completed: true }, { id: 4, completed: true }, { id: 5, completed: false }] },\n      { id: 'u3', name: 'Charlie', tasks: [] }\n    ]\n  },\n  app: {\n    currentUserId: 'u2'\n  }\n};\n\n// 1. TODO: Implement input selector getAllUsers\n// const getAllUsers = (state) => { /* ... */ };\n\n// 2. TODO: Implement input selector getCurrentUserId\n// const getCurrentUserId = (state) => { /* ... */ };\n\n// 3. TODO: Implement memoized selector getUserCompletionPercentage\n// export const getUserCompletionPercentage = createSelector(\n//   /* input selectors */,\n//   (/* result function arguments */) => { /* ... */ }\n// );\n\n// Test your selector\n// console.log('Bob\\'s completion percentage:', getUserCompletionPercentage(mockState));\n\n// const mockStateUser1 = { ...mockState, app: { currentUserId: 'u1' } };\n// console.log('Alice\\'s completion percentage:', getUserCompletionPercentage(mockStateUser1));\n\n// const mockStateNoUser = { ...mockState, app: { currentUserId: 'u99' } };\n// console.log('Non-existent user percentage:', getUserCompletionPercentage(mockStateNoUser));\n",
          "solutionCode": "import { createSelector } from 'reselect';\n\nconst mockState = {\n  users: {\n    list: [\n      { id: 'u1', name: 'Alice', tasks: [{ id: 1, completed: true }, { id: 2, completed: false }] },\n      { id: 'u2', name: 'Bob', tasks: [{ id: 3, completed: true }, { id: 4, completed: true }, { id: 5, completed: false }] },\n      { id: 'u3', name: 'Charlie', tasks: [] }\n    ]\n  },\n  app: {\n    currentUserId: 'u2'\n  }\n};\n\n// 1. Input selector for all users\nconst getAllUsers = (state) => state.users.list;\n\n// 2. Input selector for current user ID\nconst getCurrentUserId = (state) => state.app.currentUserId;\n\n// 3. Memoized selector for user task completion percentage\nexport const getUserCompletionPercentage = createSelector(\n  getAllUsers,\n  getCurrentUserId,\n  (users, currentUserId) => {\n    const user = users.find(u => u.id === currentUserId);\n\n    if (!user || !user.tasks || user.tasks.length === 0) {\n      return 0;\n    }\n\n    const completedTasks = user.tasks.filter(task => task.completed).length;\n    const totalTasks = user.tasks.length;\n\n    return (completedTasks / totalTasks) * 100;\n  }\n);\n\n// Test your selector\nconsole.log('Bob\\'s completion percentage:', getUserCompletionPercentage(mockState)); // Expected: 66.666...\n\nconst mockStateUser1 = { ...mockState, app: { currentUserId: 'u1' } };\nconsole.log('Alice\\'s completion percentage:', getUserCompletionPercentage(mockStateUser1)); // Expected: 50\n\nconst mockStateUser3 = { ...mockState, app: { currentUserId: 'u3' } };\nconsole.log('Charlie\\'s completion percentage:', getUserCompletionPercentage(mockStateUser3)); // Expected: 0\n\nconst mockStateNoUser = { ...mockState, app: { currentUserId: 'u99' } };\nconsole.log('Non-existent user percentage:', getUserCompletionPercentage(mockStateNoUser)); // Expected: 0\n",
          "testCases": [
            "Test for a user with mixed completed/uncompleted tasks (e.g., 'Bob' -> 66.66%).",
            "Test for a user with all completed tasks (e.g., modify Alice's tasks to be all true).",
            "Test for a user with all uncompleted tasks (e.g., modify Alice's tasks to be all false).",
            "Test for a user with an empty `tasks` array (e.g., 'Charlie' -> 0).",
            "Test for a user ID that does not exist in `users.list` (e.g., 'u99' -> 0).",
            "Test to verify memoization: call the selector twice with the same `mockState` and observe no re-calculation if inputs are same (requires a spy or internal check if not running in a debugger)."
          ],
          "hints": [
            "Remember that `createSelector` takes input selectors as its first arguments, and the result function as the last argument.",
            "The result function will receive the *results* of the input selectors as its arguments, in the same order.",
            "Handle edge cases for users with no tasks or non-existent users to avoid division by zero or errors."
          ],
          "tags": [
            "Redux",
            "Reselect",
            "Memoization",
            "Selectors",
            "Derived Data",
            "Coding Challenge"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "Reselect Concepts",
            "JavaScript Array Methods",
            "Basic Selectors"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "relatedConcepts": [
            "Performance Optimization",
            "Pure Functions",
            "Data Transformation"
          ]
        },
        {
          "id": "task_react_redux_connect_component",
          "title": "Connect a Counter Component to Redux",
          "description": "\nImplement a simple `Counter` React component and connect it to a mock Redux store using `react-redux`'s `connect` function. The component should display a counter value from the store and have buttons to increment and decrement it.\n\n**Requirements:**\n1.  Create a `Counter` functional or class component that displays a `count` prop and has `onIncrement` and `onDecrement` props.\n2.  Define a `mapStateToProps` function to map `state.counter.value` to the `count` prop.\n3.  Define `mapDispatchToProps` using the **object shorthand** to map mock `increment` and `decrement` action creators to `onIncrement` and `onDecrement` props.\n4.  Use the `connect` HOC to wrap your `Counter` component.\n5.  Demonstrate the connected component's usage within a minimal React setup (even if just `console.log` for button clicks).\n\n**Bonus:**\n6.  Modify `mapDispatchToProps` to use the **function form** (receiving `dispatch`) and add a `console.log` message before dispatching each action.",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\nimport { connect } from 'react-redux';\n\n// --- Mock Redux State and Actions ---\nconst mockState = { counter: { value: 0 } };\n\nconst increment = () => ({ type: 'INCREMENT' });\nconst decrement = () => ({ type: 'DECREMENT' });\n\n// --- Counter Component (Functional or Class) ---\nfunction Counter({ count, onIncrement, onDecrement }) {\n  return (\n    <div>\n      <h1>Count: {count}</h1>\n      <button onClick={onIncrement}>Increment</button>\n      <button onClick={onDecrement}>Decrement</button>\n    </div>\n  );\n}\n\n// TODO: Implement mapStateToProps\n// const mapStateToProps = (state) => { /* ... */ };\n\n// TODO: Implement mapDispatchToProps (object shorthand first)\n// const mapDispatchToProps = { /* ... */ };\n\n// TODO: Connect the Counter component\n// export default connect(mapStateToProps, mapDispatchToProps)(Counter);\n\n// --- For testing outside a full React app (optional) ---\n// This is just to simulate dispatch and state changes for console output.\n// In a real app, this would be handled by a Redux store and React rendering.\n/*\nconst store = {\n  getState: () => mockState,\n  dispatch: (action) => {\n    console.log('Dispatching:', action.type);\n    // In a real Redux app, a reducer would update mockState here.\n    // For this test, we just log the action.\n  },\n  subscribe: () => () => {}\n};\n\nconst ConnectedCounter = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Counter);\n\n// Example usage (simulating a render)\n// const props = mapStateToProps(store.getState());\n// const dispatchProps = mapDispatchToProps(store.dispatch);\n// console.log('Component props:', { ...props, ...dispatchProps });\n*/",
          "solutionCode": "import React from 'react';\nimport { connect } from 'react-redux';\n\n// --- Mock Redux State and Actions (for demonstration/testing) ---\nconst mockState = { counter: { value: 0 } }; // In a real app, this would be managed by a store\n\nconst increment = () => ({ type: 'INCREMENT' });\nconst decrement = () => ({ type: 'DECREMENT' });\n\n// --- Counter Component (Functional) ---\nfunction Counter({ count, onIncrement, onDecrement }) {\n  return (\n    <div>\n      <h1>Count: {count}</h1>\n      <button onClick={onIncrement}>Increment</button>\n      <button onClick={onDecrement}>Decrement</button>\n    </div>\n  );\n}\n\n// 1. mapStateToProps\nconst mapStateToProps = (state) => ({\n  count: state.counter.value\n});\n\n// 2. mapDispatchToProps (Object Shorthand)\nconst mapDispatchToPropsObject = {\n  onIncrement: increment,\n  onDecrement: decrement\n};\n\n// 3. Connect the Counter component using object shorthand\n// export default connect(mapStateToProps, mapDispatchToPropsObject)(Counter);\n\n// --- Bonus: mapDispatchToProps (Function Form) ---\nconst mapDispatchToPropsFunction = (dispatch) => ({\n  onIncrement: () => {\n    console.log('Dispatching increment action!');\n    dispatch(increment());\n  },\n  onDecrement: () => {\n    console.log('Dispatching decrement action!');\n    dispatch(decrement());\n  }\n});\n\n// 4. Connect the Counter component using function form for mapDispatchToProps\nexport default connect(mapStateToProps, mapDispatchToPropsFunction)(Counter);\n\n// --- For testing outside a full React app ---\n// To run this in a simple JS environment for testing purposes:\n// In a real React application, you'd wrap your app with <Provider store={store}>.\n// Here, we simulate a store and component usage for console verification.\nconst storeForTesting = {\n  getState: () => mockState, // Returns the current mock state\n  dispatch: (action) => {\n    console.log(`Action Dispatched: ${action.type}`);\n    // In a real Redux app, a reducer would update the state here.\n    // For this example, we'll just show what the dispatch would do.\n    if (action.type === 'INCREMENT') {\n        mockState.counter.value++;\n    } else if (action.type === 'DECREMENT') {\n        mockState.counter.value--;\n    }\n    console.log('Current Mock State:', mockState.counter.value);\n  },\n  subscribe: () => () => {},\n};\n\n// Simulate the connected component behavior\nconst ConnectedCounterWithFunctionalMDT = connect(\n  mapStateToProps,\n  mapDispatchToPropsFunction\n)(Counter);\n\n// Now, you can simulate interacting with the connected component's props\n// Note: This is NOT how you would usually test React components, but for demonstrating connect, it works.\nconst componentProps = ConnectedCounterWithFunctionalMDT.WrappedComponent.prototype;\n\n// Call the mapped props with the test store's dispatch\nconst mappedProps = mapStateToProps(storeForTesting.getState());\nconst mappedDispatchProps = mapDispatchToPropsFunction(storeForTesting.dispatch);\n\n// Simulate a click on Increment button\nconsole.log('\\n--- Simulating Increment ---');\nmappedDispatchProps.onIncrement();\n\n// Simulate a click on Decrement button\nconsole.log('\\n--- Simulating Decrement ---');\nmappedDispatchProps.onDecrement();\n\nconsole.log('\\nFinal Mock State Value:', storeForTesting.getState().counter.value);",
          "testCases": [
            "Verify `mapStateToProps` correctly maps `state.counter.value` to `count` prop.",
            "Verify `mapDispatchToProps` (object shorthand) correctly maps `increment` and `decrement` to `onIncrement` and `onDecrement` props.",
            "Verify `onIncrement` and `onDecrement` props, when called, dispatch the correct actions.",
            "Verify `mapDispatchToProps` (function form) correctly maps actions and executes `console.log` before dispatch.",
            "Simulate button clicks and check console output for action dispatches and (if applicable) state changes."
          ],
          "hints": [
            "Remember that `mapStateToProps` returns an object mapping state properties to component props.",
            "For the object shorthand `mapDispatchToProps`, simply provide an object where keys are prop names and values are action creator functions.",
            "For the function form of `mapDispatchToProps`, you'll receive the `dispatch` function and need to manually call `dispatch(actionCreator())`."
          ],
          "tags": [
            "React",
            "Redux",
            "react-redux",
            "connect",
            "mapStateToProps",
            "mapDispatchToProps",
            "Coding Challenge"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React Components",
            "Redux Basics",
            "Redux Actions"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "relatedConcepts": [
            "Higher-Order Component",
            "State Management Integration",
            "Functional Programming"
          ]
        }
      ]
    }
  }
]