[
  {
    "id": "8267bb57-6695-4b81-a0bd-f1b1d911fd37",
    "startLine": 3100,
    "endLine": 3199,
    "processedDate": "2025-06-17T08:38:18.279Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_render_props",
          "title": "Render Props Pattern in React",
          "content": "The Render Props pattern in React refers to a technique where a component's `props` include a function that returns a React element. This function allows the component to share code (behavior or state) with other components without explicitly rendering anything itself. Instead, it delegates the rendering responsibility to the consumer component by calling the provided render prop with its internal state or logic.\n\nThis pattern is particularly useful for sharing non-visual logic, such as data fetching, mouse tracking, or form state management, across multiple components in a reusable manner. The core idea is that the 'render prop' (often named `render` or `children`) is a function that the component calls to determine what to render, passing along whatever data or state it needs to share.\n\n## Key Concepts\n*   **Render Prop**: A prop whose value is a function that a component calls to render something. It typically receives the component's internal state or computed values as arguments.\n*   **`children` as a Function**: A common variation where the `children` prop itself is used as the render prop. This leverages the special `children` prop, which can be any valid React node, including a function.\n*   **Sharing Behavior**: The component implementing the render prop pattern encapsulates specific behavior (e.g., mouse position tracking, data loading) and exposes it via the render function, allowing other components to consume this behavior and render their UI based on it.\n\n## Benefits of Render Props\n1.  **Composition**: Facilitates easy composition of behaviors without modifying existing components. You can wrap components with different render prop components to add new functionalities.\n2.  **Reusability**: Shared functionality (like stateful logic) can be used by multiple disparate components across your application, promoting a DRY (Don't Repeat Yourself) principle.\n3.  **Separation of Concerns**: Clearly separates the logic (what to do) from the UI (what to render). The component with the render prop handles the logic, while the consumer handles the rendering.\n4.  **Flexible Rendering**: Consumers decide exactly what gets rendered based on the data provided by the render prop component. This offers unparalleled flexibility compared to fixed UI components.\n5.  **No HOC Wrapper Hell**: Avoids the issue of deeply nested Higher-Order Components (HOCs) that can make debugging and understanding the component tree difficult (often referred to as 'wrapper hell' or 'pyramid of doom'). Render props typically result in a flatter component tree.\n\n## When to Use Render Props\n*   When you need to share non-visual behavior or state between components (e.g., mouse position, network status, authentication state).\n*   When you want to avoid duplicate code across components that need the same logic.\n*   When you need more flexibility in rendering the UI than a Higher-Order Component might provide, as the render prop offers direct control over the JSX output.\n\n## Relationship with Hooks\nWhile Hooks (introduced in React 16.8) have become the primary way to reuse stateful logic and reduce boilerplate, Render Props remain a valid and sometimes preferred pattern for specific scenarios, especially in older codebases or when working with libraries that still heavily rely on them. Hooks often provide a more concise and readable way to achieve similar results by extracting logic into custom hooks, but Render Props offer explicit JSX-level composition.",
          "examples": [
            {
              "id": "example_render_props_1",
              "title": "Mouse Tracking with Render Prop (named prop)",
              "code": "import React from 'react';\n\nclass MouseTracker extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { x: 0, y: 0 };\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n  }\n\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n\n  render() {\n    // The `render` prop is a function that receives the state\n    return (\n      <div style={{ height: '100vh', border: '1px solid black' }} onMouseMove={this.handleMouseMove}>\n        {this.props.render(this.state)}\n      </div>\n    );\n  }\n}\n\n// Usage of MouseTracker with a named `render` prop\nfunction App() {\n  return (\n    <div>\n      <h1>Move the mouse around!</h1>\n      <MouseTracker\n        render={({ x, y }) => (\n          <p>Current mouse position: ({x}, {y})</p>\n        )}\n      />\n    </div>\n  );\n}",
              "explanation": "This example demonstrates the `MouseTracker` component using a named `render` prop. The `MouseTracker` component manages the mouse position state (`x`, `y`) internally. Instead of rendering a fixed UI, it calls `this.props.render(this.state)`, passing its current mouse coordinates to the function provided by its parent. The `App` component then defines how to render the mouse position using an arrow function passed to the `render` prop, making the `MouseTracker` reusable for displaying the mouse position in various ways.",
              "language": "javascript"
            },
            {
              "id": "example_render_props_2",
              "title": "Mouse Tracking with Render Prop (children as function)",
              "code": "import React from 'react';\n\nclass MouseTracker extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { x: 0, y: 0 };\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n  }\n  \n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n  \n  render() {\n    return (\n      <div style={{ height: '100vh', border: '1px solid blue' }} onMouseMove={this.handleMouseMove}>\n        {/* Using children as a function instead of a custom named prop */}\n        {this.props.children(this.state)}\n      </div>\n    );\n  }\n}\n\n// Usage of MouseTracker with children as a function\nfunction App() {\n  return (\n    <div>\n      <h1>Move the mouse around (children prop)!</h1>\n      <MouseTracker>\n        {({ x, y }) => (\n          <p>Current position: ({x}, {y})</p>\n        )}\n      </MouseTracker>\n    </div>\n  );\n}",
              "explanation": "This example shows the `MouseTracker` component using the `children` prop as a function, which is a common and idiomatic way to implement the Render Props pattern. The `MouseTracker` still manages the state, but instead of calling `this.props.render`, it calls `this.props.children(this.state)`. The consumer component then places the rendering logic directly inside the `MouseTracker`'s JSX tags, defining a function that receives the mouse coordinates. This approach often leads to cleaner and more readable JSX, especially when the render logic is simple.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_render_props_1",
            "question_render_props_2",
            "question_render_props_3",
            "question_render_props_4",
            "question_render_props_5",
            "question_render_props_6",
            "question_render_props_7",
            "question_render_props_8"
          ],
          "relatedTasks": [
            "task_render_props_data_fetcher"
          ],
          "tags": [
            "React",
            "Design Patterns",
            "Render Props",
            "Composition",
            "Reusability",
            "State Management"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Components",
            "React_State_and_Props",
            "Functional_Programming_Concepts"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced_React_Patterns",
            "Reusable_Logic_Components"
          ]
        },
        {
          "id": "theory_compound_components",
          "title": "Compound Components Pattern in React",
          "content": "The Compound Components pattern is a powerful React design pattern where multiple components work together to form a single, cohesive unit, sharing implicit state and behavior. It provides an expressive, declarative, and flexible API for complex component systems, such as `Tabs`, `Accordion`, `Select`, or `Dropdown`.\n\nInstead of managing all internal state and rendering logic within a single, monolithic component, the pattern breaks down the UI into smaller, specialized components that are used together. These sub-components are often rendered as children of a parent component and communicate through shared context.\n\n## Key Concepts\n*   **Shared Implicit State**: The parent component (e.g., `Tabs`) manages the overall state (e.g., `activeIndex`) and provides it to its nested children. This state is 'implicit' because children don't receive it directly via props from the parent; instead, they consume it from a shared context.\n*   **React Context API**: The `React.createContext` and `useContext` hooks are the primary tools for implementing shared implicit state in modern React applications. The parent component provides a context value, and child components consume it.\n*   **Declarative API**: The pattern results in a highly declarative API where the structure of the UI is clear from the JSX. For example, `<Tabs><Tabs.TabList>...</Tabs.TabList></Tabs>` clearly indicates the relationship between components.\n*   **Encapsulation**: While flexible, the pattern maintains encapsulation. The internal state management (e.g., how `activeIndex` changes) is hidden within the main `Tabs` component, and sub-components only interact with the provided context.\n*   **Flexible Composition**: Users of the compound component system can arrange the sub-components in various ways, add custom styling, or inject other components between them, without losing the shared behavior.\n\n## Benefits of Compound Components\n1.  **Expressive and Declarative API**: The way components are used in JSX (`<Tabs.TabList>`, `<Tabs.Tab>`) makes the structure and intent of the UI very clear and readable.\n2.  **Flexible Component Composition**: Allows consumers to arrange and style sub-components freely, enabling highly customizable layouts without resorting to prop drilling or complex prop configurations.\n3.  **Encapsulation of State Logic**: The shared state and its management logic are encapsulated within the main parent component (e.g., `Tabs`), keeping the sub-components simple and focused on their rendering responsibilities.\n4.  **Reduced Prop Drilling**: By using `React.Context`, the pattern avoids passing props down multiple levels of the component tree, making the code cleaner and easier to maintain.\n5.  **Improved Readability and Maintainability**: Breaking down complex UI into smaller, focused components improves code organization and makes it easier to understand, debug, and extend.\n\n## When to Use Compound Components\n*   When building complex UI widgets that consist of multiple related parts that need to share state and behavior (e.g., `Tabs`, `Accordion`, `Dropdown`, `Modal` with `Header`, `Body`, `Footer`).\n*   When you want to provide a highly declarative and flexible API for your components.\n*   When you need to share state implicitly among children without passing props manually through every level of the component tree.",
          "examples": [
            {
              "id": "example_compound_components_1",
              "title": "Tabs Component using Compound Components Pattern",
              "code": "import React, { createContext, useContext, useState } from 'react';\n\n// Create context for the Tabs component\nconst TabsContext = createContext(null);\n\n// Main Tabs component that manages state for all sub-components\nfunction Tabs({ children, defaultActiveIndex = 0 }) {\n  const [activeIndex, setActiveIndex] = useState(defaultActiveIndex);\n  \n  // Provide shared state to all children via context\n  return (\n    <TabsContext.Provider value={{ activeIndex, setActiveIndex }}>\n      <div className=\"tabs\">{children}</div>\n    </TabsContext.Provider>\n  );\n}\n\n// TabList component - container for Tab components\nTabs.TabList = function TabList({ children }) {\n  return <div className=\"tab-list\">{children}</div>;\n};\n\n// Individual Tab component\nTabs.Tab = function Tab({ children, index }) {\n  const { activeIndex, setActiveIndex } = useContext(TabsContext);\n  const isActive = activeIndex === index;\n  \n  return (\n    <div \n      className={`tab ${isActive ? 'active' : ''}`}\n      onClick={() => setActiveIndex(index)}\n      role=\"tab\"\n      aria-selected={isActive}\n      tabIndex={isActive ? 0 : -1}\n    >\n      {children}\n    </div>\n  );\n};\n\n// TabPanels component - container for TabPanel components\nTabs.TabPanels = function TabPanels({ children }) {\n  return <div className=\"tab-panels\">{children}</div>;\n};\n\n// Individual TabPanel component\nTabs.TabPanel = function TabPanel({ children, index }) {\n  const { activeIndex } = useContext(TabsContext);\n  const isActive = activeIndex === index;\n  \n  if (!isActive) return null; // Only render the active panel\n\n  return (\n    <div className=\"tab-panel\" role=\"tabpanel\" hidden={!isActive}>\n      {children}\n    </div>\n  );\n};\n\n// Example Usage:\nfunction App() {\n  return (\n    <Tabs defaultActiveIndex={0}>\n      <Tabs.TabList>\n        <Tabs.Tab index={0}>First Tab</Tabs.Tab>\n        <Tabs.Tab index={1}>Second Tab</Tabs.Tab>\n        <Tabs.Tab index={2}>Third Tab</Tabs.Tab>\n      </Tabs.TabList>\n      <Tabs.TabPanels>\n        <Tabs.TabPanel index={0}>Content for the first tab.</Tabs.TabPanel>\n        <Tabs.TabPanel index={1}>Content for the second tab.</Tabs.TabPanel>\n        <Tabs.TabPanel index={2}>Content for the third tab.</Tabs.TabPanel>\n      </Tabs.TabPanels>\n    </Tabs>\n  );\n}\n",
              "explanation": "This comprehensive example illustrates the Compound Components pattern using the React Context API to build a reusable `Tabs` component system. \n\n1.  **`TabsContext`**: A `React.createContext` instance is created to share `activeIndex` and `setActiveIndex` across all related components.\n2.  **`Tabs` (Parent)**: This component holds the `activeIndex` state and wraps its children with `TabsContext.Provider`, making the state and its setter available to all descendants.\n3.  **`Tabs.TabList`**: A simple container for `Tab` components.\n4.  **`Tabs.Tab`**: Each individual tab. It uses `useContext(TabsContext)` to read the `activeIndex` and `setActiveIndex`. It determines if it's active and sets itself active on click.\n5.  **`Tabs.TabPanels`**: A simple container for `TabPanel` components.\n6.  **`Tabs.TabPanel`**: Each individual content panel. It consumes `activeIndex` from the context and only renders its children if its `index` matches the `activeIndex`.\n\nThe consumer (e.g., `App` component) then composes these sub-components in a declarative way, and they automatically coordinate via the shared context.",
              "language": "javascript"
            }
          ],
          "relatedQuestions": [
            "question_compound_components_1",
            "question_compound_components_2",
            "question_compound_components_3",
            "question_compound_components_4",
            "question_compound_components_5",
            "question_compound_components_6",
            "question_compound_components_7"
          ],
          "relatedTasks": [
            "task_compound_components_accordion"
          ],
          "tags": [
            "React",
            "Design Patterns",
            "Compound Components",
            "Context API",
            "Composition",
            "Encapsulation"
          ],
          "technology": "React",
          "prerequisites": [
            "React_Components",
            "React_Hooks",
            "React_Context_API",
            "Component_Composition"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "Advanced_React_Patterns",
            "Reusable_UI_Libraries",
            "Complex_Component_Design"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_render_props_1",
          "topic": "Render Props Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the core idea behind the 'Render Props' pattern in React?",
          "answer": "The core idea is to share code (behavior or state) between React components using a prop whose value is a function that returns a React element.",
          "analysisPoints": [
            "Identifies the purpose of the pattern (sharing code).",
            "Recognizes the mechanism (prop as a function).",
            "Understands the output (returns a React element)."
          ],
          "keyConcepts": [
            "Render Props Definition",
            "Code Reusability"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles"
          ],
          "example": "A `MouseTracker` component passing `x, y` coordinates via a `render` prop function to a consumer component.",
          "tags": [
            "Render Props",
            "Definition",
            "Basics"
          ],
          "prerequisites": [
            "React_Props"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_render_props_2",
          "topic": "Render Props Implementation",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following `DataProvider` component:\n\n```jsx\nclass DataProvider extends React.Component {\n  state = { data: [] };\n\n  componentDidMount() {\n    // Simulate data fetching\n    setTimeout(() => {\n      this.setState({ data: ['item1', 'item2', 'item3'] });\n    }, 1000);\n  }\n\n  render() {\n    // Which of the following best utilizes the render prop pattern?\n    // A. return <div>{this.props.children}</div>;\n    // B. return <div>{this.props.render()}</div>;\n    // C. return <div>{this.props.render(this.state.data)}</div>;\n    // D. return <div>{this.props.data(this.state.data)}</div>;\n  }\n}\n```\n\nWhich line inside the `render` method correctly implements the Render Props pattern to pass the `data` state to its consumer?",
          "answer": "C. return <div>{this.props.render(this.state.data)}</div>;",
          "options": [
            "A. return <div>{this.props.children}</div>;",
            "B. return <div>{this.props.render()}</div>;",
            "C. return <div>{this.props.render(this.state.data)}</div>;",
            "D. return <div>{this.props.data(this.state.data)}</div>;"
          ],
          "analysisPoints": [
            "Understands that the render prop is a function.",
            "Recognizes that the render prop function needs to be *called*.",
            "Identifies that the internal state/data should be *passed as an argument* to the render prop function.",
            "Distinguishes between a simple `children` prop and `children` as a function."
          ],
          "keyConcepts": [
            "Render Props Implementation",
            "Props as Functions",
            "State Sharing"
          ],
          "evaluationCriteria": [
            "Ability to distinguish between similar concepts",
            "Application of best practices"
          ],
          "example": "Option C correctly demonstrates passing the component's internal state (`this.state.data`) as an argument to the function provided via the `render` prop. Options A and B either don't treat `children` as a function or don't pass data. Option D uses a non-standard prop name for a render prop and assumes it's a function.",
          "tags": [
            "Render Props",
            "Implementation",
            "MCQ",
            "State"
          ],
          "prerequisites": [
            "React_Components",
            "React_State_and_Props"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_render_props_3",
          "topic": "Render Props Benefits",
          "level": "medium",
          "type": "open",
          "question": "Explain at least three key benefits of using the Render Props pattern in React development.",
          "answer": "Three key benefits of using the Render Props pattern are:\n\n1.  **Reusability**: It allows developers to encapsulate and reuse stateful logic or behavior (e.g., mouse tracking, data fetching) across multiple components without duplicating code. The render prop component handles the logic, while different consumer components can use that logic to render diverse UIs.\n2.  **Composition and Flexibility**: It makes it very easy to compose different behaviors. A component can consume data from multiple render prop components, or a render prop component can be used in various parts of the application with different rendering outcomes. The consumer has full control over what to render and how to render it, based on the data provided by the render prop.\n3.  **Separation of Concerns**: It cleanly separates the 'what to do' (the logic/behavior within the render prop component) from the 'how to render' (the UI logic provided by the consumer). This improves code organization, readability, and maintainability.",
          "analysisPoints": [
            "Identifies core benefits like Reusability, Composition, and Separation of Concerns.",
            "Provides clear explanations for each benefit.",
            "Demonstrates understanding of why these benefits are important in React development."
          ],
          "keyConcepts": [
            "Render Props Benefits",
            "Reusability",
            "Composition",
            "Separation of Concerns"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles",
            "Ability to explain concepts clearly"
          ],
          "example": "N/A",
          "tags": [
            "Render Props",
            "Benefits",
            "Open-Ended"
          ],
          "prerequisites": [
            "React_Patterns"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_render_props_4",
          "topic": "Render Props vs. HOCs",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast Render Props with Higher-Order Components (HOCs) in React. When might you prefer one over the other?",
          "answer": "Both Render Props and Higher-Order Components (HOCs) are patterns in React for code reuse and sharing stateful logic. However, they achieve this in different ways and have distinct advantages and disadvantages.\n\n**Render Props:**\n*   **Mechanism**: A component receives a function via a prop (e.g., `render` or `children`), and this function is called inside the component's `render` method, passing the internal state/logic as arguments.\n*   **Composition**: Achieved at the JSX level, often leading to a flatter component tree. Easier to see data flow.\n*   **Debugging**: Generally easier to debug as the component tree is more explicit and props are passed directly.\n*   **Flexibility**: High flexibility because the consumer directly defines the rendering logic.\n*   **Limitations**: Can sometimes lead to deeply nested JSX if multiple render prop components are used (though less problematic than HOC 'wrapper hell').\n\n**Higher-Order Components (HOCs):**\n*   **Mechanism**: A function that takes a component as an argument and returns a new component with enhanced props or behavior.\n*   **Composition**: Achieved at component definition time. Can lead to a deeply nested component tree (wrapper hell) in React DevTools.\n*   **Debugging**: Can be harder to debug due to implicit prop passing and the wrapped component's name not always being clear in DevTools.\n*   **Flexibility**: Less flexible in terms of rendering control compared to Render Props, as the HOC dictates the structure of the enhanced component.\n*   **Limitations**: Name collisions for props, 'wrapper hell', and difficulty in explicitly seeing the source of props.\n\n**When to prefer one over the other:**\n*   **Prefer Render Props when**: You need maximum flexibility in rendering, want to avoid deeply nested component trees in DevTools, or when the shared logic primarily provides data or handlers that dictate *how* to render a part of the UI. It's often clearer for component users to see what data they're receiving.\n*   **Prefer HOCs when**: You want to inject common cross-cutting concerns (like authentication, analytics, or global state) into many components without modifying their render logic, or when you're enhancing a component's capabilities without changing its fundamental rendering. HOCs can be cleaner for truly generic enhancements that don't involve the consumer's rendering choices.\n\nWith the advent of **React Hooks**, many use cases for both Render Props and HOCs can now be handled more cleanly and concisely using custom hooks, which often provide the best of both worlds.",
          "analysisPoints": [
            "Clearly defines both patterns.",
            "Highlights key differences in mechanism, composition, and debugging.",
            "Provides specific scenarios for preference.",
            "Mentions the impact of Hooks as a modern alternative."
          ],
          "keyConcepts": [
            "Render Props",
            "Higher-Order Components",
            "Pattern Comparison",
            "Code Reusability",
            "React Hooks"
          ],
          "evaluationCriteria": [
            "Ability to distinguish between similar concepts",
            "Application of best practices",
            "Encourages critical thinking"
          ],
          "example": "N/A",
          "tags": [
            "Render Props",
            "HOCs",
            "Comparison",
            "Advanced",
            "Architecture"
          ],
          "prerequisites": [
            "React_Patterns",
            "React_Hooks"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_render_props_5",
          "topic": "Render Props `children` vs. named prop",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the common convention for naming the 'render prop' function, and what is an alternative?",
          "answer": "The common convention is to use a prop named `render`, like `this.props.render(data)`. An equally common and often more idiomatic alternative is to use the `children` prop as a function, like `this.props.children(data)`.",
          "analysisPoints": [
            "Identifies `render` as a common name.",
            "Identifies `children` as a function as an alternative.",
            "Shows understanding of the flexibility in naming."
          ],
          "keyConcepts": [
            "Render Props Naming",
            "Children Prop"
          ],
          "evaluationCriteria": [
            "Quick recall/memory-based learning"
          ],
          "example": "N/A",
          "tags": [
            "Render Props",
            "Convention",
            "Basics"
          ],
          "prerequisites": [
            "React_Props"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_render_props_6",
          "topic": "Render Props and Performance",
          "level": "medium",
          "type": "open",
          "question": "When using Render Props, it's possible to encounter performance issues related to unnecessary re-renders. Explain why this might happen and how you would mitigate it.",
          "answer": "Performance issues with Render Props often arise because if the render prop function is defined inline in the consumer component's `render` method (e.g., `<MouseTracker render={({x,y}) => <p>{x},{y}</p>}/>`), a new function instance is created on every render of the consumer component. When this new function is passed as a prop to the `MouseTracker` (or similar render prop component), it will cause `MouseTracker` to re-render, even if its own internal state hasn't changed, because `props.render` is a new reference.\n\n**Mitigation Strategies:**\n\n1.  **Use `React.PureComponent` or `React.memo`**: The render prop component itself (e.g., `MouseTracker`) should be a `PureComponent` (for class components) or wrapped with `React.memo` (for functional components). This will prevent it from re-rendering unless its props (including the render prop function) or state actually change. However, this alone doesn't solve the issue if the inline function *itself* is changing.\n\n2.  **Define the render prop function outside the `render` method**: For class components, define the render prop function as an instance method. For functional components, use `useCallback` to memoize the function. This ensures the function reference remains stable across renders unless its dependencies change.\n\n    ```jsx\n    // Class Component Mitigation\n    class App extends React.Component {\n      renderMousePosition = ({ x, y }) => <p>Position: {x}, {y}</p>;\n\n      render() {\n        return <MouseTracker render={this.renderMousePosition} />;\n      }\n    }\n\n    // Functional Component Mitigation with useCallback\n    const App = () => {\n      const renderMousePosition = useCallback(({ x, y }) => <p>Position: {x}, {y}</p>, []);\n      return <MouseTracker render={renderMousePosition} />;\n    };\n    ```\n\nBy ensuring the render prop function's reference is stable, you prevent unnecessary re-renders of the render prop component when only the consumer component re-renders.",
          "analysisPoints": [
            "Identifies the root cause: inline function creation leading to new prop reference.",
            "Suggests `PureComponent` / `memo` for the render prop component.",
            "Provides correct mitigation for the inline function issue (instance method or `useCallback`).",
            "Includes code examples for mitigation."
          ],
          "keyConcepts": [
            "Render Props",
            "Performance Optimization",
            "Re-renders",
            "PureComponent",
            "React.memo",
            "useCallback"
          ],
          "evaluationCriteria": [
            "Understanding of common pitfalls",
            "Ability to propose practical solutions",
            "Application of best practices"
          ],
          "example": "```jsx\n// Example of the problem:\nfunction AppWithIssue() {\n  return (\n    <MouseTracker render={({ x, y }) => <p>Current: {x}, {y}</p>} />\n    // This inline function creates a new reference on every render of AppWithIssue\n  );\n}\n```",
          "tags": [
            "Render Props",
            "Performance",
            "Optimization",
            "Advanced"
          ],
          "prerequisites": [
            "React_Lifecycle",
            "React_Hooks_Performance",
            "Component_Re-rendering"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        },
        {
          "id": "question_render_props_7",
          "topic": "Render Props Use Case",
          "level": "easy",
          "type": "flashcard",
          "question": "Name one common use case where the Render Props pattern is beneficial.",
          "answer": "Sharing non-visual logic or state, such as mouse position tracking, keyboard input tracking, network status monitoring, or data fetching logic, between multiple components.",
          "analysisPoints": [
            "Provides a relevant and common use case."
          ],
          "keyConcepts": [
            "Render Props Use Cases",
            "Shared Logic"
          ],
          "evaluationCriteria": [
            "Quick recall/memory-based learning"
          ],
          "example": "N/A",
          "tags": [
            "Render Props",
            "Use Case",
            "Basics"
          ],
          "prerequisites": [
            "React_Patterns"
          ],
          "complexity": 3,
          "interviewFrequency": 5,
          "learningPath": "beginner"
        },
        {
          "id": "question_render_props_8",
          "topic": "Render Props and Composition",
          "level": "medium",
          "type": "code",
          "question": "Implement a `Toggle` component using the Render Props pattern (specifically, using `children` as a function). The `Toggle` component should manage a boolean `on` state and provide a `toggle` function to its consumer. The consumer should then render a button that displays 'On' or 'Off' based on the `on` state, and toggles it when clicked.",
          "answer": "```jsx\nimport React, { useState } from 'react';\n\nfunction Toggle({ children }) {\n  const [on, setOn] = useState(false);\n\n  const toggle = () => setOn(prevOn => !prevOn);\n\n  // children is expected to be a function that receives { on, toggle }\n  return children({ on, toggle });\n}\n\n// Example Usage:\nfunction App() {\n  return (\n    <div>\n      <h1>Render Props Toggle Example</h1>\n      <Toggle>\n        {({ on, toggle }) => (\n          <button onClick={toggle}>\n            {on ? 'On' : 'Off'}\n          </button>\n        )}\n      </Toggle>\n      <Toggle>\n        {({ on, toggle }) => (\n          <label style={{ cursor: 'pointer', display: 'block', marginTop: '10px' }}>\n            <input type=\"checkbox\" checked={on} onChange={toggle} /> \n            Toggle Switch: {on ? 'Active' : 'Inactive'}\n          </label>\n        )}\n      </Toggle>\n    </div>\n  );\n}\n\n// To run this example, you would typically render the App component:\n// ReactDOM.render(<App />, document.getElementById('root'));\n```",
          "options": [],
          "analysisPoints": [
            "Correctly implements the `Toggle` component with state and a toggle function.",
            "Uses `children` as a function to pass `on` and `toggle` to the consumer.",
            "Demonstrates a consumer using the provided `on` and `toggle` values to render UI.",
            "Shows understanding of state management within a render prop component."
          ],
          "keyConcepts": [
            "Render Props",
            "Children as Function",
            "State Management",
            "Functional Components"
          ],
          "evaluationCriteria": [
            "Ability to implement the pattern",
            "Correct state management",
            "Correct use of `children` prop"
          ],
          "example": "N/A",
          "tags": [
            "Render Props",
            "Code Challenge",
            "Implementation",
            "Hooks"
          ],
          "prerequisites": [
            "React_Hooks",
            "React_Components"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_compound_components_1",
          "topic": "Compound Components Definition",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary characteristic of the Compound Components pattern in React?",
          "answer": "It's a pattern where multiple components are designed to work together and share implicit state, often providing an expressive and declarative API.",
          "analysisPoints": [
            "Identifies key aspects: multiple components, working together, implicit state, declarative API."
          ],
          "keyConcepts": [
            "Compound Components Definition",
            "Shared State",
            "Declarative API"
          ],
          "evaluationCriteria": [
            "Understanding of fundamental principles"
          ],
          "example": "N/A",
          "tags": [
            "Compound Components",
            "Definition",
            "Basics"
          ],
          "prerequisites": [
            "React_Patterns"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_compound_components_2",
          "topic": "Compound Components and Context API",
          "level": "medium",
          "type": "mcq",
          "question": "Which React API is most commonly used to facilitate the sharing of implicit state between the parent and child components in the Compound Components pattern?",
          "answer": "React Context API (`createContext` and `useContext`)",
          "options": [
            "React Redux",
            "React Context API (`createContext` and `useContext`)",
            "React Portals",
            "React Refs"
          ],
          "analysisPoints": [
            "Identifies the correct and primary mechanism for implicit state sharing.",
            "Distinguishes Context API from other React features/libraries."
          ],
          "keyConcepts": [
            "Compound Components",
            "React Context API",
            "State Sharing"
          ],
          "evaluationCriteria": [
            "Recognition of key tools",
            "Understanding of pattern implementation"
          ],
          "example": "The `Tabs` component uses `TabsContext.Provider` to share `activeIndex` and `setActiveIndex`, while `Tabs.Tab` and `Tabs.TabPanel` use `useContext(TabsContext)` to consume them.",
          "tags": [
            "Compound Components",
            "Context API",
            "MCQ"
          ],
          "prerequisites": [
            "React_Context_API"
          ],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_compound_components_3",
          "topic": "Compound Components Benefits",
          "level": "medium",
          "type": "open",
          "question": "Describe two significant advantages of using the Compound Components pattern for building complex UI widgets.",
          "answer": "Two significant advantages of using the Compound Components pattern are:\n\n1.  **Expressive and Declarative API**: The pattern results in a highly readable and intuitive API. For example, using `<Tabs.TabList><Tabs.Tab>...</Tabs.Tab></Tabs.TabList>` clearly communicates the structure and relationships of the components. This makes the code easier to understand, use, and maintain, even for new developers.\n2.  **Flexible Component Composition**: It allows consumers to arrange the sub-components in various ways and inject their own elements or logic between them, without losing the shared state and behavior. This provides great flexibility, enabling highly customized UI layouts and functionalities that would be difficult to achieve with a single monolithic component or by prop-drilling.",
          "analysisPoints": [
            "Identifies key benefits: Expressive API and Flexible Composition.",
            "Provides clear explanations for each advantage.",
            "Connects the benefits to real-world UI development challenges."
          ],
          "keyConcepts": [
            "Compound Components Benefits",
            "Declarative API",
            "Flexible Composition"
          ],
          "evaluationCriteria": [
            "Ability to explain concepts clearly",
            "Understanding of pattern advantages"
          ],
          "example": "N/A",
          "tags": [
            "Compound Components",
            "Benefits",
            "Open-Ended"
          ],
          "prerequisites": [
            "React_Patterns"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_compound_components_4",
          "topic": "Compound Components Implementation Detail",
          "level": "medium",
          "type": "code",
          "question": "In the Compound Components `Tabs` example, why is `if (!isActive) return null;` used inside the `Tabs.TabPanel` component?",
          "answer": "```javascript\n// Inside Tabs.TabPanel\nconst { activeIndex } = useContext(TabsContext);\nconst isActive = activeIndex === index;\n\nif (!isActive) return null; // This line\n\nreturn (\n  <div className=\"tab-panel\" role=\"tabpanel\" hidden={!isActive}>\n    {children}\n  </div>\n);\n```\n\nThis line `if (!isActive) return null;` is used to prevent the inactive `TabPanel` components from being rendered into the DOM. By returning `null`, React effectively unmounts that specific `TabPanel` and its children from the DOM when it's not the active one. This has several benefits:\n\n1.  **Performance**: It avoids rendering potentially complex UI elements and executing their associated logic (e.g., fetching data, running animations) if they are not currently visible.\n2.  **Resource Management**: Components that are `null` are not in the DOM, reducing the browser's workload.\n3.  **Correctness**: Ensures only the content of the currently active tab is displayed, which is the expected behavior for a tabs component.\n\nWhile a `hidden` HTML attribute could visually hide elements, returning `null` completely removes them, which is often preferred for dynamic content or performance reasons.",
          "options": [],
          "analysisPoints": [
            "Correctly identifies the purpose of `return null` (conditional rendering/unmounting).",
            "Explains the benefits (performance, resource management, correctness).",
            "Differentiates from simply hiding with CSS/HTML attributes."
          ],
          "keyConcepts": [
            "Compound Components",
            "Conditional Rendering",
            "Performance",
            "React DOM"
          ],
          "evaluationCriteria": [
            "Understanding of React rendering lifecycle",
            "Ability to explain code functionality and implications"
          ],
          "example": "N/A",
          "tags": [
            "Compound Components",
            "Conditional Rendering",
            "Performance",
            "Code Explanation"
          ],
          "prerequisites": [
            "React_Rendering",
            "React_Conditional_Rendering"
          ],
          "complexity": 6,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_compound_components_5",
          "topic": "Compound Components vs. Prop Drilling",
          "level": "hard",
          "type": "open",
          "question": "How does the Compound Components pattern, particularly when using React Context, alleviate the problem of 'prop drilling'?",
          "answer": "Prop drilling (or 'prop threading') is a common issue in React where props have to be passed down through multiple layers of nested components to reach a component that actually needs them, even if intermediate components don't directly use those props. This can make code harder to read, maintain, and refactor.\n\nThe Compound Components pattern, when implemented with the React Context API, directly addresses prop drilling by providing a centralized mechanism for sharing state and functions:\n\n1.  **Centralized State Management**: The main parent component (e.g., `Tabs`) manages the shared state (e.g., `activeIndex`) and the functions to update it (e.g., `setActiveIndex`).\n2.  **Context Provision**: This parent component wraps its children with a `Context.Provider`, making the shared state and functions available to *any* descendant component, regardless of how deep it is in the component tree.\n3.  **Direct Consumption**: Any sub-component (e.g., `Tabs.Tab`, `Tabs.TabPanel`) that needs access to this shared state or function can directly consume it using the `useContext` hook, without requiring it to be passed explicitly as a prop from its immediate parent.\n\nThis eliminates the need for intermediate components to receive and pass down props they don't care about, resulting in cleaner code, a more maintainable component structure, and a more focused API for the individual components within the compound system.",
          "analysisPoints": [
            "Defines prop drilling clearly.",
            "Explains how `Context.Provider` makes state available globally within the subtree.",
            "Details how `useContext` allows direct consumption.",
            "Highlights the benefits of avoiding prop drilling."
          ],
          "keyConcepts": [
            "Compound Components",
            "Prop Drilling",
            "React Context API",
            "State Management"
          ],
          "evaluationCriteria": [
            "Understanding of common React problems",
            "Ability to explain solutions provided by patterns",
            "Knowledge of Context API mechanism"
          ],
          "example": "N/A",
          "tags": [
            "Compound Components",
            "Context API",
            "Prop Drilling",
            "Advanced"
          ],
          "prerequisites": [
            "React_Context_API",
            "Component_Props"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_compound_components_6",
          "topic": "Compound Components Structure",
          "level": "easy",
          "type": "flashcard",
          "question": "How are sub-components typically exposed in the Compound Components pattern (e.g., for a `Tabs` component)?",
          "answer": "They are typically exposed as static properties of the main parent component, for example, `Tabs.TabList`, `Tabs.Tab`, `Tabs.TabPanels`, `Tabs.TabPanel`.",
          "analysisPoints": [
            "Identifies the common naming convention/structure."
          ],
          "keyConcepts": [
            "Compound Components Structure",
            "Static Properties"
          ],
          "evaluationCriteria": [
            "Quick recall/memory-based learning"
          ],
          "example": "N/A",
          "tags": [
            "Compound Components",
            "Structure",
            "Basics"
          ],
          "prerequisites": [
            "JavaScript_Object_Properties"
          ],
          "complexity": 3,
          "interviewFrequency": 6,
          "learningPath": "beginner"
        },
        {
          "id": "question_compound_components_7",
          "topic": "Compound Components Use Case",
          "level": "medium",
          "type": "open",
          "question": "Imagine you need to build a complex `Dropdown` component with a trigger, a list of options, and individual option items. Explain how you would apply the Compound Components pattern to design its API and internal structure.",
          "answer": "To design a `Dropdown` component using the Compound Components pattern, you would break it down into several cooperating sub-components, managing its open/closed state and selected value implicitly via React Context.\n\n**API Design:**\n\n```jsx\n<Dropdown>\n  <Dropdown.Trigger>Click Me</Dropdown.Trigger>\n  <Dropdown.Menu>\n    <Dropdown.Item value=\"option1\">Option 1</Dropdown.Item>\n    <Dropdown.Item value=\"option2\">Option 2</Dropdown.Item>\n    <Dropdown.Item value=\"option3\">Option 3</Dropdown.Item>\n  </Dropdown.Menu>\n</Dropdown>\n```\n\n**Internal Structure and State Management (using React Context):**\n\n1.  **`DropdownContext`**: Create a `React.Context` to share the dropdown's `isOpen` state, a `toggle` function, and potentially the `selectedValue` and a function to update it (`setSelectedValue`).\n    ```jsx\n    const DropdownContext = createContext(null);\n    ```\n\n2.  **`Dropdown` (Parent Component)**:\n    *   Manages the `isOpen` (boolean) state to control menu visibility and `selectedValue` state.\n    *   Provides `isOpen`, `toggle` function, `selectedValue`, and `setSelectedValue` via `DropdownContext.Provider` to its children.\n    *   Renders its `children` within a container `div`.\n    ```jsx\n    function Dropdown({ children, onSelect }) {\n      const [isOpen, setIsOpen] = useState(false);\n      const [selectedValue, setSelectedValue] = useState(null);\n      const toggle = () => setIsOpen(prev => !prev);\n      const handleSelect = (value) => {\n        setSelectedValue(value);\n        setIsOpen(false); // Close menu on select\n        onSelect && onSelect(value);\n      };\n\n      const contextValue = { isOpen, toggle, selectedValue, handleSelect };\n\n      return (\n        <DropdownContext.Provider value={contextValue}>\n          <div className=\"dropdown\">{children}</div>\n        </DropdownContext.Provider>\n      );\n    }\n    ```\n\n3.  **`Dropdown.Trigger` (Sub-component)**:\n    *   Consumes `isOpen` and `toggle` from `DropdownContext`.\n    *   Renders a button or trigger element.\n    *   On click, it calls the `toggle` function to open/close the menu.\n    ```jsx\n    Dropdown.Trigger = function DropdownTrigger({ children }) {\n      const { toggle } = useContext(DropdownContext);\n      return <button onClick={toggle}>{children}</button>;\n    };\n    ```\n\n4.  **`Dropdown.Menu` (Sub-component)**:\n    *   Consumes `isOpen` from `DropdownContext`.\n    *   Conditionally renders its `children` (the menu list) based on `isOpen`.\n    *   Typically renders a `<ul>` or `<div>`.\n    ```jsx\n    Dropdown.Menu = function DropdownMenu({ children }) {\n      const { isOpen } = useContext(DropdownContext);\n      if (!isOpen) return null;\n      return <ul className=\"dropdown-menu\">{children}</ul>;\n    };\n    ```\n\n5.  **`Dropdown.Item` (Sub-component)**:\n    *   Consumes `handleSelect` from `DropdownContext`.\n    *   Renders an `<li>` or `<div>`.\n    *   On click, it calls `handleSelect` with its own `value` prop.\n    ```jsx\n    Dropdown.Item = function DropdownItem({ children, value }) {\n      const { handleSelect } = useContext(DropdownContext);\n      return <li onClick={() => handleSelect(value)}>{children}</li>;\n    };\n    ```\n\nThis structure provides a clean, declarative API for the `Dropdown`, allowing users to compose it flexibly while the internal state management remains encapsulated and implicit via Context.",
          "analysisPoints": [
            "Applies the pattern to a new complex UI component (Dropdown).",
            "Defines the declarative API structure for the dropdown.",
            "Explains how `React.Context` would be used to share state (`isOpen`, `toggle`, `selectedValue`).",
            "Details the responsibilities of each sub-component and how they interact with the context."
          ],
          "keyConcepts": [
            "Compound Components",
            "React Context API",
            "Declarative API",
            "Component Design",
            "State Management",
            "Use Cases"
          ],
          "evaluationCriteria": [
            "Ability to apply the pattern to a new problem",
            "Design thinking for component APIs",
            "Correct use of Context API"
          ],
          "example": "N/A",
          "tags": [
            "Compound Components",
            "Design",
            "Architecture",
            "Advanced",
            "Use Case"
          ],
          "prerequisites": [
            "React_Context_API",
            "Component_Design"
          ],
          "complexity": 8,
          "interviewFrequency": 8,
          "learningPath": "advanced"
        }
      ],
      "tasks": [
        {
          "id": "task_render_props_data_fetcher",
          "title": "Implement a Data Fetcher using Render Props",
          "description": "\nImplement a `DataFetcher` component using the Render Props pattern (specifically, using `children` as a function). This component should encapsulate the logic for fetching data from a given URL and managing its loading and error states.\n\n**Requirements:**\n1.  The `DataFetcher` component should accept a `url` prop.\n2.  It should manage three states: `data` (fetched data), `loading` (boolean), and `error` (any error object).\n3.  It should perform data fetching when the component mounts and re-fetch if the `url` prop changes.\n4.  The `children` prop must be a function that receives an object `{ data, loading, error }`.\n5.  The component should set `loading` to `true` before fetching and `false` after fetching (or on error).\n6.  On successful fetch, `data` should be updated. On error, `error` should be updated.\n\nYour solution should be robust enough to handle basic fetching scenarios and clearly demonstrate the Render Props pattern.\n",
          "difficulty": "medium",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\nfunction DataFetcher({ url, children }) {\n  // TODO: Implement state for data, loading, error\n  // TODO: Implement data fetching logic using useEffect\n  // TODO: Call children with the appropriate state\n\n  return null; // Replace with your implementation\n}\n\n// Example Usage (for testing):\nfunction App() {\n  return (\n    <div>\n      <h1>Data Fetcher Example</h1>\n      <DataFetcher url=\"https://jsonplaceholder.typicode.com/posts/1\">\n        {({ data, loading, error }) => {\n          if (loading) return <p>Loading data...</p>;\n          if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n          if (data) return (\n            <div>\n              <h2>Post Title: {data.title}</h2>\n              <p>{data.body}</p>\n            </div>\n          );\n          return <p>No data yet.</p>;\n        }}\n      </DataFetcher>\n\n      <hr />\n\n      <h2>Another Data Fetcher (simulated invalid URL)</h2>\n      <DataFetcher url=\"invalid-url\">\n        {({ data, loading, error }) => {\n          if (loading) return <p>Loading another...</p>;\n          if (error) return <p style={{ color: 'red' }}>Error fetching: {error.message}</p>;\n          return <p>Data received (if any): {JSON.stringify(data)}</p>;\n        }}\n      </DataFetcher>\n    </div>\n  );\n}\n\n// To run this in a React environment:\n// ReactDOM.render(<App />, document.getElementById('root'));",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\nfunction DataFetcher({ url, children }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      setData(null); // Clear previous data\n\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    if (url) {\n      fetchData();\n    } else {\n      // Handle case where URL might be initially empty or null\n      setLoading(false);\n      setError(new Error('URL not provided'));\n    }\n\n  }, [url]); // Re-run effect if URL changes\n\n  // children is expected to be a function that receives { data, loading, error }\n  return children({ data, loading, error });\n}\n\n// Example Usage:\nfunction App() {\n  return (\n    <div>\n      <h1>Data Fetcher Example</h1>\n      <DataFetcher url=\"https://jsonplaceholder.typicode.com/posts/1\">\n        {({ data, loading, error }) => {\n          if (loading) return <p>Loading data...</p>;\n          if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n          if (data) return (\n            <div>\n              <h2>Post Title: {data.title}</h2>\n              <p>{data.body}</p>\n            </div>\n          );\n          return <p>No data yet.</p>;\n        }}\n      </DataFetcher>\n\n      <hr />\n\n      <h2>Another Data Fetcher (simulated invalid URL)</h2>\n      <DataFetcher url=\"https://jsonplaceholder.typicode.com/invalid-path\">\n        {({ data, loading, error }) => {\n          if (loading) return <p>Loading another...</p>;\n          if (error) return <p style={{ color: 'red' }}>Error fetching: {error.message}</p>;\n          return <p>Data received (if any): {JSON.stringify(data)}</p>;\n        }}\n      </DataFetcher>\n\n      <hr />\n\n      <h2>Data Fetcher with no URL (should show error)</h2>\n      <DataFetcher url=\"\">\n        {({ data, loading, error }) => {\n          if (loading) return <p>Still loading, even without URL?</p>;\n          if (error) return <p style={{ color: 'red' }}>Error: {error.message}</p>;\n          return <p>Should not get here.</p>;\n        }}\n      </DataFetcher>\n    </div>\n  );\n}",
          "testCases": [
            "Test with a valid API URL (e.g., `https://jsonplaceholder.typicode.com/posts/1`). Expect `loading` to be `true` initially, then `data` to be populated and `loading` to be `false`.",
            "Test with an invalid API URL (e.g., `https://jsonplaceholder.typicode.com/nonexistent`). Expect `loading` to be `true` initially, then `error` to be populated with an `Error` object and `loading` to be `false`.",
            "Test with `url` prop changing. Expect the component to re-fetch data based on the new URL.",
            "Test with an empty or `null` `url` prop initially. Expect `loading` to become `false` and `error` to indicate missing URL.",
            "Verify that `data` is cleared when a new fetch is initiated (e.g., on `url` change)."
          ],
          "hints": [
            "Use `useState` for `data`, `loading`, and `error` states.",
            "The `useEffect` hook is essential for performing side effects like data fetching. Remember to include `url` in its dependency array.",
            "Don't forget to handle both successful responses and errors during the fetch.",
            "Ensure that `loading` state is correctly managed (set `true` before fetch, `false` in `finally` block)."
          ],
          "tags": [
            "Render Props",
            "Data Fetching",
            "React Hooks",
            "Error Handling",
            "Loading State"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "React_Hooks",
            "JavaScript_Promises",
            "Fetch_API"
          ],
          "complexity": 7,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Render Props Pattern",
            "useEffect Hook",
            "useState Hook",
            "Asynchronous JavaScript"
          ]
        },
        {
          "id": "task_compound_components_accordion",
          "title": "Build an Accordion Component using Compound Components",
          "description": "\nImplement a reusable `Accordion` component system using the Compound Components pattern. The accordion should allow for one item to be open at a time.\n\n**Requirements:**\n1.  Create a main `Accordion` component that manages the `activeIndex` (the index of the currently open panel) state.\n2.  Expose sub-components as static properties of `Accordion`: `Accordion.Item`, `Accordion.Header`, `Accordion.Panel`.\n3.  Use the React Context API to share the `activeIndex` and a function to set it (`setActiveIndex`) implicitly down the component tree.\n4.  `Accordion.Item` should encapsulate an `Accordion.Header` and `Accordion.Panel`.\n5.  `Accordion.Header` should be clickable and, when clicked, should update the `activeIndex` in the parent `Accordion` to its own item's index. It should also indicate if its corresponding panel is active.\n6.  `Accordion.Panel` should only render its content if its corresponding item's index matches the `activeIndex`.\n7.  Ensure the API is declarative and flexible, similar to the `Tabs` example.\n\n",
          "difficulty": "hard",
          "startingCode": "import React, { createContext, useContext, useState } from 'react';\n\n// TODO: Create AccordionContext\n// TODO: Implement Accordion (main component)\n// TODO: Implement Accordion.Item\n// TODO: Implement Accordion.Header\n// TODO: Implement Accordion.Panel\n\n// Example Usage (for testing):\nfunction App() {\n  return (\n    <Accordion defaultIndex={0}>\n      <Accordion.Item index={0}>\n        <Accordion.Header>Section 1 Title</Accordion.Header>\n        <Accordion.Panel>\n          <p>Content for section 1.</p>\n          <ul>\n            <li>Item A</li>\n            <li>Item B</li>\n          </ul>\n        </Accordion.Panel>\n      </Accordion.Item>\n\n      <Accordion.Item index={1}>\n        <Accordion.Header>Section 2 Title</Accordion.Header>\n        <Accordion.Panel>\n          <p>This is the content for section 2. It could be quite long.</p>\n        </Accordion.Panel>\n      </Accordion.Item>\n\n      <Accordion.Item index={2}>\n        <Accordion.Header>Section 3 Title</Accordion.Header>\n        <Accordion.Panel>\n          <p>Final section content.</p>\n          <button>Click Me</button>\n        </Accordion.Panel>\n      </Accordion.Item>\n    </Accordion>\n  );\n}\n\n// To run this in a React environment:\n// ReactDOM.render(<App />, document.getElementById('root'));",
          "solutionCode": "import React, { createContext, useContext, useState, useRef } from 'react';\n\n// Create AccordionContext\nconst AccordionContext = createContext(null);\n\n// Main Accordion component\nfunction Accordion({ children, defaultIndex = -1 }) {\n  const [activeIndex, setActiveIndex] = useState(defaultIndex);\n  \n  const contextValue = {\n    activeIndex,\n    setActiveIndex,\n  };\n\n  return (\n    <AccordionContext.Provider value={contextValue}>\n      <div className=\"accordion\">{children}</div>\n    </AccordionContext.Provider>\n  );\n}\n\n// Accordion.Item component\nAccordion.Item = function AccordionItem({ children, index }) {\n  // Pass the item's index down to its children (Header/Panel)\n  // This allows Header/Panel to know which item they belong to\n  const itemContext = useRef({ index }).current;\n\n  return (\n    <div className=\"accordion-item\">\n      <AccordionItemContext.Provider value={itemContext}>\n        {children}\n      </AccordionItemContext.Provider>\n    </div>\n  );\n};\n\n// New context for Accordion.Item to pass its index to Header/Panel\nconst AccordionItemContext = createContext(null);\n\n// Accordion.Header component\nAccordion.Header = function AccordionHeader({ children }) {\n  const { activeIndex, setActiveIndex } = useContext(AccordionContext);\n  const { index: myIndex } = useContext(AccordionItemContext);\n\n  const isActive = activeIndex === myIndex;\n\n  const handleClick = () => {\n    setActiveIndex(isActive ? -1 : myIndex); // Toggle logic\n  };\n\n  return (\n    <h2 \n      className={`accordion-header ${isActive ? 'active' : ''}`}\n      onClick={handleClick}\n      role=\"button\"\n      aria-expanded={isActive}\n      tabIndex={0}\n    >\n      {children}\n      <span className=\"accordion-icon\">{isActive ? '' : ''}</span>\n    </h2>\n  );\n};\n\n// Accordion.Panel component\nAccordion.Panel = function AccordionPanel({ children }) {\n  const { activeIndex } = useContext(AccordionContext);\n  const { index: myIndex } = useContext(AccordionItemContext);\n\n  const isActive = activeIndex === myIndex;\n\n  if (!isActive) return null; // Hide if not active\n\n  return (\n    <div className=\"accordion-panel\" role=\"region\" hidden={!isActive}>\n      {children}\n    </div>\n  );\n};\n\n// Example Usage:\nfunction App() {\n  return (\n    <div style={{ maxWidth: '600px', margin: '20px auto', border: '1px solid #ccc', borderRadius: '5px' }}>\n      <h1 style={{ textAlign: 'center' }}>Simple Accordion</h1>\n      <Accordion defaultIndex={0}>\n        <Accordion.Item index={0}>\n          <Accordion.Header>Section One - What is React?</Accordion.Header>\n          <Accordion.Panel>\n            <p>React is a JavaScript library for building user interfaces. It lets you compose complex UIs from small and isolated pieces of code called 'components'.</p>\n            <p>React's core principle is declarative programming, making your code more predictable and easier to debug.</p>\n          </Accordion.Panel>\n        </Accordion.Item>\n\n        <Accordion.Item index={1}>\n          <Accordion.Header>Section Two - Why use Hooks?</Accordion.Header>\n          <Accordion.Panel>\n            <p>Hooks let you use state and other React features without writing a class. They make components easier to read, test, and compose.</p>\n            <p>Popular hooks include <code>useState</code>, <code>useEffect</code>, <code>useContext</code>, and <code>useCallback</code>.</p>\n          </Accordion.Panel>\n        </Accordion.Item>\n\n        <Accordion.Item index={2}>\n          <Accordion.Header>Section Three - Compound Components Benefit</Accordion.Header>\n          <Accordion.Panel>\n            <p>Compound components provide a flexible and declarative API, allowing users to arrange sub-components freely while sharing implicit state via React Context. This avoids prop drilling and enhances reusability.</p>\n            <button style={{ padding: '8px 15px', background: '#007bff', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>Learn More</button>\n          </Accordion.Panel>\n        </Accordion.Item>\n      </Accordion>\n    </div>\n  );\n}\n\n// Add some basic CSS for visual feedback (optional for task, but good practice)\n/*\n.accordion-item {\n  border-bottom: 1px solid #eee;\n}\n.accordion-header {\n  padding: 15px;\n  background-color: #f8f8f8;\n  cursor: pointer;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  font-weight: bold;\n}\n.accordion-header.active {\n  background-color: #e0e0e0;\n}\n.accordion-panel {\n  padding: 15px;\n  background-color: #fff;\n}\n.accordion-icon {\n  margin-left: 10px;\n  font-size: 0.8em;\n}\n*/",
          "testCases": [
            "Initialize with `defaultIndex` 0: Expect the first panel to be open and others closed.",
            "Click on the second header: Expect the first panel to close and the second panel to open.",
            "Click on the currently open header: Expect the panel to close (allowing no panels to be open).",
            "Test multiple clicks on different headers to ensure correct active panel switching.",
            "Verify that only one panel is open at any given time.",
            "Test accessibility attributes (e.g., `role`, `aria-expanded`, `tabIndex`) for `Accordion.Header` and `Accordion.Panel`."
          ],
          "hints": [
            "You'll likely need two contexts: one for the main `Accordion` to share `activeIndex` and `setActiveIndex`, and another, temporary one, within `Accordion.Item` to pass the `index` down to its immediate children (`Header` and `Panel`).",
            "The `Accordion.Item` component itself doesn't need to consume the main context, but it's crucial for passing its `index` to its `Header` and `Panel` children.",
            "Inside `Accordion.Header`, determine `isActive` by comparing its own item's `index` with the `activeIndex` from the main context.",
            "Remember to conditionally render `Accordion.Panel` based on its `isActive` status.",
            "Consider `useRef` within `Accordion.Item` to create a stable object for the item's index that can be passed to its context provider, avoiding unnecessary re-renders."
          ],
          "tags": [
            "Compound Components",
            "React Context",
            "State Management",
            "Component Design",
            "UI Widget"
          ],
          "timeEstimate": 90,
          "prerequisites": [
            "React_Context_API",
            "React_Hooks",
            "Component_Composition"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Compound Components Pattern",
            "React Context API",
            "useState Hook",
            "createContext Hook",
            "useContext Hook",
            "Conditional Rendering"
          ]
        }
      ]
    }
  },
  {
    "id": "813fc626-6d3d-42b0-a407-590768e8b398",
    "startLine": 3200,
    "endLine": 3299,
    "processedDate": "2025-06-17T08:39:40.482Z",
    "content": {
      "logicalBlockInfo": {
        "suggestedEndLine": -1
      },
      "theory": [
        {
          "id": "theory_compound_components",
          "title": "React Compound Components Pattern",
          "content": "Compound components are a design pattern in React where multiple components work together to form a complete UI widget, sharing implicit state and logic. Instead of passing many props down to deeply nested children, compound components allow developers to compose a complex UI by using child components as properties of a parent component. This pattern promotes flexibility, reusability, and separation of concerns.\n\n### Key Concepts\n-   **Declarative API**: They create a more readable, HTML-like component structure, making the component's intent clear from its usage.\n-   **Flexible Composition**: The consumer of the component can control the order and structure of the component parts, allowing for greater customization without modifying the core component logic.\n-   **Implicit State Sharing**: Component parts share state without explicit prop drilling. This is often achieved using React Context, allowing children to access the parent's state and methods.\n-   **Encapsulation**: Internal state logic is hidden from the consumer, providing a clean and intuitive API. Consumers only interact with the top-level components and their designated properties.\n-   **Intuitive API**: Developers can understand the relationship between components at a glance, as the nested structure visually represents the logical hierarchy.\n\n### Implementation Details\nTypically, the parent compound component (e.g., `Tabs`) manages the shared state (e.g., `activeIndex`). Its children (e.g., `Tabs.TabList`, `Tabs.Tab`, `Tabs.TabPanels`, `Tabs.TabPanel`) then consume this state, often using `React.Children.map` to iterate over children and `React.cloneElement` to inject props, or more commonly, React Context API for state distribution.",
          "examples": [
            {
              "id": "example_compound_components_1",
              "title": "Tabs Component Usage",
              "code": "import React from 'react';\n\n// Usage of the compound components\nfunction App() {\n  return (\n    <Tabs defaultActiveIndex={1}>\n      <Tabs.TabList>\n        <Tabs.Tab index={0}>Profile</Tabs.Tab>\n        <Tabs.Tab index={1}>Settings</Tabs.Tab>\n        <Tabs.Tab index={2}>Notifications</Tabs.Tab>\n      </Tabs.TabList>\n      \n      <Tabs.TabPanels>\n        <Tabs.TabPanel index={0}>\n          <h2>Profile Content</h2>\n          <p>User profile information goes here</p>\n        </Tabs.TabPanel>\n        <Tabs.TabPanel index={1}>\n          <h2>Settings Content</h2>\n          <p>User settings go here</p>\n        </Tabs.TabPanel>\n        <Tabs.TabPanel index={2}>\n          <h2>Notifications Content</h2>\n          <p>User notifications go here</p>\n        </Tabs.TabPanel>\n      </Tabs.TabPanels>\n    </Tabs>\n  );\n}",
              "explanation": "This example shows how a `Tabs` compound component is used. The `Tabs` component itself wraps `Tabs.TabList` and `Tabs.TabPanels`, which are components attached as properties of `Tabs`. `Tabs.Tab` and `Tabs.TabPanel` are children of their respective parent compound components. This structure allows the `Tabs` component to manage the active index state, which is then implicitly available to `Tabs.Tab` (for highlighting the active tab) and `Tabs.TabPanel` (for displaying the correct content). The consumer only needs to define the structure, and the state management is handled internally by the compound components.",
              "language": "typescript"
            },
            {
              "id": "example_compound_components_2",
              "title": "Conceptual Implementation of Tabs (Simplified)",
              "code": "import React, { useState, createContext, useContext } from 'react';\n\ninterface TabsContextType {\n  activeIndex: number;\n  setActiveIndex: (index: number) => void;\n}\n\nconst TabsContext = createContext<TabsContextType | undefined>(undefined);\n\nfunction useTabsContext() {\n  const context = useContext(TabsContext);\n  if (context === undefined) {\n    throw new Error('useTabsContext must be used within a TabsProvider');\n  }\n  return context;\n}\n\nexport function Tabs({ defaultActiveIndex, children }: { defaultActiveIndex: number; children: React.ReactNode }) {\n  const [activeIndex, setActiveIndex] = useState(defaultActiveIndex);\n\n  const contextValue = { activeIndex, setActiveIndex };\n\n  return (\n    <TabsContext.Provider value={contextValue}>\n      {children}\n    </TabsContext.Provider>\n  );\n}\n\nfunction TabList({ children }: { children: React.ReactNode }) {\n  return <div role=\"tablist\">{children}</div>;\n}\n\nfunction Tab({ index, children }: { index: number; children: React.ReactNode }) {\n  const { activeIndex, setActiveIndex } = useTabsContext();\n  const isActive = activeIndex === index;\n\n  return (\n    <button\n      role=\"tab\"\n      aria-selected={isActive}\n      onClick={() => setActiveIndex(index)}\n      style={{ fontWeight: isActive ? 'bold' : 'normal' }}\n    >\n      {children}\n    </button>\n  );\n}\n\nfunction TabPanels({ children }: { children: React.ReactNode }) {\n  return <div>{children}</div>;\n}\n\nfunction TabPanel({ index, children }: { index: number; children: React.ReactNode }) {\n  const { activeIndex } = useTabsContext();\n  const isActive = activeIndex === index;\n\n  return isActive ? <div role=\"tabpanel\">{children}</div> : null;\n}\n\n// Attach child components to the parent Tabs component\nTabs.TabList = TabList;\nTabs.Tab = Tab;\nTabs.TabPanels = TabPanels;\nTabs.TabPanel = TabPanel;\n",
              "explanation": "This is a simplified conceptual implementation of the `Tabs` compound component using React Context API. The `Tabs` component creates a context (`TabsContext`) to share `activeIndex` and `setActiveIndex`. `Tab` and `TabPanel` components then consume this context using `useTabsContext` to get the necessary state and functions, allowing them to render conditionally or react to state changes without direct prop passing from `Tabs`. This demonstrates how implicit state sharing is achieved.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_compound_components_1",
            "question_compound_components_2",
            "question_compound_components_3",
            "question_compound_components_4",
            "question_compound_components_5",
            "question_compound_components_6"
          ],
          "relatedTasks": [
            "task_compound_components_1"
          ],
          "tags": [
            "React",
            "Design Patterns",
            "Component Composition",
            "Context API",
            "Frontend Architecture"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics",
            "react_context_api"
          ],
          "complexity": 7,
          "interviewRelevance": 8,
          "learningPath": "advanced",
          "requiredFor": [
            "complex_ui_libraries",
            "reusable_component_design"
          ]
        },
        {
          "id": "theory_functional_components_hooks",
          "title": "React Functional Components with Hooks",
          "content": "Functional components are JavaScript functions that accept props as an argument and return React elements. Before the introduction of Hooks in React 16.8, functional components were primarily used for presentational purposes (stateless components). Hooks revolutionized functional components by allowing them to use state and other React features (like lifecycle methods, context) without writing a class.\n\n### Key Concepts\n-   **Simpler Syntax**: More concise and easier to read compared to class components, reducing boilerplate.\n-   **Reusability of Logic**: Hooks allow you to extract stateful logic from a component so it can be tested independently and reused. `useState`, `useEffect`, `useContext`, `useReducer`, `useCallback`, `useMemo`, `useRef` are some built-in hooks.\n-   **No `this` Binding Issues**: Functional components do not have `this` context issues, which simplifies event handler binding.\n-   **Improved Performance (Potentially)**: While not a direct performance gain, the simpler mental model and explicit dependency arrays in `useEffect`, `useCallback`, and `useMemo` can lead to more optimized renders if used correctly.\n\n### `useState` Hook\n`useState` is a Hook that lets you add React state to functional components. It returns a pair: the current state value and a function that lets you update it.\n```typescript\nconst [state, setState] = useState(initialState);\n```\n-   `state`: The current state value.\n-   `setState`: A function to update the state. When called, it queues a re-render of the component.\n-   `initialState`: The value used for the state's initial render. It can be a primitive value or a function that returns the initial state.\n\n### `useEffect` Hook\n`useEffect` is a Hook that lets you perform side effects in functional components. Side effects include data fetching, subscriptions, manually changing the DOM, and logging. It runs after every render of the component by default, but you can control when it runs by specifying a dependency array.\n```typescript\nuseEffect(() => {\n  // Side effect code here\n  return () => {\n    // Cleanup function (optional)\n  };\n}, [dependencies]); // Dependency array (optional)\n```\n-   The first argument is a function containing the side effect logic.\n-   The optional return function is a cleanup function, which runs before the component unmounts or before the effect re-runs.\n-   The second argument, the dependency array, controls when the effect re-runs:\n    -   `[]` (empty array): The effect runs once after the initial render and cleans up when the component unmounts (like `componentDidMount` and `componentWillUnmount`).\n    -   No dependency array: The effect runs after every render.\n    -   `[prop1, state2]`: The effect runs when any of the values in the array change (like `componentDidMount` and `componentDidUpdate`).",
          "examples": [
            {
              "id": "example_functional_components_hooks_1",
              "title": "Basic User Profile with `useState` and `useEffect`",
              "code": "import React, { useState, useEffect } from 'react';\n\n// Mock API call\nconst fetchUser = async () => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({ name: 'John Doe', id: 1 });\n    }, 1000);\n  });\n};\n\nfunction UserProfile() {\n  const [user, setUser] = useState<{ name: string; id: number } | null>(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    fetchUser()\n      .then(data => {\n        setUser(data as { name: string; id: number });\n        setLoading(false);\n      })\n      .catch(error => {\n        console.error('Failed to fetch user:', error);\n        setLoading(false);\n      });\n  }, []); // Empty dependency array: runs once on mount\n  \n  if (loading) return <div>Loading user data...</div>;\n  if (!user) return <div>Failed to load user.</div>;\n  return <div>Hello, {user.name}! Your ID is {user.id}.</div>;\n}",
              "explanation": "This `UserProfile` functional component demonstrates the use of `useState` and `useEffect`. `useState` is used to manage `user` data and `loading` status. `useEffect` is used to perform the `fetchUser` side effect. The empty dependency array `[]` ensures that `fetchUser` is called only once after the initial render, mimicking `componentDidMount` behavior. The `loading` state provides feedback to the user while data is being fetched.",
              "language": "typescript"
            },
            {
              "id": "example_functional_components_hooks_2",
              "title": "Component with State and Props Dependencies",
              "code": "import React, { useState, useEffect } from 'react';\n\ninterface MessageDisplayProps {\n  messageId: number;\n}\n\n// Mock message fetch\nconst fetchMessage = async (id: number) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(`This is message number ${id}.`);\n    }, 500);\n  });\n};\n\nfunction MessageDisplay({ messageId }: MessageDisplayProps) {\n  const [message, setMessage] = useState<string>('');\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n\n  useEffect(() => {\n    setIsLoading(true);\n    fetchMessage(messageId).then(data => {\n      setMessage(data as string);\n      setIsLoading(false);\n    });\n    return () => {\n      // Cleanup if needed, e.g., cancel a fetch request\n    };\n  }, [messageId]); // Reruns when messageId prop changes\n\n  if (isLoading) return <div>Loading message {messageId}...</div>;\n  return <div>Message: {message}</div>;\n}\n\n// Usage in App component:\n// function App() {\n//   const [currentMessageId, setCurrentMessageId] = useState(1);\n//   return (\n//     <div>\n//       <MessageDisplay messageId={currentMessageId} />\n//       <button onClick={() => setCurrentMessageId(prevId => prevId + 1)}>Next Message</button>\n//     </div>\n//   );\n// }\n",
              "explanation": "This example shows `useEffect` with a dependency array containing a prop (`messageId`). The effect will re-run whenever `messageId` changes, fetching a new message. This demonstrates how effects can react to changes in props or state, similar to `componentDidUpdate`.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_functional_components_1",
            "question_functional_components_2",
            "question_functional_components_3",
            "question_functional_components_4",
            "question_functional_components_5",
            "question_functional_components_6"
          ],
          "relatedTasks": [
            "task_functional_components_1"
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "useEffect",
            "Functional Components",
            "State Management",
            "Side Effects"
          ],
          "technology": "React",
          "prerequisites": [
            "javascript_functions",
            "react_basics"
          ],
          "complexity": 6,
          "interviewRelevance": 9,
          "learningPath": "intermediate",
          "requiredFor": [
            "modern_react_development",
            "stateful_functional_components"
          ]
        },
        {
          "id": "theory_props_in_react",
          "title": "React Props (Properties)",
          "content": "Props (short for 'properties') are a mechanism for passing data from parent components to child components in React. They are read-only (immutable) within the receiving component, meaning a child component should never modify the props it receives directly. This immutability helps ensure a unidirectional data flow and predictable component behavior.\n\n### Key Characteristics\n-   **Unidirectional Data Flow**: Data flows down the component tree, from parent to child. This makes it easier to understand how data changes affect the application.\n-   **Read-Only**: Props are immutable within the component that receives them. If a child component needs to change data, it should communicate back to its parent (e.g., via a callback function passed as a prop).\n-   **Reusability**: Components are made more reusable by accepting props, allowing them to render different content or behave differently based on the data they receive.\n-   **Any Data Type**: Props can be of any JavaScript data type, including strings, numbers, booleans, objects, arrays, functions, and even other React elements.\n\n### Passing Props\nProps are passed to components using an HTML-like attribute syntax when rendering a component:\n```typescript\n<MyComponent propName={value} anotherProp=\"string_value\" />\n```\n\n### Receiving Props\n**In Functional Components:**\nFunctional components receive props as the first argument to the function. This argument is an object containing all the props passed to the component.\n\n**In Class Components:**\nClass components receive props via `this.props`. This is an instance property that holds the props object.",
          "examples": [
            {
              "id": "example_props_functional_1",
              "title": "Passing and Receiving Props in Functional Components",
              "code": "import React from 'react';\n\n// Passing props\nfunction App() {\n  return (\n    <UserProfile name=\"John\" age={25} isAdmin={true} />\n  );\n}\n\n// Receiving props using the props object\nfunction UserProfile(props: { name: string; age: number; isAdmin: boolean }) {\n  return (\n    <div>\n      <h2>User Profile: {props.name}</h2>\n      <p>Age: {props.age}</p>\n      {props.isAdmin && <p>Administrator</p>}\n    </div>\n  );\n}\n",
              "explanation": "The `App` component passes `name`, `age`, and `isAdmin` as props to `UserProfile`. The `UserProfile` functional component receives these as a single `props` object and accesses them using `props.name`, `props.age`, etc.",
              "language": "typescript"
            },
            {
              "id": "example_props_functional_2",
              "title": "Receiving Props with Destructuring in Functional Components",
              "code": "import React from 'react';\n\n// Passing props (same as above)\nfunction App() {\n  return (\n    <UserProfile name=\"Jane\" age={30} isAdmin={false} />\n  );\n}\n\n// Receiving props using destructuring\nfunction UserProfile({ name, age, isAdmin }: { name: string; age: number; isAdmin: boolean }) {\n  return (\n    <div>\n      <h2>User Profile: {name}</h2>\n      <p>Age: {age}</p>\n      {isAdmin && <p>Administrator</p>}\n    </div>\n  );\n}",
              "explanation": "This example shows a more common and cleaner way to receive props in functional components using ES6 object destructuring in the function signature. This directly extracts the `name`, `age`, and `isAdmin` properties from the `props` object, making the code more concise.",
              "language": "typescript"
            },
            {
              "id": "example_props_class_1",
              "title": "Receiving Props in Class Components",
              "code": "import React from 'react';\n\ninterface UserProfileProps {\n  name: string;\n  age: number;\n  isAdmin: boolean;\n}\n\nclass UserProfile extends React.Component<UserProfileProps> {\n  render() {\n    const { name, age, isAdmin } = this.props; // Access props via this.props\n    return (\n      <div>\n        <h2>User Profile: {name}</h2>\n        <p>Age: {age}</p>\n        {isAdmin && <p>Administrator</p>}\n      </div>\n    );\n  }\n}\n\n// Usage in App component:\n// function App() {\n//   return (\n//     <UserProfile name=\"Peter\" age={40} isAdmin={true} />\n//   );\n// }\n",
              "explanation": "In class components, props are accessed through `this.props`. Here, destructuring is used from `this.props` within the `render` method to make the usage of props cleaner.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_props_1",
            "question_props_2",
            "question_props_3",
            "question_props_4",
            "question_props_5"
          ],
          "relatedTasks": [
            "task_props_1"
          ],
          "tags": [
            "React",
            "Props",
            "Component Communication",
            "Data Flow",
            "Immutability"
          ],
          "technology": "React",
          "prerequisites": [
            "react_basics",
            "javascript_objects_destructuring"
          ],
          "complexity": 5,
          "interviewRelevance": 8,
          "learningPath": "beginner",
          "requiredFor": [
            "react_component_development",
            "data_passing"
          ]
        },
        {
          "id": "theory_state_in_react",
          "title": "React State Management",
          "content": "State in React refers to data that can change over time within a component and trigger re-renders. Unlike props, which are passed from parent to child and are immutable, state is managed internally by the component itself and is mutable. When state changes, React re-renders the component and its children to reflect the updated data.\n\n### Key Concepts\n-   **Internal Data**: State is private to its component (or managed by a state management solution like Redux/Context API for global state), enabling components to manage their own dynamic data.\n-   **Mutability**: State is designed to be updated. React provides mechanisms (`setState` in class components, `useState` hook in functional components) to update state, which then schedules a re-render.\n-   **Re-renders**: Changes to a component's state trigger a re-render of that component and its child components, ensuring the UI is always in sync with the data.\n-   **Local State**: State is typically local to the component that owns it. If state needs to be shared with siblings or distant descendants, it often needs to be 'lifted up' to a common ancestor or managed via Context API/global state management.\n\n### Managing State with `useState` Hook\nIn functional components, the `useState` Hook is the primary way to manage local component state. It allows you to declare a 'state variable' and a function to update it.\n\n```typescript\nconst [value, setValue] = useState(initialValue);\n```\n-   `value`: The current value of the state variable.\n-   `setValue`: A function that updates `value`. When called, it causes the component to re-render. It can accept a new value directly or a function that receives the previous state and returns the new state (useful for updates based on previous state).\n-   `initialValue`: The value used for the state's initial render. It is only used on the first render.\n\n### How State Differs from Props\n| Feature    | Props                                      | State                                      |\n| :--------- | :----------------------------------------- | :----------------------------------------- |\n| **Origin** | Passed from parent component               | Managed internally by the component        |\n| **Mutable**| Immutable (read-only) in child component   | Mutable (can be updated by the component)  |\n| **Usage**  | Configure component, pass data down        | Manage dynamic data, component's internal data |\n| **Impact** | Re-renders child if parent's prop changes  | Re-renders component and its children      |\n\nUnderstanding the distinction between props and state is fundamental to building dynamic React applications.",
          "examples": [
            {
              "id": "example_state_1",
              "title": "Basic Counter Component with `useState`",
              "code": "import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    setCount(count + 1); // Updates state, triggers re-render\n  };\n\n  const decrement = () => {\n    setCount(prevCount => prevCount - 1); // Using functional update for safety\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n    </div>\n  );\n}",
              "explanation": "This `Counter` component uses `useState` to manage a `count` variable. The `setCount` function is used to update `count`. Clicking the buttons triggers state updates, which in turn causes the component to re-render and display the new count. The `decrement` function uses a functional update (`prevCount => prevCount - 1`) which is preferred when the new state depends on the previous state, ensuring you're working with the most up-to-date value.",
              "language": "typescript"
            },
            {
              "id": "example_state_2",
              "title": "Toggle Component with Boolean State",
              "code": "import React, { useState } from 'react';\n\nfunction ToggleButton() {\n  const [isOn, setIsOn] = useState(false);\n\n  const toggle = () => {\n    setIsOn(prevIsOn => !prevIsOn);\n  };\n\n  return (\n    <div>\n      <button onClick={toggle}>\n        {isOn ? 'Turn Off' : 'Turn On'}\n      </button>\n      <p>Status: {isOn ? 'ON' : 'OFF'}</p>\n    </div>\n  );\n}",
              "explanation": "This component demonstrates managing a boolean state (`isOn`) to control UI elements. The `toggle` function flips the `isOn` state, which causes the button text and status paragraph to update accordingly. This is a common pattern for managing UI visibility or active states.",
              "language": "typescript"
            }
          ],
          "relatedQuestions": [
            "question_state_1",
            "question_state_2",
            "question_state_3",
            "question_state_4",
            "question_state_5",
            "question_state_6"
          ],
          "relatedTasks": [
            "task_state_1"
          ],
          "tags": [
            "React",
            "State",
            "useState",
            "Data Management",
            "Component Lifecycle"
          ],
          "technology": "React",
          "prerequisites": [
            "react_functional_components",
            "javascript_variables"
          ],
          "complexity": 5,
          "interviewRelevance": 9,
          "learningPath": "beginner",
          "requiredFor": [
            "dynamic_ui_development",
            "interactive_components"
          ]
        }
      ],
      "questions": [
        {
          "id": "question_compound_components_1",
          "topic": "Compound Components Benefits",
          "level": "easy",
          "type": "mcq",
          "question": "Which of the following is NOT a direct benefit of using the Compound Components pattern in React?",
          "answer": "Increased prop drilling",
          "options": [
            "Declarative API",
            "Flexible Composition",
            "Implicit State Sharing",
            "Increased prop drilling"
          ],
          "analysisPoints": [
            "Compound components aim to *reduce* prop drilling by providing mechanisms like React Context for implicit state sharing, making 'Increased prop drilling' an incorrect benefit.",
            "Declarative API is achieved by providing a clear, HTML-like structure.",
            "Flexible Composition is a key advantage, allowing consumers to control the internal structure.",
            "Implicit State Sharing is a core feature, often enabled by Context API, avoiding explicit prop passing for shared state."
          ],
          "keyConcepts": [
            "Compound Components",
            "Declarative API",
            "Flexible Composition",
            "Implicit State Sharing",
            "Prop drilling"
          ],
          "evaluationCriteria": [
            "Understanding of compound component benefits",
            "Ability to identify anti-patterns related to component composition"
          ],
          "example": "The primary goal of compound components is to improve developer experience and flexibility, and they achieve implicit state sharing to avoid common issues like excessive prop drilling.",
          "tags": [
            "React",
            "Compound Components",
            "Design Patterns",
            "Prop Drilling"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 4,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_compound_components_2",
          "topic": "Compound Components Structure",
          "level": "medium",
          "type": "open",
          "question": "Explain the typical structure of a React Compound Component pattern, specifically focusing on how the parent and child components interact to share state and logic without explicit prop drilling. Mention the common React API used for this purpose.",
          "answer": "A typical React Compound Component structure involves a main 'parent' component (e.g., `Tabs`) that serves as the entry point and holds the shared state. Its 'child' components (e.g., `Tabs.Tab`, `Tabs.TabList`, `Tabs.TabPanel`) are often attached as static properties to the parent component, allowing for a nested, HTML-like JSX syntax.\n\nThe interaction for state and logic sharing primarily relies on the **React Context API**. The parent component creates a Context Provider, wrapping its children and providing the shared state (e.g., `activeIndex`) and updater functions (e.g., `setActiveIndex`) to the context. The child components then consume this context using the `useContext` hook (in functional components) or `Context.Consumer` (in class components) to access the shared data and functions. This mechanism avoids prop drilling because components in the middle of the tree don't need to explicitly pass down props; instead, relevant children can 'reach up' and consume the necessary state from the context provider.",
          "analysisPoints": [
            "Identifies the parent-child relationship in terms of API structure (e.g., `Tabs.TabList`).",
            "Explains the role of shared state in the parent.",
            "Describes how state is implicitly shared (Context API).",
            "Mentions `useContext` hook as the primary mechanism.",
            "Highlights the benefit of avoiding prop drilling."
          ],
          "keyConcepts": [
            "Compound Components",
            "React Context API",
            "State Sharing",
            "Prop Drilling",
            "Component Composition"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of the pattern's architecture",
            "Correct identification of key React APIs",
            "Clarity in explaining state sharing mechanisms"
          ],
          "tags": [
            "React",
            "Compound Components",
            "Context API",
            "State Management"
          ],
          "prerequisites": [
            "react_context_api",
            "react_hooks_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_compound_components_3",
          "topic": "Compound Components Disadvantages",
          "level": "medium",
          "type": "mcq",
          "question": "While Compound Components offer great benefits, which of the following could be considered a potential disadvantage or complexity when implementing them?",
          "answer": "Increased complexity in state management for deeply nested or highly dynamic structures",
          "options": [
            "Reduced reusability due to tightly coupled parts",
            "Inability to share state between child components",
            "Increased bundle size due to redundant code",
            "Increased complexity in state management for deeply nested or highly dynamic structures"
          ],
          "analysisPoints": [
            "Compound components are designed for *increased* reusability, not reduced.",
            "They *enable* state sharing between child components via Context API.",
            "They don't inherently increase bundle size more than other patterns; redundant code is usually a sign of poor implementation, not the pattern itself.",
            "While they simplify state sharing in many cases, for very complex or deeply nested scenarios, managing the context and ensuring all parts react correctly can introduce its own set of complexities, especially if not designed carefully. Debugging can also be harder as state is implicit.",
            "The primary 'disadvantage' is often the initial setup complexity of the context and parent component, and potential difficulty in debugging implicit state flows if not well-documented."
          ],
          "keyConcepts": [
            "Compound Components",
            "State Management Complexity",
            "React Context"
          ],
          "evaluationCriteria": [
            "Critical thinking about design patterns",
            "Understanding of potential implementation challenges"
          ],
          "example": "While Compound Components simplify the consumer API, the internal implementation, especially managing context for many interdependent parts or highly dynamic scenarios, can become complex. For instance, if you have a `Tabs` component where tabs can be dynamically added/removed, ensuring context updates correctly and all panels respond can require careful handling of indices and state logic.",
          "tags": [
            "React",
            "Compound Components",
            "Design Patterns",
            "Challenges"
          ],
          "prerequisites": [
            "react_context_api"
          ],
          "complexity": 6,
          "interviewFrequency": 5,
          "learningPath": "advanced"
        },
        {
          "id": "question_compound_components_4",
          "topic": "Compound Components vs. Prop Drilling",
          "level": "easy",
          "type": "flashcard",
          "question": "What common React issue do Compound Components help mitigate, and how?",
          "answer": "Compound Components help mitigate 'prop drilling' by allowing implicit state sharing between logically connected components, often through the React Context API.",
          "analysisPoints": [],
          "keyConcepts": [
            "Compound Components",
            "Prop Drilling",
            "React Context"
          ],
          "evaluationCriteria": [
            "Recall of core problem solved",
            "Understanding of solution mechanism"
          ],
          "tags": [
            "React",
            "Compound Components",
            "Prop Drilling"
          ],
          "prerequisites": [],
          "complexity": 3,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_compound_components_5",
          "topic": "Compound Components Code Analysis",
          "level": "medium",
          "type": "code",
          "question": "Consider the following incomplete React code for a `MenuItem` component that is part of a `Menu` compound component. The `Menu` component provides an `activeItem` state and a `setActiveItem` function via a Context. Complete the `MenuItem` component so that it highlights itself if it is the `activeItem` and updates the `activeItem` when clicked. Assume `MenuContext` and `useMenuContext` are already defined and provide `activeItem: string | null` and `setActiveItem: (id: string) => void`.",
          "answer": "```typescript\nimport React, { useContext } from 'react';\n\n// Assume these are defined elsewhere:\ninterface MenuContextType {\n  activeItem: string | null;\n  setActiveItem: (id: string) => void;\n}\n\nconst MenuContext = React.createContext<MenuContextType | undefined>(undefined);\n\nfunction useMenuContext() {\n  const context = useContext(MenuContext);\n  if (context === undefined) {\n    throw new Error('useMenuContext must be used within a MenuProvider');\n  }\n  return context;\n}\n\ninterface MenuItemProps {\n  id: string;\n  children: React.ReactNode;\n}\n\nfunction MenuItem({ id, children }: MenuItemProps) {\n  const { activeItem, setActiveItem } = useMenuContext();\n  const isActive = activeItem === id;\n\n  const handleClick = () => {\n    setActiveItem(id);\n  };\n\n  return (\n    <div\n      onClick={handleClick}\n      style={{ fontWeight: isActive ? 'bold' : 'normal', cursor: 'pointer' }}\n    >\n      {children}\n    </div>\n  );\n}\n```",
          "options": [],
          "analysisPoints": [
            "Correctly uses `useContext` to access shared state and updater function.",
            "Implements logic to determine `isActive` based on `activeItem` from context.",
            "Attaches an `onClick` handler that calls `setActiveItem` with its own `id`.",
            "Demonstrates conditional styling based on active state.",
            "Shows proper prop destructuring for `id` and `children`."
          ],
          "keyConcepts": [
            "Compound Components",
            "React Context",
            "useState",
            "Event Handling",
            "Conditional Rendering/Styling"
          ],
          "evaluationCriteria": [
            "Ability to consume context in a child component.",
            "Correct implementation of event handlers.",
            "Logical application of shared state to UI.",
            "Understanding of component responsibilities within a compound pattern."
          ],
          "example": "The provided solution correctly accesses the `activeItem` and `setActiveItem` from the `MenuContext`. It then uses `activeItem` to determine if the current `MenuItem` should be highlighted and `setActiveItem` to update the active item when clicked, demonstrating effective state sharing within the compound component pattern.",
          "tags": [
            "React",
            "Code Challenge",
            "Compound Components",
            "Context API",
            "Hooks"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_context_api"
          ],
          "complexity": 7,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_compound_components_6",
          "topic": "Compound Components vs. Render Props",
          "level": "hard",
          "type": "open",
          "question": "Compare and contrast the Compound Components pattern with the Render Props pattern in React. When might you choose one over the other, and what are their respective strengths regarding flexibility and implicit state sharing?",
          "answer": "Both Compound Components and Render Props are patterns for sharing logic and state among components, but they achieve this differently.\n\n**Compound Components:**\n*   **Mechanism**: Relies on implicit state sharing, typically via React Context, where a parent component provides state and updater functions that child components (often attached as static properties) consume.\n*   **Flexibility**: Offers high flexibility in terms of *markup structure*. Consumers can freely interleave other HTML elements or components between the compound parts while maintaining the internal logic.\n*   **Implicit State Sharing**: Its main strength. State is shared 'behind the scenes' through context, reducing the need for explicit prop passing through intermediate components.\n*   **Readability**: Creates a very declarative, HTML-like API that is intuitive and easy to read.\n*   **Use Case**: Best for components that are *visually and logically coupled*, forming a single cohesive UI widget (e.g., `Tabs`, `Select`, `Modal`).\n\n**Render Props:**\n*   **Mechanism**: Involves a component that takes a `prop` (usually named `render` or `children`) which is a function that returns a React element. This function receives data/logic from the component, allowing the consumer to render anything based on that data.\n*   **Flexibility**: Offers high flexibility in terms of *rendering logic*. Consumers define exactly what gets rendered using the data provided by the render prop function.\n*   **Implicit State Sharing**: Does *not* inherently provide implicit state sharing. The data is explicitly passed to the render prop function.\n*   **Readability**: Can sometimes lead to deeply nested JSX, often referred to as 'callback hell', making it less readable than compound components for complex structures.\n*   **Use Case**: Best for sharing *behavior or stateful logic* across disparate components, especially when the visual output is highly variable (e.g., `Toggle`, `MouseTracker`).\n\n**When to choose which:**\n*   Choose **Compound Components** when you have a set of components that are logically a single unit and you want to provide a highly declarative and intuitive API for structuring the UI. It excels when the consumer needs control over the *structure* of the combined components.\n*   Choose **Render Props** when you need to share *reusable logic* and want the consumer to have full control over the *rendering* of that logic. It's ideal when the visual output varies greatly but the underlying behavior is consistent.\n\nIn summary, Compound Components provide structural flexibility with implicit state, while Render Props provide rendering flexibility with explicit state/logic passing.",
          "analysisPoints": [
            "Defines both patterns accurately.",
            "Compares their mechanisms (Context vs. function prop).",
            "Contrasts their flexibility (structural vs. rendering).",
            "Explains state sharing differences (implicit vs. explicit).",
            "Discusses readability implications.",
            "Provides clear use cases for each.",
            "Demonstrates a nuanced understanding of React design patterns."
          ],
          "keyConcepts": [
            "Compound Components",
            "Render Props",
            "Design Patterns",
            "Component Composition",
            "React Context",
            "State Sharing",
            "Flexibility"
          ],
          "evaluationCriteria": [
            "Depth of knowledge of React patterns",
            "Ability to articulate trade-offs",
            "Strategic thinking about component design"
          ],
          "tags": [
            "React",
            "Design Patterns",
            "Advanced React",
            "Compound Components",
            "Render Props"
          ],
          "prerequisites": [
            "react_context_api",
            "react_functional_components"
          ],
          "complexity": 9,
          "interviewFrequency": 8,
          "learningPath": "expert"
        },
        {
          "id": "question_functional_components_1",
          "topic": "Functional Components Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the primary difference between a functional component and a class component in React before Hooks?",
          "answer": "Before Hooks, functional components were stateless and couldn't use lifecycle methods, while class components could manage state and utilize lifecycle methods.",
          "analysisPoints": [],
          "keyConcepts": [
            "Functional Components",
            "Class Components",
            "State",
            "Lifecycle Methods"
          ],
          "evaluationCriteria": [
            "Basic recall of component types"
          ],
          "tags": [
            "React",
            "Functional Components",
            "Class Components"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 8,
          "learningPath": "beginner"
        },
        {
          "id": "question_functional_components_2",
          "topic": "Hooks Purpose",
          "level": "easy",
          "type": "mcq",
          "question": "What problem do React Hooks primarily solve for functional components?",
          "answer": "Allowing functional components to use state and lifecycle features.",
          "options": [
            "Eliminating the need for JSX.",
            "Allowing functional components to use state and lifecycle features.",
            "Replacing the Virtual DOM entirely.",
            "Enforcing strict type checking in JavaScript."
          ],
          "analysisPoints": [
            "Hooks were introduced to bridge the gap between functional components (simplicity) and class components (state/lifecycle capabilities).",
            "JSX is a syntax extension, unrelated to Hooks' primary purpose.",
            "Hooks operate within the Virtual DOM concept, not replacing it.",
            "Hooks don't enforce type checking; TypeScript does that."
          ],
          "keyConcepts": [
            "React Hooks",
            "Functional Components",
            "State Management",
            "Lifecycle Methods"
          ],
          "evaluationCriteria": [
            "Understanding of Hooks' core value proposition"
          ],
          "example": "Before Hooks, if you needed state or lifecycle methods in a component, you had to convert it to a class component. Hooks, like `useState` and `useEffect`, brought these capabilities directly to functional components, making them more powerful and reducing the need for class components.",
          "tags": [
            "React",
            "Hooks",
            "Functional Components"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_components_3",
          "topic": "`useEffect` Dependencies",
          "level": "medium",
          "type": "open",
          "question": "Explain the role of the dependency array in the `useEffect` hook. Provide an example of how its absence, an empty array, and an array with values affect the execution of the effect and its cleanup.",
          "answer": "The dependency array (the second argument) in `useEffect` controls when the effect function re-runs and when its cleanup function (if provided) is executed. It tells React to re-run the effect only when values in this array change.\n\n1.  **No dependency array**: `useEffect(() => { /* effect */ });`\n    *   **Execution**: The effect runs after *every* render of the component.\n    *   **Cleanup**: The cleanup function (if any) runs before *every* re-execution of the effect and before the component unmounts.\n    *   **Use Case**: Very rarely used, often indicates a bug if not intentionally desired (e.g., logging every render).\n\n2.  **Empty dependency array**: `useEffect(() => { /* effect */ }, []);`\n    *   **Execution**: The effect runs only *once* after the initial render of the component.\n    *   **Cleanup**: The cleanup function runs only *once* when the component unmounts.\n    *   **Use Case**: Mimics `componentDidMount` and `componentWillUnmount` behavior, suitable for one-time setups like data fetching, subscriptions, or adding event listeners.\n\n3.  **Dependency array with values**: `useEffect(() => { /* effect */ }, [val1, val2]);`\n    *   **Execution**: The effect runs after the initial render, and then *only if any value in the `[val1, val2]` array changes* between renders.\n    *   **Cleanup**: The cleanup function runs before the effect re-runs (due to dependency change) and before the component unmounts.\n    *   **Use Case**: Mimics `componentDidMount` and `componentDidUpdate` (for specific props/state), suitable for effects that depend on dynamic values, like fetching data based on a user ID or reacting to prop changes.\n\nCorrectly using the dependency array is crucial for preventing infinite loops, optimizing performance, and avoiding stale closures in `useEffect`.",
          "analysisPoints": [
            "Clearly defines the purpose of the dependency array.",
            "Explains behavior for no array, empty array, and array with values.",
            "Provides analogy to class component lifecycle methods.",
            "Discusses cleanup function execution in each scenario.",
            "Mentions practical use cases for each scenario.",
            "Highlights the importance of correct usage."
          ],
          "keyConcepts": [
            "React Hooks",
            "useEffect",
            "Dependency Array",
            "Side Effects",
            "Component Lifecycle",
            "Cleanup Function"
          ],
          "evaluationCriteria": [
            "Comprehensive understanding of `useEffect` behavior",
            "Ability to explain implications of dependency array choices",
            "Knowledge of related lifecycle concepts"
          ],
          "tags": [
            "React",
            "Hooks",
            "useEffect",
            "Lifecycle"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_components_4",
          "topic": "`useState` Functional Updates",
          "level": "medium",
          "type": "mcq",
          "question": "Consider the following React functional component and its state update logic:\n\n```typescript\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    setCount(count + 1); // Line A\n    setCount(count + 1); // Line B\n    setCount(count + 1); // Line C\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Increment 3 Times</button>\n    </div>\n  );\n}\n```\n\nIf the current `count` is `0` and `handleClick` is called, what will be the value of `count` displayed after the component re-renders?",
          "answer": "1",
          "options": [
            "0",
            "1",
            "2",
            "3"
          ],
          "analysisPoints": [
            "React state updates are asynchronous and batched. When `setCount(count + 1)` is called multiple times within the same event loop, React batches these updates.",
            "Because `count` is a stale closure in each of these `setCount` calls (it refers to the `count` value *at the time the event handler was called*, i.e., `0`), all three calls will try to update `count` from `0` to `1`.",
            "Only the last update in the batch 'wins' if the new state depends on the previous state in an unbatched manner, but here, they all depend on the *same* initial `count` value. So, they all effectively try to set `count` to `0 + 1`.",
            "To correctly increment by 3, functional updates (`setCount(prevCount => prevCount + 1)`) should be used, as they guarantee access to the latest state."
          ],
          "keyConcepts": [
            "useState",
            "State Batching",
            "Asynchronous Updates",
            "Stale Closures",
            "Functional Updates"
          ],
          "evaluationCriteria": [
            "Understanding of React's state update mechanism",
            "Knowledge of state batching and stale closures"
          ],
          "example": "```typescript\n// Corrected handleClick using functional updates:\nconst handleClick = () => {\n  setCount(prevCount => prevCount + 1);\n  setCount(prevCount => prevCount + 1);\n  setCount(prevCount => prevCount + 1);\n};\n// With this correction, clicking the button would correctly update count to 3.\n```\nWhen `setCount(count + 1)` is called multiple times synchronously, React batches these updates. Each `setCount` call uses the `count` value from the closure of that render. If `count` is 0 when `handleClick` is invoked, all three `setCount` calls will effectively calculate `0 + 1 = 1`. React then processes these batched updates, resulting in `count` becoming `1` after the single re-render.",
          "tags": [
            "React",
            "Hooks",
            "useState",
            "State Management",
            "Batching"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 7,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_functional_components_5",
          "topic": "Functional Component Props",
          "level": "easy",
          "type": "flashcard",
          "question": "How do functional components receive props, and what's a common way to extract them for use?",
          "answer": "Functional components receive props as the first argument (an object). A common way to extract them for use is via ES6 object destructuring in the function signature.",
          "analysisPoints": [],
          "keyConcepts": [
            "Functional Components",
            "Props",
            "Destructuring"
          ],
          "evaluationCriteria": [
            "Recall of basic prop handling"
          ],
          "tags": [
            "React",
            "Props",
            "Functional Components"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 7,
          "learningPath": "beginner"
        },
        {
          "id": "question_functional_components_6",
          "topic": "When to use Functional vs. Class Components",
          "level": "hard",
          "type": "open",
          "question": "Given the widespread adoption of Hooks, discuss the current relevance of class components in modern React development. When might you still encounter or choose to use a class component over a functional component with Hooks, if at all?",
          "answer": "With the introduction of React Hooks, functional components have become the recommended and predominant way to write React components. They offer a simpler API, better reusability of stateful logic, and often lead to more concise code.\n\n**Current Relevance of Class Components:**\nWhile functional components with Hooks cover almost all use cases previously requiring class components, class components are not entirely deprecated. You will still encounter them in:\n\n1.  **Legacy Codebases**: Many existing large applications were built before Hooks were introduced. Migrating an entire codebase can be a massive undertaking, so new features might still be added using class components to maintain consistency, or new functional components might coexist with existing class components.\n2.  **Error Boundaries**: As of React 18, `componentDidCatch` and `static getDerivedStateFromError` lifecycle methods are still unique to class components for implementing Error Boundaries. There is no Hook equivalent for this specific feature.\n3.  **Older React Versions**: If working on a project using an older React version (pre-16.8), class components are necessary for stateful logic and lifecycle methods.\n4.  **Learning/Understanding History**: Understanding class components can be beneficial for debugging older code or appreciating the evolution of React's API.\n\n**When you *might* still choose a Class Component (very rare now):**\n*   **Error Boundaries**: This is the only legitimate and commonly cited reason today.\n*   **Specific edge cases or complex component logic** where a developer might find the class component's lifecycle methods more intuitive for a very particular setup, although this is becoming increasingly rare as developers become more proficient with `useEffect`.\n*   **Resistance to change / personal preference**: Some developers might prefer the mental model of class components, though this is generally discouraged for new development.\n\n**Conclusion:** For all new React development, functional components with Hooks are the **preferred choice**. Class components are primarily maintained for backward compatibility and the niche use case of Error Boundaries. Interviewers often ask this to gauge your understanding of React's evolution and best practices.",
          "analysisPoints": [
            "Acknowledges functional components with Hooks as the standard.",
            "Identifies key reasons for class component continued existence (legacy code, error boundaries).",
            "Explains the specific limitation of Hooks regarding error boundaries.",
            "Discusses other less common/valid reasons for using class components.",
            "Provides a clear conclusion on modern best practices.",
            "Demonstrates awareness of React's evolution."
          ],
          "keyConcepts": [
            "Functional Components",
            "Class Components",
            "React Hooks",
            "Error Boundaries",
            "Legacy Code",
            "Component Lifecycle"
          ],
          "evaluationCriteria": [
            "In-depth understanding of React component types.",
            "Knowledge of Hooks' capabilities and limitations.",
            "Awareness of current best practices and legacy considerations."
          ],
          "tags": [
            "React",
            "Hooks",
            "Class Components",
            "Functional Components",
            "Error Boundaries"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_class_components_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 7,
          "learningPath": "advanced"
        },
        {
          "id": "question_props_1",
          "topic": "Props Immutability",
          "level": "easy",
          "type": "mcq",
          "question": "Which statement accurately describes props in React?",
          "answer": "Props are immutable and flow from parent to child.",
          "options": [
            "Props are mutable and can be changed by the child component.",
            "Props are immutable and flow from parent to child.",
            "Props are used for internal component state management.",
            "Props are only used for passing primitive data types."
          ],
          "analysisPoints": [
            "Props are strictly read-only in the receiving component; they cannot be mutated directly by the child.",
            "Data flow in React is unidirectional, always from parent to child.",
            "Props are for external data from parents, while state is for internal, mutable data.",
            "Props can pass any JavaScript data type, including objects, arrays, functions, and React elements."
          ],
          "keyConcepts": [
            "Props",
            "Immutability",
            "Unidirectional Data Flow",
            "Component Communication"
          ],
          "evaluationCriteria": [
            "Fundamental understanding of props characteristics"
          ],
          "example": "If a child component needs to change data that originated as a prop, it should request the parent component to update its state, which then re-renders the child with new props. This strict immutability of props ensures predictable data flow and easier debugging.",
          "tags": [
            "React",
            "Props",
            "Immutability"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 3,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_props_2",
          "topic": "Passing Functions as Props",
          "level": "medium",
          "type": "open",
          "question": "Describe how you would pass a callback function from a parent component to a child component via props, and explain why this pattern is essential for communication back up the component tree in React.",
          "answer": "To pass a callback function, the parent component defines a function (e.g., `handleChildClick`) and then passes it as a prop to the child component:\n\n```typescript\n// ParentComponent.tsx\nimport React, { useState } from 'react';\nimport { ChildComponent } from './ChildComponent';\n\nfunction ParentComponent() {\n  const [message, setMessage] = useState('No message yet');\n\n  const handleChildClick = (dataFromChild: string) => {\n    setMessage(`Child says: ${dataFromChild}`);\n  };\n\n  return (\n    <div>\n      <p>{message}</p>\n      <ChildComponent onButtonClick={handleChildClick} />\n    </div>\n  );\n}\n\n// ChildComponent.tsx\nimport React from 'react';\n\ninterface ChildComponentProps {\n  onButtonClick: (data: string) => void;\n}\n\nexport function ChildComponent({ onButtonClick }: ChildComponentProps) {\n  return (\n    <button onClick={() => onButtonClick('Hello from child!')}>\n      Click me\n    </button>\n  );\n}\n```\n\nThis pattern is essential for **communication back up the component tree** (child to parent) because props themselves enforce a unidirectional data flow (parent to child). Since child components cannot directly modify props or their parent's state, passing a function as a prop provides a mechanism for the child to *inform* the parent that something has happened or that data needs to be updated. When the child invokes the callback function, the parent's function (and potentially its state) is updated, triggering a re-render of the parent and any affected children. This maintains React's philosophy of predictable data flow and a single source of truth for state.",
          "analysisPoints": [
            "Provides a clear code example of passing a function as a prop.",
            "Explains how the child uses the received function.",
            "Articulates *why* this pattern is necessary (unidirectional data flow, child-to-parent communication).",
            "Connects the concept to maintaining React's data flow principles."
          ],
          "keyConcepts": [
            "Props",
            "Callback Functions",
            "Unidirectional Data Flow",
            "Component Communication",
            "State Lifting"
          ],
          "evaluationCriteria": [
            "Practical understanding of prop usage for callbacks",
            "Theoretical grasp of React's data flow principles",
            "Ability to explain the 'why' behind the pattern"
          ],
          "tags": [
            "React",
            "Props",
            "Component Communication",
            "Callbacks"
          ],
          "prerequisites": [
            "react_basics",
            "javascript_functions"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_props_3",
          "topic": "Default Props",
          "level": "medium",
          "type": "mcq",
          "question": "You have a `Button` component that should display 'Click Me' by default if no `label` prop is provided. Which of the following is the most idiomatic way to achieve this in a modern functional React component?",
          "answer": "Using default parameter values in the functional component's destructuring.",
          "options": [
            "Checking `props.label` and setting a default inside the component's JSX.",
            "Using `Button.defaultProps = { label: 'Click Me' };` after the component definition.",
            "Using default parameter values in the functional component's destructuring.",
            "Implementing a `getDerivedStateFromProps` method to set default state."
          ],
          "analysisPoints": [
            "Option A works but is less concise and idiomatic.",
            "Option B (`defaultProps` static property) is a valid way, traditionally used with class components, and still supported but less common for functional components with ES6 default parameters.",
            "Option C (default parameters) is the most concise and modern way for functional components, leveraging native JavaScript features.",
            "Option D (`getDerivedStateFromProps`) is a class component lifecycle method and is used for specific state derivations, not for default props.",
            "The question specifically asks for the 'most idiomatic way in a *modern functional* React component'."
          ],
          "keyConcepts": [
            "Props",
            "Default Props",
            "Functional Components",
            "ES6 Destructuring"
          ],
          "evaluationCriteria": [
            "Knowledge of modern React practices for default props",
            "Understanding of ES6 features in React context"
          ],
          "example": "```typescript\nimport React from 'react';\n\ninterface ButtonProps {\n  label?: string;\n  onClick?: () => void;\n}\n\nfunction Button({ label = 'Click Me', onClick }: ButtonProps) {\n  return (\n    <button onClick={onClick}>\n      {label}\n    </button>\n  );\n}\n\n// Usage:\n// <Button /> // Displays 'Click Me'\n// <Button label=\"Submit\" /> // Displays 'Submit'\n```\nThis example demonstrates setting a default value for the `label` prop directly in the destructuring of the function parameters. If `label` is `undefined` when `Button` is rendered, it will default to `'Click Me'`. This is clean and leverages standard JavaScript.",
          "tags": [
            "React",
            "Props",
            "Default Props",
            "Functional Components"
          ],
          "prerequisites": [
            "javascript_es6",
            "react_functional_components"
          ],
          "complexity": 5,
          "interviewFrequency": 7,
          "learningPath": "intermediate"
        },
        {
          "id": "question_props_4",
          "topic": "Prop Drilling",
          "level": "medium",
          "type": "flashcard",
          "question": "What is 'prop drilling' in React, and why is it considered an issue?",
          "answer": "'Prop drilling' (or 'props tunneling') is the process of passing data from a parent component down to a deeply nested child component by passing it through intermediate components that don't actually need the data themselves. It's considered an issue because it increases code complexity, makes components less reusable (as they become coupled to specific prop structures they just pass along), and makes debugging harder by obscuring where a prop actually originates or is used.",
          "analysisPoints": [],
          "keyConcepts": [
            "Prop Drilling",
            "Component Communication",
            "Code Maintainability"
          ],
          "evaluationCriteria": [
            "Recall of a common React anti-pattern",
            "Understanding of its negative impacts"
          ],
          "tags": [
            "React",
            "Prop Drilling",
            "Anti-patterns"
          ],
          "prerequisites": [],
          "complexity": 5,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_props_5",
          "topic": "Props vs. Children Prop",
          "level": "hard",
          "type": "open",
          "question": "Explain the difference between passing data via named props (e.g., `<MyComponent data={value} />`) versus using the `children` prop (e.g., `<MyComponent>{value}</MyComponent>`). When would you prefer one over the other?",
          "answer": "Both named props and the `children` prop are ways to pass data or elements to a React component, but they serve different semantic purposes and are preferred in different scenarios.\n\n**Named Props (`<MyComponent data={value} />`):**\n*   **Purpose**: Used for passing discrete pieces of data, configuration options, or callbacks. They are typically key-value pairs.\n*   **Flexibility**: Good for clearly defining specific inputs the component expects.\n*   **Semantics**: Implies that the data is an 'attribute' or 'property' of the component, defining its behavior or content in a structured way.\n*   **Use Cases**: `name`, `age`, `isLoading`, `onClick`, `src`, `href`.\n\n**`children` Prop (`<MyComponent>{value}</MyComponent>`):**\n*   **Purpose**: Represents the content enclosed between the opening and closing tags of a component. It can be a string, number, array of elements, or another component.\n*   **Flexibility**: Extremely flexible, allowing for arbitrary content and complex nested structures within the component's body. The component itself becomes a 'container' or 'wrapper'.\n*   **Semantics**: Implies a parent-child relationship where the inner content is 'owned' or rendered by the component. It's often used for layout components or components that act as containers.\n*   **Use Cases**: Layout components (`<Card><Header /><Body /></Card>`), higher-order components (in a conceptual sense), or simple text content (`<Heading>My Title</Heading>`).\n\n**When to prefer one over the other:**\n*   **Choose Named Props** when the data is a distinct, specific value that describes an attribute or behavior of the component (e.g., a user's name, a toggle's initial state, a callback for an event). It's for when you want to define *how* the component should act or what specific pieces of data it needs.\n*   **Choose `children` Prop** when the component is primarily a container or wrapper, and its main purpose is to render the content passed inside its tags. This is ideal when the content's structure or type is highly variable, or when you want to create a semantic grouping of other elements (e.g., a `Modal` that wraps its entire content, a `Grid` that wraps its `GridItem`s). It's for when you want to define *what* the component contains or renders as its primary output.\n\nIn essence, named props are for *configuration*, while the `children` prop is for *composition*.",
          "analysisPoints": [
            "Clearly defines named props and the `children` prop.",
            "Explains their respective purposes and flexibilities.",
            "Distinguishes their semantic implications.",
            "Provides relevant use cases for each.",
            "Offers clear guidance on when to choose one over the other.",
            "Demonstrates a deep understanding of React's composition model."
          ],
          "keyConcepts": [
            "Props",
            "Children Prop",
            "Component Composition",
            "Component Design",
            "Flexibility",
            "Semantics"
          ],
          "evaluationCriteria": [
            "Advanced understanding of React component design.",
            "Ability to differentiate between similar concepts based on best practices.",
            "Strategic thinking about component API design."
          ],
          "tags": [
            "React",
            "Props",
            "Children",
            "Component Composition",
            "Advanced React"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 8,
          "interviewFrequency": 6,
          "learningPath": "advanced"
        },
        {
          "id": "question_state_1",
          "topic": "State vs. Props Basics",
          "level": "easy",
          "type": "flashcard",
          "question": "What is the fundamental difference between 'props' and 'state' in React?",
          "answer": "Props (properties) are immutable data passed from parent to child, while state is mutable data managed internally by a component and can change over time.",
          "analysisPoints": [],
          "keyConcepts": [
            "Props",
            "State",
            "Immutability",
            "Mutability"
          ],
          "evaluationCriteria": [
            "Recall of basic definitions"
          ],
          "tags": [
            "React",
            "Props",
            "State"
          ],
          "prerequisites": [],
          "complexity": 2,
          "interviewFrequency": 9,
          "learningPath": "beginner"
        },
        {
          "id": "question_state_2",
          "topic": "State Updates and Re-renders",
          "level": "medium",
          "type": "mcq",
          "question": "When a component's state is updated using `useState`'s setter function, what is the immediate consequence in React?",
          "answer": "React schedules a re-render of the component and its children.",
          "options": [
            "The component immediately re-renders synchronously.",
            "React schedules a re-render of the component and its children.",
            "Only the specific part of the DOM affected by the state change is updated.",
            "The component's props are automatically updated from its parent."
          ],
          "analysisPoints": [
            "React's state updates are generally asynchronous and batched for performance, so it doesn't immediately re-render synchronously.",
            "Updating state (`setState` or `useState`'s setter) signals React that the component (and its children) might need to be re-rendered to reflect the new state. React then decides *when* to perform the actual render.",
            "While React's reconciliation process efficiently updates only necessary parts of the *actual* DOM, the *scheduling* consequence of a state update is a re-render of the component within React's virtual DOM.",
            "State updates are internal to the component and don't automatically update props from its parent; props are external data."
          ],
          "keyConcepts": [
            "React State",
            "useState",
            "Re-renders",
            "Asynchronous Updates",
            "Reconciliation"
          ],
          "evaluationCriteria": [
            "Understanding of React's rendering process",
            "Knowledge of state update mechanisms"
          ],
          "example": "When you call `setCount(count + 1)` in a counter component, React doesn't instantaneously update the UI. Instead, it marks the component as 'dirty' and, at an opportune time (often after all synchronous code has run), it will trigger a re-render cycle where it compares the new Virtual DOM tree with the old one and efficiently updates the real DOM.",
          "tags": [
            "React",
            "State",
            "useState",
            "Rendering"
          ],
          "prerequisites": [
            "react_basics"
          ],
          "complexity": 6,
          "interviewFrequency": 8,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_3",
          "topic": "State Immutability Practices",
          "level": "medium",
          "type": "open",
          "question": "When dealing with state that is an object or an array in React, why is it crucial to update it immutably (i.e., create a new object/array instead of modifying the existing one)? Provide a simple code example demonstrating a correct immutable update for an array state.",
          "answer": "It is crucial to update state immutably (by creating a new object or array) for two main reasons:\n\n1.  **React's Change Detection**: React uses a shallow comparison to determine if a component needs to re-render. If you mutate the original state object or array directly, the reference to that object/array remains the same. React's shallow comparison will see the *same reference* and might not detect the change, thus failing to re-render the component and update the UI.\n2.  **Predictability and Debugging**: Immutability makes your application's state more predictable. Each state change results in a new version of the state, making it easier to track changes, debug issues (e.g., with time-travel debuggers), and implement features like undo/redo.\n\n**Correct Immutable Update for an Array State:**\n\n```typescript\nimport React, { useState } from 'react';\n\nfunction TodoList() {\n  const [todos, setTodos] = useState(['Learn React', 'Write Code']);\n\n  const addTodo = (newTodo: string) => {\n    // INCORRECT: Mutates original array, React might not re-render\n    // todos.push(newTodo);\n    // setTodos(todos);\n\n    // CORRECT: Creates a new array using spread operator\n    setTodos([...todos, newTodo]);\n  };\n\n  const removeTodo = (indexToRemove: number) => {\n    // CORRECT: Creates a new array using filter\n    setTodos(todos.filter((_, index) => index !== indexToRemove));\n  };\n\n  return (\n    <div>\n      <ul>\n        {todos.map((todo, index) => (\n          <li key={index}>\n            {todo}\n            <button onClick={() => removeTodo(index)}>x</button>\n          </li>\n        ))}\n      </ul>\n      <button onClick={() => addTodo('Explore Hooks')}>Add 'Explore Hooks'</button>\n    </div>\n  );\n}\n```\n\nIn the `addTodo` example, `[...todos, newTodo]` creates a brand new array with all existing todos plus the new one. Similarly, `todos.filter(...)` returns a new array without the removed item. This ensures React detects the change and triggers a re-render.",
          "analysisPoints": [
            "Explains the two core reasons: React's shallow comparison and predictability.",
            "Provides a clear code example of an array state update.",
            "Demonstrates both adding and removing elements immutably.",
            "Contrasts correct immutable update with incorrect mutable one.",
            "Highlights the use of spread operator and `filter` for immutable array operations."
          ],
          "keyConcepts": [
            "React State",
            "Immutability",
            "Shallow Comparison",
            "Re-renders",
            "Array/Object Updates",
            "Spread Operator",
            "Filter Method"
          ],
          "evaluationCriteria": [
            "Understanding of React's rendering optimization principles.",
            "Practical knowledge of immutable data structures in JavaScript.",
            "Ability to write correct state update logic."
          ],
          "tags": [
            "React",
            "State",
            "Immutability",
            "useState"
          ],
          "prerequisites": [
            "react_basics",
            "javascript_array_methods",
            "javascript_objects"
          ],
          "complexity": 7,
          "interviewFrequency": 9,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_4",
          "topic": "Local vs. Global State",
          "level": "hard",
          "type": "open",
          "question": "When should you prefer managing state locally within a component using `useState` versus using a global state management solution (like React Context API or Redux)? Provide examples for both scenarios.",
          "answer": "The choice between local state (`useState`) and global state management depends on the scope and sharing requirements of the data.\n\n**1. Local State (`useState`):**\n*   **When to Use**: When the state is only relevant to a single component and does not need to be shared with distant components in the component tree (siblings, cousins, or deeply nested children). It's ideal for UI-specific data that doesn't affect other parts of the application or for component-internal logic.\n*   **Examples**: \n    *   A `ToggleButton`'s `isOn` state.\n    *   A `Counter` component's `count`.\n    *   The input value of a single `Form` field.\n    *   A `Modal` component's `isOpen` state.\n    *   `isLoading` state for a component fetching its own data.\n*   **Benefits**: Simple, lightweight, and easy to reason about. Encapsulates concerns within the component.\n\n**2. Global State Management (e.g., React Context API, Redux, Zustand):**\n*   **When to Use**: When state needs to be shared across multiple components that are not directly related (e.g., siblings, deeply nested children in different branches of the tree) or when the state represents application-wide data that affects many parts of the UI.\n*   **Examples**: \n    *   **User authentication status** (e.g., `isLoggedIn`, `currentUser` object) that needs to be accessible by navigation bars, profile pages, and protected routes.\n    *   **Shopping cart data** in an e-commerce application, accessed by product pages, cart summary, and checkout.\n    *   **Theme preferences** (e.g., dark/light mode) applied across the entire application.\n    *   **Application-wide notifications/toasts** that can be triggered from anywhere.\n    *   A **global filter/sort setting** that impacts multiple data displays.\n*   **Benefits**: Centralized data management, avoids prop drilling, easier debugging for shared state, better separation of concerns for application-level data.\n\n**Summary:**\nStart with local state. If a component's state needs to be passed down through many levels (prop drilling occurs), consider lifting state up to a common ancestor. If that ancestor is very high in the tree, or if the state is truly global and needed by many disparate components, then a global state management solution is appropriate.",
          "analysisPoints": [
            "Clearly defines use cases for local state.",
            "Provides concrete examples for local state scenarios.",
            "Clearly defines use cases for global state management.",
            "Provides concrete examples for global state scenarios.",
            "Discusses benefits of each approach.",
            "Offers a guideline for choosing between them (start local, then scale)."
          ],
          "keyConcepts": [
            "React State",
            "useState",
            "Global State Management",
            "React Context",
            "Redux",
            "Prop Drilling",
            "State Lifting",
            "Component Scope"
          ],
          "evaluationCriteria": [
            "Strategic understanding of state management.",
            "Ability to choose appropriate tools based on requirements.",
            "Knowledge of different state patterns in React."
          ],
          "tags": [
            "React",
            "State Management",
            "useState",
            "Context API",
            "Redux"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "react_context_api"
          ],
          "complexity": 8,
          "interviewFrequency": 9,
          "learningPath": "advanced"
        },
        {
          "id": "question_state_5",
          "topic": "`useState` Initial State",
          "level": "easy",
          "type": "mcq",
          "question": "What happens if you provide a function as the initial state argument to `useState`?",
          "answer": "The function will be executed only once during the initial render to compute the initial state.",
          "options": [
            "The function will be executed on every re-render to compute the new state.",
            "The function will be executed only once during the initial render to compute the initial state.",
            "React will treat the function itself as the initial state value.",
            "An error will be thrown because `useState` expects a direct value, not a function."
          ],
          "analysisPoints": [
            "This is a common optimization for `useState`. If the initial state computation is expensive (e.g., reading from local storage, complex calculations), providing a function ensures it's only run once.",
            "If you pass a direct value, it's computed on every render, even if `useState` only uses it on the first.",
            "React distinguishes between a direct value and a function returning a value for initial state.",
            "It's a valid and recommended pattern, not an error."
          ],
          "keyConcepts": [
            "React State",
            "useState",
            "Initial State",
            "Performance Optimization"
          ],
          "evaluationCriteria": [
            "Knowledge of `useState` advanced usage",
            "Understanding of performance considerations"
          ],
          "example": "```typescript\nimport React, { useState } from 'react';\n\nconst heavyInitialComputation = () => {\n  console.log('Running heavy initial computation...');\n  let sum = 0;\n  for (let i = 0; i < 10000000; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\nfunction MyComponent() {\n  // This function only runs once on initial render\n  const [data, setData] = useState(heavyInitialComputation);\n\n  // ... rest of component\n  return <div>Data: {data}</div>;\n}\n```\nIf `heavyInitialComputation()` were passed directly (e.g., `useState(heavyInitialComputation())`), the function would execute on every re-render, even though `useState` only uses the result once. Passing it as a function `useState(heavyInitialComputation)` ensures it's only called on the first render for efficiency.",
          "tags": [
            "React",
            "State",
            "useState",
            "Performance"
          ],
          "prerequisites": [
            "react_hooks_basics"
          ],
          "complexity": 5,
          "interviewFrequency": 6,
          "learningPath": "intermediate"
        },
        {
          "id": "question_state_6",
          "topic": "Batching State Updates",
          "level": "hard",
          "type": "open",
          "question": "Explain React's concept of 'batching' state updates. Why is it important, and how does it relate to the behavior of multiple `setCount` calls in a single event handler (as seen in `question_functional_components_4`) versus calls made within asynchronous operations (e.g., `setTimeout` or `Promise.then`)?",
          "answer": "React's 'batching' is a performance optimization where multiple state updates (e.g., multiple calls to `setState` or `useState` setters) triggered in the same event loop cycle are grouped together into a single re-render. Instead of re-rendering the component immediately after each state update, React waits until all updates within the current event handler or browser event are processed, then performs a single render.\n\n**Importance of Batching:**\n1.  **Performance**: Reduces the number of re-renders, preventing unnecessary computation and DOM manipulations. This leads to a smoother and more responsive UI.\n2.  **Consistency**: Ensures that your UI reflects the final state after a series of updates, rather than flickering through intermediate states.\n\n**Batching in Event Handlers vs. Asynchronous Operations:**\n\n*   **Synchronous Event Handlers (e.g., `onClick`, `onChange`):**\n    *   **Behavior**: React **batches** updates. If you call `setCount(count + 1)` three times within a single `onClick` handler, React sees all three calls, but because they occur within the same synchronous event, it performs a single re-render at the end. However, each `setCount(count + 1)` call in this scenario uses the `count` value from the *initial render's closure* (the `count` value when the event handler was defined, or when the component last rendered). This is why if `count` is `0`, all three calls calculate `0 + 1`, and the final `count` becomes `1` (the last update wins, or rather, all resolve to the same value).\n    *   **Solution for Sequential Updates**: To ensure each update uses the *latest* state, you must use **functional updates** (e.g., `setCount(prevCount => prevCount + 1)`). This ensures the `prevCount` argument inside the updater function is always the most recent state value.\n\n*   **Asynchronous Operations (e.g., `setTimeout`, `Promise.then`, native DOM event handlers):**\n    *   **Behavior (Pre-React 18)**: Historically, React did *not* batch updates originating from asynchronous code or outside of React's own event system. Each `setCount` call in a `setTimeout` would trigger a separate re-render, leading to multiple, potentially inefficient, renders.\n    *   **Behavior (React 18+ / Automatic Batching)**: React 18 introduced **automatic batching** for all state updates, regardless of where they originate (event handlers, `setTimeout`, promises, etc.). Now, multiple `setCount` calls within *any* context will be batched into a single re-render by default. This makes the behavior more consistent and predictable.\n\n    *   **Example (React 18+):**\n        ```typescript\n        function MyComponent() {\n          const [countA, setCountA] = useState(0);\n          const [countB, setCountB] = useState(0);\n\n          const handleClick = () => {\n            setTimeout(() => {\n              setCountA(countA + 1); // Uses stale `countA` if not functional update\n              setCountB(countB + 1); // Uses stale `countB` if not functional update\n              // Both updates are batched into one re-render in React 18+\n            }, 0);\n          };\n\n          return <button onClick={handleClick}>Update Counts</button>;\n        }\n        ```\n        Even with automatic batching, using functional updates (`setCountA(prev => prev + 1)`) is still crucial for correctness when a new state depends on the previous state, especially with stale closures in asynchronous contexts.",
          "analysisPoints": [
            "Defines batching and its purpose (performance, consistency).",
            "Explains batching behavior in synchronous event handlers, including the issue of stale closures with direct values.",
            "Explains the solution for synchronous updates (functional updates).",
            "Discusses the historical (pre-React 18) and current (React 18+ automatic batching) behavior for asynchronous updates.",
            "Reinforces that functional updates are still important for correctness even with automatic batching.",
            "Demonstrates a deep understanding of React's internal rendering mechanisms."
          ],
          "keyConcepts": [
            "React State",
            "Batching",
            "Performance Optimization",
            "Asynchronous Updates",
            "Stale Closures",
            "Functional Updates",
            "React 18"
          ],
          "evaluationCriteria": [
            "Expert-level understanding of React rendering and state management.",
            "Knowledge of React versions and their impact on features.",
            "Ability to explain complex interactions between concepts."
          ],
          "tags": [
            "React",
            "State",
            "Batching",
            "Performance",
            "Hooks",
            "Advanced React"
          ],
          "prerequisites": [
            "react_hooks_basics",
            "javascript_asynchronicity"
          ],
          "complexity": 9,
          "interviewFrequency": 7,
          "learningPath": "expert"
        }
      ],
      "tasks": [
        {
          "id": "task_compound_components_1",
          "title": "Build a Custom Accordion Compound Component",
          "description": "\nImplement a flexible `Accordion` compound component that can manage the open/closed state of multiple accordion items. The component should allow consumers to define the structure using sub-components.\n\n**Requirements:**\n1.  Create a main `Accordion` component.\n2.  Create sub-components: `Accordion.Item`, `Accordion.Header`, `Accordion.Panel`.\n3.  The `Accordion` component should manage the `activeItem` state (the ID of the currently open item, or `null` if none). It should support only one item being open at a time (like a standard accordion).\n4.  `Accordion.Header` should toggle the `Accordion.Panel` associated with its `Accordion.Item` when clicked. It should also indicate if its parent `Accordion.Item` is active (e.g., by changing text or adding a style).\n5.  `Accordion.Panel` should only be visible if its associated `Accordion.Item` is active.\n6.  Use React Context API for state sharing between `Accordion` and its sub-components.\n7.  Each `Accordion.Item` must have a unique `id` prop.\n\n**Example Usage:**\n```typescript\nfunction App() {\n  return (\n    <Accordion>\n      <Accordion.Item id=\"item-1\">\n        <Accordion.Header>Section 1</Accordion.Header>\n        <Accordion.Panel>\n          <p>Content for section 1.</p>\n        </Accordion.Panel>\n      </Accordion.Item>\n      <Accordion.Item id=\"item-2\">\n        <Accordion.Header>Section 2</Accordion.Header>\n        <Accordion.Panel>\n          <p>Content for section 2.</p>\n        </Accordion.Panel>\n      </Accordion.Item>\n    </Accordion>\n  );\n}\n```\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, createContext, useContext } from 'react';\n\n// 1. Define AccordionContext and useAccordionContext hook\ninterface AccordionContextType {\n  activeItem: string | null;\n  setActiveItem: (id: string | null) => void;\n  // Add any other shared state/functions here\n}\n\nconst AccordionContext = createContext<AccordionContextType | undefined>(undefined);\n\nfunction useAccordionContext() {\n  const context = useContext(AccordionContext);\n  if (context === undefined) {\n    throw new Error('useAccordionContext must be used within an AccordionProvider');\n  }\n  return context;\n}\n\n// 2. Implement the main Accordion component\nexport function Accordion({ children }: { children: React.ReactNode }) {\n  const [activeItem, setActiveItem] = useState<string | null>(null);\n\n  const contextValue: AccordionContextType = {\n    activeItem,\n    setActiveItem,\n  };\n\n  return (\n    <AccordionContext.Provider value={contextValue}>\n      <div className=\"accordion-container\">\n        {children}\n      </div>\n    </AccordionContext.Provider>\n  );\n}\n\n// 3. Implement Accordion.Item component\n//    This component needs to make its own ID available to its children\n//    Consider creating an inner context for the Item if Header/Panel need the ID.\n\n// Inner context for each Accordion.Item to pass its ID down\ninterface AccordionItemContextType {\n  id: string;\n}\nconst AccordionItemContext = createContext<AccordionItemContextType | undefined>(undefined);\n\nfunction useAccordionItemContext() {\n  const context = useContext(AccordionItemContext);\n  if (context === undefined) {\n    throw new Error('useAccordionItemContext must be used within an Accordion.Item');\n  }\n  return context;\n}\n\nAccordion.Item = function AccordionItem({ id, children }: { id: string; children: React.ReactNode }) {\n  // Implement logic to wrap children with AccordionItemContext.Provider\n  const { activeItem } = useAccordionContext(); // Access main accordion state to determine if this item is active\n  const isActive = activeItem === id;\n\n  const itemContextValue = { id };\n\n  return (\n    <AccordionItemContext.Provider value={itemContextValue}>\n      <div className={`accordion-item ${isActive ? 'active' : ''}`}>\n        {children}\n      </div>\n    </AccordionItemContext.Provider>\n  );\n};\n\n// 4. Implement Accordion.Header component\nAccordion.Header = function AccordionHeader({ children }: { children: React.ReactNode }) {\n  const { id } = useAccordionItemContext(); // Get item ID from item context\n  const { activeItem, setActiveItem } = useAccordionContext(); // Get main accordion state\n\n  const handleClick = () => {\n    // Toggle logic: If this item is active, close it (set activeItem to null).\n    // Otherwise, open this item (set activeItem to its id).\n    setActiveItem(activeItem === id ? null : id);\n  };\n\n  const isActive = activeItem === id;\n\n  return (\n    <div\n      className={`accordion-header ${isActive ? 'active' : ''}`}\n      onClick={handleClick}\n      style={{ cursor: 'pointer', padding: '10px', border: '1px solid #ccc', margin: '5px 0' }}\n    >\n      {children} {isActive ? '(Open)' : '(Closed)'}\n    </div>\n  );\n};\n\n// 5. Implement Accordion.Panel component\nAccordion.Panel = function AccordionPanel({ children }: { children: React.ReactNode }) {\n  const { id } = useAccordionItemContext(); // Get item ID from item context\n  const { activeItem } = useAccordionContext(); // Get main accordion state\n\n  const isActive = activeItem === id;\n\n  return isActive ? (\n    <div className=\"accordion-panel\" style={{ padding: '10px', border: '1px solid #eee' }}>\n      {children}\n    </div>\n  ) : null;\n};\n",
          "solutionCode": "import React, { useState, createContext, useContext } from 'react';\n\n// 1. Define AccordionContext and useAccordionContext hook\ninterface AccordionContextType {\n  activeItem: string | null;\n  setActiveItem: (id: string | null) => void;\n}\n\nconst AccordionContext = createContext<AccordionContextType | undefined>(undefined);\n\nfunction useAccordionContext() {\n  const context = useContext(AccordionContext);\n  if (context === undefined) {\n    throw new Error('useAccordionContext must be used within an AccordionProvider');\n  }\n  return context;\n}\n\n// Inner context for each Accordion.Item to pass its ID down\ninterface AccordionItemContextType {\n  id: string;\n}\nconst AccordionItemContext = createContext<AccordionItemContextType | undefined>(undefined);\n\nfunction useAccordionItemContext() {\n  const context = useContext(AccordionItemContext);\n  if (context === undefined) {\n    throw new Error('useAccordionItemContext must be used within an Accordion.Item');\n  }\n  return context;\n}\n\n// 2. Implement the main Accordion component\nexport function Accordion({ children }: { children: React.ReactNode }) {\n  const [activeItem, setActiveItem] = useState<string | null>(null);\n\n  const contextValue: AccordionContextType = {\n    activeItem,\n    setActiveItem,\n  };\n\n  return (\n    <AccordionContext.Provider value={contextValue}>\n      <div className=\"accordion-container\">\n        {children}\n      </div>\n    </AccordionContext.Provider>\n  );\n}\n\n// 3. Implement Accordion.Item component\nAccordion.Item = function AccordionItem({ id, children }: { id: string; children: React.ReactNode }) {\n  // activeItem and isActive check is done in Header and Panel\n  const itemContextValue = { id };\n\n  return (\n    <AccordionItemContext.Provider value={itemContextValue}>\n      <div className=\"accordion-item\">\n        {children}\n      </div>\n    </AccordionItemContext.Provider>\n  );\n};\n\n// 4. Implement Accordion.Header component\nAccordion.Header = function AccordionHeader({ children }: { children: React.ReactNode }) {\n  const { id } = useAccordionItemContext(); // Get item ID from item context\n  const { activeItem, setActiveItem } = useAccordionContext(); // Get main accordion state\n\n  const handleClick = () => {\n    // Toggle logic: If this item is active, close it (set activeItem to null).\n    // Otherwise, open this item (set activeItem to its id).\n    setActiveItem(activeItem === id ? null : id);\n  };\n\n  const isActive = activeItem === id;\n\n  return (\n    <div\n      className={`accordion-header ${isActive ? 'active' : ''}`}\n      onClick={handleClick}\n      style={{ cursor: 'pointer', padding: '10px', border: '1px solid #ccc', margin: '5px 0', background: isActive ? '#f0f0f0' : 'white' }}\n    >\n      {children} {isActive ? '' : ''}\n    </div>\n  );\n};\n\n// 5. Implement Accordion.Panel component\nAccordion.Panel = function AccordionPanel({ children }: { children: React.ReactNode }) {\n  const { id } = useAccordionItemContext(); // Get item ID from item context\n  const { activeItem } = useAccordionContext(); // Get main accordion state\n\n  const isActive = activeItem === id;\n\n  return isActive ? (\n    <div className=\"accordion-panel\" style={{ padding: '10px', border: '1px solid #eee', borderTop: 'none' }}>\n      {children}\n    </div>\n  ) : null;\n};\n",
          "testCases": [
            "Render Accordion with two items: Only the first item should be collapsed by default.",
            "Clicking Header 1: Panel 1 should open. Clicking Header 1 again should close Panel 1.",
            "Clicking Header 1, then Header 2: Panel 1 should close, Panel 2 should open.",
            "Render with items having different content: Verify correct content is displayed when panel is active.",
            "Test with no items: Should render gracefully without errors.",
            "Test with only one item: Should function correctly (open/close)."
          ],
          "hints": [
            "Remember to create a separate context for the `Accordion.Item` to pass its `id` down to `Header` and `Panel`.",
            "The `activeItem` state in the main `Accordion` component should store the `id` of the currently open item.",
            "The `Header` component will be responsible for updating the `activeItem` in the main `Accordion` context when clicked.",
            "The `Panel` component should conditionally render its children based on whether its `id` matches the `activeItem` from the main `Accordion` context."
          ],
          "tags": [
            "React",
            "Compound Components",
            "Context API",
            "Hooks",
            "UI Components"
          ],
          "timeEstimate": 60,
          "prerequisites": [
            "react_context_api",
            "react_hooks_basics"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Component Composition",
            "State Management",
            "Implicit State Sharing"
          ]
        },
        {
          "id": "task_functional_components_1",
          "title": "Create a Searchable Data Table with Debouncing",
          "description": "\nImplement a functional React component called `SearchableTable` that displays a list of users, allowing users to filter the list by a search query. The search functionality should be debounced to optimize performance.\n\n**Requirements:**\n1.  **`SearchableTable` Component**: This component should:\n    *   Take an initial `data` prop (an array of user objects: `{ id: number, name: string, email: string }`).\n    *   Display a search input field.\n    *   Display the filtered user data in a simple HTML table.\n2.  **Search Logic**: \n    *   Filter users by `name` or `email` based on the search query.\n    *   Case-insensitive matching.\n3.  **Debouncing**: \n    *   The actual filtering operation (which can be a heavy computation for large datasets) should only run after the user stops typing for a specific duration (e.g., 300ms).\n    *   Implement this debouncing using `useEffect` and `useState`.\n4.  **Loading State**: Display a 'Searching...' message while the debounced search is active.\n\n**User Data Example:**\n```typescript\nconst initialUsers = [\n  { id: 1, name: 'Alice Smith', email: 'alice@example.com' },\n  { id: 2, name: 'Bob Johnson', email: 'bob@example.com' },\n  { id: 3, name: 'Charlie Brown', email: 'charlie@example.com' },\n  { id: 4, name: 'David Lee', email: 'david@example.com' },\n  { id: 5, name: 'Eve Davis', email: 'eve@example.com' },\n];\n```\n",
          "difficulty": "hard",
          "startingCode": "import React, { useState, useEffect } from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface SearchableTableProps {\n  data: User[];\n}\n\nconst initialUsers: User[] = [\n  { id: 1, name: 'Alice Smith', email: 'alice@example.com' },\n  { id: 2, name: 'Bob Johnson', email: 'bob@example.com' },\n  { id: 3, name: 'Charlie Brown', email: 'charlie@example.com' },\n  { id: 4, name: 'David Lee', email: 'david@example.com' },\n  { id: 5, name: 'Eve Davis', email: 'eve@example.com' },\n  { id: 6, name: 'Frank White', email: 'frank@example.com' },\n  { id: 7, name: 'Grace Green', email: 'grace@example.com' },\n  { id: 8, name: 'Harry Black', email: 'harry@example.com' },\n  { id: 9, name: 'Ivy Blue', email: 'ivy@example.com' },\n  { id: 10, name: 'Jack Red', email: 'jack@example.com' },\n];\n\nexport function SearchableTable({ data }: SearchableTableProps) {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState('');\n  const [isSearching, setIsSearching] = useState(false);\n  const [filteredData, setFilteredData] = useState<User[]>(data);\n\n  // TODO: Implement debouncing logic using useEffect\n  // Hint: A useEffect can be used to update debouncedSearchTerm after a delay.\n  // Hint: Another useEffect can be used to filter data based on debouncedSearchTerm.\n\n  // Effect for debouncing searchTerm\n  useEffect(() => {\n    // Set a timer to update debouncedSearchTerm\n    // Clear the previous timer if searchTerm changes before the delay\n    // Set isSearching to true when searchTerm changes, and false after debouncedSearchTerm updates\n  }, [searchTerm]);\n\n  // Effect for filtering data based on debouncedSearchTerm\n  useEffect(() => {\n    // Perform the filtering logic here\n    // Update filteredData state\n    // Set isSearching to false once filtering is complete\n  }, [debouncedSearchTerm, data]); // data is a dependency because the original data might change\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Search by name or email...\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        style={{ width: '300px', padding: '8px', marginBottom: '15px' }}\n      />\n      {isSearching && <p>Searching...</p>}\n      <table style={{ width: '100%', borderCollapse: 'collapse' }}>\n        <thead>\n          <tr style={{ background: '#f2f2f2' }}>\n            <th style={{ border: '1px solid #ddd', padding: '8px', textAlign: 'left' }}>ID</th>\n            <th style={{ border: '1px solid #ddd', padding: '8px', textAlign: 'left' }}>Name</th>\n            <th style={{ border: '1px solid #ddd', padding: '8px', textAlign: 'left' }}>Email</th>\n          </tr>\n        </thead>\n        <tbody>\n          {filteredData.length === 0 && !isSearching ? (\n            <tr>\n              <td colSpan={3} style={{ textAlign: 'center', padding: '10px' }}>No users found.</td>\n            </tr>\n          ) : (\n            filteredData.map(user => (\n              <tr key={user.id}>\n                <td style={{ border: '1px solid #ddd', padding: '8px' }}>{user.id}</td>\n                <td style={{ border: '1px solid #ddd', padding: '8px' }}>{user.name}</td>\n                <td style={{ border: '1px solid #ddd', padding: '8px' }}>{user.email}</td>\n              </tr>\n            ))\n          )}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\n// Usage in App.tsx (for testing):\n// function App() {\n//   return <SearchableTable data={initialUsers} />;\n// }\n",
          "solutionCode": "import React, { useState, useEffect } from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface SearchableTableProps {\n  data: User[];\n}\n\nconst initialUsers: User[] = [\n  { id: 1, name: 'Alice Smith', email: 'alice@example.com' },\n  { id: 2, name: 'Bob Johnson', email: 'bob@example.com' },\n  { id: 3, name: 'Charlie Brown', email: 'charlie@example.com' },\n  { id: 4, name: 'David Lee', email: 'david@example.com' },\n  { id: 5, name: 'Eve Davis', email: 'eve@example.com' },\n  { id: 6, name: 'Frank White', email: 'frank@example.com' },\n  { id: 7, name: 'Grace Green', email: 'grace@example.com' },\n  { id: 8, name: 'Harry Black', email: 'harry@example.com' },\n  { id: 9, name: 'Ivy Blue', email: 'ivy@example.com' },\n  { id: 10, name: 'Jack Red', email: 'jack@example.com' },\n];\n\nconst DEBOUNCE_DELAY = 300; // milliseconds\n\nexport function SearchableTable({ data }: SearchableTableProps) {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState('');\n  const [isSearching, setIsSearching] = useState(false);\n  const [filteredData, setFilteredData] = useState<User[]>(data);\n\n  // Effect for debouncing searchTerm\n  useEffect(() => {\n    if (searchTerm !== '') {\n        setIsSearching(true); // Indicate searching as soon as input changes\n    }\n\n    const handler = setTimeout(() => {\n      setDebouncedSearchTerm(searchTerm);\n    }, DEBOUNCE_DELAY);\n\n    // Cleanup function to clear the timeout if searchTerm changes before delay\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [searchTerm]);\n\n  // Effect for filtering data based on debouncedSearchTerm\n  useEffect(() => {\n    const lowercasedDebouncedTerm = debouncedSearchTerm.toLowerCase();\n    const newFilteredData = data.filter(user =>\n      user.name.toLowerCase().includes(lowercasedDebouncedTerm) ||\n      user.email.toLowerCase().includes(lowercasedDebouncedTerm)\n    );\n    setFilteredData(newFilteredData);\n    setIsSearching(false); // Filtering complete\n  }, [debouncedSearchTerm, data]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Search by name or email...\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        style={{ width: '300px', padding: '8px', marginBottom: '15px' }}\n      />\n      {isSearching && <p>Searching...</p>}\n      <table style={{ width: '100%', borderCollapse: 'collapse' }}>\n        <thead>\n          <tr style={{ background: '#f2f2f2' }}>\n            <th style={{ border: '1px solid #ddd', padding: '8px', textAlign: 'left' }}>ID</th>\n            <th style={{ border: '1px solid #ddd', padding: '8px', textAlign: 'left' }}>Name</th>\n            <th style={{ border: '1px solid #ddd', padding: '8px', textAlign: 'left' }}>Email</th>\n          </tr>\n        </thead>\n        <tbody>\n          {filteredData.length === 0 && !isSearching && debouncedSearchTerm !== '' ? (\n            <tr>\n              <td colSpan={3} style={{ textAlign: 'center', padding: '10px' }}>No users found for \"{debouncedSearchTerm}\".</td>\n            </tr>\n          ) : filteredData.length === 0 && debouncedSearchTerm === '' ? (\n            <tr>\n              <td colSpan={3} style={{ textAlign: 'center', padding: '10px' }}>Start typing to search users.</td>\n            </tr>\n          ) : (\n            filteredData.map(user => (\n              <tr key={user.id}>\n                <td style={{ border: '1px solid #ddd', padding: '8px' }}>{user.id}</td>\n                <td style={{ border: '1px solid #ddd', padding: '8px' }}>{user.name}</td>\n                <td style={{ border: '1px solid #ddd', padding: '8px' }}>{user.email}</td>\n              </tr>\n            ))\n          )}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: Table should display all users, 'Searching...' should not be visible.",
            "Type 'a' rapidly: 'Searching...' should appear. After 300ms pause, results for 'a' (Alice, Charlie, David, Grace, Harry, Jack) should appear. 'Searching...' should disappear.",
            "Type 'al': 'Searching...' should appear. After 300ms pause, results for 'al' (Alice) should appear.",
            "Type a non-matching query (e.g., 'xyz'): 'Searching...' should appear. After 300ms pause, 'No users found.' should appear.",
            "Clear input: Table should revert to showing all users. 'Searching...' should not be visible.",
            "Rapid typing and then clearing: Ensure no stale search results appear after clearing.",
            "Input change followed by immediate component unmount: Ensure `setTimeout` is cleared to prevent memory leaks."
          ],
          "hints": [
            "You'll need two `useEffect` hooks. One to manage the debounced search term and another to perform the actual filtering.",
            "The first `useEffect` (for debouncing) should have `searchTerm` in its dependency array and use `setTimeout` with a cleanup function (`clearTimeout`).",
            "The second `useEffect` (for filtering) should have `debouncedSearchTerm` and `data` in its dependency array.",
            "Manage the `isSearching` state carefully: set it to `true` when `searchTerm` changes, and `false` after `debouncedSearchTerm` is updated (i.e., after filtering completes)."
          ],
          "tags": [
            "React",
            "Hooks",
            "useState",
            "useEffect",
            "Debouncing",
            "Performance",
            "Frontend Logic"
          ],
          "timeEstimate": 75,
          "prerequisites": [
            "react_functional_components",
            "javascript_timers",
            "javascript_array_methods"
          ],
          "complexity": 8,
          "interviewRelevance": 9,
          "learningPath": "advanced",
          "relatedConcepts": [
            "Side Effects",
            "State Management",
            "Performance Optimization",
            "User Experience"
          ]
        },
        {
          "id": "task_props_1",
          "title": "Build a Flexible Card Component with Props",
          "description": "\nCreate a `Card` functional component in React that is highly configurable through its props. The component should display content dynamically based on the props it receives.\n\n**Requirements:**\n1.  The `Card` component should accept the following props:\n    *   `title: string` (required): The main title of the card.\n    *   `description: string` (required): A brief description for the card.\n    *   `imageUrl?: string` (optional): URL for an image to display at the top of the card.\n    *   `buttonText?: string` (optional): Text for a call-to-action button. If not provided, no button should be rendered.\n    *   `onButtonClick?: () => void` (optional): A callback function to be executed when the button is clicked.\n    *   `children?: React.ReactNode` (optional): Allows passing arbitrary JSX content to be rendered at the bottom of the card content area, below the description and button.\n2.  Implement conditional rendering for the image, button, and children prop.\n3.  Ensure default text for the button, if provided, is 'Learn More' when `buttonText` is an empty string or just whitespace.\n4.  Style the card minimally to make its structure clear (e.g., border, padding).\n\n**Example Usage:**\n```typescript\nfunction App() {\n  return (\n    <div>\n      <Card\n        title=\"Welcome to Our Service\"\n        description=\"Discover amazing features and services offered to you.\"\n        imageUrl=\"https://via.placeholder.com/150\"\n        buttonText=\"Explore Now\"\n        onButtonClick={() => alert('Exploring!')}\n      />\n\n      <Card\n        title=\"About Us\"\n        description=\"Learn more about our mission and values.\"\n      >\n        <p>This is additional content from the children prop!</p>\n        <p>You can put anything here.</p>\n      </Card>\n\n      <Card\n        title=\"Simple Card\"\n        description=\"No image, no button, just content.\"\n      />\n    </div>\n  );\n}\n```\n",
          "difficulty": "medium",
          "startingCode": "import React from 'react';\n\ninterface CardProps {\n  title: string;\n  description: string;\n  imageUrl?: string;\n  buttonText?: string;\n  onButtonClick?: () => void;\n  children?: React.ReactNode;\n}\n\nexport function Card({\n  title,\n  description,\n  imageUrl,\n  buttonText,\n  onButtonClick,\n  children,\n}: CardProps) {\n  // TODO: Implement conditional rendering for imageUrl, button, and children\n  // TODO: Handle default buttonText to 'Learn More' if provided but empty/whitespace\n\n  const displayButtonText = (buttonText && buttonText.trim() !== '') ? buttonText : 'Learn More';\n\n  return (\n    <div style={{\n      border: '1px solid #ddd',\n      borderRadius: '8px',\n      padding: '20px',\n      margin: '10px',\n      maxWidth: '300px',\n      boxShadow: '0 2px 4px rgba(0,0,0,0.1)'\n    }}>\n      {/* Image rendering */}\n      {imageUrl && <img src={imageUrl} alt={title} style={{ width: '100%', height: '150px', objectFit: 'cover', borderRadius: '4px' }} />}\n      \n      <h3 style={{ margin: '15px 0 10px 0' }}>{title}</h3>\n      <p style={{ fontSize: '0.9em', color: '#555', marginBottom: '15px' }}>{description}</p>\n      \n      {/* Button rendering */}\n      {(buttonText || onButtonClick) && (\n        <button\n          onClick={onButtonClick}\n          style={{\n            padding: '10px 15px',\n            backgroundColor: '#007bff',\n            color: 'white',\n            border: 'none',\n            borderRadius: '5px',\n            cursor: 'pointer',\n            marginBottom: '15px'\n          }}\n        >\n          {displayButtonText}\n        </button>\n      )}\n\n      {/* Children rendering */}\n      {children && (\n        <div style={{ marginTop: '15px', borderTop: '1px dashed #eee', paddingTop: '15px' }}>\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}\n",
          "solutionCode": "import React from 'react';\n\ninterface CardProps {\n  title: string;\n  description: string;\n  imageUrl?: string;\n  buttonText?: string;\n  onButtonClick?: () => void;\n  children?: React.ReactNode;\n}\n\nexport function Card({\n  title,\n  description,\n  imageUrl,\n  buttonText,\n  onButtonClick,\n  children,\n}: CardProps) {\n  // Determine button display text, defaulting to 'Learn More' if buttonText is provided but empty/whitespace\n  const finalButtonText = (buttonText !== undefined && buttonText.trim() !== '') ? buttonText : 'Learn More';\n\n  // Determine if the button should be rendered at all\n  const shouldRenderButton = (buttonText !== undefined || onButtonClick !== undefined);\n\n  return (\n    <div style={{\n      border: '1px solid #ddd',\n      borderRadius: '8px',\n      padding: '20px',\n      margin: '10px',\n      maxWidth: '300px',\n      boxShadow: '0 2px 4px rgba(0,0,0,0.1)'\n    }}>\n      {imageUrl && (\n        <img src={imageUrl} alt={title} style={{ width: '100%', height: '150px', objectFit: 'cover', borderRadius: '4px' }} />\n      )}\n      \n      <h3 style={{ margin: '15px 0 10px 0' }}>{title}</h3>\n      <p style={{ fontSize: '0.9em', color: '#555', marginBottom: '15px' }}>{description}</p>\n      \n      {shouldRenderButton && (\n        <button\n          onClick={onButtonClick} // onClick will be undefined if no handler provided, which is fine\n          style={{\n            padding: '10px 15px',\n            backgroundColor: '#007bff',\n            color: 'white',\n            border: 'none',\n            borderRadius: '5px',\n            cursor: 'pointer',\n            marginBottom: '15px'\n          }}\n        >\n          {finalButtonText}\n        </button>\n      )}\n\n      {children && (\n        <div style={{ marginTop: '15px', borderTop: '1px dashed #eee', paddingTop: '15px' }}>\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}\n",
          "testCases": [
            "Card with `title`, `description`, `imageUrl`, `buttonText`, `onButtonClick`: All elements should render correctly and button should be clickable.",
            "Card with `title`, `description`, no `imageUrl`, no `buttonText`, no `onButtonClick`: Only title and description should render.",
            "Card with `title`, `description`, and `children` prop: Title, description, and children content should render.",
            "Card with `buttonText` as empty string `\"\"`: Button should render with 'Learn More' text.",
            "Card with `buttonText` as `\"   \"` (whitespace only): Button should render with 'Learn More' text.",
            "Card with `buttonText=\"Submit\"` but no `onButtonClick`: Button should render with 'Submit' text but be non-functional (or log a warning if clicked)."
          ],
          "hints": [
            "Use logical AND (`&&`) for conditional rendering of JSX elements (e.g., `imageUrl && <img ... />`).",
            "For the button, consider a boolean variable `shouldRenderButton` that combines the checks for `buttonText` and `onButtonClick` existence.",
            "For `buttonText` default, check if it's `undefined` or if its `.trim()` length is `0`."
          ],
          "tags": [
            "React",
            "Props",
            "Conditional Rendering",
            "Component Design",
            "Flexibility"
          ],
          "timeEstimate": 45,
          "prerequisites": [
            "react_functional_components",
            "javascript_conditional_logic"
          ],
          "complexity": 6,
          "interviewRelevance": 8,
          "learningPath": "intermediate",
          "relatedConcepts": [
            "Component Reusability",
            "Children Prop"
          ]
        },
        {
          "id": "task_state_1",
          "title": "Implement a Collapsible Panel Component",
          "description": "\nCreate a `CollapsiblePanel` functional component that manages its own open/closed state. The panel should display a header and a content area that can be toggled visible/hidden.\n\n**Requirements:**\n1.  The component should be named `CollapsiblePanel`.\n2.  It should accept `title: string` for the header and `children: React.ReactNode` for the content.\n3.  Use the `useState` hook to manage the `isOpen` (boolean) state, determining whether the panel's content is visible.\n4.  The header should be clickable and toggle the `isOpen` state.\n5.  The header should visually indicate the panel's state (e.g., by changing a symbol like '' for closed and '' for open).\n6.  The content area should only be rendered when `isOpen` is `true`.\n7.  Apply minimal inline styles for clarity (border, padding, pointer cursor for header).\n\n**Example Usage:**\n```typescript\nfunction App() {\n  return (\n    <CollapsiblePanel title=\"My First Section\">\n      <p>This is the content of the first collapsible section.</p>\n      <ul>\n        <li>Item 1</li>\n        <li>Item 2</li>\n      </ul>\n    </CollapsiblePanel>\n  );\n}\n```\n",
          "difficulty": "easy",
          "startingCode": "import React, { useState } from 'react';\n\ninterface CollapsiblePanelProps {\n  title: string;\n  children: React.ReactNode;\n}\n\nexport function CollapsiblePanel({ title, children }: CollapsiblePanelProps) {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const togglePanel = () => {\n    // TODO: Implement toggle logic for isOpen state\n  };\n\n  const indicator = isOpen ? '' : '';\n\n  return (\n    <div style={{\n      border: '1px solid #ccc',\n      borderRadius: '4px',\n      margin: '10px 0',\n      width: '300px'\n    }}>\n      <div\n        onClick={togglePanel}\n        style={{\n          padding: '10px',\n          backgroundColor: '#f0f0f0',\n          cursor: 'pointer',\n          fontWeight: 'bold',\n          display: 'flex',\n          justifyContent: 'space-between',\n          alignItems: 'center'\n        }}\n      >\n        {title} <span>{indicator}</span>\n      </div>\n      {/* TODO: Conditionally render children based on isOpen */}\n      {isOpen && (\n        <div style={{ padding: '10px', borderTop: '1px solid #eee' }}>\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}\n",
          "solutionCode": "import React, { useState } from 'react';\n\ninterface CollapsiblePanelProps {\n  title: string;\n  children: React.ReactNode;\n}\n\nexport function CollapsiblePanel({ title, children }: CollapsiblePanelProps) {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const togglePanel = () => {\n    setIsOpen(prevIsOpen => !prevIsOpen); // Toggles the boolean state\n  };\n\n  const indicator = isOpen ? '' : '';\n\n  return (\n    <div style={{\n      border: '1px solid #ccc',\n      borderRadius: '4px',\n      margin: '10px 0',\n      width: '300px'\n    }}>\n      <div\n        onClick={togglePanel}\n        style={{\n          padding: '10px',\n          backgroundColor: '#f0f0f0',\n          cursor: 'pointer',\n          fontWeight: 'bold',\n          display: 'flex',\n          justifyContent: 'space-between',\n          alignItems: 'center'\n        }}\n      >\n        {title} <span>{indicator}</span>\n      </div>\n      {isOpen && (\n        <div style={{ padding: '10px', borderTop: '1px solid #eee' }}>\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}\n",
          "testCases": [
            "Initial render: Panel content should be hidden, header should show ''.",
            "Click header: Panel content should become visible, header should show ''.",
            "Click header again: Panel content should be hidden, header should show ''.",
            "Render with different titles and children: Verify content and title are correctly displayed when open."
          ],
          "hints": [
            "Use `useState` with a boolean initial value (e.g., `false` for closed).",
            "The `togglePanel` function should use the functional update form of `setIsOpen` (`prevIsOpen => !prevIsOpen`) to ensure correct toggling, especially if updates are batched.",
            "Conditional rendering for the `children` can be achieved using a simple logical AND (`&&`) operator (`isOpen && <div...> {children} </div>`)."
          ],
          "tags": [
            "React",
            "State",
            "useState",
            "Conditional Rendering",
            "UI Components"
          ],
          "timeEstimate": 30,
          "prerequisites": [
            "react_functional_components",
            "react_hooks_basics"
          ],
          "complexity": 5,
          "interviewRelevance": 7,
          "learningPath": "beginner",
          "relatedConcepts": [
            "Component Reusability",
            "User Interface"
          ]
        }
      ]
    }
  }
]